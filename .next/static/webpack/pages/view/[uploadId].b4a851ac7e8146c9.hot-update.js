"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/IDMLUtils.js":
/*!********************************!*\
  !*** ./lib/utils/IDMLUtils.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"?82df\");\nclass IDMLUtils {\n    static parseGeometricBounds(boundsString) {\n        console.log(\"DEBUG: boundsString =\", boundsString);\n        if (!boundsString || boundsString === \"undefined\") {\n            console.log(\"Warning: Missing geometric bounds, using defaults\");\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n        const bounds = boundsString.split(\" \").map(parseFloat);\n        const result = {\n            top: bounds[0] || 0,\n            left: bounds[1] || 0,\n            bottom: bounds[2] || 0,\n            right: bounds[3] || 0,\n            width: (bounds[3] || 0) - (bounds[1] || 0),\n            height: (bounds[2] || 0) - (bounds[0] || 0)\n        };\n        console.log(\"Parsed bounds:\", result);\n        return result;\n    }\n    static parseTransform(transformString) {\n        if (!transformString) return {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            tx: 0,\n            ty: 0\n        };\n        const values = transformString.split(\" \").map(parseFloat);\n        return {\n            a: values[0] || 1,\n            b: values[1] || 0,\n            c: values[2] || 0,\n            d: values[3] || 1,\n            tx: values[4] || 0,\n            ty: values[5] || 0\n        };\n    }\n    static calculateRotation(transform) {\n        // Calculate rotation angle from transform matrix\n        return Math.atan2(transform.b, transform.a) * (180 / Math.PI);\n    }\n    static calculateCorners(bounds, transform) {\n        const corners = {\n            topLeft: {\n                x: bounds.left,\n                y: bounds.top\n            },\n            topRight: {\n                x: bounds.right,\n                y: bounds.top\n            },\n            bottomLeft: {\n                x: bounds.left,\n                y: bounds.bottom\n            },\n            bottomRight: {\n                x: bounds.right,\n                y: bounds.bottom\n            }\n        };\n        // Apply transformation to corners\n        Object.keys(corners).forEach((corner)=>{\n            const point = corners[corner];\n            corners[corner] = {\n                x: transform.a * point.x + transform.c * point.y + transform.tx,\n                y: transform.b * point.x + transform.d * point.y + transform.ty\n            };\n        });\n        return corners;\n    }\n    static cmykToRgb(c, m, y, k) {\n        // Convert CMYK percentages (0-100) to RGB (0-255)\n        c = c / 100;\n        m = m / 100;\n        y = y / 100;\n        k = k / 100;\n        const r = Math.round(255 * (1 - c) * (1 - k));\n        const g = Math.round(255 * (1 - m) * (1 - k));\n        const b = Math.round(255 * (1 - y) * (1 - k));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    static parseInDesignColor(colorRef) {\n        if (!colorRef || colorRef === \"Color/None\") return null;\n        // Handle CMYK colors\n        const cmykMatch = colorRef.match(/Color\\/C=(\\d+)\\s*M=(\\d+)\\s*Y=(\\d+)\\s*K=(\\d+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map(Number);\n            const rgb = this.cmykToRgb(c, m, y, k);\n            return \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n        }\n        // Handle RGB colors\n        const rgbMatch = colorRef.match(/Color\\/R=(\\d+)\\s*G=(\\d+)\\s*B=(\\d+)/);\n        if (rgbMatch) {\n            const [, r, g, b] = rgbMatch.map(Number);\n            return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n        }\n        // Standard colors\n        const standardColors = {\n            \"Color/Black\": \"rgb(0, 0, 0)\",\n            \"Color/White\": \"rgb(255, 255, 255)\",\n            \"Color/Red\": \"rgb(255, 0, 0)\",\n            \"Color/Green\": \"rgb(0, 255, 0)\",\n            \"Color/Blue\": \"rgb(0, 0, 255)\",\n            \"Color/Cyan\": \"rgb(0, 255, 255)\",\n            \"Color/Magenta\": \"rgb(255, 0, 255)\",\n            \"Color/Yellow\": \"rgb(255, 255, 0)\",\n            \"Color/Paper\": \"rgb(255, 255, 255)\",\n            \"Color/Registration\": \"rgb(0, 0, 0)\"\n        };\n        return standardColors[colorRef] || null;\n    }\n    static decodeXMLEntities(text) {\n        if (!text) return \"\";\n        return text.replace(/&#x000A;/g, \"\\n\") // Line feed\n        .replace(/&#x000D;/g, \"\\r\") // Carriage return\n        .replace(/&#x0009;/g, \"\t\") // Tab\n        .replace(/&#x00A0;/g, \"\\xa0\") // Non-breaking space\n        .replace(/&#x2028;/g, \"\\u2028\") // Line separator\n        .replace(/&#x2029;/g, \"\\u2029\") // Paragraph separator\n        .replace(/&#10;/g, \"\\n\") // Decimal line feed\n        .replace(/&#13;/g, \"\\r\") // Decimal carriage return\n        .replace(/&#9;/g, \"\t\") // Decimal tab\n        .replace(/&#160;/g, \"\\xa0\") // Decimal non-breaking space\n        .replace(/&lt;/g, \"<\") // Less than\n        .replace(/&gt;/g, \">\") // Greater than\n        .replace(/&amp;/g, \"&\") // Ampersand (must be last)\n        .replace(/&quot;/g, '\"') // Quote\n        .replace(/&apos;/g, \"'\"); // Apostrophe\n    }\n    static cleanTextContent(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\t/g, \"    \") // Convert tabs to spaces\n        .replace(/\\u00A0/g, \" \") // Convert non-breaking spaces\n        .replace(/ +/g, \" \") // Collapse multiple spaces\n        // REMOVED: .replace(/\\n{3,}/g, '\\n\\n')  // Allow unlimited consecutive line breaks\n        .trim();\n    }\n    static preserveLineBreaks(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\"); // Convert paragraph separators\n    // REMOVED: .replace(/\\n{3,}/g, '\\n\\n'); // Allow unlimited consecutive line breaks\n    }\n    // NEW: Clean up excessive line breaks to prevent text overflow\n    static cleanTextForRendering(text) {\n        if (!text) return \"\";\n        return text// Normalize line endings\n        .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\")// Remove trailing whitespace on each line only\n        .replace(/[ \\t]+\\n/g, \"\\n\");\n    // DO NOT collapse multiple spaces, tabs, or newlines\n    // DO NOT trim the whole string\n    }\n    // ENHANCED: Better line break processing that preserves word spaces\n    static sophisticatedLineBreakProcessing(content) {\n        if (!content) return \"\";\n        // DEBUG: Track if problematic text is being processed\n        const hasProblematicText = content.includes(\"pavoluptusda\") || content.includes(\"pa\") && content.includes(\"voluptusda\");\n        if (hasProblematicText) {\n            console.log(\"\\uD83D\\uDD27 IDMLUtils.sophisticatedLineBreakProcessing:\");\n            console.log(\"   - Input:\", JSON.stringify(content));\n        }\n        // First clean up the content but preserve word spaces\n        let processed = this.cleanTextForRendering(content);\n        if (hasProblematicText) {\n            console.log(\"   - After cleanTextForRendering:\", JSON.stringify(processed));\n        }\n        // Normalize line breaks but don't touch word spaces\n        // processed = processed\n        //   .replace(/\\r\\n/g, '\\n')      // Normalize Windows line breaks\n        //   .replace(/\\r/g, '\\n')        // Normalize old Mac line breaks\n        //   .replace(/\\u2029/g, '\\n')    // Convert line separators\n        //   .replace(/\\u2028/g, '\\n\\n')  // Convert paragraph separators to double breaks\n        //   .replace(/\\u000A/g, '\\n');   // Convert explicit line feed characters\n        // Ensure paragraph breaks are properly spaced\n        // processed = processed.replace(/\\n\\n+/g, '\\n\\n'); // REMOVE THIS LINE to preserve all consecutive newlines\n        return processed;\n    }\n    static countWords(text) {\n        return text.split(/\\s+/).filter((word)=>word.length > 0).length;\n    }\n    static parseNumeric(value) {\n        if (value === null || value === undefined || value === \"\") return null;\n        const num = parseFloat(value);\n        return isNaN(num) ? null : num;\n    }\n    static isImageFile(fileName) {\n        const imageExtensions = [\n            \".jpg\",\n            \".jpeg\",\n            \".png\",\n            \".gif\",\n            \".tiff\",\n            \".tif\",\n            \".bmp\",\n            \".svg\",\n            \".eps\",\n            \".ai\",\n            \".psd\",\n            \".webp\",\n            \".ico\",\n            \".jfif\",\n            \".jp2\",\n            \".jpx\"\n        ];\n        return imageExtensions.some((ext)=>fileName.toLowerCase().endsWith(ext));\n    }\n    static getImageExtension(imageTypeName) {\n        const typeMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return typeMap[imageTypeName] || \"jpg\";\n    }\n    static getImageExtensionFromFormat(format) {\n        const formatMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return formatMap[format] || \"jpg\";\n    }\n    static extractImageNameFromLink(linkUri) {\n        if (!linkUri) return null;\n        // Extract filename from path like \"file:C:/Users/lalo/Downloads/Tesla-Model-3.jpg 13325 \"\n        const match = linkUri.match(/([^\\/\\\\]+)\\.[^.]+$/);\n        return match ? match[1] : null;\n    }\n    static calculateCoordinateOffset(elements) {\n        if (!elements || elements.length === 0) {\n            console.log(\"\\uD83D\\uDEAB No elements provided for coordinate offset calculation\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        let minX = Infinity, minY = Infinity;\n        let maxStrokeWidth = 0;\n        let validElements = 0;\n        console.log(\"\\uD83D\\uDD0D ANALYZING \".concat(elements.length, \" elements for coordinate offset...\"));\n        // First pass: find TRUE minimum coordinates across all elements\n        elements.forEach((element, index)=>{\n            const bounds = element.geometricBounds || element.originalBounds;\n            const transform = element.itemTransform || {\n                tx: 0,\n                ty: 0\n            };\n            if (bounds && (bounds.left !== undefined || bounds.top !== undefined)) {\n                // Calculate final position after transform\n                const finalX = (bounds.left || 0) + (transform.tx || 0);\n                const finalY = (bounds.top || 0) + (transform.ty || 0);\n                console.log(\"   Element \".concat(index, \": bounds(\").concat(bounds.left, \", \").concat(bounds.top, \") + transform(\").concat(transform.tx, \", \").concat(transform.ty, \") = final(\").concat(finalX, \", \").concat(finalY, \")\"));\n                minX = Math.min(minX, finalX);\n                minY = Math.min(minY, finalY);\n                validElements++;\n                // Track maximum stroke width for intelligent padding\n                const strokeWidth = element.strokeWeight || 0;\n                maxStrokeWidth = Math.max(maxStrokeWidth, strokeWidth);\n            } else {\n                console.log(\"   Element \".concat(index, \": No valid bounds - skipping\"));\n            }\n        });\n        // Handle case where no valid elements found\n        if (validElements === 0) {\n            console.log(\"⚠️  No valid elements with bounds found - using zero offset\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        // Reset infinite values to 0 if no valid coordinates found\n        if (minX === Infinity) minX = 0;\n        if (minY === Infinity) minY = 0;\n        console.log(\"\\uD83D\\uDCCA ANALYSIS COMPLETE: minX=\".concat(minX, \", minY=\").concat(minY, \", maxStroke=\").concat(maxStrokeWidth, \"px, validElements=\").concat(validElements));\n        // ZERO-BASED OFFSET CALCULATION:\n        // The goal is to have NO OFFSET unless absolutely necessary for negative coordinates\n        let offsetX = 0;\n        let offsetY = 0;\n        // Only add offset if coordinates are actually negative\n        if (minX < 0) {\n            offsetX = Math.abs(minX);\n            console.log(\"❌ Negative X detected: \".concat(minX, \" → adding offset: \").concat(offsetX));\n        }\n        if (minY < 0) {\n            offsetY = Math.abs(minY);\n            console.log(\"❌ Negative Y detected: \".concat(minY, \" → adding offset: \").concat(offsetY));\n        }\n        // Add minimal stroke padding only if we already have an offset\n        if ((offsetX > 0 || offsetY > 0) && maxStrokeWidth > 0) {\n            const strokePadding = Math.ceil(maxStrokeWidth / 2);\n            if (offsetX > 0) offsetX += strokePadding;\n            if (offsetY > 0) offsetY += strokePadding;\n            console.log(\"\\uD83D\\uDD8C️ Added stroke padding: \".concat(strokePadding, \"px\"));\n        }\n        console.log(\"\\uD83C\\uDFAF FINAL OFFSET: X=\".concat(offsetX, \", Y=\").concat(offsetY));\n        console.log(\"   \".concat(offsetX === 0 ? \"✅ Perfect! No X offset needed\" : \"⚠️ X offset: \".concat(offsetX, \"px (\").concat(minX, \" was negative)\")));\n        console.log(\"   \".concat(offsetY === 0 ? \"✅ Perfect! No Y offset needed\" : \"⚠️ Y offset: \".concat(offsetY, \"px (\").concat(minY, \" was negative)\")));\n        return {\n            x: offsetX,\n            y: offsetY\n        };\n    }\n    /**\r\n   * Calculate precise coordinate offset for pixel-perfect InDesign coordinate system transformation\r\n   * This ensures accurate positioning similar to professional tools like IMG.LY InDesign\r\n   * @param {Array} elements - Array of elements with bounds and transforms\r\n   * @returns {Object} - {x, y} offset for coordinate transformation\r\n   */ static calculateCoordinateOffsetPrecise(elements) {\n        if (!elements || elements.length === 0) {\n            console.warn(\"\\uD83C\\uDFAF No elements provided for coordinate offset calculation\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        console.log(\"\\uD83D\\uDD0D ANALYZING\", elements.length, \"elements for PRECISE coordinate offset...\");\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxStroke = 0;\n        let validElements = 0;\n        elements.forEach((element, index)=>{\n            if (!element.geometricBounds || !element.itemTransform) {\n                console.warn(\"   ⚠️ Element \".concat(index, \" missing bounds/transform - skipping\"));\n                return;\n            }\n            // Calculate final position (bounds + transform)\n            const finalX = element.geometricBounds.left + element.itemTransform.tx;\n            const finalY = element.geometricBounds.top + element.itemTransform.ty;\n            // Track stroke width for precise positioning\n            const strokeWidth = element.strokeWeight || 0;\n            maxStroke = Math.max(maxStroke, strokeWidth);\n            console.log(\"   Element \".concat(index, \": bounds(\").concat(element.geometricBounds.left, \", \").concat(element.geometricBounds.top, \") + transform(\").concat(element.itemTransform.tx, \", \").concat(element.itemTransform.ty, \") = final(\").concat(finalX, \", \").concat(finalY, \")\"));\n            minX = Math.min(minX, finalX);\n            minY = Math.min(minY, finalY);\n            validElements++;\n        });\n        console.log(\"\\uD83D\\uDCCA ANALYSIS COMPLETE:\", \"minX=\".concat(minX, \", minY=\").concat(minY, \", maxStroke=\").concat(maxStroke, \"px, validElements=\").concat(validElements));\n        // FIXED: Only add offset if coordinates are actually negative\n        // Don't force elements to start at origin - preserve InDesign positioning\n        let offsetX = 0;\n        let offsetY = 0;\n        // Only handle negative coordinates that would be clipped by the browser\n        if (minX < 0) {\n            offsetX = Math.abs(minX) + maxStroke;\n            console.log(\"❌ Negative X detected: \".concat(minX, \" → adding offset: \").concat(offsetX));\n        } else {\n            console.log(\"✅ Positive X coordinates: \".concat(minX, \" → no offset needed\"));\n        }\n        if (minY < 0) {\n            offsetY = Math.abs(minY) + maxStroke;\n            console.log(\"❌ Negative Y detected: \".concat(minY, \" → adding offset: \").concat(offsetY));\n        } else {\n            console.log(\"✅ Positive Y coordinates: \".concat(minY, \" → no offset needed\"));\n        }\n        const finalOffset = {\n            x: offsetX,\n            y: offsetY\n        };\n        console.log(\"\\uD83C\\uDFAF FINAL PRECISE OFFSET:\", \"X=\".concat(offsetX, \", Y=\").concat(offsetY));\n        console.log(\"   \".concat(offsetX === 0 ? \"✅ Perfect! No X offset needed\" : \"⚠️ X offset: \".concat(offsetX, \"px (compensating for negative coordinates)\")));\n        console.log(\"   \".concat(offsetY === 0 ? \"✅ Perfect! No Y offset needed\" : \"⚠️ Y offset: \".concat(offsetY, \"px (compensating for negative coordinates)\")));\n        return finalOffset;\n    }\n    static calculateBoundsFromPath(item) {\n        try {\n            var _item_Properties_PathGeometry_GeometryPathType_PathPointArray, _item_Properties_PathGeometry_GeometryPathType, _item_Properties_PathGeometry, _item_Properties;\n            // First try to get bounds from GeometricBounds attribute\n            if (item[\"@_GeometricBounds\"]) {\n                return this.parseGeometricBounds(item[\"@_GeometricBounds\"]);\n            }\n            // Then try path geometry\n            const pathGeometry = item === null || item === void 0 ? void 0 : (_item_Properties = item.Properties) === null || _item_Properties === void 0 ? void 0 : (_item_Properties_PathGeometry = _item_Properties.PathGeometry) === null || _item_Properties_PathGeometry === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType = _item_Properties_PathGeometry.GeometryPathType) === null || _item_Properties_PathGeometry_GeometryPathType === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType_PathPointArray = _item_Properties_PathGeometry_GeometryPathType.PathPointArray) === null || _item_Properties_PathGeometry_GeometryPathType_PathPointArray === void 0 ? void 0 : _item_Properties_PathGeometry_GeometryPathType_PathPointArray.PathPointType;\n            if (!pathGeometry || !Array.isArray(pathGeometry)) {\n                console.log(\"Warning: No geometry found for \".concat(item[\"@_Self\"], \", using item transform\"));\n                // Fallback to item transform if available\n                const transform = this.parseTransform(item[\"@_ItemTransform\"]);\n                return {\n                    top: transform.ty || 0,\n                    left: transform.tx || 0,\n                    bottom: (transform.ty || 0) + 100,\n                    right: (transform.tx || 0) + 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n            pathGeometry.forEach((point)=>{\n                const anchor = point[\"@_Anchor\"];\n                if (anchor) {\n                    const [x, y] = anchor.split(\" \").map(parseFloat);\n                    if (!isNaN(x) && !isNaN(y)) {\n                        minX = Math.min(minX, x);\n                        maxX = Math.max(maxX, x);\n                        minY = Math.min(minY, y);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            });\n            if (minX === Infinity || minY === Infinity) {\n                console.log(\"Warning: Could not calculate bounds for \".concat(item[\"@_Self\"]));\n                return {\n                    top: 0,\n                    left: 0,\n                    bottom: 100,\n                    right: 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            return {\n                top: minY,\n                left: minX,\n                bottom: maxY,\n                right: maxX,\n                width: maxX - minX,\n                height: maxY - minY\n            };\n        } catch (error) {\n            console.error(\"Error calculating bounds for \".concat(item[\"@_Self\"], \":\"), error);\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n    }\n    static calculateRelativePosition(frameBounds, contentBounds, frameTransform, contentTransform) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            offsetX: (contentBounds.left || 0) - (frameBounds.left || 0),\n            offsetY: (contentBounds.top || 0) - (frameBounds.top || 0),\n            scaleX: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.a) || 1,\n            scaleY: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.d) || 1,\n            transformDifference: {\n                frame: frameTransform,\n                content: contentTransform\n            }\n        };\n    }\n    static calculateGap(frameBounds, contentBounds) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            top: (contentBounds.top || 0) - (frameBounds.top || 0),\n            left: (contentBounds.left || 0) - (frameBounds.left || 0),\n            bottom: (frameBounds.bottom || 0) - (contentBounds.bottom || 0),\n            right: (frameBounds.right || 0) - (contentBounds.right || 0)\n        };\n    }\n    static calculateImagePositionInFrame(frameBounds, frameTransform, placedContent) {\n        if (!frameBounds || !(placedContent === null || placedContent === void 0 ? void 0 : placedContent.transform)) {\n            return null;\n        }\n        const imageTransform = placedContent.transform;\n        // Calculate image position relative to frame\n        const imageX = (frameBounds.left || 0) + (imageTransform.tx || 0);\n        const imageY = (frameBounds.top || 0) + (imageTransform.ty || 0);\n        // Calculate image size with scaling\n        const imageWidth = (frameBounds.width || 0) * (imageTransform.a || 1);\n        const imageHeight = (frameBounds.height || 0) * (imageTransform.d || 1);\n        return {\n            x: imageX,\n            y: imageY,\n            width: imageWidth,\n            height: imageHeight,\n            scaleX: imageTransform.a || 1,\n            scaleY: imageTransform.d || 1\n        };\n    }\n    static getXMLStructure(obj) {\n        let maxDepth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        if (currentDepth >= maxDepth || typeof obj !== \"object\" || obj === null) {\n            return typeof obj;\n        }\n        const structure = {};\n        Object.keys(obj).forEach((key)=>{\n            if (Array.isArray(obj[key])) {\n                structure[key] = \"Array[\".concat(obj[key].length, \"]\");\n            } else if (typeof obj[key] === \"object\" && obj[key] !== null) {\n                structure[key] = this.getXMLStructure(obj[key], maxDepth, currentDepth + 1);\n            } else {\n                structure[key] = typeof obj[key];\n            }\n        });\n        return structure;\n    }\n    static isFormattingAttribute(attributeName) {\n        const formattingAttributes = [\n            \"@_PointSize\",\n            \"@_Leading\",\n            \"@_Tracking\",\n            \"@_FontStyle\",\n            \"@_AppliedFont\",\n            \"@_FillColor\",\n            \"@_StrokeColor\",\n            \"@_Justification\",\n            \"@_LeftIndent\",\n            \"@_RightIndent\",\n            \"@_FirstLineIndent\",\n            \"@_SpaceBefore\",\n            \"@_SpaceAfter\",\n            \"@_Alignment\"\n        ];\n        return formattingAttributes.includes(attributeName);\n    }\n    static saveDebugInfo(debugInfo, fileName) {\n        try {\n            fs.writeFileSync(fileName, JSON.stringify(debugInfo, null, 2));\n            console.log(\"✅ Debug info saved to \".concat(fileName));\n        } catch (error) {\n            console.error(\"❌ Error saving debug info:\", error);\n            console.log(\"Debug info (first 2000 chars):\", JSON.stringify(debugInfo, null, 2).substring(0, 2000));\n        }\n    }\n}\nmodule.exports = IDMLUtils;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cUJBQXFCOUYsUUFBUSxDQUFDNkY7SUFDdkM7SUFFQSxPQUFPRSxjQUFjQyxTQUFTLEVBQUVsRixRQUFRLEVBQUU7UUFDeEMsSUFBSTtZQUNGbEYsR0FBR3FLLGFBQWEsQ0FBQ25GLFVBQVViLEtBQUtDLFNBQVMsQ0FBQzhGLFdBQVcsTUFBTTtZQUMzRGhLLFFBQVFDLEdBQUcsQ0FBQyx5QkFBa0MsT0FBVDZFO1FBQ3ZDLEVBQUUsT0FBT3NELE9BQU87WUFDZHBJLFFBQVFvSSxLQUFLLENBQUMsOEJBQThCQTtZQUM1Q3BJLFFBQVFDLEdBQUcsQ0FDVCxrQ0FDQWdFLEtBQUtDLFNBQVMsQ0FBQzhGLFdBQVcsTUFBTSxHQUFHRSxTQUFTLENBQUMsR0FBRztRQUVwRDtJQUNGO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHdksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3V0aWxzL0lETUxVdGlscy5qcz84ZDJmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcblxyXG5jbGFzcyBJRE1MVXRpbHMge1xyXG4gIHN0YXRpYyBwYXJzZUdlb21ldHJpY0JvdW5kcyhib3VuZHNTdHJpbmcpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IGJvdW5kc1N0cmluZyA9XCIsIGJvdW5kc1N0cmluZyk7XHJcbiAgICBpZiAoIWJvdW5kc1N0cmluZyB8fCBib3VuZHNTdHJpbmcgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiBNaXNzaW5nIGdlb21ldHJpYyBib3VuZHMsIHVzaW5nIGRlZmF1bHRzXCIpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMTAwLFxyXG4gICAgICAgIHJpZ2h0OiAxMDAsXHJcbiAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBib3VuZHMgPSBib3VuZHNTdHJpbmcuc3BsaXQoXCIgXCIpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgdG9wOiBib3VuZHNbMF0gfHwgMCxcclxuICAgICAgbGVmdDogYm91bmRzWzFdIHx8IDAsXHJcbiAgICAgIGJvdHRvbTogYm91bmRzWzJdIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBib3VuZHNbM10gfHwgMCxcclxuICAgICAgd2lkdGg6IChib3VuZHNbM10gfHwgMCkgLSAoYm91bmRzWzFdIHx8IDApLFxyXG4gICAgICBoZWlnaHQ6IChib3VuZHNbMl0gfHwgMCkgLSAoYm91bmRzWzBdIHx8IDApLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlBhcnNlZCBib3VuZHM6XCIsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybVN0cmluZykge1xyXG4gICAgaWYgKCF0cmFuc2Zvcm1TdHJpbmcpIHJldHVybiB7IGE6IDEsIGI6IDAsIGM6IDAsIGQ6IDEsIHR4OiAwLCB0eTogMCB9O1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IHRyYW5zZm9ybVN0cmluZy5zcGxpdChcIiBcIikubWFwKHBhcnNlRmxvYXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYTogdmFsdWVzWzBdIHx8IDEsIC8vIHggc2NhbGVcclxuICAgICAgYjogdmFsdWVzWzFdIHx8IDAsIC8vIHkgc2tld1xyXG4gICAgICBjOiB2YWx1ZXNbMl0gfHwgMCwgLy8geCBza2V3XHJcbiAgICAgIGQ6IHZhbHVlc1szXSB8fCAxLCAvLyB5IHNjYWxlXHJcbiAgICAgIHR4OiB2YWx1ZXNbNF0gfHwgMCwgLy8geCB0cmFuc2xhdGlvblxyXG4gICAgICB0eTogdmFsdWVzWzVdIHx8IDAsIC8vIHkgdHJhbnNsYXRpb25cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlUm90YXRpb24odHJhbnNmb3JtKSB7XHJcbiAgICAvLyBDYWxjdWxhdGUgcm90YXRpb24gYW5nbGUgZnJvbSB0cmFuc2Zvcm0gbWF0cml4XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmEpICogKDE4MCAvIE1hdGguUEkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUNvcm5lcnMoYm91bmRzLCB0cmFuc2Zvcm0pIHtcclxuICAgIGNvbnN0IGNvcm5lcnMgPSB7XHJcbiAgICAgIHRvcExlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy50b3AgfSxcclxuICAgICAgdG9wUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMudG9wIH0sXHJcbiAgICAgIGJvdHRvbUxlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy5ib3R0b20gfSxcclxuICAgICAgYm90dG9tUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMuYm90dG9tIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIGNvcm5lcnNcclxuICAgIE9iamVjdC5rZXlzKGNvcm5lcnMpLmZvckVhY2goKGNvcm5lcikgPT4ge1xyXG4gICAgICBjb25zdCBwb2ludCA9IGNvcm5lcnNbY29ybmVyXTtcclxuICAgICAgY29ybmVyc1tjb3JuZXJdID0ge1xyXG4gICAgICAgIHg6IHRyYW5zZm9ybS5hICogcG9pbnQueCArIHRyYW5zZm9ybS5jICogcG9pbnQueSArIHRyYW5zZm9ybS50eCxcclxuICAgICAgICB5OiB0cmFuc2Zvcm0uYiAqIHBvaW50LnggKyB0cmFuc2Zvcm0uZCAqIHBvaW50LnkgKyB0cmFuc2Zvcm0udHksXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29ybmVycztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjbXlrVG9SZ2IoYywgbSwgeSwgaykge1xyXG4gICAgLy8gQ29udmVydCBDTVlLIHBlcmNlbnRhZ2VzICgwLTEwMCkgdG8gUkdCICgwLTI1NSlcclxuICAgIGMgPSBjIC8gMTAwO1xyXG4gICAgbSA9IG0gLyAxMDA7XHJcbiAgICB5ID0geSAvIDEwMDtcclxuICAgIGsgPSBrIC8gMTAwO1xyXG5cclxuICAgIGNvbnN0IHIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gYykgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGcgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gbSkgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0geSkgKiAoMSAtIGspKTtcclxuXHJcbiAgICByZXR1cm4geyByLCBnLCBiIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VJbkRlc2lnbkNvbG9yKGNvbG9yUmVmKSB7XHJcbiAgICBpZiAoIWNvbG9yUmVmIHx8IGNvbG9yUmVmID09PSBcIkNvbG9yL05vbmVcIikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gSGFuZGxlIENNWUsgY29sb3JzXHJcbiAgICBjb25zdCBjbXlrTWF0Y2ggPSBjb2xvclJlZi5tYXRjaChcclxuICAgICAgL0NvbG9yXFwvQz0oXFxkKylcXHMqTT0oXFxkKylcXHMqWT0oXFxkKylcXHMqSz0oXFxkKykvXHJcbiAgICApO1xyXG4gICAgaWYgKGNteWtNYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCBjLCBtLCB5LCBrXSA9IGNteWtNYXRjaC5tYXAoTnVtYmVyKTtcclxuICAgICAgY29uc3QgcmdiID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cmdiLnJ9LCAke3JnYi5nfSwgJHtyZ2IuYn0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgUkdCIGNvbG9yc1xyXG4gICAgY29uc3QgcmdiTWF0Y2ggPSBjb2xvclJlZi5tYXRjaCgvQ29sb3JcXC9SPShcXGQrKVxccypHPShcXGQrKVxccypCPShcXGQrKS8pO1xyXG4gICAgaWYgKHJnYk1hdGNoKSB7XHJcbiAgICAgIGNvbnN0IFssIHIsIGcsIGJdID0gcmdiTWF0Y2gubWFwKE51bWJlcik7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGFuZGFyZCBjb2xvcnNcclxuICAgIGNvbnN0IHN0YW5kYXJkQ29sb3JzID0ge1xyXG4gICAgICBcIkNvbG9yL0JsYWNrXCI6IFwicmdiKDAsIDAsIDApXCIsXHJcbiAgICAgIFwiQ29sb3IvV2hpdGVcIjogXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIixcclxuICAgICAgXCJDb2xvci9SZWRcIjogXCJyZ2IoMjU1LCAwLCAwKVwiLFxyXG4gICAgICBcIkNvbG9yL0dyZWVuXCI6IFwicmdiKDAsIDI1NSwgMClcIixcclxuICAgICAgXCJDb2xvci9CbHVlXCI6IFwicmdiKDAsIDAsIDI1NSlcIixcclxuICAgICAgXCJDb2xvci9DeWFuXCI6IFwicmdiKDAsIDI1NSwgMjU1KVwiLFxyXG4gICAgICBcIkNvbG9yL01hZ2VudGFcIjogXCJyZ2IoMjU1LCAwLCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvWWVsbG93XCI6IFwicmdiKDI1NSwgMjU1LCAwKVwiLFxyXG4gICAgICBcIkNvbG9yL1BhcGVyXCI6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvUmVnaXN0cmF0aW9uXCI6IFwicmdiKDAsIDAsIDApXCIsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBzdGFuZGFyZENvbG9yc1tjb2xvclJlZl0gfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBkZWNvZGVYTUxFbnRpdGllcyh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMDBBOy9nLCBcIlxcblwiKSAvLyBMaW5lIGZlZWRcclxuICAgICAgLnJlcGxhY2UoLyYjeDAwMEQ7L2csIFwiXFxyXCIpIC8vIENhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiN4MDAwOTsvZywgXCJcXHRcIikgLy8gVGFiXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMEEwOy9nLCBcIlxcdTAwQTBcIikgLy8gTm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gyMDI4Oy9nLCBcIlxcdTIwMjhcIikgLy8gTGluZSBzZXBhcmF0b3JcclxuICAgICAgLnJlcGxhY2UoLyYjeDIwMjk7L2csIFwiXFx1MjAyOVwiKSAvLyBQYXJhZ3JhcGggc2VwYXJhdG9yXHJcbiAgICAgIC5yZXBsYWNlKC8mIzEwOy9nLCBcIlxcblwiKSAvLyBEZWNpbWFsIGxpbmUgZmVlZFxyXG4gICAgICAucmVwbGFjZSgvJiMxMzsvZywgXCJcXHJcIikgLy8gRGVjaW1hbCBjYXJyaWFnZSByZXR1cm5cclxuICAgICAgLnJlcGxhY2UoLyYjOTsvZywgXCJcXHRcIikgLy8gRGVjaW1hbCB0YWJcclxuICAgICAgLnJlcGxhY2UoLyYjMTYwOy9nLCBcIlxcdTAwQTBcIikgLy8gRGVjaW1hbCBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgLnJlcGxhY2UoLyZsdDsvZywgXCI8XCIpIC8vIExlc3MgdGhhblxyXG4gICAgICAucmVwbGFjZSgvJmd0Oy9nLCBcIj5cIikgLy8gR3JlYXRlciB0aGFuXHJcbiAgICAgIC5yZXBsYWNlKC8mYW1wOy9nLCBcIiZcIikgLy8gQW1wZXJzYW5kIChtdXN0IGJlIGxhc3QpXHJcbiAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJykgLy8gUXVvdGVcclxuICAgICAgLnJlcGxhY2UoLyZhcG9zOy9nLCBcIidcIik7IC8vIEFwb3N0cm9waGVcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjbGVhblRleHRDb250ZW50KGNvbnRlbnQpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGNvbnRlbnRcclxuICAgICAgICAucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpIC8vIE5vcm1hbGl6ZSBXaW5kb3dzIGxpbmUgYnJlYWtzXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKSAvLyBOb3JtYWxpemUgb2xkIE1hYyBsaW5lIGJyZWFrc1xyXG4gICAgICAgIC5yZXBsYWNlKC9cXHQvZywgXCIgICAgXCIpIC8vIENvbnZlcnQgdGFicyB0byBzcGFjZXNcclxuICAgICAgICAucmVwbGFjZSgvXFx1MDBBMC9nLCBcIiBcIikgLy8gQ29udmVydCBub24tYnJlYWtpbmcgc3BhY2VzXHJcbiAgICAgICAgLnJlcGxhY2UoLyArL2csIFwiIFwiKSAvLyBDb2xsYXBzZSBtdWx0aXBsZSBzcGFjZXNcclxuICAgICAgICAvLyBSRU1PVkVEOiAucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJykgIC8vIEFsbG93IHVubGltaXRlZCBjb25zZWN1dGl2ZSBsaW5lIGJyZWFrc1xyXG4gICAgICAgIC50cmltKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcHJlc2VydmVMaW5lQnJlYWtzKGNvbnRlbnQpIHtcclxuICAgIHJldHVybiBjb250ZW50XHJcbiAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIikgLy8gTm9ybWFsaXplIFdpbmRvd3MgbGluZSBicmVha3NcclxuICAgICAgLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKSAvLyBOb3JtYWxpemUgb2xkIE1hYyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKSAvLyBDb252ZXJ0IGxpbmUgc2VwYXJhdG9yc1xyXG4gICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcblxcblwiKTsgLy8gQ29udmVydCBwYXJhZ3JhcGggc2VwYXJhdG9yc1xyXG4gICAgLy8gUkVNT1ZFRDogLnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpOyAvLyBBbGxvdyB1bmxpbWl0ZWQgY29uc2VjdXRpdmUgbGluZSBicmVha3NcclxuICB9XHJcblxyXG4gIC8vIE5FVzogQ2xlYW4gdXAgZXhjZXNzaXZlIGxpbmUgYnJlYWtzIHRvIHByZXZlbnQgdGV4dCBvdmVyZmxvd1xyXG4gIHN0YXRpYyBjbGVhblRleHRGb3JSZW5kZXJpbmcodGV4dCkge1xyXG4gICAgaWYgKCF0ZXh0KSByZXR1cm4gXCJcIjtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRleHRcclxuICAgICAgICAvLyBOb3JtYWxpemUgbGluZSBlbmRpbmdzXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIilcclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBvbiBlYWNoIGxpbmUgb25seVxyXG4gICAgICAgIC5yZXBsYWNlKC9bIFxcdF0rXFxuL2csIFwiXFxuXCIpXHJcbiAgICApO1xyXG4gICAgLy8gRE8gTk9UIGNvbGxhcHNlIG11bHRpcGxlIHNwYWNlcywgdGFicywgb3IgbmV3bGluZXNcclxuICAgIC8vIERPIE5PVCB0cmltIHRoZSB3aG9sZSBzdHJpbmdcclxuICB9XHJcblxyXG4gIC8vIEVOSEFOQ0VEOiBCZXR0ZXIgbGluZSBicmVhayBwcm9jZXNzaW5nIHRoYXQgcHJlc2VydmVzIHdvcmQgc3BhY2VzXHJcbiAgc3RhdGljIHNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nKGNvbnRlbnQpIHtcclxuICAgIGlmICghY29udGVudCkgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgLy8gREVCVUc6IFRyYWNrIGlmIHByb2JsZW1hdGljIHRleHQgaXMgYmVpbmcgcHJvY2Vzc2VkXHJcbiAgICBjb25zdCBoYXNQcm9ibGVtYXRpY1RleHQgPVxyXG4gICAgICBjb250ZW50LmluY2x1ZGVzKFwicGF2b2x1cHR1c2RhXCIpIHx8XHJcbiAgICAgIChjb250ZW50LmluY2x1ZGVzKFwicGFcIikgJiYgY29udGVudC5pbmNsdWRlcyhcInZvbHVwdHVzZGFcIikpO1xyXG4gICAgaWYgKGhhc1Byb2JsZW1hdGljVGV4dCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCflKcgSURNTFV0aWxzLnNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nOlwiKTtcclxuICAgICAgY29uc29sZS5sb2coXCIgICAtIElucHV0OlwiLCBKU09OLnN0cmluZ2lmeShjb250ZW50KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlyc3QgY2xlYW4gdXAgdGhlIGNvbnRlbnQgYnV0IHByZXNlcnZlIHdvcmQgc3BhY2VzXHJcbiAgICBsZXQgcHJvY2Vzc2VkID0gdGhpcy5jbGVhblRleHRGb3JSZW5kZXJpbmcoY29udGVudCk7XHJcblxyXG4gICAgaWYgKGhhc1Byb2JsZW1hdGljVGV4dCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIiAgIC0gQWZ0ZXIgY2xlYW5UZXh0Rm9yUmVuZGVyaW5nOlwiLFxyXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHByb2Nlc3NlZClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3JtYWxpemUgbGluZSBicmVha3MgYnV0IGRvbid0IHRvdWNoIHdvcmQgc3BhY2VzXHJcbiAgICAvLyBwcm9jZXNzZWQgPSBwcm9jZXNzZWRcclxuICAgIC8vICAgLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykgICAgICAvLyBOb3JtYWxpemUgV2luZG93cyBsaW5lIGJyZWFrc1xyXG4gICAgLy8gICAucmVwbGFjZSgvXFxyL2csICdcXG4nKSAgICAgICAgLy8gTm9ybWFsaXplIG9sZCBNYWMgbGluZSBicmVha3NcclxuICAgIC8vICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcbicpICAgIC8vIENvbnZlcnQgbGluZSBzZXBhcmF0b3JzXHJcbiAgICAvLyAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXG5cXG4nKSAgLy8gQ29udmVydCBwYXJhZ3JhcGggc2VwYXJhdG9ycyB0byBkb3VibGUgYnJlYWtzXHJcbiAgICAvLyAgIC5yZXBsYWNlKC9cXHUwMDBBL2csICdcXG4nKTsgICAvLyBDb252ZXJ0IGV4cGxpY2l0IGxpbmUgZmVlZCBjaGFyYWN0ZXJzXHJcblxyXG4gICAgLy8gRW5zdXJlIHBhcmFncmFwaCBicmVha3MgYXJlIHByb3Blcmx5IHNwYWNlZFxyXG4gICAgLy8gcHJvY2Vzc2VkID0gcHJvY2Vzc2VkLnJlcGxhY2UoL1xcblxcbisvZywgJ1xcblxcbicpOyAvLyBSRU1PVkUgVEhJUyBMSU5FIHRvIHByZXNlcnZlIGFsbCBjb25zZWN1dGl2ZSBuZXdsaW5lc1xyXG5cclxuICAgIHJldHVybiBwcm9jZXNzZWQ7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY291bnRXb3Jkcyh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdGV4dC5zcGxpdCgvXFxzKy8pLmZpbHRlcigod29yZCkgPT4gd29yZC5sZW5ndGggPiAwKS5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VOdW1lcmljKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gXCJcIikgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgIHJldHVybiBpc05hTihudW0pID8gbnVsbCA6IG51bTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBpc0ltYWdlRmlsZShmaWxlTmFtZSkge1xyXG4gICAgY29uc3QgaW1hZ2VFeHRlbnNpb25zID0gW1xyXG4gICAgICBcIi5qcGdcIixcclxuICAgICAgXCIuanBlZ1wiLFxyXG4gICAgICBcIi5wbmdcIixcclxuICAgICAgXCIuZ2lmXCIsXHJcbiAgICAgIFwiLnRpZmZcIixcclxuICAgICAgXCIudGlmXCIsXHJcbiAgICAgIFwiLmJtcFwiLFxyXG4gICAgICBcIi5zdmdcIixcclxuICAgICAgXCIuZXBzXCIsXHJcbiAgICAgIFwiLmFpXCIsXHJcbiAgICAgIFwiLnBzZFwiLFxyXG4gICAgICBcIi53ZWJwXCIsXHJcbiAgICAgIFwiLmljb1wiLFxyXG4gICAgICBcIi5qZmlmXCIsXHJcbiAgICAgIFwiLmpwMlwiLFxyXG4gICAgICBcIi5qcHhcIixcclxuICAgIF07XHJcbiAgICByZXR1cm4gaW1hZ2VFeHRlbnNpb25zLnNvbWUoKGV4dCkgPT4gZmlsZU5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRJbWFnZUV4dGVuc2lvbihpbWFnZVR5cGVOYW1lKSB7XHJcbiAgICBjb25zdCB0eXBlTWFwID0ge1xyXG4gICAgICBcIiRJRC9KUEVHXCI6IFwianBnXCIsXHJcbiAgICAgIFwiJElEL1BOR1wiOiBcInBuZ1wiLFxyXG4gICAgICBcIiRJRC9USUZGXCI6IFwidGlmXCIsXHJcbiAgICAgIFwiJElEL0dJRlwiOiBcImdpZlwiLFxyXG4gICAgICBcIiRJRC9CTVBcIjogXCJibXBcIixcclxuICAgIH07XHJcbiAgICByZXR1cm4gdHlwZU1hcFtpbWFnZVR5cGVOYW1lXSB8fCBcImpwZ1wiO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldEltYWdlRXh0ZW5zaW9uRnJvbUZvcm1hdChmb3JtYXQpIHtcclxuICAgIGNvbnN0IGZvcm1hdE1hcCA9IHtcclxuICAgICAgXCIkSUQvSlBFR1wiOiBcImpwZ1wiLFxyXG4gICAgICBcIiRJRC9QTkdcIjogXCJwbmdcIixcclxuICAgICAgXCIkSUQvVElGRlwiOiBcInRpZlwiLFxyXG4gICAgICBcIiRJRC9HSUZcIjogXCJnaWZcIixcclxuICAgICAgXCIkSUQvQk1QXCI6IFwiYm1wXCIsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZvcm1hdE1hcFtmb3JtYXRdIHx8IFwianBnXCI7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZXh0cmFjdEltYWdlTmFtZUZyb21MaW5rKGxpbmtVcmkpIHtcclxuICAgIGlmICghbGlua1VyaSkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gRXh0cmFjdCBmaWxlbmFtZSBmcm9tIHBhdGggbGlrZSBcImZpbGU6QzovVXNlcnMvbGFsby9Eb3dubG9hZHMvVGVzbGEtTW9kZWwtMy5qcGcgMTMzMjUgXCJcclxuICAgIGNvbnN0IG1hdGNoID0gbGlua1VyaS5tYXRjaCgvKFteXFwvXFxcXF0rKVxcLlteLl0rJC8pO1xyXG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXQoZWxlbWVudHMpIHtcclxuICAgIGlmICghZWxlbWVudHMgfHwgZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+aqyBObyBlbGVtZW50cyBwcm92aWRlZCBmb3IgY29vcmRpbmF0ZSBvZmZzZXQgY2FsY3VsYXRpb25cIik7XHJcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbWluWCA9IEluZmluaXR5LFxyXG4gICAgICBtaW5ZID0gSW5maW5pdHk7XHJcbiAgICBsZXQgbWF4U3Ryb2tlV2lkdGggPSAwO1xyXG4gICAgbGV0IHZhbGlkRWxlbWVudHMgPSAwO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBg8J+UjSBBTkFMWVpJTkcgJHtlbGVtZW50cy5sZW5ndGh9IGVsZW1lbnRzIGZvciBjb29yZGluYXRlIG9mZnNldC4uLmBcclxuICAgICk7XHJcblxyXG4gICAgLy8gRmlyc3QgcGFzczogZmluZCBUUlVFIG1pbmltdW0gY29vcmRpbmF0ZXMgYWNyb3NzIGFsbCBlbGVtZW50c1xyXG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgYm91bmRzID0gZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMgfHwgZWxlbWVudC5vcmlnaW5hbEJvdW5kcztcclxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZWxlbWVudC5pdGVtVHJhbnNmb3JtIHx8IHsgdHg6IDAsIHR5OiAwIH07XHJcblxyXG4gICAgICBpZiAoYm91bmRzICYmIChib3VuZHMubGVmdCAhPT0gdW5kZWZpbmVkIHx8IGJvdW5kcy50b3AgIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgZmluYWwgcG9zaXRpb24gYWZ0ZXIgdHJhbnNmb3JtXHJcbiAgICAgICAgY29uc3QgZmluYWxYID0gKGJvdW5kcy5sZWZ0IHx8IDApICsgKHRyYW5zZm9ybS50eCB8fCAwKTtcclxuICAgICAgICBjb25zdCBmaW5hbFkgPSAoYm91bmRzLnRvcCB8fCAwKSArICh0cmFuc2Zvcm0udHkgfHwgMCk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgIEVsZW1lbnQgJHtpbmRleH06IGJvdW5kcygke2JvdW5kcy5sZWZ0fSwgJHtib3VuZHMudG9wfSkgKyB0cmFuc2Zvcm0oJHt0cmFuc2Zvcm0udHh9LCAke3RyYW5zZm9ybS50eX0pID0gZmluYWwoJHtmaW5hbFh9LCAke2ZpbmFsWX0pYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBmaW5hbFgpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBmaW5hbFkpO1xyXG4gICAgICAgIHZhbGlkRWxlbWVudHMrKztcclxuXHJcbiAgICAgICAgLy8gVHJhY2sgbWF4aW11bSBzdHJva2Ugd2lkdGggZm9yIGludGVsbGlnZW50IHBhZGRpbmdcclxuICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IGVsZW1lbnQuc3Ryb2tlV2VpZ2h0IHx8IDA7XHJcbiAgICAgICAgbWF4U3Ryb2tlV2lkdGggPSBNYXRoLm1heChtYXhTdHJva2VXaWR0aCwgc3Ryb2tlV2lkdGgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBFbGVtZW50ICR7aW5kZXh9OiBObyB2YWxpZCBib3VuZHMgLSBza2lwcGluZ2ApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBubyB2YWxpZCBlbGVtZW50cyBmb3VuZFxyXG4gICAgaWYgKHZhbGlkRWxlbWVudHMgPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCLimqDvuI8gIE5vIHZhbGlkIGVsZW1lbnRzIHdpdGggYm91bmRzIGZvdW5kIC0gdXNpbmcgemVybyBvZmZzZXRcIlxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgaW5maW5pdGUgdmFsdWVzIHRvIDAgaWYgbm8gdmFsaWQgY29vcmRpbmF0ZXMgZm91bmRcclxuICAgIGlmIChtaW5YID09PSBJbmZpbml0eSkgbWluWCA9IDA7XHJcbiAgICBpZiAobWluWSA9PT0gSW5maW5pdHkpIG1pblkgPSAwO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBg8J+TiiBBTkFMWVNJUyBDT01QTEVURTogbWluWD0ke21pblh9LCBtaW5ZPSR7bWluWX0sIG1heFN0cm9rZT0ke21heFN0cm9rZVdpZHRofXB4LCB2YWxpZEVsZW1lbnRzPSR7dmFsaWRFbGVtZW50c31gXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFpFUk8tQkFTRUQgT0ZGU0VUIENBTENVTEFUSU9OOlxyXG4gICAgLy8gVGhlIGdvYWwgaXMgdG8gaGF2ZSBOTyBPRkZTRVQgdW5sZXNzIGFic29sdXRlbHkgbmVjZXNzYXJ5IGZvciBuZWdhdGl2ZSBjb29yZGluYXRlc1xyXG4gICAgbGV0IG9mZnNldFggPSAwO1xyXG4gICAgbGV0IG9mZnNldFkgPSAwO1xyXG5cclxuICAgIC8vIE9ubHkgYWRkIG9mZnNldCBpZiBjb29yZGluYXRlcyBhcmUgYWN0dWFsbHkgbmVnYXRpdmVcclxuICAgIGlmIChtaW5YIDwgMCkge1xyXG4gICAgICBvZmZzZXRYID0gTWF0aC5hYnMobWluWCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDinYwgTmVnYXRpdmUgWCBkZXRlY3RlZDogJHttaW5YfSDihpIgYWRkaW5nIG9mZnNldDogJHtvZmZzZXRYfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWluWSA8IDApIHtcclxuICAgICAgb2Zmc2V0WSA9IE1hdGguYWJzKG1pblkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4p2MIE5lZ2F0aXZlIFkgZGV0ZWN0ZWQ6ICR7bWluWX0g4oaSIGFkZGluZyBvZmZzZXQ6ICR7b2Zmc2V0WX1gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIG1pbmltYWwgc3Ryb2tlIHBhZGRpbmcgb25seSBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gb2Zmc2V0XHJcbiAgICBpZiAoKG9mZnNldFggPiAwIHx8IG9mZnNldFkgPiAwKSAmJiBtYXhTdHJva2VXaWR0aCA+IDApIHtcclxuICAgICAgY29uc3Qgc3Ryb2tlUGFkZGluZyA9IE1hdGguY2VpbChtYXhTdHJva2VXaWR0aCAvIDIpO1xyXG4gICAgICBpZiAob2Zmc2V0WCA+IDApIG9mZnNldFggKz0gc3Ryb2tlUGFkZGluZztcclxuICAgICAgaWYgKG9mZnNldFkgPiAwKSBvZmZzZXRZICs9IHN0cm9rZVBhZGRpbmc7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5aM77iPIEFkZGVkIHN0cm9rZSBwYWRkaW5nOiAke3N0cm9rZVBhZGRpbmd9cHhgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+OryBGSU5BTCBPRkZTRVQ6IFg9JHtvZmZzZXRYfSwgWT0ke29mZnNldFl9YCk7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYCAgICR7XHJcbiAgICAgICAgb2Zmc2V0WCA9PT0gMFxyXG4gICAgICAgICAgPyBcIuKchSBQZXJmZWN0ISBObyBYIG9mZnNldCBuZWVkZWRcIlxyXG4gICAgICAgICAgOiBg4pqg77iPIFggb2Zmc2V0OiAke29mZnNldFh9cHggKCR7bWluWH0gd2FzIG5lZ2F0aXZlKWBcclxuICAgICAgfWBcclxuICAgICk7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYCAgICR7XHJcbiAgICAgICAgb2Zmc2V0WSA9PT0gMFxyXG4gICAgICAgICAgPyBcIuKchSBQZXJmZWN0ISBObyBZIG9mZnNldCBuZWVkZWRcIlxyXG4gICAgICAgICAgOiBg4pqg77iPIFkgb2Zmc2V0OiAke29mZnNldFl9cHggKCR7bWluWX0gd2FzIG5lZ2F0aXZlKWBcclxuICAgICAgfWBcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHsgeDogb2Zmc2V0WCwgeTogb2Zmc2V0WSB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHByZWNpc2UgY29vcmRpbmF0ZSBvZmZzZXQgZm9yIHBpeGVsLXBlcmZlY3QgSW5EZXNpZ24gY29vcmRpbmF0ZSBzeXN0ZW0gdHJhbnNmb3JtYXRpb25cclxuICAgKiBUaGlzIGVuc3VyZXMgYWNjdXJhdGUgcG9zaXRpb25pbmcgc2ltaWxhciB0byBwcm9mZXNzaW9uYWwgdG9vbHMgbGlrZSBJTUcuTFkgSW5EZXNpZ25cclxuICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyAtIEFycmF5IG9mIGVsZW1lbnRzIHdpdGggYm91bmRzIGFuZCB0cmFuc2Zvcm1zXHJcbiAgICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gb2Zmc2V0IGZvciBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXRQcmVjaXNlKGVsZW1lbnRzKSB7XHJcbiAgICBpZiAoIWVsZW1lbnRzIHx8IGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCLwn46vIE5vIGVsZW1lbnRzIHByb3ZpZGVkIGZvciBjb29yZGluYXRlIG9mZnNldCBjYWxjdWxhdGlvblwiKTtcclxuICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIvCflI0gQU5BTFlaSU5HXCIsXHJcbiAgICAgIGVsZW1lbnRzLmxlbmd0aCxcclxuICAgICAgXCJlbGVtZW50cyBmb3IgUFJFQ0lTRSBjb29yZGluYXRlIG9mZnNldC4uLlwiXHJcbiAgICApO1xyXG5cclxuICAgIGxldCBtaW5YID0gSW5maW5pdHk7XHJcbiAgICBsZXQgbWluWSA9IEluZmluaXR5O1xyXG4gICAgbGV0IG1heFN0cm9rZSA9IDA7XHJcbiAgICBsZXQgdmFsaWRFbGVtZW50cyA9IDA7XHJcblxyXG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKCFlbGVtZW50Lmdlb21ldHJpY0JvdW5kcyB8fCAhZWxlbWVudC5pdGVtVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgYCAgIOKaoO+4jyBFbGVtZW50ICR7aW5kZXh9IG1pc3NpbmcgYm91bmRzL3RyYW5zZm9ybSAtIHNraXBwaW5nYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgZmluYWwgcG9zaXRpb24gKGJvdW5kcyArIHRyYW5zZm9ybSlcclxuICAgICAgY29uc3QgZmluYWxYID0gZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMubGVmdCArIGVsZW1lbnQuaXRlbVRyYW5zZm9ybS50eDtcclxuICAgICAgY29uc3QgZmluYWxZID0gZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMudG9wICsgZWxlbWVudC5pdGVtVHJhbnNmb3JtLnR5O1xyXG5cclxuICAgICAgLy8gVHJhY2sgc3Ryb2tlIHdpZHRoIGZvciBwcmVjaXNlIHBvc2l0aW9uaW5nXHJcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gZWxlbWVudC5zdHJva2VXZWlnaHQgfHwgMDtcclxuICAgICAgbWF4U3Ryb2tlID0gTWF0aC5tYXgobWF4U3Ryb2tlLCBzdHJva2VXaWR0aCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgICAgRWxlbWVudCAke2luZGV4fTogYm91bmRzKCR7ZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMubGVmdH0sICR7ZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMudG9wfSkgKyB0cmFuc2Zvcm0oJHtlbGVtZW50Lml0ZW1UcmFuc2Zvcm0udHh9LCAke2VsZW1lbnQuaXRlbVRyYW5zZm9ybS50eX0pID0gZmluYWwoJHtmaW5hbFh9LCAke2ZpbmFsWX0pYFxyXG4gICAgICApO1xyXG5cclxuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIGZpbmFsWCk7XHJcbiAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBmaW5hbFkpO1xyXG4gICAgICB2YWxpZEVsZW1lbnRzKys7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgXCLwn5OKIEFOQUxZU0lTIENPTVBMRVRFOlwiLFxyXG4gICAgICBgbWluWD0ke21pblh9LCBtaW5ZPSR7bWluWX0sIG1heFN0cm9rZT0ke21heFN0cm9rZX1weCwgdmFsaWRFbGVtZW50cz0ke3ZhbGlkRWxlbWVudHN9YFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBGSVhFRDogT25seSBhZGQgb2Zmc2V0IGlmIGNvb3JkaW5hdGVzIGFyZSBhY3R1YWxseSBuZWdhdGl2ZVxyXG4gICAgLy8gRG9uJ3QgZm9yY2UgZWxlbWVudHMgdG8gc3RhcnQgYXQgb3JpZ2luIC0gcHJlc2VydmUgSW5EZXNpZ24gcG9zaXRpb25pbmdcclxuICAgIGxldCBvZmZzZXRYID0gMDtcclxuICAgIGxldCBvZmZzZXRZID0gMDtcclxuXHJcbiAgICAvLyBPbmx5IGhhbmRsZSBuZWdhdGl2ZSBjb29yZGluYXRlcyB0aGF0IHdvdWxkIGJlIGNsaXBwZWQgYnkgdGhlIGJyb3dzZXJcclxuICAgIGlmIChtaW5YIDwgMCkge1xyXG4gICAgICBvZmZzZXRYID0gTWF0aC5hYnMobWluWCkgKyBtYXhTdHJva2U7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDinYwgTmVnYXRpdmUgWCBkZXRlY3RlZDogJHttaW5YfSDihpIgYWRkaW5nIG9mZnNldDogJHtvZmZzZXRYfWBcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUG9zaXRpdmUgWCBjb29yZGluYXRlczogJHttaW5YfSDihpIgbm8gb2Zmc2V0IG5lZWRlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtaW5ZIDwgMCkge1xyXG4gICAgICBvZmZzZXRZID0gTWF0aC5hYnMobWluWSkgKyBtYXhTdHJva2U7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDinYwgTmVnYXRpdmUgWSBkZXRlY3RlZDogJHttaW5ZfSDihpIgYWRkaW5nIG9mZnNldDogJHtvZmZzZXRZfWBcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUG9zaXRpdmUgWSBjb29yZGluYXRlczogJHttaW5ZfSDihpIgbm8gb2Zmc2V0IG5lZWRlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZpbmFsT2Zmc2V0ID0geyB4OiBvZmZzZXRYLCB5OiBvZmZzZXRZIH07XHJcblxyXG4gICAgY29uc29sZS5sb2coXCLwn46vIEZJTkFMIFBSRUNJU0UgT0ZGU0VUOlwiLCBgWD0ke29mZnNldFh9LCBZPSR7b2Zmc2V0WX1gKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBgICAgJHtcclxuICAgICAgICBvZmZzZXRYID09PSAwXHJcbiAgICAgICAgICA/IFwi4pyFIFBlcmZlY3QhIE5vIFggb2Zmc2V0IG5lZWRlZFwiXHJcbiAgICAgICAgICA6IGDimqDvuI8gWCBvZmZzZXQ6ICR7b2Zmc2V0WH1weCAoY29tcGVuc2F0aW5nIGZvciBuZWdhdGl2ZSBjb29yZGluYXRlcylgXHJcbiAgICAgIH1gXHJcbiAgICApO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGAgICAke1xyXG4gICAgICAgIG9mZnNldFkgPT09IDBcclxuICAgICAgICAgID8gXCLinIUgUGVyZmVjdCEgTm8gWSBvZmZzZXQgbmVlZGVkXCJcclxuICAgICAgICAgIDogYOKaoO+4jyBZIG9mZnNldDogJHtvZmZzZXRZfXB4IChjb21wZW5zYXRpbmcgZm9yIG5lZ2F0aXZlIGNvb3JkaW5hdGVzKWBcclxuICAgICAgfWBcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsT2Zmc2V0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUJvdW5kc0Zyb21QYXRoKGl0ZW0pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgYm91bmRzIGZyb20gR2VvbWV0cmljQm91bmRzIGF0dHJpYnV0ZVxyXG4gICAgICBpZiAoaXRlbVtcIkBfR2VvbWV0cmljQm91bmRzXCJdKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VHZW9tZXRyaWNCb3VuZHMoaXRlbVtcIkBfR2VvbWV0cmljQm91bmRzXCJdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlbiB0cnkgcGF0aCBnZW9tZXRyeVxyXG4gICAgICBjb25zdCBwYXRoR2VvbWV0cnkgPVxyXG4gICAgICAgIGl0ZW0/LlByb3BlcnRpZXM/LlBhdGhHZW9tZXRyeT8uR2VvbWV0cnlQYXRoVHlwZT8uUGF0aFBvaW50QXJyYXlcclxuICAgICAgICAgID8uUGF0aFBvaW50VHlwZTtcclxuXHJcbiAgICAgIGlmICghcGF0aEdlb21ldHJ5IHx8ICFBcnJheS5pc0FycmF5KHBhdGhHZW9tZXRyeSkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBXYXJuaW5nOiBObyBnZW9tZXRyeSBmb3VuZCBmb3IgJHtpdGVtW1wiQF9TZWxmXCJdfSwgdXNpbmcgaXRlbSB0cmFuc2Zvcm1gXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gaXRlbSB0cmFuc2Zvcm0gaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5wYXJzZVRyYW5zZm9ybShpdGVtW1wiQF9JdGVtVHJhbnNmb3JtXCJdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdG9wOiB0cmFuc2Zvcm0udHkgfHwgMCxcclxuICAgICAgICAgIGxlZnQ6IHRyYW5zZm9ybS50eCB8fCAwLFxyXG4gICAgICAgICAgYm90dG9tOiAodHJhbnNmb3JtLnR5IHx8IDApICsgMTAwLCAvLyBEZWZhdWx0IGhlaWdodFxyXG4gICAgICAgICAgcmlnaHQ6ICh0cmFuc2Zvcm0udHggfHwgMCkgKyAxMDAsIC8vIERlZmF1bHQgd2lkdGhcclxuICAgICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgbWluWCA9IEluZmluaXR5LFxyXG4gICAgICAgIG1pblkgPSBJbmZpbml0eSxcclxuICAgICAgICBtYXhYID0gLUluZmluaXR5LFxyXG4gICAgICAgIG1heFkgPSAtSW5maW5pdHk7XHJcblxyXG4gICAgICBwYXRoR2VvbWV0cnkuZm9yRWFjaCgocG9pbnQpID0+IHtcclxuICAgICAgICBjb25zdCBhbmNob3IgPSBwb2ludFtcIkBfQW5jaG9yXCJdO1xyXG4gICAgICAgIGlmIChhbmNob3IpIHtcclxuICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IGFuY2hvci5zcGxpdChcIiBcIikubWFwKHBhcnNlRmxvYXQpO1xyXG4gICAgICAgICAgaWYgKCFpc05hTih4KSAmJiAhaXNOYU4oeSkpIHtcclxuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xyXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XHJcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcclxuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAobWluWCA9PT0gSW5maW5pdHkgfHwgbWluWSA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBXYXJuaW5nOiBDb3VsZCBub3QgY2FsY3VsYXRlIGJvdW5kcyBmb3IgJHtpdGVtW1wiQF9TZWxmXCJdfWBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgYm90dG9tOiAxMDAsXHJcbiAgICAgICAgICByaWdodDogMTAwLFxyXG4gICAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiBtaW5ZLFxyXG4gICAgICAgIGxlZnQ6IG1pblgsXHJcbiAgICAgICAgYm90dG9tOiBtYXhZLFxyXG4gICAgICAgIHJpZ2h0OiBtYXhYLFxyXG4gICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcclxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY2FsY3VsYXRpbmcgYm91bmRzIGZvciAke2l0ZW1bXCJAX1NlbGZcIl19OmAsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICBib3R0b206IDEwMCxcclxuICAgICAgICByaWdodDogMTAwLFxyXG4gICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgaGVpZ2h0OiAxMDAsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlUmVsYXRpdmVQb3NpdGlvbihcclxuICAgIGZyYW1lQm91bmRzLFxyXG4gICAgY29udGVudEJvdW5kcyxcclxuICAgIGZyYW1lVHJhbnNmb3JtLFxyXG4gICAgY29udGVudFRyYW5zZm9ybVxyXG4gICkge1xyXG4gICAgaWYgKCFmcmFtZUJvdW5kcyB8fCAhY29udGVudEJvdW5kcykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb2Zmc2V0WDogKGNvbnRlbnRCb3VuZHMubGVmdCB8fCAwKSAtIChmcmFtZUJvdW5kcy5sZWZ0IHx8IDApLFxyXG4gICAgICBvZmZzZXRZOiAoY29udGVudEJvdW5kcy50b3AgfHwgMCkgLSAoZnJhbWVCb3VuZHMudG9wIHx8IDApLFxyXG4gICAgICBzY2FsZVg6IGNvbnRlbnRUcmFuc2Zvcm0/LmEgfHwgMSxcclxuICAgICAgc2NhbGVZOiBjb250ZW50VHJhbnNmb3JtPy5kIHx8IDEsXHJcbiAgICAgIHRyYW5zZm9ybURpZmZlcmVuY2U6IHtcclxuICAgICAgICBmcmFtZTogZnJhbWVUcmFuc2Zvcm0sXHJcbiAgICAgICAgY29udGVudDogY29udGVudFRyYW5zZm9ybSxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlR2FwKGZyYW1lQm91bmRzLCBjb250ZW50Qm91bmRzKSB7XHJcbiAgICBpZiAoIWZyYW1lQm91bmRzIHx8ICFjb250ZW50Qm91bmRzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IChjb250ZW50Qm91bmRzLnRvcCB8fCAwKSAtIChmcmFtZUJvdW5kcy50b3AgfHwgMCksXHJcbiAgICAgIGxlZnQ6IChjb250ZW50Qm91bmRzLmxlZnQgfHwgMCkgLSAoZnJhbWVCb3VuZHMubGVmdCB8fCAwKSxcclxuICAgICAgYm90dG9tOiAoZnJhbWVCb3VuZHMuYm90dG9tIHx8IDApIC0gKGNvbnRlbnRCb3VuZHMuYm90dG9tIHx8IDApLFxyXG4gICAgICByaWdodDogKGZyYW1lQm91bmRzLnJpZ2h0IHx8IDApIC0gKGNvbnRlbnRCb3VuZHMucmlnaHQgfHwgMCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUltYWdlUG9zaXRpb25JbkZyYW1lKFxyXG4gICAgZnJhbWVCb3VuZHMsXHJcbiAgICBmcmFtZVRyYW5zZm9ybSxcclxuICAgIHBsYWNlZENvbnRlbnRcclxuICApIHtcclxuICAgIGlmICghZnJhbWVCb3VuZHMgfHwgIXBsYWNlZENvbnRlbnQ/LnRyYW5zZm9ybSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbWFnZVRyYW5zZm9ybSA9IHBsYWNlZENvbnRlbnQudHJhbnNmb3JtO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBpbWFnZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBmcmFtZVxyXG4gICAgY29uc3QgaW1hZ2VYID0gKGZyYW1lQm91bmRzLmxlZnQgfHwgMCkgKyAoaW1hZ2VUcmFuc2Zvcm0udHggfHwgMCk7XHJcbiAgICBjb25zdCBpbWFnZVkgPSAoZnJhbWVCb3VuZHMudG9wIHx8IDApICsgKGltYWdlVHJhbnNmb3JtLnR5IHx8IDApO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBpbWFnZSBzaXplIHdpdGggc2NhbGluZ1xyXG4gICAgY29uc3QgaW1hZ2VXaWR0aCA9IChmcmFtZUJvdW5kcy53aWR0aCB8fCAwKSAqIChpbWFnZVRyYW5zZm9ybS5hIHx8IDEpO1xyXG4gICAgY29uc3QgaW1hZ2VIZWlnaHQgPSAoZnJhbWVCb3VuZHMuaGVpZ2h0IHx8IDApICogKGltYWdlVHJhbnNmb3JtLmQgfHwgMSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogaW1hZ2VYLFxyXG4gICAgICB5OiBpbWFnZVksXHJcbiAgICAgIHdpZHRoOiBpbWFnZVdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGltYWdlSGVpZ2h0LFxyXG4gICAgICBzY2FsZVg6IGltYWdlVHJhbnNmb3JtLmEgfHwgMSxcclxuICAgICAgc2NhbGVZOiBpbWFnZVRyYW5zZm9ybS5kIHx8IDEsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldFhNTFN0cnVjdHVyZShvYmosIG1heERlcHRoID0gMywgY3VycmVudERlcHRoID0gMCkge1xyXG4gICAgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdHJ1Y3R1cmUgPSB7fTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkpIHtcclxuICAgICAgICBzdHJ1Y3R1cmVba2V5XSA9IGBBcnJheVske29ialtrZXldLmxlbmd0aH1dYDtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09IFwib2JqZWN0XCIgJiYgb2JqW2tleV0gIT09IG51bGwpIHtcclxuICAgICAgICBzdHJ1Y3R1cmVba2V5XSA9IHRoaXMuZ2V0WE1MU3RydWN0dXJlKFxyXG4gICAgICAgICAgb2JqW2tleV0sXHJcbiAgICAgICAgICBtYXhEZXB0aCxcclxuICAgICAgICAgIGN1cnJlbnREZXB0aCArIDFcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0cnVjdHVyZVtrZXldID0gdHlwZW9mIG9ialtrZXldO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gc3RydWN0dXJlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGlzRm9ybWF0dGluZ0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB7XHJcbiAgICBjb25zdCBmb3JtYXR0aW5nQXR0cmlidXRlcyA9IFtcclxuICAgICAgXCJAX1BvaW50U2l6ZVwiLFxyXG4gICAgICBcIkBfTGVhZGluZ1wiLFxyXG4gICAgICBcIkBfVHJhY2tpbmdcIixcclxuICAgICAgXCJAX0ZvbnRTdHlsZVwiLFxyXG4gICAgICBcIkBfQXBwbGllZEZvbnRcIixcclxuICAgICAgXCJAX0ZpbGxDb2xvclwiLFxyXG4gICAgICBcIkBfU3Ryb2tlQ29sb3JcIixcclxuICAgICAgXCJAX0p1c3RpZmljYXRpb25cIixcclxuICAgICAgXCJAX0xlZnRJbmRlbnRcIixcclxuICAgICAgXCJAX1JpZ2h0SW5kZW50XCIsXHJcbiAgICAgIFwiQF9GaXJzdExpbmVJbmRlbnRcIixcclxuICAgICAgXCJAX1NwYWNlQmVmb3JlXCIsXHJcbiAgICAgIFwiQF9TcGFjZUFmdGVyXCIsXHJcbiAgICAgIFwiQF9BbGlnbm1lbnRcIixcclxuICAgIF07XHJcbiAgICByZXR1cm4gZm9ybWF0dGluZ0F0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgc2F2ZURlYnVnSW5mbyhkZWJ1Z0luZm8sIGZpbGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVOYW1lLCBKU09OLnN0cmluZ2lmeShkZWJ1Z0luZm8sIG51bGwsIDIpKTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBEZWJ1ZyBpbmZvIHNhdmVkIHRvICR7ZmlsZU5hbWV9YCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIHNhdmluZyBkZWJ1ZyBpbmZvOlwiLCBlcnJvcik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwiRGVidWcgaW5mbyAoZmlyc3QgMjAwMCBjaGFycyk6XCIsXHJcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGVidWdJbmZvLCBudWxsLCAyKS5zdWJzdHJpbmcoMCwgMjAwMClcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSURNTFV0aWxzO1xyXG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJmcyIsIklETUxVdGlscyIsInBhcnNlR2VvbWV0cmljQm91bmRzIiwiYm91bmRzU3RyaW5nIiwiY29uc29sZSIsImxvZyIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiYm91bmRzIiwic3BsaXQiLCJtYXAiLCJwYXJzZUZsb2F0IiwicmVzdWx0IiwicGFyc2VUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1TdHJpbmciLCJhIiwiYiIsImMiLCJkIiwidHgiLCJ0eSIsInZhbHVlcyIsImNhbGN1bGF0ZVJvdGF0aW9uIiwidHJhbnNmb3JtIiwiTWF0aCIsImF0YW4yIiwiUEkiLCJjYWxjdWxhdGVDb3JuZXJzIiwiY29ybmVycyIsInRvcExlZnQiLCJ4IiwieSIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJjb3JuZXIiLCJwb2ludCIsImNteWtUb1JnYiIsIm0iLCJrIiwiciIsInJvdW5kIiwiZyIsInBhcnNlSW5EZXNpZ25Db2xvciIsImNvbG9yUmVmIiwiY215a01hdGNoIiwibWF0Y2giLCJOdW1iZXIiLCJyZ2IiLCJyZ2JNYXRjaCIsInN0YW5kYXJkQ29sb3JzIiwiZGVjb2RlWE1MRW50aXRpZXMiLCJ0ZXh0IiwicmVwbGFjZSIsImNsZWFuVGV4dENvbnRlbnQiLCJjb250ZW50IiwidHJpbSIsInByZXNlcnZlTGluZUJyZWFrcyIsImNsZWFuVGV4dEZvclJlbmRlcmluZyIsInNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nIiwiaGFzUHJvYmxlbWF0aWNUZXh0IiwiaW5jbHVkZXMiLCJKU09OIiwic3RyaW5naWZ5IiwicHJvY2Vzc2VkIiwiY291bnRXb3JkcyIsImZpbHRlciIsIndvcmQiLCJsZW5ndGgiLCJwYXJzZU51bWVyaWMiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIm51bSIsImlzTmFOIiwiaXNJbWFnZUZpbGUiLCJmaWxlTmFtZSIsImltYWdlRXh0ZW5zaW9ucyIsInNvbWUiLCJleHQiLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiZ2V0SW1hZ2VFeHRlbnNpb24iLCJpbWFnZVR5cGVOYW1lIiwidHlwZU1hcCIsImdldEltYWdlRXh0ZW5zaW9uRnJvbUZvcm1hdCIsImZvcm1hdCIsImZvcm1hdE1hcCIsImV4dHJhY3RJbWFnZU5hbWVGcm9tTGluayIsImxpbmtVcmkiLCJjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0IiwiZWxlbWVudHMiLCJtaW5YIiwiSW5maW5pdHkiLCJtaW5ZIiwibWF4U3Ryb2tlV2lkdGgiLCJ2YWxpZEVsZW1lbnRzIiwiZWxlbWVudCIsImluZGV4IiwiZ2VvbWV0cmljQm91bmRzIiwib3JpZ2luYWxCb3VuZHMiLCJpdGVtVHJhbnNmb3JtIiwiZmluYWxYIiwiZmluYWxZIiwibWluIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VXZWlnaHQiLCJtYXgiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImFicyIsInN0cm9rZVBhZGRpbmciLCJjZWlsIiwiY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldFByZWNpc2UiLCJ3YXJuIiwibWF4U3Ryb2tlIiwiZmluYWxPZmZzZXQiLCJjYWxjdWxhdGVCb3VuZHNGcm9tUGF0aCIsIml0ZW0iLCJwYXRoR2VvbWV0cnkiLCJQcm9wZXJ0aWVzIiwiUGF0aEdlb21ldHJ5IiwiR2VvbWV0cnlQYXRoVHlwZSIsIlBhdGhQb2ludEFycmF5IiwiUGF0aFBvaW50VHlwZSIsIkFycmF5IiwiaXNBcnJheSIsIm1heFgiLCJtYXhZIiwiYW5jaG9yIiwiZXJyb3IiLCJjYWxjdWxhdGVSZWxhdGl2ZVBvc2l0aW9uIiwiZnJhbWVCb3VuZHMiLCJjb250ZW50Qm91bmRzIiwiZnJhbWVUcmFuc2Zvcm0iLCJjb250ZW50VHJhbnNmb3JtIiwic2NhbGVYIiwic2NhbGVZIiwidHJhbnNmb3JtRGlmZmVyZW5jZSIsImZyYW1lIiwiY2FsY3VsYXRlR2FwIiwiY2FsY3VsYXRlSW1hZ2VQb3NpdGlvbkluRnJhbWUiLCJwbGFjZWRDb250ZW50IiwiaW1hZ2VUcmFuc2Zvcm0iLCJpbWFnZVgiLCJpbWFnZVkiLCJpbWFnZVdpZHRoIiwiaW1hZ2VIZWlnaHQiLCJnZXRYTUxTdHJ1Y3R1cmUiLCJvYmoiLCJtYXhEZXB0aCIsImN1cnJlbnREZXB0aCIsInN0cnVjdHVyZSIsImtleSIsImlzRm9ybWF0dGluZ0F0dHJpYnV0ZSIsImF0dHJpYnV0ZU5hbWUiLCJmb3JtYXR0aW5nQXR0cmlidXRlcyIsInNhdmVEZWJ1Z0luZm8iLCJkZWJ1Z0luZm8iLCJ3cml0ZUZpbGVTeW5jIiwic3Vic3RyaW5nIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/utils/IDMLUtils.js\n"));

/***/ })

});