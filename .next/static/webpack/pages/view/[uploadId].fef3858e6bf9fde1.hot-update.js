"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/IDMLUtils.js":
/*!********************************!*\
  !*** ./lib/utils/IDMLUtils.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"?82df\");\nclass IDMLUtils {\n    static parseGeometricBounds(boundsString) {\n        console.log(\"DEBUG: boundsString =\", boundsString);\n        if (!boundsString || boundsString === \"undefined\") {\n            console.log(\"Warning: Missing geometric bounds, using defaults\");\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n        const bounds = boundsString.split(\" \").map(parseFloat);\n        const result = {\n            top: bounds[0] || 0,\n            left: bounds[1] || 0,\n            bottom: bounds[2] || 0,\n            right: bounds[3] || 0,\n            width: (bounds[3] || 0) - (bounds[1] || 0),\n            height: (bounds[2] || 0) - (bounds[0] || 0)\n        };\n        console.log(\"Parsed bounds:\", result);\n        return result;\n    }\n    static parseTransform(transformString) {\n        if (!transformString) return {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            tx: 0,\n            ty: 0\n        };\n        const values = transformString.split(\" \").map(parseFloat);\n        return {\n            a: values[0] || 1,\n            b: values[1] || 0,\n            c: values[2] || 0,\n            d: values[3] || 1,\n            tx: values[4] || 0,\n            ty: values[5] || 0 // y translation\n        };\n    }\n    static calculateRotation(transform) {\n        // Calculate rotation angle from transform matrix\n        return Math.atan2(transform.b, transform.a) * (180 / Math.PI);\n    }\n    static calculateCorners(bounds, transform) {\n        const corners = {\n            topLeft: {\n                x: bounds.left,\n                y: bounds.top\n            },\n            topRight: {\n                x: bounds.right,\n                y: bounds.top\n            },\n            bottomLeft: {\n                x: bounds.left,\n                y: bounds.bottom\n            },\n            bottomRight: {\n                x: bounds.right,\n                y: bounds.bottom\n            }\n        };\n        // Apply transformation to corners\n        Object.keys(corners).forEach((corner)=>{\n            const point = corners[corner];\n            corners[corner] = {\n                x: transform.a * point.x + transform.c * point.y + transform.tx,\n                y: transform.b * point.x + transform.d * point.y + transform.ty\n            };\n        });\n        return corners;\n    }\n    static cmykToRgb(c, m, y, k) {\n        // Convert CMYK percentages (0-100) to RGB (0-255)\n        c = c / 100;\n        m = m / 100;\n        y = y / 100;\n        k = k / 100;\n        const r = Math.round(255 * (1 - c) * (1 - k));\n        const g = Math.round(255 * (1 - m) * (1 - k));\n        const b = Math.round(255 * (1 - y) * (1 - k));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    static parseInDesignColor(colorRef) {\n        if (!colorRef || colorRef === \"Color/None\") return null;\n        // Handle CMYK colors\n        const cmykMatch = colorRef.match(/Color\\/C=(\\d+)\\s*M=(\\d+)\\s*Y=(\\d+)\\s*K=(\\d+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map(Number);\n            const rgb = this.cmykToRgb(c, m, y, k);\n            return \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n        }\n        // Handle RGB colors\n        const rgbMatch = colorRef.match(/Color\\/R=(\\d+)\\s*G=(\\d+)\\s*B=(\\d+)/);\n        if (rgbMatch) {\n            const [, r, g, b] = rgbMatch.map(Number);\n            return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n        }\n        // Standard colors\n        const standardColors = {\n            \"Color/Black\": \"rgb(0, 0, 0)\",\n            \"Color/White\": \"rgb(255, 255, 255)\",\n            \"Color/Red\": \"rgb(255, 0, 0)\",\n            \"Color/Green\": \"rgb(0, 255, 0)\",\n            \"Color/Blue\": \"rgb(0, 0, 255)\",\n            \"Color/Cyan\": \"rgb(0, 255, 255)\",\n            \"Color/Magenta\": \"rgb(255, 0, 255)\",\n            \"Color/Yellow\": \"rgb(255, 255, 0)\",\n            \"Color/Paper\": \"rgb(255, 255, 255)\",\n            \"Color/Registration\": \"rgb(0, 0, 0)\"\n        };\n        return standardColors[colorRef] || null;\n    }\n    static decodeXMLEntities(text) {\n        if (!text) return \"\";\n        return text.replace(/&#x000A;/g, \"\\n\") // Line feed\n        .replace(/&#x000D;/g, \"\\r\") // Carriage return\n        .replace(/&#x0009;/g, \"\t\") // Tab\n        .replace(/&#x00A0;/g, \"\\xa0\") // Non-breaking space\n        .replace(/&#x2028;/g, \"\\u2028\") // Line separator\n        .replace(/&#x2029;/g, \"\\u2029\") // Paragraph separator\n        .replace(/&#10;/g, \"\\n\") // Decimal line feed\n        .replace(/&#13;/g, \"\\r\") // Decimal carriage return\n        .replace(/&#9;/g, \"\t\") // Decimal tab\n        .replace(/&#160;/g, \"\\xa0\") // Decimal non-breaking space\n        .replace(/&lt;/g, \"<\") // Less than\n        .replace(/&gt;/g, \">\") // Greater than\n        .replace(/&amp;/g, \"&\") // Ampersand (must be last)\n        .replace(/&quot;/g, '\"') // Quote\n        .replace(/&apos;/g, \"'\"); // Apostrophe\n    }\n    static cleanTextContent(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\t/g, \"    \") // Convert tabs to spaces\n        .replace(/\\u00A0/g, \" \") // Convert non-breaking spaces\n        .replace(/ +/g, \" \") // Collapse multiple spaces\n        .replace(/\\n{3,}/g, \"\\n\\n\") // Maximum 2 consecutive line breaks\n        .trim();\n    }\n    static preserveLineBreaks(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\") // Convert paragraph separators\n        .replace(/\\n{3,}/g, \"\\n\\n\"); // Maximum 2 consecutive line breaks\n    }\n    // NEW: Clean up excessive line breaks to prevent text overflow  \n    static cleanTextForRendering(text) {\n        if (!text) return \"\";\n        return text// Remove excessive line breaks (more than 2 consecutive)\n        .replace(/\\n{3,}/g, \"\\n\\n\")// Remove line breaks followed by only whitespace and then another line break\n        .replace(/\\n\\s*\\n/g, \"\\n\\n\")// Remove trailing whitespace on lines (but preserve single spaces between words)\n        .replace(/[ \\t]+\\n/g, \"\\n\")// Clean up multiple spaces (but preserve single spaces - IMPORTANT for word separation)\n        .replace(/[ \\t]{3,}/g, \"  \") // Reduce 3+ spaces to 2 spaces max\n        // Remove leading/trailing whitespace\n        .trim();\n    }\n    // ENHANCED: Better line break processing that preserves word spaces\n    static sophisticatedLineBreakProcessing(content) {\n        if (!content) return \"\";\n        // DEBUG: Track if problematic text is being processed\n        const hasProblematicText = content.includes(\"pavoluptusda\") || content.includes(\"pa\") && content.includes(\"voluptusda\");\n        if (hasProblematicText) {\n            console.log(\"\\uD83D\\uDD27 IDMLUtils.sophisticatedLineBreakProcessing:\");\n            console.log(\"   - Input:\", JSON.stringify(content));\n        }\n        // First clean up the content but preserve word spaces\n        let processed = this.cleanTextForRendering(content);\n        if (hasProblematicText) {\n            console.log(\"   - After cleanTextForRendering:\", JSON.stringify(processed));\n        }\n        // Normalize line breaks but don't touch word spaces\n        processed = processed.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\") // Convert paragraph separators to double breaks\n        .replace(/\\u000A/g, \"\\n\"); // Convert explicit line feed characters\n        // Ensure paragraph breaks are properly spaced\n        processed = processed.replace(/\\n\\n+/g, \"\\n\\n\");\n        if (hasProblematicText) {\n            console.log(\"   - Final output:\", JSON.stringify(processed));\n            console.log('   - Contains \"pa voluptusda\":', processed.includes(\"pa voluptusda\"));\n            console.log('   - Contains \"pavoluptusda\":', processed.includes(\"pavoluptusda\"));\n        }\n        return processed;\n    }\n    static countWords(text) {\n        return text.split(/\\s+/).filter((word)=>word.length > 0).length;\n    }\n    static parseNumeric(value) {\n        if (value === null || value === undefined || value === \"\") return null;\n        const num = parseFloat(value);\n        return isNaN(num) ? null : num;\n    }\n    static isImageFile(fileName) {\n        const imageExtensions = [\n            \".jpg\",\n            \".jpeg\",\n            \".png\",\n            \".gif\",\n            \".tiff\",\n            \".tif\",\n            \".bmp\",\n            \".svg\",\n            \".eps\",\n            \".ai\",\n            \".psd\",\n            \".webp\",\n            \".ico\",\n            \".jfif\",\n            \".jp2\",\n            \".jpx\"\n        ];\n        return imageExtensions.some((ext)=>fileName.toLowerCase().endsWith(ext));\n    }\n    static getImageExtension(imageTypeName) {\n        const typeMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return typeMap[imageTypeName] || \"jpg\";\n    }\n    static getImageExtensionFromFormat(format) {\n        const formatMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return formatMap[format] || \"jpg\";\n    }\n    static extractImageNameFromLink(linkUri) {\n        if (!linkUri) return null;\n        // Extract filename from path like \"file:C:/Users/lalo/Downloads/Tesla-Model-3.jpg 13325 \"\n        const match = linkUri.match(/([^\\/\\\\]+)\\.[^.]+$/);\n        return match ? match[1] : null;\n    }\n    static calculateCoordinateOffset(elements) {\n        let minX = 0, minY = 0;\n        let maxStrokeWidth = 0;\n        // First pass: find minimum coordinates and maximum stroke width\n        elements.forEach((element)=>{\n            const bounds = element.geometricBounds || element.originalBounds;\n            const transform = element.itemTransform || {\n                tx: 0,\n                ty: 0\n            };\n            if (bounds) {\n                // Calculate final position after transform\n                const finalX = (bounds.left || 0) + (transform.tx || 0);\n                const finalY = (bounds.top || 0) + (transform.ty || 0);\n                minX = Math.min(minX, finalX);\n                minY = Math.min(minY, finalY);\n                // Track maximum stroke width for intelligent padding\n                const strokeWidth = element.strokeWeight || 0;\n                maxStrokeWidth = Math.max(maxStrokeWidth, strokeWidth);\n            }\n        });\n        // ULTRA-SMART PADDING CALCULATION:\n        // - No padding if no strokes exist or strokes are minimal\n        // - Half of max stroke width to prevent stroke clipping\n        // - Only when actually needed (negative coordinates)\n        let intelligentPadding = 0;\n        if (maxStrokeWidth > 0) {\n            intelligentPadding = Math.ceil(maxStrokeWidth / 2); // Half stroke width to prevent clipping\n        } else {\n            intelligentPadding = 0; // No padding needed if no strokes\n        }\n        // PERFECT OFFSET CALCULATION:\n        // - Zero offset if all coordinates are positive (most common case)\n        // - Exact offset to make negative coordinates positive + minimal stroke padding only when needed\n        const offsetX = minX < 0 ? Math.abs(minX) + intelligentPadding : 0;\n        const offsetY = minY < 0 ? Math.abs(minY) + intelligentPadding : 0;\n        console.log(\"\\uD83C\\uDFAF SMART OFFSET: X: \".concat(offsetX, \", Y: \").concat(offsetY, \" (minX: \").concat(minX, \", minY: \").concat(minY, \")\"));\n        console.log(\"   Max stroke width: \".concat(maxStrokeWidth, \"px → intelligent padding: \").concat(intelligentPadding, \"px\"));\n        console.log(\"   \".concat(minX < 0 ? \"⚠️  Negative X: \".concat(minX, \" → offset \").concat(Math.abs(minX), \" + padding \").concat(intelligentPadding) : \"✅ X positive → no offset\"));\n        console.log(\"   \".concat(minY < 0 ? \"⚠️  Negative Y: \".concat(minY, \" → offset \").concat(Math.abs(minY), \" + padding \").concat(intelligentPadding) : \"✅ Y positive → no offset\"));\n        return {\n            x: offsetX,\n            y: offsetY\n        };\n    }\n    static calculateBoundsFromPath(item) {\n        try {\n            var _item_Properties_PathGeometry_GeometryPathType_PathPointArray, _item_Properties_PathGeometry_GeometryPathType, _item_Properties_PathGeometry, _item_Properties;\n            // First try to get bounds from GeometricBounds attribute\n            if (item[\"@_GeometricBounds\"]) {\n                return this.parseGeometricBounds(item[\"@_GeometricBounds\"]);\n            }\n            // Then try path geometry\n            const pathGeometry = item === null || item === void 0 ? void 0 : (_item_Properties = item.Properties) === null || _item_Properties === void 0 ? void 0 : (_item_Properties_PathGeometry = _item_Properties.PathGeometry) === null || _item_Properties_PathGeometry === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType = _item_Properties_PathGeometry.GeometryPathType) === null || _item_Properties_PathGeometry_GeometryPathType === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType_PathPointArray = _item_Properties_PathGeometry_GeometryPathType.PathPointArray) === null || _item_Properties_PathGeometry_GeometryPathType_PathPointArray === void 0 ? void 0 : _item_Properties_PathGeometry_GeometryPathType_PathPointArray.PathPointType;\n            if (!pathGeometry || !Array.isArray(pathGeometry)) {\n                console.log(\"Warning: No geometry found for \".concat(item[\"@_Self\"], \", using item transform\"));\n                // Fallback to item transform if available\n                const transform = this.parseTransform(item[\"@_ItemTransform\"]);\n                return {\n                    top: transform.ty || 0,\n                    left: transform.tx || 0,\n                    bottom: (transform.ty || 0) + 100,\n                    right: (transform.tx || 0) + 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n            pathGeometry.forEach((point)=>{\n                const anchor = point[\"@_Anchor\"];\n                if (anchor) {\n                    const [x, y] = anchor.split(\" \").map(parseFloat);\n                    if (!isNaN(x) && !isNaN(y)) {\n                        minX = Math.min(minX, x);\n                        maxX = Math.max(maxX, x);\n                        minY = Math.min(minY, y);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            });\n            if (minX === Infinity || minY === Infinity) {\n                console.log(\"Warning: Could not calculate bounds for \".concat(item[\"@_Self\"]));\n                return {\n                    top: 0,\n                    left: 0,\n                    bottom: 100,\n                    right: 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            return {\n                top: minY,\n                left: minX,\n                bottom: maxY,\n                right: maxX,\n                width: maxX - minX,\n                height: maxY - minY\n            };\n        } catch (error) {\n            console.error(\"Error calculating bounds for \".concat(item[\"@_Self\"], \":\"), error);\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n    }\n    static calculateRelativePosition(frameBounds, contentBounds, frameTransform, contentTransform) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            offsetX: (contentBounds.left || 0) - (frameBounds.left || 0),\n            offsetY: (contentBounds.top || 0) - (frameBounds.top || 0),\n            scaleX: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.a) || 1,\n            scaleY: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.d) || 1,\n            transformDifference: {\n                frame: frameTransform,\n                content: contentTransform\n            }\n        };\n    }\n    static calculateGap(frameBounds, contentBounds) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            top: (contentBounds.top || 0) - (frameBounds.top || 0),\n            left: (contentBounds.left || 0) - (frameBounds.left || 0),\n            bottom: (frameBounds.bottom || 0) - (contentBounds.bottom || 0),\n            right: (frameBounds.right || 0) - (contentBounds.right || 0)\n        };\n    }\n    static calculateImagePositionInFrame(frameBounds, frameTransform, placedContent) {\n        if (!frameBounds || !(placedContent === null || placedContent === void 0 ? void 0 : placedContent.transform)) {\n            return null;\n        }\n        const imageTransform = placedContent.transform;\n        // Calculate image position relative to frame\n        const imageX = (frameBounds.left || 0) + (imageTransform.tx || 0);\n        const imageY = (frameBounds.top || 0) + (imageTransform.ty || 0);\n        // Calculate image size with scaling\n        const imageWidth = (frameBounds.width || 0) * (imageTransform.a || 1);\n        const imageHeight = (frameBounds.height || 0) * (imageTransform.d || 1);\n        return {\n            x: imageX,\n            y: imageY,\n            width: imageWidth,\n            height: imageHeight,\n            scaleX: imageTransform.a || 1,\n            scaleY: imageTransform.d || 1\n        };\n    }\n    static getXMLStructure(obj) {\n        let maxDepth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        if (currentDepth >= maxDepth || typeof obj !== \"object\" || obj === null) {\n            return typeof obj;\n        }\n        const structure = {};\n        Object.keys(obj).forEach((key)=>{\n            if (Array.isArray(obj[key])) {\n                structure[key] = \"Array[\".concat(obj[key].length, \"]\");\n            } else if (typeof obj[key] === \"object\" && obj[key] !== null) {\n                structure[key] = this.getXMLStructure(obj[key], maxDepth, currentDepth + 1);\n            } else {\n                structure[key] = typeof obj[key];\n            }\n        });\n        return structure;\n    }\n    static isFormattingAttribute(attributeName) {\n        const formattingAttributes = [\n            \"@_PointSize\",\n            \"@_Leading\",\n            \"@_Tracking\",\n            \"@_FontStyle\",\n            \"@_AppliedFont\",\n            \"@_FillColor\",\n            \"@_StrokeColor\",\n            \"@_Justification\",\n            \"@_LeftIndent\",\n            \"@_RightIndent\",\n            \"@_FirstLineIndent\",\n            \"@_SpaceBefore\",\n            \"@_SpaceAfter\",\n            \"@_Alignment\"\n        ];\n        return formattingAttributes.includes(attributeName);\n    }\n    static saveDebugInfo(debugInfo, fileName) {\n        try {\n            fs.writeFileSync(fileName, JSON.stringify(debugInfo, null, 2));\n            console.log(\"✅ Debug info saved to \".concat(fileName));\n        } catch (error) {\n            console.error(\"❌ Error saving debug info:\", error);\n            console.log(\"Debug info (first 2000 chars):\", JSON.stringify(debugInfo, null, 2).substring(0, 2000));\n        }\n    }\n}\nmodule.exports = IDMLUtils;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y2s6Ly9fTl9FLy4vbGliL3V0aWxzL0lETUxVdGlscy5qcz84ZDJmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcclxuXHJcbmNsYXNzIElETUxVdGlscyB7XHJcbiAgc3RhdGljIHBhcnNlR2VvbWV0cmljQm91bmRzKGJvdW5kc1N0cmluZykge1xyXG4gICAgY29uc29sZS5sb2coJ0RFQlVHOiBib3VuZHNTdHJpbmcgPScsIGJvdW5kc1N0cmluZyk7XHJcbiAgICBpZiAoIWJvdW5kc1N0cmluZyB8fCBib3VuZHNTdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiBNaXNzaW5nIGdlb21ldHJpYyBib3VuZHMsIHVzaW5nIGRlZmF1bHRzJyk7XHJcbiAgICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiAxMDAsIHJpZ2h0OiAxMDAsIHdpZHRoOiAxMDAsIGhlaWdodDogMTAwIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGJvdW5kcyA9IGJvdW5kc1N0cmluZy5zcGxpdCgnICcpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgdG9wOiBib3VuZHNbMF0gfHwgMCxcclxuICAgICAgbGVmdDogYm91bmRzWzFdIHx8IDAsXHJcbiAgICAgIGJvdHRvbTogYm91bmRzWzJdIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBib3VuZHNbM10gfHwgMCxcclxuICAgICAgd2lkdGg6IChib3VuZHNbM10gfHwgMCkgLSAoYm91bmRzWzFdIHx8IDApLFxyXG4gICAgICBoZWlnaHQ6IChib3VuZHNbMl0gfHwgMCkgLSAoYm91bmRzWzBdIHx8IDApXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnUGFyc2VkIGJvdW5kczonLCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm1TdHJpbmcpIHtcclxuICAgIGlmICghdHJhbnNmb3JtU3RyaW5nKSByZXR1cm4geyBhOiAxLCBiOiAwLCBjOiAwLCBkOiAxLCB0eDogMCwgdHk6IDAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgdmFsdWVzID0gdHJhbnNmb3JtU3RyaW5nLnNwbGl0KCcgJykubWFwKHBhcnNlRmxvYXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYTogdmFsdWVzWzBdIHx8IDEsICAgLy8geCBzY2FsZVxyXG4gICAgICBiOiB2YWx1ZXNbMV0gfHwgMCwgICAvLyB5IHNrZXdcclxuICAgICAgYzogdmFsdWVzWzJdIHx8IDAsICAgLy8geCBza2V3XHJcbiAgICAgIGQ6IHZhbHVlc1szXSB8fCAxLCAgIC8vIHkgc2NhbGVcclxuICAgICAgdHg6IHZhbHVlc1s0XSB8fCAwLCAgLy8geCB0cmFuc2xhdGlvblxyXG4gICAgICB0eTogdmFsdWVzWzVdIHx8IDAgICAvLyB5IHRyYW5zbGF0aW9uXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZVJvdGF0aW9uKHRyYW5zZm9ybSkge1xyXG4gICAgLy8gQ2FsY3VsYXRlIHJvdGF0aW9uIGFuZ2xlIGZyb20gdHJhbnNmb3JtIG1hdHJpeFxyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIodHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5hKSAqICgxODAgLyBNYXRoLlBJKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVDb3JuZXJzKGJvdW5kcywgdHJhbnNmb3JtKSB7XHJcbiAgICBjb25zdCBjb3JuZXJzID0ge1xyXG4gICAgICB0b3BMZWZ0OiB7IHg6IGJvdW5kcy5sZWZ0LCB5OiBib3VuZHMudG9wIH0sXHJcbiAgICAgIHRvcFJpZ2h0OiB7IHg6IGJvdW5kcy5yaWdodCwgeTogYm91bmRzLnRvcCB9LFxyXG4gICAgICBib3R0b21MZWZ0OiB7IHg6IGJvdW5kcy5sZWZ0LCB5OiBib3VuZHMuYm90dG9tIH0sXHJcbiAgICAgIGJvdHRvbVJpZ2h0OiB7IHg6IGJvdW5kcy5yaWdodCwgeTogYm91bmRzLmJvdHRvbSB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbiB0byBjb3JuZXJzXHJcbiAgICBPYmplY3Qua2V5cyhjb3JuZXJzKS5mb3JFYWNoKGNvcm5lciA9PiB7XHJcbiAgICAgIGNvbnN0IHBvaW50ID0gY29ybmVyc1tjb3JuZXJdO1xyXG4gICAgICBjb3JuZXJzW2Nvcm5lcl0gPSB7XHJcbiAgICAgICAgeDogKHRyYW5zZm9ybS5hICogcG9pbnQueCkgKyAodHJhbnNmb3JtLmMgKiBwb2ludC55KSArIHRyYW5zZm9ybS50eCxcclxuICAgICAgICB5OiAodHJhbnNmb3JtLmIgKiBwb2ludC54KSArICh0cmFuc2Zvcm0uZCAqIHBvaW50LnkpICsgdHJhbnNmb3JtLnR5XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGNvcm5lcnM7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY215a1RvUmdiKGMsIG0sIHksIGspIHtcclxuICAgIC8vIENvbnZlcnQgQ01ZSyBwZXJjZW50YWdlcyAoMC0xMDApIHRvIFJHQiAoMC0yNTUpXHJcbiAgICBjID0gYyAvIDEwMDtcclxuICAgIG0gPSBtIC8gMTAwO1xyXG4gICAgeSA9IHkgLyAxMDA7XHJcbiAgICBrID0gayAvIDEwMDtcclxuXHJcbiAgICBjb25zdCByID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIGMpICogKDEgLSBrKSk7XHJcbiAgICBjb25zdCBnID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIG0pICogKDEgLSBrKSk7XHJcbiAgICBjb25zdCBiID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIHkpICogKDEgLSBrKSk7XHJcblxyXG4gICAgcmV0dXJuIHsgciwgZywgYiB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlSW5EZXNpZ25Db2xvcihjb2xvclJlZikge1xyXG4gICAgaWYgKCFjb2xvclJlZiB8fCBjb2xvclJlZiA9PT0gJ0NvbG9yL05vbmUnKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIENNWUsgY29sb3JzXHJcbiAgICBjb25zdCBjbXlrTWF0Y2ggPSBjb2xvclJlZi5tYXRjaCgvQ29sb3JcXC9DPShcXGQrKVxccypNPShcXGQrKVxccypZPShcXGQrKVxccypLPShcXGQrKS8pO1xyXG4gICAgaWYgKGNteWtNYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCBjLCBtLCB5LCBrXSA9IGNteWtNYXRjaC5tYXAoTnVtYmVyKTtcclxuICAgICAgY29uc3QgcmdiID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cmdiLnJ9LCAke3JnYi5nfSwgJHtyZ2IuYn0pYDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIFJHQiBjb2xvcnNcclxuICAgIGNvbnN0IHJnYk1hdGNoID0gY29sb3JSZWYubWF0Y2goL0NvbG9yXFwvUj0oXFxkKylcXHMqRz0oXFxkKylcXHMqQj0oXFxkKykvKTtcclxuICAgIGlmIChyZ2JNYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCByLCBnLCBiXSA9IHJnYk1hdGNoLm1hcChOdW1iZXIpO1xyXG4gICAgICByZXR1cm4gYHJnYigke3J9LCAke2d9LCAke2J9KWA7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFN0YW5kYXJkIGNvbG9yc1xyXG4gICAgY29uc3Qgc3RhbmRhcmRDb2xvcnMgPSB7XHJcbiAgICAgICdDb2xvci9CbGFjayc6ICdyZ2IoMCwgMCwgMCknLFxyXG4gICAgICAnQ29sb3IvV2hpdGUnOiAncmdiKDI1NSwgMjU1LCAyNTUpJyxcclxuICAgICAgJ0NvbG9yL1JlZCc6ICdyZ2IoMjU1LCAwLCAwKScsXHJcbiAgICAgICdDb2xvci9HcmVlbic6ICdyZ2IoMCwgMjU1LCAwKScsXHJcbiAgICAgICdDb2xvci9CbHVlJzogJ3JnYigwLCAwLCAyNTUpJyxcclxuICAgICAgJ0NvbG9yL0N5YW4nOiAncmdiKDAsIDI1NSwgMjU1KScsXHJcbiAgICAgICdDb2xvci9NYWdlbnRhJzogJ3JnYigyNTUsIDAsIDI1NSknLFxyXG4gICAgICAnQ29sb3IvWWVsbG93JzogJ3JnYigyNTUsIDI1NSwgMCknLFxyXG4gICAgICAnQ29sb3IvUGFwZXInOiAncmdiKDI1NSwgMjU1LCAyNTUpJyxcclxuICAgICAgJ0NvbG9yL1JlZ2lzdHJhdGlvbic6ICdyZ2IoMCwgMCwgMCknXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4gc3RhbmRhcmRDb2xvcnNbY29sb3JSZWZdIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZGVjb2RlWE1MRW50aXRpZXModGV4dCkge1xyXG4gICAgaWYgKCF0ZXh0KSByZXR1cm4gJyc7XHJcbiAgICBcclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMDBBOy9nLCAnXFxuJykgICAgICAvLyBMaW5lIGZlZWRcclxuICAgICAgLnJlcGxhY2UoLyYjeDAwMEQ7L2csICdcXHInKSAgICAgIC8vIENhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiN4MDAwOTsvZywgJ1xcdCcpICAgICAgLy8gVGFiXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMEEwOy9nLCAnXFx1MDBBMCcpICAvLyBOb24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgLnJlcGxhY2UoLyYjeDIwMjg7L2csICdcXHUyMDI4JykgIC8vIExpbmUgc2VwYXJhdG9yXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gyMDI5Oy9nLCAnXFx1MjAyOScpICAvLyBQYXJhZ3JhcGggc2VwYXJhdG9yXHJcbiAgICAgIC5yZXBsYWNlKC8mIzEwOy9nLCAnXFxuJykgICAgICAgICAvLyBEZWNpbWFsIGxpbmUgZmVlZFxyXG4gICAgICAucmVwbGFjZSgvJiMxMzsvZywgJ1xccicpICAgICAgICAgLy8gRGVjaW1hbCBjYXJyaWFnZSByZXR1cm5cclxuICAgICAgLnJlcGxhY2UoLyYjOTsvZywgJ1xcdCcpICAgICAgICAgIC8vIERlY2ltYWwgdGFiXHJcbiAgICAgIC5yZXBsYWNlKC8mIzE2MDsvZywgJ1xcdTAwQTAnKSAgICAvLyBEZWNpbWFsIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpICAgICAgICAgICAvLyBMZXNzIHRoYW5cclxuICAgICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKSAgICAgICAgICAgLy8gR3JlYXRlciB0aGFuXHJcbiAgICAgIC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpICAgICAgICAgIC8vIEFtcGVyc2FuZCAobXVzdCBiZSBsYXN0KVxyXG4gICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpICAgICAgICAgLy8gUXVvdGVcclxuICAgICAgLnJlcGxhY2UoLyZhcG9zOy9nLCBcIidcIik7ICAgICAgICAvLyBBcG9zdHJvcGhlXHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2xlYW5UZXh0Q29udGVudChjb250ZW50KSB7XHJcbiAgICByZXR1cm4gY29udGVudFxyXG4gICAgICAucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKSAgICAgIC8vIE5vcm1hbGl6ZSBXaW5kb3dzIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcbicpICAgICAgICAvLyBOb3JtYWxpemUgb2xkIE1hYyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJykgICAgICAvLyBDb252ZXJ0IHRhYnMgdG8gc3BhY2VzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUwMEEwL2csICcgJykgICAgIC8vIENvbnZlcnQgbm9uLWJyZWFraW5nIHNwYWNlc1xyXG4gICAgICAucmVwbGFjZSgvICsvZywgJyAnKSAgICAgICAgIC8vIENvbGxhcHNlIG11bHRpcGxlIHNwYWNlc1xyXG4gICAgICAucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJykgIC8vIE1heGltdW0gMiBjb25zZWN1dGl2ZSBsaW5lIGJyZWFrc1xyXG4gICAgICAudHJpbSgpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHByZXNlcnZlTGluZUJyZWFrcyhjb250ZW50KSB7XHJcbiAgICByZXR1cm4gY29udGVudFxyXG4gICAgICAucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKSAgICAgIC8vIE5vcm1hbGl6ZSBXaW5kb3dzIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcbicpICAgICAgICAvLyBOb3JtYWxpemUgb2xkIE1hYyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxuJykgICAgLy8gQ29udmVydCBsaW5lIHNlcGFyYXRvcnNcclxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcblxcbicpICAvLyBDb252ZXJ0IHBhcmFncmFwaCBzZXBhcmF0b3JzXHJcbiAgICAgIC5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKTsgLy8gTWF4aW11bSAyIGNvbnNlY3V0aXZlIGxpbmUgYnJlYWtzXHJcbiAgfVxyXG5cclxuICAvLyBORVc6IENsZWFuIHVwIGV4Y2Vzc2l2ZSBsaW5lIGJyZWFrcyB0byBwcmV2ZW50IHRleHQgb3ZlcmZsb3cgIFxyXG4gIHN0YXRpYyBjbGVhblRleHRGb3JSZW5kZXJpbmcodGV4dCkge1xyXG4gICAgaWYgKCF0ZXh0KSByZXR1cm4gJyc7XHJcbiAgICBcclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgIC8vIFJlbW92ZSBleGNlc3NpdmUgbGluZSBicmVha3MgKG1vcmUgdGhhbiAyIGNvbnNlY3V0aXZlKVxyXG4gICAgICAucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJylcclxuICAgICAgLy8gUmVtb3ZlIGxpbmUgYnJlYWtzIGZvbGxvd2VkIGJ5IG9ubHkgd2hpdGVzcGFjZSBhbmQgdGhlbiBhbm90aGVyIGxpbmUgYnJlYWtcclxuICAgICAgLnJlcGxhY2UoL1xcblxccypcXG4vZywgJ1xcblxcbicpXHJcbiAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG9uIGxpbmVzIChidXQgcHJlc2VydmUgc2luZ2xlIHNwYWNlcyBiZXR3ZWVuIHdvcmRzKVxyXG4gICAgICAucmVwbGFjZSgvWyBcXHRdK1xcbi9nLCAnXFxuJylcclxuICAgICAgLy8gQ2xlYW4gdXAgbXVsdGlwbGUgc3BhY2VzIChidXQgcHJlc2VydmUgc2luZ2xlIHNwYWNlcyAtIElNUE9SVEFOVCBmb3Igd29yZCBzZXBhcmF0aW9uKVxyXG4gICAgICAucmVwbGFjZSgvWyBcXHRdezMsfS9nLCAnICAnKSAvLyBSZWR1Y2UgMysgc3BhY2VzIHRvIDIgc3BhY2VzIG1heFxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXHJcbiAgICAgIC50cmltKCk7XHJcbiAgfVxyXG5cclxuICAvLyBFTkhBTkNFRDogQmV0dGVyIGxpbmUgYnJlYWsgcHJvY2Vzc2luZyB0aGF0IHByZXNlcnZlcyB3b3JkIHNwYWNlc1xyXG4gIHN0YXRpYyBzb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyhjb250ZW50KSB7XHJcbiAgICBpZiAoIWNvbnRlbnQpIHJldHVybiAnJztcclxuICAgIFxyXG4gICAgLy8gREVCVUc6IFRyYWNrIGlmIHByb2JsZW1hdGljIHRleHQgaXMgYmVpbmcgcHJvY2Vzc2VkXHJcbiAgICBjb25zdCBoYXNQcm9ibGVtYXRpY1RleHQgPSBjb250ZW50LmluY2x1ZGVzKCdwYXZvbHVwdHVzZGEnKSB8fCAoY29udGVudC5pbmNsdWRlcygncGEnKSAmJiBjb250ZW50LmluY2x1ZGVzKCd2b2x1cHR1c2RhJykpO1xyXG4gICAgaWYgKGhhc1Byb2JsZW1hdGljVGV4dCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UpyBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3Npbmc6Jyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIElucHV0OicsIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRmlyc3QgY2xlYW4gdXAgdGhlIGNvbnRlbnQgYnV0IHByZXNlcnZlIHdvcmQgc3BhY2VzXHJcbiAgICBsZXQgcHJvY2Vzc2VkID0gdGhpcy5jbGVhblRleHRGb3JSZW5kZXJpbmcoY29udGVudCk7XHJcbiAgICBcclxuICAgIGlmIChoYXNQcm9ibGVtYXRpY1RleHQpIHtcclxuICAgICAgY29uc29sZS5sb2coJyAgIC0gQWZ0ZXIgY2xlYW5UZXh0Rm9yUmVuZGVyaW5nOicsIEpTT04uc3RyaW5naWZ5KHByb2Nlc3NlZCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBOb3JtYWxpemUgbGluZSBicmVha3MgYnV0IGRvbid0IHRvdWNoIHdvcmQgc3BhY2VzXHJcbiAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWRcclxuICAgICAgLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykgICAgICAvLyBOb3JtYWxpemUgV2luZG93cyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXG4nKSAgICAgICAgLy8gTm9ybWFsaXplIG9sZCBNYWMgbGluZSBicmVha3NcclxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcbicpICAgIC8vIENvbnZlcnQgbGluZSBzZXBhcmF0b3JzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXG5cXG4nKSAgLy8gQ29udmVydCBwYXJhZ3JhcGggc2VwYXJhdG9ycyB0byBkb3VibGUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUwMDBBL2csICdcXG4nKTsgICAvLyBDb252ZXJ0IGV4cGxpY2l0IGxpbmUgZmVlZCBjaGFyYWN0ZXJzXHJcbiAgICBcclxuICAgIC8vIEVuc3VyZSBwYXJhZ3JhcGggYnJlYWtzIGFyZSBwcm9wZXJseSBzcGFjZWRcclxuICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5yZXBsYWNlKC9cXG5cXG4rL2csICdcXG5cXG4nKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc1Byb2JsZW1hdGljVGV4dCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBGaW5hbCBvdXRwdXQ6JywgSlNPTi5zdHJpbmdpZnkocHJvY2Vzc2VkKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIENvbnRhaW5zIFwicGEgdm9sdXB0dXNkYVwiOicsIHByb2Nlc3NlZC5pbmNsdWRlcygncGEgdm9sdXB0dXNkYScpKTtcclxuICAgICAgY29uc29sZS5sb2coJyAgIC0gQ29udGFpbnMgXCJwYXZvbHVwdHVzZGFcIjonLCBwcm9jZXNzZWQuaW5jbHVkZXMoJ3Bhdm9sdXB0dXNkYScpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHByb2Nlc3NlZDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjb3VudFdvcmRzKHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0LnNwbGl0KC9cXHMrLykuZmlsdGVyKHdvcmQgPT4gd29yZC5sZW5ndGggPiAwKS5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VOdW1lcmljKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICByZXR1cm4gaXNOYU4obnVtKSA/IG51bGwgOiBudW07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaXNJbWFnZUZpbGUoZmlsZU5hbWUpIHtcclxuICAgIGNvbnN0IGltYWdlRXh0ZW5zaW9ucyA9IFtcclxuICAgICAgJy5qcGcnLCAnLmpwZWcnLCAnLnBuZycsICcuZ2lmJywgJy50aWZmJywgJy50aWYnLCAnLmJtcCcsICcuc3ZnJywgXHJcbiAgICAgICcuZXBzJywgJy5haScsICcucHNkJywgJy53ZWJwJywgJy5pY28nLCAnLmpmaWYnLCAnLmpwMicsICcuanB4J1xyXG4gICAgXTtcclxuICAgIHJldHVybiBpbWFnZUV4dGVuc2lvbnMuc29tZShleHQgPT4gZmlsZU5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRJbWFnZUV4dGVuc2lvbihpbWFnZVR5cGVOYW1lKSB7XHJcbiAgICBjb25zdCB0eXBlTWFwID0ge1xyXG4gICAgICAnJElEL0pQRUcnOiAnanBnJyxcclxuICAgICAgJyRJRC9QTkcnOiAncG5nJywgXHJcbiAgICAgICckSUQvVElGRic6ICd0aWYnLFxyXG4gICAgICAnJElEL0dJRic6ICdnaWYnLFxyXG4gICAgICAnJElEL0JNUCc6ICdibXAnXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHR5cGVNYXBbaW1hZ2VUeXBlTmFtZV0gfHwgJ2pwZyc7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0SW1hZ2VFeHRlbnNpb25Gcm9tRm9ybWF0KGZvcm1hdCkge1xyXG4gICAgY29uc3QgZm9ybWF0TWFwID0ge1xyXG4gICAgICAnJElEL0pQRUcnOiAnanBnJyxcclxuICAgICAgJyRJRC9QTkcnOiAncG5nJyxcclxuICAgICAgJyRJRC9USUZGJzogJ3RpZicsXHJcbiAgICAgICckSUQvR0lGJzogJ2dpZicsXHJcbiAgICAgICckSUQvQk1QJzogJ2JtcCdcclxuICAgIH07XHJcbiAgICByZXR1cm4gZm9ybWF0TWFwW2Zvcm1hdF0gfHwgJ2pwZyc7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZXh0cmFjdEltYWdlTmFtZUZyb21MaW5rKGxpbmtVcmkpIHtcclxuICAgIGlmICghbGlua1VyaSkgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgZmlsZW5hbWUgZnJvbSBwYXRoIGxpa2UgXCJmaWxlOkM6L1VzZXJzL2xhbG8vRG93bmxvYWRzL1Rlc2xhLU1vZGVsLTMuanBnIDEzMzI1IFwiXHJcbiAgICBjb25zdCBtYXRjaCA9IGxpbmtVcmkubWF0Y2goLyhbXlxcL1xcXFxdKylcXC5bXi5dKyQvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KGVsZW1lbnRzKSB7XHJcbiAgICBsZXQgbWluWCA9IDAsIG1pblkgPSAwO1xyXG4gICAgbGV0IG1heFN0cm9rZVdpZHRoID0gMDtcclxuICAgIFxyXG4gICAgLy8gRmlyc3QgcGFzczogZmluZCBtaW5pbXVtIGNvb3JkaW5hdGVzIGFuZCBtYXhpbXVtIHN0cm9rZSB3aWR0aFxyXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgY29uc3QgYm91bmRzID0gZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMgfHwgZWxlbWVudC5vcmlnaW5hbEJvdW5kcztcclxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZWxlbWVudC5pdGVtVHJhbnNmb3JtIHx8IHsgdHg6IDAsIHR5OiAwIH07XHJcbiAgICAgIFxyXG4gICAgICBpZiAoYm91bmRzKSB7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZpbmFsIHBvc2l0aW9uIGFmdGVyIHRyYW5zZm9ybVxyXG4gICAgICAgIGNvbnN0IGZpbmFsWCA9IChib3VuZHMubGVmdCB8fCAwKSArICh0cmFuc2Zvcm0udHggfHwgMCk7XHJcbiAgICAgICAgY29uc3QgZmluYWxZID0gKGJvdW5kcy50b3AgfHwgMCkgKyAodHJhbnNmb3JtLnR5IHx8IDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBmaW5hbFgpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBmaW5hbFkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyYWNrIG1heGltdW0gc3Ryb2tlIHdpZHRoIGZvciBpbnRlbGxpZ2VudCBwYWRkaW5nXHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBlbGVtZW50LnN0cm9rZVdlaWdodCB8fCAwO1xyXG4gICAgICAgIG1heFN0cm9rZVdpZHRoID0gTWF0aC5tYXgobWF4U3Ryb2tlV2lkdGgsIHN0cm9rZVdpZHRoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFVMVFJBLVNNQVJUIFBBRERJTkcgQ0FMQ1VMQVRJT046XHJcbiAgICAvLyAtIE5vIHBhZGRpbmcgaWYgbm8gc3Ryb2tlcyBleGlzdCBvciBzdHJva2VzIGFyZSBtaW5pbWFsXHJcbiAgICAvLyAtIEhhbGYgb2YgbWF4IHN0cm9rZSB3aWR0aCB0byBwcmV2ZW50IHN0cm9rZSBjbGlwcGluZ1xyXG4gICAgLy8gLSBPbmx5IHdoZW4gYWN0dWFsbHkgbmVlZGVkIChuZWdhdGl2ZSBjb29yZGluYXRlcylcclxuICAgIGxldCBpbnRlbGxpZ2VudFBhZGRpbmcgPSAwO1xyXG4gICAgaWYgKG1heFN0cm9rZVdpZHRoID4gMCkge1xyXG4gICAgICBpbnRlbGxpZ2VudFBhZGRpbmcgPSBNYXRoLmNlaWwobWF4U3Ryb2tlV2lkdGggLyAyKTsgLy8gSGFsZiBzdHJva2Ugd2lkdGggdG8gcHJldmVudCBjbGlwcGluZ1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW50ZWxsaWdlbnRQYWRkaW5nID0gMDsgLy8gTm8gcGFkZGluZyBuZWVkZWQgaWYgbm8gc3Ryb2tlc1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBQRVJGRUNUIE9GRlNFVCBDQUxDVUxBVElPTjpcclxuICAgIC8vIC0gWmVybyBvZmZzZXQgaWYgYWxsIGNvb3JkaW5hdGVzIGFyZSBwb3NpdGl2ZSAobW9zdCBjb21tb24gY2FzZSlcclxuICAgIC8vIC0gRXhhY3Qgb2Zmc2V0IHRvIG1ha2UgbmVnYXRpdmUgY29vcmRpbmF0ZXMgcG9zaXRpdmUgKyBtaW5pbWFsIHN0cm9rZSBwYWRkaW5nIG9ubHkgd2hlbiBuZWVkZWRcclxuICAgIGNvbnN0IG9mZnNldFggPSBtaW5YIDwgMCA/IE1hdGguYWJzKG1pblgpICsgaW50ZWxsaWdlbnRQYWRkaW5nIDogMDtcclxuICAgIGNvbnN0IG9mZnNldFkgPSBtaW5ZIDwgMCA/IE1hdGguYWJzKG1pblkpICsgaW50ZWxsaWdlbnRQYWRkaW5nIDogMDtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCfjq8gU01BUlQgT0ZGU0VUOiBYOiAke29mZnNldFh9LCBZOiAke29mZnNldFl9IChtaW5YOiAke21pblh9LCBtaW5ZOiAke21pbll9KWApO1xyXG4gICAgY29uc29sZS5sb2coYCAgIE1heCBzdHJva2Ugd2lkdGg6ICR7bWF4U3Ryb2tlV2lkdGh9cHgg4oaSIGludGVsbGlnZW50IHBhZGRpbmc6ICR7aW50ZWxsaWdlbnRQYWRkaW5nfXB4YCk7XHJcbiAgICBjb25zb2xlLmxvZyhgICAgJHttaW5YIDwgMCA/IGDimqDvuI8gIE5lZ2F0aXZlIFg6ICR7bWluWH0g4oaSIG9mZnNldCAke01hdGguYWJzKG1pblgpfSArIHBhZGRpbmcgJHtpbnRlbGxpZ2VudFBhZGRpbmd9YCA6ICfinIUgWCBwb3NpdGl2ZSDihpIgbm8gb2Zmc2V0J31gKTtcclxuICAgIGNvbnNvbGUubG9nKGAgICAke21pblkgPCAwID8gYOKaoO+4jyAgTmVnYXRpdmUgWTogJHttaW5ZfSDihpIgb2Zmc2V0ICR7TWF0aC5hYnMobWluWSl9ICsgcGFkZGluZyAke2ludGVsbGlnZW50UGFkZGluZ31gIDogJ+KchSBZIHBvc2l0aXZlIOKGkiBubyBvZmZzZXQnfWApO1xyXG4gICAgXHJcbiAgICByZXR1cm4geyB4OiBvZmZzZXRYLCB5OiBvZmZzZXRZIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgoaXRlbSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gRmlyc3QgdHJ5IHRvIGdldCBib3VuZHMgZnJvbSBHZW9tZXRyaWNCb3VuZHMgYXR0cmlidXRlXHJcbiAgICAgIGlmIChpdGVtWydAX0dlb21ldHJpY0JvdW5kcyddKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VHZW9tZXRyaWNCb3VuZHMoaXRlbVsnQF9HZW9tZXRyaWNCb3VuZHMnXSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFRoZW4gdHJ5IHBhdGggZ2VvbWV0cnlcclxuICAgICAgY29uc3QgcGF0aEdlb21ldHJ5ID0gaXRlbT8uUHJvcGVydGllcz8uUGF0aEdlb21ldHJ5Py5HZW9tZXRyeVBhdGhUeXBlPy5QYXRoUG9pbnRBcnJheT8uUGF0aFBvaW50VHlwZTtcclxuICAgICAgXHJcbiAgICAgIGlmICghcGF0aEdlb21ldHJ5IHx8ICFBcnJheS5pc0FycmF5KHBhdGhHZW9tZXRyeSkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgV2FybmluZzogTm8gZ2VvbWV0cnkgZm91bmQgZm9yICR7aXRlbVsnQF9TZWxmJ119LCB1c2luZyBpdGVtIHRyYW5zZm9ybWApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGl0ZW0gdHJhbnNmb3JtIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMucGFyc2VUcmFuc2Zvcm0oaXRlbVsnQF9JdGVtVHJhbnNmb3JtJ10pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0b3A6IHRyYW5zZm9ybS50eSB8fCAwLFxyXG4gICAgICAgICAgbGVmdDogdHJhbnNmb3JtLnR4IHx8IDAsXHJcbiAgICAgICAgICBib3R0b206ICh0cmFuc2Zvcm0udHkgfHwgMCkgKyAxMDAsIC8vIERlZmF1bHQgaGVpZ2h0XHJcbiAgICAgICAgICByaWdodDogKHRyYW5zZm9ybS50eCB8fCAwKSArIDEwMCwgIC8vIERlZmF1bHQgd2lkdGhcclxuICAgICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgICBoZWlnaHQ6IDEwMFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGxldCBtaW5YID0gSW5maW5pdHksIG1pblkgPSBJbmZpbml0eSwgbWF4WCA9IC1JbmZpbml0eSwgbWF4WSA9IC1JbmZpbml0eTtcclxuICAgICAgXHJcbiAgICAgIHBhdGhHZW9tZXRyeS5mb3JFYWNoKHBvaW50ID0+IHtcclxuICAgICAgICBjb25zdCBhbmNob3IgPSBwb2ludFsnQF9BbmNob3InXTtcclxuICAgICAgICBpZiAoYW5jaG9yKSB7XHJcbiAgICAgICAgICBjb25zdCBbeCwgeV0gPSBhbmNob3Iuc3BsaXQoJyAnKS5tYXAocGFyc2VGbG9hdCk7XHJcbiAgICAgICAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xyXG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XHJcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcclxuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xyXG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGlmIChtaW5YID09PSBJbmZpbml0eSB8fCBtaW5ZID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBXYXJuaW5nOiBDb3VsZCBub3QgY2FsY3VsYXRlIGJvdW5kcyBmb3IgJHtpdGVtWydAX1NlbGYnXX1gKTtcclxuICAgICAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogMTAwLCByaWdodDogMTAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMCB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogbWluWSxcclxuICAgICAgICBsZWZ0OiBtaW5YLFxyXG4gICAgICAgIGJvdHRvbTogbWF4WSxcclxuICAgICAgICByaWdodDogbWF4WCxcclxuICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXHJcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNhbGN1bGF0aW5nIGJvdW5kcyBmb3IgJHtpdGVtWydAX1NlbGYnXX06YCwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogMTAwLCByaWdodDogMTAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMCB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZVJlbGF0aXZlUG9zaXRpb24oZnJhbWVCb3VuZHMsIGNvbnRlbnRCb3VuZHMsIGZyYW1lVHJhbnNmb3JtLCBjb250ZW50VHJhbnNmb3JtKSB7XHJcbiAgICBpZiAoIWZyYW1lQm91bmRzIHx8ICFjb250ZW50Qm91bmRzKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb2Zmc2V0WDogKGNvbnRlbnRCb3VuZHMubGVmdCB8fCAwKSAtIChmcmFtZUJvdW5kcy5sZWZ0IHx8IDApLFxyXG4gICAgICBvZmZzZXRZOiAoY29udGVudEJvdW5kcy50b3AgfHwgMCkgLSAoZnJhbWVCb3VuZHMudG9wIHx8IDApLFxyXG4gICAgICBzY2FsZVg6IGNvbnRlbnRUcmFuc2Zvcm0/LmEgfHwgMSxcclxuICAgICAgc2NhbGVZOiBjb250ZW50VHJhbnNmb3JtPy5kIHx8IDEsXHJcbiAgICAgIHRyYW5zZm9ybURpZmZlcmVuY2U6IHtcclxuICAgICAgICBmcmFtZTogZnJhbWVUcmFuc2Zvcm0sXHJcbiAgICAgICAgY29udGVudDogY29udGVudFRyYW5zZm9ybVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUdhcChmcmFtZUJvdW5kcywgY29udGVudEJvdW5kcykge1xyXG4gICAgaWYgKCFmcmFtZUJvdW5kcyB8fCAhY29udGVudEJvdW5kcykgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcDogKGNvbnRlbnRCb3VuZHMudG9wIHx8IDApIC0gKGZyYW1lQm91bmRzLnRvcCB8fCAwKSxcclxuICAgICAgbGVmdDogKGNvbnRlbnRCb3VuZHMubGVmdCB8fCAwKSAtIChmcmFtZUJvdW5kcy5sZWZ0IHx8IDApLFxyXG4gICAgICBib3R0b206IChmcmFtZUJvdW5kcy5ib3R0b20gfHwgMCkgLSAoY29udGVudEJvdW5kcy5ib3R0b20gfHwgMCksXHJcbiAgICAgIHJpZ2h0OiAoZnJhbWVCb3VuZHMucmlnaHQgfHwgMCkgLSAoY29udGVudEJvdW5kcy5yaWdodCB8fCAwKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVJbWFnZVBvc2l0aW9uSW5GcmFtZShmcmFtZUJvdW5kcywgZnJhbWVUcmFuc2Zvcm0sIHBsYWNlZENvbnRlbnQpIHtcclxuICAgIGlmICghZnJhbWVCb3VuZHMgfHwgIXBsYWNlZENvbnRlbnQ/LnRyYW5zZm9ybSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgaW1hZ2VUcmFuc2Zvcm0gPSBwbGFjZWRDb250ZW50LnRyYW5zZm9ybTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGltYWdlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGZyYW1lXHJcbiAgICBjb25zdCBpbWFnZVggPSAoZnJhbWVCb3VuZHMubGVmdCB8fCAwKSArIChpbWFnZVRyYW5zZm9ybS50eCB8fCAwKTtcclxuICAgIGNvbnN0IGltYWdlWSA9IChmcmFtZUJvdW5kcy50b3AgfHwgMCkgKyAoaW1hZ2VUcmFuc2Zvcm0udHkgfHwgMCk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBpbWFnZSBzaXplIHdpdGggc2NhbGluZ1xyXG4gICAgY29uc3QgaW1hZ2VXaWR0aCA9IChmcmFtZUJvdW5kcy53aWR0aCB8fCAwKSAqIChpbWFnZVRyYW5zZm9ybS5hIHx8IDEpO1xyXG4gICAgY29uc3QgaW1hZ2VIZWlnaHQgPSAoZnJhbWVCb3VuZHMuaGVpZ2h0IHx8IDApICogKGltYWdlVHJhbnNmb3JtLmQgfHwgMSk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGltYWdlWCxcclxuICAgICAgeTogaW1hZ2VZLFxyXG4gICAgICB3aWR0aDogaW1hZ2VXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBpbWFnZUhlaWdodCxcclxuICAgICAgc2NhbGVYOiBpbWFnZVRyYW5zZm9ybS5hIHx8IDEsXHJcbiAgICAgIHNjYWxlWTogaW1hZ2VUcmFuc2Zvcm0uZCB8fCAxXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldFhNTFN0cnVjdHVyZShvYmosIG1heERlcHRoID0gMywgY3VycmVudERlcHRoID0gMCkge1xyXG4gICAgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHN0cnVjdHVyZSA9IHt9O1xyXG4gICAgXHJcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XHJcbiAgICAgICAgc3RydWN0dXJlW2tleV0gPSBgQXJyYXlbJHtvYmpba2V5XS5sZW5ndGh9XWA7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0JyAmJiBvYmpba2V5XSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHN0cnVjdHVyZVtrZXldID0gdGhpcy5nZXRYTUxTdHJ1Y3R1cmUob2JqW2tleV0sIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHJ1Y3R1cmVba2V5XSA9IHR5cGVvZiBvYmpba2V5XTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBzdHJ1Y3R1cmU7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaXNGb3JtYXR0aW5nQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmdBdHRyaWJ1dGVzID0gW1xyXG4gICAgICAnQF9Qb2ludFNpemUnLCAnQF9MZWFkaW5nJywgJ0BfVHJhY2tpbmcnLCAnQF9Gb250U3R5bGUnLFxyXG4gICAgICAnQF9BcHBsaWVkRm9udCcsICdAX0ZpbGxDb2xvcicsICdAX1N0cm9rZUNvbG9yJywgJ0BfSnVzdGlmaWNhdGlvbicsXHJcbiAgICAgICdAX0xlZnRJbmRlbnQnLCAnQF9SaWdodEluZGVudCcsICdAX0ZpcnN0TGluZUluZGVudCcsXHJcbiAgICAgICdAX1NwYWNlQmVmb3JlJywgJ0BfU3BhY2VBZnRlcicsICdAX0FsaWdubWVudCdcclxuICAgIF07XHJcbiAgICByZXR1cm4gZm9ybWF0dGluZ0F0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgc2F2ZURlYnVnSW5mbyhkZWJ1Z0luZm8sIGZpbGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVOYW1lLCBKU09OLnN0cmluZ2lmeShkZWJ1Z0luZm8sIG51bGwsIDIpKTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBEZWJ1ZyBpbmZvIHNhdmVkIHRvICR7ZmlsZU5hbWV9YCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3Igc2F2aW5nIGRlYnVnIGluZm86JywgZXJyb3IpO1xyXG4gICAgICBjb25zb2xlLmxvZygnRGVidWcgaW5mbyAoZmlyc3QgMjAwMCBjaGFycyk6JywgSlNPTi5zdHJpbmdpZnkoZGVidWdJbmZvLCBudWxsLCAyKS5zdWJzdHJpbmcoMCwgMjAwMCkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJRE1MVXRpbHM7IFxyXG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJmcyIsIklETUxVdGlscyIsInBhcnNlR2VvbWV0cmljQm91bmRzIiwiYm91bmRzU3RyaW5nIiwiY29uc29sZSIsImxvZyIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiYm91bmRzIiwic3BsaXQiLCJtYXAiLCJwYXJzZUZsb2F0IiwicmVzdWx0IiwicGFyc2VUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1TdHJpbmciLCJhIiwiYiIsImMiLCJkIiwidHgiLCJ0eSIsInZhbHVlcyIsImNhbGN1bGF0ZVJvdGF0aW9uIiwidHJhbnNmb3JtIiwiTWF0aCIsImF0YW4yIiwiUEkiLCJjYWxjdWxhdGVDb3JuZXJzIiwiY29ybmVycyIsInRvcExlZnQiLCJ4IiwieSIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJjb3JuZXIiLCJwb2ludCIsImNteWtUb1JnYiIsIm0iLCJrIiwiciIsInJvdW5kIiwiZyIsInBhcnNlSW5EZXNpZ25Db2xvciIsImNvbG9yUmVmIiwiY215a01hdGNoIiwibWF0Y2giLCJOdW1iZXIiLCJyZ2IiLCJyZ2JNYXRjaCIsInN0YW5kYXJkQ29sb3JzIiwiZGVjb2RlWE1MRW50aXRpZXMiLCJ0ZXh0IiwicmVwbGFjZSIsImNsZWFuVGV4dENvbnRlbnQiLCJjb250ZW50IiwidHJpbSIsInByZXNlcnZlTGluZUJyZWFrcyIsImNsZWFuVGV4dEZvclJlbmRlcmluZyIsInNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nIiwiaGFzUHJvYmxlbWF0aWNUZXh0IiwiaW5jbHVkZXMiLCJKU09OIiwic3RyaW5naWZ5IiwicHJvY2Vzc2VkIiwiY291bnRXb3JkcyIsImZpbHRlciIsIndvcmQiLCJsZW5ndGgiLCJwYXJzZU51bWVyaWMiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIm51bSIsImlzTmFOIiwiaXNJbWFnZUZpbGUiLCJmaWxlTmFtZSIsImltYWdlRXh0ZW5zaW9ucyIsInNvbWUiLCJleHQiLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiZ2V0SW1hZ2VFeHRlbnNpb24iLCJpbWFnZVR5cGVOYW1lIiwidHlwZU1hcCIsImdldEltYWdlRXh0ZW5zaW9uRnJvbUZvcm1hdCIsImZvcm1hdCIsImZvcm1hdE1hcCIsImV4dHJhY3RJbWFnZU5hbWVGcm9tTGluayIsImxpbmtVcmkiLCJjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0IiwiZWxlbWVudHMiLCJtaW5YIiwibWluWSIsIm1heFN0cm9rZVdpZHRoIiwiZWxlbWVudCIsImdlb21ldHJpY0JvdW5kcyIsIm9yaWdpbmFsQm91bmRzIiwiaXRlbVRyYW5zZm9ybSIsImZpbmFsWCIsImZpbmFsWSIsIm1pbiIsInN0cm9rZVdpZHRoIiwic3Ryb2tlV2VpZ2h0IiwibWF4IiwiaW50ZWxsaWdlbnRQYWRkaW5nIiwiY2VpbCIsIm9mZnNldFgiLCJhYnMiLCJvZmZzZXRZIiwiY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgiLCJpdGVtIiwicGF0aEdlb21ldHJ5IiwiUHJvcGVydGllcyIsIlBhdGhHZW9tZXRyeSIsIkdlb21ldHJ5UGF0aFR5cGUiLCJQYXRoUG9pbnRBcnJheSIsIlBhdGhQb2ludFR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJJbmZpbml0eSIsIm1heFgiLCJtYXhZIiwiYW5jaG9yIiwiZXJyb3IiLCJjYWxjdWxhdGVSZWxhdGl2ZVBvc2l0aW9uIiwiZnJhbWVCb3VuZHMiLCJjb250ZW50Qm91bmRzIiwiZnJhbWVUcmFuc2Zvcm0iLCJjb250ZW50VHJhbnNmb3JtIiwic2NhbGVYIiwic2NhbGVZIiwidHJhbnNmb3JtRGlmZmVyZW5jZSIsImZyYW1lIiwiY2FsY3VsYXRlR2FwIiwiY2FsY3VsYXRlSW1hZ2VQb3NpdGlvbkluRnJhbWUiLCJwbGFjZWRDb250ZW50IiwiaW1hZ2VUcmFuc2Zvcm0iLCJpbWFnZVgiLCJpbWFnZVkiLCJpbWFnZVdpZHRoIiwiaW1hZ2VIZWlnaHQiLCJnZXRYTUxTdHJ1Y3R1cmUiLCJvYmoiLCJtYXhEZXB0aCIsImN1cnJlbnREZXB0aCIsInN0cnVjdHVyZSIsImtleSIsImlzRm9ybWF0dGluZ0F0dHJpYnV0ZSIsImF0dHJpYnV0ZU5hbWUiLCJmb3JtYXR0aW5nQXR0cmlidXRlcyIsInNhdmVEZWJ1Z0luZm8iLCJkZWJ1Z0luZm8iLCJ3cml0ZUZpbGVTeW5jIiwic3Vic3RyaW5nIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/utils/IDMLUtils.js\n"));

/***/ })

});