"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/IDMLUtils.js":
/*!********************************!*\
  !*** ./lib/utils/IDMLUtils.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"?82df\");\nclass IDMLUtils {\n    static parseGeometricBounds(boundsString) {\n        console.log(\"DEBUG: boundsString =\", boundsString);\n        if (!boundsString || boundsString === \"undefined\") {\n            console.log(\"Warning: Missing geometric bounds, using defaults\");\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n        const bounds = boundsString.split(\" \").map(parseFloat);\n        const result = {\n            top: bounds[0] || 0,\n            left: bounds[1] || 0,\n            bottom: bounds[2] || 0,\n            right: bounds[3] || 0,\n            width: (bounds[3] || 0) - (bounds[1] || 0),\n            height: (bounds[2] || 0) - (bounds[0] || 0)\n        };\n        console.log(\"Parsed bounds:\", result);\n        return result;\n    }\n    static parseTransform(transformString) {\n        if (!transformString) return {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            tx: 0,\n            ty: 0\n        };\n        const values = transformString.split(\" \").map(parseFloat);\n        return {\n            a: values[0] || 1,\n            b: values[1] || 0,\n            c: values[2] || 0,\n            d: values[3] || 1,\n            tx: values[4] || 0,\n            ty: values[5] || 0\n        };\n    }\n    static calculateRotation(transform) {\n        // Calculate rotation angle from transform matrix\n        return Math.atan2(transform.b, transform.a) * (180 / Math.PI);\n    }\n    static calculateCorners(bounds, transform) {\n        const corners = {\n            topLeft: {\n                x: bounds.left,\n                y: bounds.top\n            },\n            topRight: {\n                x: bounds.right,\n                y: bounds.top\n            },\n            bottomLeft: {\n                x: bounds.left,\n                y: bounds.bottom\n            },\n            bottomRight: {\n                x: bounds.right,\n                y: bounds.bottom\n            }\n        };\n        // Apply transformation to corners\n        Object.keys(corners).forEach((corner)=>{\n            const point = corners[corner];\n            corners[corner] = {\n                x: transform.a * point.x + transform.c * point.y + transform.tx,\n                y: transform.b * point.x + transform.d * point.y + transform.ty\n            };\n        });\n        return corners;\n    }\n    static cmykToRgb(c, m, y, k) {\n        // Convert CMYK percentages (0-100) to RGB (0-255)\n        c = c / 100;\n        m = m / 100;\n        y = y / 100;\n        k = k / 100;\n        const r = Math.round(255 * (1 - c) * (1 - k));\n        const g = Math.round(255 * (1 - m) * (1 - k));\n        const b = Math.round(255 * (1 - y) * (1 - k));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    static parseInDesignColor(colorRef) {\n        if (!colorRef || colorRef === \"Color/None\") return null;\n        // Handle CMYK colors\n        const cmykMatch = colorRef.match(/Color\\/C=(\\d+)\\s*M=(\\d+)\\s*Y=(\\d+)\\s*K=(\\d+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map(Number);\n            const rgb = this.cmykToRgb(c, m, y, k);\n            return \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n        }\n        // Handle RGB colors\n        const rgbMatch = colorRef.match(/Color\\/R=(\\d+)\\s*G=(\\d+)\\s*B=(\\d+)/);\n        if (rgbMatch) {\n            const [, r, g, b] = rgbMatch.map(Number);\n            return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n        }\n        // Standard colors\n        const standardColors = {\n            \"Color/Black\": \"rgb(0, 0, 0)\",\n            \"Color/White\": \"rgb(255, 255, 255)\",\n            \"Color/Red\": \"rgb(255, 0, 0)\",\n            \"Color/Green\": \"rgb(0, 255, 0)\",\n            \"Color/Blue\": \"rgb(0, 0, 255)\",\n            \"Color/Cyan\": \"rgb(0, 255, 255)\",\n            \"Color/Magenta\": \"rgb(255, 0, 255)\",\n            \"Color/Yellow\": \"rgb(255, 255, 0)\",\n            \"Color/Paper\": \"rgb(255, 255, 255)\",\n            \"Color/Registration\": \"rgb(0, 0, 0)\"\n        };\n        return standardColors[colorRef] || null;\n    }\n    static decodeXMLEntities(text) {\n        if (!text) return \"\";\n        return text.replace(/&#x000A;/g, \"\\n\") // Line feed\n        .replace(/&#x000D;/g, \"\\r\") // Carriage return\n        .replace(/&#x0009;/g, \"\t\") // Tab\n        .replace(/&#x00A0;/g, \"\\xa0\") // Non-breaking space\n        .replace(/&#x2028;/g, \"\\n\") // Line separator\n        .replace(/&#x2029;/g, \"\\u2029\") // Paragraph separator\n        .replace(/&#10;/g, \"\\n\") // Decimal line feed\n        .replace(/&#13;/g, \"\\r\") // Decimal carriage return\n        .replace(/&#9;/g, \"\t\") // Decimal tab\n        .replace(/&#160;/g, \"\\xa0\") // Decimal non-breaking space\n        .replace(/&lt;/g, \"<\") // Less than\n        .replace(/&gt;/g, \">\") // Greater than\n        .replace(/&amp;/g, \"&\") // Ampersand (must be last)\n        .replace(/&quot;/g, '\"') // Quote\n        .replace(/&apos;/g, \"'\"); // Apostrophe\n    }\n    static cleanTextContent(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\t/g, \"    \") // Convert tabs to spaces\n        .replace(/\\u00A0/g, \" \") // Convert non-breaking spaces\n        .replace(/ +/g, \" \") // Collapse multiple spaces\n        // REMOVED: .replace(/\\n{3,}/g, '\\n\\n')  // Allow unlimited consecutive line breaks\n        .trim();\n    }\n    static preserveLineBreaks(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\"); // Convert paragraph separators\n    // REMOVED: .replace(/\\n{3,}/g, '\\n\\n'); // Allow unlimited consecutive line breaks\n    }\n    // NEW: Clean up excessive line breaks to prevent text overflow\n    static cleanTextForRendering(text) {\n        if (!text) return \"\";\n        return text// Normalize line endings\n        .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\")// Remove trailing whitespace on each line only\n        .replace(/[ \\t]+\\n/g, \"\\n\");\n    // DO NOT collapse multiple spaces, tabs, or newlines\n    // DO NOT trim the whole string\n    }\n    // ENHANCED: Better line break processing that preserves word spaces\n    static sophisticatedLineBreakProcessing(content) {\n        if (!content) return \"\";\n        // DEBUG: Track if problematic text is being processed\n        const hasProblematicText = content.includes(\"pavoluptusda\") || content.includes(\"pa\") && content.includes(\"voluptusda\");\n        if (hasProblematicText) {\n            console.log(\"\\uD83D\\uDD27 IDMLUtils.sophisticatedLineBreakProcessing:\");\n            console.log(\"   - Input:\", JSON.stringify(content));\n        }\n        // First clean up the content but preserve word spaces\n        let processed = this.cleanTextForRendering(content).replace(/\\u2028/g, \"\\n\");\n        if (hasProblematicText) {\n            console.log(\"   - After cleanTextForRendering:\", JSON.stringify(processed));\n        }\n        // Normalize line breaks but don't touch word spaces\n        // processed = processed\n        //   .replace(/\\r\\n/g, '\\n')      // Normalize Windows line breaks\n        //   .replace(/\\r/g, '\\n')        // Normalize old Mac line breaks\n        //   .replace(/\\u2029/g, '\\n')    // Convert line separators\n        //   .replace(/\\u2028/g, '\\n\\n')  // Convert paragraph separators to double breaks\n        //   .replace(/\\u000A/g, '\\n');   // Convert explicit line feed characters\n        // Ensure paragraph breaks are properly spaced\n        // processed = processed.replace(/\\n\\n+/g, '\\n\\n'); // REMOVE THIS LINE to preserve all consecutive newlines\n        return processed;\n    }\n    static countWords(text) {\n        return text.split(/\\s+/).filter((word)=>word.length > 0).length;\n    }\n    static parseNumeric(value) {\n        if (value === null || value === undefined || value === \"\") return null;\n        const num = parseFloat(value);\n        return isNaN(num) ? null : num;\n    }\n    static isImageFile(fileName) {\n        const imageExtensions = [\n            \".jpg\",\n            \".jpeg\",\n            \".png\",\n            \".gif\",\n            \".tiff\",\n            \".tif\",\n            \".bmp\",\n            \".svg\",\n            \".eps\",\n            \".ai\",\n            \".psd\",\n            \".webp\",\n            \".ico\",\n            \".jfif\",\n            \".jp2\",\n            \".jpx\"\n        ];\n        return imageExtensions.some((ext)=>fileName.toLowerCase().endsWith(ext));\n    }\n    static getImageExtension(imageTypeName) {\n        const typeMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return typeMap[imageTypeName] || \"jpg\";\n    }\n    static getImageExtensionFromFormat(format) {\n        const formatMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return formatMap[format] || \"jpg\";\n    }\n    static extractImageNameFromLink(linkUri) {\n        if (!linkUri) return null;\n        // Extract filename from path like \"file:C:/Users/lalo/Downloads/Tesla-Model-3.jpg 13325 \"\n        const match = linkUri.match(/([^\\/\\\\]+)\\.[^.]+$/);\n        return match ? match[1] : null;\n    }\n    static calculateCoordinateOffset(elements) {\n        if (!elements || elements.length === 0) {\n            console.log(\"\\uD83D\\uDEAB No elements provided for coordinate offset calculation\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        let minX = Infinity, minY = Infinity;\n        let maxStrokeWidth = 0;\n        let validElements = 0;\n        console.log(\"\\uD83D\\uDD0D ANALYZING \".concat(elements.length, \" elements for coordinate offset...\"));\n        // First pass: find TRUE minimum coordinates across all elements\n        elements.forEach((element, index)=>{\n            const bounds = element.geometricBounds || element.originalBounds;\n            const transform = element.itemTransform || {\n                tx: 0,\n                ty: 0\n            };\n            if (bounds && (bounds.left !== undefined || bounds.top !== undefined)) {\n                // Calculate final position after transform\n                const finalX = (bounds.left || 0) + (transform.tx || 0);\n                const finalY = (bounds.top || 0) + (transform.ty || 0);\n                console.log(\"   Element \".concat(index, \": bounds(\").concat(bounds.left, \", \").concat(bounds.top, \") + transform(\").concat(transform.tx, \", \").concat(transform.ty, \") = final(\").concat(finalX, \", \").concat(finalY, \")\"));\n                minX = Math.min(minX, finalX);\n                minY = Math.min(minY, finalY);\n                validElements++;\n                // Track maximum stroke width for intelligent padding\n                const strokeWidth = element.strokeWeight || 0;\n                maxStrokeWidth = Math.max(maxStrokeWidth, strokeWidth);\n            } else {\n                console.log(\"   Element \".concat(index, \": No valid bounds - skipping\"));\n            }\n        });\n        // Handle case where no valid elements found\n        if (validElements === 0) {\n            console.log(\"⚠️  No valid elements with bounds found - using zero offset\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        // Reset infinite values to 0 if no valid coordinates found\n        if (minX === Infinity) minX = 0;\n        if (minY === Infinity) minY = 0;\n        console.log(\"\\uD83D\\uDCCA ANALYSIS COMPLETE: minX=\".concat(minX, \", minY=\").concat(minY, \", maxStroke=\").concat(maxStrokeWidth, \"px, validElements=\").concat(validElements));\n        // ZERO-BASED OFFSET CALCULATION:\n        // The goal is to have NO OFFSET unless absolutely necessary for negative coordinates\n        let offsetX = 0;\n        let offsetY = 0;\n        // Only add offset if coordinates are actually negative\n        if (minX < 0) {\n            offsetX = Math.abs(minX);\n            console.log(\"❌ Negative X detected: \".concat(minX, \" → adding offset: \").concat(offsetX));\n        }\n        if (minY < 0) {\n            offsetY = Math.abs(minY);\n            console.log(\"❌ Negative Y detected: \".concat(minY, \" → adding offset: \").concat(offsetY));\n        }\n        // Add minimal stroke padding only if we already have an offset\n        if ((offsetX > 0 || offsetY > 0) && maxStrokeWidth > 0) {\n            const strokePadding = Math.ceil(maxStrokeWidth / 2);\n            if (offsetX > 0) offsetX += strokePadding;\n            if (offsetY > 0) offsetY += strokePadding;\n            console.log(\"\\uD83D\\uDD8C️ Added stroke padding: \".concat(strokePadding, \"px\"));\n        }\n        console.log(\"\\uD83C\\uDFAF FINAL OFFSET: X=\".concat(offsetX, \", Y=\").concat(offsetY));\n        console.log(\"   \".concat(offsetX === 0 ? \"✅ Perfect! No X offset needed\" : \"⚠️ X offset: \".concat(offsetX, \"px (\").concat(minX, \" was negative)\")));\n        console.log(\"   \".concat(offsetY === 0 ? \"✅ Perfect! No Y offset needed\" : \"⚠️ Y offset: \".concat(offsetY, \"px (\").concat(minY, \" was negative)\")));\n        return {\n            x: offsetX,\n            y: offsetY\n        };\n    }\n    /**\r\n   * Calculate precise coordinate offset for pixel-perfect InDesign coordinate system transformation\r\n   * This ensures accurate positioning similar to professional tools like IMG.LY InDesign\r\n   * @param {Array} elements - Array of elements with bounds and transforms\r\n   * @returns {Object} - {x, y} offset for coordinate transformation\r\n   */ static calculateCoordinateOffsetPrecise(elements) {\n        if (!elements || elements.length === 0) {\n            console.warn(\"\\uD83C\\uDFAF No elements provided for coordinate offset calculation\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        console.log(\"\\uD83D\\uDD0D ANALYZING\", elements.length, \"elements for PRECISE coordinate offset...\");\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxStroke = 0;\n        let validElements = 0;\n        elements.forEach((element, index)=>{\n            if (!element.geometricBounds || !element.itemTransform) {\n                console.warn(\"   ⚠️ Element \".concat(index, \" missing bounds/transform - skipping\"));\n                return;\n            }\n            // Calculate final position (bounds + transform)\n            const finalX = element.geometricBounds.left + element.itemTransform.tx;\n            const finalY = element.geometricBounds.top + element.itemTransform.ty;\n            // Track stroke width for precise positioning\n            const strokeWidth = element.strokeWeight || 0;\n            maxStroke = Math.max(maxStroke, strokeWidth);\n            console.log(\"   Element \".concat(index, \": bounds(\").concat(element.geometricBounds.left, \", \").concat(element.geometricBounds.top, \") + transform(\").concat(element.itemTransform.tx, \", \").concat(element.itemTransform.ty, \") = final(\").concat(finalX, \", \").concat(finalY, \")\"));\n            minX = Math.min(minX, finalX);\n            minY = Math.min(minY, finalY);\n            validElements++;\n        });\n        console.log(\"\\uD83D\\uDCCA ANALYSIS COMPLETE:\", \"minX=\".concat(minX, \", minY=\").concat(minY, \", maxStroke=\").concat(maxStroke, \"px, validElements=\").concat(validElements));\n        // FIXED: Only add offset if coordinates are actually negative\n        // Don't force elements to start at origin - preserve InDesign positioning\n        let offsetX = 0;\n        let offsetY = 0;\n        // Only handle negative coordinates that would be clipped by the browser\n        if (minX < 0) {\n            offsetX = Math.abs(minX) + maxStroke;\n            console.log(\"❌ Negative X detected: \".concat(minX, \" → adding offset: \").concat(offsetX));\n        } else {\n            console.log(\"✅ Positive X coordinates: \".concat(minX, \" → no offset needed\"));\n        }\n        if (minY < 0) {\n            offsetY = Math.abs(minY) + maxStroke;\n            console.log(\"❌ Negative Y detected: \".concat(minY, \" → adding offset: \").concat(offsetY));\n        } else {\n            console.log(\"✅ Positive Y coordinates: \".concat(minY, \" → no offset needed\"));\n        }\n        const finalOffset = {\n            x: offsetX,\n            y: offsetY\n        };\n        console.log(\"\\uD83C\\uDFAF FINAL PRECISE OFFSET:\", \"X=\".concat(offsetX, \", Y=\").concat(offsetY));\n        console.log(\"   \".concat(offsetX === 0 ? \"✅ Perfect! No X offset needed\" : \"⚠️ X offset: \".concat(offsetX, \"px (compensating for negative coordinates)\")));\n        console.log(\"   \".concat(offsetY === 0 ? \"✅ Perfect! No Y offset needed\" : \"⚠️ Y offset: \".concat(offsetY, \"px (compensating for negative coordinates)\")));\n        return finalOffset;\n    }\n    static calculateBoundsFromPath(item) {\n        try {\n            var _item_Properties_PathGeometry_GeometryPathType_PathPointArray, _item_Properties_PathGeometry_GeometryPathType, _item_Properties_PathGeometry, _item_Properties;\n            // First try to get bounds from GeometricBounds attribute\n            if (item[\"@_GeometricBounds\"]) {\n                return this.parseGeometricBounds(item[\"@_GeometricBounds\"]);\n            }\n            // Then try path geometry\n            const pathGeometry = item === null || item === void 0 ? void 0 : (_item_Properties = item.Properties) === null || _item_Properties === void 0 ? void 0 : (_item_Properties_PathGeometry = _item_Properties.PathGeometry) === null || _item_Properties_PathGeometry === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType = _item_Properties_PathGeometry.GeometryPathType) === null || _item_Properties_PathGeometry_GeometryPathType === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType_PathPointArray = _item_Properties_PathGeometry_GeometryPathType.PathPointArray) === null || _item_Properties_PathGeometry_GeometryPathType_PathPointArray === void 0 ? void 0 : _item_Properties_PathGeometry_GeometryPathType_PathPointArray.PathPointType;\n            if (!pathGeometry || !Array.isArray(pathGeometry)) {\n                console.log(\"Warning: No geometry found for \".concat(item[\"@_Self\"], \", using item transform\"));\n                // Fallback to item transform if available\n                const transform = this.parseTransform(item[\"@_ItemTransform\"]);\n                return {\n                    top: transform.ty || 0,\n                    left: transform.tx || 0,\n                    bottom: (transform.ty || 0) + 100,\n                    right: (transform.tx || 0) + 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n            pathGeometry.forEach((point)=>{\n                const anchor = point[\"@_Anchor\"];\n                if (anchor) {\n                    const [x, y] = anchor.split(\" \").map(parseFloat);\n                    if (!isNaN(x) && !isNaN(y)) {\n                        minX = Math.min(minX, x);\n                        maxX = Math.max(maxX, x);\n                        minY = Math.min(minY, y);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            });\n            if (minX === Infinity || minY === Infinity) {\n                console.log(\"Warning: Could not calculate bounds for \".concat(item[\"@_Self\"]));\n                return {\n                    top: 0,\n                    left: 0,\n                    bottom: 100,\n                    right: 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            return {\n                top: minY,\n                left: minX,\n                bottom: maxY,\n                right: maxX,\n                width: maxX - minX,\n                height: maxY - minY\n            };\n        } catch (error) {\n            console.error(\"Error calculating bounds for \".concat(item[\"@_Self\"], \":\"), error);\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n    }\n    static calculateRelativePosition(frameBounds, contentBounds, frameTransform, contentTransform) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            offsetX: (contentBounds.left || 0) - (frameBounds.left || 0),\n            offsetY: (contentBounds.top || 0) - (frameBounds.top || 0),\n            scaleX: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.a) || 1,\n            scaleY: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.d) || 1,\n            transformDifference: {\n                frame: frameTransform,\n                content: contentTransform\n            }\n        };\n    }\n    static calculateGap(frameBounds, contentBounds) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            top: (contentBounds.top || 0) - (frameBounds.top || 0),\n            left: (contentBounds.left || 0) - (frameBounds.left || 0),\n            bottom: (frameBounds.bottom || 0) - (contentBounds.bottom || 0),\n            right: (frameBounds.right || 0) - (contentBounds.right || 0)\n        };\n    }\n    static calculateImagePositionInFrame(frameBounds, frameTransform, placedContent) {\n        if (!frameBounds || !(placedContent === null || placedContent === void 0 ? void 0 : placedContent.transform)) {\n            return null;\n        }\n        const imageTransform = placedContent.transform;\n        // Calculate image position relative to frame\n        const imageX = (frameBounds.left || 0) + (imageTransform.tx || 0);\n        const imageY = (frameBounds.top || 0) + (imageTransform.ty || 0);\n        // Calculate image size with scaling\n        const imageWidth = (frameBounds.width || 0) * (imageTransform.a || 1);\n        const imageHeight = (frameBounds.height || 0) * (imageTransform.d || 1);\n        return {\n            x: imageX,\n            y: imageY,\n            width: imageWidth,\n            height: imageHeight,\n            scaleX: imageTransform.a || 1,\n            scaleY: imageTransform.d || 1\n        };\n    }\n    static getXMLStructure(obj) {\n        let maxDepth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        if (currentDepth >= maxDepth || typeof obj !== \"object\" || obj === null) {\n            return typeof obj;\n        }\n        const structure = {};\n        Object.keys(obj).forEach((key)=>{\n            if (Array.isArray(obj[key])) {\n                structure[key] = \"Array[\".concat(obj[key].length, \"]\");\n            } else if (typeof obj[key] === \"object\" && obj[key] !== null) {\n                structure[key] = this.getXMLStructure(obj[key], maxDepth, currentDepth + 1);\n            } else {\n                structure[key] = typeof obj[key];\n            }\n        });\n        return structure;\n    }\n    static isFormattingAttribute(attributeName) {\n        const formattingAttributes = [\n            \"@_PointSize\",\n            \"@_Leading\",\n            \"@_Tracking\",\n            \"@_FontStyle\",\n            \"@_AppliedFont\",\n            \"@_FillColor\",\n            \"@_StrokeColor\",\n            \"@_Justification\",\n            \"@_LeftIndent\",\n            \"@_RightIndent\",\n            \"@_FirstLineIndent\",\n            \"@_SpaceBefore\",\n            \"@_SpaceAfter\",\n            \"@_Alignment\"\n        ];\n        return formattingAttributes.includes(attributeName);\n    }\n    static saveDebugInfo(debugInfo, fileName) {\n        try {\n            fs.writeFileSync(fileName, JSON.stringify(debugInfo, null, 2));\n            console.log(\"✅ Debug info saved to \".concat(fileName));\n        } catch (error) {\n            console.error(\"❌ Error saving debug info:\", error);\n            console.log(\"Debug info (first 2000 chars):\", JSON.stringify(debugInfo, null, 2).substring(0, 2000));\n        }\n    }\n}\nmodule.exports = IDMLUtils;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDQTtTQUNEO1FBQ0QsT0FBT0EscUJBQXFCOUYsUUFBUSxDQUFDNkY7SUFDdkM7SUFFQSxPQUFPRSxjQUFjQyxTQUFTLEVBQUVsRixRQUFRLEVBQUU7UUFDeEMsSUFBSTtZQUNGbEYsR0FBR3FLLGFBQWEsQ0FBQ25GLFVBQVViLEtBQUtDLFNBQVMsQ0FBQzhGLFdBQVcsTUFBTTtZQUMzRGhLLFFBQVFDLEdBQUcsQ0FBQyx5QkFBa0MsT0FBVDZFO1FBQ3ZDLEVBQUUsT0FBT3NELE9BQU87WUFDZHBJLFFBQVFvSSxLQUFLLENBQUMsOEJBQThCQTtZQUM1Q3BJLFFBQVFDLEdBQUcsQ0FDVCxrQ0FDQWdFLEtBQUtDLFNBQVMsQ0FBQzhGLFdBQVcsTUFBTSxHQUFHRSxTQUFTLENBQUMsR0FBRztRQUVwRDtJQUNGO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHdksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3V0aWxzL0lETUxVdGlscy5qcz84ZDJmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcblxyXG5jbGFzcyBJRE1MVXRpbHMge1xyXG4gIHN0YXRpYyBwYXJzZUdlb21ldHJpY0JvdW5kcyhib3VuZHNTdHJpbmcpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IGJvdW5kc1N0cmluZyA9XCIsIGJvdW5kc1N0cmluZyk7XHJcbiAgICBpZiAoIWJvdW5kc1N0cmluZyB8fCBib3VuZHNTdHJpbmcgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiBNaXNzaW5nIGdlb21ldHJpYyBib3VuZHMsIHVzaW5nIGRlZmF1bHRzXCIpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMTAwLFxyXG4gICAgICAgIHJpZ2h0OiAxMDAsXHJcbiAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBib3VuZHMgPSBib3VuZHNTdHJpbmcuc3BsaXQoXCIgXCIpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgdG9wOiBib3VuZHNbMF0gfHwgMCxcclxuICAgICAgbGVmdDogYm91bmRzWzFdIHx8IDAsXHJcbiAgICAgIGJvdHRvbTogYm91bmRzWzJdIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBib3VuZHNbM10gfHwgMCxcclxuICAgICAgd2lkdGg6IChib3VuZHNbM10gfHwgMCkgLSAoYm91bmRzWzFdIHx8IDApLFxyXG4gICAgICBoZWlnaHQ6IChib3VuZHNbMl0gfHwgMCkgLSAoYm91bmRzWzBdIHx8IDApLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlBhcnNlZCBib3VuZHM6XCIsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybVN0cmluZykge1xyXG4gICAgaWYgKCF0cmFuc2Zvcm1TdHJpbmcpIHJldHVybiB7IGE6IDEsIGI6IDAsIGM6IDAsIGQ6IDEsIHR4OiAwLCB0eTogMCB9O1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IHRyYW5zZm9ybVN0cmluZy5zcGxpdChcIiBcIikubWFwKHBhcnNlRmxvYXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYTogdmFsdWVzWzBdIHx8IDEsIC8vIHggc2NhbGVcclxuICAgICAgYjogdmFsdWVzWzFdIHx8IDAsIC8vIHkgc2tld1xyXG4gICAgICBjOiB2YWx1ZXNbMl0gfHwgMCwgLy8geCBza2V3XHJcbiAgICAgIGQ6IHZhbHVlc1szXSB8fCAxLCAvLyB5IHNjYWxlXHJcbiAgICAgIHR4OiB2YWx1ZXNbNF0gfHwgMCwgLy8geCB0cmFuc2xhdGlvblxyXG4gICAgICB0eTogdmFsdWVzWzVdIHx8IDAsIC8vIHkgdHJhbnNsYXRpb25cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlUm90YXRpb24odHJhbnNmb3JtKSB7XHJcbiAgICAvLyBDYWxjdWxhdGUgcm90YXRpb24gYW5nbGUgZnJvbSB0cmFuc2Zvcm0gbWF0cml4XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmEpICogKDE4MCAvIE1hdGguUEkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUNvcm5lcnMoYm91bmRzLCB0cmFuc2Zvcm0pIHtcclxuICAgIGNvbnN0IGNvcm5lcnMgPSB7XHJcbiAgICAgIHRvcExlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy50b3AgfSxcclxuICAgICAgdG9wUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMudG9wIH0sXHJcbiAgICAgIGJvdHRvbUxlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy5ib3R0b20gfSxcclxuICAgICAgYm90dG9tUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMuYm90dG9tIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIGNvcm5lcnNcclxuICAgIE9iamVjdC5rZXlzKGNvcm5lcnMpLmZvckVhY2goKGNvcm5lcikgPT4ge1xyXG4gICAgICBjb25zdCBwb2ludCA9IGNvcm5lcnNbY29ybmVyXTtcclxuICAgICAgY29ybmVyc1tjb3JuZXJdID0ge1xyXG4gICAgICAgIHg6IHRyYW5zZm9ybS5hICogcG9pbnQueCArIHRyYW5zZm9ybS5jICogcG9pbnQueSArIHRyYW5zZm9ybS50eCxcclxuICAgICAgICB5OiB0cmFuc2Zvcm0uYiAqIHBvaW50LnggKyB0cmFuc2Zvcm0uZCAqIHBvaW50LnkgKyB0cmFuc2Zvcm0udHksXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29ybmVycztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjbXlrVG9SZ2IoYywgbSwgeSwgaykge1xyXG4gICAgLy8gQ29udmVydCBDTVlLIHBlcmNlbnRhZ2VzICgwLTEwMCkgdG8gUkdCICgwLTI1NSlcclxuICAgIGMgPSBjIC8gMTAwO1xyXG4gICAgbSA9IG0gLyAxMDA7XHJcbiAgICB5ID0geSAvIDEwMDtcclxuICAgIGsgPSBrIC8gMTAwO1xyXG5cclxuICAgIGNvbnN0IHIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gYykgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGcgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gbSkgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0geSkgKiAoMSAtIGspKTtcclxuXHJcbiAgICByZXR1cm4geyByLCBnLCBiIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VJbkRlc2lnbkNvbG9yKGNvbG9yUmVmKSB7XHJcbiAgICBpZiAoIWNvbG9yUmVmIHx8IGNvbG9yUmVmID09PSBcIkNvbG9yL05vbmVcIikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gSGFuZGxlIENNWUsgY29sb3JzXHJcbiAgICBjb25zdCBjbXlrTWF0Y2ggPSBjb2xvclJlZi5tYXRjaChcclxuICAgICAgL0NvbG9yXFwvQz0oXFxkKylcXHMqTT0oXFxkKylcXHMqWT0oXFxkKylcXHMqSz0oXFxkKykvXHJcbiAgICApO1xyXG4gICAgaWYgKGNteWtNYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCBjLCBtLCB5LCBrXSA9IGNteWtNYXRjaC5tYXAoTnVtYmVyKTtcclxuICAgICAgY29uc3QgcmdiID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cmdiLnJ9LCAke3JnYi5nfSwgJHtyZ2IuYn0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgUkdCIGNvbG9yc1xyXG4gICAgY29uc3QgcmdiTWF0Y2ggPSBjb2xvclJlZi5tYXRjaCgvQ29sb3JcXC9SPShcXGQrKVxccypHPShcXGQrKVxccypCPShcXGQrKS8pO1xyXG4gICAgaWYgKHJnYk1hdGNoKSB7XHJcbiAgICAgIGNvbnN0IFssIHIsIGcsIGJdID0gcmdiTWF0Y2gubWFwKE51bWJlcik7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGFuZGFyZCBjb2xvcnNcclxuICAgIGNvbnN0IHN0YW5kYXJkQ29sb3JzID0ge1xyXG4gICAgICBcIkNvbG9yL0JsYWNrXCI6IFwicmdiKDAsIDAsIDApXCIsXHJcbiAgICAgIFwiQ29sb3IvV2hpdGVcIjogXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIixcclxuICAgICAgXCJDb2xvci9SZWRcIjogXCJyZ2IoMjU1LCAwLCAwKVwiLFxyXG4gICAgICBcIkNvbG9yL0dyZWVuXCI6IFwicmdiKDAsIDI1NSwgMClcIixcclxuICAgICAgXCJDb2xvci9CbHVlXCI6IFwicmdiKDAsIDAsIDI1NSlcIixcclxuICAgICAgXCJDb2xvci9DeWFuXCI6IFwicmdiKDAsIDI1NSwgMjU1KVwiLFxyXG4gICAgICBcIkNvbG9yL01hZ2VudGFcIjogXCJyZ2IoMjU1LCAwLCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvWWVsbG93XCI6IFwicmdiKDI1NSwgMjU1LCAwKVwiLFxyXG4gICAgICBcIkNvbG9yL1BhcGVyXCI6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvUmVnaXN0cmF0aW9uXCI6IFwicmdiKDAsIDAsIDApXCIsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBzdGFuZGFyZENvbG9yc1tjb2xvclJlZl0gfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBkZWNvZGVYTUxFbnRpdGllcyh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMDBBOy9nLCBcIlxcblwiKSAvLyBMaW5lIGZlZWRcclxuICAgICAgLnJlcGxhY2UoLyYjeDAwMEQ7L2csIFwiXFxyXCIpIC8vIENhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiN4MDAwOTsvZywgXCJcXHRcIikgLy8gVGFiXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMEEwOy9nLCBcIlxcdTAwQTBcIikgLy8gTm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gyMDI4Oy9nLCBcIlxcblwiKSAvLyBMaW5lIHNlcGFyYXRvclxyXG4gICAgICAucmVwbGFjZSgvJiN4MjAyOTsvZywgXCJcXHUyMDI5XCIpIC8vIFBhcmFncmFwaCBzZXBhcmF0b3JcclxuICAgICAgLnJlcGxhY2UoLyYjMTA7L2csIFwiXFxuXCIpIC8vIERlY2ltYWwgbGluZSBmZWVkXHJcbiAgICAgIC5yZXBsYWNlKC8mIzEzOy9nLCBcIlxcclwiKSAvLyBEZWNpbWFsIGNhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiM5Oy9nLCBcIlxcdFwiKSAvLyBEZWNpbWFsIHRhYlxyXG4gICAgICAucmVwbGFjZSgvJiMxNjA7L2csIFwiXFx1MDBBMFwiKSAvLyBEZWNpbWFsIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAucmVwbGFjZSgvJmx0Oy9nLCBcIjxcIikgLy8gTGVzcyB0aGFuXHJcbiAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKSAvLyBHcmVhdGVyIHRoYW5cclxuICAgICAgLnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKSAvLyBBbXBlcnNhbmQgKG11c3QgYmUgbGFzdClcclxuICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKSAvLyBRdW90ZVxyXG4gICAgICAucmVwbGFjZSgvJmFwb3M7L2csIFwiJ1wiKTsgLy8gQXBvc3Ryb3BoZVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNsZWFuVGV4dENvbnRlbnQoY29udGVudCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgY29udGVudFxyXG4gICAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIikgLy8gTm9ybWFsaXplIFdpbmRvd3MgbGluZSBicmVha3NcclxuICAgICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCBcIiAgICBcIikgLy8gQ29udmVydCB0YWJzIHRvIHNwYWNlc1xyXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMEEwL2csIFwiIFwiKSAvLyBDb252ZXJ0IG5vbi1icmVha2luZyBzcGFjZXNcclxuICAgICAgICAucmVwbGFjZSgvICsvZywgXCIgXCIpIC8vIENvbGxhcHNlIG11bHRpcGxlIHNwYWNlc1xyXG4gICAgICAgIC8vIFJFTU9WRUQ6IC5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKSAgLy8gQWxsb3cgdW5saW1pdGVkIGNvbnNlY3V0aXZlIGxpbmUgYnJlYWtzXHJcbiAgICAgICAgLnRyaW0oKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwcmVzZXJ2ZUxpbmVCcmVha3MoY29udGVudCkge1xyXG4gICAgcmV0dXJuIGNvbnRlbnRcclxuICAgICAgLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKSAvLyBOb3JtYWxpemUgV2luZG93cyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpIC8vIENvbnZlcnQgbGluZSBzZXBhcmF0b3JzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpOyAvLyBDb252ZXJ0IHBhcmFncmFwaCBzZXBhcmF0b3JzXHJcbiAgICAvLyBSRU1PVkVEOiAucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJyk7IC8vIEFsbG93IHVubGltaXRlZCBjb25zZWN1dGl2ZSBsaW5lIGJyZWFrc1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBDbGVhbiB1cCBleGNlc3NpdmUgbGluZSBicmVha3MgdG8gcHJldmVudCB0ZXh0IG92ZXJmbG93XHJcbiAgc3RhdGljIGNsZWFuVGV4dEZvclJlbmRlcmluZyh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiBcIlwiO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGV4dFxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBsaW5lIGVuZGluZ3NcclxuICAgICAgICAucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKVxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG9uIGVhY2ggbGluZSBvbmx5XHJcbiAgICAgICAgLnJlcGxhY2UoL1sgXFx0XStcXG4vZywgXCJcXG5cIilcclxuICAgICk7XHJcbiAgICAvLyBETyBOT1QgY29sbGFwc2UgbXVsdGlwbGUgc3BhY2VzLCB0YWJzLCBvciBuZXdsaW5lc1xyXG4gICAgLy8gRE8gTk9UIHRyaW0gdGhlIHdob2xlIHN0cmluZ1xyXG4gIH1cclxuXHJcbiAgLy8gRU5IQU5DRUQ6IEJldHRlciBsaW5lIGJyZWFrIHByb2Nlc3NpbmcgdGhhdCBwcmVzZXJ2ZXMgd29yZCBzcGFjZXNcclxuICBzdGF0aWMgc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmcoY29udGVudCkge1xyXG4gICAgaWYgKCFjb250ZW50KSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAvLyBERUJVRzogVHJhY2sgaWYgcHJvYmxlbWF0aWMgdGV4dCBpcyBiZWluZyBwcm9jZXNzZWRcclxuICAgIGNvbnN0IGhhc1Byb2JsZW1hdGljVGV4dCA9XHJcbiAgICAgIGNvbnRlbnQuaW5jbHVkZXMoXCJwYXZvbHVwdHVzZGFcIikgfHxcclxuICAgICAgKGNvbnRlbnQuaW5jbHVkZXMoXCJwYVwiKSAmJiBjb250ZW50LmluY2x1ZGVzKFwidm9sdXB0dXNkYVwiKSk7XHJcbiAgICBpZiAoaGFzUHJvYmxlbWF0aWNUZXh0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3Npbmc6XCIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIiAgIC0gSW5wdXQ6XCIsIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaXJzdCBjbGVhbiB1cCB0aGUgY29udGVudCBidXQgcHJlc2VydmUgd29yZCBzcGFjZXNcclxuICAgIGxldCBwcm9jZXNzZWQgPSB0aGlzLmNsZWFuVGV4dEZvclJlbmRlcmluZyhjb250ZW50KS5yZXBsYWNlKFxyXG4gICAgICAvXFx1MjAyOC9nLFxyXG4gICAgICBcIlxcblwiXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChoYXNQcm9ibGVtYXRpY1RleHQpIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCIgICAtIEFmdGVyIGNsZWFuVGV4dEZvclJlbmRlcmluZzpcIixcclxuICAgICAgICBKU09OLnN0cmluZ2lmeShwcm9jZXNzZWQpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ybWFsaXplIGxpbmUgYnJlYWtzIGJ1dCBkb24ndCB0b3VjaCB3b3JkIHNwYWNlc1xyXG4gICAgLy8gcHJvY2Vzc2VkID0gcHJvY2Vzc2VkXHJcbiAgICAvLyAgIC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpICAgICAgLy8gTm9ybWFsaXplIFdpbmRvd3MgbGluZSBicmVha3NcclxuICAgIC8vICAgLnJlcGxhY2UoL1xcci9nLCAnXFxuJykgICAgICAgIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAvLyAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXG4nKSAgICAvLyBDb252ZXJ0IGxpbmUgc2VwYXJhdG9yc1xyXG4gICAgLy8gICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxuXFxuJykgIC8vIENvbnZlcnQgcGFyYWdyYXBoIHNlcGFyYXRvcnMgdG8gZG91YmxlIGJyZWFrc1xyXG4gICAgLy8gICAucmVwbGFjZSgvXFx1MDAwQS9nLCAnXFxuJyk7ICAgLy8gQ29udmVydCBleHBsaWNpdCBsaW5lIGZlZWQgY2hhcmFjdGVyc1xyXG5cclxuICAgIC8vIEVuc3VyZSBwYXJhZ3JhcGggYnJlYWtzIGFyZSBwcm9wZXJseSBzcGFjZWRcclxuICAgIC8vIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5yZXBsYWNlKC9cXG5cXG4rL2csICdcXG5cXG4nKTsgLy8gUkVNT1ZFIFRISVMgTElORSB0byBwcmVzZXJ2ZSBhbGwgY29uc2VjdXRpdmUgbmV3bGluZXNcclxuXHJcbiAgICByZXR1cm4gcHJvY2Vzc2VkO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNvdW50V29yZHModGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQuc3BsaXQoL1xccysvKS5maWx0ZXIoKHdvcmQpID0+IHdvcmQubGVuZ3RoID4gMCkubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlTnVtZXJpYyh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IFwiXCIpIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICByZXR1cm4gaXNOYU4obnVtKSA/IG51bGwgOiBudW07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaXNJbWFnZUZpbGUoZmlsZU5hbWUpIHtcclxuICAgIGNvbnN0IGltYWdlRXh0ZW5zaW9ucyA9IFtcclxuICAgICAgXCIuanBnXCIsXHJcbiAgICAgIFwiLmpwZWdcIixcclxuICAgICAgXCIucG5nXCIsXHJcbiAgICAgIFwiLmdpZlwiLFxyXG4gICAgICBcIi50aWZmXCIsXHJcbiAgICAgIFwiLnRpZlwiLFxyXG4gICAgICBcIi5ibXBcIixcclxuICAgICAgXCIuc3ZnXCIsXHJcbiAgICAgIFwiLmVwc1wiLFxyXG4gICAgICBcIi5haVwiLFxyXG4gICAgICBcIi5wc2RcIixcclxuICAgICAgXCIud2VicFwiLFxyXG4gICAgICBcIi5pY29cIixcclxuICAgICAgXCIuamZpZlwiLFxyXG4gICAgICBcIi5qcDJcIixcclxuICAgICAgXCIuanB4XCIsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGltYWdlRXh0ZW5zaW9ucy5zb21lKChleHQpID0+IGZpbGVOYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0SW1hZ2VFeHRlbnNpb24oaW1hZ2VUeXBlTmFtZSkge1xyXG4gICAgY29uc3QgdHlwZU1hcCA9IHtcclxuICAgICAgXCIkSUQvSlBFR1wiOiBcImpwZ1wiLFxyXG4gICAgICBcIiRJRC9QTkdcIjogXCJwbmdcIixcclxuICAgICAgXCIkSUQvVElGRlwiOiBcInRpZlwiLFxyXG4gICAgICBcIiRJRC9HSUZcIjogXCJnaWZcIixcclxuICAgICAgXCIkSUQvQk1QXCI6IFwiYm1wXCIsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHR5cGVNYXBbaW1hZ2VUeXBlTmFtZV0gfHwgXCJqcGdcIjtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRJbWFnZUV4dGVuc2lvbkZyb21Gb3JtYXQoZm9ybWF0KSB7XHJcbiAgICBjb25zdCBmb3JtYXRNYXAgPSB7XHJcbiAgICAgIFwiJElEL0pQRUdcIjogXCJqcGdcIixcclxuICAgICAgXCIkSUQvUE5HXCI6IFwicG5nXCIsXHJcbiAgICAgIFwiJElEL1RJRkZcIjogXCJ0aWZcIixcclxuICAgICAgXCIkSUQvR0lGXCI6IFwiZ2lmXCIsXHJcbiAgICAgIFwiJElEL0JNUFwiOiBcImJtcFwiLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBmb3JtYXRNYXBbZm9ybWF0XSB8fCBcImpwZ1wiO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGV4dHJhY3RJbWFnZU5hbWVGcm9tTGluayhsaW5rVXJpKSB7XHJcbiAgICBpZiAoIWxpbmtVcmkpIHJldHVybiBudWxsO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgZmlsZW5hbWUgZnJvbSBwYXRoIGxpa2UgXCJmaWxlOkM6L1VzZXJzL2xhbG8vRG93bmxvYWRzL1Rlc2xhLU1vZGVsLTMuanBnIDEzMzI1IFwiXHJcbiAgICBjb25zdCBtYXRjaCA9IGxpbmtVcmkubWF0Y2goLyhbXlxcL1xcXFxdKylcXC5bXi5dKyQvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KGVsZW1lbnRzKSB7XHJcbiAgICBpZiAoIWVsZW1lbnRzIHx8IGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCfmqsgTm8gZWxlbWVudHMgcHJvdmlkZWQgZm9yIGNvb3JkaW5hdGUgb2Zmc2V0IGNhbGN1bGF0aW9uXCIpO1xyXG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG1pblggPSBJbmZpbml0eSxcclxuICAgICAgbWluWSA9IEluZmluaXR5O1xyXG4gICAgbGV0IG1heFN0cm9rZVdpZHRoID0gMDtcclxuICAgIGxldCB2YWxpZEVsZW1lbnRzID0gMDtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCflI0gQU5BTFlaSU5HICR7ZWxlbWVudHMubGVuZ3RofSBlbGVtZW50cyBmb3IgY29vcmRpbmF0ZSBvZmZzZXQuLi5gXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEZpcnN0IHBhc3M6IGZpbmQgVFJVRSBtaW5pbXVtIGNvb3JkaW5hdGVzIGFjcm9zcyBhbGwgZWxlbWVudHNcclxuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGJvdW5kcyA9IGVsZW1lbnQuZ2VvbWV0cmljQm91bmRzIHx8IGVsZW1lbnQub3JpZ2luYWxCb3VuZHM7XHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVsZW1lbnQuaXRlbVRyYW5zZm9ybSB8fCB7IHR4OiAwLCB0eTogMCB9O1xyXG5cclxuICAgICAgaWYgKGJvdW5kcyAmJiAoYm91bmRzLmxlZnQgIT09IHVuZGVmaW5lZCB8fCBib3VuZHMudG9wICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZpbmFsIHBvc2l0aW9uIGFmdGVyIHRyYW5zZm9ybVxyXG4gICAgICAgIGNvbnN0IGZpbmFsWCA9IChib3VuZHMubGVmdCB8fCAwKSArICh0cmFuc2Zvcm0udHggfHwgMCk7XHJcbiAgICAgICAgY29uc3QgZmluYWxZID0gKGJvdW5kcy50b3AgfHwgMCkgKyAodHJhbnNmb3JtLnR5IHx8IDApO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGAgICBFbGVtZW50ICR7aW5kZXh9OiBib3VuZHMoJHtib3VuZHMubGVmdH0sICR7Ym91bmRzLnRvcH0pICsgdHJhbnNmb3JtKCR7dHJhbnNmb3JtLnR4fSwgJHt0cmFuc2Zvcm0udHl9KSA9IGZpbmFsKCR7ZmluYWxYfSwgJHtmaW5hbFl9KWBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgZmluYWxYKTtcclxuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgZmluYWxZKTtcclxuICAgICAgICB2YWxpZEVsZW1lbnRzKys7XHJcblxyXG4gICAgICAgIC8vIFRyYWNrIG1heGltdW0gc3Ryb2tlIHdpZHRoIGZvciBpbnRlbGxpZ2VudCBwYWRkaW5nXHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBlbGVtZW50LnN0cm9rZVdlaWdodCB8fCAwO1xyXG4gICAgICAgIG1heFN0cm9rZVdpZHRoID0gTWF0aC5tYXgobWF4U3Ryb2tlV2lkdGgsIHN0cm9rZVdpZHRoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgICAgRWxlbWVudCAke2luZGV4fTogTm8gdmFsaWQgYm91bmRzIC0gc2tpcHBpbmdgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgbm8gdmFsaWQgZWxlbWVudHMgZm91bmRcclxuICAgIGlmICh2YWxpZEVsZW1lbnRzID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwi4pqg77iPICBObyB2YWxpZCBlbGVtZW50cyB3aXRoIGJvdW5kcyBmb3VuZCAtIHVzaW5nIHplcm8gb2Zmc2V0XCJcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGluZmluaXRlIHZhbHVlcyB0byAwIGlmIG5vIHZhbGlkIGNvb3JkaW5hdGVzIGZvdW5kXHJcbiAgICBpZiAobWluWCA9PT0gSW5maW5pdHkpIG1pblggPSAwO1xyXG4gICAgaWYgKG1pblkgPT09IEluZmluaXR5KSBtaW5ZID0gMDtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCfk4ogQU5BTFlTSVMgQ09NUExFVEU6IG1pblg9JHttaW5YfSwgbWluWT0ke21pbll9LCBtYXhTdHJva2U9JHttYXhTdHJva2VXaWR0aH1weCwgdmFsaWRFbGVtZW50cz0ke3ZhbGlkRWxlbWVudHN9YFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBaRVJPLUJBU0VEIE9GRlNFVCBDQUxDVUxBVElPTjpcclxuICAgIC8vIFRoZSBnb2FsIGlzIHRvIGhhdmUgTk8gT0ZGU0VUIHVubGVzcyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBmb3IgbmVnYXRpdmUgY29vcmRpbmF0ZXNcclxuICAgIGxldCBvZmZzZXRYID0gMDtcclxuICAgIGxldCBvZmZzZXRZID0gMDtcclxuXHJcbiAgICAvLyBPbmx5IGFkZCBvZmZzZXQgaWYgY29vcmRpbmF0ZXMgYXJlIGFjdHVhbGx5IG5lZ2F0aXZlXHJcbiAgICBpZiAobWluWCA8IDApIHtcclxuICAgICAgb2Zmc2V0WCA9IE1hdGguYWJzKG1pblgpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4p2MIE5lZ2F0aXZlIFggZGV0ZWN0ZWQ6ICR7bWluWH0g4oaSIGFkZGluZyBvZmZzZXQ6ICR7b2Zmc2V0WH1gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1pblkgPCAwKSB7XHJcbiAgICAgIG9mZnNldFkgPSBNYXRoLmFicyhtaW5ZKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKdjCBOZWdhdGl2ZSBZIGRldGVjdGVkOiAke21pbll9IOKGkiBhZGRpbmcgb2Zmc2V0OiAke29mZnNldFl9YFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBtaW5pbWFsIHN0cm9rZSBwYWRkaW5nIG9ubHkgaWYgd2UgYWxyZWFkeSBoYXZlIGFuIG9mZnNldFxyXG4gICAgaWYgKChvZmZzZXRYID4gMCB8fCBvZmZzZXRZID4gMCkgJiYgbWF4U3Ryb2tlV2lkdGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IHN0cm9rZVBhZGRpbmcgPSBNYXRoLmNlaWwobWF4U3Ryb2tlV2lkdGggLyAyKTtcclxuICAgICAgaWYgKG9mZnNldFggPiAwKSBvZmZzZXRYICs9IHN0cm9rZVBhZGRpbmc7XHJcbiAgICAgIGlmIChvZmZzZXRZID4gMCkgb2Zmc2V0WSArPSBzdHJva2VQYWRkaW5nO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+WjO+4jyBBZGRlZCBzdHJva2UgcGFkZGluZzogJHtzdHJva2VQYWRkaW5nfXB4YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYPCfjq8gRklOQUwgT0ZGU0VUOiBYPSR7b2Zmc2V0WH0sIFk9JHtvZmZzZXRZfWApO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGAgICAke1xyXG4gICAgICAgIG9mZnNldFggPT09IDBcclxuICAgICAgICAgID8gXCLinIUgUGVyZmVjdCEgTm8gWCBvZmZzZXQgbmVlZGVkXCJcclxuICAgICAgICAgIDogYOKaoO+4jyBYIG9mZnNldDogJHtvZmZzZXRYfXB4ICgke21pblh9IHdhcyBuZWdhdGl2ZSlgXHJcbiAgICAgIH1gXHJcbiAgICApO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGAgICAke1xyXG4gICAgICAgIG9mZnNldFkgPT09IDBcclxuICAgICAgICAgID8gXCLinIUgUGVyZmVjdCEgTm8gWSBvZmZzZXQgbmVlZGVkXCJcclxuICAgICAgICAgIDogYOKaoO+4jyBZIG9mZnNldDogJHtvZmZzZXRZfXB4ICgke21pbll9IHdhcyBuZWdhdGl2ZSlgXHJcbiAgICAgIH1gXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7IHg6IG9mZnNldFgsIHk6IG9mZnNldFkgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBwcmVjaXNlIGNvb3JkaW5hdGUgb2Zmc2V0IGZvciBwaXhlbC1wZXJmZWN0IEluRGVzaWduIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9uXHJcbiAgICogVGhpcyBlbnN1cmVzIGFjY3VyYXRlIHBvc2l0aW9uaW5nIHNpbWlsYXIgdG8gcHJvZmVzc2lvbmFsIHRvb2xzIGxpa2UgSU1HLkxZIEluRGVzaWduXHJcbiAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgLSBBcnJheSBvZiBlbGVtZW50cyB3aXRoIGJvdW5kcyBhbmQgdHJhbnNmb3Jtc1xyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0ge3gsIHl9IG9mZnNldCBmb3IgY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvblxyXG4gICAqL1xyXG4gIHN0YXRpYyBjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0UHJlY2lzZShlbGVtZW50cykge1xyXG4gICAgaWYgKCFlbGVtZW50cyB8fCBlbGVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS53YXJuKFwi8J+OryBObyBlbGVtZW50cyBwcm92aWRlZCBmb3IgY29vcmRpbmF0ZSBvZmZzZXQgY2FsY3VsYXRpb25cIik7XHJcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgXCLwn5SNIEFOQUxZWklOR1wiLFxyXG4gICAgICBlbGVtZW50cy5sZW5ndGgsXHJcbiAgICAgIFwiZWxlbWVudHMgZm9yIFBSRUNJU0UgY29vcmRpbmF0ZSBvZmZzZXQuLi5cIlxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgbWluWCA9IEluZmluaXR5O1xyXG4gICAgbGV0IG1pblkgPSBJbmZpbml0eTtcclxuICAgIGxldCBtYXhTdHJva2UgPSAwO1xyXG4gICAgbGV0IHZhbGlkRWxlbWVudHMgPSAwO1xyXG5cclxuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmICghZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMgfHwgIWVsZW1lbnQuaXRlbVRyYW5zZm9ybSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgIGAgICDimqDvuI8gRWxlbWVudCAke2luZGV4fSBtaXNzaW5nIGJvdW5kcy90cmFuc2Zvcm0gLSBza2lwcGluZ2BcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIGZpbmFsIHBvc2l0aW9uIChib3VuZHMgKyB0cmFuc2Zvcm0pXHJcbiAgICAgIGNvbnN0IGZpbmFsWCA9IGVsZW1lbnQuZ2VvbWV0cmljQm91bmRzLmxlZnQgKyBlbGVtZW50Lml0ZW1UcmFuc2Zvcm0udHg7XHJcbiAgICAgIGNvbnN0IGZpbmFsWSA9IGVsZW1lbnQuZ2VvbWV0cmljQm91bmRzLnRvcCArIGVsZW1lbnQuaXRlbVRyYW5zZm9ybS50eTtcclxuXHJcbiAgICAgIC8vIFRyYWNrIHN0cm9rZSB3aWR0aCBmb3IgcHJlY2lzZSBwb3NpdGlvbmluZ1xyXG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IGVsZW1lbnQuc3Ryb2tlV2VpZ2h0IHx8IDA7XHJcbiAgICAgIG1heFN0cm9rZSA9IE1hdGgubWF4KG1heFN0cm9rZSwgc3Ryb2tlV2lkdGgpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYCAgIEVsZW1lbnQgJHtpbmRleH06IGJvdW5kcygke2VsZW1lbnQuZ2VvbWV0cmljQm91bmRzLmxlZnR9LCAke2VsZW1lbnQuZ2VvbWV0cmljQm91bmRzLnRvcH0pICsgdHJhbnNmb3JtKCR7ZWxlbWVudC5pdGVtVHJhbnNmb3JtLnR4fSwgJHtlbGVtZW50Lml0ZW1UcmFuc2Zvcm0udHl9KSA9IGZpbmFsKCR7ZmluYWxYfSwgJHtmaW5hbFl9KWBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBmaW5hbFgpO1xyXG4gICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgZmluYWxZKTtcclxuICAgICAgdmFsaWRFbGVtZW50cysrO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwi8J+TiiBBTkFMWVNJUyBDT01QTEVURTpcIixcclxuICAgICAgYG1pblg9JHttaW5YfSwgbWluWT0ke21pbll9LCBtYXhTdHJva2U9JHttYXhTdHJva2V9cHgsIHZhbGlkRWxlbWVudHM9JHt2YWxpZEVsZW1lbnRzfWBcclxuICAgICk7XHJcblxyXG4gICAgLy8gRklYRUQ6IE9ubHkgYWRkIG9mZnNldCBpZiBjb29yZGluYXRlcyBhcmUgYWN0dWFsbHkgbmVnYXRpdmVcclxuICAgIC8vIERvbid0IGZvcmNlIGVsZW1lbnRzIHRvIHN0YXJ0IGF0IG9yaWdpbiAtIHByZXNlcnZlIEluRGVzaWduIHBvc2l0aW9uaW5nXHJcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XHJcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XHJcblxyXG4gICAgLy8gT25seSBoYW5kbGUgbmVnYXRpdmUgY29vcmRpbmF0ZXMgdGhhdCB3b3VsZCBiZSBjbGlwcGVkIGJ5IHRoZSBicm93c2VyXHJcbiAgICBpZiAobWluWCA8IDApIHtcclxuICAgICAgb2Zmc2V0WCA9IE1hdGguYWJzKG1pblgpICsgbWF4U3Ryb2tlO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4p2MIE5lZ2F0aXZlIFggZGV0ZWN0ZWQ6ICR7bWluWH0g4oaSIGFkZGluZyBvZmZzZXQ6ICR7b2Zmc2V0WH1gXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFBvc2l0aXZlIFggY29vcmRpbmF0ZXM6ICR7bWluWH0g4oaSIG5vIG9mZnNldCBuZWVkZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWluWSA8IDApIHtcclxuICAgICAgb2Zmc2V0WSA9IE1hdGguYWJzKG1pblkpICsgbWF4U3Ryb2tlO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4p2MIE5lZ2F0aXZlIFkgZGV0ZWN0ZWQ6ICR7bWluWX0g4oaSIGFkZGluZyBvZmZzZXQ6ICR7b2Zmc2V0WX1gXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFBvc2l0aXZlIFkgY29vcmRpbmF0ZXM6ICR7bWluWX0g4oaSIG5vIG9mZnNldCBuZWVkZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmaW5hbE9mZnNldCA9IHsgeDogb2Zmc2V0WCwgeTogb2Zmc2V0WSB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwi8J+OryBGSU5BTCBQUkVDSVNFIE9GRlNFVDpcIiwgYFg9JHtvZmZzZXRYfSwgWT0ke29mZnNldFl9YCk7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYCAgICR7XHJcbiAgICAgICAgb2Zmc2V0WCA9PT0gMFxyXG4gICAgICAgICAgPyBcIuKchSBQZXJmZWN0ISBObyBYIG9mZnNldCBuZWVkZWRcIlxyXG4gICAgICAgICAgOiBg4pqg77iPIFggb2Zmc2V0OiAke29mZnNldFh9cHggKGNvbXBlbnNhdGluZyBmb3IgbmVnYXRpdmUgY29vcmRpbmF0ZXMpYFxyXG4gICAgICB9YFxyXG4gICAgKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBgICAgJHtcclxuICAgICAgICBvZmZzZXRZID09PSAwXHJcbiAgICAgICAgICA/IFwi4pyFIFBlcmZlY3QhIE5vIFkgb2Zmc2V0IG5lZWRlZFwiXHJcbiAgICAgICAgICA6IGDimqDvuI8gWSBvZmZzZXQ6ICR7b2Zmc2V0WX1weCAoY29tcGVuc2F0aW5nIGZvciBuZWdhdGl2ZSBjb29yZGluYXRlcylgXHJcbiAgICAgIH1gXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBmaW5hbE9mZnNldDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVCb3VuZHNGcm9tUGF0aChpdGVtKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IGJvdW5kcyBmcm9tIEdlb21ldHJpY0JvdW5kcyBhdHRyaWJ1dGVcclxuICAgICAgaWYgKGl0ZW1bXCJAX0dlb21ldHJpY0JvdW5kc1wiXSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlR2VvbWV0cmljQm91bmRzKGl0ZW1bXCJAX0dlb21ldHJpY0JvdW5kc1wiXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZW4gdHJ5IHBhdGggZ2VvbWV0cnlcclxuICAgICAgY29uc3QgcGF0aEdlb21ldHJ5ID1cclxuICAgICAgICBpdGVtPy5Qcm9wZXJ0aWVzPy5QYXRoR2VvbWV0cnk/Lkdlb21ldHJ5UGF0aFR5cGU/LlBhdGhQb2ludEFycmF5XHJcbiAgICAgICAgICA/LlBhdGhQb2ludFR5cGU7XHJcblxyXG4gICAgICBpZiAoIXBhdGhHZW9tZXRyeSB8fCAhQXJyYXkuaXNBcnJheShwYXRoR2VvbWV0cnkpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgV2FybmluZzogTm8gZ2VvbWV0cnkgZm91bmQgZm9yICR7aXRlbVtcIkBfU2VsZlwiXX0sIHVzaW5nIGl0ZW0gdHJhbnNmb3JtYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGl0ZW0gdHJhbnNmb3JtIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMucGFyc2VUcmFuc2Zvcm0oaXRlbVtcIkBfSXRlbVRyYW5zZm9ybVwiXSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHRvcDogdHJhbnNmb3JtLnR5IHx8IDAsXHJcbiAgICAgICAgICBsZWZ0OiB0cmFuc2Zvcm0udHggfHwgMCxcclxuICAgICAgICAgIGJvdHRvbTogKHRyYW5zZm9ybS50eSB8fCAwKSArIDEwMCwgLy8gRGVmYXVsdCBoZWlnaHRcclxuICAgICAgICAgIHJpZ2h0OiAodHJhbnNmb3JtLnR4IHx8IDApICsgMTAwLCAvLyBEZWZhdWx0IHdpZHRoXHJcbiAgICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgICAgaGVpZ2h0OiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IG1pblggPSBJbmZpbml0eSxcclxuICAgICAgICBtaW5ZID0gSW5maW5pdHksXHJcbiAgICAgICAgbWF4WCA9IC1JbmZpbml0eSxcclxuICAgICAgICBtYXhZID0gLUluZmluaXR5O1xyXG5cclxuICAgICAgcGF0aEdlb21ldHJ5LmZvckVhY2goKHBvaW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yID0gcG9pbnRbXCJAX0FuY2hvclwiXTtcclxuICAgICAgICBpZiAoYW5jaG9yKSB7XHJcbiAgICAgICAgICBjb25zdCBbeCwgeV0gPSBhbmNob3Iuc3BsaXQoXCIgXCIpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgICAgICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XHJcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcclxuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xyXG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XHJcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKG1pblggPT09IEluZmluaXR5IHx8IG1pblkgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgV2FybmluZzogQ291bGQgbm90IGNhbGN1bGF0ZSBib3VuZHMgZm9yICR7aXRlbVtcIkBfU2VsZlwiXX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgIGJvdHRvbTogMTAwLFxyXG4gICAgICAgICAgcmlnaHQ6IDEwMCxcclxuICAgICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogbWluWSxcclxuICAgICAgICBsZWZ0OiBtaW5YLFxyXG4gICAgICAgIGJvdHRvbTogbWF4WSxcclxuICAgICAgICByaWdodDogbWF4WCxcclxuICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXHJcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWSxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNhbGN1bGF0aW5nIGJvdW5kcyBmb3IgJHtpdGVtW1wiQF9TZWxmXCJdfTpgLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgYm90dG9tOiAxMDAsXHJcbiAgICAgICAgcmlnaHQ6IDEwMCxcclxuICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZVJlbGF0aXZlUG9zaXRpb24oXHJcbiAgICBmcmFtZUJvdW5kcyxcclxuICAgIGNvbnRlbnRCb3VuZHMsXHJcbiAgICBmcmFtZVRyYW5zZm9ybSxcclxuICAgIGNvbnRlbnRUcmFuc2Zvcm1cclxuICApIHtcclxuICAgIGlmICghZnJhbWVCb3VuZHMgfHwgIWNvbnRlbnRCb3VuZHMpIHJldHVybiBudWxsO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9mZnNldFg6IChjb250ZW50Qm91bmRzLmxlZnQgfHwgMCkgLSAoZnJhbWVCb3VuZHMubGVmdCB8fCAwKSxcclxuICAgICAgb2Zmc2V0WTogKGNvbnRlbnRCb3VuZHMudG9wIHx8IDApIC0gKGZyYW1lQm91bmRzLnRvcCB8fCAwKSxcclxuICAgICAgc2NhbGVYOiBjb250ZW50VHJhbnNmb3JtPy5hIHx8IDEsXHJcbiAgICAgIHNjYWxlWTogY29udGVudFRyYW5zZm9ybT8uZCB8fCAxLFxyXG4gICAgICB0cmFuc2Zvcm1EaWZmZXJlbmNlOiB7XHJcbiAgICAgICAgZnJhbWU6IGZyYW1lVHJhbnNmb3JtLFxyXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRUcmFuc2Zvcm0sXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUdhcChmcmFtZUJvdW5kcywgY29udGVudEJvdW5kcykge1xyXG4gICAgaWYgKCFmcmFtZUJvdW5kcyB8fCAhY29udGVudEJvdW5kcykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiAoY29udGVudEJvdW5kcy50b3AgfHwgMCkgLSAoZnJhbWVCb3VuZHMudG9wIHx8IDApLFxyXG4gICAgICBsZWZ0OiAoY29udGVudEJvdW5kcy5sZWZ0IHx8IDApIC0gKGZyYW1lQm91bmRzLmxlZnQgfHwgMCksXHJcbiAgICAgIGJvdHRvbTogKGZyYW1lQm91bmRzLmJvdHRvbSB8fCAwKSAtIChjb250ZW50Qm91bmRzLmJvdHRvbSB8fCAwKSxcclxuICAgICAgcmlnaHQ6IChmcmFtZUJvdW5kcy5yaWdodCB8fCAwKSAtIChjb250ZW50Qm91bmRzLnJpZ2h0IHx8IDApLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVJbWFnZVBvc2l0aW9uSW5GcmFtZShcclxuICAgIGZyYW1lQm91bmRzLFxyXG4gICAgZnJhbWVUcmFuc2Zvcm0sXHJcbiAgICBwbGFjZWRDb250ZW50XHJcbiAgKSB7XHJcbiAgICBpZiAoIWZyYW1lQm91bmRzIHx8ICFwbGFjZWRDb250ZW50Py50cmFuc2Zvcm0pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW1hZ2VUcmFuc2Zvcm0gPSBwbGFjZWRDb250ZW50LnRyYW5zZm9ybTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgaW1hZ2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gZnJhbWVcclxuICAgIGNvbnN0IGltYWdlWCA9IChmcmFtZUJvdW5kcy5sZWZ0IHx8IDApICsgKGltYWdlVHJhbnNmb3JtLnR4IHx8IDApO1xyXG4gICAgY29uc3QgaW1hZ2VZID0gKGZyYW1lQm91bmRzLnRvcCB8fCAwKSArIChpbWFnZVRyYW5zZm9ybS50eSB8fCAwKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgaW1hZ2Ugc2l6ZSB3aXRoIHNjYWxpbmdcclxuICAgIGNvbnN0IGltYWdlV2lkdGggPSAoZnJhbWVCb3VuZHMud2lkdGggfHwgMCkgKiAoaW1hZ2VUcmFuc2Zvcm0uYSB8fCAxKTtcclxuICAgIGNvbnN0IGltYWdlSGVpZ2h0ID0gKGZyYW1lQm91bmRzLmhlaWdodCB8fCAwKSAqIChpbWFnZVRyYW5zZm9ybS5kIHx8IDEpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGltYWdlWCxcclxuICAgICAgeTogaW1hZ2VZLFxyXG4gICAgICB3aWR0aDogaW1hZ2VXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBpbWFnZUhlaWdodCxcclxuICAgICAgc2NhbGVYOiBpbWFnZVRyYW5zZm9ybS5hIHx8IDEsXHJcbiAgICAgIHNjYWxlWTogaW1hZ2VUcmFuc2Zvcm0uZCB8fCAxLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRYTUxTdHJ1Y3R1cmUob2JqLCBtYXhEZXB0aCA9IDMsIGN1cnJlbnREZXB0aCA9IDApIHtcclxuICAgIGlmIChjdXJyZW50RGVwdGggPj0gbWF4RGVwdGggfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RydWN0dXJlID0ge307XHJcblxyXG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XHJcbiAgICAgICAgc3RydWN0dXJlW2tleV0gPSBgQXJyYXlbJHtvYmpba2V5XS5sZW5ndGh9XWA7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtrZXldID09PSBcIm9iamVjdFwiICYmIG9ialtrZXldICE9PSBudWxsKSB7XHJcbiAgICAgICAgc3RydWN0dXJlW2tleV0gPSB0aGlzLmdldFhNTFN0cnVjdHVyZShcclxuICAgICAgICAgIG9ialtrZXldLFxyXG4gICAgICAgICAgbWF4RGVwdGgsXHJcbiAgICAgICAgICBjdXJyZW50RGVwdGggKyAxXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHJ1Y3R1cmVba2V5XSA9IHR5cGVvZiBvYmpba2V5XTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBpc0Zvcm1hdHRpbmdBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkge1xyXG4gICAgY29uc3QgZm9ybWF0dGluZ0F0dHJpYnV0ZXMgPSBbXHJcbiAgICAgIFwiQF9Qb2ludFNpemVcIixcclxuICAgICAgXCJAX0xlYWRpbmdcIixcclxuICAgICAgXCJAX1RyYWNraW5nXCIsXHJcbiAgICAgIFwiQF9Gb250U3R5bGVcIixcclxuICAgICAgXCJAX0FwcGxpZWRGb250XCIsXHJcbiAgICAgIFwiQF9GaWxsQ29sb3JcIixcclxuICAgICAgXCJAX1N0cm9rZUNvbG9yXCIsXHJcbiAgICAgIFwiQF9KdXN0aWZpY2F0aW9uXCIsXHJcbiAgICAgIFwiQF9MZWZ0SW5kZW50XCIsXHJcbiAgICAgIFwiQF9SaWdodEluZGVudFwiLFxyXG4gICAgICBcIkBfRmlyc3RMaW5lSW5kZW50XCIsXHJcbiAgICAgIFwiQF9TcGFjZUJlZm9yZVwiLFxyXG4gICAgICBcIkBfU3BhY2VBZnRlclwiLFxyXG4gICAgICBcIkBfQWxpZ25tZW50XCIsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmdBdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHNhdmVEZWJ1Z0luZm8oZGVidWdJbmZvLCBmaWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlTmFtZSwgSlNPTi5zdHJpbmdpZnkoZGVidWdJbmZvLCBudWxsLCAyKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgRGVidWcgaW5mbyBzYXZlZCB0byAke2ZpbGVOYW1lfWApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBzYXZpbmcgZGVidWcgaW5mbzpcIiwgZXJyb3IpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIkRlYnVnIGluZm8gKGZpcnN0IDIwMDAgY2hhcnMpOlwiLFxyXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGRlYnVnSW5mbywgbnVsbCwgMikuc3Vic3RyaW5nKDAsIDIwMDApXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElETUxVdGlscztcclxuIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiZnMiLCJJRE1MVXRpbHMiLCJwYXJzZUdlb21ldHJpY0JvdW5kcyIsImJvdW5kc1N0cmluZyIsImNvbnNvbGUiLCJsb2ciLCJ0b3AiLCJsZWZ0IiwiYm90dG9tIiwicmlnaHQiLCJ3aWR0aCIsImhlaWdodCIsImJvdW5kcyIsInNwbGl0IiwibWFwIiwicGFyc2VGbG9hdCIsInJlc3VsdCIsInBhcnNlVHJhbnNmb3JtIiwidHJhbnNmb3JtU3RyaW5nIiwiYSIsImIiLCJjIiwiZCIsInR4IiwidHkiLCJ2YWx1ZXMiLCJjYWxjdWxhdGVSb3RhdGlvbiIsInRyYW5zZm9ybSIsIk1hdGgiLCJhdGFuMiIsIlBJIiwiY2FsY3VsYXRlQ29ybmVycyIsImNvcm5lcnMiLCJ0b3BMZWZ0IiwieCIsInkiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiY29ybmVyIiwicG9pbnQiLCJjbXlrVG9SZ2IiLCJtIiwiayIsInIiLCJyb3VuZCIsImciLCJwYXJzZUluRGVzaWduQ29sb3IiLCJjb2xvclJlZiIsImNteWtNYXRjaCIsIm1hdGNoIiwiTnVtYmVyIiwicmdiIiwicmdiTWF0Y2giLCJzdGFuZGFyZENvbG9ycyIsImRlY29kZVhNTEVudGl0aWVzIiwidGV4dCIsInJlcGxhY2UiLCJjbGVhblRleHRDb250ZW50IiwiY29udGVudCIsInRyaW0iLCJwcmVzZXJ2ZUxpbmVCcmVha3MiLCJjbGVhblRleHRGb3JSZW5kZXJpbmciLCJzb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyIsImhhc1Byb2JsZW1hdGljVGV4dCIsImluY2x1ZGVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInByb2Nlc3NlZCIsImNvdW50V29yZHMiLCJmaWx0ZXIiLCJ3b3JkIiwibGVuZ3RoIiwicGFyc2VOdW1lcmljIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJudW0iLCJpc05hTiIsImlzSW1hZ2VGaWxlIiwiZmlsZU5hbWUiLCJpbWFnZUV4dGVuc2lvbnMiLCJzb21lIiwiZXh0IiwidG9Mb3dlckNhc2UiLCJlbmRzV2l0aCIsImdldEltYWdlRXh0ZW5zaW9uIiwiaW1hZ2VUeXBlTmFtZSIsInR5cGVNYXAiLCJnZXRJbWFnZUV4dGVuc2lvbkZyb21Gb3JtYXQiLCJmb3JtYXQiLCJmb3JtYXRNYXAiLCJleHRyYWN0SW1hZ2VOYW1lRnJvbUxpbmsiLCJsaW5rVXJpIiwiY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldCIsImVsZW1lbnRzIiwibWluWCIsIkluZmluaXR5IiwibWluWSIsIm1heFN0cm9rZVdpZHRoIiwidmFsaWRFbGVtZW50cyIsImVsZW1lbnQiLCJpbmRleCIsImdlb21ldHJpY0JvdW5kcyIsIm9yaWdpbmFsQm91bmRzIiwiaXRlbVRyYW5zZm9ybSIsImZpbmFsWCIsImZpbmFsWSIsIm1pbiIsInN0cm9rZVdpZHRoIiwic3Ryb2tlV2VpZ2h0IiwibWF4Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJhYnMiLCJzdHJva2VQYWRkaW5nIiwiY2VpbCIsImNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXRQcmVjaXNlIiwid2FybiIsIm1heFN0cm9rZSIsImZpbmFsT2Zmc2V0IiwiY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgiLCJpdGVtIiwicGF0aEdlb21ldHJ5IiwiUHJvcGVydGllcyIsIlBhdGhHZW9tZXRyeSIsIkdlb21ldHJ5UGF0aFR5cGUiLCJQYXRoUG9pbnRBcnJheSIsIlBhdGhQb2ludFR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJtYXhYIiwibWF4WSIsImFuY2hvciIsImVycm9yIiwiY2FsY3VsYXRlUmVsYXRpdmVQb3NpdGlvbiIsImZyYW1lQm91bmRzIiwiY29udGVudEJvdW5kcyIsImZyYW1lVHJhbnNmb3JtIiwiY29udGVudFRyYW5zZm9ybSIsInNjYWxlWCIsInNjYWxlWSIsInRyYW5zZm9ybURpZmZlcmVuY2UiLCJmcmFtZSIsImNhbGN1bGF0ZUdhcCIsImNhbGN1bGF0ZUltYWdlUG9zaXRpb25JbkZyYW1lIiwicGxhY2VkQ29udGVudCIsImltYWdlVHJhbnNmb3JtIiwiaW1hZ2VYIiwiaW1hZ2VZIiwiaW1hZ2VXaWR0aCIsImltYWdlSGVpZ2h0IiwiZ2V0WE1MU3RydWN0dXJlIiwib2JqIiwibWF4RGVwdGgiLCJjdXJyZW50RGVwdGgiLCJzdHJ1Y3R1cmUiLCJrZXkiLCJpc0Zvcm1hdHRpbmdBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVOYW1lIiwiZm9ybWF0dGluZ0F0dHJpYnV0ZXMiLCJzYXZlRGVidWdJbmZvIiwiZGVidWdJbmZvIiwid3JpdGVGaWxlU3luYyIsInN1YnN0cmluZyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/utils/IDMLUtils.js\n"));

/***/ })

});