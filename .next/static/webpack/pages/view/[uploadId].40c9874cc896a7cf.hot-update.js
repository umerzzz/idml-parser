"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/IDMLProcessor.js":
/*!******************************!*\
  !*** ./lib/IDMLProcessor.js ***!
  \******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Core modules\n\nconst IDMLXMLParser = __webpack_require__(/*! ./parsers/XMLParser */ \"./lib/parsers/XMLParser.js\");\nconst FileExtractor = __webpack_require__(/*! ./extractors/FileExtractor */ \"./lib/extractors/FileExtractor.js\");\nconst StyleParser = __webpack_require__(/*! ./parsers/StyleParser */ \"./lib/parsers/StyleParser.js\");\nconst StoryParser = __webpack_require__(/*! ./parsers/StoryParser */ \"./lib/parsers/StoryParser.js\");\nconst ElementParser = __webpack_require__(/*! ./parsers/ElementParser */ \"./lib/parsers/ElementParser.js\");\nconst DocumentParser = __webpack_require__(/*! ./parsers/DocumentParser */ \"./lib/parsers/DocumentParser.js\");\nconst ImageProcessor = __webpack_require__(/*! ./processors/ImageProcessor */ \"./lib/processors/ImageProcessor.js\");\nconst DebugAnalyzer = __webpack_require__(/*! ./debug/DebugAnalyzer */ \"./lib/debug/DebugAnalyzer.js\");\nconst IDMLUtils = __webpack_require__(/*! ./utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nconst UnitConverter = __webpack_require__(/*! ./utils/UnitConverter */ \"./lib/utils/UnitConverter.js\"); // ADDED: Unit conversion support\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nclass IDMLProcessor {\n    async processIDML(filePath) {\n        console.log(\"Processing IDML file:\", filePath);\n        try {\n            var _this_document, _this_document1, _this_pageInfo_dimensions, _this_pageInfo_dimensions1, _this_documentInfo_preferences_viewPreferences, _this_documentInfo_preferences;\n            // Extract ZIP contents\n            const extractedData = await this.fileExtractor.extractIDMLContents(filePath);\n            console.log(\"Extracted \".concat(Object.keys(extractedData).length, \" files from IDML\"));\n            // Parse main structure\n            await this.parseDocumentStructure(extractedData);\n            // Extract detailed information\n            await this.extractDetailedInformation();\n            // Return the correct structure\n            const documentData = {\n                document: {\n                    version: ((_this_document = this.document) === null || _this_document === void 0 ? void 0 : _this_document[\"@_DOMVersion\"]) || \"Unknown\",\n                    pageCount: Math.max(1, this.elements.length > 0 ? 1 : 0),\n                    name: ((_this_document1 = this.document) === null || _this_document1 === void 0 ? void 0 : _this_document1[\"@_Name\"]) || \"Untitled\",\n                    dimensions: this.pageInfo.dimensions\n                },\n                // ADDED: Unit conversion information\n                unitConversion: {\n                    enabled: this.config.convertToPixels,\n                    dpi: this.config.dpi,\n                    originalUnits: ((_this_pageInfo_dimensions = this.pageInfo.dimensions) === null || _this_pageInfo_dimensions === void 0 ? void 0 : _this_pageInfo_dimensions.units) || \"Unknown\",\n                    convertedToPixels: !!((_this_pageInfo_dimensions1 = this.pageInfo.dimensions) === null || _this_pageInfo_dimensions1 === void 0 ? void 0 : _this_pageInfo_dimensions1.pixelDimensions),\n                    conversionAppliedTo: [\n                        \"document dimensions\",\n                        \"element geometric bounds\",\n                        \"element positions\",\n                        \"font sizes\",\n                        \"spacing measurements\",\n                        \"page margins\",\n                        \"transform coordinates\",\n                        \"stroke weights\",\n                        \"text frame insets\"\n                    ].filter(Boolean)\n                },\n                // === ADD GLOBAL STYLE INFO ===\n                paragraphStyles: this.styleParser.getParagraphStyles(),\n                characterStyles: this.styleParser.getCharacterStyles(),\n                fontDefinitions: this.styleParser.getFontDefinitions(),\n                // === END GLOBAL STYLE INFO ===\n                pageInfo: {\n                    dimensions: this.pageInfo.dimensions,\n                    margins: this.pageInfo.margins\n                },\n                elements: this.elements.map((element)=>{\n                    if (!element.pixelPosition) {\n                        console.warn(\"⚠️ Element \".concat(element.self, \" is missing pixelPosition! This may cause rendering issues.\"));\n                    }\n                    return {\n                        id: element.self,\n                        type: element.type,\n                        name: element.name,\n                        // ENFORCED: Only output pixelPosition (in pixels)\n                        pixelPosition: element.pixelPosition,\n                        fill: element.fillColor,\n                        stroke: element.strokeColor,\n                        strokeWeight: element.strokeWeight,\n                        parentStory: element.parentStory,\n                        linkedImage: element.linkedImage,\n                        visible: element.visible,\n                        locked: element.locked,\n                        // Content frame specific properties\n                        isContentFrame: element.isContentFrame || false,\n                        hasPlacedContent: element.hasPlacedContent || false,\n                        contentType: element.contentType || null,\n                        // Image positioning within frame\n                        imagePosition: element.imagePosition || null,\n                        placedContent: element.placedContent || null\n                    };\n                }),\n                stories: Object.keys(this.stories).reduce((acc, storyId)=>{\n                    var _story_content;\n                    const story = this.stories[storyId];\n                    if (story === null || story === void 0 ? void 0 : (_story_content = story.content) === null || _story_content === void 0 ? void 0 : _story_content.plainText) {\n                        var _story_content_lineBreakInfo, _story_content_lineBreakInfo1;\n                        acc[storyId] = {\n                            text: story.content.plainText,\n                            wordCount: story.content.wordCount,\n                            characterCount: story.content.characterCount,\n                            textColor: story.content.textColor,\n                            hasLineBreaks: ((_story_content_lineBreakInfo = story.content.lineBreakInfo) === null || _story_content_lineBreakInfo === void 0 ? void 0 : _story_content_lineBreakInfo.hasLineBreaks) || false,\n                            lineBreakCount: ((_story_content_lineBreakInfo1 = story.content.lineBreakInfo) === null || _story_content_lineBreakInfo1 === void 0 ? void 0 : _story_content_lineBreakInfo1.lineBreakCount) || 0,\n                            // Include resolved styling information\n                            styling: this.styleParser.getStoryStyleSummary(story),\n                            // Include formatted content with resolved formatting\n                            formattedContent: story.content.formattedContent || []\n                        };\n                    }\n                    return acc;\n                }, {}),\n                debug22: {\n                    measurementUnits: (_this_documentInfo_preferences = this.documentInfo.preferences) === null || _this_documentInfo_preferences === void 0 ? void 0 : (_this_documentInfo_preferences_viewPreferences = _this_documentInfo_preferences.viewPreferences) === null || _this_documentInfo_preferences_viewPreferences === void 0 ? void 0 : _this_documentInfo_preferences_viewPreferences.horizontalMeasurementUnits,\n                    coordinateOffset: this.calculateCoordinateOffset(),\n                    contentFramesCount: this.elements.filter((el)=>el.isContentFrame).length,\n                    imagesLinkedCount: this.elements.filter((el)=>el.linkedImage && !el.linkedImage.isEmbedded).length,\n                    embeddedImagesCount: this.elements.filter((el)=>el.linkedImage && el.linkedImage.isEmbedded).length\n                }\n            };\n            await this.addComprehensiveTextFormattingDebug();\n            console.log(\"✅ IDML processing completed. Elements:\", documentData.elements.length);\n            return documentData;\n        } catch (error) {\n            console.error(\"Error processing IDML:\", error);\n            throw error;\n        }\n    }\n    async parseDocumentStructure(extractedData) {\n        console.log(\"Parsing document structure...\");\n        // Parse Resources\n        console.log(\"\\n\\uD83D\\uDCCB === PARSING RESOURCES ===\");\n        for (const [fileName, content] of Object.entries(extractedData)){\n            if (fileName.startsWith(\"Resources/\")) {\n                console.log(\"\\uD83D\\uDD0D Processing resource:\", fileName);\n                await this.styleParser.parseResourceFile(fileName, content, this.xmlParser);\n            }\n        }\n        // Parse document structure (spreads, master spreads)\n        await this.documentParser.parseDocumentStructure(extractedData, this.xmlParser);\n        // Parse Stories\n        console.log(\"\\n\\uD83D\\uDCDD === PARSING STORIES ===\");\n        let storyCount = 0;\n        for (const [fileName, content] of Object.entries(extractedData)){\n            if (fileName.startsWith(\"Stories/\")) {\n                console.log(\"\\uD83D\\uDD0D Found story file:\", fileName);\n                console.log(\"   Content length:\", content.length);\n                console.log(\"   Content preview:\", content.substring(0, 200));\n                storyCount++;\n                await this.storyParser.parseStoryFile(fileName, content, this.xmlParser);\n            }\n        }\n        console.log(\"\\uD83D\\uDCDD Total stories processed: \".concat(storyCount));\n        // Sync data from modules to maintain backward compatibility\n        this.syncModuleData();\n    }\n    syncModuleData() {\n        // Sync document data\n        this.document = this.documentParser.getDocument();\n        this.spreads = this.documentParser.getSpreads();\n        this.masterSpreads = this.documentParser.getMasterSpreads();\n        this.documentInfo = this.documentParser.getDocumentInfo();\n        this.layers = this.documentParser.getLayers();\n        // Sync style data\n        this.styles = this.styleParser.getStyles();\n        this.resources = this.styleParser.getResources();\n        // Sync story data\n        this.stories = this.storyParser.getStories();\n        // Sync element data\n        this.elements = this.elementParser.getElements();\n    }\n    async extractDetailedInformation() {\n        var _this_pageInfo_dimensions, _this_pageInfo;\n        console.log(\"Extracting detailed information with enhanced processing...\");\n        await this.documentParser.extractDetailedInformation();\n        this.pageInfo = this.documentParser.getPageInfo();\n        // ADDED: Set document units on StoryParser after pageInfo is available\n        if ((_this_pageInfo = this.pageInfo) === null || _this_pageInfo === void 0 ? void 0 : (_this_pageInfo_dimensions = _this_pageInfo.dimensions) === null || _this_pageInfo_dimensions === void 0 ? void 0 : _this_pageInfo_dimensions.units) {\n            const documentUnits = this.pageInfo.dimensions.units;\n            console.log(\"\\uD83D\\uDCD0 IDMLProcessor: Setting document units to\", documentUnits, \"on StoryParser\");\n            if (this.storyParser.setDocumentUnits) {\n                this.storyParser.setDocumentUnits(documentUnits);\n            }\n        }\n        console.log(\"✅ Enhanced detailed information extracted\");\n    }\n    calculateCoordinateOffset() {\n        return this.documentParser.calculateCoordinateOffset();\n    }\n    async addComprehensiveTextFormattingDebug() {\n        return await this.debugAnalyzer.addComprehensiveTextFormattingDebug(this);\n    }\n    // Package processing methods\n    async processIDMLPackage(idmlFilePath, packageStructure) {\n        let extractedImages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        console.log(\"Processing IDML package:\", idmlFilePath);\n        try {\n            var _packageStructure_resourceMap, _packageStructure_resourceMap1;\n            // Process the IDML file first\n            const documentData = await this.processIDML(idmlFilePath);\n            // Process linked images and update elements\n            await this.imageProcessor.processLinkedResources(documentData, packageStructure, extractedImages);\n            // Add package info\n            documentData.packageInfo = {\n                hasLinks: ((_packageStructure_resourceMap = packageStructure.resourceMap) === null || _packageStructure_resourceMap === void 0 ? void 0 : _packageStructure_resourceMap.size) > 1,\n                hasFonts: false,\n                linksCount: Array.from(((_packageStructure_resourceMap1 = packageStructure.resourceMap) === null || _packageStructure_resourceMap1 === void 0 ? void 0 : _packageStructure_resourceMap1.keys()) || []).filter((name)=>IDMLUtils.isImageFile(name)).length,\n                fontsCount: 0,\n                extractedImagesCount: extractedImages.length\n            };\n            return documentData;\n        } catch (error) {\n            console.error(\"Error processing IDML package:\", error);\n            throw error;\n        }\n    }\n    // Image processing methods\n    async extractAndSaveEmbeddedImages(idmlPath, uploadDir) {\n        return await this.fileExtractor.extractAndSaveEmbeddedImages(idmlPath, uploadDir);\n    }\n    async extractEmbeddedImageFromSpread(idmlPath, uploadDir) {\n        return await this.imageProcessor.extractEmbeddedImageFromSpread(idmlPath, uploadDir, this.xmlParser);\n    }\n    // Debug methods\n    async debugIDMLContents(idmlPath) {\n        return await this.fileExtractor.debugIDMLContents(idmlPath);\n    }\n    async debugIDMLContentsDetailed(idmlPath) {\n        return await this.fileExtractor.debugIDMLContentsDetailed(idmlPath);\n    }\n    async analyzeSpreadForImageReferences(idmlPath) {\n        return await this.imageProcessor.analyzeSpreadForImageReferences(idmlPath, this.xmlParser);\n    }\n    // Utility methods for backward compatibility\n    getPageContent(pageId) {\n        return this.documentParser.getPageContent(pageId);\n    }\n    // Getter methods for accessing module data\n    getStyles() {\n        return this.styleParser.getStyles();\n    }\n    getResources() {\n        return this.styleParser.getResources();\n    }\n    getStories() {\n        return this.storyParser.getStories();\n    }\n    getElements() {\n        return this.elementParser.getElements();\n    }\n    getSpreads() {\n        return this.documentParser.getSpreads();\n    }\n    getMasterSpreads() {\n        return this.documentParser.getMasterSpreads();\n    }\n    getDocumentInfo() {\n        return this.documentParser.getDocumentInfo();\n    }\n    getPageInfo() {\n        return this.documentParser.getPageInfo();\n    }\n    getLayers() {\n        return this.documentParser.getLayers();\n    }\n    // Module access for advanced usage\n    getXMLParser() {\n        return this.xmlParser;\n    }\n    getFileExtractor() {\n        return this.fileExtractor;\n    }\n    getStyleParser() {\n        return this.styleParser;\n    }\n    getStoryParser() {\n        return this.storyParser;\n    }\n    getElementParser() {\n        return this.elementParser;\n    }\n    getDocumentParser() {\n        return this.documentParser;\n    }\n    getImageProcessor() {\n        return this.imageProcessor;\n    }\n    getDebugAnalyzer() {\n        return this.debugAnalyzer;\n    }\n    constructor(options = {}){\n        // Configuration options\n        this.config = {\n            dpi: options.dpi || 96,\n            convertToPixels: options.convertToPixels !== false,\n            preserveOriginalUnits: options.preserveOriginalUnits !== false,\n            ...options\n        };\n        // ADDED: Initialize unit converter with configured DPI first\n        this.unitConverter = new UnitConverter(this.config.dpi);\n        // Initialize all modules\n        this.xmlParser = new IDMLXMLParser();\n        this.fileExtractor = new FileExtractor();\n        this.styleParser = new StyleParser(this.unitConverter); // ADDED: Pass UnitConverter\n        this.elementParser = new ElementParser(this.unitConverter); // ADDED: Pass UnitConverter\n        this.storyParser = new StoryParser(this.styleParser, this.unitConverter); // ADDED: Pass UnitConverter\n        this.documentParser = new DocumentParser(this.elementParser, this.styleParser, this.unitConverter); // FIXED: Pass StyleParser and UnitConverter\n        this.imageProcessor = new ImageProcessor(this.fileExtractor);\n        this.debugAnalyzer = new DebugAnalyzer();\n        // Maintain backward compatibility properties\n        this.document = null;\n        this.resources = {};\n        this.spreads = {};\n        this.stories = {};\n        this.masterSpreads = {};\n        this.documentInfo = {};\n        this.pageInfo = {};\n        this.elements = [];\n        this.layers = [];\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n    }\n}\nmodule.exports = IDMLProcessor;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM3RCxRQUFRLEdBQUcsQ0FBQztRQUNqQixJQUFJLENBQUNILFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQzhGLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0UsTUFBTSxHQUFHO1lBQ1ppRCxXQUFXLENBQUM7WUFDWkMsV0FBVyxDQUFDO1lBQ1pDLFFBQVEsQ0FBQztZQUNUQyxPQUFPLENBQUM7WUFDUkMsTUFBTSxDQUFDO1FBQ1Q7SUFDRjtBQTJYRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUcxSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvSURNTFByb2Nlc3Nvci5qcz8wODkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcmUgbW9kdWxlc1xyXG5jb25zdCBJRE1MWE1MUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9YTUxQYXJzZXJcIik7XHJcbmNvbnN0IEZpbGVFeHRyYWN0b3IgPSByZXF1aXJlKFwiLi9leHRyYWN0b3JzL0ZpbGVFeHRyYWN0b3JcIik7XHJcbmNvbnN0IFN0eWxlUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9TdHlsZVBhcnNlclwiKTtcclxuY29uc3QgU3RvcnlQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL1N0b3J5UGFyc2VyXCIpO1xyXG5jb25zdCBFbGVtZW50UGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9FbGVtZW50UGFyc2VyXCIpO1xyXG5jb25zdCBEb2N1bWVudFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvRG9jdW1lbnRQYXJzZXJcIik7XHJcbmNvbnN0IEltYWdlUHJvY2Vzc29yID0gcmVxdWlyZShcIi4vcHJvY2Vzc29ycy9JbWFnZVByb2Nlc3NvclwiKTtcclxuY29uc3QgRGVidWdBbmFseXplciA9IHJlcXVpcmUoXCIuL2RlYnVnL0RlYnVnQW5hbHl6ZXJcIik7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL0lETUxVdGlsc1wiKTtcclxuY29uc3QgVW5pdENvbnZlcnRlciA9IHJlcXVpcmUoXCIuL3V0aWxzL1VuaXRDb252ZXJ0ZXJcIik7IC8vIEFEREVEOiBVbml0IGNvbnZlcnNpb24gc3VwcG9ydFxyXG5cclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5cclxuY2xhc3MgSURNTFByb2Nlc3NvciB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAvLyBDb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICBkcGk6IG9wdGlvbnMuZHBpIHx8IDk2LCAvLyBEZWZhdWx0IHdlYiBEUEksIDMwMC82MDAgZm9yIHByaW50XHJcbiAgICAgIGNvbnZlcnRUb1BpeGVsczogb3B0aW9ucy5jb252ZXJ0VG9QaXhlbHMgIT09IGZhbHNlLCAvLyBEZWZhdWx0IHRydWVcclxuICAgICAgcHJlc2VydmVPcmlnaW5hbFVuaXRzOiBvcHRpb25zLnByZXNlcnZlT3JpZ2luYWxVbml0cyAhPT0gZmFsc2UsIC8vIERlZmF1bHQgdHJ1ZVxyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBRERFRDogSW5pdGlhbGl6ZSB1bml0IGNvbnZlcnRlciB3aXRoIGNvbmZpZ3VyZWQgRFBJIGZpcnN0XHJcbiAgICB0aGlzLnVuaXRDb252ZXJ0ZXIgPSBuZXcgVW5pdENvbnZlcnRlcih0aGlzLmNvbmZpZy5kcGkpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgYWxsIG1vZHVsZXNcclxuICAgIHRoaXMueG1sUGFyc2VyID0gbmV3IElETUxYTUxQYXJzZXIoKTtcclxuICAgIHRoaXMuZmlsZUV4dHJhY3RvciA9IG5ldyBGaWxlRXh0cmFjdG9yKCk7XHJcbiAgICB0aGlzLnN0eWxlUGFyc2VyID0gbmV3IFN0eWxlUGFyc2VyKHRoaXMudW5pdENvbnZlcnRlcik7IC8vIEFEREVEOiBQYXNzIFVuaXRDb252ZXJ0ZXJcclxuICAgIHRoaXMuZWxlbWVudFBhcnNlciA9IG5ldyBFbGVtZW50UGFyc2VyKHRoaXMudW5pdENvbnZlcnRlcik7IC8vIEFEREVEOiBQYXNzIFVuaXRDb252ZXJ0ZXJcclxuICAgIHRoaXMuc3RvcnlQYXJzZXIgPSBuZXcgU3RvcnlQYXJzZXIodGhpcy5zdHlsZVBhcnNlciwgdGhpcy51bml0Q29udmVydGVyKTsgLy8gQURERUQ6IFBhc3MgVW5pdENvbnZlcnRlclxyXG4gICAgdGhpcy5kb2N1bWVudFBhcnNlciA9IG5ldyBEb2N1bWVudFBhcnNlcihcclxuICAgICAgdGhpcy5lbGVtZW50UGFyc2VyLFxyXG4gICAgICB0aGlzLnN0eWxlUGFyc2VyLFxyXG4gICAgICB0aGlzLnVuaXRDb252ZXJ0ZXJcclxuICAgICk7IC8vIEZJWEVEOiBQYXNzIFN0eWxlUGFyc2VyIGFuZCBVbml0Q29udmVydGVyXHJcbiAgICB0aGlzLmltYWdlUHJvY2Vzc29yID0gbmV3IEltYWdlUHJvY2Vzc29yKHRoaXMuZmlsZUV4dHJhY3Rvcik7XHJcbiAgICB0aGlzLmRlYnVnQW5hbHl6ZXIgPSBuZXcgRGVidWdBbmFseXplcigpO1xyXG5cclxuICAgIC8vIE1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcHJvcGVydGllc1xyXG4gICAgdGhpcy5kb2N1bWVudCA9IG51bGw7XHJcbiAgICB0aGlzLnJlc291cmNlcyA9IHt9O1xyXG4gICAgdGhpcy5zcHJlYWRzID0ge307XHJcbiAgICB0aGlzLnN0b3JpZXMgPSB7fTtcclxuICAgIHRoaXMubWFzdGVyU3ByZWFkcyA9IHt9O1xyXG4gICAgdGhpcy5kb2N1bWVudEluZm8gPSB7fTtcclxuICAgIHRoaXMucGFnZUluZm8gPSB7fTtcclxuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICAgIHRoaXMubGF5ZXJzID0gW107XHJcbiAgICB0aGlzLnN0eWxlcyA9IHtcclxuICAgICAgcGFyYWdyYXBoOiB7fSxcclxuICAgICAgY2hhcmFjdGVyOiB7fSxcclxuICAgICAgb2JqZWN0OiB7fSxcclxuICAgICAgdGFibGU6IHt9LFxyXG4gICAgICBjZWxsOiB7fSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcm9jZXNzSURNTChmaWxlUGF0aCkge1xyXG4gICAgY29uc29sZS5sb2coXCJQcm9jZXNzaW5nIElETUwgZmlsZTpcIiwgZmlsZVBhdGgpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEV4dHJhY3QgWklQIGNvbnRlbnRzXHJcbiAgICAgIGNvbnN0IGV4dHJhY3RlZERhdGEgPSBhd2FpdCB0aGlzLmZpbGVFeHRyYWN0b3IuZXh0cmFjdElETUxDb250ZW50cyhcclxuICAgICAgICBmaWxlUGF0aFxyXG4gICAgICApO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgRXh0cmFjdGVkICR7T2JqZWN0LmtleXMoZXh0cmFjdGVkRGF0YSkubGVuZ3RofSBmaWxlcyBmcm9tIElETUxgXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBQYXJzZSBtYWluIHN0cnVjdHVyZVxyXG4gICAgICBhd2FpdCB0aGlzLnBhcnNlRG9jdW1lbnRTdHJ1Y3R1cmUoZXh0cmFjdGVkRGF0YSk7XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IGRldGFpbGVkIGluZm9ybWF0aW9uXHJcbiAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdERldGFpbGVkSW5mb3JtYXRpb24oKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB0aGUgY29ycmVjdCBzdHJ1Y3R1cmVcclxuICAgICAgY29uc3QgZG9jdW1lbnREYXRhID0ge1xyXG4gICAgICAgIGRvY3VtZW50OiB7XHJcbiAgICAgICAgICB2ZXJzaW9uOiB0aGlzLmRvY3VtZW50Py5bXCJAX0RPTVZlcnNpb25cIl0gfHwgXCJVbmtub3duXCIsXHJcbiAgICAgICAgICBwYWdlQ291bnQ6IE1hdGgubWF4KDEsIHRoaXMuZWxlbWVudHMubGVuZ3RoID4gMCA/IDEgOiAwKSxcclxuICAgICAgICAgIG5hbWU6IHRoaXMuZG9jdW1lbnQ/LltcIkBfTmFtZVwiXSB8fCBcIlVudGl0bGVkXCIsXHJcbiAgICAgICAgICBkaW1lbnNpb25zOiB0aGlzLnBhZ2VJbmZvLmRpbWVuc2lvbnMsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gQURERUQ6IFVuaXQgY29udmVyc2lvbiBpbmZvcm1hdGlvblxyXG4gICAgICAgIHVuaXRDb252ZXJzaW9uOiB7XHJcbiAgICAgICAgICBlbmFibGVkOiB0aGlzLmNvbmZpZy5jb252ZXJ0VG9QaXhlbHMsXHJcbiAgICAgICAgICBkcGk6IHRoaXMuY29uZmlnLmRwaSxcclxuICAgICAgICAgIG9yaWdpbmFsVW5pdHM6IHRoaXMucGFnZUluZm8uZGltZW5zaW9ucz8udW5pdHMgfHwgXCJVbmtub3duXCIsXHJcbiAgICAgICAgICBjb252ZXJ0ZWRUb1BpeGVsczogISF0aGlzLnBhZ2VJbmZvLmRpbWVuc2lvbnM/LnBpeGVsRGltZW5zaW9ucyxcclxuICAgICAgICAgIGNvbnZlcnNpb25BcHBsaWVkVG86IFtcclxuICAgICAgICAgICAgXCJkb2N1bWVudCBkaW1lbnNpb25zXCIsXHJcbiAgICAgICAgICAgIFwiZWxlbWVudCBnZW9tZXRyaWMgYm91bmRzXCIsXHJcbiAgICAgICAgICAgIFwiZWxlbWVudCBwb3NpdGlvbnNcIixcclxuICAgICAgICAgICAgXCJmb250IHNpemVzXCIsXHJcbiAgICAgICAgICAgIFwic3BhY2luZyBtZWFzdXJlbWVudHNcIixcclxuICAgICAgICAgICAgXCJwYWdlIG1hcmdpbnNcIixcclxuICAgICAgICAgICAgXCJ0cmFuc2Zvcm0gY29vcmRpbmF0ZXNcIixcclxuICAgICAgICAgICAgXCJzdHJva2Ugd2VpZ2h0c1wiLFxyXG4gICAgICAgICAgICBcInRleHQgZnJhbWUgaW5zZXRzXCIsXHJcbiAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKSxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyA9PT0gQUREIEdMT0JBTCBTVFlMRSBJTkZPID09PVxyXG4gICAgICAgIHBhcmFncmFwaFN0eWxlczogdGhpcy5zdHlsZVBhcnNlci5nZXRQYXJhZ3JhcGhTdHlsZXMoKSxcclxuICAgICAgICBjaGFyYWN0ZXJTdHlsZXM6IHRoaXMuc3R5bGVQYXJzZXIuZ2V0Q2hhcmFjdGVyU3R5bGVzKCksXHJcbiAgICAgICAgZm9udERlZmluaXRpb25zOiB0aGlzLnN0eWxlUGFyc2VyLmdldEZvbnREZWZpbml0aW9ucygpLFxyXG4gICAgICAgIC8vID09PSBFTkQgR0xPQkFMIFNUWUxFIElORk8gPT09XHJcblxyXG4gICAgICAgIHBhZ2VJbmZvOiB7XHJcbiAgICAgICAgICBkaW1lbnNpb25zOiB0aGlzLnBhZ2VJbmZvLmRpbWVuc2lvbnMsXHJcbiAgICAgICAgICBtYXJnaW5zOiB0aGlzLnBhZ2VJbmZvLm1hcmdpbnMsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMubWFwKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICBpZiAoIWVsZW1lbnQucGl4ZWxQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgICAgYOKaoO+4jyBFbGVtZW50ICR7ZWxlbWVudC5zZWxmfSBpcyBtaXNzaW5nIHBpeGVsUG9zaXRpb24hIFRoaXMgbWF5IGNhdXNlIHJlbmRlcmluZyBpc3N1ZXMuYFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IGVsZW1lbnQuc2VsZixcclxuICAgICAgICAgICAgdHlwZTogZWxlbWVudC50eXBlLFxyXG4gICAgICAgICAgICBuYW1lOiBlbGVtZW50Lm5hbWUsXHJcbiAgICAgICAgICAgIC8vIEVORk9SQ0VEOiBPbmx5IG91dHB1dCBwaXhlbFBvc2l0aW9uIChpbiBwaXhlbHMpXHJcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb246IGVsZW1lbnQucGl4ZWxQb3NpdGlvbixcclxuICAgICAgICAgICAgZmlsbDogZWxlbWVudC5maWxsQ29sb3IsXHJcbiAgICAgICAgICAgIHN0cm9rZTogZWxlbWVudC5zdHJva2VDb2xvcixcclxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBlbGVtZW50LnN0cm9rZVdlaWdodCxcclxuICAgICAgICAgICAgcGFyZW50U3Rvcnk6IGVsZW1lbnQucGFyZW50U3RvcnksXHJcbiAgICAgICAgICAgIGxpbmtlZEltYWdlOiBlbGVtZW50LmxpbmtlZEltYWdlLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBlbGVtZW50LnZpc2libGUsXHJcbiAgICAgICAgICAgIGxvY2tlZDogZWxlbWVudC5sb2NrZWQsXHJcblxyXG4gICAgICAgICAgICAvLyBDb250ZW50IGZyYW1lIHNwZWNpZmljIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgaXNDb250ZW50RnJhbWU6IGVsZW1lbnQuaXNDb250ZW50RnJhbWUgfHwgZmFsc2UsXHJcbiAgICAgICAgICAgIGhhc1BsYWNlZENvbnRlbnQ6IGVsZW1lbnQuaGFzUGxhY2VkQ29udGVudCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IGVsZW1lbnQuY29udGVudFR5cGUgfHwgbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8vIEltYWdlIHBvc2l0aW9uaW5nIHdpdGhpbiBmcmFtZVxyXG4gICAgICAgICAgICBpbWFnZVBvc2l0aW9uOiBlbGVtZW50LmltYWdlUG9zaXRpb24gfHwgbnVsbCxcclxuICAgICAgICAgICAgcGxhY2VkQ29udGVudDogZWxlbWVudC5wbGFjZWRDb250ZW50IHx8IG51bGwsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgICBzdG9yaWVzOiBPYmplY3Qua2V5cyh0aGlzLnN0b3JpZXMpLnJlZHVjZSgoYWNjLCBzdG9yeUlkKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzdG9yeSA9IHRoaXMuc3Rvcmllc1tzdG9yeUlkXTtcclxuICAgICAgICAgIGlmIChzdG9yeT8uY29udGVudD8ucGxhaW5UZXh0KSB7XHJcbiAgICAgICAgICAgIGFjY1tzdG9yeUlkXSA9IHtcclxuICAgICAgICAgICAgICB0ZXh0OiBzdG9yeS5jb250ZW50LnBsYWluVGV4dCxcclxuICAgICAgICAgICAgICB3b3JkQ291bnQ6IHN0b3J5LmNvbnRlbnQud29yZENvdW50LFxyXG4gICAgICAgICAgICAgIGNoYXJhY3RlckNvdW50OiBzdG9yeS5jb250ZW50LmNoYXJhY3RlckNvdW50LFxyXG4gICAgICAgICAgICAgIHRleHRDb2xvcjogc3RvcnkuY29udGVudC50ZXh0Q29sb3IsXHJcbiAgICAgICAgICAgICAgaGFzTGluZUJyZWFrczpcclxuICAgICAgICAgICAgICAgIHN0b3J5LmNvbnRlbnQubGluZUJyZWFrSW5mbz8uaGFzTGluZUJyZWFrcyB8fCBmYWxzZSxcclxuICAgICAgICAgICAgICBsaW5lQnJlYWtDb3VudDogc3RvcnkuY29udGVudC5saW5lQnJlYWtJbmZvPy5saW5lQnJlYWtDb3VudCB8fCAwLFxyXG5cclxuICAgICAgICAgICAgICAvLyBJbmNsdWRlIHJlc29sdmVkIHN0eWxpbmcgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICBzdHlsaW5nOiB0aGlzLnN0eWxlUGFyc2VyLmdldFN0b3J5U3R5bGVTdW1tYXJ5KHN0b3J5KSxcclxuXHJcbiAgICAgICAgICAgICAgLy8gSW5jbHVkZSBmb3JtYXR0ZWQgY29udGVudCB3aXRoIHJlc29sdmVkIGZvcm1hdHRpbmdcclxuICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50OiBzdG9yeS5jb250ZW50LmZvcm1hdHRlZENvbnRlbnQgfHwgW10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgIH0sIHt9KSxcclxuXHJcbiAgICAgICAgZGVidWcyMjoge1xyXG4gICAgICAgICAgbWVhc3VyZW1lbnRVbml0czpcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudEluZm8ucHJlZmVyZW5jZXM/LnZpZXdQcmVmZXJlbmNlc1xyXG4gICAgICAgICAgICAgID8uaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHMsXHJcbiAgICAgICAgICBjb29yZGluYXRlT2Zmc2V0OiB0aGlzLmNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXQoKSxcclxuICAgICAgICAgIGNvbnRlbnRGcmFtZXNDb3VudDogdGhpcy5lbGVtZW50cy5maWx0ZXIoKGVsKSA9PiBlbC5pc0NvbnRlbnRGcmFtZSlcclxuICAgICAgICAgICAgLmxlbmd0aCxcclxuICAgICAgICAgIGltYWdlc0xpbmtlZENvdW50OiB0aGlzLmVsZW1lbnRzLmZpbHRlcihcclxuICAgICAgICAgICAgKGVsKSA9PiBlbC5saW5rZWRJbWFnZSAmJiAhZWwubGlua2VkSW1hZ2UuaXNFbWJlZGRlZFxyXG4gICAgICAgICAgKS5sZW5ndGgsXHJcbiAgICAgICAgICBlbWJlZGRlZEltYWdlc0NvdW50OiB0aGlzLmVsZW1lbnRzLmZpbHRlcihcclxuICAgICAgICAgICAgKGVsKSA9PiBlbC5saW5rZWRJbWFnZSAmJiBlbC5saW5rZWRJbWFnZS5pc0VtYmVkZGVkXHJcbiAgICAgICAgICApLmxlbmd0aCxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgYXdhaXQgdGhpcy5hZGRDb21wcmVoZW5zaXZlVGV4dEZvcm1hdHRpbmdEZWJ1ZygpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCLinIUgSURNTCBwcm9jZXNzaW5nIGNvbXBsZXRlZC4gRWxlbWVudHM6XCIsXHJcbiAgICAgICAgZG9jdW1lbnREYXRhLmVsZW1lbnRzLmxlbmd0aFxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIGRvY3VtZW50RGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIElETUw6XCIsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBwYXJzZURvY3VtZW50U3RydWN0dXJlKGV4dHJhY3RlZERhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiUGFyc2luZyBkb2N1bWVudCBzdHJ1Y3R1cmUuLi5cIik7XHJcblxyXG4gICAgLy8gUGFyc2UgUmVzb3VyY2VzXHJcbiAgICBjb25zb2xlLmxvZyhcIlxcbvCfk4sgPT09IFBBUlNJTkcgUkVTT1VSQ0VTID09PVwiKTtcclxuICAgIGZvciAoY29uc3QgW2ZpbGVOYW1lLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhleHRyYWN0ZWREYXRhKSkge1xyXG4gICAgICBpZiAoZmlsZU5hbWUuc3RhcnRzV2l0aChcIlJlc291cmNlcy9cIikpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gUHJvY2Vzc2luZyByZXNvdXJjZTpcIiwgZmlsZU5hbWUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc3R5bGVQYXJzZXIucGFyc2VSZXNvdXJjZUZpbGUoXHJcbiAgICAgICAgICBmaWxlTmFtZSxcclxuICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICB0aGlzLnhtbFBhcnNlclxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSBkb2N1bWVudCBzdHJ1Y3R1cmUgKHNwcmVhZHMsIG1hc3RlciBzcHJlYWRzKVxyXG4gICAgYXdhaXQgdGhpcy5kb2N1bWVudFBhcnNlci5wYXJzZURvY3VtZW50U3RydWN0dXJlKFxyXG4gICAgICBleHRyYWN0ZWREYXRhLFxyXG4gICAgICB0aGlzLnhtbFBhcnNlclxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBQYXJzZSBTdG9yaWVzXHJcbiAgICBjb25zb2xlLmxvZyhcIlxcbvCfk50gPT09IFBBUlNJTkcgU1RPUklFUyA9PT1cIik7XHJcbiAgICBsZXQgc3RvcnlDb3VudCA9IDA7XHJcbiAgICBmb3IgKGNvbnN0IFtmaWxlTmFtZSwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoZXh0cmFjdGVkRGF0YSkpIHtcclxuICAgICAgaWYgKGZpbGVOYW1lLnN0YXJ0c1dpdGgoXCJTdG9yaWVzL1wiKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBGb3VuZCBzdG9yeSBmaWxlOlwiLCBmaWxlTmFtZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCIgICBDb250ZW50IGxlbmd0aDpcIiwgY29udGVudC5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiICAgQ29udGVudCBwcmV2aWV3OlwiLCBjb250ZW50LnN1YnN0cmluZygwLCAyMDApKTtcclxuICAgICAgICBzdG9yeUNvdW50Kys7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zdG9yeVBhcnNlci5wYXJzZVN0b3J5RmlsZShcclxuICAgICAgICAgIGZpbGVOYW1lLFxyXG4gICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgIHRoaXMueG1sUGFyc2VyXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coYPCfk50gVG90YWwgc3RvcmllcyBwcm9jZXNzZWQ6ICR7c3RvcnlDb3VudH1gKTtcclxuXHJcbiAgICAvLyBTeW5jIGRhdGEgZnJvbSBtb2R1bGVzIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuICAgIHRoaXMuc3luY01vZHVsZURhdGEoKTtcclxuICB9XHJcblxyXG4gIHN5bmNNb2R1bGVEYXRhKCkge1xyXG4gICAgLy8gU3luYyBkb2N1bWVudCBkYXRhXHJcbiAgICB0aGlzLmRvY3VtZW50ID0gdGhpcy5kb2N1bWVudFBhcnNlci5nZXREb2N1bWVudCgpO1xyXG4gICAgdGhpcy5zcHJlYWRzID0gdGhpcy5kb2N1bWVudFBhcnNlci5nZXRTcHJlYWRzKCk7XHJcbiAgICB0aGlzLm1hc3RlclNwcmVhZHMgPSB0aGlzLmRvY3VtZW50UGFyc2VyLmdldE1hc3RlclNwcmVhZHMoKTtcclxuICAgIHRoaXMuZG9jdW1lbnRJbmZvID0gdGhpcy5kb2N1bWVudFBhcnNlci5nZXREb2N1bWVudEluZm8oKTtcclxuICAgIHRoaXMubGF5ZXJzID0gdGhpcy5kb2N1bWVudFBhcnNlci5nZXRMYXllcnMoKTtcclxuXHJcbiAgICAvLyBTeW5jIHN0eWxlIGRhdGFcclxuICAgIHRoaXMuc3R5bGVzID0gdGhpcy5zdHlsZVBhcnNlci5nZXRTdHlsZXMoKTtcclxuICAgIHRoaXMucmVzb3VyY2VzID0gdGhpcy5zdHlsZVBhcnNlci5nZXRSZXNvdXJjZXMoKTtcclxuXHJcbiAgICAvLyBTeW5jIHN0b3J5IGRhdGFcclxuICAgIHRoaXMuc3RvcmllcyA9IHRoaXMuc3RvcnlQYXJzZXIuZ2V0U3RvcmllcygpO1xyXG5cclxuICAgIC8vIFN5bmMgZWxlbWVudCBkYXRhXHJcbiAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50UGFyc2VyLmdldEVsZW1lbnRzKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHRyYWN0RGV0YWlsZWRJbmZvcm1hdGlvbigpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiB3aXRoIGVuaGFuY2VkIHByb2Nlc3NpbmcuLi5cIik7XHJcblxyXG4gICAgYXdhaXQgdGhpcy5kb2N1bWVudFBhcnNlci5leHRyYWN0RGV0YWlsZWRJbmZvcm1hdGlvbigpO1xyXG4gICAgdGhpcy5wYWdlSW5mbyA9IHRoaXMuZG9jdW1lbnRQYXJzZXIuZ2V0UGFnZUluZm8oKTtcclxuXHJcbiAgICAvLyBBRERFRDogU2V0IGRvY3VtZW50IHVuaXRzIG9uIFN0b3J5UGFyc2VyIGFmdGVyIHBhZ2VJbmZvIGlzIGF2YWlsYWJsZVxyXG4gICAgaWYgKHRoaXMucGFnZUluZm8/LmRpbWVuc2lvbnM/LnVuaXRzKSB7XHJcbiAgICAgIGNvbnN0IGRvY3VtZW50VW5pdHMgPSB0aGlzLnBhZ2VJbmZvLmRpbWVuc2lvbnMudW5pdHM7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwi8J+TkCBJRE1MUHJvY2Vzc29yOiBTZXR0aW5nIGRvY3VtZW50IHVuaXRzIHRvXCIsXHJcbiAgICAgICAgZG9jdW1lbnRVbml0cyxcclxuICAgICAgICBcIm9uIFN0b3J5UGFyc2VyXCJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnN0b3J5UGFyc2VyLnNldERvY3VtZW50VW5pdHMpIHtcclxuICAgICAgICB0aGlzLnN0b3J5UGFyc2VyLnNldERvY3VtZW50VW5pdHMoZG9jdW1lbnRVbml0cyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIuKchSBFbmhhbmNlZCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBleHRyYWN0ZWRcIik7XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRQYXJzZXIuY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldCgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYWRkQ29tcHJlaGVuc2l2ZVRleHRGb3JtYXR0aW5nRGVidWcoKSB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWJ1Z0FuYWx5emVyLmFkZENvbXByZWhlbnNpdmVUZXh0Rm9ybWF0dGluZ0RlYnVnKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLy8gUGFja2FnZSBwcm9jZXNzaW5nIG1ldGhvZHNcclxuICBhc3luYyBwcm9jZXNzSURNTFBhY2thZ2UoXHJcbiAgICBpZG1sRmlsZVBhdGgsXHJcbiAgICBwYWNrYWdlU3RydWN0dXJlLFxyXG4gICAgZXh0cmFjdGVkSW1hZ2VzID0gW11cclxuICApIHtcclxuICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2luZyBJRE1MIHBhY2thZ2U6XCIsIGlkbWxGaWxlUGF0aCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gUHJvY2VzcyB0aGUgSURNTCBmaWxlIGZpcnN0XHJcbiAgICAgIGNvbnN0IGRvY3VtZW50RGF0YSA9IGF3YWl0IHRoaXMucHJvY2Vzc0lETUwoaWRtbEZpbGVQYXRoKTtcclxuXHJcbiAgICAgIC8vIFByb2Nlc3MgbGlua2VkIGltYWdlcyBhbmQgdXBkYXRlIGVsZW1lbnRzXHJcbiAgICAgIGF3YWl0IHRoaXMuaW1hZ2VQcm9jZXNzb3IucHJvY2Vzc0xpbmtlZFJlc291cmNlcyhcclxuICAgICAgICBkb2N1bWVudERhdGEsXHJcbiAgICAgICAgcGFja2FnZVN0cnVjdHVyZSxcclxuICAgICAgICBleHRyYWN0ZWRJbWFnZXNcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEFkZCBwYWNrYWdlIGluZm9cclxuICAgICAgZG9jdW1lbnREYXRhLnBhY2thZ2VJbmZvID0ge1xyXG4gICAgICAgIGhhc0xpbmtzOiBwYWNrYWdlU3RydWN0dXJlLnJlc291cmNlTWFwPy5zaXplID4gMSxcclxuICAgICAgICBoYXNGb250czogZmFsc2UsXHJcbiAgICAgICAgbGlua3NDb3VudDogQXJyYXkuZnJvbShcclxuICAgICAgICAgIHBhY2thZ2VTdHJ1Y3R1cmUucmVzb3VyY2VNYXA/LmtleXMoKSB8fCBbXVxyXG4gICAgICAgICkuZmlsdGVyKChuYW1lKSA9PiBJRE1MVXRpbHMuaXNJbWFnZUZpbGUobmFtZSkpLmxlbmd0aCxcclxuICAgICAgICBmb250c0NvdW50OiAwLFxyXG4gICAgICAgIGV4dHJhY3RlZEltYWdlc0NvdW50OiBleHRyYWN0ZWRJbWFnZXMubGVuZ3RoLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIGRvY3VtZW50RGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIElETUwgcGFja2FnZTpcIiwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEltYWdlIHByb2Nlc3NpbmcgbWV0aG9kc1xyXG4gIGFzeW5jIGV4dHJhY3RBbmRTYXZlRW1iZWRkZWRJbWFnZXMoaWRtbFBhdGgsIHVwbG9hZERpcikge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmlsZUV4dHJhY3Rvci5leHRyYWN0QW5kU2F2ZUVtYmVkZGVkSW1hZ2VzKFxyXG4gICAgICBpZG1sUGF0aCxcclxuICAgICAgdXBsb2FkRGlyXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdEVtYmVkZGVkSW1hZ2VGcm9tU3ByZWFkKGlkbWxQYXRoLCB1cGxvYWREaXIpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmltYWdlUHJvY2Vzc29yLmV4dHJhY3RFbWJlZGRlZEltYWdlRnJvbVNwcmVhZChcclxuICAgICAgaWRtbFBhdGgsXHJcbiAgICAgIHVwbG9hZERpcixcclxuICAgICAgdGhpcy54bWxQYXJzZXJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBEZWJ1ZyBtZXRob2RzXHJcbiAgYXN5bmMgZGVidWdJRE1MQ29udGVudHMoaWRtbFBhdGgpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmZpbGVFeHRyYWN0b3IuZGVidWdJRE1MQ29udGVudHMoaWRtbFBhdGgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVidWdJRE1MQ29udGVudHNEZXRhaWxlZChpZG1sUGF0aCkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmlsZUV4dHJhY3Rvci5kZWJ1Z0lETUxDb250ZW50c0RldGFpbGVkKGlkbWxQYXRoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGFuYWx5emVTcHJlYWRGb3JJbWFnZVJlZmVyZW5jZXMoaWRtbFBhdGgpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmltYWdlUHJvY2Vzc29yLmFuYWx5emVTcHJlYWRGb3JJbWFnZVJlZmVyZW5jZXMoXHJcbiAgICAgIGlkbWxQYXRoLFxyXG4gICAgICB0aGlzLnhtbFBhcnNlclxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG4gIGdldFBhZ2VDb250ZW50KHBhZ2VJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRQYXJzZXIuZ2V0UGFnZUNvbnRlbnQocGFnZUlkKTtcclxuICB9XHJcblxyXG4gIC8vIEdldHRlciBtZXRob2RzIGZvciBhY2Nlc3NpbmcgbW9kdWxlIGRhdGFcclxuICBnZXRTdHlsZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZVBhcnNlci5nZXRTdHlsZXMoKTtcclxuICB9XHJcblxyXG4gIGdldFJlc291cmNlcygpIHtcclxuICAgIHJldHVybiB0aGlzLnN0eWxlUGFyc2VyLmdldFJlc291cmNlcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3RvcmllcygpIHtcclxuICAgIHJldHVybiB0aGlzLnN0b3J5UGFyc2VyLmdldFN0b3JpZXMoKTtcclxuICB9XHJcblxyXG4gIGdldEVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFBhcnNlci5nZXRFbGVtZW50cygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3ByZWFkcygpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50UGFyc2VyLmdldFNwcmVhZHMoKTtcclxuICB9XHJcblxyXG4gIGdldE1hc3RlclNwcmVhZHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudFBhcnNlci5nZXRNYXN0ZXJTcHJlYWRzKCk7XHJcbiAgfVxyXG5cclxuICBnZXREb2N1bWVudEluZm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudFBhcnNlci5nZXREb2N1bWVudEluZm8oKTtcclxuICB9XHJcblxyXG4gIGdldFBhZ2VJbmZvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRQYXJzZXIuZ2V0UGFnZUluZm8oKTtcclxuICB9XHJcblxyXG4gIGdldExheWVycygpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50UGFyc2VyLmdldExheWVycygpO1xyXG4gIH1cclxuXHJcbiAgLy8gTW9kdWxlIGFjY2VzcyBmb3IgYWR2YW5jZWQgdXNhZ2VcclxuICBnZXRYTUxQYXJzZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy54bWxQYXJzZXI7XHJcbiAgfVxyXG5cclxuICBnZXRGaWxlRXh0cmFjdG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZmlsZUV4dHJhY3RvcjtcclxuICB9XHJcblxyXG4gIGdldFN0eWxlUGFyc2VyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVQYXJzZXI7XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yeVBhcnNlcigpIHtcclxuICAgIHJldHVybiB0aGlzLnN0b3J5UGFyc2VyO1xyXG4gIH1cclxuXHJcbiAgZ2V0RWxlbWVudFBhcnNlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmVsZW1lbnRQYXJzZXI7XHJcbiAgfVxyXG5cclxuICBnZXREb2N1bWVudFBhcnNlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50UGFyc2VyO1xyXG4gIH1cclxuXHJcbiAgZ2V0SW1hZ2VQcm9jZXNzb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbWFnZVByb2Nlc3NvcjtcclxuICB9XHJcblxyXG4gIGdldERlYnVnQW5hbHl6ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kZWJ1Z0FuYWx5emVyO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJRE1MUHJvY2Vzc29yO1xyXG4iXSwibmFtZXMiOlsiSURNTFhNTFBhcnNlciIsInJlcXVpcmUiLCJGaWxlRXh0cmFjdG9yIiwiU3R5bGVQYXJzZXIiLCJTdG9yeVBhcnNlciIsIkVsZW1lbnRQYXJzZXIiLCJEb2N1bWVudFBhcnNlciIsIkltYWdlUHJvY2Vzc29yIiwiRGVidWdBbmFseXplciIsIklETUxVdGlscyIsIlVuaXRDb252ZXJ0ZXIiLCJwYXRoIiwiSURNTFByb2Nlc3NvciIsInByb2Nlc3NJRE1MIiwiZmlsZVBhdGgiLCJjb25zb2xlIiwibG9nIiwiZXh0cmFjdGVkRGF0YSIsImZpbGVFeHRyYWN0b3IiLCJleHRyYWN0SURNTENvbnRlbnRzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInBhcnNlRG9jdW1lbnRTdHJ1Y3R1cmUiLCJleHRyYWN0RGV0YWlsZWRJbmZvcm1hdGlvbiIsImRvY3VtZW50RGF0YSIsImRvY3VtZW50IiwidmVyc2lvbiIsInBhZ2VDb3VudCIsIk1hdGgiLCJtYXgiLCJlbGVtZW50cyIsIm5hbWUiLCJkaW1lbnNpb25zIiwicGFnZUluZm8iLCJ1bml0Q29udmVyc2lvbiIsImVuYWJsZWQiLCJjb25maWciLCJjb252ZXJ0VG9QaXhlbHMiLCJkcGkiLCJvcmlnaW5hbFVuaXRzIiwidW5pdHMiLCJjb252ZXJ0ZWRUb1BpeGVscyIsInBpeGVsRGltZW5zaW9ucyIsImNvbnZlcnNpb25BcHBsaWVkVG8iLCJmaWx0ZXIiLCJCb29sZWFuIiwicGFyYWdyYXBoU3R5bGVzIiwic3R5bGVQYXJzZXIiLCJnZXRQYXJhZ3JhcGhTdHlsZXMiLCJjaGFyYWN0ZXJTdHlsZXMiLCJnZXRDaGFyYWN0ZXJTdHlsZXMiLCJmb250RGVmaW5pdGlvbnMiLCJnZXRGb250RGVmaW5pdGlvbnMiLCJtYXJnaW5zIiwibWFwIiwiZWxlbWVudCIsInBpeGVsUG9zaXRpb24iLCJ3YXJuIiwic2VsZiIsImlkIiwidHlwZSIsImZpbGwiLCJmaWxsQ29sb3IiLCJzdHJva2UiLCJzdHJva2VDb2xvciIsInN0cm9rZVdlaWdodCIsInBhcmVudFN0b3J5IiwibGlua2VkSW1hZ2UiLCJ2aXNpYmxlIiwibG9ja2VkIiwiaXNDb250ZW50RnJhbWUiLCJoYXNQbGFjZWRDb250ZW50IiwiY29udGVudFR5cGUiLCJpbWFnZVBvc2l0aW9uIiwicGxhY2VkQ29udGVudCIsInN0b3JpZXMiLCJyZWR1Y2UiLCJhY2MiLCJzdG9yeUlkIiwic3RvcnkiLCJjb250ZW50IiwicGxhaW5UZXh0IiwidGV4dCIsIndvcmRDb3VudCIsImNoYXJhY3RlckNvdW50IiwidGV4dENvbG9yIiwiaGFzTGluZUJyZWFrcyIsImxpbmVCcmVha0luZm8iLCJsaW5lQnJlYWtDb3VudCIsInN0eWxpbmciLCJnZXRTdG9yeVN0eWxlU3VtbWFyeSIsImZvcm1hdHRlZENvbnRlbnQiLCJkZWJ1ZzIyIiwibWVhc3VyZW1lbnRVbml0cyIsImRvY3VtZW50SW5mbyIsInByZWZlcmVuY2VzIiwidmlld1ByZWZlcmVuY2VzIiwiaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHMiLCJjb29yZGluYXRlT2Zmc2V0IiwiY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldCIsImNvbnRlbnRGcmFtZXNDb3VudCIsImVsIiwiaW1hZ2VzTGlua2VkQ291bnQiLCJpc0VtYmVkZGVkIiwiZW1iZWRkZWRJbWFnZXNDb3VudCIsImFkZENvbXByZWhlbnNpdmVUZXh0Rm9ybWF0dGluZ0RlYnVnIiwiZXJyb3IiLCJmaWxlTmFtZSIsImVudHJpZXMiLCJzdGFydHNXaXRoIiwicGFyc2VSZXNvdXJjZUZpbGUiLCJ4bWxQYXJzZXIiLCJkb2N1bWVudFBhcnNlciIsInN0b3J5Q291bnQiLCJzdWJzdHJpbmciLCJzdG9yeVBhcnNlciIsInBhcnNlU3RvcnlGaWxlIiwic3luY01vZHVsZURhdGEiLCJnZXREb2N1bWVudCIsInNwcmVhZHMiLCJnZXRTcHJlYWRzIiwibWFzdGVyU3ByZWFkcyIsImdldE1hc3RlclNwcmVhZHMiLCJnZXREb2N1bWVudEluZm8iLCJsYXllcnMiLCJnZXRMYXllcnMiLCJzdHlsZXMiLCJnZXRTdHlsZXMiLCJyZXNvdXJjZXMiLCJnZXRSZXNvdXJjZXMiLCJnZXRTdG9yaWVzIiwiZWxlbWVudFBhcnNlciIsImdldEVsZW1lbnRzIiwiZ2V0UGFnZUluZm8iLCJkb2N1bWVudFVuaXRzIiwic2V0RG9jdW1lbnRVbml0cyIsImRlYnVnQW5hbHl6ZXIiLCJwcm9jZXNzSURNTFBhY2thZ2UiLCJpZG1sRmlsZVBhdGgiLCJwYWNrYWdlU3RydWN0dXJlIiwiZXh0cmFjdGVkSW1hZ2VzIiwiaW1hZ2VQcm9jZXNzb3IiLCJwcm9jZXNzTGlua2VkUmVzb3VyY2VzIiwicGFja2FnZUluZm8iLCJoYXNMaW5rcyIsInJlc291cmNlTWFwIiwic2l6ZSIsImhhc0ZvbnRzIiwibGlua3NDb3VudCIsIkFycmF5IiwiZnJvbSIsImlzSW1hZ2VGaWxlIiwiZm9udHNDb3VudCIsImV4dHJhY3RlZEltYWdlc0NvdW50IiwiZXh0cmFjdEFuZFNhdmVFbWJlZGRlZEltYWdlcyIsImlkbWxQYXRoIiwidXBsb2FkRGlyIiwiZXh0cmFjdEVtYmVkZGVkSW1hZ2VGcm9tU3ByZWFkIiwiZGVidWdJRE1MQ29udGVudHMiLCJkZWJ1Z0lETUxDb250ZW50c0RldGFpbGVkIiwiYW5hbHl6ZVNwcmVhZEZvckltYWdlUmVmZXJlbmNlcyIsImdldFBhZ2VDb250ZW50IiwicGFnZUlkIiwiZ2V0WE1MUGFyc2VyIiwiZ2V0RmlsZUV4dHJhY3RvciIsImdldFN0eWxlUGFyc2VyIiwiZ2V0U3RvcnlQYXJzZXIiLCJnZXRFbGVtZW50UGFyc2VyIiwiZ2V0RG9jdW1lbnRQYXJzZXIiLCJnZXRJbWFnZVByb2Nlc3NvciIsImdldERlYnVnQW5hbHl6ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJwcmVzZXJ2ZU9yaWdpbmFsVW5pdHMiLCJ1bml0Q29udmVydGVyIiwicGFyYWdyYXBoIiwiY2hhcmFjdGVyIiwib2JqZWN0IiwidGFibGUiLCJjZWxsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/IDMLProcessor.js\n"));

/***/ })

});