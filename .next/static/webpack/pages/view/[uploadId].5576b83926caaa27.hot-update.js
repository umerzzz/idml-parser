"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/DocumentParser.js":
/*!***************************************!*\
  !*** ./lib/parsers/DocumentParser.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass DocumentParser {\n    async parseDocumentStructure(extractedData, xmlParser) {\n        console.log(\"Parsing document structure...\");\n        console.log(\"\\uD83D\\uDD0D Total files to process:\", Object.keys(extractedData).length);\n        // Parse designmap.xml first (main document structure)\n        if (extractedData[\"designmap.xml\"]) {\n            console.log(\"Parsing designmap.xml...\");\n            try {\n                const designMapData = xmlParser.parse(extractedData[\"designmap.xml\"]);\n                this.document = designMapData.Document || designMapData;\n                await this.extractDocumentInfo(this.document);\n                console.log(\"✅ DesignMap parsed successfully\");\n            } catch (error) {\n                console.error(\"Error parsing designmap.xml:\", error);\n            }\n        }\n        // Parse Spreads\n        console.log(\"\\n\\uD83D\\uDCC4 === PARSING SPREADS ===\");\n        for (const [fileName, content] of Object.entries(extractedData)){\n            if (fileName.startsWith(\"Spreads/\")) {\n                console.log(\"\\uD83D\\uDD0D Processing spread:\", fileName);\n                await this.parseSpreadFile(fileName, content, xmlParser);\n            }\n        }\n        // Parse Master Spreads\n        console.log(\"\\n\\uD83C\\uDFA8 === PARSING MASTER SPREADS ===\");\n        for (const [fileName, content] of Object.entries(extractedData)){\n            if (fileName.startsWith(\"MasterSpreads/\")) {\n                console.log(\"\\uD83D\\uDD0D Processing master spread:\", fileName);\n                await this.parseMasterSpreadFile(fileName, content, xmlParser);\n            }\n        }\n    }\n    async extractDocumentInfo(document) {\n        console.log(\"Extracting document information...\");\n        if (!document) return;\n        // Extract document preferences and page setup\n        this.documentInfo = {\n            version: document[\"@_DOMVersion\"] || \"Unknown\",\n            self: document[\"@_Self\"] || \"Unknown\",\n            activeLayer: document[\"@_ActiveLayer\"] || null,\n            unusedSwatches: document[\"@_UnusedSwatches\"] || [],\n            // Document preferences\n            documentPreferences: this.extractDocumentPreferences(document),\n            // Page setup\n            pageSetup: this.extractPageSetup(document),\n            // Layers\n            layers: this.extractLayers(document),\n            // Pages\n            pages: this.extractPages(document)\n        };\n        console.log(\"✅ Document info extracted\");\n    }\n    extractDocumentPreferences(document) {\n        console.log(\"\\uD83D\\uDCCB Extracting document preferences...\");\n        console.log(\"Document keys:\", Object.keys(document));\n        const prefs = {};\n        // Try multiple possible locations for document preferences\n        let docPref = null;\n        if (document.DocumentPreference) {\n            docPref = document.DocumentPreference;\n            console.log(\"Found DocumentPreference\");\n        } else if (document.documentPreference) {\n            docPref = document.documentPreference;\n            console.log(\"Found documentPreference (lowercase)\");\n        } else if (document.Properties && document.Properties.DocumentPreference) {\n            docPref = document.Properties.DocumentPreference;\n            console.log(\"Found DocumentPreference in Properties\");\n        }\n        if (docPref) {\n            console.log(\"DocumentPreference keys:\", Object.keys(docPref));\n            prefs.pageWidth = parseFloat(docPref[\"@_PageWidth\"]) || 0;\n            prefs.pageHeight = parseFloat(docPref[\"@_PageHeight\"]) || 0;\n            prefs.left = parseFloat(docPref[\"@_Left\"]) || 0;\n            prefs.top = parseFloat(docPref[\"@_Top\"]) || 0;\n            prefs.right = parseFloat(docPref[\"@_Right\"]) || 0;\n            prefs.bottom = parseFloat(docPref[\"@_Bottom\"]) || 0;\n            prefs.columnCount = parseInt(docPref[\"@_ColumnCount\"]) || 1;\n            prefs.columnGutter = parseFloat(docPref[\"@_ColumnGutter\"]) || 0;\n            prefs.facingPages = docPref[\"@_FacingPages\"] === \"true\" || docPref[\"@_FacingPages\"] === true;\n            console.log(\"\\uD83D\\uDCCB Extracted document preferences:\", prefs);\n        } else {\n            console.log(\"⚠️ No DocumentPreference found in document\");\n        }\n        // Also try to extract margin preferences\n        let marginPref = null;\n        if (document.MarginPreference) {\n            marginPref = document.MarginPreference;\n            console.log(\"Found MarginPreference\");\n        } else if (document.marginPreference) {\n            marginPref = document.marginPreference;\n            console.log(\"Found marginPreference (lowercase)\");\n        } else if (document.Properties && document.Properties.MarginPreference) {\n            marginPref = document.Properties.MarginPreference;\n            console.log(\"Found MarginPreference in Properties\");\n        }\n        if (marginPref) {\n            console.log(\"MarginPreference keys:\", Object.keys(marginPref));\n            prefs.marginTop = parseFloat(marginPref[\"@_Top\"]) || 0;\n            prefs.marginBottom = parseFloat(marginPref[\"@_Bottom\"]) || 0;\n            prefs.marginLeft = parseFloat(marginPref[\"@_Left\"]) || 0;\n            prefs.marginRight = parseFloat(marginPref[\"@_Right\"]) || 0;\n            prefs.marginColumnCount = parseInt(marginPref[\"@_ColumnCount\"]) || 1;\n            prefs.marginColumnGutter = parseFloat(marginPref[\"@_ColumnGutter\"]) || 0;\n            console.log(\"\\uD83D\\uDCCF Extracted margin preferences:\", {\n                top: prefs.marginTop,\n                bottom: prefs.marginBottom,\n                left: prefs.marginLeft,\n                right: prefs.marginRight,\n                columnCount: prefs.marginColumnCount,\n                columnGutter: prefs.marginColumnGutter\n            });\n        }\n        return prefs;\n    }\n    extractPageSetup(document) {\n        const pageSetup = {\n            pages: [],\n            masterPages: [],\n            spreads: []\n        };\n        // Extract page information from document\n        if (document.Page) {\n            const pages = Array.isArray(document.Page) ? document.Page : [\n                document.Page\n            ];\n            pages.forEach((page)=>{\n                pageSetup.pages.push({\n                    self: page[\"@_Self\"],\n                    name: page[\"@_Name\"] || \"\",\n                    appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                    geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                    itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"]),\n                    overrideList: page[\"@_OverrideList\"] || []\n                });\n            });\n        }\n        return pageSetup;\n    }\n    extractLayers(document) {\n        const layers = [];\n        if (document.Layer) {\n            const layerData = Array.isArray(document.Layer) ? document.Layer : [\n                document.Layer\n            ];\n            layerData.forEach((layer)=>{\n                layers.push({\n                    self: layer[\"@_Self\"],\n                    name: layer[\"@_Name\"] || \"\",\n                    visible: layer[\"@_Visible\"] !== false,\n                    locked: layer[\"@_Locked\"] === true,\n                    ignoreWrap: layer[\"@_IgnoreWrap\"] === true,\n                    showGuides: layer[\"@_ShowGuides\"] !== false,\n                    lockGuides: layer[\"@_LockGuides\"] === true,\n                    ui: layer[\"@_UI\"] || \"\",\n                    layerColor: layer[\"@_LayerColor\"] || \"LightBlue\"\n                });\n            });\n        }\n        this.layers = layers;\n        return layers;\n    }\n    extractPages(document) {\n        const pages = [];\n        if (document.Spread) {\n            const spreads = Array.isArray(document.Spread) ? document.Spread : [\n                document.Spread\n            ];\n            spreads.forEach((spread)=>{\n                if (spread.Page) {\n                    const spreadPages = Array.isArray(spread.Page) ? spread.Page : [\n                        spread.Page\n                    ];\n                    spreadPages.forEach((page)=>{\n                        pages.push({\n                            self: page[\"@_Self\"],\n                            name: page[\"@_Name\"] || \"\",\n                            appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                            geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                            itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"]),\n                            spreadParent: spread[\"@_Self\"]\n                        });\n                    });\n                }\n            });\n        }\n        return pages;\n    }\n    async parseSpreadFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCC4 Parsing spread: \".concat(fileName));\n        try {\n            var _parsed_Spread;\n            const parsed = xmlParser.parse(content);\n            const spreadId = path.basename(fileName, \".xml\");\n            const spreadData = ((_parsed_Spread = parsed.Spread) === null || _parsed_Spread === void 0 ? void 0 : _parsed_Spread.Spread) || parsed.Spread || parsed;\n            if (parsed.Spread) {\n                console.log(\"Spread wrapper keys:\", Object.keys(parsed.Spread));\n                if (parsed.Spread.Spread) {\n                    console.log(\"Actual spread keys:\", Object.keys(parsed.Spread.Spread));\n                }\n            }\n            if (spreadData.Page) {\n                const pages = Array.isArray(spreadData.Page) ? spreadData.Page : [\n                    spreadData.Page\n                ];\n                console.log(\"Found \".concat(pages.length, \" pages in spread\"));\n                pages.forEach((page, index)=>{\n                    console.log(\"Page \".concat(index, \" keys:\"), Object.keys(page));\n                    // Look for elements in the page\n                    Object.keys(page).forEach((key)=>{\n                        if (key !== \"@_Self\" && key !== \"@_Name\" && key !== \"@_GeometricBounds\" && key !== \"@_ItemTransform\" && key !== \"@_AppliedMaster\") {\n                            const value = page[key];\n                            if (Array.isArray(value)) {\n                                console.log(\"  Found array \".concat(key, \" with \").concat(value.length, \" items\"));\n                            } else if (typeof value === \"object\") {\n                                console.log(\"  Found object \".concat(key, \":\"), Object.keys(value));\n                            }\n                        }\n                    });\n                });\n            } else {\n                console.log(\"No Page property found in spread\");\n            }\n            // Check for direct elements in spread\n            Object.keys(spreadData).forEach((key)=>{\n                if (key.includes(\"Frame\") || key.includes(\"Rectangle\") || key.includes(\"Text\") || key.includes(\"Group\") || key.includes(\"Oval\")) {\n                    console.log(\"Found potential elements directly in spread: \".concat(key), Array.isArray(spreadData[key]) ? spreadData[key].length : \"single\");\n                }\n            });\n            // Extract detailed spread information\n            const detailedSpread = {\n                self: spreadData[\"@_Self\"],\n                flattenerOverride: spreadData[\"@_FlattenerOverride\"] || \"\",\n                bindingLocation: parseFloat(spreadData[\"@_BindingLocation\"]) || 0,\n                allowPageShuffle: spreadData[\"@_AllowPageShuffle\"] !== false,\n                // Extract page elements\n                pages: this.elementParser.extractSpreadPages(spreadData),\n                // Extract all page items (text frames, rectangles, etc.)\n                pageItems: this.elementParser.extractPageItems(spreadData)\n            };\n            this.spreads[spreadId] = detailedSpread;\n            console.log(\"✅ Spread \".concat(spreadId, \" parsed with \").concat(detailedSpread.pageItems.length, \" items\"));\n        } catch (error) {\n            console.error(\"❌ Error parsing spread \".concat(fileName, \":\"), error.message);\n        }\n    }\n    async parseMasterSpreadFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83C\\uDFA8 Parsing master spread: \".concat(fileName));\n        try {\n            var _parsed_MasterSpread;\n            const parsed = xmlParser.parse(content);\n            const masterId = path.basename(fileName, \".xml\");\n            const masterData = ((_parsed_MasterSpread = parsed.MasterSpread) === null || _parsed_MasterSpread === void 0 ? void 0 : _parsed_MasterSpread.MasterSpread) || parsed.MasterSpread || parsed;\n            console.log(\"Parsed master spread keys:\", Object.keys(parsed));\n            if (parsed.MasterSpread) {\n                console.log(\"MasterSpread wrapper keys:\", Object.keys(parsed.MasterSpread));\n                if (parsed.MasterSpread.MasterSpread) {\n                    console.log(\"Actual master spread keys:\", Object.keys(parsed.MasterSpread.MasterSpread));\n                }\n            }\n            // Extract detailed master spread information\n            const detailedMaster = {\n                self: masterData[\"@_Self\"],\n                name: masterData[\"@_Name\"] || \"\",\n                namePrefix: masterData[\"@_NamePrefix\"] || \"\",\n                basedOn: masterData[\"@_BasedOn\"] || \"\",\n                itemTransform: IDMLUtils.parseTransform(masterData[\"@_ItemTransform\"]),\n                // Extract master pages\n                pages: this.elementParser.extractMasterPages(masterData),\n                // Extract master page items\n                pageItems: this.elementParser.extractPageItems(masterData)\n            };\n            this.masterSpreads[masterId] = detailedMaster;\n            console.log(\"✅ Master spread \".concat(masterId, \" parsed with \").concat(detailedMaster.pageItems.length, \" items\"));\n        } catch (error) {\n            console.error(\"❌ Error parsing master spread \".concat(fileName, \":\"), error.message);\n        }\n    }\n    async extractDetailedInformation() {\n        console.log(\"Extracting detailed information with enhanced processing...\");\n        this.pageInfo = {\n            dimensions: this.calculatePageDimensions(),\n            margins: this.calculateMargins(),\n            bleeds: this.calculateBleeds(),\n            guides: this.extractGuides(),\n            grids: this.extractGrids()\n        };\n        this.elementParser.createElementPositionMapFixed(); // Use the fixed version\n        console.log(\"✅ Enhanced detailed information extracted\");\n    }\n    calculatePageDimensions() {\n        var _this_documentInfo_preferences, _this_documentInfo_preferences_viewPreferences, _this_documentInfo_preferences1;\n        // Try to get dimensions from spreads first (most reliable)\n        if (this.spreads && Object.keys(this.spreads).length > 0) {\n            const firstSpread = Object.values(this.spreads)[0];\n            if (firstSpread.pages && firstSpread.pages.length > 0) {\n                const firstPage = firstSpread.pages[0];\n                if (firstPage.geometricBounds) {\n                    const bounds = firstPage.geometricBounds;\n                    return {\n                        width: bounds.width || bounds.right - bounds.left || 0,\n                        height: bounds.height || bounds.bottom - bounds.top || 0,\n                        facingPages: Object.values(this.spreads).some((spread)=>spread.pages && spread.pages.length > 1),\n                        units: \"Points\"\n                    };\n                }\n            }\n        }\n        // Fallback to document preferences\n        const docPrefs = ((_this_documentInfo_preferences = this.documentInfo.preferences) === null || _this_documentInfo_preferences === void 0 ? void 0 : _this_documentInfo_preferences.documentPreferences) || {};\n        return {\n            width: docPrefs.pageWidth || 0,\n            height: docPrefs.pageHeight || 0,\n            facingPages: docPrefs.facingPages || false,\n            units: ((_this_documentInfo_preferences1 = this.documentInfo.preferences) === null || _this_documentInfo_preferences1 === void 0 ? void 0 : (_this_documentInfo_preferences_viewPreferences = _this_documentInfo_preferences1.viewPreferences) === null || _this_documentInfo_preferences_viewPreferences === void 0 ? void 0 : _this_documentInfo_preferences_viewPreferences.horizontalMeasurementUnits) || \"Points\"\n        };\n    }\n    calculateMargins() {\n        var _this_documentInfo_preferences;\n        console.log(\"\\uD83D\\uDCCF Calculating margins from multiple sources...\");\n        // Try to get margins from master pages first (most reliable)\n        if (this.masterSpreads && Object.keys(this.masterSpreads).length > 0) {\n            const firstMaster = Object.values(this.masterSpreads)[0];\n            if (firstMaster.pages && firstMaster.pages.length > 0) {\n                const firstMasterPage = firstMaster.pages[0];\n                // Look for margin preferences in master page\n                // This will be populated by the improved master spread parsing\n                if (firstMasterPage.marginPreference) {\n                    const masterMargins = {\n                        top: firstMasterPage.marginPreference.top || 0,\n                        bottom: firstMasterPage.marginPreference.bottom || 0,\n                        left: firstMasterPage.marginPreference.left || 0,\n                        right: firstMasterPage.marginPreference.right || 0,\n                        columnCount: firstMasterPage.marginPreference.columnCount || 1,\n                        columnGutter: firstMasterPage.marginPreference.columnGutter || 0\n                    };\n                    console.log(\"\\uD83D\\uDCCF Found margins from master page:\", masterMargins);\n                    return masterMargins;\n                }\n            }\n        }\n        // Fallback to document preferences\n        const docPrefs = this.documentInfo.documentPreferences || {};\n        const marginPrefs = ((_this_documentInfo_preferences = this.documentInfo.preferences) === null || _this_documentInfo_preferences === void 0 ? void 0 : _this_documentInfo_preferences.marginPreferences) || {};\n        // Check for margin data in document preferences (fallback)\n        const margins = {\n            top: marginPrefs.top || docPrefs.marginTop || docPrefs.top || 0,\n            bottom: marginPrefs.bottom || docPrefs.marginBottom || docPrefs.bottom || 0,\n            left: marginPrefs.left || docPrefs.marginLeft || docPrefs.left || 0,\n            right: marginPrefs.right || docPrefs.marginRight || docPrefs.right || 0,\n            columnCount: marginPrefs.columnCount || docPrefs.marginColumnCount || docPrefs.columnCount || 1,\n            columnGutter: marginPrefs.columnGutter || docPrefs.marginColumnGutter || docPrefs.columnGutter || 0\n        };\n        console.log(\"\\uD83D\\uDCCF Calculated margins (fallback):\", margins);\n        return margins;\n    }\n    calculateBleeds() {\n        var _this_documentInfo_preferences;\n        const docPrefs = ((_this_documentInfo_preferences = this.documentInfo.preferences) === null || _this_documentInfo_preferences === void 0 ? void 0 : _this_documentInfo_preferences.documentPreferences) || {};\n        return {\n            top: docPrefs.documentBleedTopOffset || 0,\n            bottom: docPrefs.documentBleedBottomOffset || 0,\n            inside: docPrefs.documentBleedInsideOrLeftOffset || 0,\n            outside: docPrefs.documentBleedOutsideOrRightOffset || 0\n        };\n    }\n    extractGuides() {\n        const guides = [];\n        // Extract guides from spreads\n        Object.values(this.spreads).forEach((spread)=>{\n            if (spread.pageItems) {\n                spread.pageItems.forEach((item)=>{\n                    if (item.type === \"Guide\") {\n                        guides.push({\n                            orientation: item.orientation || \"Horizontal\",\n                            location: item.location || 0,\n                            fitToPage: item.fitToPage || false,\n                            viewThreshold: item.viewThreshold || 0\n                        });\n                    }\n                });\n            }\n        });\n        return guides;\n    }\n    extractGrids() {\n        var _this_documentInfo_preferences;\n        const gridPrefs = ((_this_documentInfo_preferences = this.documentInfo.preferences) === null || _this_documentInfo_preferences === void 0 ? void 0 : _this_documentInfo_preferences.gridPreferences) || {};\n        return {\n            baseline: {\n                start: gridPrefs.baselineStart || 0,\n                division: gridPrefs.baselineDivision || 12,\n                shown: gridPrefs.baselineShown || false,\n                snapTo: gridPrefs.baselineSnapto || false\n            },\n            document: {\n                shown: gridPrefs.documentGridShown || false,\n                snapTo: gridPrefs.documentGridSnapto || false\n            }\n        };\n    }\n    // Utility method to get page content\n    getPageContent(pageId) {\n        return this.elementParser.getPageContent(pageId);\n    }\n    getDocument() {\n        return this.document;\n    }\n    getSpreads() {\n        return this.spreads;\n    }\n    getMasterSpreads() {\n        return this.masterSpreads;\n    }\n    getDocumentInfo() {\n        return this.documentInfo;\n    }\n    getPageInfo() {\n        return this.pageInfo;\n    }\n    getLayers() {\n        return this.layers;\n    }\n    calculateCoordinateOffset() {\n        return IDMLUtils.calculateCoordinateOffset(this.elementParser.getElements());\n    }\n    constructor(elementParser){\n        this.elementParser = elementParser;\n        this.document = null;\n        this.spreads = {};\n        this.masterSpreads = {};\n        this.documentInfo = {};\n        this.pageInfo = {};\n        this.layers = [];\n    }\n}\nmodule.exports = DocumentParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcGFyc2Vycy9Eb2N1bWVudFBhcnNlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDckIsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUM7QUFFMUIsTUFBTUU7SUFXSixNQUFNQyx1QkFBdUJDLGFBQWEsRUFBRUMsU0FBUyxFQUFFO1FBQ3JEQyxRQUFRQyxHQUFHLENBQUM7UUFDWkQsUUFBUUMsR0FBRyxDQUFDLHdDQUE4QkMsT0FBT0MsSUFBSSxDQUFDTCxlQUFlTSxNQUFNO1FBRTNFLHNEQUFzRDtRQUN0RCxJQUFJTixhQUFhLENBQUMsZ0JBQWdCLEVBQUU7WUFDbENFLFFBQVFDLEdBQUcsQ0FBQztZQUNaLElBQUk7Z0JBQ0YsTUFBTUksZ0JBQWdCTixVQUFVTyxLQUFLLENBQUNSLGFBQWEsQ0FBQyxnQkFBZ0I7Z0JBQ3BFLElBQUksQ0FBQ1MsUUFBUSxHQUFHRixjQUFjRyxRQUFRLElBQUlIO2dCQUMxQyxNQUFNLElBQUksQ0FBQ0ksbUJBQW1CLENBQUMsSUFBSSxDQUFDRixRQUFRO2dCQUM1Q1AsUUFBUUMsR0FBRyxDQUFDO1lBQ2QsRUFBRSxPQUFPUyxPQUFPO2dCQUNkVixRQUFRVSxLQUFLLENBQUMsZ0NBQWdDQTtZQUNoRDtRQUNGO1FBRUEsZ0JBQWdCO1FBQ2hCVixRQUFRQyxHQUFHLENBQUM7UUFDWixLQUFLLE1BQU0sQ0FBQ1UsVUFBVUMsUUFBUSxJQUFJVixPQUFPVyxPQUFPLENBQUNmLGVBQWdCO1lBQy9ELElBQUlhLFNBQVNHLFVBQVUsQ0FBQyxhQUFhO2dCQUNuQ2QsUUFBUUMsR0FBRyxDQUFDLG1DQUF5QlU7Z0JBQ3JDLE1BQU0sSUFBSSxDQUFDSSxlQUFlLENBQUNKLFVBQVVDLFNBQVNiO1lBQ2hEO1FBQ0Y7UUFFQSx1QkFBdUI7UUFDdkJDLFFBQVFDLEdBQUcsQ0FBQztRQUNaLEtBQUssTUFBTSxDQUFDVSxVQUFVQyxRQUFRLElBQUlWLE9BQU9XLE9BQU8sQ0FBQ2YsZUFBZ0I7WUFDL0QsSUFBSWEsU0FBU0csVUFBVSxDQUFDLG1CQUFtQjtnQkFDekNkLFFBQVFDLEdBQUcsQ0FBQywwQ0FBZ0NVO2dCQUM1QyxNQUFNLElBQUksQ0FBQ0sscUJBQXFCLENBQUNMLFVBQVVDLFNBQVNiO1lBQ3REO1FBQ0Y7SUFDRjtJQUVBLE1BQU1VLG9CQUFvQkYsUUFBUSxFQUFFO1FBQ2xDUCxRQUFRQyxHQUFHLENBQUM7UUFFWixJQUFJLENBQUNNLFVBQVU7UUFFZiw4Q0FBOEM7UUFDOUMsSUFBSSxDQUFDVSxZQUFZLEdBQUc7WUFDbEJDLFNBQVNYLFFBQVEsQ0FBQyxlQUFlLElBQUk7WUFDckNZLE1BQU1aLFFBQVEsQ0FBQyxTQUFTLElBQUk7WUFDNUJhLGFBQWFiLFFBQVEsQ0FBQyxnQkFBZ0IsSUFBSTtZQUMxQ2MsZ0JBQWdCZCxRQUFRLENBQUMsbUJBQW1CLElBQUksRUFBRTtZQUVsRCx1QkFBdUI7WUFDdkJlLHFCQUFxQixJQUFJLENBQUNDLDBCQUEwQixDQUFDaEI7WUFFckQsYUFBYTtZQUNiaUIsV0FBVyxJQUFJLENBQUNDLGdCQUFnQixDQUFDbEI7WUFFakMsU0FBUztZQUNUbUIsUUFBUSxJQUFJLENBQUNDLGFBQWEsQ0FBQ3BCO1lBRTNCLFFBQVE7WUFDUnFCLE9BQU8sSUFBSSxDQUFDQyxZQUFZLENBQUN0QjtRQUMzQjtRQUVBUCxRQUFRQyxHQUFHLENBQUM7SUFDZDtJQUVBc0IsMkJBQTJCaEIsUUFBUSxFQUFFO1FBQ25DUCxRQUFRQyxHQUFHLENBQUM7UUFDWkQsUUFBUUMsR0FBRyxDQUFDLGtCQUFrQkMsT0FBT0MsSUFBSSxDQUFDSTtRQUUxQyxNQUFNdUIsUUFBUSxDQUFDO1FBRWYsMkRBQTJEO1FBQzNELElBQUlDLFVBQVU7UUFFZCxJQUFJeEIsU0FBU3lCLGtCQUFrQixFQUFFO1lBQy9CRCxVQUFVeEIsU0FBU3lCLGtCQUFrQjtZQUNyQ2hDLFFBQVFDLEdBQUcsQ0FBQztRQUNkLE9BQU8sSUFBSU0sU0FBUzBCLGtCQUFrQixFQUFFO1lBQ3RDRixVQUFVeEIsU0FBUzBCLGtCQUFrQjtZQUNyQ2pDLFFBQVFDLEdBQUcsQ0FBQztRQUNkLE9BQU8sSUFBSU0sU0FBUzJCLFVBQVUsSUFBSTNCLFNBQVMyQixVQUFVLENBQUNGLGtCQUFrQixFQUFFO1lBQ3hFRCxVQUFVeEIsU0FBUzJCLFVBQVUsQ0FBQ0Ysa0JBQWtCO1lBQ2hEaEMsUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7UUFFQSxJQUFJOEIsU0FBUztZQUNYL0IsUUFBUUMsR0FBRyxDQUFDLDRCQUE0QkMsT0FBT0MsSUFBSSxDQUFDNEI7WUFDcERELE1BQU1LLFNBQVMsR0FBR0MsV0FBV0wsT0FBTyxDQUFDLGNBQWMsS0FBSztZQUN4REQsTUFBTU8sVUFBVSxHQUFHRCxXQUFXTCxPQUFPLENBQUMsZUFBZSxLQUFLO1lBQzFERCxNQUFNUSxJQUFJLEdBQUdGLFdBQVdMLE9BQU8sQ0FBQyxTQUFTLEtBQUs7WUFDOUNELE1BQU1TLEdBQUcsR0FBR0gsV0FBV0wsT0FBTyxDQUFDLFFBQVEsS0FBSztZQUM1Q0QsTUFBTVUsS0FBSyxHQUFHSixXQUFXTCxPQUFPLENBQUMsVUFBVSxLQUFLO1lBQ2hERCxNQUFNVyxNQUFNLEdBQUdMLFdBQVdMLE9BQU8sQ0FBQyxXQUFXLEtBQUs7WUFDbERELE1BQU1ZLFdBQVcsR0FBR0MsU0FBU1osT0FBTyxDQUFDLGdCQUFnQixLQUFLO1lBQzFERCxNQUFNYyxZQUFZLEdBQUdSLFdBQVdMLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSztZQUM5REQsTUFBTWUsV0FBVyxHQUFHZCxPQUFPLENBQUMsZ0JBQWdCLEtBQUssVUFBVUEsT0FBTyxDQUFDLGdCQUFnQixLQUFLO1lBRXhGL0IsUUFBUUMsR0FBRyxDQUFDLGdEQUFzQzZCO1FBQ3BELE9BQU87WUFDTDlCLFFBQVFDLEdBQUcsQ0FBQztRQUNkO1FBRUEseUNBQXlDO1FBQ3pDLElBQUk2QyxhQUFhO1FBQ2pCLElBQUl2QyxTQUFTd0MsZ0JBQWdCLEVBQUU7WUFDN0JELGFBQWF2QyxTQUFTd0MsZ0JBQWdCO1lBQ3RDL0MsUUFBUUMsR0FBRyxDQUFDO1FBQ2QsT0FBTyxJQUFJTSxTQUFTeUMsZ0JBQWdCLEVBQUU7WUFDcENGLGFBQWF2QyxTQUFTeUMsZ0JBQWdCO1lBQ3RDaEQsUUFBUUMsR0FBRyxDQUFDO1FBQ2QsT0FBTyxJQUFJTSxTQUFTMkIsVUFBVSxJQUFJM0IsU0FBUzJCLFVBQVUsQ0FBQ2EsZ0JBQWdCLEVBQUU7WUFDdEVELGFBQWF2QyxTQUFTMkIsVUFBVSxDQUFDYSxnQkFBZ0I7WUFDakQvQyxRQUFRQyxHQUFHLENBQUM7UUFDZDtRQUVBLElBQUk2QyxZQUFZO1lBQ2Q5QyxRQUFRQyxHQUFHLENBQUMsMEJBQTBCQyxPQUFPQyxJQUFJLENBQUMyQztZQUNsRGhCLE1BQU1tQixTQUFTLEdBQUdiLFdBQVdVLFVBQVUsQ0FBQyxRQUFRLEtBQUs7WUFDckRoQixNQUFNb0IsWUFBWSxHQUFHZCxXQUFXVSxVQUFVLENBQUMsV0FBVyxLQUFLO1lBQzNEaEIsTUFBTXFCLFVBQVUsR0FBR2YsV0FBV1UsVUFBVSxDQUFDLFNBQVMsS0FBSztZQUN2RGhCLE1BQU1zQixXQUFXLEdBQUdoQixXQUFXVSxVQUFVLENBQUMsVUFBVSxLQUFLO1lBQ3pEaEIsTUFBTXVCLGlCQUFpQixHQUFHVixTQUFTRyxVQUFVLENBQUMsZ0JBQWdCLEtBQUs7WUFDbkVoQixNQUFNd0Isa0JBQWtCLEdBQUdsQixXQUFXVSxVQUFVLENBQUMsaUJBQWlCLEtBQUs7WUFFdkU5QyxRQUFRQyxHQUFHLENBQUMsOENBQW9DO2dCQUM5Q3NDLEtBQUtULE1BQU1tQixTQUFTO2dCQUNwQlIsUUFBUVgsTUFBTW9CLFlBQVk7Z0JBQzFCWixNQUFNUixNQUFNcUIsVUFBVTtnQkFDdEJYLE9BQU9WLE1BQU1zQixXQUFXO2dCQUN4QlYsYUFBYVosTUFBTXVCLGlCQUFpQjtnQkFDcENULGNBQWNkLE1BQU13QixrQkFBa0I7WUFDeEM7UUFDRjtRQUVBLE9BQU94QjtJQUNUO0lBRUFMLGlCQUFpQmxCLFFBQVEsRUFBRTtRQUN6QixNQUFNaUIsWUFBWTtZQUNoQkksT0FBTyxFQUFFO1lBQ1QyQixhQUFhLEVBQUU7WUFDZkMsU0FBUyxFQUFFO1FBQ2I7UUFFQSx5Q0FBeUM7UUFDekMsSUFBSWpELFNBQVNrRCxJQUFJLEVBQUU7WUFDakIsTUFBTTdCLFFBQVE4QixNQUFNQyxPQUFPLENBQUNwRCxTQUFTa0QsSUFBSSxJQUFJbEQsU0FBU2tELElBQUksR0FBRztnQkFBQ2xELFNBQVNrRCxJQUFJO2FBQUM7WUFFNUU3QixNQUFNZ0MsT0FBTyxDQUFDQyxDQUFBQTtnQkFDWnJDLFVBQVVJLEtBQUssQ0FBQ2tDLElBQUksQ0FBQztvQkFDbkIzQyxNQUFNMEMsSUFBSSxDQUFDLFNBQVM7b0JBQ3BCRSxNQUFNRixJQUFJLENBQUMsU0FBUyxJQUFJO29CQUN4QkcsZUFBZUgsSUFBSSxDQUFDLGtCQUFrQixJQUFJO29CQUMxQ0ksaUJBQWlCdEUsVUFBVXVFLG9CQUFvQixDQUFDTCxJQUFJLENBQUMsb0JBQW9CO29CQUN6RU0sZUFBZXhFLFVBQVV5RSxjQUFjLENBQUNQLElBQUksQ0FBQyxrQkFBa0I7b0JBQy9EUSxjQUFjUixJQUFJLENBQUMsaUJBQWlCLElBQUksRUFBRTtnQkFDNUM7WUFDRjtRQUNGO1FBRUEsT0FBT3JDO0lBQ1Q7SUFFQUcsY0FBY3BCLFFBQVEsRUFBRTtRQUN0QixNQUFNbUIsU0FBUyxFQUFFO1FBRWpCLElBQUluQixTQUFTK0QsS0FBSyxFQUFFO1lBQ2xCLE1BQU1DLFlBQVliLE1BQU1DLE9BQU8sQ0FBQ3BELFNBQVMrRCxLQUFLLElBQUkvRCxTQUFTK0QsS0FBSyxHQUFHO2dCQUFDL0QsU0FBUytELEtBQUs7YUFBQztZQUVuRkMsVUFBVVgsT0FBTyxDQUFDWSxDQUFBQTtnQkFDaEI5QyxPQUFPb0MsSUFBSSxDQUFDO29CQUNWM0MsTUFBTXFELEtBQUssQ0FBQyxTQUFTO29CQUNyQlQsTUFBTVMsS0FBSyxDQUFDLFNBQVMsSUFBSTtvQkFDekJDLFNBQVNELEtBQUssQ0FBQyxZQUFZLEtBQUs7b0JBQ2hDRSxRQUFRRixLQUFLLENBQUMsV0FBVyxLQUFLO29CQUM5QkcsWUFBWUgsS0FBSyxDQUFDLGVBQWUsS0FBSztvQkFDdENJLFlBQVlKLEtBQUssQ0FBQyxlQUFlLEtBQUs7b0JBQ3RDSyxZQUFZTCxLQUFLLENBQUMsZUFBZSxLQUFLO29CQUN0Q00sSUFBSU4sS0FBSyxDQUFDLE9BQU8sSUFBSTtvQkFDckJPLFlBQVlQLEtBQUssQ0FBQyxlQUFlLElBQUk7Z0JBQ3ZDO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQzlDLE1BQU0sR0FBR0E7UUFDZCxPQUFPQTtJQUNUO0lBRUFHLGFBQWF0QixRQUFRLEVBQUU7UUFDckIsTUFBTXFCLFFBQVEsRUFBRTtRQUVoQixJQUFJckIsU0FBU3lFLE1BQU0sRUFBRTtZQUNuQixNQUFNeEIsVUFBVUUsTUFBTUMsT0FBTyxDQUFDcEQsU0FBU3lFLE1BQU0sSUFBSXpFLFNBQVN5RSxNQUFNLEdBQUc7Z0JBQUN6RSxTQUFTeUUsTUFBTTthQUFDO1lBRXBGeEIsUUFBUUksT0FBTyxDQUFDcUIsQ0FBQUE7Z0JBQ2QsSUFBSUEsT0FBT3hCLElBQUksRUFBRTtvQkFDZixNQUFNeUIsY0FBY3hCLE1BQU1DLE9BQU8sQ0FBQ3NCLE9BQU94QixJQUFJLElBQUl3QixPQUFPeEIsSUFBSSxHQUFHO3dCQUFDd0IsT0FBT3hCLElBQUk7cUJBQUM7b0JBQzVFeUIsWUFBWXRCLE9BQU8sQ0FBQ0MsQ0FBQUE7d0JBQ2xCakMsTUFBTWtDLElBQUksQ0FBQzs0QkFDVDNDLE1BQU0wQyxJQUFJLENBQUMsU0FBUzs0QkFDcEJFLE1BQU1GLElBQUksQ0FBQyxTQUFTLElBQUk7NEJBQ3hCRyxlQUFlSCxJQUFJLENBQUMsa0JBQWtCLElBQUk7NEJBQzFDSSxpQkFBaUJ0RSxVQUFVdUUsb0JBQW9CLENBQUNMLElBQUksQ0FBQyxvQkFBb0I7NEJBQ3pFTSxlQUFleEUsVUFBVXlFLGNBQWMsQ0FBQ1AsSUFBSSxDQUFDLGtCQUFrQjs0QkFDL0RzQixjQUFjRixNQUFNLENBQUMsU0FBUzt3QkFDaEM7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT3JEO0lBQ1Q7SUFFQSxNQUFNYixnQkFBZ0JKLFFBQVEsRUFBRUMsT0FBTyxFQUFFYixTQUFTLEVBQUU7UUFDbERDLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBK0IsT0FBVFU7UUFFbEMsSUFBSTtnQkFJaUJ5RTtZQUhuQixNQUFNQSxTQUFTckYsVUFBVU8sS0FBSyxDQUFDTTtZQUMvQixNQUFNeUUsV0FBVzVGLEtBQUs2RixRQUFRLENBQUMzRSxVQUFVO1lBRXpDLE1BQU00RSxhQUFhSCxFQUFBQSxpQkFBQUEsT0FBT0osTUFBTSxjQUFiSSxxQ0FBQUEsZUFBZUosTUFBTSxLQUFJSSxPQUFPSixNQUFNLElBQUlJO1lBRTdELElBQUlBLE9BQU9KLE1BQU0sRUFBRTtnQkFDakJoRixRQUFRQyxHQUFHLENBQUMsd0JBQXdCQyxPQUFPQyxJQUFJLENBQUNpRixPQUFPSixNQUFNO2dCQUM3RCxJQUFJSSxPQUFPSixNQUFNLENBQUNBLE1BQU0sRUFBRTtvQkFDeEJoRixRQUFRQyxHQUFHLENBQUMsdUJBQXVCQyxPQUFPQyxJQUFJLENBQUNpRixPQUFPSixNQUFNLENBQUNBLE1BQU07Z0JBQ3JFO1lBQ0Y7WUFFQSxJQUFJTyxXQUFXOUIsSUFBSSxFQUFFO2dCQUNuQixNQUFNN0IsUUFBUThCLE1BQU1DLE9BQU8sQ0FBQzRCLFdBQVc5QixJQUFJLElBQUk4QixXQUFXOUIsSUFBSSxHQUFHO29CQUFDOEIsV0FBVzlCLElBQUk7aUJBQUM7Z0JBQ2xGekQsUUFBUUMsR0FBRyxDQUFDLFNBQXNCLE9BQWIyQixNQUFNeEIsTUFBTSxFQUFDO2dCQUNsQ3dCLE1BQU1nQyxPQUFPLENBQUMsQ0FBQ0MsTUFBTTJCO29CQUNuQnhGLFFBQVFDLEdBQUcsQ0FBQyxRQUFjLE9BQU51RixPQUFNLFdBQVN0RixPQUFPQyxJQUFJLENBQUMwRDtvQkFFL0MsZ0NBQWdDO29CQUNoQzNELE9BQU9DLElBQUksQ0FBQzBELE1BQU1ELE9BQU8sQ0FBQzZCLENBQUFBO3dCQUN4QixJQUFJQSxRQUFRLFlBQVlBLFFBQVEsWUFBWUEsUUFBUSx1QkFBdUJBLFFBQVEscUJBQXFCQSxRQUFRLG1CQUFtQjs0QkFDakksTUFBTUMsUUFBUTdCLElBQUksQ0FBQzRCLElBQUk7NEJBQ3ZCLElBQUkvQixNQUFNQyxPQUFPLENBQUMrQixRQUFRO2dDQUN4QjFGLFFBQVFDLEdBQUcsQ0FBQyxpQkFBNkJ5RixPQUFaRCxLQUFJLFVBQXFCLE9BQWJDLE1BQU10RixNQUFNLEVBQUM7NEJBQ3hELE9BQU8sSUFBSSxPQUFPc0YsVUFBVSxVQUFVO2dDQUNwQzFGLFFBQVFDLEdBQUcsQ0FBQyxrQkFBc0IsT0FBSndGLEtBQUksTUFBSXZGLE9BQU9DLElBQUksQ0FBQ3VGOzRCQUNwRDt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGLE9BQU87Z0JBQ0wxRixRQUFRQyxHQUFHLENBQUM7WUFDZDtZQUVBLHNDQUFzQztZQUN0Q0MsT0FBT0MsSUFBSSxDQUFDb0YsWUFBWTNCLE9BQU8sQ0FBQzZCLENBQUFBO2dCQUM5QixJQUFJQSxJQUFJRSxRQUFRLENBQUMsWUFBWUYsSUFBSUUsUUFBUSxDQUFDLGdCQUFnQkYsSUFBSUUsUUFBUSxDQUFDLFdBQVdGLElBQUlFLFFBQVEsQ0FBQyxZQUFZRixJQUFJRSxRQUFRLENBQUMsU0FBUztvQkFDL0gzRixRQUFRQyxHQUFHLENBQUMsZ0RBQW9ELE9BQUp3RixNQUFPL0IsTUFBTUMsT0FBTyxDQUFDNEIsVUFBVSxDQUFDRSxJQUFJLElBQUlGLFVBQVUsQ0FBQ0UsSUFBSSxDQUFDckYsTUFBTSxHQUFHO2dCQUMvSDtZQUNGO1lBRUEsc0NBQXNDO1lBQ3RDLE1BQU13RixpQkFBaUI7Z0JBQ3JCekUsTUFBTW9FLFVBQVUsQ0FBQyxTQUFTO2dCQUMxQk0sbUJBQW1CTixVQUFVLENBQUMsc0JBQXNCLElBQUk7Z0JBQ3hETyxpQkFBaUIxRCxXQUFXbUQsVUFBVSxDQUFDLG9CQUFvQixLQUFLO2dCQUNoRVEsa0JBQWtCUixVQUFVLENBQUMscUJBQXFCLEtBQUs7Z0JBRXZELHdCQUF3QjtnQkFDeEIzRCxPQUFPLElBQUksQ0FBQ29FLGFBQWEsQ0FBQ0Msa0JBQWtCLENBQUNWO2dCQUU3Qyx5REFBeUQ7Z0JBQ3pEVyxXQUFXLElBQUksQ0FBQ0YsYUFBYSxDQUFDRyxnQkFBZ0IsQ0FBQ1o7WUFDakQ7WUFFQSxJQUFJLENBQUMvQixPQUFPLENBQUM2QixTQUFTLEdBQUdPO1lBQ3pCNUYsUUFBUUMsR0FBRyxDQUFDLFlBQW9DMkYsT0FBeEJQLFVBQVMsaUJBQStDLE9BQWhDTyxlQUFlTSxTQUFTLENBQUM5RixNQUFNLEVBQUM7UUFFbEYsRUFBRSxPQUFPTSxPQUFPO1lBQ2RWLFFBQVFVLEtBQUssQ0FBQywwQkFBbUMsT0FBVEMsVUFBUyxNQUFJRCxNQUFNMEYsT0FBTztRQUNwRTtJQUNGO0lBRUEsTUFBTXBGLHNCQUFzQkwsUUFBUSxFQUFFQyxPQUFPLEVBQUViLFNBQVMsRUFBRTtRQUN4REMsUUFBUUMsR0FBRyxDQUFDLHVDQUFzQyxPQUFUVTtRQUV6QyxJQUFJO2dCQUlpQnlFO1lBSG5CLE1BQU1BLFNBQVNyRixVQUFVTyxLQUFLLENBQUNNO1lBQy9CLE1BQU15RixXQUFXNUcsS0FBSzZGLFFBQVEsQ0FBQzNFLFVBQVU7WUFFekMsTUFBTTJGLGFBQWFsQixFQUFBQSx1QkFBQUEsT0FBT21CLFlBQVksY0FBbkJuQiwyQ0FBQUEscUJBQXFCbUIsWUFBWSxLQUFJbkIsT0FBT21CLFlBQVksSUFBSW5CO1lBRS9FcEYsUUFBUUMsR0FBRyxDQUFDLDhCQUE4QkMsT0FBT0MsSUFBSSxDQUFDaUY7WUFDdEQsSUFBSUEsT0FBT21CLFlBQVksRUFBRTtnQkFDdkJ2RyxRQUFRQyxHQUFHLENBQUMsOEJBQThCQyxPQUFPQyxJQUFJLENBQUNpRixPQUFPbUIsWUFBWTtnQkFDekUsSUFBSW5CLE9BQU9tQixZQUFZLENBQUNBLFlBQVksRUFBRTtvQkFDcEN2RyxRQUFRQyxHQUFHLENBQUMsOEJBQThCQyxPQUFPQyxJQUFJLENBQUNpRixPQUFPbUIsWUFBWSxDQUFDQSxZQUFZO2dCQUN4RjtZQUNGO1lBRUEsNkNBQTZDO1lBQzdDLE1BQU1DLGlCQUFpQjtnQkFDckJyRixNQUFNbUYsVUFBVSxDQUFDLFNBQVM7Z0JBQzFCdkMsTUFBTXVDLFVBQVUsQ0FBQyxTQUFTLElBQUk7Z0JBQzlCRyxZQUFZSCxVQUFVLENBQUMsZUFBZSxJQUFJO2dCQUMxQ0ksU0FBU0osVUFBVSxDQUFDLFlBQVksSUFBSTtnQkFDcENuQyxlQUFleEUsVUFBVXlFLGNBQWMsQ0FBQ2tDLFVBQVUsQ0FBQyxrQkFBa0I7Z0JBRXJFLHVCQUF1QjtnQkFDdkIxRSxPQUFPLElBQUksQ0FBQ29FLGFBQWEsQ0FBQ1csa0JBQWtCLENBQUNMO2dCQUU3Qyw0QkFBNEI7Z0JBQzVCSixXQUFXLElBQUksQ0FBQ0YsYUFBYSxDQUFDRyxnQkFBZ0IsQ0FBQ0c7WUFDakQ7WUFFQSxJQUFJLENBQUNNLGFBQWEsQ0FBQ1AsU0FBUyxHQUFHRztZQUMvQnhHLFFBQVFDLEdBQUcsQ0FBQyxtQkFBMkN1RyxPQUF4QkgsVUFBUyxpQkFBK0MsT0FBaENHLGVBQWVOLFNBQVMsQ0FBQzlGLE1BQU0sRUFBQztRQUV6RixFQUFFLE9BQU9NLE9BQU87WUFDZFYsUUFBUVUsS0FBSyxDQUFDLGlDQUEwQyxPQUFUQyxVQUFTLE1BQUlELE1BQU0wRixPQUFPO1FBQzNFO0lBQ0Y7SUFFQSxNQUFNUyw2QkFBNkI7UUFDakM3RyxRQUFRQyxHQUFHLENBQUM7UUFFWixJQUFJLENBQUM2RyxRQUFRLEdBQUc7WUFDZEMsWUFBWSxJQUFJLENBQUNDLHVCQUF1QjtZQUN4Q0MsU0FBUyxJQUFJLENBQUNDLGdCQUFnQjtZQUM5QkMsUUFBUSxJQUFJLENBQUNDLGVBQWU7WUFDNUJDLFFBQVEsSUFBSSxDQUFDQyxhQUFhO1lBQzFCQyxPQUFPLElBQUksQ0FBQ0MsWUFBWTtRQUMxQjtRQUVBLElBQUksQ0FBQ3hCLGFBQWEsQ0FBQ3lCLDZCQUE2QixJQUFJLHdCQUF3QjtRQUU1RXpILFFBQVFDLEdBQUcsQ0FBQztJQUNkO0lBRUErRywwQkFBMEI7WUFtQlAsZ0NBTVI7UUF4QlQsMkRBQTJEO1FBQzNELElBQUksSUFBSSxDQUFDeEQsT0FBTyxJQUFJdEQsT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQ3FELE9BQU8sRUFBRXBELE1BQU0sR0FBRyxHQUFHO1lBQ3hELE1BQU1zSCxjQUFjeEgsT0FBT3lILE1BQU0sQ0FBQyxJQUFJLENBQUNuRSxPQUFPLENBQUMsQ0FBQyxFQUFFO1lBQ2xELElBQUlrRSxZQUFZOUYsS0FBSyxJQUFJOEYsWUFBWTlGLEtBQUssQ0FBQ3hCLE1BQU0sR0FBRyxHQUFHO2dCQUNyRCxNQUFNd0gsWUFBWUYsWUFBWTlGLEtBQUssQ0FBQyxFQUFFO2dCQUN0QyxJQUFJZ0csVUFBVTNELGVBQWUsRUFBRTtvQkFDN0IsTUFBTTRELFNBQVNELFVBQVUzRCxlQUFlO29CQUN4QyxPQUFPO3dCQUNMNkQsT0FBT0QsT0FBT0MsS0FBSyxJQUFJRCxPQUFPckYsS0FBSyxHQUFHcUYsT0FBT3ZGLElBQUksSUFBSTt3QkFDckR5RixRQUFRRixPQUFPRSxNQUFNLElBQUlGLE9BQU9wRixNQUFNLEdBQUdvRixPQUFPdEYsR0FBRyxJQUFJO3dCQUN2RE0sYUFBYTNDLE9BQU95SCxNQUFNLENBQUMsSUFBSSxDQUFDbkUsT0FBTyxFQUFFd0UsSUFBSSxDQUFDL0MsQ0FBQUEsU0FBVUEsT0FBT3JELEtBQUssSUFBSXFELE9BQU9yRCxLQUFLLENBQUN4QixNQUFNLEdBQUc7d0JBQzlGNkgsT0FBTztvQkFDVDtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxtQ0FBbUM7UUFDbkMsTUFBTUMsV0FBVyx1Q0FBSSxDQUFDakgsWUFBWSxDQUFDa0gsV0FBVyxjQUE3QixvRkFBK0I3RyxtQkFBbUIsS0FBSSxDQUFDO1FBRXhFLE9BQU87WUFDTHdHLE9BQU9JLFNBQVMvRixTQUFTLElBQUk7WUFDN0I0RixRQUFRRyxTQUFTN0YsVUFBVSxJQUFJO1lBQy9CUSxhQUFhcUYsU0FBU3JGLFdBQVcsSUFBSTtZQUNyQ29GLE9BQU8sd0NBQUksQ0FBQ2hILFlBQVksQ0FBQ2tILFdBQVcsY0FBN0Isd0lBQStCQyxlQUFlLGNBQTlDLG9IQUFnREMsMEJBQTBCLEtBQUk7UUFDdkY7SUFDRjtJQUVBbkIsbUJBQW1CO1lBNkJHO1FBNUJwQmxILFFBQVFDLEdBQUcsQ0FBQztRQUVaLDZEQUE2RDtRQUM3RCxJQUFJLElBQUksQ0FBQzJHLGFBQWEsSUFBSTFHLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUN5RyxhQUFhLEVBQUV4RyxNQUFNLEdBQUcsR0FBRztZQUNwRSxNQUFNa0ksY0FBY3BJLE9BQU95SCxNQUFNLENBQUMsSUFBSSxDQUFDZixhQUFhLENBQUMsQ0FBQyxFQUFFO1lBQ3hELElBQUkwQixZQUFZMUcsS0FBSyxJQUFJMEcsWUFBWTFHLEtBQUssQ0FBQ3hCLE1BQU0sR0FBRyxHQUFHO2dCQUNyRCxNQUFNbUksa0JBQWtCRCxZQUFZMUcsS0FBSyxDQUFDLEVBQUU7Z0JBRTVDLDZDQUE2QztnQkFDN0MsK0RBQStEO2dCQUMvRCxJQUFJMkcsZ0JBQWdCdkYsZ0JBQWdCLEVBQUU7b0JBQ3BDLE1BQU13RixnQkFBZ0I7d0JBQ3BCakcsS0FBS2dHLGdCQUFnQnZGLGdCQUFnQixDQUFDVCxHQUFHLElBQUk7d0JBQzdDRSxRQUFROEYsZ0JBQWdCdkYsZ0JBQWdCLENBQUNQLE1BQU0sSUFBSTt3QkFDbkRILE1BQU1pRyxnQkFBZ0J2RixnQkFBZ0IsQ0FBQ1YsSUFBSSxJQUFJO3dCQUMvQ0UsT0FBTytGLGdCQUFnQnZGLGdCQUFnQixDQUFDUixLQUFLLElBQUk7d0JBQ2pERSxhQUFhNkYsZ0JBQWdCdkYsZ0JBQWdCLENBQUNOLFdBQVcsSUFBSTt3QkFDN0RFLGNBQWMyRixnQkFBZ0J2RixnQkFBZ0IsQ0FBQ0osWUFBWSxJQUFJO29CQUNqRTtvQkFFQTVDLFFBQVFDLEdBQUcsQ0FBQyxnREFBc0N1STtvQkFDbEQsT0FBT0E7Z0JBQ1Q7WUFDRjtRQUNGO1FBRUEsbUNBQW1DO1FBQ25DLE1BQU1OLFdBQVcsSUFBSSxDQUFDakgsWUFBWSxDQUFDSyxtQkFBbUIsSUFBSSxDQUFDO1FBQzNELE1BQU1tSCxjQUFjLHVDQUFJLENBQUN4SCxZQUFZLENBQUNrSCxXQUFXLGNBQTdCLG9GQUErQk8saUJBQWlCLEtBQUksQ0FBQztRQUV6RSwyREFBMkQ7UUFDM0QsTUFBTXpCLFVBQVU7WUFDZDFFLEtBQUtrRyxZQUFZbEcsR0FBRyxJQUFJMkYsU0FBU2pGLFNBQVMsSUFBSWlGLFNBQVMzRixHQUFHLElBQUk7WUFDOURFLFFBQVFnRyxZQUFZaEcsTUFBTSxJQUFJeUYsU0FBU2hGLFlBQVksSUFBSWdGLFNBQVN6RixNQUFNLElBQUk7WUFDMUVILE1BQU1tRyxZQUFZbkcsSUFBSSxJQUFJNEYsU0FBUy9FLFVBQVUsSUFBSStFLFNBQVM1RixJQUFJLElBQUk7WUFDbEVFLE9BQU9pRyxZQUFZakcsS0FBSyxJQUFJMEYsU0FBUzlFLFdBQVcsSUFBSThFLFNBQVMxRixLQUFLLElBQUk7WUFDdEVFLGFBQWErRixZQUFZL0YsV0FBVyxJQUFJd0YsU0FBUzdFLGlCQUFpQixJQUFJNkUsU0FBU3hGLFdBQVcsSUFBSTtZQUM5RkUsY0FBYzZGLFlBQVk3RixZQUFZLElBQUlzRixTQUFTNUUsa0JBQWtCLElBQUk0RSxTQUFTdEYsWUFBWSxJQUFJO1FBQ3BHO1FBRUE1QyxRQUFRQyxHQUFHLENBQUMsK0NBQXFDZ0g7UUFDakQsT0FBT0E7SUFDVDtJQUVBRyxrQkFBa0I7WUFDQztRQUFqQixNQUFNYyxXQUFXLHVDQUFJLENBQUNqSCxZQUFZLENBQUNrSCxXQUFXLGNBQTdCLG9GQUErQjdHLG1CQUFtQixLQUFJLENBQUM7UUFFeEUsT0FBTztZQUNMaUIsS0FBSzJGLFNBQVNTLHNCQUFzQixJQUFJO1lBQ3hDbEcsUUFBUXlGLFNBQVNVLHlCQUF5QixJQUFJO1lBQzlDQyxRQUFRWCxTQUFTWSwrQkFBK0IsSUFBSTtZQUNwREMsU0FBU2IsU0FBU2MsaUNBQWlDLElBQUk7UUFDekQ7SUFDRjtJQUVBMUIsZ0JBQWdCO1FBQ2QsTUFBTUQsU0FBUyxFQUFFO1FBRWpCLDhCQUE4QjtRQUM5Qm5ILE9BQU95SCxNQUFNLENBQUMsSUFBSSxDQUFDbkUsT0FBTyxFQUFFSSxPQUFPLENBQUNxQixDQUFBQTtZQUNsQyxJQUFJQSxPQUFPaUIsU0FBUyxFQUFFO2dCQUNwQmpCLE9BQU9pQixTQUFTLENBQUN0QyxPQUFPLENBQUNxRixDQUFBQTtvQkFDdkIsSUFBSUEsS0FBS0MsSUFBSSxLQUFLLFNBQVM7d0JBQ3pCN0IsT0FBT3ZELElBQUksQ0FBQzs0QkFDVnFGLGFBQWFGLEtBQUtFLFdBQVcsSUFBSTs0QkFDakNDLFVBQVVILEtBQUtHLFFBQVEsSUFBSTs0QkFDM0JDLFdBQVdKLEtBQUtJLFNBQVMsSUFBSTs0QkFDN0JDLGVBQWVMLEtBQUtLLGFBQWEsSUFBSTt3QkFDdkM7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT2pDO0lBQ1Q7SUFFQUcsZUFBZTtZQUNLO1FBQWxCLE1BQU0rQixZQUFZLHVDQUFJLENBQUN0SSxZQUFZLENBQUNrSCxXQUFXLGNBQTdCLG9GQUErQnFCLGVBQWUsS0FBSSxDQUFDO1FBRXJFLE9BQU87WUFDTEMsVUFBVTtnQkFDUkMsT0FBT0gsVUFBVUksYUFBYSxJQUFJO2dCQUNsQ0MsVUFBVUwsVUFBVU0sZ0JBQWdCLElBQUk7Z0JBQ3hDQyxPQUFPUCxVQUFVUSxhQUFhLElBQUk7Z0JBQ2xDQyxRQUFRVCxVQUFVVSxjQUFjLElBQUk7WUFDdEM7WUFDQTFKLFVBQVU7Z0JBQ1J1SixPQUFPUCxVQUFVVyxpQkFBaUIsSUFBSTtnQkFDdENGLFFBQVFULFVBQVVZLGtCQUFrQixJQUFJO1lBQzFDO1FBQ0Y7SUFDRjtJQUVBLHFDQUFxQztJQUNyQ0MsZUFBZUMsTUFBTSxFQUFFO1FBQ3JCLE9BQU8sSUFBSSxDQUFDckUsYUFBYSxDQUFDb0UsY0FBYyxDQUFDQztJQUMzQztJQUVBQyxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUMvSixRQUFRO0lBQ3RCO0lBRUFnSyxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUMvRyxPQUFPO0lBQ3JCO0lBRUFnSCxtQkFBbUI7UUFDakIsT0FBTyxJQUFJLENBQUM1RCxhQUFhO0lBQzNCO0lBRUE2RCxrQkFBa0I7UUFDaEIsT0FBTyxJQUFJLENBQUN4SixZQUFZO0lBQzFCO0lBRUF5SixjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUM1RCxRQUFRO0lBQ3RCO0lBRUE2RCxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUNqSixNQUFNO0lBQ3BCO0lBRUFrSiw0QkFBNEI7UUFDMUIsT0FBT2pMLFVBQVVpTCx5QkFBeUIsQ0FBQyxJQUFJLENBQUM1RSxhQUFhLENBQUM2RSxXQUFXO0lBQzNFO0lBcmZBQyxZQUFZOUUsYUFBYSxDQUFFO1FBQ3pCLElBQUksQ0FBQ0EsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUN6RixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDaUQsT0FBTyxHQUFHLENBQUM7UUFDaEIsSUFBSSxDQUFDb0QsYUFBYSxHQUFHLENBQUM7UUFDdEIsSUFBSSxDQUFDM0YsWUFBWSxHQUFHLENBQUM7UUFDckIsSUFBSSxDQUFDNkYsUUFBUSxHQUFHLENBQUM7UUFDakIsSUFBSSxDQUFDcEYsTUFBTSxHQUFHLEVBQUU7SUFDbEI7QUE4ZUY7QUFFQXFKLE9BQU9DLE9BQU8sR0FBR3BMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9wYXJzZXJzL0RvY3VtZW50UGFyc2VyLmpzPzk0MWEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3QgSURNTFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvSURNTFV0aWxzJyk7XHJcblxyXG5jbGFzcyBEb2N1bWVudFBhcnNlciB7XHJcbiAgY29uc3RydWN0b3IoZWxlbWVudFBhcnNlcikge1xyXG4gICAgdGhpcy5lbGVtZW50UGFyc2VyID0gZWxlbWVudFBhcnNlcjtcclxuICAgIHRoaXMuZG9jdW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5zcHJlYWRzID0ge307XHJcbiAgICB0aGlzLm1hc3RlclNwcmVhZHMgPSB7fTtcclxuICAgIHRoaXMuZG9jdW1lbnRJbmZvID0ge307XHJcbiAgICB0aGlzLnBhZ2VJbmZvID0ge307XHJcbiAgICB0aGlzLmxheWVycyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcGFyc2VEb2N1bWVudFN0cnVjdHVyZShleHRyYWN0ZWREYXRhLCB4bWxQYXJzZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKCdQYXJzaW5nIGRvY3VtZW50IHN0cnVjdHVyZS4uLicpO1xyXG4gICAgY29uc29sZS5sb2coJ/CflI0gVG90YWwgZmlsZXMgdG8gcHJvY2VzczonLCBPYmplY3Qua2V5cyhleHRyYWN0ZWREYXRhKS5sZW5ndGgpO1xyXG4gICAgXHJcbiAgICAvLyBQYXJzZSBkZXNpZ25tYXAueG1sIGZpcnN0IChtYWluIGRvY3VtZW50IHN0cnVjdHVyZSlcclxuICAgIGlmIChleHRyYWN0ZWREYXRhWydkZXNpZ25tYXAueG1sJ10pIHtcclxuICAgICAgY29uc29sZS5sb2coJ1BhcnNpbmcgZGVzaWdubWFwLnhtbC4uLicpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRlc2lnbk1hcERhdGEgPSB4bWxQYXJzZXIucGFyc2UoZXh0cmFjdGVkRGF0YVsnZGVzaWdubWFwLnhtbCddKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZGVzaWduTWFwRGF0YS5Eb2N1bWVudCB8fCBkZXNpZ25NYXBEYXRhO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdERvY3VtZW50SW5mbyh0aGlzLmRvY3VtZW50KTtcclxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIERlc2lnbk1hcCBwYXJzZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBkZXNpZ25tYXAueG1sOicsIGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBQYXJzZSBTcHJlYWRzXHJcbiAgICBjb25zb2xlLmxvZygnXFxu8J+ThCA9PT0gUEFSU0lORyBTUFJFQURTID09PScpO1xyXG4gICAgZm9yIChjb25zdCBbZmlsZU5hbWUsIGNvbnRlbnRdIG9mIE9iamVjdC5lbnRyaWVzKGV4dHJhY3RlZERhdGEpKSB7XHJcbiAgICAgIGlmIChmaWxlTmFtZS5zdGFydHNXaXRoKCdTcHJlYWRzLycpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gUHJvY2Vzc2luZyBzcHJlYWQ6JywgZmlsZU5hbWUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucGFyc2VTcHJlYWRGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFBhcnNlIE1hc3RlciBTcHJlYWRzXHJcbiAgICBjb25zb2xlLmxvZygnXFxu8J+OqCA9PT0gUEFSU0lORyBNQVNURVIgU1BSRUFEUyA9PT0nKTtcclxuICAgIGZvciAoY29uc3QgW2ZpbGVOYW1lLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhleHRyYWN0ZWREYXRhKSkge1xyXG4gICAgICBpZiAoZmlsZU5hbWUuc3RhcnRzV2l0aCgnTWFzdGVyU3ByZWFkcy8nKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFByb2Nlc3NpbmcgbWFzdGVyIHNwcmVhZDonLCBmaWxlTmFtZSk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXJzZU1hc3RlclNwcmVhZEZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3REb2N1bWVudEluZm8oZG9jdW1lbnQpIHtcclxuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0aW5nIGRvY3VtZW50IGluZm9ybWF0aW9uLi4uJyk7XHJcbiAgICBcclxuICAgIGlmICghZG9jdW1lbnQpIHJldHVybjtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBkb2N1bWVudCBwcmVmZXJlbmNlcyBhbmQgcGFnZSBzZXR1cFxyXG4gICAgdGhpcy5kb2N1bWVudEluZm8gPSB7XHJcbiAgICAgIHZlcnNpb246IGRvY3VtZW50WydAX0RPTVZlcnNpb24nXSB8fCAnVW5rbm93bicsXHJcbiAgICAgIHNlbGY6IGRvY3VtZW50WydAX1NlbGYnXSB8fCAnVW5rbm93bicsXHJcbiAgICAgIGFjdGl2ZUxheWVyOiBkb2N1bWVudFsnQF9BY3RpdmVMYXllciddIHx8IG51bGwsXHJcbiAgICAgIHVudXNlZFN3YXRjaGVzOiBkb2N1bWVudFsnQF9VbnVzZWRTd2F0Y2hlcyddIHx8IFtdLFxyXG4gICAgICBcclxuICAgICAgLy8gRG9jdW1lbnQgcHJlZmVyZW5jZXNcclxuICAgICAgZG9jdW1lbnRQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0RG9jdW1lbnRQcmVmZXJlbmNlcyhkb2N1bWVudCksXHJcbiAgICAgIFxyXG4gICAgICAvLyBQYWdlIHNldHVwXHJcbiAgICAgIHBhZ2VTZXR1cDogdGhpcy5leHRyYWN0UGFnZVNldHVwKGRvY3VtZW50KSxcclxuICAgICAgXHJcbiAgICAgIC8vIExheWVyc1xyXG4gICAgICBsYXllcnM6IHRoaXMuZXh0cmFjdExheWVycyhkb2N1bWVudCksXHJcbiAgICAgIFxyXG4gICAgICAvLyBQYWdlc1xyXG4gICAgICBwYWdlczogdGhpcy5leHRyYWN0UGFnZXMoZG9jdW1lbnQpXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygn4pyFIERvY3VtZW50IGluZm8gZXh0cmFjdGVkJyk7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0RG9jdW1lbnRQcmVmZXJlbmNlcyhkb2N1bWVudCkge1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk4sgRXh0cmFjdGluZyBkb2N1bWVudCBwcmVmZXJlbmNlcy4uLicpO1xyXG4gICAgY29uc29sZS5sb2coJ0RvY3VtZW50IGtleXM6JywgT2JqZWN0LmtleXMoZG9jdW1lbnQpKTtcclxuICAgIFxyXG4gICAgY29uc3QgcHJlZnMgPSB7fTtcclxuICAgIFxyXG4gICAgLy8gVHJ5IG11bHRpcGxlIHBvc3NpYmxlIGxvY2F0aW9ucyBmb3IgZG9jdW1lbnQgcHJlZmVyZW5jZXNcclxuICAgIGxldCBkb2NQcmVmID0gbnVsbDtcclxuICAgIFxyXG4gICAgaWYgKGRvY3VtZW50LkRvY3VtZW50UHJlZmVyZW5jZSkge1xyXG4gICAgICBkb2NQcmVmID0gZG9jdW1lbnQuRG9jdW1lbnRQcmVmZXJlbmNlO1xyXG4gICAgICBjb25zb2xlLmxvZygnRm91bmQgRG9jdW1lbnRQcmVmZXJlbmNlJyk7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmRvY3VtZW50UHJlZmVyZW5jZSkge1xyXG4gICAgICBkb2NQcmVmID0gZG9jdW1lbnQuZG9jdW1lbnRQcmVmZXJlbmNlO1xyXG4gICAgICBjb25zb2xlLmxvZygnRm91bmQgZG9jdW1lbnRQcmVmZXJlbmNlIChsb3dlcmNhc2UpJyk7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LlByb3BlcnRpZXMgJiYgZG9jdW1lbnQuUHJvcGVydGllcy5Eb2N1bWVudFByZWZlcmVuY2UpIHtcclxuICAgICAgZG9jUHJlZiA9IGRvY3VtZW50LlByb3BlcnRpZXMuRG9jdW1lbnRQcmVmZXJlbmNlO1xyXG4gICAgICBjb25zb2xlLmxvZygnRm91bmQgRG9jdW1lbnRQcmVmZXJlbmNlIGluIFByb3BlcnRpZXMnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKGRvY1ByZWYpIHtcclxuICAgICAgY29uc29sZS5sb2coJ0RvY3VtZW50UHJlZmVyZW5jZSBrZXlzOicsIE9iamVjdC5rZXlzKGRvY1ByZWYpKTtcclxuICAgICAgcHJlZnMucGFnZVdpZHRoID0gcGFyc2VGbG9hdChkb2NQcmVmWydAX1BhZ2VXaWR0aCddKSB8fCAwO1xyXG4gICAgICBwcmVmcy5wYWdlSGVpZ2h0ID0gcGFyc2VGbG9hdChkb2NQcmVmWydAX1BhZ2VIZWlnaHQnXSkgfHwgMDtcclxuICAgICAgcHJlZnMubGVmdCA9IHBhcnNlRmxvYXQoZG9jUHJlZlsnQF9MZWZ0J10pIHx8IDA7XHJcbiAgICAgIHByZWZzLnRvcCA9IHBhcnNlRmxvYXQoZG9jUHJlZlsnQF9Ub3AnXSkgfHwgMDtcclxuICAgICAgcHJlZnMucmlnaHQgPSBwYXJzZUZsb2F0KGRvY1ByZWZbJ0BfUmlnaHQnXSkgfHwgMDtcclxuICAgICAgcHJlZnMuYm90dG9tID0gcGFyc2VGbG9hdChkb2NQcmVmWydAX0JvdHRvbSddKSB8fCAwO1xyXG4gICAgICBwcmVmcy5jb2x1bW5Db3VudCA9IHBhcnNlSW50KGRvY1ByZWZbJ0BfQ29sdW1uQ291bnQnXSkgfHwgMTtcclxuICAgICAgcHJlZnMuY29sdW1uR3V0dGVyID0gcGFyc2VGbG9hdChkb2NQcmVmWydAX0NvbHVtbkd1dHRlciddKSB8fCAwO1xyXG4gICAgICBwcmVmcy5mYWNpbmdQYWdlcyA9IGRvY1ByZWZbJ0BfRmFjaW5nUGFnZXMnXSA9PT0gJ3RydWUnIHx8IGRvY1ByZWZbJ0BfRmFjaW5nUGFnZXMnXSA9PT0gdHJ1ZTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEV4dHJhY3RlZCBkb2N1bWVudCBwcmVmZXJlbmNlczonLCBwcmVmcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZygn4pqg77iPIE5vIERvY3VtZW50UHJlZmVyZW5jZSBmb3VuZCBpbiBkb2N1bWVudCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBbHNvIHRyeSB0byBleHRyYWN0IG1hcmdpbiBwcmVmZXJlbmNlc1xyXG4gICAgbGV0IG1hcmdpblByZWYgPSBudWxsO1xyXG4gICAgaWYgKGRvY3VtZW50Lk1hcmdpblByZWZlcmVuY2UpIHtcclxuICAgICAgbWFyZ2luUHJlZiA9IGRvY3VtZW50Lk1hcmdpblByZWZlcmVuY2U7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBNYXJnaW5QcmVmZXJlbmNlJyk7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1hcmdpblByZWZlcmVuY2UpIHtcclxuICAgICAgbWFyZ2luUHJlZiA9IGRvY3VtZW50Lm1hcmdpblByZWZlcmVuY2U7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBtYXJnaW5QcmVmZXJlbmNlIChsb3dlcmNhc2UpJyk7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LlByb3BlcnRpZXMgJiYgZG9jdW1lbnQuUHJvcGVydGllcy5NYXJnaW5QcmVmZXJlbmNlKSB7XHJcbiAgICAgIG1hcmdpblByZWYgPSBkb2N1bWVudC5Qcm9wZXJ0aWVzLk1hcmdpblByZWZlcmVuY2U7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBNYXJnaW5QcmVmZXJlbmNlIGluIFByb3BlcnRpZXMnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKG1hcmdpblByZWYpIHtcclxuICAgICAgY29uc29sZS5sb2coJ01hcmdpblByZWZlcmVuY2Uga2V5czonLCBPYmplY3Qua2V5cyhtYXJnaW5QcmVmKSk7XHJcbiAgICAgIHByZWZzLm1hcmdpblRvcCA9IHBhcnNlRmxvYXQobWFyZ2luUHJlZlsnQF9Ub3AnXSkgfHwgMDtcclxuICAgICAgcHJlZnMubWFyZ2luQm90dG9tID0gcGFyc2VGbG9hdChtYXJnaW5QcmVmWydAX0JvdHRvbSddKSB8fCAwO1xyXG4gICAgICBwcmVmcy5tYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChtYXJnaW5QcmVmWydAX0xlZnQnXSkgfHwgMDtcclxuICAgICAgcHJlZnMubWFyZ2luUmlnaHQgPSBwYXJzZUZsb2F0KG1hcmdpblByZWZbJ0BfUmlnaHQnXSkgfHwgMDtcclxuICAgICAgcHJlZnMubWFyZ2luQ29sdW1uQ291bnQgPSBwYXJzZUludChtYXJnaW5QcmVmWydAX0NvbHVtbkNvdW50J10pIHx8IDE7XHJcbiAgICAgIHByZWZzLm1hcmdpbkNvbHVtbkd1dHRlciA9IHBhcnNlRmxvYXQobWFyZ2luUHJlZlsnQF9Db2x1bW5HdXR0ZXInXSkgfHwgMDtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OPIEV4dHJhY3RlZCBtYXJnaW4gcHJlZmVyZW5jZXM6Jywge1xyXG4gICAgICAgIHRvcDogcHJlZnMubWFyZ2luVG9wLFxyXG4gICAgICAgIGJvdHRvbTogcHJlZnMubWFyZ2luQm90dG9tLFxyXG4gICAgICAgIGxlZnQ6IHByZWZzLm1hcmdpbkxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IHByZWZzLm1hcmdpblJpZ2h0LFxyXG4gICAgICAgIGNvbHVtbkNvdW50OiBwcmVmcy5tYXJnaW5Db2x1bW5Db3VudCxcclxuICAgICAgICBjb2x1bW5HdXR0ZXI6IHByZWZzLm1hcmdpbkNvbHVtbkd1dHRlclxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHByZWZzO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBhZ2VTZXR1cChkb2N1bWVudCkge1xyXG4gICAgY29uc3QgcGFnZVNldHVwID0ge1xyXG4gICAgICBwYWdlczogW10sXHJcbiAgICAgIG1hc3RlclBhZ2VzOiBbXSxcclxuICAgICAgc3ByZWFkczogW11cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgcGFnZSBpbmZvcm1hdGlvbiBmcm9tIGRvY3VtZW50XHJcbiAgICBpZiAoZG9jdW1lbnQuUGFnZSkge1xyXG4gICAgICBjb25zdCBwYWdlcyA9IEFycmF5LmlzQXJyYXkoZG9jdW1lbnQuUGFnZSkgPyBkb2N1bWVudC5QYWdlIDogW2RvY3VtZW50LlBhZ2VdO1xyXG4gICAgICBcclxuICAgICAgcGFnZXMuZm9yRWFjaChwYWdlID0+IHtcclxuICAgICAgICBwYWdlU2V0dXAucGFnZXMucHVzaCh7XHJcbiAgICAgICAgICBzZWxmOiBwYWdlWydAX1NlbGYnXSxcclxuICAgICAgICAgIG5hbWU6IHBhZ2VbJ0BfTmFtZSddIHx8ICcnLFxyXG4gICAgICAgICAgYXBwbGllZE1hc3RlcjogcGFnZVsnQF9BcHBsaWVkTWFzdGVyJ10gfHwgJycsXHJcbiAgICAgICAgICBnZW9tZXRyaWNCb3VuZHM6IElETUxVdGlscy5wYXJzZUdlb21ldHJpY0JvdW5kcyhwYWdlWydAX0dlb21ldHJpY0JvdW5kcyddKSxcclxuICAgICAgICAgIGl0ZW1UcmFuc2Zvcm06IElETUxVdGlscy5wYXJzZVRyYW5zZm9ybShwYWdlWydAX0l0ZW1UcmFuc2Zvcm0nXSksXHJcbiAgICAgICAgICBvdmVycmlkZUxpc3Q6IHBhZ2VbJ0BfT3ZlcnJpZGVMaXN0J10gfHwgW11cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBwYWdlU2V0dXA7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0TGF5ZXJzKGRvY3VtZW50KSB7XHJcbiAgICBjb25zdCBsYXllcnMgPSBbXTtcclxuICAgIFxyXG4gICAgaWYgKGRvY3VtZW50LkxheWVyKSB7XHJcbiAgICAgIGNvbnN0IGxheWVyRGF0YSA9IEFycmF5LmlzQXJyYXkoZG9jdW1lbnQuTGF5ZXIpID8gZG9jdW1lbnQuTGF5ZXIgOiBbZG9jdW1lbnQuTGF5ZXJdO1xyXG4gICAgICBcclxuICAgICAgbGF5ZXJEYXRhLmZvckVhY2gobGF5ZXIgPT4ge1xyXG4gICAgICAgIGxheWVycy5wdXNoKHtcclxuICAgICAgICAgIHNlbGY6IGxheWVyWydAX1NlbGYnXSxcclxuICAgICAgICAgIG5hbWU6IGxheWVyWydAX05hbWUnXSB8fCAnJyxcclxuICAgICAgICAgIHZpc2libGU6IGxheWVyWydAX1Zpc2libGUnXSAhPT0gZmFsc2UsXHJcbiAgICAgICAgICBsb2NrZWQ6IGxheWVyWydAX0xvY2tlZCddID09PSB0cnVlLFxyXG4gICAgICAgICAgaWdub3JlV3JhcDogbGF5ZXJbJ0BfSWdub3JlV3JhcCddID09PSB0cnVlLFxyXG4gICAgICAgICAgc2hvd0d1aWRlczogbGF5ZXJbJ0BfU2hvd0d1aWRlcyddICE9PSBmYWxzZSxcclxuICAgICAgICAgIGxvY2tHdWlkZXM6IGxheWVyWydAX0xvY2tHdWlkZXMnXSA9PT0gdHJ1ZSxcclxuICAgICAgICAgIHVpOiBsYXllclsnQF9VSSddIHx8ICcnLFxyXG4gICAgICAgICAgbGF5ZXJDb2xvcjogbGF5ZXJbJ0BfTGF5ZXJDb2xvciddIHx8ICdMaWdodEJsdWUnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLmxheWVycyA9IGxheWVycztcclxuICAgIHJldHVybiBsYXllcnM7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0UGFnZXMoZG9jdW1lbnQpIHtcclxuICAgIGNvbnN0IHBhZ2VzID0gW107XHJcbiAgICBcclxuICAgIGlmIChkb2N1bWVudC5TcHJlYWQpIHtcclxuICAgICAgY29uc3Qgc3ByZWFkcyA9IEFycmF5LmlzQXJyYXkoZG9jdW1lbnQuU3ByZWFkKSA/IGRvY3VtZW50LlNwcmVhZCA6IFtkb2N1bWVudC5TcHJlYWRdO1xyXG4gICAgICBcclxuICAgICAgc3ByZWFkcy5mb3JFYWNoKHNwcmVhZCA9PiB7XHJcbiAgICAgICAgaWYgKHNwcmVhZC5QYWdlKSB7XHJcbiAgICAgICAgICBjb25zdCBzcHJlYWRQYWdlcyA9IEFycmF5LmlzQXJyYXkoc3ByZWFkLlBhZ2UpID8gc3ByZWFkLlBhZ2UgOiBbc3ByZWFkLlBhZ2VdO1xyXG4gICAgICAgICAgc3ByZWFkUGFnZXMuZm9yRWFjaChwYWdlID0+IHtcclxuICAgICAgICAgICAgcGFnZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgc2VsZjogcGFnZVsnQF9TZWxmJ10sXHJcbiAgICAgICAgICAgICAgbmFtZTogcGFnZVsnQF9OYW1lJ10gfHwgJycsXHJcbiAgICAgICAgICAgICAgYXBwbGllZE1hc3RlcjogcGFnZVsnQF9BcHBsaWVkTWFzdGVyJ10gfHwgJycsXHJcbiAgICAgICAgICAgICAgZ2VvbWV0cmljQm91bmRzOiBJRE1MVXRpbHMucGFyc2VHZW9tZXRyaWNCb3VuZHMocGFnZVsnQF9HZW9tZXRyaWNCb3VuZHMnXSksXHJcbiAgICAgICAgICAgICAgaXRlbVRyYW5zZm9ybTogSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKHBhZ2VbJ0BfSXRlbVRyYW5zZm9ybSddKSxcclxuICAgICAgICAgICAgICBzcHJlYWRQYXJlbnQ6IHNwcmVhZFsnQF9TZWxmJ11cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcGFnZXM7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwYXJzZVNwcmVhZEZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coYPCfk4QgUGFyc2luZyBzcHJlYWQ6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcclxuICAgICAgY29uc3Qgc3ByZWFkSWQgPSBwYXRoLmJhc2VuYW1lKGZpbGVOYW1lLCAnLnhtbCcpO1xyXG4gICAgICBcclxuICAgICAgY29uc3Qgc3ByZWFkRGF0YSA9IHBhcnNlZC5TcHJlYWQ/LlNwcmVhZCB8fCBwYXJzZWQuU3ByZWFkIHx8IHBhcnNlZDtcclxuXHJcbiAgICAgIGlmIChwYXJzZWQuU3ByZWFkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1NwcmVhZCB3cmFwcGVyIGtleXM6JywgT2JqZWN0LmtleXMocGFyc2VkLlNwcmVhZCkpO1xyXG4gICAgICAgIGlmIChwYXJzZWQuU3ByZWFkLlNwcmVhZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0FjdHVhbCBzcHJlYWQga2V5czonLCBPYmplY3Qua2V5cyhwYXJzZWQuU3ByZWFkLlNwcmVhZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNwcmVhZERhdGEuUGFnZSkge1xyXG4gICAgICAgIGNvbnN0IHBhZ2VzID0gQXJyYXkuaXNBcnJheShzcHJlYWREYXRhLlBhZ2UpID8gc3ByZWFkRGF0YS5QYWdlIDogW3NwcmVhZERhdGEuUGFnZV07XHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7cGFnZXMubGVuZ3RofSBwYWdlcyBpbiBzcHJlYWRgKTtcclxuICAgICAgICBwYWdlcy5mb3JFYWNoKChwYWdlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFBhZ2UgJHtpbmRleH0ga2V5czpgLCBPYmplY3Qua2V5cyhwYWdlKSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIExvb2sgZm9yIGVsZW1lbnRzIGluIHRoZSBwYWdlXHJcbiAgICAgICAgICBPYmplY3Qua2V5cyhwYWdlKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdAX1NlbGYnICYmIGtleSAhPT0gJ0BfTmFtZScgJiYga2V5ICE9PSAnQF9HZW9tZXRyaWNCb3VuZHMnICYmIGtleSAhPT0gJ0BfSXRlbVRyYW5zZm9ybScgJiYga2V5ICE9PSAnQF9BcHBsaWVkTWFzdGVyJykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFnZVtrZXldO1xyXG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgRm91bmQgYXJyYXkgJHtrZXl9IHdpdGggJHt2YWx1ZS5sZW5ndGh9IGl0ZW1zYCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBGb3VuZCBvYmplY3QgJHtrZXl9OmAsIE9iamVjdC5rZXlzKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTm8gUGFnZSBwcm9wZXJ0eSBmb3VuZCBpbiBzcHJlYWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIGRpcmVjdCBlbGVtZW50cyBpbiBzcHJlYWRcclxuICAgICAgT2JqZWN0LmtleXMoc3ByZWFkRGF0YSkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGlmIChrZXkuaW5jbHVkZXMoJ0ZyYW1lJykgfHwga2V5LmluY2x1ZGVzKCdSZWN0YW5nbGUnKSB8fCBrZXkuaW5jbHVkZXMoJ1RleHQnKSB8fCBrZXkuaW5jbHVkZXMoJ0dyb3VwJykgfHwga2V5LmluY2x1ZGVzKCdPdmFsJykpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBwb3RlbnRpYWwgZWxlbWVudHMgZGlyZWN0bHkgaW4gc3ByZWFkOiAke2tleX1gLCBBcnJheS5pc0FycmF5KHNwcmVhZERhdGFba2V5XSkgPyBzcHJlYWREYXRhW2tleV0ubGVuZ3RoIDogJ3NpbmdsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IGRldGFpbGVkIHNwcmVhZCBpbmZvcm1hdGlvblxyXG4gICAgICBjb25zdCBkZXRhaWxlZFNwcmVhZCA9IHtcclxuICAgICAgICBzZWxmOiBzcHJlYWREYXRhWydAX1NlbGYnXSxcclxuICAgICAgICBmbGF0dGVuZXJPdmVycmlkZTogc3ByZWFkRGF0YVsnQF9GbGF0dGVuZXJPdmVycmlkZSddIHx8ICcnLFxyXG4gICAgICAgIGJpbmRpbmdMb2NhdGlvbjogcGFyc2VGbG9hdChzcHJlYWREYXRhWydAX0JpbmRpbmdMb2NhdGlvbiddKSB8fCAwLFxyXG4gICAgICAgIGFsbG93UGFnZVNodWZmbGU6IHNwcmVhZERhdGFbJ0BfQWxsb3dQYWdlU2h1ZmZsZSddICE9PSBmYWxzZSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBFeHRyYWN0IHBhZ2UgZWxlbWVudHNcclxuICAgICAgICBwYWdlczogdGhpcy5lbGVtZW50UGFyc2VyLmV4dHJhY3RTcHJlYWRQYWdlcyhzcHJlYWREYXRhKSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBFeHRyYWN0IGFsbCBwYWdlIGl0ZW1zICh0ZXh0IGZyYW1lcywgcmVjdGFuZ2xlcywgZXRjLilcclxuICAgICAgICBwYWdlSXRlbXM6IHRoaXMuZWxlbWVudFBhcnNlci5leHRyYWN0UGFnZUl0ZW1zKHNwcmVhZERhdGEpXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLnNwcmVhZHNbc3ByZWFkSWRdID0gZGV0YWlsZWRTcHJlYWQ7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgU3ByZWFkICR7c3ByZWFkSWR9IHBhcnNlZCB3aXRoICR7ZGV0YWlsZWRTcHJlYWQucGFnZUl0ZW1zLmxlbmd0aH0gaXRlbXNgKTtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcGFyc2luZyBzcHJlYWQgJHtmaWxlTmFtZX06YCwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBwYXJzZU1hc3RlclNwcmVhZEZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coYPCfjqggUGFyc2luZyBtYXN0ZXIgc3ByZWFkOiAke2ZpbGVOYW1lfWApO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSB4bWxQYXJzZXIucGFyc2UoY29udGVudCk7XHJcbiAgICAgIGNvbnN0IG1hc3RlcklkID0gcGF0aC5iYXNlbmFtZShmaWxlTmFtZSwgJy54bWwnKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IG1hc3RlckRhdGEgPSBwYXJzZWQuTWFzdGVyU3ByZWFkPy5NYXN0ZXJTcHJlYWQgfHwgcGFyc2VkLk1hc3RlclNwcmVhZCB8fCBwYXJzZWQ7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnUGFyc2VkIG1hc3RlciBzcHJlYWQga2V5czonLCBPYmplY3Qua2V5cyhwYXJzZWQpKTtcclxuICAgICAgaWYgKHBhcnNlZC5NYXN0ZXJTcHJlYWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTWFzdGVyU3ByZWFkIHdyYXBwZXIga2V5czonLCBPYmplY3Qua2V5cyhwYXJzZWQuTWFzdGVyU3ByZWFkKSk7XHJcbiAgICAgICAgaWYgKHBhcnNlZC5NYXN0ZXJTcHJlYWQuTWFzdGVyU3ByZWFkKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnQWN0dWFsIG1hc3RlciBzcHJlYWQga2V5czonLCBPYmplY3Qua2V5cyhwYXJzZWQuTWFzdGVyU3ByZWFkLk1hc3RlclNwcmVhZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSAgICAgXHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IGRldGFpbGVkIG1hc3RlciBzcHJlYWQgaW5mb3JtYXRpb25cclxuICAgICAgY29uc3QgZGV0YWlsZWRNYXN0ZXIgPSB7XHJcbiAgICAgICAgc2VsZjogbWFzdGVyRGF0YVsnQF9TZWxmJ10sXHJcbiAgICAgICAgbmFtZTogbWFzdGVyRGF0YVsnQF9OYW1lJ10gfHwgJycsXHJcbiAgICAgICAgbmFtZVByZWZpeDogbWFzdGVyRGF0YVsnQF9OYW1lUHJlZml4J10gfHwgJycsXHJcbiAgICAgICAgYmFzZWRPbjogbWFzdGVyRGF0YVsnQF9CYXNlZE9uJ10gfHwgJycsXHJcbiAgICAgICAgaXRlbVRyYW5zZm9ybTogSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKG1hc3RlckRhdGFbJ0BfSXRlbVRyYW5zZm9ybSddKSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBFeHRyYWN0IG1hc3RlciBwYWdlc1xyXG4gICAgICAgIHBhZ2VzOiB0aGlzLmVsZW1lbnRQYXJzZXIuZXh0cmFjdE1hc3RlclBhZ2VzKG1hc3RlckRhdGEpLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEV4dHJhY3QgbWFzdGVyIHBhZ2UgaXRlbXNcclxuICAgICAgICBwYWdlSXRlbXM6IHRoaXMuZWxlbWVudFBhcnNlci5leHRyYWN0UGFnZUl0ZW1zKG1hc3RlckRhdGEpXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLm1hc3RlclNwcmVhZHNbbWFzdGVySWRdID0gZGV0YWlsZWRNYXN0ZXI7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgTWFzdGVyIHNwcmVhZCAke21hc3RlcklkfSBwYXJzZWQgd2l0aCAke2RldGFpbGVkTWFzdGVyLnBhZ2VJdGVtcy5sZW5ndGh9IGl0ZW1zYCk7XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHBhcnNpbmcgbWFzdGVyIHNwcmVhZCAke2ZpbGVOYW1lfTpgLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3REZXRhaWxlZEluZm9ybWF0aW9uKCkge1xyXG4gICAgY29uc29sZS5sb2coJ0V4dHJhY3RpbmcgZGV0YWlsZWQgaW5mb3JtYXRpb24gd2l0aCBlbmhhbmNlZCBwcm9jZXNzaW5nLi4uJyk7XHJcbiAgICBcclxuICAgIHRoaXMucGFnZUluZm8gPSB7XHJcbiAgICAgIGRpbWVuc2lvbnM6IHRoaXMuY2FsY3VsYXRlUGFnZURpbWVuc2lvbnMoKSxcclxuICAgICAgbWFyZ2luczogdGhpcy5jYWxjdWxhdGVNYXJnaW5zKCksXHJcbiAgICAgIGJsZWVkczogdGhpcy5jYWxjdWxhdGVCbGVlZHMoKSxcclxuICAgICAgZ3VpZGVzOiB0aGlzLmV4dHJhY3RHdWlkZXMoKSxcclxuICAgICAgZ3JpZHM6IHRoaXMuZXh0cmFjdEdyaWRzKClcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZWxlbWVudFBhcnNlci5jcmVhdGVFbGVtZW50UG9zaXRpb25NYXBGaXhlZCgpOyAvLyBVc2UgdGhlIGZpeGVkIHZlcnNpb25cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ+KchSBFbmhhbmNlZCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBleHRyYWN0ZWQnKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZVBhZ2VEaW1lbnNpb25zKCkge1xyXG4gICAgLy8gVHJ5IHRvIGdldCBkaW1lbnNpb25zIGZyb20gc3ByZWFkcyBmaXJzdCAobW9zdCByZWxpYWJsZSlcclxuICAgIGlmICh0aGlzLnNwcmVhZHMgJiYgT2JqZWN0LmtleXModGhpcy5zcHJlYWRzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGZpcnN0U3ByZWFkID0gT2JqZWN0LnZhbHVlcyh0aGlzLnNwcmVhZHMpWzBdO1xyXG4gICAgICBpZiAoZmlyc3RTcHJlYWQucGFnZXMgJiYgZmlyc3RTcHJlYWQucGFnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0UGFnZSA9IGZpcnN0U3ByZWFkLnBhZ2VzWzBdO1xyXG4gICAgICAgIGlmIChmaXJzdFBhZ2UuZ2VvbWV0cmljQm91bmRzKSB7XHJcbiAgICAgICAgICBjb25zdCBib3VuZHMgPSBmaXJzdFBhZ2UuZ2VvbWV0cmljQm91bmRzO1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCB8fCBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCB8fCAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQgfHwgYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3AgfHwgMCxcclxuICAgICAgICAgICAgZmFjaW5nUGFnZXM6IE9iamVjdC52YWx1ZXModGhpcy5zcHJlYWRzKS5zb21lKHNwcmVhZCA9PiBzcHJlYWQucGFnZXMgJiYgc3ByZWFkLnBhZ2VzLmxlbmd0aCA+IDEpLFxyXG4gICAgICAgICAgICB1bml0czogJ1BvaW50cydcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEZhbGxiYWNrIHRvIGRvY3VtZW50IHByZWZlcmVuY2VzXHJcbiAgICBjb25zdCBkb2NQcmVmcyA9IHRoaXMuZG9jdW1lbnRJbmZvLnByZWZlcmVuY2VzPy5kb2N1bWVudFByZWZlcmVuY2VzIHx8IHt9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogZG9jUHJlZnMucGFnZVdpZHRoIHx8IDAsXHJcbiAgICAgIGhlaWdodDogZG9jUHJlZnMucGFnZUhlaWdodCB8fCAwLFxyXG4gICAgICBmYWNpbmdQYWdlczogZG9jUHJlZnMuZmFjaW5nUGFnZXMgfHwgZmFsc2UsXHJcbiAgICAgIHVuaXRzOiB0aGlzLmRvY3VtZW50SW5mby5wcmVmZXJlbmNlcz8udmlld1ByZWZlcmVuY2VzPy5ob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cyB8fCAnUG9pbnRzJ1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZU1hcmdpbnMoKSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TjyBDYWxjdWxhdGluZyBtYXJnaW5zIGZyb20gbXVsdGlwbGUgc291cmNlcy4uLicpO1xyXG4gICAgXHJcbiAgICAvLyBUcnkgdG8gZ2V0IG1hcmdpbnMgZnJvbSBtYXN0ZXIgcGFnZXMgZmlyc3QgKG1vc3QgcmVsaWFibGUpXHJcbiAgICBpZiAodGhpcy5tYXN0ZXJTcHJlYWRzICYmIE9iamVjdC5rZXlzKHRoaXMubWFzdGVyU3ByZWFkcykubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaXJzdE1hc3RlciA9IE9iamVjdC52YWx1ZXModGhpcy5tYXN0ZXJTcHJlYWRzKVswXTtcclxuICAgICAgaWYgKGZpcnN0TWFzdGVyLnBhZ2VzICYmIGZpcnN0TWFzdGVyLnBhZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBmaXJzdE1hc3RlclBhZ2UgPSBmaXJzdE1hc3Rlci5wYWdlc1swXTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBMb29rIGZvciBtYXJnaW4gcHJlZmVyZW5jZXMgaW4gbWFzdGVyIHBhZ2VcclxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgcG9wdWxhdGVkIGJ5IHRoZSBpbXByb3ZlZCBtYXN0ZXIgc3ByZWFkIHBhcnNpbmdcclxuICAgICAgICBpZiAoZmlyc3RNYXN0ZXJQYWdlLm1hcmdpblByZWZlcmVuY2UpIHtcclxuICAgICAgICAgIGNvbnN0IG1hc3Rlck1hcmdpbnMgPSB7XHJcbiAgICAgICAgICAgIHRvcDogZmlyc3RNYXN0ZXJQYWdlLm1hcmdpblByZWZlcmVuY2UudG9wIHx8IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogZmlyc3RNYXN0ZXJQYWdlLm1hcmdpblByZWZlcmVuY2UuYm90dG9tIHx8IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IGZpcnN0TWFzdGVyUGFnZS5tYXJnaW5QcmVmZXJlbmNlLmxlZnQgfHwgMCxcclxuICAgICAgICAgICAgcmlnaHQ6IGZpcnN0TWFzdGVyUGFnZS5tYXJnaW5QcmVmZXJlbmNlLnJpZ2h0IHx8IDAsXHJcbiAgICAgICAgICAgIGNvbHVtbkNvdW50OiBmaXJzdE1hc3RlclBhZ2UubWFyZ2luUHJlZmVyZW5jZS5jb2x1bW5Db3VudCB8fCAxLFxyXG4gICAgICAgICAgICBjb2x1bW5HdXR0ZXI6IGZpcnN0TWFzdGVyUGFnZS5tYXJnaW5QcmVmZXJlbmNlLmNvbHVtbkd1dHRlciB8fCAwXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TjyBGb3VuZCBtYXJnaW5zIGZyb20gbWFzdGVyIHBhZ2U6JywgbWFzdGVyTWFyZ2lucyk7XHJcbiAgICAgICAgICByZXR1cm4gbWFzdGVyTWFyZ2lucztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRmFsbGJhY2sgdG8gZG9jdW1lbnQgcHJlZmVyZW5jZXNcclxuICAgIGNvbnN0IGRvY1ByZWZzID0gdGhpcy5kb2N1bWVudEluZm8uZG9jdW1lbnRQcmVmZXJlbmNlcyB8fCB7fTtcclxuICAgIGNvbnN0IG1hcmdpblByZWZzID0gdGhpcy5kb2N1bWVudEluZm8ucHJlZmVyZW5jZXM/Lm1hcmdpblByZWZlcmVuY2VzIHx8IHt9O1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBmb3IgbWFyZ2luIGRhdGEgaW4gZG9jdW1lbnQgcHJlZmVyZW5jZXMgKGZhbGxiYWNrKVxyXG4gICAgY29uc3QgbWFyZ2lucyA9IHtcclxuICAgICAgdG9wOiBtYXJnaW5QcmVmcy50b3AgfHwgZG9jUHJlZnMubWFyZ2luVG9wIHx8IGRvY1ByZWZzLnRvcCB8fCAwLFxyXG4gICAgICBib3R0b206IG1hcmdpblByZWZzLmJvdHRvbSB8fCBkb2NQcmVmcy5tYXJnaW5Cb3R0b20gfHwgZG9jUHJlZnMuYm90dG9tIHx8IDAsXHJcbiAgICAgIGxlZnQ6IG1hcmdpblByZWZzLmxlZnQgfHwgZG9jUHJlZnMubWFyZ2luTGVmdCB8fCBkb2NQcmVmcy5sZWZ0IHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBtYXJnaW5QcmVmcy5yaWdodCB8fCBkb2NQcmVmcy5tYXJnaW5SaWdodCB8fCBkb2NQcmVmcy5yaWdodCB8fCAwLFxyXG4gICAgICBjb2x1bW5Db3VudDogbWFyZ2luUHJlZnMuY29sdW1uQ291bnQgfHwgZG9jUHJlZnMubWFyZ2luQ29sdW1uQ291bnQgfHwgZG9jUHJlZnMuY29sdW1uQ291bnQgfHwgMSxcclxuICAgICAgY29sdW1uR3V0dGVyOiBtYXJnaW5QcmVmcy5jb2x1bW5HdXR0ZXIgfHwgZG9jUHJlZnMubWFyZ2luQ29sdW1uR3V0dGVyIHx8IGRvY1ByZWZzLmNvbHVtbkd1dHRlciB8fCAwXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygn8J+TjyBDYWxjdWxhdGVkIG1hcmdpbnMgKGZhbGxiYWNrKTonLCBtYXJnaW5zKTtcclxuICAgIHJldHVybiBtYXJnaW5zO1xyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlQmxlZWRzKCkge1xyXG4gICAgY29uc3QgZG9jUHJlZnMgPSB0aGlzLmRvY3VtZW50SW5mby5wcmVmZXJlbmNlcz8uZG9jdW1lbnRQcmVmZXJlbmNlcyB8fCB7fTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiBkb2NQcmVmcy5kb2N1bWVudEJsZWVkVG9wT2Zmc2V0IHx8IDAsXHJcbiAgICAgIGJvdHRvbTogZG9jUHJlZnMuZG9jdW1lbnRCbGVlZEJvdHRvbU9mZnNldCB8fCAwLFxyXG4gICAgICBpbnNpZGU6IGRvY1ByZWZzLmRvY3VtZW50QmxlZWRJbnNpZGVPckxlZnRPZmZzZXQgfHwgMCxcclxuICAgICAgb3V0c2lkZTogZG9jUHJlZnMuZG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0IHx8IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3VpZGVzKCkge1xyXG4gICAgY29uc3QgZ3VpZGVzID0gW107XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgZ3VpZGVzIGZyb20gc3ByZWFkc1xyXG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLnNwcmVhZHMpLmZvckVhY2goc3ByZWFkID0+IHtcclxuICAgICAgaWYgKHNwcmVhZC5wYWdlSXRlbXMpIHtcclxuICAgICAgICBzcHJlYWQucGFnZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnR3VpZGUnKSB7XHJcbiAgICAgICAgICAgIGd1aWRlcy5wdXNoKHtcclxuICAgICAgICAgICAgICBvcmllbnRhdGlvbjogaXRlbS5vcmllbnRhdGlvbiB8fCAnSG9yaXpvbnRhbCcsXHJcbiAgICAgICAgICAgICAgbG9jYXRpb246IGl0ZW0ubG9jYXRpb24gfHwgMCxcclxuICAgICAgICAgICAgICBmaXRUb1BhZ2U6IGl0ZW0uZml0VG9QYWdlIHx8IGZhbHNlLFxyXG4gICAgICAgICAgICAgIHZpZXdUaHJlc2hvbGQ6IGl0ZW0udmlld1RocmVzaG9sZCB8fCAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGd1aWRlcztcclxuICB9XHJcblxyXG4gIGV4dHJhY3RHcmlkcygpIHtcclxuICAgIGNvbnN0IGdyaWRQcmVmcyA9IHRoaXMuZG9jdW1lbnRJbmZvLnByZWZlcmVuY2VzPy5ncmlkUHJlZmVyZW5jZXMgfHwge307XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJhc2VsaW5lOiB7XHJcbiAgICAgICAgc3RhcnQ6IGdyaWRQcmVmcy5iYXNlbGluZVN0YXJ0IHx8IDAsXHJcbiAgICAgICAgZGl2aXNpb246IGdyaWRQcmVmcy5iYXNlbGluZURpdmlzaW9uIHx8IDEyLFxyXG4gICAgICAgIHNob3duOiBncmlkUHJlZnMuYmFzZWxpbmVTaG93biB8fCBmYWxzZSxcclxuICAgICAgICBzbmFwVG86IGdyaWRQcmVmcy5iYXNlbGluZVNuYXB0byB8fCBmYWxzZVxyXG4gICAgICB9LFxyXG4gICAgICBkb2N1bWVudDoge1xyXG4gICAgICAgIHNob3duOiBncmlkUHJlZnMuZG9jdW1lbnRHcmlkU2hvd24gfHwgZmFsc2UsXHJcbiAgICAgICAgc25hcFRvOiBncmlkUHJlZnMuZG9jdW1lbnRHcmlkU25hcHRvIHx8IGZhbHNlXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBnZXQgcGFnZSBjb250ZW50XHJcbiAgZ2V0UGFnZUNvbnRlbnQocGFnZUlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50UGFyc2VyLmdldFBhZ2VDb250ZW50KHBhZ2VJZCk7XHJcbiAgfVxyXG5cclxuICBnZXREb2N1bWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50O1xyXG4gIH1cclxuXHJcbiAgZ2V0U3ByZWFkcygpIHtcclxuICAgIHJldHVybiB0aGlzLnNwcmVhZHM7XHJcbiAgfVxyXG5cclxuICBnZXRNYXN0ZXJTcHJlYWRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWFzdGVyU3ByZWFkcztcclxuICB9XHJcblxyXG4gIGdldERvY3VtZW50SW5mbygpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50SW5mbztcclxuICB9XHJcblxyXG4gIGdldFBhZ2VJbmZvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGFnZUluZm87XHJcbiAgfVxyXG5cclxuICBnZXRMYXllcnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sYXllcnM7XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KCkge1xyXG4gICAgcmV0dXJuIElETUxVdGlscy5jYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KHRoaXMuZWxlbWVudFBhcnNlci5nZXRFbGVtZW50cygpKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnRQYXJzZXI7IFxyXG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJJRE1MVXRpbHMiLCJEb2N1bWVudFBhcnNlciIsInBhcnNlRG9jdW1lbnRTdHJ1Y3R1cmUiLCJleHRyYWN0ZWREYXRhIiwieG1sUGFyc2VyIiwiY29uc29sZSIsImxvZyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJkZXNpZ25NYXBEYXRhIiwicGFyc2UiLCJkb2N1bWVudCIsIkRvY3VtZW50IiwiZXh0cmFjdERvY3VtZW50SW5mbyIsImVycm9yIiwiZmlsZU5hbWUiLCJjb250ZW50IiwiZW50cmllcyIsInN0YXJ0c1dpdGgiLCJwYXJzZVNwcmVhZEZpbGUiLCJwYXJzZU1hc3RlclNwcmVhZEZpbGUiLCJkb2N1bWVudEluZm8iLCJ2ZXJzaW9uIiwic2VsZiIsImFjdGl2ZUxheWVyIiwidW51c2VkU3dhdGNoZXMiLCJkb2N1bWVudFByZWZlcmVuY2VzIiwiZXh0cmFjdERvY3VtZW50UHJlZmVyZW5jZXMiLCJwYWdlU2V0dXAiLCJleHRyYWN0UGFnZVNldHVwIiwibGF5ZXJzIiwiZXh0cmFjdExheWVycyIsInBhZ2VzIiwiZXh0cmFjdFBhZ2VzIiwicHJlZnMiLCJkb2NQcmVmIiwiRG9jdW1lbnRQcmVmZXJlbmNlIiwiZG9jdW1lbnRQcmVmZXJlbmNlIiwiUHJvcGVydGllcyIsInBhZ2VXaWR0aCIsInBhcnNlRmxvYXQiLCJwYWdlSGVpZ2h0IiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY29sdW1uQ291bnQiLCJwYXJzZUludCIsImNvbHVtbkd1dHRlciIsImZhY2luZ1BhZ2VzIiwibWFyZ2luUHJlZiIsIk1hcmdpblByZWZlcmVuY2UiLCJtYXJnaW5QcmVmZXJlbmNlIiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQ29sdW1uQ291bnQiLCJtYXJnaW5Db2x1bW5HdXR0ZXIiLCJtYXN0ZXJQYWdlcyIsInNwcmVhZHMiLCJQYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInBhZ2UiLCJwdXNoIiwibmFtZSIsImFwcGxpZWRNYXN0ZXIiLCJnZW9tZXRyaWNCb3VuZHMiLCJwYXJzZUdlb21ldHJpY0JvdW5kcyIsIml0ZW1UcmFuc2Zvcm0iLCJwYXJzZVRyYW5zZm9ybSIsIm92ZXJyaWRlTGlzdCIsIkxheWVyIiwibGF5ZXJEYXRhIiwibGF5ZXIiLCJ2aXNpYmxlIiwibG9ja2VkIiwiaWdub3JlV3JhcCIsInNob3dHdWlkZXMiLCJsb2NrR3VpZGVzIiwidWkiLCJsYXllckNvbG9yIiwiU3ByZWFkIiwic3ByZWFkIiwic3ByZWFkUGFnZXMiLCJzcHJlYWRQYXJlbnQiLCJwYXJzZWQiLCJzcHJlYWRJZCIsImJhc2VuYW1lIiwic3ByZWFkRGF0YSIsImluZGV4Iiwia2V5IiwidmFsdWUiLCJpbmNsdWRlcyIsImRldGFpbGVkU3ByZWFkIiwiZmxhdHRlbmVyT3ZlcnJpZGUiLCJiaW5kaW5nTG9jYXRpb24iLCJhbGxvd1BhZ2VTaHVmZmxlIiwiZWxlbWVudFBhcnNlciIsImV4dHJhY3RTcHJlYWRQYWdlcyIsInBhZ2VJdGVtcyIsImV4dHJhY3RQYWdlSXRlbXMiLCJtZXNzYWdlIiwibWFzdGVySWQiLCJtYXN0ZXJEYXRhIiwiTWFzdGVyU3ByZWFkIiwiZGV0YWlsZWRNYXN0ZXIiLCJuYW1lUHJlZml4IiwiYmFzZWRPbiIsImV4dHJhY3RNYXN0ZXJQYWdlcyIsIm1hc3RlclNwcmVhZHMiLCJleHRyYWN0RGV0YWlsZWRJbmZvcm1hdGlvbiIsInBhZ2VJbmZvIiwiZGltZW5zaW9ucyIsImNhbGN1bGF0ZVBhZ2VEaW1lbnNpb25zIiwibWFyZ2lucyIsImNhbGN1bGF0ZU1hcmdpbnMiLCJibGVlZHMiLCJjYWxjdWxhdGVCbGVlZHMiLCJndWlkZXMiLCJleHRyYWN0R3VpZGVzIiwiZ3JpZHMiLCJleHRyYWN0R3JpZHMiLCJjcmVhdGVFbGVtZW50UG9zaXRpb25NYXBGaXhlZCIsImZpcnN0U3ByZWFkIiwidmFsdWVzIiwiZmlyc3RQYWdlIiwiYm91bmRzIiwid2lkdGgiLCJoZWlnaHQiLCJzb21lIiwidW5pdHMiLCJkb2NQcmVmcyIsInByZWZlcmVuY2VzIiwidmlld1ByZWZlcmVuY2VzIiwiaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHMiLCJmaXJzdE1hc3RlciIsImZpcnN0TWFzdGVyUGFnZSIsIm1hc3Rlck1hcmdpbnMiLCJtYXJnaW5QcmVmcyIsIm1hcmdpblByZWZlcmVuY2VzIiwiZG9jdW1lbnRCbGVlZFRvcE9mZnNldCIsImRvY3VtZW50QmxlZWRCb3R0b21PZmZzZXQiLCJpbnNpZGUiLCJkb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0Iiwib3V0c2lkZSIsImRvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldCIsIml0ZW0iLCJ0eXBlIiwib3JpZW50YXRpb24iLCJsb2NhdGlvbiIsImZpdFRvUGFnZSIsInZpZXdUaHJlc2hvbGQiLCJncmlkUHJlZnMiLCJncmlkUHJlZmVyZW5jZXMiLCJiYXNlbGluZSIsInN0YXJ0IiwiYmFzZWxpbmVTdGFydCIsImRpdmlzaW9uIiwiYmFzZWxpbmVEaXZpc2lvbiIsInNob3duIiwiYmFzZWxpbmVTaG93biIsInNuYXBUbyIsImJhc2VsaW5lU25hcHRvIiwiZG9jdW1lbnRHcmlkU2hvd24iLCJkb2N1bWVudEdyaWRTbmFwdG8iLCJnZXRQYWdlQ29udGVudCIsInBhZ2VJZCIsImdldERvY3VtZW50IiwiZ2V0U3ByZWFkcyIsImdldE1hc3RlclNwcmVhZHMiLCJnZXREb2N1bWVudEluZm8iLCJnZXRQYWdlSW5mbyIsImdldExheWVycyIsImNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXQiLCJnZXRFbGVtZW50cyIsImNvbnN0cnVjdG9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/parsers/DocumentParser.js\n"));

/***/ })

});