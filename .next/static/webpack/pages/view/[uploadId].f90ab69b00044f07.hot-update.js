"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StoryParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StoryParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StoryParser {\n    async parseStoryFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCDD Parsing story: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const storyId = path.basename(fileName, \".xml\");\n            const storyData = parsed.Story || parsed;\n            // ADD THESE SIMPLE LOGS FIRST:\n            console.log(\"=== SIMPLE DEBUG TEST ===\");\n            console.log(\"Story file name:\", fileName);\n            console.log(\"Parsed story keys:\", Object.keys(storyData));\n            console.log(\"Raw story data sample:\", JSON.stringify(storyData, null, 2).substring(0, 500));\n            // Extract detailed story information\n            const detailedStory = {\n                self: storyData[\"@_Self\"],\n                appliedTOCStyle: storyData[\"@_AppliedTOCStyle\"] || \"n\",\n                userText: storyData[\"@_UserText\"] !== false,\n                // Extract story content with formatting\n                content: this.extractDetailedStoryContent(storyData),\n                // Extract text formatting\n                textFormatting: this.extractTextFormatting(storyData)\n            };\n            const cleanStoryId = storyId.replace(\"Story_\", \"\");\n            this.stories[cleanStoryId] = detailedStory;\n            // Enhanced logging to show line breaks\n            const { plainText, lineBreakInfo } = detailedStory.content;\n            console.log(\"✅ Story \".concat(storyId, \" parsed:\"));\n            console.log(\"   - Characters: \".concat(plainText.length));\n            console.log(\"   - Words: \".concat(detailedStory.content.wordCount));\n            console.log(\"   - Line breaks: \".concat((lineBreakInfo === null || lineBreakInfo === void 0 ? void 0 : lineBreakInfo.lineBreakCount) || 0));\n            console.log('   - Text preview: \"'.concat(plainText.substring(0, 50).replace(/\\n/g, \"\\\\n\"), '...\"'));\n        } catch (error) {\n            console.error(\"❌ Error parsing story \".concat(fileName, \":\"), error.message);\n        }\n    }\n    // Replace the existing extractDetailedStoryContent method with this corrected version\n    extractDetailedStoryContent(storyData) {\n        var _this = this;\n        let content = \"\";\n        let formattedContent = [];\n        let textColor = null;\n        let debugInfo = [];\n        const extractTextRecursively = function(element) {\n            let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (typeof element === \"string\") {\n                content += element;\n                return;\n            }\n            if (element && typeof element === \"object\") {\n                // ENHANCED: Special handling for CharacterStyleRange with sophisticated Br detection\n                if (element.CharacterStyleRange) {\n                    const ranges = Array.isArray(element.CharacterStyleRange) ? element.CharacterStyleRange : [\n                        element.CharacterStyleRange\n                    ];\n                    // SIMPLIFIED DEBUG: Just log problematic text ranges\n                    const allRangeContent = ranges.map((r)=>r.Content ? Array.isArray(r.Content) ? r.Content.join(\"\") : String(r.Content) : \"\").join(\"\");\n                    if (allRangeContent.includes(\"pavoluptusda\") || allRangeContent.includes(\"pa\") || allRangeContent.includes(\"voluptusda\")) {\n                        console.log(\"\\uD83D\\uDEA8 FOUND RANGES WITH PROBLEMATIC TEXT:\");\n                        ranges.forEach((range, index)=>{\n                            const content = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                            console.log(\"   Range \".concat(index, ': \"').concat(content, '\"'));\n                        });\n                    }\n                    ranges.forEach((range, rangeIndex)=>{\n                        // Extract direct font references from the XML range\n                        const directFontRef = range[\"@_AppliedFont\"] || range[\"@_FontFamily\"] || range[\"@_Font\"] || \"\";\n                        const formatting = {\n                            paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                            characterStyle: range[\"@_AppliedCharacterStyle\"] || null,\n                            fontSize: range[\"@_PointSize\"] ? parseFloat(range[\"@_PointSize\"]) : null,\n                            fontReference: directFontRef,\n                            fillColor: range[\"@_FillColor\"] || null,\n                            fontStyle: range[\"@_FontStyle\"] || null,\n                            // CRITICAL FIX: Inherit paragraph alignment from context if not explicitly set\n                            alignment: range[\"@_Justification\"] || range[\"@_Alignment\"] || context.paragraphAlignment || null\n                        };\n                        // DEBUG: Log formatting extraction for any styled text (generic check)\n                        const rangeContent = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                        const hasStyleInfo = range[\"@_FontStyle\"] || range[\"@_AppliedCharacterStyle\"] || element[\"@_AppliedParagraphStyle\"] || range[\"@_AppliedFont\"];\n                        if (hasStyleInfo && rangeContent.trim()) {\n                            console.log(\"\\uD83D\\uDD27 StoryParser - Extracting formatting for range:\", JSON.stringify(rangeContent.substring(0, 30) + \"...\"), {\n                                rawRangeAttributes: Object.keys(range).filter((k)=>k.startsWith(\"@_\")),\n                                extractedFormatting: formatting,\n                                fontStyleFromXML: range[\"@_FontStyle\"],\n                                characterStyleFromXML: range[\"@_AppliedCharacterStyle\"],\n                                paragraphStyleFromXML: element[\"@_AppliedParagraphStyle\"]\n                            });\n                        }\n                        const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                        // FIXED: Process content with proper space preservation\n                        if (range.Content) {\n                            const contents = Array.isArray(range.Content) ? range.Content : [\n                                range.Content\n                            ];\n                            contents.forEach((contentItem, contentIndex)=>{\n                                const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n                                content += text;\n                                formattedContent.push({\n                                    text: text,\n                                    formatting: resolvedFormatting\n                                });\n                                // CRITICAL FIX: Check for Br elements AFTER each content item within the same range\n                                if (range.Br !== undefined && contentIndex < contents.length - 1) {\n                                    const lineBreakText = \"\\n\";\n                                    content += lineBreakText;\n                                    formattedContent.push({\n                                        text: lineBreakText,\n                                        formatting: {\n                                            isBreak: true,\n                                            breakType: \"line\",\n                                            position: \"between_content\",\n                                            source: \"Br element within range\"\n                                        }\n                                    });\n                                    debugInfo.push({\n                                        type: \"Line break detected within content\",\n                                        location: \"CharacterStyleRange[\".concat(rangeIndex, \"], between content[\").concat(contentIndex, \"] and content[\").concat(contentIndex + 1, \"]\"),\n                                        breakType: \"line\",\n                                        context: context\n                                    });\n                                }\n                            });\n                        }\n                        // Handle Br elements at the end of the range\n                        if (range.Br !== undefined && (!range.Content || Array.isArray(range.Content) === false)) {\n                            const brElements = _this.extractBrElements(range);\n                            brElements.forEach((brInfo, brIndex)=>{\n                                const lineBreakText = _this.determineLineBreakType(brInfo, context);\n                                content += lineBreakText;\n                                formattedContent.push({\n                                    text: lineBreakText,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: brInfo.type || \"line\",\n                                        position: brInfo.position || \"end\",\n                                        source: \"Br element at end of range\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Line break detected at end of range\",\n                                    location: \"CharacterStyleRange[\".concat(rangeIndex, \"], Br[\").concat(brIndex, \"]\"),\n                                    breakType: brInfo.type || \"line\",\n                                    context: context\n                                });\n                            });\n                        }\n                        // CRITICAL FIX: Add space between character style ranges if needed\n                        if (rangeIndex < ranges.length - 1) {\n                            const nextRange = ranges[rangeIndex + 1];\n                            // More robust space detection\n                            const currentText = content.slice(-10); // Check last 10 characters\n                            const currentRangeEndsWithSpace = /\\s$/.test(currentText); // Any whitespace at end\n                            const nextContent = nextRange.Content ? String(Array.isArray(nextRange.Content) ? nextRange.Content[0] : nextRange.Content) : \"\";\n                            const nextRangeStartsWithSpace = /^\\s/.test(nextContent); // Any whitespace at start\n                            // AGGRESSIVE FIX: Add space between ALL ranges unless explicitly not needed\n                            const shouldSkipSpace = currentRangeEndsWithSpace || nextRangeStartsWithSpace || _this.shouldInsertImplicitLineBreak(range, nextRange, context) || !nextRange.Content || // Skip if next range has no content\n                            nextContent.trim() === \"\"; // Skip if next content is only whitespace\n                            if (!shouldSkipSpace) {\n                                const currentStyle = range[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const nextStyle = nextRange[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const spaceText = \" \";\n                                content += spaceText;\n                                formattedContent.push({\n                                    text: spaceText,\n                                    formatting: {\n                                        isSpace: true,\n                                        source: \"between character style ranges (aggressive)\",\n                                        currentStyle,\n                                        nextStyle\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Space inserted between character styles (aggressive)\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    currentStyle,\n                                    nextStyle,\n                                    reason: \"Default space insertion - words likely split across ranges\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            } else {\n                                debugInfo.push({\n                                    type: \"Space insertion skipped\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    reason: currentRangeEndsWithSpace ? \"Current range ends with space\" : nextRangeStartsWithSpace ? \"Next range starts with space\" : !nextRange.Content ? \"Next range has no content\" : nextContent.trim() === \"\" ? \"Next content is only whitespace\" : \"Line break would be inserted\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            }\n                            // Handle explicit line breaks between ranges (for cases where shouldInsertImplicitLineBreak is true)\n                            if (_this.shouldInsertImplicitLineBreak(range, nextRange, context)) {\n                                const implicitBreak = \"\\n\";\n                                content += implicitBreak;\n                                formattedContent.push({\n                                    text: implicitBreak,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: \"implicit\",\n                                        source: \"between ranges\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Implicit line break\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1)\n                                });\n                            }\n                        }\n                    });\n                    return; // Don't continue processing to avoid duplication\n                }\n                // ENHANCED: Handle ParagraphStyleRange with context\n                if (element.ParagraphStyleRange) {\n                    const ranges = Array.isArray(element.ParagraphStyleRange) ? element.ParagraphStyleRange : [\n                        element.ParagraphStyleRange\n                    ];\n                    ranges.forEach((range, index)=>{\n                        const paragraphContext = {\n                            ...context,\n                            paragraphIndex: index,\n                            totalParagraphs: ranges.length,\n                            appliedStyle: range[\"@_AppliedParagraphStyle\"],\n                            // CRITICAL FIX: Pass down direct paragraph-level alignment\n                            paragraphAlignment: range[\"@_Justification\"] || range[\"@_Alignment\"]\n                        };\n                        extractTextRecursively(range, depth + 1, paragraphContext);\n                        // Add paragraph break between paragraphs (but not after the last one)\n                        if (index < ranges.length - 1) {\n                            const paragraphBreak = \"\\n\";\n                            content += paragraphBreak;\n                            formattedContent.push({\n                                text: paragraphBreak,\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"paragraph\",\n                                    source: \"between paragraphs\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Paragraph break\",\n                                location: \"between paragraphs \".concat(index, \" and \").concat(index + 1)\n                            });\n                        }\n                    });\n                    return;\n                }\n                // Handle direct Content elements (when not inside CharacterStyleRange)\n                if (element.Content && !element.CharacterStyleRange) {\n                    let text = Array.isArray(element.Content) ? element.Content.join(\"\") : String(element.Content);\n                    text = IDMLUtils.decodeXMLEntities(text);\n                    content += text;\n                    const formatting = {\n                        paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                        characterStyle: element[\"@_AppliedCharacterStyle\"] || null,\n                        fontSize: element[\"@_PointSize\"] || null,\n                        fontFamily: element[\"@_AppliedFont\"] || null,\n                        fillColor: element[\"@_FillColor\"] || null,\n                        // CRITICAL FIX: Inherit paragraph alignment from context if not explicitly set\n                        alignment: element[\"@_Justification\"] || element[\"@_Alignment\"] || context.paragraphAlignment || null\n                    };\n                    const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                    formattedContent.push({\n                        text: text,\n                        formatting: resolvedFormatting\n                    });\n                }\n                // ENHANCED: Direct Br element handling (outside of ranges)\n                if (element.Br !== undefined) {\n                    const brElements = Array.isArray(element.Br) ? element.Br : [\n                        element.Br\n                    ];\n                    brElements.forEach((br, index)=>{\n                        const lineBreakText = \"\\n\";\n                        content += lineBreakText;\n                        formattedContent.push({\n                            text: lineBreakText,\n                            formatting: {\n                                isBreak: true,\n                                breakType: \"explicit\",\n                                source: \"direct Br element\"\n                            }\n                        });\n                        debugInfo.push({\n                            type: \"Direct Br element\",\n                            location: \"Direct element, index \".concat(index)\n                        });\n                    });\n                }\n                // Continue with other nested elements\n                Object.entries(element).forEach((param)=>{\n                    let [key, value] = param;\n                    if (!key.startsWith(\"@_\") && key !== \"Content\" && key !== \"Br\" && key !== \"CharacterStyleRange\" && key !== \"ParagraphStyleRange\") {\n                        if (Array.isArray(value)) {\n                            value.forEach((item)=>extractTextRecursively(item, depth + 1, context));\n                        } else if (typeof value === \"object\" && depth < 10) {\n                            extractTextRecursively(value, depth + 1, context);\n                        }\n                    }\n                });\n            }\n        };\n        extractTextRecursively(storyData);\n        // ENHANCED: Process and clean up the content with sophisticated line break preservation\n        const processedContent = IDMLUtils.sophisticatedLineBreakProcessing(content);\n        // DEBUG: Log space preservation results\n        console.log(\"\\uD83D\\uDCDD Text extraction results:\");\n        console.log(\"   - Original content length:\", content.length);\n        console.log(\"   - Processed content length:\", processedContent.length);\n        console.log(\"   - Space preservation events:\", debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length);\n        // SPECIFIC DEBUG: Check for the problematic \"pavoluptusda\" text (simplified)\n        if (processedContent.includes(\"pavoluptusda\") || processedContent.includes(\"pa\") && processedContent.includes(\"voluptusda\")) {\n            console.log(\"\\uD83D\\uDEA8 FOUND PROBLEMATIC TEXT:\");\n            console.log('   - Contains \"pavoluptusda\":', processedContent.includes(\"pavoluptusda\"));\n            console.log('   - Contains \"pa voluptusda\":', processedContent.includes(\"pa voluptusda\"));\n            console.log(\"   - FormattedContent breakdown:\", formattedContent.map((item)=>item.text).join(\"|\"));\n        }\n        const lineBreakInfo = {\n            hasLineBreaks: processedContent.includes(\"\\n\"),\n            lineBreakCount: (processedContent.match(/\\n/g) || []).length,\n            lineBreakTypes: this.analyzeLineBreakTypes(formattedContent),\n            debugInfo: debugInfo,\n            spacePreservationCount: debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length\n        };\n        return {\n            plainText: processedContent,\n            formattedContent: formattedContent.filter((item)=>item.text && item.text.length > 0),\n            wordCount: IDMLUtils.countWords(processedContent.replace(/\\n/g, \" \")),\n            characterCount: processedContent.length,\n            textColor: textColor,\n            lineBreakInfo: lineBreakInfo\n        };\n    }\n    // Add this helper method to better handle mixed content and Br elements\n    analyzeContentStructure(range) {\n        const structure = {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentItems: range.Content ? Array.isArray(range.Content) ? range.Content : [\n                range.Content\n            ] : [],\n            brElements: range.Br ? Array.isArray(range.Br) ? range.Br : [\n                range.Br\n            ] : []\n        };\n        console.log(\"Content structure analysis:\", structure);\n        return structure;\n    }\n    // Enhanced helper for processing interleaved content and breaks\n    processInterleavedContent(range, resolvedFormatting) {\n        const results = [];\n        let content = \"\";\n        // This method would need access to the actual XML structure to determine\n        // the exact order of Content and Br elements. For now, we'll use the \n        // approach above which handles the most common case.\n        return results;\n    }\n    // SOPHISTICATED: Helper method to extract Br elements with context\n    extractBrElements(range) {\n        const brElements = [];\n        if (range.Br !== undefined) {\n            if (Array.isArray(range.Br)) {\n                range.Br.forEach((br, index)=>{\n                    brElements.push({\n                        type: \"line\",\n                        position: index === 0 ? \"start\" : \"middle\",\n                        element: br\n                    });\n                });\n            } else {\n                brElements.push({\n                    type: \"line\",\n                    position: \"end\",\n                    element: range.Br\n                });\n            }\n        }\n        return brElements;\n    }\n    // SOPHISTICATED: Determine the appropriate line break type\n    determineLineBreakType(brInfo, context) {\n        // Different line break characters based on context\n        switch(brInfo.type){\n            case \"paragraph\":\n                return \"\\n\\n\"; // Double line break for paragraph separation\n            case \"forced\":\n                return \"\\n\"; // Forced line break (Shift+Enter equivalent)\n            case \"line\":\n            default:\n                return \"\\n\"; // Standard line break\n        }\n    }\n    // SOPHISTICATED: Determine if an implicit line break should be inserted\n    shouldInsertImplicitLineBreak(currentRange, nextRange, context) {\n        // Don't insert implicit breaks if explicit Br elements are present\n        if (currentRange.Br !== undefined || nextRange.Br !== undefined) {\n            return false;\n        }\n        // Insert breaks between different character styles in different paragraphs\n        const currentCharStyle = currentRange[\"@_AppliedCharacterStyle\"];\n        const nextCharStyle = nextRange[\"@_AppliedCharacterStyle\"];\n        // If we're in a context where styles change significantly, add a break\n        if (currentCharStyle && nextCharStyle && currentCharStyle !== nextCharStyle) {\n            // Check if this might be a title/heading followed by body text\n            const styleIndicatesBreak = this.styleIndicatesLineBreak(currentCharStyle, nextCharStyle);\n            return styleIndicatesBreak;\n        }\n        return false;\n    }\n    // SOPHISTICATED: Analyze if style change indicates a line break\n    styleIndicatesLineBreak(currentStyle, nextStyle) {\n        const titleIndicators = [\n            \"title\",\n            \"heading\",\n            \"header\"\n        ];\n        const bodyIndicators = [\n            \"body\",\n            \"text\",\n            \"normal\"\n        ];\n        const currentIsTitle = titleIndicators.some((indicator)=>currentStyle.toLowerCase().includes(indicator));\n        const nextIsBody = bodyIndicators.some((indicator)=>nextStyle.toLowerCase().includes(indicator));\n        return currentIsTitle && nextIsBody;\n    }\n    // SOPHISTICATED: Analyze line break types in formatted content\n    analyzeLineBreakTypes(formattedContent) {\n        const types = {\n            explicit: 0,\n            implicit: 0,\n            paragraph: 0,\n            direct: 0 // Direct Br elements\n        };\n        formattedContent.forEach((item)=>{\n            var _item_formatting;\n            if ((_item_formatting = item.formatting) === null || _item_formatting === void 0 ? void 0 : _item_formatting.isBreak) {\n                const breakType = item.formatting.breakType || \"unknown\";\n                if (types.hasOwnProperty(breakType)) {\n                    types[breakType]++;\n                }\n            }\n        });\n        return types;\n    }\n    extractDetailedFormattingFromRange(range) {\n        const formatting = {};\n        // Extract all possible font attributes\n        const fontAttributes = [\n            \"@_AppliedFont\",\n            \"@_FontFamily\",\n            \"@_Font\",\n            \"@_PostScriptName\",\n            \"@_FontName\"\n        ];\n        fontAttributes.forEach((attr)=>{\n            if (range[attr]) {\n                formatting.fontReference = range[attr];\n            }\n        });\n        // Extract font and size attributes\n        formatting.fontSize = IDMLUtils.parseNumeric(range[\"@_PointSize\"]);\n        // ENHANCED: Extract leading with proper processing\n        const rawLeading = range[\"@_Leading\"];\n        formatting.leading = this.processLeadingValue(rawLeading, formatting.fontSize);\n        formatting.leadingType = this.determineLeadingType(rawLeading);\n        // Extract color and style attributes\n        formatting.fillColor = range[\"@_FillColor\"];\n        formatting.strokeColor = range[\"@_StrokeColor\"];\n        formatting.fontStyle = range[\"@_FontStyle\"];\n        // Extract advanced typography attributes\n        formatting.tracking = IDMLUtils.parseNumeric(range[\"@_Tracking\"]);\n        formatting.baselineShift = IDMLUtils.parseNumeric(range[\"@_BaselineShift\"]);\n        formatting.kerning = IDMLUtils.parseNumeric(range[\"@_Kerning\"]);\n        formatting.horizontalScale = IDMLUtils.parseNumeric(range[\"@_HorizontalScale\"]) || 100;\n        formatting.verticalScale = IDMLUtils.parseNumeric(range[\"@_VerticalScale\"]) || 100;\n        // Extract paragraph-level attributes if present\n        // CRITICAL FIX: Only set alignment if explicitly specified, allowing paragraph inheritance\n        const explicitAlignment = range[\"@_Justification\"] || range[\"@_Alignment\"];\n        if (explicitAlignment) {\n            formatting.alignment = explicitAlignment;\n        }\n        formatting.leftIndent = IDMLUtils.parseNumeric(range[\"@_LeftIndent\"]);\n        formatting.rightIndent = IDMLUtils.parseNumeric(range[\"@_RightIndent\"]);\n        formatting.firstLineIndent = IDMLUtils.parseNumeric(range[\"@_FirstLineIndent\"]);\n        formatting.spaceBefore = IDMLUtils.parseNumeric(range[\"@_SpaceBefore\"]);\n        formatting.spaceAfter = IDMLUtils.parseNumeric(range[\"@_SpaceAfter\"]);\n        // Calculate effective line height for CSS\n        formatting.effectiveLineHeight = this.calculateEffectiveLineHeight(formatting);\n        return formatting;\n    }\n    // NEW: Process leading values with InDesign-specific logic\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = IDMLUtils.parseNumeric(rawLeading);\n        if (numericLeading) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (IDMLUtils.parseNumeric(rawLeading)) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(formatting) {\n        const fontSize = formatting.fontSize || 12;\n        const leading = formatting.leading;\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\") {\n            // Convert points to CSS line-height ratio\n            return leading / fontSize;\n        }\n        return 1.2; // Fallback\n    }\n    extractTextFormatting(storyData) {\n        const formatting = {\n            paragraphStyles: [],\n            characterStyles: [],\n            appliedStyles: []\n        };\n        // Extract applied paragraph styles\n        if (storyData.ParagraphStyleRange) {\n            const ranges = Array.isArray(storyData.ParagraphStyleRange) ? storyData.ParagraphStyleRange : [\n                storyData.ParagraphStyleRange\n            ];\n            ranges.forEach((range)=>{\n                const appliedStyle = range[\"@_AppliedParagraphStyle\"];\n                if (appliedStyle && !formatting.paragraphStyles.includes(appliedStyle)) {\n                    formatting.paragraphStyles.push(appliedStyle);\n                }\n                // Extract character styles within paragraph ranges\n                if (range.CharacterStyleRange) {\n                    const charRanges = Array.isArray(range.CharacterStyleRange) ? range.CharacterStyleRange : [\n                        range.CharacterStyleRange\n                    ];\n                    charRanges.forEach((charRange)=>{\n                        const charStyle = charRange[\"@_AppliedCharacterStyle\"];\n                        if (charStyle && !formatting.characterStyles.includes(charStyle)) {\n                            formatting.characterStyles.push(charStyle);\n                        }\n                    });\n                }\n            });\n        }\n        return formatting;\n    }\n    // Add this method to debug raw story content\n    debugRawStoryContent(storyData) {\n        console.log(\"\\n\\uD83D\\uDD0D RAW STORY CONTENT DEBUG:\");\n        console.log(\"Story keys:\", Object.keys(storyData));\n        const findCharacterRanges = function(obj) {\n            let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key === \"CharacterStyleRange\") {\n                        console.log(\"\\n\\uD83D\\uDCDD Found CharacterStyleRange at \".concat(path, \":\"), obj[key]);\n                        const ranges = Array.isArray(obj[key]) ? obj[key] : [\n                            obj[key]\n                        ];\n                        ranges.forEach((range, index)=>{\n                            console.log(\"  Range \".concat(index + 1, \" attributes:\"), Object.keys(range).filter((k)=>k.startsWith(\"@_\")));\n                            console.log(\"  Range \".concat(index + 1, \" font info:\"), {\n                                AppliedFont: range[\"@_AppliedFont\"],\n                                FontStyle: range[\"@_FontStyle\"],\n                                PointSize: range[\"@_PointSize\"]\n                            });\n                        });\n                    } else if (typeof obj[key] === \"object\") {\n                        findCharacterRanges(obj[key], \"\".concat(path, \".\").concat(key));\n                    }\n                });\n            }\n        };\n        findCharacterRanges(storyData);\n    }\n    getStories() {\n        return this.stories;\n    }\n    getStory(storyId) {\n        return this.stories[storyId];\n    }\n    clearStories() {\n        this.stories = {};\n    }\n    constructor(styleParser){\n        this.styleParser = styleParser;\n        this.stories = {};\n    }\n}\nmodule.exports = StoryParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGFyc2Vycy9TdG9yeVBhcnNlci5qcz82OGNmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL0lETUxVdGlscycpO1xyXG5cclxuY2xhc3MgU3RvcnlQYXJzZXIge1xyXG4gIGNvbnN0cnVjdG9yKHN0eWxlUGFyc2VyKSB7XHJcbiAgICB0aGlzLnN0eWxlUGFyc2VyID0gc3R5bGVQYXJzZXI7XHJcbiAgICB0aGlzLnN0b3JpZXMgPSB7fTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHBhcnNlU3RvcnlGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OdIFBhcnNpbmcgc3Rvcnk6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcclxuICAgICAgY29uc3Qgc3RvcnlJZCA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUsICcueG1sJyk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzdG9yeURhdGEgPSBwYXJzZWQuU3RvcnkgfHwgcGFyc2VkO1xyXG4gICAgICBcclxuICAgICAgLy8gQUREIFRIRVNFIFNJTVBMRSBMT0dTIEZJUlNUOlxyXG4gICAgICBjb25zb2xlLmxvZygnPT09IFNJTVBMRSBERUJVRyBURVNUID09PScpO1xyXG4gICAgICBjb25zb2xlLmxvZygnU3RvcnkgZmlsZSBuYW1lOicsIGZpbGVOYW1lKTtcclxuICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCBzdG9yeSBrZXlzOicsIE9iamVjdC5rZXlzKHN0b3J5RGF0YSkpO1xyXG4gICAgICBjb25zb2xlLmxvZygnUmF3IHN0b3J5IGRhdGEgc2FtcGxlOicsIEpTT04uc3RyaW5naWZ5KHN0b3J5RGF0YSwgbnVsbCwgMikuc3Vic3RyaW5nKDAsIDUwMCkpO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBkZXRhaWxlZCBzdG9yeSBpbmZvcm1hdGlvblxyXG4gICAgICBjb25zdCBkZXRhaWxlZFN0b3J5ID0ge1xyXG4gICAgICAgIHNlbGY6IHN0b3J5RGF0YVsnQF9TZWxmJ10sXHJcbiAgICAgICAgYXBwbGllZFRPQ1N0eWxlOiBzdG9yeURhdGFbJ0BfQXBwbGllZFRPQ1N0eWxlJ10gfHwgJ24nLFxyXG4gICAgICAgIHVzZXJUZXh0OiBzdG9yeURhdGFbJ0BfVXNlclRleHQnXSAhPT0gZmFsc2UsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXh0cmFjdCBzdG9yeSBjb250ZW50IHdpdGggZm9ybWF0dGluZ1xyXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50KHN0b3J5RGF0YSksXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXh0cmFjdCB0ZXh0IGZvcm1hdHRpbmdcclxuICAgICAgICB0ZXh0Rm9ybWF0dGluZzogdGhpcy5leHRyYWN0VGV4dEZvcm1hdHRpbmcoc3RvcnlEYXRhKVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2xlYW5TdG9yeUlkID0gc3RvcnlJZC5yZXBsYWNlKCdTdG9yeV8nLCAnJyk7XHJcbiAgICAgIHRoaXMuc3Rvcmllc1tjbGVhblN0b3J5SWRdID0gZGV0YWlsZWRTdG9yeTtcclxuICAgICAgXHJcbiAgICAgIC8vIEVuaGFuY2VkIGxvZ2dpbmcgdG8gc2hvdyBsaW5lIGJyZWFrc1xyXG4gICAgICBjb25zdCB7IHBsYWluVGV4dCwgbGluZUJyZWFrSW5mbyB9ID0gZGV0YWlsZWRTdG9yeS5jb250ZW50O1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFN0b3J5ICR7c3RvcnlJZH0gcGFyc2VkOmApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBDaGFyYWN0ZXJzOiAke3BsYWluVGV4dC5sZW5ndGh9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIFdvcmRzOiAke2RldGFpbGVkU3RvcnkuY29udGVudC53b3JkQ291bnR9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIExpbmUgYnJlYWtzOiAke2xpbmVCcmVha0luZm8/LmxpbmVCcmVha0NvdW50IHx8IDB9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIFRleHQgcHJldmlldzogXCIke3BsYWluVGV4dC5zdWJzdHJpbmcoMCwgNTApLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKX0uLi5cImApO1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBwYXJzaW5nIHN0b3J5ICR7ZmlsZU5hbWV9OmAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVwbGFjZSB0aGUgZXhpc3RpbmcgZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50IG1ldGhvZCB3aXRoIHRoaXMgY29ycmVjdGVkIHZlcnNpb25cclxuICBleHRyYWN0RGV0YWlsZWRTdG9yeUNvbnRlbnQoc3RvcnlEYXRhKSB7XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgbGV0IGZvcm1hdHRlZENvbnRlbnQgPSBbXTtcclxuICAgIGxldCB0ZXh0Q29sb3IgPSBudWxsO1xyXG4gICAgbGV0IGRlYnVnSW5mbyA9IFtdO1xyXG4gICAgXHJcbiAgICBjb25zdCBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5ID0gKGVsZW1lbnQsIGRlcHRoID0gMCwgY29udGV4dCA9IHt9KSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb250ZW50ICs9IGVsZW1lbnQ7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyBFTkhBTkNFRDogU3BlY2lhbCBoYW5kbGluZyBmb3IgQ2hhcmFjdGVyU3R5bGVSYW5nZSB3aXRoIHNvcGhpc3RpY2F0ZWQgQnIgZGV0ZWN0aW9uXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpID8gXHJcbiAgICAgICAgICAgIGVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZSA6IFtlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTSU1QTElGSUVEIERFQlVHOiBKdXN0IGxvZyBwcm9ibGVtYXRpYyB0ZXh0IHJhbmdlc1xyXG4gICAgICAgICAgY29uc3QgYWxsUmFuZ2VDb250ZW50ID0gcmFuZ2VzLm1hcChyID0+IHIuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShyLkNvbnRlbnQpID8gci5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKHIuQ29udGVudCkpIDogJycpLmpvaW4oJycpO1xyXG4gICAgICAgICAgaWYgKGFsbFJhbmdlQ29udGVudC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykgfHwgYWxsUmFuZ2VDb250ZW50LmluY2x1ZGVzKCdwYScpIHx8IGFsbFJhbmdlQ29udGVudC5pbmNsdWRlcygndm9sdXB0dXNkYScpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5qoIEZPVU5EIFJBTkdFUyBXSVRIIFBST0JMRU1BVElDIFRFWFQ6Jyk7XHJcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmFuZ2UuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudCkgPyByYW5nZS5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKHJhbmdlLkNvbnRlbnQpKSA6ICcnO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBSYW5nZSAke2luZGV4fTogXCIke2NvbnRlbnR9XCJgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgcmFuZ2VJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBFeHRyYWN0IGRpcmVjdCBmb250IHJlZmVyZW5jZXMgZnJvbSB0aGUgWE1MIHJhbmdlXHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdEZvbnRSZWYgPSByYW5nZVsnQF9BcHBsaWVkRm9udCddIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVsnQF9Gb250RmFtaWx5J10gfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWydAX0ZvbnQnXSB8fCAnJztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7XHJcbiAgICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ10gfHwgY29udGV4dC5hcHBsaWVkU3R5bGUgfHwgbnVsbCxcclxuICAgICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZTogcmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgICBmb250U2l6ZTogcmFuZ2VbJ0BfUG9pbnRTaXplJ10gPyBwYXJzZUZsb2F0KHJhbmdlWydAX1BvaW50U2l6ZSddKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgZm9udFJlZmVyZW5jZTogZGlyZWN0Rm9udFJlZixcclxuICAgICAgICAgICAgICBmaWxsQ29sb3I6IHJhbmdlWydAX0ZpbGxDb2xvciddIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgZm9udFN0eWxlOiByYW5nZVsnQF9Gb250U3R5bGUnXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogSW5oZXJpdCBwYXJhZ3JhcGggYWxpZ25tZW50IGZyb20gY29udGV4dCBpZiBub3QgZXhwbGljaXRseSBzZXRcclxuICAgICAgICAgICAgICBhbGlnbm1lbnQ6IHJhbmdlWydAX0p1c3RpZmljYXRpb24nXSB8fCByYW5nZVsnQF9BbGlnbm1lbnQnXSB8fCBjb250ZXh0LnBhcmFncmFwaEFsaWdubWVudCB8fCBudWxsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBERUJVRzogTG9nIGZvcm1hdHRpbmcgZXh0cmFjdGlvbiBmb3IgYW55IHN0eWxlZCB0ZXh0IChnZW5lcmljIGNoZWNrKVxyXG4gICAgICAgICAgICBjb25zdCByYW5nZUNvbnRlbnQgPSByYW5nZS5Db250ZW50ID8gXHJcbiAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudCkgPyByYW5nZS5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKHJhbmdlLkNvbnRlbnQpKSA6ICcnO1xyXG4gICAgICAgICAgICBjb25zdCBoYXNTdHlsZUluZm8gPSByYW5nZVsnQF9Gb250U3R5bGUnXSB8fCByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50WydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddIHx8IHJhbmdlWydAX0FwcGxpZWRGb250J107XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaGFzU3R5bGVJbmZvICYmIHJhbmdlQ29udGVudC50cmltKCkpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UpyBTdG9yeVBhcnNlciAtIEV4dHJhY3RpbmcgZm9ybWF0dGluZyBmb3IgcmFuZ2U6JywgSlNPTi5zdHJpbmdpZnkocmFuZ2VDb250ZW50LnN1YnN0cmluZygwLCAzMCkgKyAnLi4uJyksIHtcclxuICAgICAgICAgICAgICAgIHJhd1JhbmdlQXR0cmlidXRlczogT2JqZWN0LmtleXMocmFuZ2UpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnQF8nKSksXHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRGb3JtYXR0aW5nOiBmb3JtYXR0aW5nLFxyXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlRnJvbVhNTDogcmFuZ2VbJ0BfRm9udFN0eWxlJ10sXHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZUZyb21YTUw6IHJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddLFxyXG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGVGcm9tWE1MOiBlbGVtZW50WydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkRm9ybWF0dGluZyA9IHRoaXMuc3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZJWEVEOiBQcm9jZXNzIGNvbnRlbnQgd2l0aCBwcm9wZXIgc3BhY2UgcHJlc2VydmF0aW9uXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5Db250ZW50KSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudCA6IFtyYW5nZS5Db250ZW50XTtcclxuICAgICAgICAgICAgICBjb250ZW50cy5mb3JFYWNoKChjb250ZW50SXRlbSwgY29udGVudEluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gSURNTFV0aWxzLmRlY29kZVhNTEVudGl0aWVzKFN0cmluZyhjb250ZW50SXRlbSkpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBDaGVjayBmb3IgQnIgZWxlbWVudHMgQUZURVIgZWFjaCBjb250ZW50IGl0ZW0gd2l0aGluIHRoZSBzYW1lIHJhbmdlXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCAmJiBjb250ZW50SW5kZXggPCBjb250ZW50cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSAnXFxuJztcclxuICAgICAgICAgICAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzogeyBcclxuICAgICAgICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYmV0d2Vlbl9jb250ZW50JyxcclxuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ0JyIGVsZW1lbnQgd2l0aGluIHJhbmdlJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0xpbmUgYnJlYWsgZGV0ZWN0ZWQgd2l0aGluIGNvbnRlbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQ2hhcmFjdGVyU3R5bGVSYW5nZVske3JhbmdlSW5kZXh9XSwgYmV0d2VlbiBjb250ZW50WyR7Y29udGVudEluZGV4fV0gYW5kIGNvbnRlbnRbJHtjb250ZW50SW5kZXggKyAxfV1gLFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBCciBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSByYW5nZVxyXG4gICAgICAgICAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCAmJiAoIXJhbmdlLkNvbnRlbnQgfHwgQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA9PT0gZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgYnJFbGVtZW50cyA9IHRoaXMuZXh0cmFjdEJyRWxlbWVudHMocmFuZ2UpO1xyXG4gICAgICAgICAgICAgIGJyRWxlbWVudHMuZm9yRWFjaCgoYnJJbmZvLCBickluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gdGhpcy5kZXRlcm1pbmVMaW5lQnJlYWtUeXBlKGJySW5mbywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGxpbmVCcmVha1RleHQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHQsXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHsgXHJcbiAgICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6IGJySW5mby50eXBlIHx8ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYnJJbmZvLnBvc2l0aW9uIHx8ICdlbmQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ0JyIGVsZW1lbnQgYXQgZW5kIG9mIHJhbmdlJ1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnTGluZSBicmVhayBkZXRlY3RlZCBhdCBlbmQgb2YgcmFuZ2UnLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYENoYXJhY3RlclN0eWxlUmFuZ2VbJHtyYW5nZUluZGV4fV0sIEJyWyR7YnJJbmRleH1dYCxcclxuICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiBickluZm8udHlwZSB8fCAnbGluZScsXHJcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IEFkZCBzcGFjZSBiZXR3ZWVuIGNoYXJhY3RlciBzdHlsZSByYW5nZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChyYW5nZUluZGV4IDwgcmFuZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0UmFuZ2UgPSByYW5nZXNbcmFuZ2VJbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIE1vcmUgcm9idXN0IHNwYWNlIGRldGVjdGlvblxyXG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gY29udGVudC5zbGljZSgtMTApOyAvLyBDaGVjayBsYXN0IDEwIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlID0gL1xccyQvLnRlc3QoY3VycmVudFRleHQpOyAvLyBBbnkgd2hpdGVzcGFjZSBhdCBlbmRcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0Q29udGVudCA9IG5leHRSYW5nZS5Db250ZW50ID8gXHJcbiAgICAgICAgICAgICAgICBTdHJpbmcoQXJyYXkuaXNBcnJheShuZXh0UmFuZ2UuQ29udGVudCkgPyBuZXh0UmFuZ2UuQ29udGVudFswXSA6IG5leHRSYW5nZS5Db250ZW50KSA6ICcnO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSA9IC9eXFxzLy50ZXN0KG5leHRDb250ZW50KTsgLy8gQW55IHdoaXRlc3BhY2UgYXQgc3RhcnRcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBBR0dSRVNTSVZFIEZJWDogQWRkIHNwYWNlIGJldHdlZW4gQUxMIHJhbmdlcyB1bmxlc3MgZXhwbGljaXRseSBub3QgbmVlZGVkXHJcbiAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2tpcFNwYWNlID0gY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsocmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFuZXh0UmFuZ2UuQ29udGVudCB8fCAvLyBTa2lwIGlmIG5leHQgcmFuZ2UgaGFzIG5vIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb250ZW50LnRyaW0oKSA9PT0gJyc7IC8vIFNraXAgaWYgbmV4dCBjb250ZW50IGlzIG9ubHkgd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGlmICghc2hvdWxkU2tpcFNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGUgPSByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U3R5bGUgPSBuZXh0UmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFjZVRleHQgPSAnICc7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IHNwYWNlVGV4dDtcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHNwYWNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzU3BhY2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGUgcmFuZ2VzIChhZ2dyZXNzaXZlKScsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdHlsZVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnU3BhY2UgaW5zZXJ0ZWQgYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGVzIChhZ2dyZXNzaXZlKScsXHJcbiAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQmV0d2VlbiByYW5nZXMgJHtyYW5nZUluZGV4fSBhbmQgJHtyYW5nZUluZGV4ICsgMX1gLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgIG5leHRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgcmVhc29uOiAnRGVmYXVsdCBzcGFjZSBpbnNlcnRpb24gLSB3b3JkcyBsaWtlbHkgc3BsaXQgYWNyb3NzIHJhbmdlcycsXHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0RW5kOiBjdXJyZW50VGV4dC5zbGljZSgtNSksXHJcbiAgICAgICAgICAgICAgICAgIG5leHRUZXh0U3RhcnQ6IG5leHRDb250ZW50LnNsaWNlKDAsIDUpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnU3BhY2UgaW5zZXJ0aW9uIHNraXBwZWQnLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7cmFuZ2VJbmRleCArIDF9YCxcclxuICAgICAgICAgICAgICAgICAgcmVhc29uOiBjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlID8gJ0N1cnJlbnQgcmFuZ2UgZW5kcyB3aXRoIHNwYWNlJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJhbmdlU3RhcnRzV2l0aFNwYWNlID8gJ05leHQgcmFuZ2Ugc3RhcnRzIHdpdGggc3BhY2UnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAhbmV4dFJhbmdlLkNvbnRlbnQgPyAnTmV4dCByYW5nZSBoYXMgbm8gY29udGVudCcgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29udGVudC50cmltKCkgPT09ICcnID8gJ05leHQgY29udGVudCBpcyBvbmx5IHdoaXRlc3BhY2UnIDogJ0xpbmUgYnJlYWsgd291bGQgYmUgaW5zZXJ0ZWQnLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dEVuZDogY3VycmVudFRleHQuc2xpY2UoLTUpLFxyXG4gICAgICAgICAgICAgICAgICBuZXh0VGV4dFN0YXJ0OiBuZXh0Q29udGVudC5zbGljZSgwLCA1KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBleHBsaWNpdCBsaW5lIGJyZWFrcyBiZXR3ZWVuIHJhbmdlcyAoZm9yIGNhc2VzIHdoZXJlIHNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrIGlzIHRydWUpXHJcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsocmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltcGxpY2l0QnJlYWsgPSAnXFxuJztcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gaW1wbGljaXRCcmVhaztcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGltcGxpY2l0QnJlYWssXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogJ2ltcGxpY2l0JyxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdiZXR3ZWVuIHJhbmdlcydcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ0ltcGxpY2l0IGxpbmUgYnJlYWsnLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7cmFuZ2VJbmRleCArIDF9YFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgY29udGludWUgcHJvY2Vzc2luZyB0byBhdm9pZCBkdXBsaWNhdGlvblxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBFTkhBTkNFRDogSGFuZGxlIFBhcmFncmFwaFN0eWxlUmFuZ2Ugd2l0aCBjb250ZXh0XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2UpID8gXHJcbiAgICAgICAgICAgIGVsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZSA6IFtlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaENvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgLi4uY29udGV4dCxcclxuICAgICAgICAgICAgICBwYXJhZ3JhcGhJbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgdG90YWxQYXJhZ3JhcGhzOiByYW5nZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgIGFwcGxpZWRTdHlsZTogcmFuZ2VbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ10sXHJcbiAgICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBQYXNzIGRvd24gZGlyZWN0IHBhcmFncmFwaC1sZXZlbCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgICBwYXJhZ3JhcGhBbGlnbm1lbnQ6IHJhbmdlWydAX0p1c3RpZmljYXRpb24nXSB8fCByYW5nZVsnQF9BbGlnbm1lbnQnXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZXh0cmFjdFRleHRSZWN1cnNpdmVseShyYW5nZSwgZGVwdGggKyAxLCBwYXJhZ3JhcGhDb250ZXh0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFkZCBwYXJhZ3JhcGggYnJlYWsgYmV0d2VlbiBwYXJhZ3JhcGhzIChidXQgbm90IGFmdGVyIHRoZSBsYXN0IG9uZSlcclxuICAgICAgICAgICAgaWYgKGluZGV4IDwgcmFuZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhCcmVhayA9ICdcXG4nO1xyXG4gICAgICAgICAgICAgIGNvbnRlbnQgKz0gcGFyYWdyYXBoQnJlYWs7XHJcbiAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcmFncmFwaEJyZWFrLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdwYXJhZ3JhcGgnLFxyXG4gICAgICAgICAgICAgICAgICBzb3VyY2U6ICdiZXR3ZWVuIHBhcmFncmFwaHMnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goeyBcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdQYXJhZ3JhcGggYnJlYWsnLCBcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgYmV0d2VlbiBwYXJhZ3JhcGhzICR7aW5kZXh9IGFuZCAke2luZGV4ICsgMX1gIFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSGFuZGxlIGRpcmVjdCBDb250ZW50IGVsZW1lbnRzICh3aGVuIG5vdCBpbnNpZGUgQ2hhcmFjdGVyU3R5bGVSYW5nZSlcclxuICAgICAgICBpZiAoZWxlbWVudC5Db250ZW50ICYmICFlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGxldCB0ZXh0ID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkNvbnRlbnQpID8gZWxlbWVudC5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKGVsZW1lbnQuQ29udGVudCk7XHJcbiAgICAgICAgICB0ZXh0ID0gSURNTFV0aWxzLmRlY29kZVhNTEVudGl0aWVzKHRleHQpO1xyXG4gICAgICAgICAgY29udGVudCArPSB0ZXh0O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBmb3JtYXR0aW5nID0ge1xyXG4gICAgICAgICAgICBwYXJhZ3JhcGhTdHlsZTogZWxlbWVudFsnQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGUnXSB8fCBjb250ZXh0LmFwcGxpZWRTdHlsZSB8fCBudWxsLFxyXG4gICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZTogZWxlbWVudFsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCBudWxsLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogZWxlbWVudFsnQF9Qb2ludFNpemUnXSB8fCBudWxsLFxyXG4gICAgICAgICAgICBmb250RmFtaWx5OiBlbGVtZW50WydAX0FwcGxpZWRGb250J10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZmlsbENvbG9yOiBlbGVtZW50WydAX0ZpbGxDb2xvciddIHx8IG51bGwsXHJcbiAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogSW5oZXJpdCBwYXJhZ3JhcGggYWxpZ25tZW50IGZyb20gY29udGV4dCBpZiBub3QgZXhwbGljaXRseSBzZXRcclxuICAgICAgICAgICAgYWxpZ25tZW50OiBlbGVtZW50WydAX0p1c3RpZmljYXRpb24nXSB8fCBlbGVtZW50WydAX0FsaWdubWVudCddIHx8IGNvbnRleHQucGFyYWdyYXBoQWxpZ25tZW50IHx8IG51bGxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRGb3JtYXR0aW5nID0gdGhpcy5zdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nKGZvcm1hdHRpbmcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICBmb3JtYXR0aW5nOiByZXNvbHZlZEZvcm1hdHRpbmdcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBFTkhBTkNFRDogRGlyZWN0IEJyIGVsZW1lbnQgaGFuZGxpbmcgKG91dHNpZGUgb2YgcmFuZ2VzKVxyXG4gICAgICAgIGlmIChlbGVtZW50LkJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGJyRWxlbWVudHMgPSBBcnJheS5pc0FycmF5KGVsZW1lbnQuQnIpID8gZWxlbWVudC5CciA6IFtlbGVtZW50LkJyXTtcclxuICAgICAgICAgIGJyRWxlbWVudHMuZm9yRWFjaCgoYnIsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSAnXFxuJztcclxuICAgICAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHQsXHJcbiAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogJ2V4cGxpY2l0JyxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogJ2RpcmVjdCBCciBlbGVtZW50J1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICB0eXBlOiAnRGlyZWN0IEJyIGVsZW1lbnQnLFxyXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiBgRGlyZWN0IGVsZW1lbnQsIGluZGV4ICR7aW5kZXh9YFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDb250aW51ZSB3aXRoIG90aGVyIG5lc3RlZCBlbGVtZW50c1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGVsZW1lbnQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aCgnQF8nKSAmJiBcclxuICAgICAgICAgICAgICBrZXkgIT09ICdDb250ZW50JyAmJiBcclxuICAgICAgICAgICAgICBrZXkgIT09ICdCcicgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQ2hhcmFjdGVyU3R5bGVSYW5nZScgJiZcclxuICAgICAgICAgICAgICBrZXkgIT09ICdQYXJhZ3JhcGhTdHlsZVJhbmdlJykge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGl0ZW0gPT4gZXh0cmFjdFRleHRSZWN1cnNpdmVseShpdGVtLCBkZXB0aCArIDEsIGNvbnRleHQpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIGRlcHRoIDwgMTApIHtcclxuICAgICAgICAgICAgICBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5KHZhbHVlLCBkZXB0aCArIDEsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkoc3RvcnlEYXRhKTtcclxuICAgIFxyXG4gICAgLy8gRU5IQU5DRUQ6IFByb2Nlc3MgYW5kIGNsZWFuIHVwIHRoZSBjb250ZW50IHdpdGggc29waGlzdGljYXRlZCBsaW5lIGJyZWFrIHByZXNlcnZhdGlvblxyXG4gICAgY29uc3QgcHJvY2Vzc2VkQ29udGVudCA9IElETUxVdGlscy5zb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyhjb250ZW50KTtcclxuICAgIFxyXG4gICAgLy8gREVCVUc6IExvZyBzcGFjZSBwcmVzZXJ2YXRpb24gcmVzdWx0c1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk50gVGV4dCBleHRyYWN0aW9uIHJlc3VsdHM6Jyk7XHJcbiAgICBjb25zb2xlLmxvZygnICAgLSBPcmlnaW5hbCBjb250ZW50IGxlbmd0aDonLCBjb250ZW50Lmxlbmd0aCk7XHJcbiAgICBjb25zb2xlLmxvZygnICAgLSBQcm9jZXNzZWQgY29udGVudCBsZW5ndGg6JywgcHJvY2Vzc2VkQ29udGVudC5sZW5ndGgpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gU3BhY2UgcHJlc2VydmF0aW9uIGV2ZW50czonLCBkZWJ1Z0luZm8uZmlsdGVyKGluZm8gPT4gaW5mby50eXBlLmluY2x1ZGVzKCdTcGFjZSBpbnNlcnRlZCcpKS5sZW5ndGgpO1xyXG4gICAgXHJcbiAgICAvLyBTUEVDSUZJQyBERUJVRzogQ2hlY2sgZm9yIHRoZSBwcm9ibGVtYXRpYyBcInBhdm9sdXB0dXNkYVwiIHRleHQgKHNpbXBsaWZpZWQpXHJcbiAgICBpZiAocHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykgfHwgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygncGEnKSAmJiBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCd2b2x1cHR1c2RhJykpIHtcclxuICAgICAgY29uc29sZS5sb2coJ/CfmqggRk9VTkQgUFJPQkxFTUFUSUMgVEVYVDonKTtcclxuICAgICAgY29uc29sZS5sb2coJyAgIC0gQ29udGFpbnMgXCJwYXZvbHVwdHVzZGFcIjonLCBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCdwYXZvbHVwdHVzZGEnKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIENvbnRhaW5zIFwicGEgdm9sdXB0dXNkYVwiOicsIHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3BhIHZvbHVwdHVzZGEnKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIEZvcm1hdHRlZENvbnRlbnQgYnJlYWtkb3duOicsIGZvcm1hdHRlZENvbnRlbnQubWFwKGl0ZW0gPT4gaXRlbS50ZXh0KS5qb2luKCd8JykpO1xyXG4gICAgfVxyXG4gICAgXHJcblxyXG4gICAgXHJcbiAgICBjb25zdCBsaW5lQnJlYWtJbmZvID0ge1xyXG4gICAgICBoYXNMaW5lQnJlYWtzOiBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCdcXG4nKSxcclxuICAgICAgbGluZUJyZWFrQ291bnQ6IChwcm9jZXNzZWRDb250ZW50Lm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aCxcclxuICAgICAgbGluZUJyZWFrVHlwZXM6IHRoaXMuYW5hbHl6ZUxpbmVCcmVha1R5cGVzKGZvcm1hdHRlZENvbnRlbnQpLFxyXG4gICAgICBkZWJ1Z0luZm86IGRlYnVnSW5mbyxcclxuICAgICAgc3BhY2VQcmVzZXJ2YXRpb25Db3VudDogZGVidWdJbmZvLmZpbHRlcihpbmZvID0+IGluZm8udHlwZS5pbmNsdWRlcygnU3BhY2UgaW5zZXJ0ZWQnKSkubGVuZ3RoXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwbGFpblRleHQ6IHByb2Nlc3NlZENvbnRlbnQsXHJcbiAgICAgIGZvcm1hdHRlZENvbnRlbnQ6IGZvcm1hdHRlZENvbnRlbnQuZmlsdGVyKGl0ZW0gPT4gaXRlbS50ZXh0ICYmIGl0ZW0udGV4dC5sZW5ndGggPiAwKSxcclxuICAgICAgd29yZENvdW50OiBJRE1MVXRpbHMuY291bnRXb3Jkcyhwcm9jZXNzZWRDb250ZW50LnJlcGxhY2UoL1xcbi9nLCAnICcpKSxcclxuICAgICAgY2hhcmFjdGVyQ291bnQ6IHByb2Nlc3NlZENvbnRlbnQubGVuZ3RoLFxyXG4gICAgICB0ZXh0Q29sb3I6IHRleHRDb2xvcixcclxuICAgICAgbGluZUJyZWFrSW5mbzogbGluZUJyZWFrSW5mb1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEFkZCB0aGlzIGhlbHBlciBtZXRob2QgdG8gYmV0dGVyIGhhbmRsZSBtaXhlZCBjb250ZW50IGFuZCBCciBlbGVtZW50c1xyXG4gIGFuYWx5emVDb250ZW50U3RydWN0dXJlKHJhbmdlKSB7XHJcbiAgICBjb25zdCBzdHJ1Y3R1cmUgPSB7XHJcbiAgICAgIGhhc0NvbnRlbnQ6ICEhcmFuZ2UuQ29udGVudCxcclxuICAgICAgaGFzQnI6IHJhbmdlLkJyICE9PSB1bmRlZmluZWQsXHJcbiAgICAgIGNvbnRlbnRJdGVtczogcmFuZ2UuQ29udGVudCA/IChBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudCA6IFtyYW5nZS5Db250ZW50XSkgOiBbXSxcclxuICAgICAgYnJFbGVtZW50czogcmFuZ2UuQnIgPyAoQXJyYXkuaXNBcnJheShyYW5nZS5CcikgPyByYW5nZS5CciA6IFtyYW5nZS5Ccl0pIDogW11cclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdDb250ZW50IHN0cnVjdHVyZSBhbmFseXNpczonLCBzdHJ1Y3R1cmUpO1xyXG4gICAgcmV0dXJuIHN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIGhlbHBlciBmb3IgcHJvY2Vzc2luZyBpbnRlcmxlYXZlZCBjb250ZW50IGFuZCBicmVha3NcclxuICBwcm9jZXNzSW50ZXJsZWF2ZWRDb250ZW50KHJhbmdlLCByZXNvbHZlZEZvcm1hdHRpbmcpIHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBcclxuICAgIC8vIFRoaXMgbWV0aG9kIHdvdWxkIG5lZWQgYWNjZXNzIHRvIHRoZSBhY3R1YWwgWE1MIHN0cnVjdHVyZSB0byBkZXRlcm1pbmVcclxuICAgIC8vIHRoZSBleGFjdCBvcmRlciBvZiBDb250ZW50IGFuZCBCciBlbGVtZW50cy4gRm9yIG5vdywgd2UnbGwgdXNlIHRoZSBcclxuICAgIC8vIGFwcHJvYWNoIGFib3ZlIHdoaWNoIGhhbmRsZXMgdGhlIG1vc3QgY29tbW9uIGNhc2UuXHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogSGVscGVyIG1ldGhvZCB0byBleHRyYWN0IEJyIGVsZW1lbnRzIHdpdGggY29udGV4dFxyXG4gIGV4dHJhY3RCckVsZW1lbnRzKHJhbmdlKSB7XHJcbiAgICBjb25zdCBickVsZW1lbnRzID0gW107XHJcbiAgICBcclxuICAgIGlmIChyYW5nZS5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhbmdlLkJyKSkge1xyXG4gICAgICAgIHJhbmdlLkJyLmZvckVhY2goKGJyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgYnJFbGVtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogaW5kZXggPT09IDAgPyAnc3RhcnQnIDogJ21pZGRsZScsXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IGJyXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBickVsZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxyXG4gICAgICAgICAgZWxlbWVudDogcmFuZ2UuQnJcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gYnJFbGVtZW50cztcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgbGluZSBicmVhayB0eXBlXHJcbiAgZGV0ZXJtaW5lTGluZUJyZWFrVHlwZShickluZm8sIGNvbnRleHQpIHtcclxuICAgIC8vIERpZmZlcmVudCBsaW5lIGJyZWFrIGNoYXJhY3RlcnMgYmFzZWQgb24gY29udGV4dFxyXG4gICAgc3dpdGNoIChickluZm8udHlwZSkge1xyXG4gICAgICBjYXNlICdwYXJhZ3JhcGgnOlxyXG4gICAgICAgIHJldHVybiAnXFxuXFxuJzsgLy8gRG91YmxlIGxpbmUgYnJlYWsgZm9yIHBhcmFncmFwaCBzZXBhcmF0aW9uXHJcbiAgICAgIGNhc2UgJ2ZvcmNlZCc6XHJcbiAgICAgICAgcmV0dXJuICdcXG4nOyAvLyBGb3JjZWQgbGluZSBicmVhayAoU2hpZnQrRW50ZXIgZXF1aXZhbGVudClcclxuICAgICAgY2FzZSAnbGluZSc6XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuICdcXG4nOyAvLyBTdGFuZGFyZCBsaW5lIGJyZWFrXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBEZXRlcm1pbmUgaWYgYW4gaW1wbGljaXQgbGluZSBicmVhayBzaG91bGQgYmUgaW5zZXJ0ZWRcclxuICBzaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayhjdXJyZW50UmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkge1xyXG4gICAgLy8gRG9uJ3QgaW5zZXJ0IGltcGxpY2l0IGJyZWFrcyBpZiBleHBsaWNpdCBCciBlbGVtZW50cyBhcmUgcHJlc2VudFxyXG4gICAgaWYgKGN1cnJlbnRSYW5nZS5CciAhPT0gdW5kZWZpbmVkIHx8IG5leHRSYW5nZS5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSW5zZXJ0IGJyZWFrcyBiZXR3ZWVuIGRpZmZlcmVudCBjaGFyYWN0ZXIgc3R5bGVzIGluIGRpZmZlcmVudCBwYXJhZ3JhcGhzXHJcbiAgICBjb25zdCBjdXJyZW50Q2hhclN0eWxlID0gY3VycmVudFJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddO1xyXG4gICAgY29uc3QgbmV4dENoYXJTdHlsZSA9IG5leHRSYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXTtcclxuICAgIFxyXG4gICAgLy8gSWYgd2UncmUgaW4gYSBjb250ZXh0IHdoZXJlIHN0eWxlcyBjaGFuZ2Ugc2lnbmlmaWNhbnRseSwgYWRkIGEgYnJlYWtcclxuICAgIGlmIChjdXJyZW50Q2hhclN0eWxlICYmIG5leHRDaGFyU3R5bGUgJiYgY3VycmVudENoYXJTdHlsZSAhPT0gbmV4dENoYXJTdHlsZSkge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIG1pZ2h0IGJlIGEgdGl0bGUvaGVhZGluZyBmb2xsb3dlZCBieSBib2R5IHRleHRcclxuICAgICAgY29uc3Qgc3R5bGVJbmRpY2F0ZXNCcmVhayA9IHRoaXMuc3R5bGVJbmRpY2F0ZXNMaW5lQnJlYWsoY3VycmVudENoYXJTdHlsZSwgbmV4dENoYXJTdHlsZSk7XHJcbiAgICAgIHJldHVybiBzdHlsZUluZGljYXRlc0JyZWFrO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBBbmFseXplIGlmIHN0eWxlIGNoYW5nZSBpbmRpY2F0ZXMgYSBsaW5lIGJyZWFrXHJcbiAgc3R5bGVJbmRpY2F0ZXNMaW5lQnJlYWsoY3VycmVudFN0eWxlLCBuZXh0U3R5bGUpIHtcclxuICAgIGNvbnN0IHRpdGxlSW5kaWNhdG9ycyA9IFsndGl0bGUnLCAnaGVhZGluZycsICdoZWFkZXInXTtcclxuICAgIGNvbnN0IGJvZHlJbmRpY2F0b3JzID0gWydib2R5JywgJ3RleHQnLCAnbm9ybWFsJ107XHJcbiAgICBcclxuICAgIGNvbnN0IGN1cnJlbnRJc1RpdGxlID0gdGl0bGVJbmRpY2F0b3JzLnNvbWUoaW5kaWNhdG9yID0+IFxyXG4gICAgICBjdXJyZW50U3R5bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhpbmRpY2F0b3IpKTtcclxuICAgIGNvbnN0IG5leHRJc0JvZHkgPSBib2R5SW5kaWNhdG9ycy5zb21lKGluZGljYXRvciA9PiBcclxuICAgICAgbmV4dFN0eWxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5kaWNhdG9yKSk7XHJcbiAgICBcclxuICAgIHJldHVybiBjdXJyZW50SXNUaXRsZSAmJiBuZXh0SXNCb2R5O1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogQW5hbHl6ZSBsaW5lIGJyZWFrIHR5cGVzIGluIGZvcm1hdHRlZCBjb250ZW50XHJcbiAgYW5hbHl6ZUxpbmVCcmVha1R5cGVzKGZvcm1hdHRlZENvbnRlbnQpIHtcclxuICAgIGNvbnN0IHR5cGVzID0ge1xyXG4gICAgICBleHBsaWNpdDogMCwgICAgICAvLyBGcm9tIDxCci8+IGVsZW1lbnRzXHJcbiAgICAgIGltcGxpY2l0OiAwLCAgICAgIC8vIEluZmVycmVkIGZyb20gc3R5bGUgY2hhbmdlc1xyXG4gICAgICBwYXJhZ3JhcGg6IDAsICAgICAvLyBCZXR3ZWVuIHBhcmFncmFwaHNcclxuICAgICAgZGlyZWN0OiAwICAgICAgICAvLyBEaXJlY3QgQnIgZWxlbWVudHNcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZvcm1hdHRlZENvbnRlbnQuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgaWYgKGl0ZW0uZm9ybWF0dGluZz8uaXNCcmVhaykge1xyXG4gICAgICAgIGNvbnN0IGJyZWFrVHlwZSA9IGl0ZW0uZm9ybWF0dGluZy5icmVha1R5cGUgfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIGlmICh0eXBlcy5oYXNPd25Qcm9wZXJ0eShicmVha1R5cGUpKSB7XHJcbiAgICAgICAgICB0eXBlc1ticmVha1R5cGVdKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHR5cGVzO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdERldGFpbGVkRm9ybWF0dGluZ0Zyb21SYW5nZShyYW5nZSkge1xyXG4gICAgY29uc3QgZm9ybWF0dGluZyA9IHt9O1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGFsbCBwb3NzaWJsZSBmb250IGF0dHJpYnV0ZXNcclxuICAgIGNvbnN0IGZvbnRBdHRyaWJ1dGVzID0gW1xyXG4gICAgICAnQF9BcHBsaWVkRm9udCcsICdAX0ZvbnRGYW1pbHknLCAnQF9Gb250JywgXHJcbiAgICAgICdAX1Bvc3RTY3JpcHROYW1lJywgJ0BfRm9udE5hbWUnXHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICBmb250QXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4ge1xyXG4gICAgICBpZiAocmFuZ2VbYXR0cl0pIHtcclxuICAgICAgICBmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UgPSByYW5nZVthdHRyXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgZm9udCBhbmQgc2l6ZSBhdHRyaWJ1dGVzXHJcbiAgICBmb3JtYXR0aW5nLmZvbnRTaXplID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9Qb2ludFNpemUnXSk7XHJcbiAgICBcclxuICAgIC8vIEVOSEFOQ0VEOiBFeHRyYWN0IGxlYWRpbmcgd2l0aCBwcm9wZXIgcHJvY2Vzc2luZ1xyXG4gICAgY29uc3QgcmF3TGVhZGluZyA9IHJhbmdlWydAX0xlYWRpbmcnXTtcclxuICAgIGZvcm1hdHRpbmcubGVhZGluZyA9IHRoaXMucHJvY2Vzc0xlYWRpbmdWYWx1ZShyYXdMZWFkaW5nLCBmb3JtYXR0aW5nLmZvbnRTaXplKTtcclxuICAgIGZvcm1hdHRpbmcubGVhZGluZ1R5cGUgPSB0aGlzLmRldGVybWluZUxlYWRpbmdUeXBlKHJhd0xlYWRpbmcpO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGNvbG9yIGFuZCBzdHlsZSBhdHRyaWJ1dGVzXHJcbiAgICBmb3JtYXR0aW5nLmZpbGxDb2xvciA9IHJhbmdlWydAX0ZpbGxDb2xvciddO1xyXG4gICAgZm9ybWF0dGluZy5zdHJva2VDb2xvciA9IHJhbmdlWydAX1N0cm9rZUNvbG9yJ107XHJcbiAgICBmb3JtYXR0aW5nLmZvbnRTdHlsZSA9IHJhbmdlWydAX0ZvbnRTdHlsZSddO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGFkdmFuY2VkIHR5cG9ncmFwaHkgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy50cmFja2luZyA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfVHJhY2tpbmcnXSk7XHJcbiAgICBmb3JtYXR0aW5nLmJhc2VsaW5lU2hpZnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0Jhc2VsaW5lU2hpZnQnXSk7XHJcbiAgICBmb3JtYXR0aW5nLmtlcm5pbmcgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0tlcm5pbmcnXSk7XHJcbiAgICBmb3JtYXR0aW5nLmhvcml6b250YWxTY2FsZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfSG9yaXpvbnRhbFNjYWxlJ10pIHx8IDEwMDtcclxuICAgIGZvcm1hdHRpbmcudmVydGljYWxTY2FsZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfVmVydGljYWxTY2FsZSddKSB8fCAxMDA7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgcGFyYWdyYXBoLWxldmVsIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxyXG4gICAgLy8gQ1JJVElDQUwgRklYOiBPbmx5IHNldCBhbGlnbm1lbnQgaWYgZXhwbGljaXRseSBzcGVjaWZpZWQsIGFsbG93aW5nIHBhcmFncmFwaCBpbmhlcml0YW5jZVxyXG4gICAgY29uc3QgZXhwbGljaXRBbGlnbm1lbnQgPSByYW5nZVsnQF9KdXN0aWZpY2F0aW9uJ10gfHwgcmFuZ2VbJ0BfQWxpZ25tZW50J107XHJcbiAgICBpZiAoZXhwbGljaXRBbGlnbm1lbnQpIHtcclxuICAgICAgZm9ybWF0dGluZy5hbGlnbm1lbnQgPSBleHBsaWNpdEFsaWdubWVudDtcclxuICAgIH1cclxuICAgIGZvcm1hdHRpbmcubGVmdEluZGVudCA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfTGVmdEluZGVudCddKTtcclxuICAgIGZvcm1hdHRpbmcucmlnaHRJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1JpZ2h0SW5kZW50J10pO1xyXG4gICAgZm9ybWF0dGluZy5maXJzdExpbmVJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0ZpcnN0TGluZUluZGVudCddKTtcclxuICAgIGZvcm1hdHRpbmcuc3BhY2VCZWZvcmUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1NwYWNlQmVmb3JlJ10pO1xyXG4gICAgZm9ybWF0dGluZy5zcGFjZUFmdGVyID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9TcGFjZUFmdGVyJ10pO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1NcclxuICAgIGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodCA9IHRoaXMuY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChmb3JtYXR0aW5nKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmc7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IFByb2Nlc3MgbGVhZGluZyB2YWx1ZXMgd2l0aCBJbkRlc2lnbi1zcGVjaWZpYyBsb2dpY1xyXG4gIHByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9udFNpemUpIHtcclxuICAgIGlmICghcmF3TGVhZGluZykgcmV0dXJuICdhdXRvJztcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIFwiYXV0b1wiIGxlYWRpbmdcclxuICAgIGlmIChyYXdMZWFkaW5nID09PSAnYXV0bycgfHwgcmF3TGVhZGluZyA9PT0gJ0F1dG8nKSB7XHJcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IGZvbnRTaXplICogMS4yIDogJ2F1dG8nOyAvLyBJbkRlc2lnbiBkZWZhdWx0IGF1dG8gbGVhZGluZyBpcyAxMjAlXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBudW1lcmljIGxlYWRpbmcgKGluIHBvaW50cylcclxuICAgIGNvbnN0IG51bWVyaWNMZWFkaW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYXdMZWFkaW5nKTtcclxuICAgIGlmIChudW1lcmljTGVhZGluZykge1xyXG4gICAgICByZXR1cm4gbnVtZXJpY0xlYWRpbmc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBwZXJjZW50YWdlLWJhc2VkIGxlYWRpbmdcclxuICAgIGlmIChyYXdMZWFkaW5nLmluY2x1ZGVzKCclJykpIHtcclxuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQocmF3TGVhZGluZy5yZXBsYWNlKCclJywgJycpKTtcclxuICAgICAgcmV0dXJuIGZvbnRTaXplID8gKGZvbnRTaXplICogcGVyY2VudGFnZSAvIDEwMCkgOiAnYXV0byc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAnYXV0byc7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IERldGVybWluZSB0aGUgdHlwZSBvZiBsZWFkaW5nIGJlaW5nIHVzZWRcclxuICBkZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcgfHwgcmF3TGVhZGluZyA9PT0gJ2F1dG8nIHx8IHJhd0xlYWRpbmcgPT09ICdBdXRvJykge1xyXG4gICAgICByZXR1cm4gJ2F1dG8nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcygnJScpKSB7XHJcbiAgICAgIHJldHVybiAncGVyY2VudGFnZSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhd0xlYWRpbmcpKSB7XHJcbiAgICAgIHJldHVybiAnYWJzb2x1dGUnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1MgcmVuZGVyaW5nXHJcbiAgY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChmb3JtYXR0aW5nKSB7XHJcbiAgICBjb25zdCBmb250U2l6ZSA9IGZvcm1hdHRpbmcuZm9udFNpemUgfHwgMTI7XHJcbiAgICBjb25zdCBsZWFkaW5nID0gZm9ybWF0dGluZy5sZWFkaW5nO1xyXG4gICAgXHJcbiAgICBpZiAobGVhZGluZyA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgIHJldHVybiAxLjI7IC8vIENTUyBsaW5lLWhlaWdodCByYXRpbyBmb3IgYXV0b1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodHlwZW9mIGxlYWRpbmcgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIC8vIENvbnZlcnQgcG9pbnRzIHRvIENTUyBsaW5lLWhlaWdodCByYXRpb1xyXG4gICAgICByZXR1cm4gbGVhZGluZyAvIGZvbnRTaXplO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gMS4yOyAvLyBGYWxsYmFja1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFRleHRGb3JtYXR0aW5nKHN0b3J5RGF0YSkge1xyXG4gICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgcGFyYWdyYXBoU3R5bGVzOiBbXSxcclxuICAgICAgY2hhcmFjdGVyU3R5bGVzOiBbXSxcclxuICAgICAgYXBwbGllZFN0eWxlczogW11cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgYXBwbGllZCBwYXJhZ3JhcGggc3R5bGVzXHJcbiAgICBpZiAoc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2UpIHtcclxuICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZSkgPyBzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZSA6IFtzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZV07XHJcbiAgICAgIFxyXG4gICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwbGllZFN0eWxlID0gcmFuZ2VbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ107XHJcbiAgICAgICAgaWYgKGFwcGxpZWRTdHlsZSAmJiAhZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZXMuaW5jbHVkZXMoYXBwbGllZFN0eWxlKSkge1xyXG4gICAgICAgICAgZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZXMucHVzaChhcHBsaWVkU3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBFeHRyYWN0IGNoYXJhY3RlciBzdHlsZXMgd2l0aGluIHBhcmFncmFwaCByYW5nZXNcclxuICAgICAgICBpZiAocmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgY2hhclJhbmdlcyA9IEFycmF5LmlzQXJyYXkocmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZSkgPyByYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlIDogW3JhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjaGFyUmFuZ2VzLmZvckVhY2goY2hhclJhbmdlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hhclN0eWxlID0gY2hhclJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddO1xyXG4gICAgICAgICAgICBpZiAoY2hhclN0eWxlICYmICFmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlcy5pbmNsdWRlcyhjaGFyU3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZXMucHVzaChjaGFyU3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZm9ybWF0dGluZztcclxuICB9XHJcblxyXG4gIC8vIEFkZCB0aGlzIG1ldGhvZCB0byBkZWJ1ZyByYXcgc3RvcnkgY29udGVudFxyXG4gIGRlYnVnUmF3U3RvcnlDb250ZW50KHN0b3J5RGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coJ1xcbvCflI0gUkFXIFNUT1JZIENPTlRFTlQgREVCVUc6Jyk7XHJcbiAgICBjb25zb2xlLmxvZygnU3Rvcnkga2V5czonLCBPYmplY3Qua2V5cyhzdG9yeURhdGEpKTtcclxuICAgIFxyXG4gICAgY29uc3QgZmluZENoYXJhY3RlclJhbmdlcyA9IChvYmosIHBhdGggPSAnJykgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICBpZiAoa2V5ID09PSAnQ2hhcmFjdGVyU3R5bGVSYW5nZScpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfk50gRm91bmQgQ2hhcmFjdGVyU3R5bGVSYW5nZSBhdCAke3BhdGh9OmAsIG9ialtrZXldKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShvYmpba2V5XSkgPyBvYmpba2V5XSA6IFtvYmpba2V5XV07XHJcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBSYW5nZSAke2luZGV4ICsgMX0gYXR0cmlidXRlczpgLCBcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhbmdlKS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoJ0BfJykpXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBSYW5nZSAke2luZGV4ICsgMX0gZm9udCBpbmZvOmAsIHtcclxuICAgICAgICAgICAgICAgIEFwcGxpZWRGb250OiByYW5nZVsnQF9BcHBsaWVkRm9udCddLFxyXG4gICAgICAgICAgICAgICAgRm9udFN0eWxlOiByYW5nZVsnQF9Gb250U3R5bGUnXSxcclxuICAgICAgICAgICAgICAgIFBvaW50U2l6ZTogcmFuZ2VbJ0BfUG9pbnRTaXplJ11cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZmluZENoYXJhY3RlclJhbmdlcyhvYmpba2V5XSwgYCR7cGF0aH0uJHtrZXl9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZpbmRDaGFyYWN0ZXJSYW5nZXMoc3RvcnlEYXRhKTtcclxuICB9XHJcblxyXG4gIGdldFN0b3JpZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdG9yaWVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3Rvcnkoc3RvcnlJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3Rvcmllc1tzdG9yeUlkXTtcclxuICB9XHJcblxyXG4gIGNsZWFyU3RvcmllcygpIHtcclxuICAgIHRoaXMuc3RvcmllcyA9IHt9O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9yeVBhcnNlcjsgIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiSURNTFV0aWxzIiwiU3RvcnlQYXJzZXIiLCJwYXJzZVN0b3J5RmlsZSIsImZpbGVOYW1lIiwiY29udGVudCIsInhtbFBhcnNlciIsImNvbnNvbGUiLCJsb2ciLCJwYXJzZWQiLCJwYXJzZSIsInN0b3J5SWQiLCJiYXNlbmFtZSIsInN0b3J5RGF0YSIsIlN0b3J5IiwiT2JqZWN0Iiwia2V5cyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdWJzdHJpbmciLCJkZXRhaWxlZFN0b3J5Iiwic2VsZiIsImFwcGxpZWRUT0NTdHlsZSIsInVzZXJUZXh0IiwiZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50IiwidGV4dEZvcm1hdHRpbmciLCJleHRyYWN0VGV4dEZvcm1hdHRpbmciLCJjbGVhblN0b3J5SWQiLCJyZXBsYWNlIiwic3RvcmllcyIsInBsYWluVGV4dCIsImxpbmVCcmVha0luZm8iLCJsZW5ndGgiLCJ3b3JkQ291bnQiLCJsaW5lQnJlYWtDb3VudCIsImVycm9yIiwibWVzc2FnZSIsImZvcm1hdHRlZENvbnRlbnQiLCJ0ZXh0Q29sb3IiLCJkZWJ1Z0luZm8iLCJleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5IiwiZWxlbWVudCIsImRlcHRoIiwiY29udGV4dCIsIkNoYXJhY3RlclN0eWxlUmFuZ2UiLCJyYW5nZXMiLCJBcnJheSIsImlzQXJyYXkiLCJhbGxSYW5nZUNvbnRlbnQiLCJtYXAiLCJyIiwiQ29udGVudCIsImpvaW4iLCJTdHJpbmciLCJpbmNsdWRlcyIsImZvckVhY2giLCJyYW5nZSIsImluZGV4IiwicmFuZ2VJbmRleCIsImRpcmVjdEZvbnRSZWYiLCJmb3JtYXR0aW5nIiwicGFyYWdyYXBoU3R5bGUiLCJhcHBsaWVkU3R5bGUiLCJjaGFyYWN0ZXJTdHlsZSIsImZvbnRTaXplIiwicGFyc2VGbG9hdCIsImZvbnRSZWZlcmVuY2UiLCJmaWxsQ29sb3IiLCJmb250U3R5bGUiLCJhbGlnbm1lbnQiLCJwYXJhZ3JhcGhBbGlnbm1lbnQiLCJyYW5nZUNvbnRlbnQiLCJoYXNTdHlsZUluZm8iLCJ0cmltIiwicmF3UmFuZ2VBdHRyaWJ1dGVzIiwiZmlsdGVyIiwiayIsInN0YXJ0c1dpdGgiLCJleHRyYWN0ZWRGb3JtYXR0aW5nIiwiZm9udFN0eWxlRnJvbVhNTCIsImNoYXJhY3RlclN0eWxlRnJvbVhNTCIsInBhcmFncmFwaFN0eWxlRnJvbVhNTCIsInJlc29sdmVkRm9ybWF0dGluZyIsInN0eWxlUGFyc2VyIiwicmVzb2x2ZVN0eWxlRm9ybWF0dGluZyIsImNvbnRlbnRzIiwiY29udGVudEl0ZW0iLCJjb250ZW50SW5kZXgiLCJ0ZXh0IiwiZGVjb2RlWE1MRW50aXRpZXMiLCJwdXNoIiwiQnIiLCJ1bmRlZmluZWQiLCJsaW5lQnJlYWtUZXh0IiwiaXNCcmVhayIsImJyZWFrVHlwZSIsInBvc2l0aW9uIiwic291cmNlIiwidHlwZSIsImxvY2F0aW9uIiwiYnJFbGVtZW50cyIsImV4dHJhY3RCckVsZW1lbnRzIiwiYnJJbmZvIiwiYnJJbmRleCIsImRldGVybWluZUxpbmVCcmVha1R5cGUiLCJuZXh0UmFuZ2UiLCJjdXJyZW50VGV4dCIsInNsaWNlIiwiY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSIsInRlc3QiLCJuZXh0Q29udGVudCIsIm5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSIsInNob3VsZFNraXBTcGFjZSIsInNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrIiwiY3VycmVudFN0eWxlIiwibmV4dFN0eWxlIiwic3BhY2VUZXh0IiwiaXNTcGFjZSIsInJlYXNvbiIsImN1cnJlbnRUZXh0RW5kIiwibmV4dFRleHRTdGFydCIsImltcGxpY2l0QnJlYWsiLCJQYXJhZ3JhcGhTdHlsZVJhbmdlIiwicGFyYWdyYXBoQ29udGV4dCIsInBhcmFncmFwaEluZGV4IiwidG90YWxQYXJhZ3JhcGhzIiwicGFyYWdyYXBoQnJlYWsiLCJmb250RmFtaWx5IiwiYnIiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJpdGVtIiwicHJvY2Vzc2VkQ29udGVudCIsInNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nIiwiaW5mbyIsImhhc0xpbmVCcmVha3MiLCJtYXRjaCIsImxpbmVCcmVha1R5cGVzIiwiYW5hbHl6ZUxpbmVCcmVha1R5cGVzIiwic3BhY2VQcmVzZXJ2YXRpb25Db3VudCIsImNvdW50V29yZHMiLCJjaGFyYWN0ZXJDb3VudCIsImFuYWx5emVDb250ZW50U3RydWN0dXJlIiwic3RydWN0dXJlIiwiaGFzQ29udGVudCIsImhhc0JyIiwiY29udGVudEl0ZW1zIiwicHJvY2Vzc0ludGVybGVhdmVkQ29udGVudCIsInJlc3VsdHMiLCJjdXJyZW50UmFuZ2UiLCJjdXJyZW50Q2hhclN0eWxlIiwibmV4dENoYXJTdHlsZSIsInN0eWxlSW5kaWNhdGVzQnJlYWsiLCJzdHlsZUluZGljYXRlc0xpbmVCcmVhayIsInRpdGxlSW5kaWNhdG9ycyIsImJvZHlJbmRpY2F0b3JzIiwiY3VycmVudElzVGl0bGUiLCJzb21lIiwiaW5kaWNhdG9yIiwidG9Mb3dlckNhc2UiLCJuZXh0SXNCb2R5IiwidHlwZXMiLCJleHBsaWNpdCIsImltcGxpY2l0IiwicGFyYWdyYXBoIiwiZGlyZWN0IiwiaGFzT3duUHJvcGVydHkiLCJleHRyYWN0RGV0YWlsZWRGb3JtYXR0aW5nRnJvbVJhbmdlIiwiZm9udEF0dHJpYnV0ZXMiLCJhdHRyIiwicGFyc2VOdW1lcmljIiwicmF3TGVhZGluZyIsImxlYWRpbmciLCJwcm9jZXNzTGVhZGluZ1ZhbHVlIiwibGVhZGluZ1R5cGUiLCJkZXRlcm1pbmVMZWFkaW5nVHlwZSIsInN0cm9rZUNvbG9yIiwidHJhY2tpbmciLCJiYXNlbGluZVNoaWZ0Iiwia2VybmluZyIsImhvcml6b250YWxTY2FsZSIsInZlcnRpY2FsU2NhbGUiLCJleHBsaWNpdEFsaWdubWVudCIsImxlZnRJbmRlbnQiLCJyaWdodEluZGVudCIsImZpcnN0TGluZUluZGVudCIsInNwYWNlQmVmb3JlIiwic3BhY2VBZnRlciIsImVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0IiwibnVtZXJpY0xlYWRpbmciLCJwZXJjZW50YWdlIiwicGFyYWdyYXBoU3R5bGVzIiwiY2hhcmFjdGVyU3R5bGVzIiwiYXBwbGllZFN0eWxlcyIsImNoYXJSYW5nZXMiLCJjaGFyUmFuZ2UiLCJjaGFyU3R5bGUiLCJkZWJ1Z1Jhd1N0b3J5Q29udGVudCIsImZpbmRDaGFyYWN0ZXJSYW5nZXMiLCJvYmoiLCJBcHBsaWVkRm9udCIsIkZvbnRTdHlsZSIsIlBvaW50U2l6ZSIsImdldFN0b3JpZXMiLCJnZXRTdG9yeSIsImNsZWFyU3RvcmllcyIsImNvbnN0cnVjdG9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/parsers/StoryParser.js\n"));

/***/ })

});