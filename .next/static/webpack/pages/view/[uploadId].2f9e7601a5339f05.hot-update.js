"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/IDMLUtils.js":
/*!********************************!*\
  !*** ./lib/utils/IDMLUtils.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"?82df\");\nclass IDMLUtils {\n    static parseGeometricBounds(boundsString) {\n        console.log(\"DEBUG: boundsString =\", boundsString);\n        if (!boundsString || boundsString === \"undefined\") {\n            console.log(\"Warning: Missing geometric bounds, using defaults\");\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n        const bounds = boundsString.split(\" \").map(parseFloat);\n        const result = {\n            top: bounds[0] || 0,\n            left: bounds[1] || 0,\n            bottom: bounds[2] || 0,\n            right: bounds[3] || 0,\n            width: (bounds[3] || 0) - (bounds[1] || 0),\n            height: (bounds[2] || 0) - (bounds[0] || 0)\n        };\n        console.log(\"Parsed bounds:\", result);\n        return result;\n    }\n    static parseTransform(transformString) {\n        if (!transformString) return {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            tx: 0,\n            ty: 0\n        };\n        const values = transformString.split(\" \").map(parseFloat);\n        return {\n            a: values[0] || 1,\n            b: values[1] || 0,\n            c: values[2] || 0,\n            d: values[3] || 1,\n            tx: values[4] || 0,\n            ty: values[5] || 0 // y translation\n        };\n    }\n    static calculateRotation(transform) {\n        // Calculate rotation angle from transform matrix\n        return Math.atan2(transform.b, transform.a) * (180 / Math.PI);\n    }\n    static calculateCorners(bounds, transform) {\n        const corners = {\n            topLeft: {\n                x: bounds.left,\n                y: bounds.top\n            },\n            topRight: {\n                x: bounds.right,\n                y: bounds.top\n            },\n            bottomLeft: {\n                x: bounds.left,\n                y: bounds.bottom\n            },\n            bottomRight: {\n                x: bounds.right,\n                y: bounds.bottom\n            }\n        };\n        // Apply transformation to corners\n        Object.keys(corners).forEach((corner)=>{\n            const point = corners[corner];\n            corners[corner] = {\n                x: transform.a * point.x + transform.c * point.y + transform.tx,\n                y: transform.b * point.x + transform.d * point.y + transform.ty\n            };\n        });\n        return corners;\n    }\n    static cmykToRgb(c, m, y, k) {\n        // Convert CMYK percentages (0-100) to RGB (0-255)\n        c = c / 100;\n        m = m / 100;\n        y = y / 100;\n        k = k / 100;\n        const r = Math.round(255 * (1 - c) * (1 - k));\n        const g = Math.round(255 * (1 - m) * (1 - k));\n        const b = Math.round(255 * (1 - y) * (1 - k));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    static parseInDesignColor(colorRef) {\n        if (!colorRef || colorRef === \"Color/None\") return null;\n        // Handle CMYK colors\n        const cmykMatch = colorRef.match(/Color\\/C=(\\d+)\\s*M=(\\d+)\\s*Y=(\\d+)\\s*K=(\\d+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map(Number);\n            const rgb = this.cmykToRgb(c, m, y, k);\n            return \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n        }\n        // Handle RGB colors\n        const rgbMatch = colorRef.match(/Color\\/R=(\\d+)\\s*G=(\\d+)\\s*B=(\\d+)/);\n        if (rgbMatch) {\n            const [, r, g, b] = rgbMatch.map(Number);\n            return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n        }\n        // Standard colors\n        const standardColors = {\n            \"Color/Black\": \"rgb(0, 0, 0)\",\n            \"Color/White\": \"rgb(255, 255, 255)\",\n            \"Color/Red\": \"rgb(255, 0, 0)\",\n            \"Color/Green\": \"rgb(0, 255, 0)\",\n            \"Color/Blue\": \"rgb(0, 0, 255)\",\n            \"Color/Cyan\": \"rgb(0, 255, 255)\",\n            \"Color/Magenta\": \"rgb(255, 0, 255)\",\n            \"Color/Yellow\": \"rgb(255, 255, 0)\",\n            \"Color/Paper\": \"rgb(255, 255, 255)\",\n            \"Color/Registration\": \"rgb(0, 0, 0)\"\n        };\n        return standardColors[colorRef] || null;\n    }\n    static decodeXMLEntities(text) {\n        if (!text) return \"\";\n        return text.replace(/&#x000A;/g, \"\\n\") // Line feed\n        .replace(/&#x000D;/g, \"\\r\") // Carriage return\n        .replace(/&#x0009;/g, \"\t\") // Tab\n        .replace(/&#x00A0;/g, \"\\xa0\") // Non-breaking space\n        .replace(/&#x2028;/g, \"\\u2028\") // Line separator\n        .replace(/&#x2029;/g, \"\\u2029\") // Paragraph separator\n        .replace(/&#10;/g, \"\\n\") // Decimal line feed\n        .replace(/&#13;/g, \"\\r\") // Decimal carriage return\n        .replace(/&#9;/g, \"\t\") // Decimal tab\n        .replace(/&#160;/g, \"\\xa0\") // Decimal non-breaking space\n        .replace(/&lt;/g, \"<\") // Less than\n        .replace(/&gt;/g, \">\") // Greater than\n        .replace(/&amp;/g, \"&\") // Ampersand (must be last)\n        .replace(/&quot;/g, '\"') // Quote\n        .replace(/&apos;/g, \"'\"); // Apostrophe\n    }\n    static cleanTextContent(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\t/g, \"    \") // Convert tabs to spaces\n        .replace(/\\u00A0/g, \" \") // Convert non-breaking spaces\n        .replace(/ +/g, \" \") // Collapse multiple spaces\n        .replace(/\\n{3,}/g, \"\\n\\n\") // Maximum 2 consecutive line breaks\n        .trim();\n    }\n    static preserveLineBreaks(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\") // Convert paragraph separators\n        .replace(/\\n{3,}/g, \"\\n\\n\"); // Maximum 2 consecutive line breaks\n    }\n    // NEW: Clean up excessive line breaks to prevent text overflow  \n    static cleanTextForRendering(text) {\n        if (!text) return \"\";\n        return text// Remove excessive line breaks (more than 2 consecutive)\n        .replace(/\\n{3,}/g, \"\\n\\n\")// Remove line breaks followed by only whitespace and then another line break\n        .replace(/\\n\\s*\\n/g, \"\\n\\n\")// Remove trailing whitespace on lines (but preserve single spaces between words)\n        .replace(/[ \\t]+\\n/g, \"\\n\")// Clean up multiple spaces (but preserve single spaces - IMPORTANT for word separation)\n        .replace(/[ \\t]{3,}/g, \"  \") // Reduce 3+ spaces to 2 spaces max\n        // Remove leading/trailing whitespace\n        .trim();\n    }\n    // ENHANCED: Better line break processing that preserves word spaces\n    static sophisticatedLineBreakProcessing(content) {\n        if (!content) return \"\";\n        // DEBUG: Track if problematic text is being processed\n        const hasProblematicText = content.includes(\"pavoluptusda\") || content.includes(\"pa\") && content.includes(\"voluptusda\");\n        if (hasProblematicText) {\n            console.log(\"\\uD83D\\uDD27 IDMLUtils.sophisticatedLineBreakProcessing:\");\n            console.log(\"   - Input:\", JSON.stringify(content));\n        }\n        // First clean up the content but preserve word spaces\n        let processed = this.cleanTextForRendering(content);\n        if (hasProblematicText) {\n            console.log(\"   - After cleanTextForRendering:\", JSON.stringify(processed));\n        }\n        // Normalize line breaks but don't touch word spaces\n        processed = processed.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\") // Convert paragraph separators to double breaks\n        .replace(/\\u000A/g, \"\\n\"); // Convert explicit line feed characters\n        // Ensure paragraph breaks are properly spaced\n        processed = processed.replace(/\\n\\n+/g, \"\\n\\n\");\n        if (hasProblematicText) {\n            console.log(\"   - Final output:\", JSON.stringify(processed));\n            console.log('   - Contains \"pa voluptusda\":', processed.includes(\"pa voluptusda\"));\n            console.log('   - Contains \"pavoluptusda\":', processed.includes(\"pavoluptusda\"));\n        }\n        return processed;\n    }\n    static countWords(text) {\n        return text.split(/\\s+/).filter((word)=>word.length > 0).length;\n    }\n    static parseNumeric(value) {\n        if (value === null || value === undefined || value === \"\") return null;\n        const num = parseFloat(value);\n        return isNaN(num) ? null : num;\n    }\n    static isImageFile(fileName) {\n        const imageExtensions = [\n            \".jpg\",\n            \".jpeg\",\n            \".png\",\n            \".gif\",\n            \".tiff\",\n            \".tif\",\n            \".bmp\",\n            \".svg\",\n            \".eps\",\n            \".ai\",\n            \".psd\",\n            \".webp\",\n            \".ico\",\n            \".jfif\",\n            \".jp2\",\n            \".jpx\"\n        ];\n        return imageExtensions.some((ext)=>fileName.toLowerCase().endsWith(ext));\n    }\n    static getImageExtension(imageTypeName) {\n        const typeMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return typeMap[imageTypeName] || \"jpg\";\n    }\n    static getImageExtensionFromFormat(format) {\n        const formatMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return formatMap[format] || \"jpg\";\n    }\n    static extractImageNameFromLink(linkUri) {\n        if (!linkUri) return null;\n        // Extract filename from path like \"file:C:/Users/lalo/Downloads/Tesla-Model-3.jpg 13325 \"\n        const match = linkUri.match(/([^\\/\\\\]+)\\.[^.]+$/);\n        return match ? match[1] : null;\n    }\n    static calculateCoordinateOffset(elements) {\n        let minX = 0, minY = 0;\n        let maxStrokeWidth = 0;\n        // First pass: find minimum coordinates and maximum stroke width\n        elements.forEach((element)=>{\n            const bounds = element.geometricBounds || element.originalBounds;\n            const transform = element.itemTransform || {\n                tx: 0,\n                ty: 0\n            };\n            if (bounds) {\n                // Calculate final position after transform\n                const finalX = (bounds.left || 0) + (transform.tx || 0);\n                const finalY = (bounds.top || 0) + (transform.ty || 0);\n                minX = Math.min(minX, finalX);\n                minY = Math.min(minY, finalY);\n                // Track maximum stroke width for intelligent padding\n                const strokeWidth = element.strokeWeight || 0;\n                maxStrokeWidth = Math.max(maxStrokeWidth, strokeWidth);\n            }\n        });\n        // Calculate intelligent padding based on actual element properties\n        const intelligentPadding = Math.max(1, Math.ceil(maxStrokeWidth / 2)); // Half stroke width + minimum 1px\n        // SMART OFFSET CALCULATION:\n        // - Zero offset if all coordinates are positive\n        // - Minimal offset for negative coordinates + intelligent padding based on stroke widths\n        const offsetX = minX < 0 ? Math.abs(minX) + intelligentPadding : 0;\n        const offsetY = minY < 0 ? Math.abs(minY) + intelligentPadding : 0;\n        console.log(\"\\uD83C\\uDFAF SMART OFFSET: X: \".concat(offsetX, \", Y: \").concat(offsetY, \" (minX: \").concat(minX, \", minY: \").concat(minY, \")\"));\n        console.log(\"   Max stroke width: \".concat(maxStrokeWidth, \"px → intelligent padding: \").concat(intelligentPadding, \"px\"));\n        console.log(\"   \".concat(minX < 0 ? \"⚠️  Negative X: \".concat(minX, \" → offset \").concat(Math.abs(minX), \" + padding \").concat(intelligentPadding) : \"✅ X positive → no offset\"));\n        console.log(\"   \".concat(minY < 0 ? \"⚠️  Negative Y: \".concat(minY, \" → offset \").concat(Math.abs(minY), \" + padding \").concat(intelligentPadding) : \"✅ Y positive → no offset\"));\n        return {\n            x: offsetX,\n            y: offsetY\n        };\n    }\n    static calculateBoundsFromPath(item) {\n        try {\n            var _item_Properties_PathGeometry_GeometryPathType_PathPointArray, _item_Properties_PathGeometry_GeometryPathType, _item_Properties_PathGeometry, _item_Properties;\n            // First try to get bounds from GeometricBounds attribute\n            if (item[\"@_GeometricBounds\"]) {\n                return this.parseGeometricBounds(item[\"@_GeometricBounds\"]);\n            }\n            // Then try path geometry\n            const pathGeometry = item === null || item === void 0 ? void 0 : (_item_Properties = item.Properties) === null || _item_Properties === void 0 ? void 0 : (_item_Properties_PathGeometry = _item_Properties.PathGeometry) === null || _item_Properties_PathGeometry === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType = _item_Properties_PathGeometry.GeometryPathType) === null || _item_Properties_PathGeometry_GeometryPathType === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType_PathPointArray = _item_Properties_PathGeometry_GeometryPathType.PathPointArray) === null || _item_Properties_PathGeometry_GeometryPathType_PathPointArray === void 0 ? void 0 : _item_Properties_PathGeometry_GeometryPathType_PathPointArray.PathPointType;\n            if (!pathGeometry || !Array.isArray(pathGeometry)) {\n                console.log(\"Warning: No geometry found for \".concat(item[\"@_Self\"], \", using item transform\"));\n                // Fallback to item transform if available\n                const transform = this.parseTransform(item[\"@_ItemTransform\"]);\n                return {\n                    top: transform.ty || 0,\n                    left: transform.tx || 0,\n                    bottom: (transform.ty || 0) + 100,\n                    right: (transform.tx || 0) + 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n            pathGeometry.forEach((point)=>{\n                const anchor = point[\"@_Anchor\"];\n                if (anchor) {\n                    const [x, y] = anchor.split(\" \").map(parseFloat);\n                    if (!isNaN(x) && !isNaN(y)) {\n                        minX = Math.min(minX, x);\n                        maxX = Math.max(maxX, x);\n                        minY = Math.min(minY, y);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            });\n            if (minX === Infinity || minY === Infinity) {\n                console.log(\"Warning: Could not calculate bounds for \".concat(item[\"@_Self\"]));\n                return {\n                    top: 0,\n                    left: 0,\n                    bottom: 100,\n                    right: 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            return {\n                top: minY,\n                left: minX,\n                bottom: maxY,\n                right: maxX,\n                width: maxX - minX,\n                height: maxY - minY\n            };\n        } catch (error) {\n            console.error(\"Error calculating bounds for \".concat(item[\"@_Self\"], \":\"), error);\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n    }\n    static calculateRelativePosition(frameBounds, contentBounds, frameTransform, contentTransform) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            offsetX: (contentBounds.left || 0) - (frameBounds.left || 0),\n            offsetY: (contentBounds.top || 0) - (frameBounds.top || 0),\n            scaleX: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.a) || 1,\n            scaleY: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.d) || 1,\n            transformDifference: {\n                frame: frameTransform,\n                content: contentTransform\n            }\n        };\n    }\n    static calculateGap(frameBounds, contentBounds) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            top: (contentBounds.top || 0) - (frameBounds.top || 0),\n            left: (contentBounds.left || 0) - (frameBounds.left || 0),\n            bottom: (frameBounds.bottom || 0) - (contentBounds.bottom || 0),\n            right: (frameBounds.right || 0) - (contentBounds.right || 0)\n        };\n    }\n    static calculateImagePositionInFrame(frameBounds, frameTransform, placedContent) {\n        if (!frameBounds || !(placedContent === null || placedContent === void 0 ? void 0 : placedContent.transform)) {\n            return null;\n        }\n        const imageTransform = placedContent.transform;\n        // Calculate image position relative to frame\n        const imageX = (frameBounds.left || 0) + (imageTransform.tx || 0);\n        const imageY = (frameBounds.top || 0) + (imageTransform.ty || 0);\n        // Calculate image size with scaling\n        const imageWidth = (frameBounds.width || 0) * (imageTransform.a || 1);\n        const imageHeight = (frameBounds.height || 0) * (imageTransform.d || 1);\n        return {\n            x: imageX,\n            y: imageY,\n            width: imageWidth,\n            height: imageHeight,\n            scaleX: imageTransform.a || 1,\n            scaleY: imageTransform.d || 1\n        };\n    }\n    static getXMLStructure(obj) {\n        let maxDepth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        if (currentDepth >= maxDepth || typeof obj !== \"object\" || obj === null) {\n            return typeof obj;\n        }\n        const structure = {};\n        Object.keys(obj).forEach((key)=>{\n            if (Array.isArray(obj[key])) {\n                structure[key] = \"Array[\".concat(obj[key].length, \"]\");\n            } else if (typeof obj[key] === \"object\" && obj[key] !== null) {\n                structure[key] = this.getXMLStructure(obj[key], maxDepth, currentDepth + 1);\n            } else {\n                structure[key] = typeof obj[key];\n            }\n        });\n        return structure;\n    }\n    static isFormattingAttribute(attributeName) {\n        const formattingAttributes = [\n            \"@_PointSize\",\n            \"@_Leading\",\n            \"@_Tracking\",\n            \"@_FontStyle\",\n            \"@_AppliedFont\",\n            \"@_FillColor\",\n            \"@_StrokeColor\",\n            \"@_Justification\",\n            \"@_LeftIndent\",\n            \"@_RightIndent\",\n            \"@_FirstLineIndent\",\n            \"@_SpaceBefore\",\n            \"@_SpaceAfter\",\n            \"@_Alignment\"\n        ];\n        return formattingAttributes.includes(attributeName);\n    }\n    static saveDebugInfo(debugInfo, fileName) {\n        try {\n            fs.writeFileSync(fileName, JSON.stringify(debugInfo, null, 2));\n            console.log(\"✅ Debug info saved to \".concat(fileName));\n        } catch (error) {\n            console.error(\"❌ Error saving debug info:\", error);\n            console.log(\"Debug info (first 2000 chars):\", JSON.stringify(debugInfo, null, 2).substring(0, 2000));\n        }\n    }\n}\nmodule.exports = IDMLUtils;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eUIsT0FBaEJKLEdBQUcsQ0FBQ0ksSUFBSSxDQUFDOUUsTUFBTSxFQUFDO1lBQzVDLE9BQU8sSUFBSSxPQUFPMEUsR0FBRyxDQUFDSSxJQUFJLEtBQUssWUFBWUosR0FBRyxDQUFDSSxJQUFJLEtBQUssTUFBTTtnQkFDNURELFNBQVMsQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ0wsZUFBZSxDQUFDQyxHQUFHLENBQUNJLElBQUksRUFBRUgsVUFBVUMsZUFBZTtZQUMzRSxPQUFPO2dCQUNMQyxTQUFTLENBQUNDLElBQUksR0FBRyxPQUFPSixHQUFHLENBQUNJLElBQUk7WUFDbEM7UUFDRjtRQUVBLE9BQU9EO0lBQ1Q7SUFFQSxPQUFPRSxzQkFBc0JDLGFBQWEsRUFBRTtRQUMxQyxNQUFNQyx1QkFBdUI7WUFDM0I7WUFBZTtZQUFhO1lBQWM7WUFDMUM7WUFBaUI7WUFBZTtZQUFpQjtZQUNqRDtZQUFnQjtZQUFpQjtZQUNqQztZQUFpQjtZQUFnQjtTQUNsQztRQUNELE9BQU9BLHFCQUFxQnhGLFFBQVEsQ0FBQ3VGO0lBQ3ZDO0lBRUEsT0FBT0UsY0FBY0MsU0FBUyxFQUFFNUUsUUFBUSxFQUFFO1FBQ3hDLElBQUk7WUFDRmxGLEdBQUcrSixhQUFhLENBQUM3RSxVQUFVYixLQUFLQyxTQUFTLENBQUN3RixXQUFXLE1BQU07WUFDM0QxSixRQUFRQyxHQUFHLENBQUMseUJBQWtDLE9BQVQ2RTtRQUN2QyxFQUFFLE9BQU9nRCxPQUFPO1lBQ2Q5SCxRQUFROEgsS0FBSyxDQUFDLDhCQUE4QkE7WUFDNUM5SCxRQUFRQyxHQUFHLENBQUMsa0NBQWtDZ0UsS0FBS0MsU0FBUyxDQUFDd0YsV0FBVyxNQUFNLEdBQUdFLFNBQVMsQ0FBQyxHQUFHO1FBQ2hHO0lBQ0Y7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdqSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvdXRpbHMvSURNTFV0aWxzLmpzPzhkMmYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xyXG5cclxuY2xhc3MgSURNTFV0aWxzIHtcclxuICBzdGF0aWMgcGFyc2VHZW9tZXRyaWNCb3VuZHMoYm91bmRzU3RyaW5nKSB7XHJcbiAgICBjb25zb2xlLmxvZygnREVCVUc6IGJvdW5kc1N0cmluZyA9JywgYm91bmRzU3RyaW5nKTtcclxuICAgIGlmICghYm91bmRzU3RyaW5nIHx8IGJvdW5kc1N0cmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1dhcm5pbmc6IE1pc3NpbmcgZ2VvbWV0cmljIGJvdW5kcywgdXNpbmcgZGVmYXVsdHMnKTtcclxuICAgICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IDEwMCwgcmlnaHQ6IDEwMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgYm91bmRzID0gYm91bmRzU3RyaW5nLnNwbGl0KCcgJykubWFwKHBhcnNlRmxvYXQpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICB0b3A6IGJvdW5kc1swXSB8fCAwLFxyXG4gICAgICBsZWZ0OiBib3VuZHNbMV0gfHwgMCxcclxuICAgICAgYm90dG9tOiBib3VuZHNbMl0gfHwgMCxcclxuICAgICAgcmlnaHQ6IGJvdW5kc1szXSB8fCAwLFxyXG4gICAgICB3aWR0aDogKGJvdW5kc1szXSB8fCAwKSAtIChib3VuZHNbMV0gfHwgMCksXHJcbiAgICAgIGhlaWdodDogKGJvdW5kc1syXSB8fCAwKSAtIChib3VuZHNbMF0gfHwgMClcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgYm91bmRzOicsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybVN0cmluZykge1xyXG4gICAgaWYgKCF0cmFuc2Zvcm1TdHJpbmcpIHJldHVybiB7IGE6IDEsIGI6IDAsIGM6IDAsIGQ6IDEsIHR4OiAwLCB0eTogMCB9O1xyXG4gICAgXHJcbiAgICBjb25zdCB2YWx1ZXMgPSB0cmFuc2Zvcm1TdHJpbmcuc3BsaXQoJyAnKS5tYXAocGFyc2VGbG9hdCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhOiB2YWx1ZXNbMF0gfHwgMSwgICAvLyB4IHNjYWxlXHJcbiAgICAgIGI6IHZhbHVlc1sxXSB8fCAwLCAgIC8vIHkgc2tld1xyXG4gICAgICBjOiB2YWx1ZXNbMl0gfHwgMCwgICAvLyB4IHNrZXdcclxuICAgICAgZDogdmFsdWVzWzNdIHx8IDEsICAgLy8geSBzY2FsZVxyXG4gICAgICB0eDogdmFsdWVzWzRdIHx8IDAsICAvLyB4IHRyYW5zbGF0aW9uXHJcbiAgICAgIHR5OiB2YWx1ZXNbNV0gfHwgMCAgIC8vIHkgdHJhbnNsYXRpb25cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlUm90YXRpb24odHJhbnNmb3JtKSB7XHJcbiAgICAvLyBDYWxjdWxhdGUgcm90YXRpb24gYW5nbGUgZnJvbSB0cmFuc2Zvcm0gbWF0cml4XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmEpICogKDE4MCAvIE1hdGguUEkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUNvcm5lcnMoYm91bmRzLCB0cmFuc2Zvcm0pIHtcclxuICAgIGNvbnN0IGNvcm5lcnMgPSB7XHJcbiAgICAgIHRvcExlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy50b3AgfSxcclxuICAgICAgdG9wUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMudG9wIH0sXHJcbiAgICAgIGJvdHRvbUxlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy5ib3R0b20gfSxcclxuICAgICAgYm90dG9tUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMuYm90dG9tIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIGNvcm5lcnNcclxuICAgIE9iamVjdC5rZXlzKGNvcm5lcnMpLmZvckVhY2goY29ybmVyID0+IHtcclxuICAgICAgY29uc3QgcG9pbnQgPSBjb3JuZXJzW2Nvcm5lcl07XHJcbiAgICAgIGNvcm5lcnNbY29ybmVyXSA9IHtcclxuICAgICAgICB4OiAodHJhbnNmb3JtLmEgKiBwb2ludC54KSArICh0cmFuc2Zvcm0uYyAqIHBvaW50LnkpICsgdHJhbnNmb3JtLnR4LFxyXG4gICAgICAgIHk6ICh0cmFuc2Zvcm0uYiAqIHBvaW50LngpICsgKHRyYW5zZm9ybS5kICogcG9pbnQueSkgKyB0cmFuc2Zvcm0udHlcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gY29ybmVycztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjbXlrVG9SZ2IoYywgbSwgeSwgaykge1xyXG4gICAgLy8gQ29udmVydCBDTVlLIHBlcmNlbnRhZ2VzICgwLTEwMCkgdG8gUkdCICgwLTI1NSlcclxuICAgIGMgPSBjIC8gMTAwO1xyXG4gICAgbSA9IG0gLyAxMDA7XHJcbiAgICB5ID0geSAvIDEwMDtcclxuICAgIGsgPSBrIC8gMTAwO1xyXG5cclxuICAgIGNvbnN0IHIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gYykgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGcgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gbSkgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0geSkgKiAoMSAtIGspKTtcclxuXHJcbiAgICByZXR1cm4geyByLCBnLCBiIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VJbkRlc2lnbkNvbG9yKGNvbG9yUmVmKSB7XHJcbiAgICBpZiAoIWNvbG9yUmVmIHx8IGNvbG9yUmVmID09PSAnQ29sb3IvTm9uZScpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgQ01ZSyBjb2xvcnNcclxuICAgIGNvbnN0IGNteWtNYXRjaCA9IGNvbG9yUmVmLm1hdGNoKC9Db2xvclxcL0M9KFxcZCspXFxzKk09KFxcZCspXFxzKlk9KFxcZCspXFxzKks9KFxcZCspLyk7XHJcbiAgICBpZiAoY215a01hdGNoKSB7XHJcbiAgICAgIGNvbnN0IFssIGMsIG0sIHksIGtdID0gY215a01hdGNoLm1hcChOdW1iZXIpO1xyXG4gICAgICBjb25zdCByZ2IgPSB0aGlzLmNteWtUb1JnYihjLCBtLCB5LCBrKTtcclxuICAgICAgcmV0dXJuIGByZ2IoJHtyZ2Iucn0sICR7cmdiLmd9LCAke3JnYi5ifSlgO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgUkdCIGNvbG9yc1xyXG4gICAgY29uc3QgcmdiTWF0Y2ggPSBjb2xvclJlZi5tYXRjaCgvQ29sb3JcXC9SPShcXGQrKVxccypHPShcXGQrKVxccypCPShcXGQrKS8pO1xyXG4gICAgaWYgKHJnYk1hdGNoKSB7XHJcbiAgICAgIGNvbnN0IFssIHIsIGcsIGJdID0gcmdiTWF0Y2gubWFwKE51bWJlcik7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gU3RhbmRhcmQgY29sb3JzXHJcbiAgICBjb25zdCBzdGFuZGFyZENvbG9ycyA9IHtcclxuICAgICAgJ0NvbG9yL0JsYWNrJzogJ3JnYigwLCAwLCAwKScsXHJcbiAgICAgICdDb2xvci9XaGl0ZSc6ICdyZ2IoMjU1LCAyNTUsIDI1NSknLFxyXG4gICAgICAnQ29sb3IvUmVkJzogJ3JnYigyNTUsIDAsIDApJyxcclxuICAgICAgJ0NvbG9yL0dyZWVuJzogJ3JnYigwLCAyNTUsIDApJyxcclxuICAgICAgJ0NvbG9yL0JsdWUnOiAncmdiKDAsIDAsIDI1NSknLFxyXG4gICAgICAnQ29sb3IvQ3lhbic6ICdyZ2IoMCwgMjU1LCAyNTUpJyxcclxuICAgICAgJ0NvbG9yL01hZ2VudGEnOiAncmdiKDI1NSwgMCwgMjU1KScsXHJcbiAgICAgICdDb2xvci9ZZWxsb3cnOiAncmdiKDI1NSwgMjU1LCAwKScsXHJcbiAgICAgICdDb2xvci9QYXBlcic6ICdyZ2IoMjU1LCAyNTUsIDI1NSknLFxyXG4gICAgICAnQ29sb3IvUmVnaXN0cmF0aW9uJzogJ3JnYigwLCAwLCAwKSdcclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiBzdGFuZGFyZENvbG9yc1tjb2xvclJlZl0gfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBkZWNvZGVYTUxFbnRpdGllcyh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiAnJztcclxuICAgIFxyXG4gICAgcmV0dXJuIHRleHRcclxuICAgICAgLnJlcGxhY2UoLyYjeDAwMEE7L2csICdcXG4nKSAgICAgIC8vIExpbmUgZmVlZFxyXG4gICAgICAucmVwbGFjZSgvJiN4MDAwRDsvZywgJ1xccicpICAgICAgLy8gQ2FycmlhZ2UgcmV0dXJuXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMDA5Oy9nLCAnXFx0JykgICAgICAvLyBUYWJcclxuICAgICAgLnJlcGxhY2UoLyYjeDAwQTA7L2csICdcXHUwMEEwJykgIC8vIE5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAucmVwbGFjZSgvJiN4MjAyODsvZywgJ1xcdTIwMjgnKSAgLy8gTGluZSBzZXBhcmF0b3JcclxuICAgICAgLnJlcGxhY2UoLyYjeDIwMjk7L2csICdcXHUyMDI5JykgIC8vIFBhcmFncmFwaCBzZXBhcmF0b3JcclxuICAgICAgLnJlcGxhY2UoLyYjMTA7L2csICdcXG4nKSAgICAgICAgIC8vIERlY2ltYWwgbGluZSBmZWVkXHJcbiAgICAgIC5yZXBsYWNlKC8mIzEzOy9nLCAnXFxyJykgICAgICAgICAvLyBEZWNpbWFsIGNhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiM5Oy9nLCAnXFx0JykgICAgICAgICAgLy8gRGVjaW1hbCB0YWJcclxuICAgICAgLnJlcGxhY2UoLyYjMTYwOy9nLCAnXFx1MDBBMCcpICAgIC8vIERlY2ltYWwgbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgIC5yZXBsYWNlKC8mbHQ7L2csICc8JykgICAgICAgICAgIC8vIExlc3MgdGhhblxyXG4gICAgICAucmVwbGFjZSgvJmd0Oy9nLCAnPicpICAgICAgICAgICAvLyBHcmVhdGVyIHRoYW5cclxuICAgICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJykgICAgICAgICAgLy8gQW1wZXJzYW5kIChtdXN0IGJlIGxhc3QpXHJcbiAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJykgICAgICAgICAvLyBRdW90ZVxyXG4gICAgICAucmVwbGFjZSgvJmFwb3M7L2csIFwiJ1wiKTsgICAgICAgIC8vIEFwb3N0cm9waGVcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjbGVhblRleHRDb250ZW50KGNvbnRlbnQpIHtcclxuICAgIHJldHVybiBjb250ZW50XHJcbiAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpICAgICAgLy8gTm9ybWFsaXplIFdpbmRvd3MgbGluZSBicmVha3NcclxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxuJykgICAgICAgIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKSAgICAgIC8vIENvbnZlcnQgdGFicyB0byBzcGFjZXNcclxuICAgICAgLnJlcGxhY2UoL1xcdTAwQTAvZywgJyAnKSAgICAgLy8gQ29udmVydCBub24tYnJlYWtpbmcgc3BhY2VzXHJcbiAgICAgIC5yZXBsYWNlKC8gKy9nLCAnICcpICAgICAgICAgLy8gQ29sbGFwc2UgbXVsdGlwbGUgc3BhY2VzXHJcbiAgICAgIC5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKSAgLy8gTWF4aW11bSAyIGNvbnNlY3V0aXZlIGxpbmUgYnJlYWtzXHJcbiAgICAgIC50cmltKCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcHJlc2VydmVMaW5lQnJlYWtzKGNvbnRlbnQpIHtcclxuICAgIHJldHVybiBjb250ZW50XHJcbiAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpICAgICAgLy8gTm9ybWFsaXplIFdpbmRvd3MgbGluZSBicmVha3NcclxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxuJykgICAgICAgIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXG4nKSAgICAvLyBDb252ZXJ0IGxpbmUgc2VwYXJhdG9yc1xyXG4gICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxuXFxuJykgIC8vIENvbnZlcnQgcGFyYWdyYXBoIHNlcGFyYXRvcnNcclxuICAgICAgLnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpOyAvLyBNYXhpbXVtIDIgY29uc2VjdXRpdmUgbGluZSBicmVha3NcclxuICB9XHJcblxyXG4gIC8vIE5FVzogQ2xlYW4gdXAgZXhjZXNzaXZlIGxpbmUgYnJlYWtzIHRvIHByZXZlbnQgdGV4dCBvdmVyZmxvdyAgXHJcbiAgc3RhdGljIGNsZWFuVGV4dEZvclJlbmRlcmluZyh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiAnJztcclxuICAgIFxyXG4gICAgcmV0dXJuIHRleHRcclxuICAgICAgLy8gUmVtb3ZlIGV4Y2Vzc2l2ZSBsaW5lIGJyZWFrcyAobW9yZSB0aGFuIDIgY29uc2VjdXRpdmUpXHJcbiAgICAgIC5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKVxyXG4gICAgICAvLyBSZW1vdmUgbGluZSBicmVha3MgZm9sbG93ZWQgYnkgb25seSB3aGl0ZXNwYWNlIGFuZCB0aGVuIGFub3RoZXIgbGluZSBicmVha1xyXG4gICAgICAucmVwbGFjZSgvXFxuXFxzKlxcbi9nLCAnXFxuXFxuJylcclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb24gbGluZXMgKGJ1dCBwcmVzZXJ2ZSBzaW5nbGUgc3BhY2VzIGJldHdlZW4gd29yZHMpXHJcbiAgICAgIC5yZXBsYWNlKC9bIFxcdF0rXFxuL2csICdcXG4nKVxyXG4gICAgICAvLyBDbGVhbiB1cCBtdWx0aXBsZSBzcGFjZXMgKGJ1dCBwcmVzZXJ2ZSBzaW5nbGUgc3BhY2VzIC0gSU1QT1JUQU5UIGZvciB3b3JkIHNlcGFyYXRpb24pXHJcbiAgICAgIC5yZXBsYWNlKC9bIFxcdF17Myx9L2csICcgICcpIC8vIFJlZHVjZSAzKyBzcGFjZXMgdG8gMiBzcGFjZXMgbWF4XHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcclxuICAgICAgLnRyaW0oKTtcclxuICB9XHJcblxyXG4gIC8vIEVOSEFOQ0VEOiBCZXR0ZXIgbGluZSBicmVhayBwcm9jZXNzaW5nIHRoYXQgcHJlc2VydmVzIHdvcmQgc3BhY2VzXHJcbiAgc3RhdGljIHNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nKGNvbnRlbnQpIHtcclxuICAgIGlmICghY29udGVudCkgcmV0dXJuICcnO1xyXG4gICAgXHJcbiAgICAvLyBERUJVRzogVHJhY2sgaWYgcHJvYmxlbWF0aWMgdGV4dCBpcyBiZWluZyBwcm9jZXNzZWRcclxuICAgIGNvbnN0IGhhc1Byb2JsZW1hdGljVGV4dCA9IGNvbnRlbnQuaW5jbHVkZXMoJ3Bhdm9sdXB0dXNkYScpIHx8IChjb250ZW50LmluY2x1ZGVzKCdwYScpICYmIGNvbnRlbnQuaW5jbHVkZXMoJ3ZvbHVwdHVzZGEnKSk7XHJcbiAgICBpZiAoaGFzUHJvYmxlbWF0aWNUZXh0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SnIElETUxVdGlscy5zb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZzonKTtcclxuICAgICAgY29uc29sZS5sb2coJyAgIC0gSW5wdXQ6JywgSlNPTi5zdHJpbmdpZnkoY29udGVudCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBGaXJzdCBjbGVhbiB1cCB0aGUgY29udGVudCBidXQgcHJlc2VydmUgd29yZCBzcGFjZXNcclxuICAgIGxldCBwcm9jZXNzZWQgPSB0aGlzLmNsZWFuVGV4dEZvclJlbmRlcmluZyhjb250ZW50KTtcclxuICAgIFxyXG4gICAgaWYgKGhhc1Byb2JsZW1hdGljVGV4dCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBBZnRlciBjbGVhblRleHRGb3JSZW5kZXJpbmc6JywgSlNPTi5zdHJpbmdpZnkocHJvY2Vzc2VkKSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIE5vcm1hbGl6ZSBsaW5lIGJyZWFrcyBidXQgZG9uJ3QgdG91Y2ggd29yZCBzcGFjZXNcclxuICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZFxyXG4gICAgICAucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKSAgICAgIC8vIE5vcm1hbGl6ZSBXaW5kb3dzIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcbicpICAgICAgICAvLyBOb3JtYWxpemUgb2xkIE1hYyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxuJykgICAgLy8gQ29udmVydCBsaW5lIHNlcGFyYXRvcnNcclxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcblxcbicpICAvLyBDb252ZXJ0IHBhcmFncmFwaCBzZXBhcmF0b3JzIHRvIGRvdWJsZSBicmVha3NcclxuICAgICAgLnJlcGxhY2UoL1xcdTAwMEEvZywgJ1xcbicpOyAgIC8vIENvbnZlcnQgZXhwbGljaXQgbGluZSBmZWVkIGNoYXJhY3RlcnNcclxuICAgIFxyXG4gICAgLy8gRW5zdXJlIHBhcmFncmFwaCBicmVha3MgYXJlIHByb3Blcmx5IHNwYWNlZFxyXG4gICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkLnJlcGxhY2UoL1xcblxcbisvZywgJ1xcblxcbicpO1xyXG4gICAgXHJcbiAgICBpZiAoaGFzUHJvYmxlbWF0aWNUZXh0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIEZpbmFsIG91dHB1dDonLCBKU09OLnN0cmluZ2lmeShwcm9jZXNzZWQpKTtcclxuICAgICAgY29uc29sZS5sb2coJyAgIC0gQ29udGFpbnMgXCJwYSB2b2x1cHR1c2RhXCI6JywgcHJvY2Vzc2VkLmluY2x1ZGVzKCdwYSB2b2x1cHR1c2RhJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBDb250YWlucyBcInBhdm9sdXB0dXNkYVwiOicsIHByb2Nlc3NlZC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcHJvY2Vzc2VkO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNvdW50V29yZHModGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQuc3BsaXQoL1xccysvKS5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDApLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwYXJzZU51bWVyaWModmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJykgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgIHJldHVybiBpc05hTihudW0pID8gbnVsbCA6IG51bTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBpc0ltYWdlRmlsZShmaWxlTmFtZSkge1xyXG4gICAgY29uc3QgaW1hZ2VFeHRlbnNpb25zID0gW1xyXG4gICAgICAnLmpwZycsICcuanBlZycsICcucG5nJywgJy5naWYnLCAnLnRpZmYnLCAnLnRpZicsICcuYm1wJywgJy5zdmcnLCBcclxuICAgICAgJy5lcHMnLCAnLmFpJywgJy5wc2QnLCAnLndlYnAnLCAnLmljbycsICcuamZpZicsICcuanAyJywgJy5qcHgnXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGltYWdlRXh0ZW5zaW9ucy5zb21lKGV4dCA9PiBmaWxlTmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldEltYWdlRXh0ZW5zaW9uKGltYWdlVHlwZU5hbWUpIHtcclxuICAgIGNvbnN0IHR5cGVNYXAgPSB7XHJcbiAgICAgICckSUQvSlBFRyc6ICdqcGcnLFxyXG4gICAgICAnJElEL1BORyc6ICdwbmcnLCBcclxuICAgICAgJyRJRC9USUZGJzogJ3RpZicsXHJcbiAgICAgICckSUQvR0lGJzogJ2dpZicsXHJcbiAgICAgICckSUQvQk1QJzogJ2JtcCdcclxuICAgIH07XHJcbiAgICByZXR1cm4gdHlwZU1hcFtpbWFnZVR5cGVOYW1lXSB8fCAnanBnJztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRJbWFnZUV4dGVuc2lvbkZyb21Gb3JtYXQoZm9ybWF0KSB7XHJcbiAgICBjb25zdCBmb3JtYXRNYXAgPSB7XHJcbiAgICAgICckSUQvSlBFRyc6ICdqcGcnLFxyXG4gICAgICAnJElEL1BORyc6ICdwbmcnLFxyXG4gICAgICAnJElEL1RJRkYnOiAndGlmJyxcclxuICAgICAgJyRJRC9HSUYnOiAnZ2lmJyxcclxuICAgICAgJyRJRC9CTVAnOiAnYm1wJ1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmb3JtYXRNYXBbZm9ybWF0XSB8fCAnanBnJztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBleHRyYWN0SW1hZ2VOYW1lRnJvbUxpbmsobGlua1VyaSkge1xyXG4gICAgaWYgKCFsaW5rVXJpKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBmaWxlbmFtZSBmcm9tIHBhdGggbGlrZSBcImZpbGU6QzovVXNlcnMvbGFsby9Eb3dubG9hZHMvVGVzbGEtTW9kZWwtMy5qcGcgMTMzMjUgXCJcclxuICAgIGNvbnN0IG1hdGNoID0gbGlua1VyaS5tYXRjaCgvKFteXFwvXFxcXF0rKVxcLlteLl0rJC8pO1xyXG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXQoZWxlbWVudHMpIHtcclxuICAgIGxldCBtaW5YID0gMCwgbWluWSA9IDA7XHJcbiAgICBsZXQgbWF4U3Ryb2tlV2lkdGggPSAwO1xyXG4gICAgXHJcbiAgICAvLyBGaXJzdCBwYXNzOiBmaW5kIG1pbmltdW0gY29vcmRpbmF0ZXMgYW5kIG1heGltdW0gc3Ryb2tlIHdpZHRoXHJcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICBjb25zdCBib3VuZHMgPSBlbGVtZW50Lmdlb21ldHJpY0JvdW5kcyB8fCBlbGVtZW50Lm9yaWdpbmFsQm91bmRzO1xyXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbGVtZW50Lml0ZW1UcmFuc2Zvcm0gfHwgeyB0eDogMCwgdHk6IDAgfTtcclxuICAgICAgXHJcbiAgICAgIGlmIChib3VuZHMpIHtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgZmluYWwgcG9zaXRpb24gYWZ0ZXIgdHJhbnNmb3JtXHJcbiAgICAgICAgY29uc3QgZmluYWxYID0gKGJvdW5kcy5sZWZ0IHx8IDApICsgKHRyYW5zZm9ybS50eCB8fCAwKTtcclxuICAgICAgICBjb25zdCBmaW5hbFkgPSAoYm91bmRzLnRvcCB8fCAwKSArICh0cmFuc2Zvcm0udHkgfHwgMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIGZpbmFsWCk7XHJcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGZpbmFsWSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVHJhY2sgbWF4aW11bSBzdHJva2Ugd2lkdGggZm9yIGludGVsbGlnZW50IHBhZGRpbmdcclxuICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IGVsZW1lbnQuc3Ryb2tlV2VpZ2h0IHx8IDA7XHJcbiAgICAgICAgbWF4U3Ryb2tlV2lkdGggPSBNYXRoLm1heChtYXhTdHJva2VXaWR0aCwgc3Ryb2tlV2lkdGgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGludGVsbGlnZW50IHBhZGRpbmcgYmFzZWQgb24gYWN0dWFsIGVsZW1lbnQgcHJvcGVydGllc1xyXG4gICAgY29uc3QgaW50ZWxsaWdlbnRQYWRkaW5nID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKG1heFN0cm9rZVdpZHRoIC8gMikpOyAvLyBIYWxmIHN0cm9rZSB3aWR0aCArIG1pbmltdW0gMXB4XHJcbiAgICBcclxuICAgIC8vIFNNQVJUIE9GRlNFVCBDQUxDVUxBVElPTjpcclxuICAgIC8vIC0gWmVybyBvZmZzZXQgaWYgYWxsIGNvb3JkaW5hdGVzIGFyZSBwb3NpdGl2ZVxyXG4gICAgLy8gLSBNaW5pbWFsIG9mZnNldCBmb3IgbmVnYXRpdmUgY29vcmRpbmF0ZXMgKyBpbnRlbGxpZ2VudCBwYWRkaW5nIGJhc2VkIG9uIHN0cm9rZSB3aWR0aHNcclxuICAgIGNvbnN0IG9mZnNldFggPSBtaW5YIDwgMCA/IE1hdGguYWJzKG1pblgpICsgaW50ZWxsaWdlbnRQYWRkaW5nIDogMDtcclxuICAgIGNvbnN0IG9mZnNldFkgPSBtaW5ZIDwgMCA/IE1hdGguYWJzKG1pblkpICsgaW50ZWxsaWdlbnRQYWRkaW5nIDogMDtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCfjq8gU01BUlQgT0ZGU0VUOiBYOiAke29mZnNldFh9LCBZOiAke29mZnNldFl9IChtaW5YOiAke21pblh9LCBtaW5ZOiAke21pbll9KWApO1xyXG4gICAgY29uc29sZS5sb2coYCAgIE1heCBzdHJva2Ugd2lkdGg6ICR7bWF4U3Ryb2tlV2lkdGh9cHgg4oaSIGludGVsbGlnZW50IHBhZGRpbmc6ICR7aW50ZWxsaWdlbnRQYWRkaW5nfXB4YCk7XHJcbiAgICBjb25zb2xlLmxvZyhgICAgJHttaW5YIDwgMCA/IGDimqDvuI8gIE5lZ2F0aXZlIFg6ICR7bWluWH0g4oaSIG9mZnNldCAke01hdGguYWJzKG1pblgpfSArIHBhZGRpbmcgJHtpbnRlbGxpZ2VudFBhZGRpbmd9YCA6ICfinIUgWCBwb3NpdGl2ZSDihpIgbm8gb2Zmc2V0J31gKTtcclxuICAgIGNvbnNvbGUubG9nKGAgICAke21pblkgPCAwID8gYOKaoO+4jyAgTmVnYXRpdmUgWTogJHttaW5ZfSDihpIgb2Zmc2V0ICR7TWF0aC5hYnMobWluWSl9ICsgcGFkZGluZyAke2ludGVsbGlnZW50UGFkZGluZ31gIDogJ+KchSBZIHBvc2l0aXZlIOKGkiBubyBvZmZzZXQnfWApO1xyXG4gICAgXHJcbiAgICByZXR1cm4geyB4OiBvZmZzZXRYLCB5OiBvZmZzZXRZIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgoaXRlbSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gRmlyc3QgdHJ5IHRvIGdldCBib3VuZHMgZnJvbSBHZW9tZXRyaWNCb3VuZHMgYXR0cmlidXRlXHJcbiAgICAgIGlmIChpdGVtWydAX0dlb21ldHJpY0JvdW5kcyddKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VHZW9tZXRyaWNCb3VuZHMoaXRlbVsnQF9HZW9tZXRyaWNCb3VuZHMnXSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFRoZW4gdHJ5IHBhdGggZ2VvbWV0cnlcclxuICAgICAgY29uc3QgcGF0aEdlb21ldHJ5ID0gaXRlbT8uUHJvcGVydGllcz8uUGF0aEdlb21ldHJ5Py5HZW9tZXRyeVBhdGhUeXBlPy5QYXRoUG9pbnRBcnJheT8uUGF0aFBvaW50VHlwZTtcclxuICAgICAgXHJcbiAgICAgIGlmICghcGF0aEdlb21ldHJ5IHx8ICFBcnJheS5pc0FycmF5KHBhdGhHZW9tZXRyeSkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgV2FybmluZzogTm8gZ2VvbWV0cnkgZm91bmQgZm9yICR7aXRlbVsnQF9TZWxmJ119LCB1c2luZyBpdGVtIHRyYW5zZm9ybWApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGl0ZW0gdHJhbnNmb3JtIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMucGFyc2VUcmFuc2Zvcm0oaXRlbVsnQF9JdGVtVHJhbnNmb3JtJ10pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0b3A6IHRyYW5zZm9ybS50eSB8fCAwLFxyXG4gICAgICAgICAgbGVmdDogdHJhbnNmb3JtLnR4IHx8IDAsXHJcbiAgICAgICAgICBib3R0b206ICh0cmFuc2Zvcm0udHkgfHwgMCkgKyAxMDAsIC8vIERlZmF1bHQgaGVpZ2h0XHJcbiAgICAgICAgICByaWdodDogKHRyYW5zZm9ybS50eCB8fCAwKSArIDEwMCwgIC8vIERlZmF1bHQgd2lkdGhcclxuICAgICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgICBoZWlnaHQ6IDEwMFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGxldCBtaW5YID0gSW5maW5pdHksIG1pblkgPSBJbmZpbml0eSwgbWF4WCA9IC1JbmZpbml0eSwgbWF4WSA9IC1JbmZpbml0eTtcclxuICAgICAgXHJcbiAgICAgIHBhdGhHZW9tZXRyeS5mb3JFYWNoKHBvaW50ID0+IHtcclxuICAgICAgICBjb25zdCBhbmNob3IgPSBwb2ludFsnQF9BbmNob3InXTtcclxuICAgICAgICBpZiAoYW5jaG9yKSB7XHJcbiAgICAgICAgICBjb25zdCBbeCwgeV0gPSBhbmNob3Iuc3BsaXQoJyAnKS5tYXAocGFyc2VGbG9hdCk7XHJcbiAgICAgICAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xyXG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XHJcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcclxuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xyXG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGlmIChtaW5YID09PSBJbmZpbml0eSB8fCBtaW5ZID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBXYXJuaW5nOiBDb3VsZCBub3QgY2FsY3VsYXRlIGJvdW5kcyBmb3IgJHtpdGVtWydAX1NlbGYnXX1gKTtcclxuICAgICAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogMTAwLCByaWdodDogMTAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMCB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogbWluWSxcclxuICAgICAgICBsZWZ0OiBtaW5YLFxyXG4gICAgICAgIGJvdHRvbTogbWF4WSxcclxuICAgICAgICByaWdodDogbWF4WCxcclxuICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXHJcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNhbGN1bGF0aW5nIGJvdW5kcyBmb3IgJHtpdGVtWydAX1NlbGYnXX06YCwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogMTAwLCByaWdodDogMTAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMCB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZVJlbGF0aXZlUG9zaXRpb24oZnJhbWVCb3VuZHMsIGNvbnRlbnRCb3VuZHMsIGZyYW1lVHJhbnNmb3JtLCBjb250ZW50VHJhbnNmb3JtKSB7XHJcbiAgICBpZiAoIWZyYW1lQm91bmRzIHx8ICFjb250ZW50Qm91bmRzKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb2Zmc2V0WDogKGNvbnRlbnRCb3VuZHMubGVmdCB8fCAwKSAtIChmcmFtZUJvdW5kcy5sZWZ0IHx8IDApLFxyXG4gICAgICBvZmZzZXRZOiAoY29udGVudEJvdW5kcy50b3AgfHwgMCkgLSAoZnJhbWVCb3VuZHMudG9wIHx8IDApLFxyXG4gICAgICBzY2FsZVg6IGNvbnRlbnRUcmFuc2Zvcm0/LmEgfHwgMSxcclxuICAgICAgc2NhbGVZOiBjb250ZW50VHJhbnNmb3JtPy5kIHx8IDEsXHJcbiAgICAgIHRyYW5zZm9ybURpZmZlcmVuY2U6IHtcclxuICAgICAgICBmcmFtZTogZnJhbWVUcmFuc2Zvcm0sXHJcbiAgICAgICAgY29udGVudDogY29udGVudFRyYW5zZm9ybVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUdhcChmcmFtZUJvdW5kcywgY29udGVudEJvdW5kcykge1xyXG4gICAgaWYgKCFmcmFtZUJvdW5kcyB8fCAhY29udGVudEJvdW5kcykgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcDogKGNvbnRlbnRCb3VuZHMudG9wIHx8IDApIC0gKGZyYW1lQm91bmRzLnRvcCB8fCAwKSxcclxuICAgICAgbGVmdDogKGNvbnRlbnRCb3VuZHMubGVmdCB8fCAwKSAtIChmcmFtZUJvdW5kcy5sZWZ0IHx8IDApLFxyXG4gICAgICBib3R0b206IChmcmFtZUJvdW5kcy5ib3R0b20gfHwgMCkgLSAoY29udGVudEJvdW5kcy5ib3R0b20gfHwgMCksXHJcbiAgICAgIHJpZ2h0OiAoZnJhbWVCb3VuZHMucmlnaHQgfHwgMCkgLSAoY29udGVudEJvdW5kcy5yaWdodCB8fCAwKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVJbWFnZVBvc2l0aW9uSW5GcmFtZShmcmFtZUJvdW5kcywgZnJhbWVUcmFuc2Zvcm0sIHBsYWNlZENvbnRlbnQpIHtcclxuICAgIGlmICghZnJhbWVCb3VuZHMgfHwgIXBsYWNlZENvbnRlbnQ/LnRyYW5zZm9ybSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgaW1hZ2VUcmFuc2Zvcm0gPSBwbGFjZWRDb250ZW50LnRyYW5zZm9ybTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGltYWdlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGZyYW1lXHJcbiAgICBjb25zdCBpbWFnZVggPSAoZnJhbWVCb3VuZHMubGVmdCB8fCAwKSArIChpbWFnZVRyYW5zZm9ybS50eCB8fCAwKTtcclxuICAgIGNvbnN0IGltYWdlWSA9IChmcmFtZUJvdW5kcy50b3AgfHwgMCkgKyAoaW1hZ2VUcmFuc2Zvcm0udHkgfHwgMCk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBpbWFnZSBzaXplIHdpdGggc2NhbGluZ1xyXG4gICAgY29uc3QgaW1hZ2VXaWR0aCA9IChmcmFtZUJvdW5kcy53aWR0aCB8fCAwKSAqIChpbWFnZVRyYW5zZm9ybS5hIHx8IDEpO1xyXG4gICAgY29uc3QgaW1hZ2VIZWlnaHQgPSAoZnJhbWVCb3VuZHMuaGVpZ2h0IHx8IDApICogKGltYWdlVHJhbnNmb3JtLmQgfHwgMSk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGltYWdlWCxcclxuICAgICAgeTogaW1hZ2VZLFxyXG4gICAgICB3aWR0aDogaW1hZ2VXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBpbWFnZUhlaWdodCxcclxuICAgICAgc2NhbGVYOiBpbWFnZVRyYW5zZm9ybS5hIHx8IDEsXHJcbiAgICAgIHNjYWxlWTogaW1hZ2VUcmFuc2Zvcm0uZCB8fCAxXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldFhNTFN0cnVjdHVyZShvYmosIG1heERlcHRoID0gMywgY3VycmVudERlcHRoID0gMCkge1xyXG4gICAgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHN0cnVjdHVyZSA9IHt9O1xyXG4gICAgXHJcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XHJcbiAgICAgICAgc3RydWN0dXJlW2tleV0gPSBgQXJyYXlbJHtvYmpba2V5XS5sZW5ndGh9XWA7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0JyAmJiBvYmpba2V5XSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHN0cnVjdHVyZVtrZXldID0gdGhpcy5nZXRYTUxTdHJ1Y3R1cmUob2JqW2tleV0sIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHJ1Y3R1cmVba2V5XSA9IHR5cGVvZiBvYmpba2V5XTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBzdHJ1Y3R1cmU7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaXNGb3JtYXR0aW5nQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmdBdHRyaWJ1dGVzID0gW1xyXG4gICAgICAnQF9Qb2ludFNpemUnLCAnQF9MZWFkaW5nJywgJ0BfVHJhY2tpbmcnLCAnQF9Gb250U3R5bGUnLFxyXG4gICAgICAnQF9BcHBsaWVkRm9udCcsICdAX0ZpbGxDb2xvcicsICdAX1N0cm9rZUNvbG9yJywgJ0BfSnVzdGlmaWNhdGlvbicsXHJcbiAgICAgICdAX0xlZnRJbmRlbnQnLCAnQF9SaWdodEluZGVudCcsICdAX0ZpcnN0TGluZUluZGVudCcsXHJcbiAgICAgICdAX1NwYWNlQmVmb3JlJywgJ0BfU3BhY2VBZnRlcicsICdAX0FsaWdubWVudCdcclxuICAgIF07XHJcbiAgICByZXR1cm4gZm9ybWF0dGluZ0F0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgc2F2ZURlYnVnSW5mbyhkZWJ1Z0luZm8sIGZpbGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVOYW1lLCBKU09OLnN0cmluZ2lmeShkZWJ1Z0luZm8sIG51bGwsIDIpKTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBEZWJ1ZyBpbmZvIHNhdmVkIHRvICR7ZmlsZU5hbWV9YCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3Igc2F2aW5nIGRlYnVnIGluZm86JywgZXJyb3IpO1xyXG4gICAgICBjb25zb2xlLmxvZygnRGVidWcgaW5mbyAoZmlyc3QgMjAwMCBjaGFycyk6JywgSlNPTi5zdHJpbmdpZnkoZGVidWdJbmZvLCBudWxsLCAyKS5zdWJzdHJpbmcoMCwgMjAwMCkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJRE1MVXRpbHM7IFxyXG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJmcyIsIklETUxVdGlscyIsInBhcnNlR2VvbWV0cmljQm91bmRzIiwiYm91bmRzU3RyaW5nIiwiY29uc29sZSIsImxvZyIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiYm91bmRzIiwic3BsaXQiLCJtYXAiLCJwYXJzZUZsb2F0IiwicmVzdWx0IiwicGFyc2VUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1TdHJpbmciLCJhIiwiYiIsImMiLCJkIiwidHgiLCJ0eSIsInZhbHVlcyIsImNhbGN1bGF0ZVJvdGF0aW9uIiwidHJhbnNmb3JtIiwiTWF0aCIsImF0YW4yIiwiUEkiLCJjYWxjdWxhdGVDb3JuZXJzIiwiY29ybmVycyIsInRvcExlZnQiLCJ4IiwieSIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJjb3JuZXIiLCJwb2ludCIsImNteWtUb1JnYiIsIm0iLCJrIiwiciIsInJvdW5kIiwiZyIsInBhcnNlSW5EZXNpZ25Db2xvciIsImNvbG9yUmVmIiwiY215a01hdGNoIiwibWF0Y2giLCJOdW1iZXIiLCJyZ2IiLCJyZ2JNYXRjaCIsInN0YW5kYXJkQ29sb3JzIiwiZGVjb2RlWE1MRW50aXRpZXMiLCJ0ZXh0IiwicmVwbGFjZSIsImNsZWFuVGV4dENvbnRlbnQiLCJjb250ZW50IiwidHJpbSIsInByZXNlcnZlTGluZUJyZWFrcyIsImNsZWFuVGV4dEZvclJlbmRlcmluZyIsInNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nIiwiaGFzUHJvYmxlbWF0aWNUZXh0IiwiaW5jbHVkZXMiLCJKU09OIiwic3RyaW5naWZ5IiwicHJvY2Vzc2VkIiwiY291bnRXb3JkcyIsImZpbHRlciIsIndvcmQiLCJsZW5ndGgiLCJwYXJzZU51bWVyaWMiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIm51bSIsImlzTmFOIiwiaXNJbWFnZUZpbGUiLCJmaWxlTmFtZSIsImltYWdlRXh0ZW5zaW9ucyIsInNvbWUiLCJleHQiLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiZ2V0SW1hZ2VFeHRlbnNpb24iLCJpbWFnZVR5cGVOYW1lIiwidHlwZU1hcCIsImdldEltYWdlRXh0ZW5zaW9uRnJvbUZvcm1hdCIsImZvcm1hdCIsImZvcm1hdE1hcCIsImV4dHJhY3RJbWFnZU5hbWVGcm9tTGluayIsImxpbmtVcmkiLCJjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0IiwiZWxlbWVudHMiLCJtaW5YIiwibWluWSIsIm1heFN0cm9rZVdpZHRoIiwiZWxlbWVudCIsImdlb21ldHJpY0JvdW5kcyIsIm9yaWdpbmFsQm91bmRzIiwiaXRlbVRyYW5zZm9ybSIsImZpbmFsWCIsImZpbmFsWSIsIm1pbiIsInN0cm9rZVdpZHRoIiwic3Ryb2tlV2VpZ2h0IiwibWF4IiwiaW50ZWxsaWdlbnRQYWRkaW5nIiwiY2VpbCIsIm9mZnNldFgiLCJhYnMiLCJvZmZzZXRZIiwiY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgiLCJpdGVtIiwicGF0aEdlb21ldHJ5IiwiUHJvcGVydGllcyIsIlBhdGhHZW9tZXRyeSIsIkdlb21ldHJ5UGF0aFR5cGUiLCJQYXRoUG9pbnRBcnJheSIsIlBhdGhQb2ludFR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJJbmZpbml0eSIsIm1heFgiLCJtYXhZIiwiYW5jaG9yIiwiZXJyb3IiLCJjYWxjdWxhdGVSZWxhdGl2ZVBvc2l0aW9uIiwiZnJhbWVCb3VuZHMiLCJjb250ZW50Qm91bmRzIiwiZnJhbWVUcmFuc2Zvcm0iLCJjb250ZW50VHJhbnNmb3JtIiwic2NhbGVYIiwic2NhbGVZIiwidHJhbnNmb3JtRGlmZmVyZW5jZSIsImZyYW1lIiwiY2FsY3VsYXRlR2FwIiwiY2FsY3VsYXRlSW1hZ2VQb3NpdGlvbkluRnJhbWUiLCJwbGFjZWRDb250ZW50IiwiaW1hZ2VUcmFuc2Zvcm0iLCJpbWFnZVgiLCJpbWFnZVkiLCJpbWFnZVdpZHRoIiwiaW1hZ2VIZWlnaHQiLCJnZXRYTUxTdHJ1Y3R1cmUiLCJvYmoiLCJtYXhEZXB0aCIsImN1cnJlbnREZXB0aCIsInN0cnVjdHVyZSIsImtleSIsImlzRm9ybWF0dGluZ0F0dHJpYnV0ZSIsImF0dHJpYnV0ZU5hbWUiLCJmb3JtYXR0aW5nQXR0cmlidXRlcyIsInNhdmVEZWJ1Z0luZm8iLCJkZWJ1Z0luZm8iLCJ3cml0ZUZpbGVTeW5jIiwic3Vic3RyaW5nIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/utils/IDMLUtils.js\n"));

/***/ })

});