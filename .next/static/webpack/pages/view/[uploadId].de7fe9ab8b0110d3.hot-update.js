"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/IDMLUtils.js":
/*!********************************!*\
  !*** ./lib/utils/IDMLUtils.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"?82df\");\nclass IDMLUtils {\n    static parseGeometricBounds(boundsString) {\n        console.log(\"DEBUG: boundsString =\", boundsString);\n        if (!boundsString || boundsString === \"undefined\") {\n            console.log(\"Warning: Missing geometric bounds, using defaults\");\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n        const bounds = boundsString.split(\" \").map(parseFloat);\n        const result = {\n            top: bounds[0] || 0,\n            left: bounds[1] || 0,\n            bottom: bounds[2] || 0,\n            right: bounds[3] || 0,\n            width: (bounds[3] || 0) - (bounds[1] || 0),\n            height: (bounds[2] || 0) - (bounds[0] || 0)\n        };\n        console.log(\"Parsed bounds:\", result);\n        return result;\n    }\n    static parseTransform(transformString) {\n        if (!transformString) return {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            tx: 0,\n            ty: 0\n        };\n        const values = transformString.split(\" \").map(parseFloat);\n        return {\n            a: values[0] || 1,\n            b: values[1] || 0,\n            c: values[2] || 0,\n            d: values[3] || 1,\n            tx: values[4] || 0,\n            ty: values[5] || 0 // y translation\n        };\n    }\n    static calculateRotation(transform) {\n        // Calculate rotation angle from transform matrix\n        return Math.atan2(transform.b, transform.a) * (180 / Math.PI);\n    }\n    static calculateCorners(bounds, transform) {\n        const corners = {\n            topLeft: {\n                x: bounds.left,\n                y: bounds.top\n            },\n            topRight: {\n                x: bounds.right,\n                y: bounds.top\n            },\n            bottomLeft: {\n                x: bounds.left,\n                y: bounds.bottom\n            },\n            bottomRight: {\n                x: bounds.right,\n                y: bounds.bottom\n            }\n        };\n        // Apply transformation to corners\n        Object.keys(corners).forEach((corner)=>{\n            const point = corners[corner];\n            corners[corner] = {\n                x: transform.a * point.x + transform.c * point.y + transform.tx,\n                y: transform.b * point.x + transform.d * point.y + transform.ty\n            };\n        });\n        return corners;\n    }\n    static cmykToRgb(c, m, y, k) {\n        // Convert CMYK percentages (0-100) to RGB (0-255)\n        c = c / 100;\n        m = m / 100;\n        y = y / 100;\n        k = k / 100;\n        const r = Math.round(255 * (1 - c) * (1 - k));\n        const g = Math.round(255 * (1 - m) * (1 - k));\n        const b = Math.round(255 * (1 - y) * (1 - k));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    static parseInDesignColor(colorRef) {\n        if (!colorRef || colorRef === \"Color/None\") return null;\n        // Handle CMYK colors\n        const cmykMatch = colorRef.match(/Color\\/C=(\\d+)\\s*M=(\\d+)\\s*Y=(\\d+)\\s*K=(\\d+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map(Number);\n            const rgb = this.cmykToRgb(c, m, y, k);\n            return \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n        }\n        // Handle RGB colors\n        const rgbMatch = colorRef.match(/Color\\/R=(\\d+)\\s*G=(\\d+)\\s*B=(\\d+)/);\n        if (rgbMatch) {\n            const [, r, g, b] = rgbMatch.map(Number);\n            return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n        }\n        // Standard colors\n        const standardColors = {\n            \"Color/Black\": \"rgb(0, 0, 0)\",\n            \"Color/White\": \"rgb(255, 255, 255)\",\n            \"Color/Red\": \"rgb(255, 0, 0)\",\n            \"Color/Green\": \"rgb(0, 255, 0)\",\n            \"Color/Blue\": \"rgb(0, 0, 255)\",\n            \"Color/Cyan\": \"rgb(0, 255, 255)\",\n            \"Color/Magenta\": \"rgb(255, 0, 255)\",\n            \"Color/Yellow\": \"rgb(255, 255, 0)\",\n            \"Color/Paper\": \"rgb(255, 255, 255)\",\n            \"Color/Registration\": \"rgb(0, 0, 0)\"\n        };\n        return standardColors[colorRef] || null;\n    }\n    static decodeXMLEntities(text) {\n        if (!text) return \"\";\n        return text.replace(/&#x000A;/g, \"\\n\") // Line feed\n        .replace(/&#x000D;/g, \"\\r\") // Carriage return\n        .replace(/&#x0009;/g, \"\t\") // Tab\n        .replace(/&#x00A0;/g, \"\\xa0\") // Non-breaking space\n        .replace(/&#x2028;/g, \"\\u2028\") // Line separator\n        .replace(/&#x2029;/g, \"\\u2029\") // Paragraph separator\n        .replace(/&#10;/g, \"\\n\") // Decimal line feed\n        .replace(/&#13;/g, \"\\r\") // Decimal carriage return\n        .replace(/&#9;/g, \"\t\") // Decimal tab\n        .replace(/&#160;/g, \"\\xa0\") // Decimal non-breaking space\n        .replace(/&lt;/g, \"<\") // Less than\n        .replace(/&gt;/g, \">\") // Greater than\n        .replace(/&amp;/g, \"&\") // Ampersand (must be last)\n        .replace(/&quot;/g, '\"') // Quote\n        .replace(/&apos;/g, \"'\"); // Apostrophe\n    }\n    static cleanTextContent(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\t/g, \"    \") // Convert tabs to spaces\n        .replace(/\\u00A0/g, \" \") // Convert non-breaking spaces\n        .replace(/ +/g, \" \") // Collapse multiple spaces\n        .replace(/\\n{3,}/g, \"\\n\\n\") // Maximum 2 consecutive line breaks\n        .trim();\n    }\n    static preserveLineBreaks(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\") // Convert paragraph separators\n        .replace(/\\n{3,}/g, \"\\n\\n\"); // Maximum 2 consecutive line breaks\n    }\n    // NEW: Clean up excessive line breaks to prevent text overflow  \n    static cleanTextForRendering(text) {\n        if (!text) return \"\";\n        return text// Remove excessive line breaks (more than 2 consecutive)\n        .replace(/\\n{3,}/g, \"\\n\\n\")// Remove line breaks followed by only whitespace and then another line break\n        .replace(/\\n\\s*\\n/g, \"\\n\\n\")// Remove trailing whitespace on lines (but preserve single spaces between words)\n        .replace(/[ \\t]+\\n/g, \"\\n\")// Clean up multiple spaces (but preserve single spaces - IMPORTANT for word separation)\n        .replace(/[ \\t]{3,}/g, \"  \") // Reduce 3+ spaces to 2 spaces max\n        // Remove leading/trailing whitespace\n        .trim();\n    }\n    // ENHANCED: Better line break processing that preserves word spaces\n    static sophisticatedLineBreakProcessing(content) {\n        if (!content) return \"\";\n        // DEBUG: Track if problematic text is being processed\n        const hasProblematicText = content.includes(\"pavoluptusda\") || content.includes(\"pa\") && content.includes(\"voluptusda\");\n        if (hasProblematicText) {\n            console.log(\"\\uD83D\\uDD27 IDMLUtils.sophisticatedLineBreakProcessing:\");\n            console.log(\"   - Input:\", JSON.stringify(content));\n        }\n        // First clean up the content but preserve word spaces\n        let processed = this.cleanTextForRendering(content);\n        if (hasProblematicText) {\n            console.log(\"   - After cleanTextForRendering:\", JSON.stringify(processed));\n        }\n        // Normalize line breaks but don't touch word spaces\n        processed = processed.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\") // Convert paragraph separators to double breaks\n        .replace(/\\u000A/g, \"\\n\"); // Convert explicit line feed characters\n        // Ensure paragraph breaks are properly spaced\n        processed = processed.replace(/\\n\\n+/g, \"\\n\\n\");\n        if (hasProblematicText) {\n            console.log(\"   - Final output:\", JSON.stringify(processed));\n            console.log('   - Contains \"pa voluptusda\":', processed.includes(\"pa voluptusda\"));\n            console.log('   - Contains \"pavoluptusda\":', processed.includes(\"pavoluptusda\"));\n        }\n        return processed;\n    }\n    static countWords(text) {\n        return text.split(/\\s+/).filter((word)=>word.length > 0).length;\n    }\n    static parseNumeric(value) {\n        if (value === null || value === undefined || value === \"\") return null;\n        const num = parseFloat(value);\n        return isNaN(num) ? null : num;\n    }\n    static isImageFile(fileName) {\n        const imageExtensions = [\n            \".jpg\",\n            \".jpeg\",\n            \".png\",\n            \".gif\",\n            \".tiff\",\n            \".tif\",\n            \".bmp\",\n            \".svg\",\n            \".eps\",\n            \".ai\",\n            \".psd\",\n            \".webp\",\n            \".ico\",\n            \".jfif\",\n            \".jp2\",\n            \".jpx\"\n        ];\n        return imageExtensions.some((ext)=>fileName.toLowerCase().endsWith(ext));\n    }\n    static getImageExtension(imageTypeName) {\n        const typeMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return typeMap[imageTypeName] || \"jpg\";\n    }\n    static getImageExtensionFromFormat(format) {\n        const formatMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return formatMap[format] || \"jpg\";\n    }\n    static extractImageNameFromLink(linkUri) {\n        if (!linkUri) return null;\n        // Extract filename from path like \"file:C:/Users/lalo/Downloads/Tesla-Model-3.jpg 13325 \"\n        const match = linkUri.match(/([^\\/\\\\]+)\\.[^.]+$/);\n        return match ? match[1] : null;\n    }\n    static calculateCoordinateOffset(elements) {\n        console.log(\"\\uD83D\\uDEAB COORDINATE OFFSET DISABLED FOR DEBUGGING\");\n        console.log(\"   This will show elements at their RAW IDML coordinates\");\n        console.log(\"   If elements are positioned correctly now, the issue was with offset calculation\");\n        console.log(\"   If elements are still wrong, the issue is elsewhere\");\n        // TEMPORARY: Return zero offset to see raw IDML positioning\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    static calculateBoundsFromPath(item) {\n        try {\n            var _item_Properties_PathGeometry_GeometryPathType_PathPointArray, _item_Properties_PathGeometry_GeometryPathType, _item_Properties_PathGeometry, _item_Properties;\n            // First try to get bounds from GeometricBounds attribute\n            if (item[\"@_GeometricBounds\"]) {\n                return this.parseGeometricBounds(item[\"@_GeometricBounds\"]);\n            }\n            // Then try path geometry\n            const pathGeometry = item === null || item === void 0 ? void 0 : (_item_Properties = item.Properties) === null || _item_Properties === void 0 ? void 0 : (_item_Properties_PathGeometry = _item_Properties.PathGeometry) === null || _item_Properties_PathGeometry === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType = _item_Properties_PathGeometry.GeometryPathType) === null || _item_Properties_PathGeometry_GeometryPathType === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType_PathPointArray = _item_Properties_PathGeometry_GeometryPathType.PathPointArray) === null || _item_Properties_PathGeometry_GeometryPathType_PathPointArray === void 0 ? void 0 : _item_Properties_PathGeometry_GeometryPathType_PathPointArray.PathPointType;\n            if (!pathGeometry || !Array.isArray(pathGeometry)) {\n                console.log(\"Warning: No geometry found for \".concat(item[\"@_Self\"], \", using item transform\"));\n                // Fallback to item transform if available\n                const transform = this.parseTransform(item[\"@_ItemTransform\"]);\n                return {\n                    top: transform.ty || 0,\n                    left: transform.tx || 0,\n                    bottom: (transform.ty || 0) + 100,\n                    right: (transform.tx || 0) + 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n            pathGeometry.forEach((point)=>{\n                const anchor = point[\"@_Anchor\"];\n                if (anchor) {\n                    const [x, y] = anchor.split(\" \").map(parseFloat);\n                    if (!isNaN(x) && !isNaN(y)) {\n                        minX = Math.min(minX, x);\n                        maxX = Math.max(maxX, x);\n                        minY = Math.min(minY, y);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            });\n            if (minX === Infinity || minY === Infinity) {\n                console.log(\"Warning: Could not calculate bounds for \".concat(item[\"@_Self\"]));\n                return {\n                    top: 0,\n                    left: 0,\n                    bottom: 100,\n                    right: 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            return {\n                top: minY,\n                left: minX,\n                bottom: maxY,\n                right: maxX,\n                width: maxX - minX,\n                height: maxY - minY\n            };\n        } catch (error) {\n            console.error(\"Error calculating bounds for \".concat(item[\"@_Self\"], \":\"), error);\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n    }\n    static calculateRelativePosition(frameBounds, contentBounds, frameTransform, contentTransform) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            offsetX: (contentBounds.left || 0) - (frameBounds.left || 0),\n            offsetY: (contentBounds.top || 0) - (frameBounds.top || 0),\n            scaleX: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.a) || 1,\n            scaleY: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.d) || 1,\n            transformDifference: {\n                frame: frameTransform,\n                content: contentTransform\n            }\n        };\n    }\n    static calculateGap(frameBounds, contentBounds) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            top: (contentBounds.top || 0) - (frameBounds.top || 0),\n            left: (contentBounds.left || 0) - (frameBounds.left || 0),\n            bottom: (frameBounds.bottom || 0) - (contentBounds.bottom || 0),\n            right: (frameBounds.right || 0) - (contentBounds.right || 0)\n        };\n    }\n    static calculateImagePositionInFrame(frameBounds, frameTransform, placedContent) {\n        if (!frameBounds || !(placedContent === null || placedContent === void 0 ? void 0 : placedContent.transform)) {\n            return null;\n        }\n        const imageTransform = placedContent.transform;\n        // Calculate image position relative to frame\n        const imageX = (frameBounds.left || 0) + (imageTransform.tx || 0);\n        const imageY = (frameBounds.top || 0) + (imageTransform.ty || 0);\n        // Calculate image size with scaling\n        const imageWidth = (frameBounds.width || 0) * (imageTransform.a || 1);\n        const imageHeight = (frameBounds.height || 0) * (imageTransform.d || 1);\n        return {\n            x: imageX,\n            y: imageY,\n            width: imageWidth,\n            height: imageHeight,\n            scaleX: imageTransform.a || 1,\n            scaleY: imageTransform.d || 1\n        };\n    }\n    static getXMLStructure(obj) {\n        let maxDepth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        if (currentDepth >= maxDepth || typeof obj !== \"object\" || obj === null) {\n            return typeof obj;\n        }\n        const structure = {};\n        Object.keys(obj).forEach((key)=>{\n            if (Array.isArray(obj[key])) {\n                structure[key] = \"Array[\".concat(obj[key].length, \"]\");\n            } else if (typeof obj[key] === \"object\" && obj[key] !== null) {\n                structure[key] = this.getXMLStructure(obj[key], maxDepth, currentDepth + 1);\n            } else {\n                structure[key] = typeof obj[key];\n            }\n        });\n        return structure;\n    }\n    static isFormattingAttribute(attributeName) {\n        const formattingAttributes = [\n            \"@_PointSize\",\n            \"@_Leading\",\n            \"@_Tracking\",\n            \"@_FontStyle\",\n            \"@_AppliedFont\",\n            \"@_FillColor\",\n            \"@_StrokeColor\",\n            \"@_Justification\",\n            \"@_LeftIndent\",\n            \"@_RightIndent\",\n            \"@_FirstLineIndent\",\n            \"@_SpaceBefore\",\n            \"@_SpaceAfter\",\n            \"@_Alignment\"\n        ];\n        return formattingAttributes.includes(attributeName);\n    }\n    static saveDebugInfo(debugInfo, fileName) {\n        try {\n            fs.writeFileSync(fileName, JSON.stringify(debugInfo, null, 2));\n            console.log(\"✅ Debug info saved to \".concat(fileName));\n        } catch (error) {\n            console.error(\"❌ Error saving debug info:\", error);\n            console.log(\"Debug info (first 2000 chars):\", JSON.stringify(debugInfo, null, 2).substring(0, 2000));\n        }\n    }\n}\nmodule.exports = IDMLUtils;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RyxDQUFDSSxJQUFJO1lBQ2xDO1FBQ0Y7UUFFQSxPQUFPRDtJQUNUO0lBRUEsT0FBT0Usc0JBQXNCQyxhQUFhLEVBQUU7UUFDMUMsTUFBTUMsdUJBQXVCO1lBQzNCO1lBQWU7WUFBYTtZQUFjO1lBQzFDO1lBQWlCO1lBQWU7WUFBaUI7WUFDakQ7WUFBZ0I7WUFBaUI7WUFDakM7WUFBaUI7WUFBZ0I7U0FDbEM7UUFDRCxPQUFPQSxxQkFBcUI1RSxRQUFRLENBQUMyRTtJQUN2QztJQUVBLE9BQU9FLGNBQWNDLFNBQVMsRUFBRWhFLFFBQVEsRUFBRTtRQUN4QyxJQUFJO1lBQ0ZsRixHQUFHbUosYUFBYSxDQUFDakUsVUFBVWIsS0FBS0MsU0FBUyxDQUFDNEUsV0FBVyxNQUFNO1lBQzNEOUksUUFBUUMsR0FBRyxDQUFDLHlCQUFrQyxPQUFUNkU7UUFDdkMsRUFBRSxPQUFPa0MsT0FBTztZQUNkaEgsUUFBUWdILEtBQUssQ0FBQyw4QkFBOEJBO1lBQzVDaEgsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQ2dFLEtBQUtDLFNBQVMsQ0FBQzRFLFdBQVcsTUFBTSxHQUFHRSxTQUFTLENBQUMsR0FBRztRQUNoRztJQUNGO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHckoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3V0aWxzL0lETUxVdGlscy5qcz84ZDJmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcclxuXHJcbmNsYXNzIElETUxVdGlscyB7XHJcbiAgc3RhdGljIHBhcnNlR2VvbWV0cmljQm91bmRzKGJvdW5kc1N0cmluZykge1xyXG4gICAgY29uc29sZS5sb2coJ0RFQlVHOiBib3VuZHNTdHJpbmcgPScsIGJvdW5kc1N0cmluZyk7XHJcbiAgICBpZiAoIWJvdW5kc1N0cmluZyB8fCBib3VuZHNTdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiBNaXNzaW5nIGdlb21ldHJpYyBib3VuZHMsIHVzaW5nIGRlZmF1bHRzJyk7XHJcbiAgICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiAxMDAsIHJpZ2h0OiAxMDAsIHdpZHRoOiAxMDAsIGhlaWdodDogMTAwIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGJvdW5kcyA9IGJvdW5kc1N0cmluZy5zcGxpdCgnICcpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgdG9wOiBib3VuZHNbMF0gfHwgMCxcclxuICAgICAgbGVmdDogYm91bmRzWzFdIHx8IDAsXHJcbiAgICAgIGJvdHRvbTogYm91bmRzWzJdIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBib3VuZHNbM10gfHwgMCxcclxuICAgICAgd2lkdGg6IChib3VuZHNbM10gfHwgMCkgLSAoYm91bmRzWzFdIHx8IDApLFxyXG4gICAgICBoZWlnaHQ6IChib3VuZHNbMl0gfHwgMCkgLSAoYm91bmRzWzBdIHx8IDApXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnUGFyc2VkIGJvdW5kczonLCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm1TdHJpbmcpIHtcclxuICAgIGlmICghdHJhbnNmb3JtU3RyaW5nKSByZXR1cm4geyBhOiAxLCBiOiAwLCBjOiAwLCBkOiAxLCB0eDogMCwgdHk6IDAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgdmFsdWVzID0gdHJhbnNmb3JtU3RyaW5nLnNwbGl0KCcgJykubWFwKHBhcnNlRmxvYXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYTogdmFsdWVzWzBdIHx8IDEsICAgLy8geCBzY2FsZVxyXG4gICAgICBiOiB2YWx1ZXNbMV0gfHwgMCwgICAvLyB5IHNrZXdcclxuICAgICAgYzogdmFsdWVzWzJdIHx8IDAsICAgLy8geCBza2V3XHJcbiAgICAgIGQ6IHZhbHVlc1szXSB8fCAxLCAgIC8vIHkgc2NhbGVcclxuICAgICAgdHg6IHZhbHVlc1s0XSB8fCAwLCAgLy8geCB0cmFuc2xhdGlvblxyXG4gICAgICB0eTogdmFsdWVzWzVdIHx8IDAgICAvLyB5IHRyYW5zbGF0aW9uXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZVJvdGF0aW9uKHRyYW5zZm9ybSkge1xyXG4gICAgLy8gQ2FsY3VsYXRlIHJvdGF0aW9uIGFuZ2xlIGZyb20gdHJhbnNmb3JtIG1hdHJpeFxyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIodHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5hKSAqICgxODAgLyBNYXRoLlBJKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVDb3JuZXJzKGJvdW5kcywgdHJhbnNmb3JtKSB7XHJcbiAgICBjb25zdCBjb3JuZXJzID0ge1xyXG4gICAgICB0b3BMZWZ0OiB7IHg6IGJvdW5kcy5sZWZ0LCB5OiBib3VuZHMudG9wIH0sXHJcbiAgICAgIHRvcFJpZ2h0OiB7IHg6IGJvdW5kcy5yaWdodCwgeTogYm91bmRzLnRvcCB9LFxyXG4gICAgICBib3R0b21MZWZ0OiB7IHg6IGJvdW5kcy5sZWZ0LCB5OiBib3VuZHMuYm90dG9tIH0sXHJcbiAgICAgIGJvdHRvbVJpZ2h0OiB7IHg6IGJvdW5kcy5yaWdodCwgeTogYm91bmRzLmJvdHRvbSB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbiB0byBjb3JuZXJzXHJcbiAgICBPYmplY3Qua2V5cyhjb3JuZXJzKS5mb3JFYWNoKGNvcm5lciA9PiB7XHJcbiAgICAgIGNvbnN0IHBvaW50ID0gY29ybmVyc1tjb3JuZXJdO1xyXG4gICAgICBjb3JuZXJzW2Nvcm5lcl0gPSB7XHJcbiAgICAgICAgeDogKHRyYW5zZm9ybS5hICogcG9pbnQueCkgKyAodHJhbnNmb3JtLmMgKiBwb2ludC55KSArIHRyYW5zZm9ybS50eCxcclxuICAgICAgICB5OiAodHJhbnNmb3JtLmIgKiBwb2ludC54KSArICh0cmFuc2Zvcm0uZCAqIHBvaW50LnkpICsgdHJhbnNmb3JtLnR5XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGNvcm5lcnM7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY215a1RvUmdiKGMsIG0sIHksIGspIHtcclxuICAgIC8vIENvbnZlcnQgQ01ZSyBwZXJjZW50YWdlcyAoMC0xMDApIHRvIFJHQiAoMC0yNTUpXHJcbiAgICBjID0gYyAvIDEwMDtcclxuICAgIG0gPSBtIC8gMTAwO1xyXG4gICAgeSA9IHkgLyAxMDA7XHJcbiAgICBrID0gayAvIDEwMDtcclxuXHJcbiAgICBjb25zdCByID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIGMpICogKDEgLSBrKSk7XHJcbiAgICBjb25zdCBnID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIG0pICogKDEgLSBrKSk7XHJcbiAgICBjb25zdCBiID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIHkpICogKDEgLSBrKSk7XHJcblxyXG4gICAgcmV0dXJuIHsgciwgZywgYiB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlSW5EZXNpZ25Db2xvcihjb2xvclJlZikge1xyXG4gICAgaWYgKCFjb2xvclJlZiB8fCBjb2xvclJlZiA9PT0gJ0NvbG9yL05vbmUnKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIENNWUsgY29sb3JzXHJcbiAgICBjb25zdCBjbXlrTWF0Y2ggPSBjb2xvclJlZi5tYXRjaCgvQ29sb3JcXC9DPShcXGQrKVxccypNPShcXGQrKVxccypZPShcXGQrKVxccypLPShcXGQrKS8pO1xyXG4gICAgaWYgKGNteWtNYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCBjLCBtLCB5LCBrXSA9IGNteWtNYXRjaC5tYXAoTnVtYmVyKTtcclxuICAgICAgY29uc3QgcmdiID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cmdiLnJ9LCAke3JnYi5nfSwgJHtyZ2IuYn0pYDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIFJHQiBjb2xvcnNcclxuICAgIGNvbnN0IHJnYk1hdGNoID0gY29sb3JSZWYubWF0Y2goL0NvbG9yXFwvUj0oXFxkKylcXHMqRz0oXFxkKylcXHMqQj0oXFxkKykvKTtcclxuICAgIGlmIChyZ2JNYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCByLCBnLCBiXSA9IHJnYk1hdGNoLm1hcChOdW1iZXIpO1xyXG4gICAgICByZXR1cm4gYHJnYigke3J9LCAke2d9LCAke2J9KWA7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFN0YW5kYXJkIGNvbG9yc1xyXG4gICAgY29uc3Qgc3RhbmRhcmRDb2xvcnMgPSB7XHJcbiAgICAgICdDb2xvci9CbGFjayc6ICdyZ2IoMCwgMCwgMCknLFxyXG4gICAgICAnQ29sb3IvV2hpdGUnOiAncmdiKDI1NSwgMjU1LCAyNTUpJyxcclxuICAgICAgJ0NvbG9yL1JlZCc6ICdyZ2IoMjU1LCAwLCAwKScsXHJcbiAgICAgICdDb2xvci9HcmVlbic6ICdyZ2IoMCwgMjU1LCAwKScsXHJcbiAgICAgICdDb2xvci9CbHVlJzogJ3JnYigwLCAwLCAyNTUpJyxcclxuICAgICAgJ0NvbG9yL0N5YW4nOiAncmdiKDAsIDI1NSwgMjU1KScsXHJcbiAgICAgICdDb2xvci9NYWdlbnRhJzogJ3JnYigyNTUsIDAsIDI1NSknLFxyXG4gICAgICAnQ29sb3IvWWVsbG93JzogJ3JnYigyNTUsIDI1NSwgMCknLFxyXG4gICAgICAnQ29sb3IvUGFwZXInOiAncmdiKDI1NSwgMjU1LCAyNTUpJyxcclxuICAgICAgJ0NvbG9yL1JlZ2lzdHJhdGlvbic6ICdyZ2IoMCwgMCwgMCknXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4gc3RhbmRhcmRDb2xvcnNbY29sb3JSZWZdIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZGVjb2RlWE1MRW50aXRpZXModGV4dCkge1xyXG4gICAgaWYgKCF0ZXh0KSByZXR1cm4gJyc7XHJcbiAgICBcclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMDBBOy9nLCAnXFxuJykgICAgICAvLyBMaW5lIGZlZWRcclxuICAgICAgLnJlcGxhY2UoLyYjeDAwMEQ7L2csICdcXHInKSAgICAgIC8vIENhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiN4MDAwOTsvZywgJ1xcdCcpICAgICAgLy8gVGFiXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMEEwOy9nLCAnXFx1MDBBMCcpICAvLyBOb24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgLnJlcGxhY2UoLyYjeDIwMjg7L2csICdcXHUyMDI4JykgIC8vIExpbmUgc2VwYXJhdG9yXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gyMDI5Oy9nLCAnXFx1MjAyOScpICAvLyBQYXJhZ3JhcGggc2VwYXJhdG9yXHJcbiAgICAgIC5yZXBsYWNlKC8mIzEwOy9nLCAnXFxuJykgICAgICAgICAvLyBEZWNpbWFsIGxpbmUgZmVlZFxyXG4gICAgICAucmVwbGFjZSgvJiMxMzsvZywgJ1xccicpICAgICAgICAgLy8gRGVjaW1hbCBjYXJyaWFnZSByZXR1cm5cclxuICAgICAgLnJlcGxhY2UoLyYjOTsvZywgJ1xcdCcpICAgICAgICAgIC8vIERlY2ltYWwgdGFiXHJcbiAgICAgIC5yZXBsYWNlKC8mIzE2MDsvZywgJ1xcdTAwQTAnKSAgICAvLyBEZWNpbWFsIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpICAgICAgICAgICAvLyBMZXNzIHRoYW5cclxuICAgICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKSAgICAgICAgICAgLy8gR3JlYXRlciB0aGFuXHJcbiAgICAgIC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpICAgICAgICAgIC8vIEFtcGVyc2FuZCAobXVzdCBiZSBsYXN0KVxyXG4gICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpICAgICAgICAgLy8gUXVvdGVcclxuICAgICAgLnJlcGxhY2UoLyZhcG9zOy9nLCBcIidcIik7ICAgICAgICAvLyBBcG9zdHJvcGhlXHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2xlYW5UZXh0Q29udGVudChjb250ZW50KSB7XHJcbiAgICByZXR1cm4gY29udGVudFxyXG4gICAgICAucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKSAgICAgIC8vIE5vcm1hbGl6ZSBXaW5kb3dzIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcbicpICAgICAgICAvLyBOb3JtYWxpemUgb2xkIE1hYyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJykgICAgICAvLyBDb252ZXJ0IHRhYnMgdG8gc3BhY2VzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUwMEEwL2csICcgJykgICAgIC8vIENvbnZlcnQgbm9uLWJyZWFraW5nIHNwYWNlc1xyXG4gICAgICAucmVwbGFjZSgvICsvZywgJyAnKSAgICAgICAgIC8vIENvbGxhcHNlIG11bHRpcGxlIHNwYWNlc1xyXG4gICAgICAucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJykgIC8vIE1heGltdW0gMiBjb25zZWN1dGl2ZSBsaW5lIGJyZWFrc1xyXG4gICAgICAudHJpbSgpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHByZXNlcnZlTGluZUJyZWFrcyhjb250ZW50KSB7XHJcbiAgICByZXR1cm4gY29udGVudFxyXG4gICAgICAucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKSAgICAgIC8vIE5vcm1hbGl6ZSBXaW5kb3dzIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcbicpICAgICAgICAvLyBOb3JtYWxpemUgb2xkIE1hYyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxuJykgICAgLy8gQ29udmVydCBsaW5lIHNlcGFyYXRvcnNcclxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcblxcbicpICAvLyBDb252ZXJ0IHBhcmFncmFwaCBzZXBhcmF0b3JzXHJcbiAgICAgIC5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKTsgLy8gTWF4aW11bSAyIGNvbnNlY3V0aXZlIGxpbmUgYnJlYWtzXHJcbiAgfVxyXG5cclxuICAvLyBORVc6IENsZWFuIHVwIGV4Y2Vzc2l2ZSBsaW5lIGJyZWFrcyB0byBwcmV2ZW50IHRleHQgb3ZlcmZsb3cgIFxyXG4gIHN0YXRpYyBjbGVhblRleHRGb3JSZW5kZXJpbmcodGV4dCkge1xyXG4gICAgaWYgKCF0ZXh0KSByZXR1cm4gJyc7XHJcbiAgICBcclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgIC8vIFJlbW92ZSBleGNlc3NpdmUgbGluZSBicmVha3MgKG1vcmUgdGhhbiAyIGNvbnNlY3V0aXZlKVxyXG4gICAgICAucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJylcclxuICAgICAgLy8gUmVtb3ZlIGxpbmUgYnJlYWtzIGZvbGxvd2VkIGJ5IG9ubHkgd2hpdGVzcGFjZSBhbmQgdGhlbiBhbm90aGVyIGxpbmUgYnJlYWtcclxuICAgICAgLnJlcGxhY2UoL1xcblxccypcXG4vZywgJ1xcblxcbicpXHJcbiAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG9uIGxpbmVzIChidXQgcHJlc2VydmUgc2luZ2xlIHNwYWNlcyBiZXR3ZWVuIHdvcmRzKVxyXG4gICAgICAucmVwbGFjZSgvWyBcXHRdK1xcbi9nLCAnXFxuJylcclxuICAgICAgLy8gQ2xlYW4gdXAgbXVsdGlwbGUgc3BhY2VzIChidXQgcHJlc2VydmUgc2luZ2xlIHNwYWNlcyAtIElNUE9SVEFOVCBmb3Igd29yZCBzZXBhcmF0aW9uKVxyXG4gICAgICAucmVwbGFjZSgvWyBcXHRdezMsfS9nLCAnICAnKSAvLyBSZWR1Y2UgMysgc3BhY2VzIHRvIDIgc3BhY2VzIG1heFxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXHJcbiAgICAgIC50cmltKCk7XHJcbiAgfVxyXG5cclxuICAvLyBFTkhBTkNFRDogQmV0dGVyIGxpbmUgYnJlYWsgcHJvY2Vzc2luZyB0aGF0IHByZXNlcnZlcyB3b3JkIHNwYWNlc1xyXG4gIHN0YXRpYyBzb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyhjb250ZW50KSB7XHJcbiAgICBpZiAoIWNvbnRlbnQpIHJldHVybiAnJztcclxuICAgIFxyXG4gICAgLy8gREVCVUc6IFRyYWNrIGlmIHByb2JsZW1hdGljIHRleHQgaXMgYmVpbmcgcHJvY2Vzc2VkXHJcbiAgICBjb25zdCBoYXNQcm9ibGVtYXRpY1RleHQgPSBjb250ZW50LmluY2x1ZGVzKCdwYXZvbHVwdHVzZGEnKSB8fCAoY29udGVudC5pbmNsdWRlcygncGEnKSAmJiBjb250ZW50LmluY2x1ZGVzKCd2b2x1cHR1c2RhJykpO1xyXG4gICAgaWYgKGhhc1Byb2JsZW1hdGljVGV4dCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UpyBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3Npbmc6Jyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIElucHV0OicsIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRmlyc3QgY2xlYW4gdXAgdGhlIGNvbnRlbnQgYnV0IHByZXNlcnZlIHdvcmQgc3BhY2VzXHJcbiAgICBsZXQgcHJvY2Vzc2VkID0gdGhpcy5jbGVhblRleHRGb3JSZW5kZXJpbmcoY29udGVudCk7XHJcbiAgICBcclxuICAgIGlmIChoYXNQcm9ibGVtYXRpY1RleHQpIHtcclxuICAgICAgY29uc29sZS5sb2coJyAgIC0gQWZ0ZXIgY2xlYW5UZXh0Rm9yUmVuZGVyaW5nOicsIEpTT04uc3RyaW5naWZ5KHByb2Nlc3NlZCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBOb3JtYWxpemUgbGluZSBicmVha3MgYnV0IGRvbid0IHRvdWNoIHdvcmQgc3BhY2VzXHJcbiAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWRcclxuICAgICAgLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykgICAgICAvLyBOb3JtYWxpemUgV2luZG93cyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXG4nKSAgICAgICAgLy8gTm9ybWFsaXplIG9sZCBNYWMgbGluZSBicmVha3NcclxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcbicpICAgIC8vIENvbnZlcnQgbGluZSBzZXBhcmF0b3JzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXG5cXG4nKSAgLy8gQ29udmVydCBwYXJhZ3JhcGggc2VwYXJhdG9ycyB0byBkb3VibGUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUwMDBBL2csICdcXG4nKTsgICAvLyBDb252ZXJ0IGV4cGxpY2l0IGxpbmUgZmVlZCBjaGFyYWN0ZXJzXHJcbiAgICBcclxuICAgIC8vIEVuc3VyZSBwYXJhZ3JhcGggYnJlYWtzIGFyZSBwcm9wZXJseSBzcGFjZWRcclxuICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5yZXBsYWNlKC9cXG5cXG4rL2csICdcXG5cXG4nKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc1Byb2JsZW1hdGljVGV4dCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBGaW5hbCBvdXRwdXQ6JywgSlNPTi5zdHJpbmdpZnkocHJvY2Vzc2VkKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIENvbnRhaW5zIFwicGEgdm9sdXB0dXNkYVwiOicsIHByb2Nlc3NlZC5pbmNsdWRlcygncGEgdm9sdXB0dXNkYScpKTtcclxuICAgICAgY29uc29sZS5sb2coJyAgIC0gQ29udGFpbnMgXCJwYXZvbHVwdHVzZGFcIjonLCBwcm9jZXNzZWQuaW5jbHVkZXMoJ3Bhdm9sdXB0dXNkYScpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHByb2Nlc3NlZDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjb3VudFdvcmRzKHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0LnNwbGl0KC9cXHMrLykuZmlsdGVyKHdvcmQgPT4gd29yZC5sZW5ndGggPiAwKS5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VOdW1lcmljKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICByZXR1cm4gaXNOYU4obnVtKSA/IG51bGwgOiBudW07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaXNJbWFnZUZpbGUoZmlsZU5hbWUpIHtcclxuICAgIGNvbnN0IGltYWdlRXh0ZW5zaW9ucyA9IFtcclxuICAgICAgJy5qcGcnLCAnLmpwZWcnLCAnLnBuZycsICcuZ2lmJywgJy50aWZmJywgJy50aWYnLCAnLmJtcCcsICcuc3ZnJywgXHJcbiAgICAgICcuZXBzJywgJy5haScsICcucHNkJywgJy53ZWJwJywgJy5pY28nLCAnLmpmaWYnLCAnLmpwMicsICcuanB4J1xyXG4gICAgXTtcclxuICAgIHJldHVybiBpbWFnZUV4dGVuc2lvbnMuc29tZShleHQgPT4gZmlsZU5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRJbWFnZUV4dGVuc2lvbihpbWFnZVR5cGVOYW1lKSB7XHJcbiAgICBjb25zdCB0eXBlTWFwID0ge1xyXG4gICAgICAnJElEL0pQRUcnOiAnanBnJyxcclxuICAgICAgJyRJRC9QTkcnOiAncG5nJywgXHJcbiAgICAgICckSUQvVElGRic6ICd0aWYnLFxyXG4gICAgICAnJElEL0dJRic6ICdnaWYnLFxyXG4gICAgICAnJElEL0JNUCc6ICdibXAnXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHR5cGVNYXBbaW1hZ2VUeXBlTmFtZV0gfHwgJ2pwZyc7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0SW1hZ2VFeHRlbnNpb25Gcm9tRm9ybWF0KGZvcm1hdCkge1xyXG4gICAgY29uc3QgZm9ybWF0TWFwID0ge1xyXG4gICAgICAnJElEL0pQRUcnOiAnanBnJyxcclxuICAgICAgJyRJRC9QTkcnOiAncG5nJyxcclxuICAgICAgJyRJRC9USUZGJzogJ3RpZicsXHJcbiAgICAgICckSUQvR0lGJzogJ2dpZicsXHJcbiAgICAgICckSUQvQk1QJzogJ2JtcCdcclxuICAgIH07XHJcbiAgICByZXR1cm4gZm9ybWF0TWFwW2Zvcm1hdF0gfHwgJ2pwZyc7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZXh0cmFjdEltYWdlTmFtZUZyb21MaW5rKGxpbmtVcmkpIHtcclxuICAgIGlmICghbGlua1VyaSkgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgZmlsZW5hbWUgZnJvbSBwYXRoIGxpa2UgXCJmaWxlOkM6L1VzZXJzL2xhbG8vRG93bmxvYWRzL1Rlc2xhLU1vZGVsLTMuanBnIDEzMzI1IFwiXHJcbiAgICBjb25zdCBtYXRjaCA9IGxpbmtVcmkubWF0Y2goLyhbXlxcL1xcXFxdKylcXC5bXi5dKyQvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KGVsZW1lbnRzKSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+aqyBDT09SRElOQVRFIE9GRlNFVCBESVNBQkxFRCBGT1IgREVCVUdHSU5HJyk7XHJcbiAgICBjb25zb2xlLmxvZygnICAgVGhpcyB3aWxsIHNob3cgZWxlbWVudHMgYXQgdGhlaXIgUkFXIElETUwgY29vcmRpbmF0ZXMnKTtcclxuICAgIGNvbnNvbGUubG9nKCcgICBJZiBlbGVtZW50cyBhcmUgcG9zaXRpb25lZCBjb3JyZWN0bHkgbm93LCB0aGUgaXNzdWUgd2FzIHdpdGggb2Zmc2V0IGNhbGN1bGF0aW9uJyk7XHJcbiAgICBjb25zb2xlLmxvZygnICAgSWYgZWxlbWVudHMgYXJlIHN0aWxsIHdyb25nLCB0aGUgaXNzdWUgaXMgZWxzZXdoZXJlJyk7XHJcbiAgICBcclxuICAgIC8vIFRFTVBPUkFSWTogUmV0dXJuIHplcm8gb2Zmc2V0IHRvIHNlZSByYXcgSURNTCBwb3NpdGlvbmluZ1xyXG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUJvdW5kc0Zyb21QYXRoKGl0ZW0pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgYm91bmRzIGZyb20gR2VvbWV0cmljQm91bmRzIGF0dHJpYnV0ZVxyXG4gICAgICBpZiAoaXRlbVsnQF9HZW9tZXRyaWNCb3VuZHMnXSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlR2VvbWV0cmljQm91bmRzKGl0ZW1bJ0BfR2VvbWV0cmljQm91bmRzJ10pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBUaGVuIHRyeSBwYXRoIGdlb21ldHJ5XHJcbiAgICAgIGNvbnN0IHBhdGhHZW9tZXRyeSA9IGl0ZW0/LlByb3BlcnRpZXM/LlBhdGhHZW9tZXRyeT8uR2VvbWV0cnlQYXRoVHlwZT8uUGF0aFBvaW50QXJyYXk/LlBhdGhQb2ludFR5cGU7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXBhdGhHZW9tZXRyeSB8fCAhQXJyYXkuaXNBcnJheShwYXRoR2VvbWV0cnkpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFdhcm5pbmc6IE5vIGdlb21ldHJ5IGZvdW5kIGZvciAke2l0ZW1bJ0BfU2VsZiddfSwgdXNpbmcgaXRlbSB0cmFuc2Zvcm1gKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBGYWxsYmFjayB0byBpdGVtIHRyYW5zZm9ybSBpZiBhdmFpbGFibGVcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLnBhcnNlVHJhbnNmb3JtKGl0ZW1bJ0BfSXRlbVRyYW5zZm9ybSddKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdG9wOiB0cmFuc2Zvcm0udHkgfHwgMCxcclxuICAgICAgICAgIGxlZnQ6IHRyYW5zZm9ybS50eCB8fCAwLFxyXG4gICAgICAgICAgYm90dG9tOiAodHJhbnNmb3JtLnR5IHx8IDApICsgMTAwLCAvLyBEZWZhdWx0IGhlaWdodFxyXG4gICAgICAgICAgcmlnaHQ6ICh0cmFuc2Zvcm0udHggfHwgMCkgKyAxMDAsICAvLyBEZWZhdWx0IHdpZHRoXHJcbiAgICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgICAgaGVpZ2h0OiAxMDBcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBsZXQgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XHJcbiAgICAgIFxyXG4gICAgICBwYXRoR2VvbWV0cnkuZm9yRWFjaChwb2ludCA9PiB7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yID0gcG9pbnRbJ0BfQW5jaG9yJ107XHJcbiAgICAgICAgaWYgKGFuY2hvcikge1xyXG4gICAgICAgICAgY29uc3QgW3gsIHldID0gYW5jaG9yLnNwbGl0KCcgJykubWFwKHBhcnNlRmxvYXQpO1xyXG4gICAgICAgICAgaWYgKCFpc05hTih4KSAmJiAhaXNOYU4oeSkpIHtcclxuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xyXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XHJcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcclxuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAobWluWCA9PT0gSW5maW5pdHkgfHwgbWluWSA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgV2FybmluZzogQ291bGQgbm90IGNhbGN1bGF0ZSBib3VuZHMgZm9yICR7aXRlbVsnQF9TZWxmJ119YCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IDEwMCwgcmlnaHQ6IDEwMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3A6IG1pblksXHJcbiAgICAgICAgbGVmdDogbWluWCxcclxuICAgICAgICBib3R0b206IG1heFksXHJcbiAgICAgICAgcmlnaHQ6IG1heFgsXHJcbiAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YLFxyXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjYWxjdWxhdGluZyBib3VuZHMgZm9yICR7aXRlbVsnQF9TZWxmJ119OmAsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IDEwMCwgcmlnaHQ6IDEwMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVSZWxhdGl2ZVBvc2l0aW9uKGZyYW1lQm91bmRzLCBjb250ZW50Qm91bmRzLCBmcmFtZVRyYW5zZm9ybSwgY29udGVudFRyYW5zZm9ybSkge1xyXG4gICAgaWYgKCFmcmFtZUJvdW5kcyB8fCAhY29udGVudEJvdW5kcykgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9mZnNldFg6IChjb250ZW50Qm91bmRzLmxlZnQgfHwgMCkgLSAoZnJhbWVCb3VuZHMubGVmdCB8fCAwKSxcclxuICAgICAgb2Zmc2V0WTogKGNvbnRlbnRCb3VuZHMudG9wIHx8IDApIC0gKGZyYW1lQm91bmRzLnRvcCB8fCAwKSxcclxuICAgICAgc2NhbGVYOiBjb250ZW50VHJhbnNmb3JtPy5hIHx8IDEsXHJcbiAgICAgIHNjYWxlWTogY29udGVudFRyYW5zZm9ybT8uZCB8fCAxLFxyXG4gICAgICB0cmFuc2Zvcm1EaWZmZXJlbmNlOiB7XHJcbiAgICAgICAgZnJhbWU6IGZyYW1lVHJhbnNmb3JtLFxyXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRUcmFuc2Zvcm1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVHYXAoZnJhbWVCb3VuZHMsIGNvbnRlbnRCb3VuZHMpIHtcclxuICAgIGlmICghZnJhbWVCb3VuZHMgfHwgIWNvbnRlbnRCb3VuZHMpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IChjb250ZW50Qm91bmRzLnRvcCB8fCAwKSAtIChmcmFtZUJvdW5kcy50b3AgfHwgMCksXHJcbiAgICAgIGxlZnQ6IChjb250ZW50Qm91bmRzLmxlZnQgfHwgMCkgLSAoZnJhbWVCb3VuZHMubGVmdCB8fCAwKSxcclxuICAgICAgYm90dG9tOiAoZnJhbWVCb3VuZHMuYm90dG9tIHx8IDApIC0gKGNvbnRlbnRCb3VuZHMuYm90dG9tIHx8IDApLFxyXG4gICAgICByaWdodDogKGZyYW1lQm91bmRzLnJpZ2h0IHx8IDApIC0gKGNvbnRlbnRCb3VuZHMucmlnaHQgfHwgMClcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlSW1hZ2VQb3NpdGlvbkluRnJhbWUoZnJhbWVCb3VuZHMsIGZyYW1lVHJhbnNmb3JtLCBwbGFjZWRDb250ZW50KSB7XHJcbiAgICBpZiAoIWZyYW1lQm91bmRzIHx8ICFwbGFjZWRDb250ZW50Py50cmFuc2Zvcm0pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGltYWdlVHJhbnNmb3JtID0gcGxhY2VkQ29udGVudC50cmFuc2Zvcm07XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBpbWFnZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBmcmFtZVxyXG4gICAgY29uc3QgaW1hZ2VYID0gKGZyYW1lQm91bmRzLmxlZnQgfHwgMCkgKyAoaW1hZ2VUcmFuc2Zvcm0udHggfHwgMCk7XHJcbiAgICBjb25zdCBpbWFnZVkgPSAoZnJhbWVCb3VuZHMudG9wIHx8IDApICsgKGltYWdlVHJhbnNmb3JtLnR5IHx8IDApO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgaW1hZ2Ugc2l6ZSB3aXRoIHNjYWxpbmdcclxuICAgIGNvbnN0IGltYWdlV2lkdGggPSAoZnJhbWVCb3VuZHMud2lkdGggfHwgMCkgKiAoaW1hZ2VUcmFuc2Zvcm0uYSB8fCAxKTtcclxuICAgIGNvbnN0IGltYWdlSGVpZ2h0ID0gKGZyYW1lQm91bmRzLmhlaWdodCB8fCAwKSAqIChpbWFnZVRyYW5zZm9ybS5kIHx8IDEpO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiBpbWFnZVgsXHJcbiAgICAgIHk6IGltYWdlWSxcclxuICAgICAgd2lkdGg6IGltYWdlV2lkdGgsXHJcbiAgICAgIGhlaWdodDogaW1hZ2VIZWlnaHQsXHJcbiAgICAgIHNjYWxlWDogaW1hZ2VUcmFuc2Zvcm0uYSB8fCAxLFxyXG4gICAgICBzY2FsZVk6IGltYWdlVHJhbnNmb3JtLmQgfHwgMVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRYTUxTdHJ1Y3R1cmUob2JqLCBtYXhEZXB0aCA9IDMsIGN1cnJlbnREZXB0aCA9IDApIHtcclxuICAgIGlmIChjdXJyZW50RGVwdGggPj0gbWF4RGVwdGggfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBzdHJ1Y3R1cmUgPSB7fTtcclxuICAgIFxyXG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xyXG4gICAgICAgIHN0cnVjdHVyZVtrZXldID0gYEFycmF5WyR7b2JqW2tleV0ubGVuZ3RofV1gO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcgJiYgb2JqW2tleV0gIT09IG51bGwpIHtcclxuICAgICAgICBzdHJ1Y3R1cmVba2V5XSA9IHRoaXMuZ2V0WE1MU3RydWN0dXJlKG9ialtrZXldLCBtYXhEZXB0aCwgY3VycmVudERlcHRoICsgMSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RydWN0dXJlW2tleV0gPSB0eXBlb2Ygb2JqW2tleV07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gc3RydWN0dXJlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGlzRm9ybWF0dGluZ0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB7XHJcbiAgICBjb25zdCBmb3JtYXR0aW5nQXR0cmlidXRlcyA9IFtcclxuICAgICAgJ0BfUG9pbnRTaXplJywgJ0BfTGVhZGluZycsICdAX1RyYWNraW5nJywgJ0BfRm9udFN0eWxlJyxcclxuICAgICAgJ0BfQXBwbGllZEZvbnQnLCAnQF9GaWxsQ29sb3InLCAnQF9TdHJva2VDb2xvcicsICdAX0p1c3RpZmljYXRpb24nLFxyXG4gICAgICAnQF9MZWZ0SW5kZW50JywgJ0BfUmlnaHRJbmRlbnQnLCAnQF9GaXJzdExpbmVJbmRlbnQnLFxyXG4gICAgICAnQF9TcGFjZUJlZm9yZScsICdAX1NwYWNlQWZ0ZXInLCAnQF9BbGlnbm1lbnQnXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmdBdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHNhdmVEZWJ1Z0luZm8oZGVidWdJbmZvLCBmaWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlTmFtZSwgSlNPTi5zdHJpbmdpZnkoZGVidWdJbmZvLCBudWxsLCAyKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgRGVidWcgaW5mbyBzYXZlZCB0byAke2ZpbGVOYW1lfWApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHNhdmluZyBkZWJ1ZyBpbmZvOicsIGVycm9yKTtcclxuICAgICAgY29uc29sZS5sb2coJ0RlYnVnIGluZm8gKGZpcnN0IDIwMDAgY2hhcnMpOicsIEpTT04uc3RyaW5naWZ5KGRlYnVnSW5mbywgbnVsbCwgMikuc3Vic3RyaW5nKDAsIDIwMDApKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSURNTFV0aWxzOyBcclxuIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiZnMiLCJJRE1MVXRpbHMiLCJwYXJzZUdlb21ldHJpY0JvdW5kcyIsImJvdW5kc1N0cmluZyIsImNvbnNvbGUiLCJsb2ciLCJ0b3AiLCJsZWZ0IiwiYm90dG9tIiwicmlnaHQiLCJ3aWR0aCIsImhlaWdodCIsImJvdW5kcyIsInNwbGl0IiwibWFwIiwicGFyc2VGbG9hdCIsInJlc3VsdCIsInBhcnNlVHJhbnNmb3JtIiwidHJhbnNmb3JtU3RyaW5nIiwiYSIsImIiLCJjIiwiZCIsInR4IiwidHkiLCJ2YWx1ZXMiLCJjYWxjdWxhdGVSb3RhdGlvbiIsInRyYW5zZm9ybSIsIk1hdGgiLCJhdGFuMiIsIlBJIiwiY2FsY3VsYXRlQ29ybmVycyIsImNvcm5lcnMiLCJ0b3BMZWZ0IiwieCIsInkiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiY29ybmVyIiwicG9pbnQiLCJjbXlrVG9SZ2IiLCJtIiwiayIsInIiLCJyb3VuZCIsImciLCJwYXJzZUluRGVzaWduQ29sb3IiLCJjb2xvclJlZiIsImNteWtNYXRjaCIsIm1hdGNoIiwiTnVtYmVyIiwicmdiIiwicmdiTWF0Y2giLCJzdGFuZGFyZENvbG9ycyIsImRlY29kZVhNTEVudGl0aWVzIiwidGV4dCIsInJlcGxhY2UiLCJjbGVhblRleHRDb250ZW50IiwiY29udGVudCIsInRyaW0iLCJwcmVzZXJ2ZUxpbmVCcmVha3MiLCJjbGVhblRleHRGb3JSZW5kZXJpbmciLCJzb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyIsImhhc1Byb2JsZW1hdGljVGV4dCIsImluY2x1ZGVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInByb2Nlc3NlZCIsImNvdW50V29yZHMiLCJmaWx0ZXIiLCJ3b3JkIiwibGVuZ3RoIiwicGFyc2VOdW1lcmljIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJudW0iLCJpc05hTiIsImlzSW1hZ2VGaWxlIiwiZmlsZU5hbWUiLCJpbWFnZUV4dGVuc2lvbnMiLCJzb21lIiwiZXh0IiwidG9Mb3dlckNhc2UiLCJlbmRzV2l0aCIsImdldEltYWdlRXh0ZW5zaW9uIiwiaW1hZ2VUeXBlTmFtZSIsInR5cGVNYXAiLCJnZXRJbWFnZUV4dGVuc2lvbkZyb21Gb3JtYXQiLCJmb3JtYXQiLCJmb3JtYXRNYXAiLCJleHRyYWN0SW1hZ2VOYW1lRnJvbUxpbmsiLCJsaW5rVXJpIiwiY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldCIsImVsZW1lbnRzIiwiY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgiLCJpdGVtIiwicGF0aEdlb21ldHJ5IiwiUHJvcGVydGllcyIsIlBhdGhHZW9tZXRyeSIsIkdlb21ldHJ5UGF0aFR5cGUiLCJQYXRoUG9pbnRBcnJheSIsIlBhdGhQb2ludFR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJtaW5YIiwiSW5maW5pdHkiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJhbmNob3IiLCJtaW4iLCJtYXgiLCJlcnJvciIsImNhbGN1bGF0ZVJlbGF0aXZlUG9zaXRpb24iLCJmcmFtZUJvdW5kcyIsImNvbnRlbnRCb3VuZHMiLCJmcmFtZVRyYW5zZm9ybSIsImNvbnRlbnRUcmFuc2Zvcm0iLCJvZmZzZXRYIiwib2Zmc2V0WSIsInNjYWxlWCIsInNjYWxlWSIsInRyYW5zZm9ybURpZmZlcmVuY2UiLCJmcmFtZSIsImNhbGN1bGF0ZUdhcCIsImNhbGN1bGF0ZUltYWdlUG9zaXRpb25JbkZyYW1lIiwicGxhY2VkQ29udGVudCIsImltYWdlVHJhbnNmb3JtIiwiaW1hZ2VYIiwiaW1hZ2VZIiwiaW1hZ2VXaWR0aCIsImltYWdlSGVpZ2h0IiwiZ2V0WE1MU3RydWN0dXJlIiwib2JqIiwibWF4RGVwdGgiLCJjdXJyZW50RGVwdGgiLCJzdHJ1Y3R1cmUiLCJrZXkiLCJpc0Zvcm1hdHRpbmdBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVOYW1lIiwiZm9ybWF0dGluZ0F0dHJpYnV0ZXMiLCJzYXZlRGVidWdJbmZvIiwiZGVidWdJbmZvIiwid3JpdGVGaWxlU3luYyIsInN1YnN0cmluZyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/utils/IDMLUtils.js\n"));

/***/ })

});