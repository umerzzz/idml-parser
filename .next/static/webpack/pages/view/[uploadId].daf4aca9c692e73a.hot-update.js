"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StyleParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StyleParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StyleParser {\n    // ADDED: Method to set document units for typography conversion\n    setDocumentUnits(units) {\n        this.documentUnits = units;\n        console.log(\"\\uD83D\\uDCD0 StyleParser: Set document units to\", units);\n    }\n    // ADDED: Method to convert typography measurements to pixels\n    convertTypographyToPixels(value) {\n        if (typeof value !== \"number\" || isNaN(value) || !this.unitConverter || !this.documentUnits) {\n            return value;\n        }\n        // Only convert if we have a supported unit and it's not already pixels\n        if (this.unitConverter.isSupportedUnit(this.documentUnits)) {\n            const convertedValue = this.unitConverter.toPixels(value, this.documentUnits);\n            console.log(\"\\uD83D\\uDCD0 Converted typography: \".concat(value, \" \").concat(this.documentUnits, \" → \").concat(convertedValue, \" px\"));\n            return convertedValue;\n        }\n        return value;\n    }\n    // ADDED: Method to convert an entire style object's measurements to pixels\n    convertStyleMeasurementsToPixels(style) {\n        if (!this.unitConverter || !this.documentUnits) {\n            return style;\n        }\n        const convertedStyle = {\n            ...style\n        };\n        // Convert measurements that need pixel conversion\n        const measurementFields = [\n            \"leftIndent\",\n            \"rightIndent\",\n            \"firstLineIndent\",\n            \"spaceBefore\",\n            \"spaceAfter\",\n            \"tracking\",\n            \"kerning\"\n        ];\n        measurementFields.forEach((field)=>{\n            if (typeof convertedStyle[field] === \"number\") {\n                convertedStyle[field] = this.convertTypographyToPixels(convertedStyle[field]);\n            }\n        });\n        // Convert leading if it's a numeric value\n        if (typeof convertedStyle.leading === \"number\") {\n            convertedStyle.leading = this.convertTypographyToPixels(convertedStyle.leading);\n        }\n        return convertedStyle;\n    }\n    async parseResourceFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCCB Parsing resource: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const resourceName = path.basename(fileName, \".xml\");\n            // Handle different resource types\n            if (fileName.includes(\"Styles.xml\")) {\n                await this.extractStyles(parsed);\n            } else if (fileName.includes(\"Fonts.xml\")) {\n                await this.extractFonts(parsed);\n            } else if (fileName.includes(\"Graphic.xml\")) {\n                await this.extractGraphics(parsed);\n            } else if (fileName.includes(\"Preferences.xml\")) {\n                await this.extractPreferences(parsed);\n            }\n            console.log(\"✅ Resource \".concat(resourceName, \" parsed\"));\n        } catch (error) {\n            console.error(\"❌ Error parsing \".concat(fileName, \":\"), error.message);\n        }\n    }\n    async extractStyles(stylesData) {\n        console.log(\"Extracting styles...\");\n        const styles = stylesData.Styles || stylesData;\n        // Extract Paragraph Styles\n        if (styles.RootParagraphStyleGroup) {\n            this.extractParagraphStyles(styles.RootParagraphStyleGroup);\n        }\n        // Extract Character Styles\n        if (styles.RootCharacterStyleGroup) {\n            this.extractCharacterStyles(styles.RootCharacterStyleGroup);\n        }\n    }\n    extractParagraphStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.ParagraphStyle) {\n                const styles = Array.isArray(group.ParagraphStyle) ? group.ParagraphStyle : [\n                    group.ParagraphStyle\n                ];\n                styles.forEach((style)=>{\n                    // CRITICAL: Extract font reference from multiple possible locations\n                    const fontRef = this.extractFontFromStyle(style);\n                    // ENHANCED: Process leading with proper InDesign logic\n                    const fontSize = parseFloat(style[\"@_PointSize\"]) || 12;\n                    const rawLeading = style[\"@_Leading\"];\n                    const processedLeading = this.processLeadingValue(rawLeading, fontSize);\n                    // FIXED: Extract raw typography measurements for conversion\n                    const rawLeftIndent = parseFloat(style[\"@_LeftIndent\"]) || 0;\n                    const rawRightIndent = parseFloat(style[\"@_RightIndent\"]) || 0;\n                    const rawFirstLineIndent = parseFloat(style[\"@_FirstLineIndent\"]) || 0;\n                    const rawSpaceBefore = parseFloat(style[\"@_SpaceBefore\"]) || 0;\n                    const rawSpaceAfter = parseFloat(style[\"@_SpaceAfter\"]) || 0;\n                    const rawTracking = parseFloat(style[\"@_Tracking\"]) || 0;\n                    const rawKerning = parseFloat(style[\"@_Kerning\"]) || 0;\n                    // FIXED: Create base style object with raw values\n                    const baseStyle = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: fontSize,\n                        leading: processedLeading,\n                        leadingType: this.determineLeadingType(rawLeading),\n                        effectiveLineHeight: this.calculateEffectiveLineHeight(processedLeading, fontSize),\n                        alignment: style[\"@_Justification\"] || \"LeftAlign\",\n                        // Raw measurements (will be converted to pixels)\n                        leftIndent: rawLeftIndent,\n                        rightIndent: rawRightIndent,\n                        firstLineIndent: rawFirstLineIndent,\n                        spaceBefore: rawSpaceBefore,\n                        spaceAfter: rawSpaceAfter,\n                        tracking: rawTracking,\n                        kerning: rawKerning,\n                        // Store original values for reference\n                        originalLeftIndent: rawLeftIndent,\n                        originalRightIndent: rawRightIndent,\n                        originalFirstLineIndent: rawFirstLineIndent,\n                        originalSpaceBefore: rawSpaceBefore,\n                        originalSpaceAfter: rawSpaceAfter,\n                        originalTracking: rawTracking,\n                        originalKerning: rawKerning,\n                        horizontalScale: parseFloat(style[\"@_HorizontalScale\"]) || 100,\n                        verticalScale: parseFloat(style[\"@_VerticalScale\"]) || 100,\n                        // ENHANCED: Use the new extraction method\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || \"Color/Black\",\n                        rawStyle: style\n                    };\n                    // FIXED: Apply unit conversion to create pixel-converted style\n                    this.styles.paragraph[style[\"@_Self\"]] = this.convertStyleMeasurementsToPixels(baseStyle);\n                    console.log(\"✅ Paragraph Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.ParagraphStyleGroup) {\n                const subGroups = Array.isArray(group.ParagraphStyleGroup) ? group.ParagraphStyleGroup : [\n                    group.ParagraphStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    extractFontFromStyle(style) {\n        // Try direct attributes first\n        let fontRef = style[\"@_AppliedFont\"] || style[\"@_FontFamily\"] || style[\"@_Font\"] || \"\";\n        // If not found, try Properties nested structure\n        if (!fontRef && style.Properties) {\n            if (style.Properties.AppliedFont) {\n                fontRef = style.Properties.AppliedFont[\"#text\"] || style.Properties.AppliedFont || \"\";\n            }\n            // Also try other property variations\n            if (!fontRef && style.Properties.FontFamily) {\n                fontRef = style.Properties.FontFamily[\"#text\"] || style.Properties.FontFamily || \"\";\n            }\n        }\n        return fontRef || \"\";\n    }\n    extractCharacterStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.CharacterStyle) {\n                const styles = Array.isArray(group.CharacterStyle) ? group.CharacterStyle : [\n                    group.CharacterStyle\n                ];\n                styles.forEach((style)=>{\n                    const fontRef = this.extractFontFromStyle(style);\n                    this.styles.character[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: parseFloat(style[\"@_PointSize\"]) || null,\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || null,\n                        strokeColor: style[\"@_StrokeColor\"] || null,\n                        rawStyle: style\n                    };\n                    console.log(\"✅ Character Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.CharacterStyleGroup) {\n                const subGroups = Array.isArray(group.CharacterStyleGroup) ? group.CharacterStyleGroup : [\n                    group.CharacterStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    async extractFonts(fontsData) {\n        console.log(\"Extracting fonts with enhanced mapping...\");\n        const fonts = fontsData.Fonts || fontsData;\n        this.resources.fonts = {};\n        this.fontMap = new Map(); // Global font lookup map\n        if (fonts.FontFamily) {\n            const fontFamilies = Array.isArray(fonts.FontFamily) ? fonts.FontFamily : [\n                fonts.FontFamily\n            ];\n            fontFamilies.forEach((family)=>{\n                const familyInfo = {\n                    self: family[\"@_Self\"],\n                    name: family[\"@_Name\"] || \"\",\n                    fonts: []\n                };\n                if (family.Font) {\n                    const fontList = Array.isArray(family.Font) ? family.Font : [\n                        family.Font\n                    ];\n                    fontList.forEach((font)=>{\n                        const fontInfo = {\n                            self: font[\"@_Self\"],\n                            fontFamily: font[\"@_FontFamily\"] || familyInfo.name,\n                            name: font[\"@_Name\"] || \"\",\n                            postScriptName: font[\"@_PostScriptName\"] || \"\",\n                            status: font[\"@_Status\"] || \"Unknown\",\n                            fontStyleName: font[\"@_FontStyleName\"] || \"Regular\"\n                        };\n                        familyInfo.fonts.push(fontInfo);\n                        // Create multiple lookup entries for this font\n                        this.fontMap.set(font[\"@_Self\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_PostScriptName\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_Name\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_FontFamily\"], familyInfo.name);\n                        console.log(\"Font mapping: \".concat(font[\"@_Self\"], \" -> \").concat(familyInfo.name));\n                    });\n                }\n                this.resources.fonts[family[\"@_Self\"]] = familyInfo;\n            });\n        }\n        console.log(\"✅ Fonts extracted: \".concat(Object.keys(this.resources.fonts).length, \" families\"));\n        console.log(\"Font map entries: \".concat(this.fontMap.size));\n    }\n    async extractGraphics(graphicsData) {\n        console.log(\"Extracting graphics and colors...\");\n        const graphics = graphicsData.Graphic || graphicsData;\n        this.resources.colors = {};\n        this.resources.gradients = {};\n        // Extract Colors\n        if (graphics.Color) {\n            const colors = Array.isArray(graphics.Color) ? graphics.Color : [\n                graphics.Color\n            ];\n            colors.forEach((color)=>{\n                // Extract channel values\n                const cyan = parseFloat(color[\"@_Cyan\"]) || 0;\n                const magenta = parseFloat(color[\"@_Magenta\"]) || 0;\n                const yellow = parseFloat(color[\"@_Yellow\"]) || 0;\n                const black = parseFloat(color[\"@_Black\"]) || 0;\n                const red = parseFloat(color[\"@_Red\"]) || 0;\n                const green = parseFloat(color[\"@_Green\"]) || 0;\n                const blue = parseFloat(color[\"@_Blue\"]) || 0;\n                // Fallback: If no CMYK or RGB, but ColorValue exists, parse as RGB\n                let fallbackRGB = null;\n                if (cyan === 0 && magenta === 0 && yellow === 0 && black === 0 && red === 0 && green === 0 && blue === 0 && color[\"@_ColorValue\"]) {\n                    // ColorValue is usually a space-separated RGB triplet, e.g. \"255 140 0\"\n                    const rgbParts = color[\"@_ColorValue\"].split(/\\s+/).map(Number);\n                    if (rgbParts.length === 3 && rgbParts.every((v)=>!isNaN(v))) {\n                        fallbackRGB = {\n                            red: rgbParts[0],\n                            green: rgbParts[1],\n                            blue: rgbParts[2]\n                        };\n                    }\n                }\n                this.resources.colors[color[\"@_Self\"]] = {\n                    self: color[\"@_Self\"],\n                    name: color[\"@_Name\"] || \"\",\n                    model: color[\"@_Model\"] || \"Process\",\n                    space: color[\"@_Space\"] || \"CMYK\",\n                    cyan,\n                    magenta,\n                    yellow,\n                    black,\n                    red: fallbackRGB ? fallbackRGB.red : red,\n                    green: fallbackRGB ? fallbackRGB.green : green,\n                    blue: fallbackRGB ? fallbackRGB.blue : blue\n                };\n            });\n        }\n        // Extract Gradients\n        if (graphics.Gradient) {\n            const gradients = Array.isArray(graphics.Gradient) ? graphics.Gradient : [\n                graphics.Gradient\n            ];\n            gradients.forEach((gradient)=>{\n                this.resources.gradients[gradient[\"@_Self\"]] = {\n                    self: gradient[\"@_Self\"],\n                    name: gradient[\"@_Name\"] || \"\",\n                    type: gradient[\"@_Type\"] || \"Linear\",\n                    gradientStops: this.extractGradientStops(gradient)\n                };\n            });\n        }\n    }\n    extractGradientStops(gradient) {\n        const stops = [];\n        if (gradient.GradientStop) {\n            const stopList = Array.isArray(gradient.GradientStop) ? gradient.GradientStop : [\n                gradient.GradientStop\n            ];\n            stopList.forEach((stop)=>{\n                stops.push({\n                    self: stop[\"@_Self\"],\n                    stopColor: stop[\"@_StopColor\"] || \"\",\n                    location: parseFloat(stop[\"@_Location\"]) || 0,\n                    midpoint: parseFloat(stop[\"@_Midpoint\"]) || 50\n                });\n            });\n        }\n        return stops;\n    }\n    async extractPreferences(preferencesData) {\n        console.log(\"Extracting document preferences...\");\n        const prefs = preferencesData.Preferences || preferencesData;\n        // Extract various document preferences\n        this.documentInfo = {\n            preferences: {\n                documentPreferences: this.extractDocumentPrefs(prefs.DocumentPreference),\n                viewPreferences: this.extractViewPrefs(prefs.ViewPreference),\n                guidePreferences: this.extractGuidePrefs(prefs.GuidePreference),\n                gridPreferences: this.extractGridPrefs(prefs.GridPreference),\n                marginPreferences: this.extractMarginPrefs(prefs.MarginPreference),\n                columnPreferences: this.extractColumnPrefs(prefs.ColumnPreference)\n            }\n        };\n    }\n    extractDocumentPrefs(docPref) {\n        if (!docPref) return {};\n        return {\n            pageWidth: parseFloat(docPref[\"@_PageWidth\"]) || 0,\n            pageHeight: parseFloat(docPref[\"@_PageHeight\"]) || 0,\n            left: parseFloat(docPref[\"@_Left\"]) || 0,\n            top: parseFloat(docPref[\"@_Top\"]) || 0,\n            right: parseFloat(docPref[\"@_Right\"]) || 0,\n            bottom: parseFloat(docPref[\"@_Bottom\"]) || 0,\n            columnCount: parseInt(docPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(docPref[\"@_ColumnGutter\"]) || 0,\n            facingPages: docPref[\"@_FacingPages\"] === true,\n            allowPageShuffle: docPref[\"@_AllowPageShuffle\"] !== false,\n            slugBleedType: docPref[\"@_SlugBleedType\"] || \"None\",\n            documentBleedTopOffset: parseFloat(docPref[\"@_DocumentBleedTopOffset\"]) || 0,\n            documentBleedBottomOffset: parseFloat(docPref[\"@_DocumentBleedBottomOffset\"]) || 0,\n            documentBleedInsideOrLeftOffset: parseFloat(docPref[\"@_DocumentBleedInsideOrLeftOffset\"]) || 0,\n            documentBleedOutsideOrRightOffset: parseFloat(docPref[\"@_DocumentBleedOutsideOrRightOffset\"]) || 0\n        };\n    }\n    extractViewPrefs(viewPref) {\n        if (!viewPref) return {};\n        return {\n            horizontalMeasurementUnits: viewPref[\"@_HorizontalMeasurementUnits\"] || \"Points\",\n            verticalMeasurementUnits: viewPref[\"@_VerticalMeasurementUnits\"] || \"Points\",\n            rulerOrigin: viewPref[\"@_RulerOrigin\"] || \"SpreadOrigin\",\n            showRulers: viewPref[\"@_ShowRulers\"] !== false\n        };\n    }\n    extractGuidePrefs(guidePref) {\n        if (!guidePref) return {};\n        return {\n            rulerGuideColor: guidePref[\"@_RulerGuideColor\"] || \"Green\",\n            guidesInBack: guidePref[\"@_GuidesInBack\"] === true,\n            guidesLocked: guidePref[\"@_GuidesLocked\"] === true,\n            guidesShown: guidePref[\"@_GuidesShown\"] !== false,\n            guidesSnapto: guidePref[\"@_GuidesSnapto\"] !== false\n        };\n    }\n    extractGridPrefs(gridPref) {\n        if (!gridPref) return {};\n        return {\n            baselineStart: parseFloat(gridPref[\"@_BaselineStart\"]) || 0,\n            baselineDivision: parseFloat(gridPref[\"@_BaselineDivision\"]) || 12,\n            baselineShown: gridPref[\"@_BaselineShown\"] === true,\n            baselineSnapto: gridPref[\"@_BaselineSnapto\"] === true,\n            documentGridShown: gridPref[\"@_DocumentGridShown\"] === true,\n            documentGridSnapto: gridPref[\"@_DocumentGridSnapto\"] === true\n        };\n    }\n    extractMarginPrefs(marginPref) {\n        if (!marginPref) return {};\n        return {\n            top: parseFloat(marginPref[\"@_Top\"]) || 0,\n            bottom: parseFloat(marginPref[\"@_Bottom\"]) || 0,\n            left: parseFloat(marginPref[\"@_Left\"]) || 0,\n            right: parseFloat(marginPref[\"@_Right\"]) || 0,\n            columnCount: parseInt(marginPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(marginPref[\"@_ColumnGutter\"]) || 0\n        };\n    }\n    extractColumnPrefs(columnPref) {\n        if (!columnPref) return {};\n        return {\n            textColumnCount: parseInt(columnPref[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(columnPref[\"@_TextColumnGutter\"]) || 0\n        };\n    }\n    resolveStyleFormatting(formatting) {\n        const resolved = {\n            ...formatting\n        };\n        // DEBUG: Check if formatting is being applied (generic check)\n        const hasAnyFormatting = formatting.paragraphStyle || formatting.characterStyle || formatting.fontStyle || formatting.fontReference || formatting.fontSize;\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Input:\", {\n                paragraphStyle: formatting.paragraphStyle,\n                characterStyle: formatting.characterStyle,\n                directFontStyle: formatting.fontStyle,\n                directFontRef: formatting.fontReference,\n                directFontSize: formatting.fontSize\n            });\n        }\n        // Resolve paragraph style (base layer)\n        if (formatting.paragraphStyle && this.styles.paragraph[formatting.paragraphStyle]) {\n            const pStyle = this.styles.paragraph[formatting.paragraphStyle];\n            if (!resolved.fontSize && pStyle.pointSize) resolved.fontSize = pStyle.pointSize;\n            if (!resolved.fillColor && pStyle.fillColor) resolved.fillColor = pStyle.fillColor;\n            // CRITICAL FIX: Always inherit paragraph alignment unless explicitly overridden\n            if (pStyle.alignment) resolved.alignment = pStyle.alignment;\n            if (!resolved.fontStyle && pStyle.fontStyle) {\n                resolved.fontStyle = pStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from paragraph style: \"'.concat(pStyle.fontStyle, '\"'));\n                }\n            }\n            // CRITICAL: Resolve font from paragraph style\n            if (!resolved.fontFamily && pStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(pStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from paragraph style: \".concat(pStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n            // Add other paragraph properties with enhanced leading support\n            resolved.leading = pStyle.leading;\n            resolved.leadingType = pStyle.leadingType;\n            resolved.effectiveLineHeight = pStyle.effectiveLineHeight;\n            resolved.leftIndent = pStyle.leftIndent;\n            resolved.rightIndent = pStyle.rightIndent;\n            resolved.firstLineIndent = pStyle.firstLineIndent;\n            resolved.spaceBefore = pStyle.spaceBefore;\n            resolved.spaceAfter = pStyle.spaceAfter;\n            resolved.tracking = pStyle.tracking;\n            resolved.kerning = pStyle.kerning;\n        }\n        // Resolve character style (override layer)\n        if (formatting.characterStyle && this.styles.character[formatting.characterStyle]) {\n            const cStyle = this.styles.character[formatting.characterStyle];\n            if (cStyle.pointSize) resolved.fontSize = cStyle.pointSize;\n            if (cStyle.fillColor) resolved.fillColor = cStyle.fillColor;\n            if (cStyle.fontStyle) {\n                resolved.fontStyle = cStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from character style: \"'.concat(cStyle.fontStyle, '\"'));\n                }\n            }\n            if (cStyle.strokeColor) resolved.strokeColor = cStyle.strokeColor;\n            // Include leading information from character style\n            if (cStyle.leading) resolved.leading = cStyle.leading;\n            if (cStyle.leadingType) resolved.leadingType = cStyle.leadingType;\n            if (cStyle.effectiveLineHeight) resolved.effectiveLineHeight = cStyle.effectiveLineHeight;\n            // CRITICAL: Character style font overrides paragraph style\n            if (cStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(cStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from character style: \".concat(cStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n        }\n        // Apply direct formatting (highest priority)\n        if (formatting.fontReference) {\n            resolved.fontFamily = this.resolveFontReference(formatting.fontReference);\n            if (hasAnyFormatting) {\n                console.log(\"   Font from direct formatting: \".concat(formatting.fontReference, \" -> \").concat(resolved.fontFamily));\n            }\n        }\n        // CRITICAL: Apply direct fontStyle if provided (this might be the issue)\n        if (formatting.fontStyle) {\n            resolved.fontStyle = formatting.fontStyle;\n            if (hasAnyFormatting) {\n                console.log('   FontStyle from direct formatting: \"'.concat(formatting.fontStyle, '\"'));\n            }\n        }\n        // Apply direct leading information (highest priority)\n        if (formatting.leading !== undefined) resolved.leading = formatting.leading;\n        if (formatting.leadingType) resolved.leadingType = formatting.leadingType;\n        if (formatting.effectiveLineHeight) resolved.effectiveLineHeight = formatting.effectiveLineHeight;\n        // Apply other direct formatting attributes\n        if (formatting.fontSize) resolved.fontSize = formatting.fontSize;\n        if (formatting.tracking) resolved.tracking = formatting.tracking;\n        if (formatting.kerning) resolved.kerning = formatting.kerning;\n        // CRITICAL FIX: Apply direct alignment if explicitly specified (overrides paragraph alignment)\n        if (formatting.alignment) {\n            resolved.alignment = formatting.alignment;\n            if (hasAnyFormatting) {\n                console.log('   Alignment from direct formatting: \"'.concat(formatting.alignment, '\"'));\n            }\n        }\n        // FIXED: Ensure fontStyle defaults to Regular/normal if not set\n        if (!resolved.fontStyle || resolved.fontStyle === \"\") {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log('   FontStyle defaulted to: \"Regular\"');\n            }\n        }\n        // ADDITIONAL FIX: If no styles were applied from any source, ensure clean defaults\n        if (!formatting.paragraphStyle && !formatting.characterStyle && !formatting.fontStyle && !formatting.fontReference) {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log(\"   No source styles found - ensuring clean defaults\");\n            }\n        }\n        // Final fallback\n        if (!resolved.fontFamily || resolved.fontFamily === \"\") {\n            resolved.fontFamily = this.getDefaultFont();\n            if (hasAnyFormatting) {\n                console.log(\"   Using fallback font: \".concat(resolved.fontFamily));\n            }\n        }\n        // Ensure line height is calculated if not explicitly set\n        if (!resolved.effectiveLineHeight && resolved.fontSize && resolved.leading) {\n            resolved.effectiveLineHeight = this.calculateEffectiveLineHeight(resolved.leading, resolved.fontSize);\n        }\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Final Output:\", {\n                fontSize: resolved.fontSize,\n                fontFamily: resolved.fontFamily,\n                fontStyle: resolved.fontStyle,\n                fillColor: resolved.fillColor,\n                leading: resolved.leading,\n                effectiveLineHeight: resolved.effectiveLineHeight\n            });\n        }\n        return resolved;\n    }\n    resolveFontReference(fontRef) {\n        if (!fontRef || fontRef === \"\") {\n            console.log(\"Empty font reference, using fallback\");\n            return this.getDefaultFont();\n        }\n        // Try direct lookup in font map\n        if (this.fontMap && this.fontMap.has(fontRef)) {\n            const resolvedFont = this.fontMap.get(fontRef);\n            console.log('Font resolved: \"'.concat(fontRef, '\" -> \"').concat(resolvedFont, '\"'));\n            return resolvedFont;\n        }\n        // Try partial matching for font families\n        if (this.resources.fonts) {\n            for (const [familyId, familyInfo] of Object.entries(this.resources.fonts)){\n                // Check family name match\n                if (familyInfo.name && (familyInfo.name.toLowerCase().includes(fontRef.toLowerCase()) || fontRef.toLowerCase().includes(familyInfo.name.toLowerCase()))) {\n                    console.log('Font partially matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                    return familyInfo.name;\n                }\n                // Check individual font matches\n                if (familyInfo.fonts) {\n                    for (const font of familyInfo.fonts){\n                        if (font.self === fontRef || font.postScriptName === fontRef || font.name === fontRef) {\n                            console.log('Font exactly matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                            return familyInfo.name;\n                        }\n                    }\n                }\n            }\n        }\n        console.log('Font not found: \"'.concat(fontRef, '\", using fallback'));\n        return this.getDefaultFont() || fontRef;\n    }\n    getDefaultFont() {\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFamily = Object.values(this.resources.fonts)[0];\n            return firstFamily.name || \"Arial\";\n        }\n        return \"Arial\";\n    }\n    inferFontFromContext() {\n        // If we have font definitions but no explicit references,\n        // return the first available font as a fallback\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFontFamily = Object.values(this.resources.fonts)[0];\n            return firstFontFamily.name;\n        }\n        return null;\n    }\n    getStoryStyleSummary(story) {\n        var _story_content_formattedContent, _story_content;\n        const summary = {\n            fontSize: null,\n            fontFamily: null,\n            alignment: null,\n            fillColor: null,\n            fontStyle: null,\n            leading: null,\n            leadingType: null,\n            effectiveLineHeight: null,\n            tracking: null,\n            kerning: null\n        };\n        // Get the most common or first formatting values\n        if (((_story_content = story.content) === null || _story_content === void 0 ? void 0 : (_story_content_formattedContent = _story_content.formattedContent) === null || _story_content_formattedContent === void 0 ? void 0 : _story_content_formattedContent.length) > 0) {\n            const firstFormatted = story.content.formattedContent.find((item)=>item.formatting && !item.formatting.isBreak);\n            if (firstFormatted === null || firstFormatted === void 0 ? void 0 : firstFormatted.formatting) {\n                const fmt = firstFormatted.formatting;\n                summary.fontSize = fmt.fontSize;\n                summary.fontFamily = fmt.fontFamily;\n                summary.alignment = fmt.alignment;\n                summary.fillColor = fmt.fillColor;\n                summary.fontStyle = fmt.fontStyle;\n                summary.leading = fmt.leading;\n                summary.leadingType = fmt.leadingType;\n                summary.effectiveLineHeight = fmt.effectiveLineHeight;\n                summary.tracking = fmt.tracking;\n                summary.kerning = fmt.kerning;\n            }\n        }\n        return summary;\n    }\n    // NEW: Process leading values with InDesign-specific logic (shared with StoryParser)\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = parseFloat(rawLeading);\n        if (!isNaN(numericLeading)) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (!isNaN(parseFloat(rawLeading))) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(leading, fontSize) {\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\" && fontSize) {\n            // Convert points to CSS line-height ratio\n            return Math.max(0.8, leading / fontSize); // Ensure minimum line height\n        }\n        return 1.2; // Fallback\n    }\n    getStyles() {\n        return this.styles;\n    }\n    getResources() {\n        return this.resources;\n    }\n    getFontMap() {\n        return this.fontMap;\n    }\n    // Add methods to return style and font definitions for debug\n    getParagraphStyles() {\n        return this.styles.paragraph;\n    }\n    getCharacterStyles() {\n        return this.styles.character;\n    }\n    getFontDefinitions() {\n        // Prefer plain object for debug output\n        if (this.resources && this.resources.fonts) {\n            return this.resources.fonts;\n        }\n        // Fallback: convert fontMap to object\n        if (this.fontMap && typeof this.fontMap.entries === \"function\") {\n            return Object.fromEntries(this.fontMap.entries());\n        }\n        return {};\n    }\n    // FIXED: Add method to access document preferences including ViewPreferences\n    getDocumentInfo() {\n        return this.documentInfo;\n    }\n    constructor(unitConverter = null){\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n        this.resources = {\n            fonts: {},\n            colors: {},\n            gradients: {}\n        };\n        this.fontMap = new Map(); // Global font lookup map\n        this.unitConverter = unitConverter; // ADDED: Unit converter for typography measurements\n        this.documentUnits = null; // Will be set from document units\n    }\n}\nmodule.exports = StyleParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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X0UvLi9saWIvcGFyc2Vycy9TdHlsZVBhcnNlci5qcz82OWFjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgSURNTFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL0lETUxVdGlsc1wiKTtcclxuXHJcbmNsYXNzIFN0eWxlUGFyc2VyIHtcclxuICBjb25zdHJ1Y3Rvcih1bml0Q29udmVydGVyID0gbnVsbCkge1xyXG4gICAgdGhpcy5zdHlsZXMgPSB7XHJcbiAgICAgIHBhcmFncmFwaDoge30sXHJcbiAgICAgIGNoYXJhY3Rlcjoge30sXHJcbiAgICAgIG9iamVjdDoge30sXHJcbiAgICAgIHRhYmxlOiB7fSxcclxuICAgICAgY2VsbDoge30sXHJcbiAgICB9O1xyXG4gICAgdGhpcy5yZXNvdXJjZXMgPSB7XHJcbiAgICAgIGZvbnRzOiB7fSxcclxuICAgICAgY29sb3JzOiB7fSxcclxuICAgICAgZ3JhZGllbnRzOiB7fSxcclxuICAgIH07XHJcbiAgICB0aGlzLmZvbnRNYXAgPSBuZXcgTWFwKCk7IC8vIEdsb2JhbCBmb250IGxvb2t1cCBtYXBcclxuICAgIHRoaXMudW5pdENvbnZlcnRlciA9IHVuaXRDb252ZXJ0ZXI7IC8vIEFEREVEOiBVbml0IGNvbnZlcnRlciBmb3IgdHlwb2dyYXBoeSBtZWFzdXJlbWVudHNcclxuICAgIHRoaXMuZG9jdW1lbnRVbml0cyA9IG51bGw7IC8vIFdpbGwgYmUgc2V0IGZyb20gZG9jdW1lbnQgdW5pdHNcclxuICB9XHJcblxyXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gc2V0IGRvY3VtZW50IHVuaXRzIGZvciB0eXBvZ3JhcGh5IGNvbnZlcnNpb25cclxuICBzZXREb2N1bWVudFVuaXRzKHVuaXRzKSB7XHJcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSB1bml0cztcclxuICAgIGNvbnNvbGUubG9nKFwi8J+TkCBTdHlsZVBhcnNlcjogU2V0IGRvY3VtZW50IHVuaXRzIHRvXCIsIHVuaXRzKTtcclxuICB9XHJcblxyXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gY29udmVydCB0eXBvZ3JhcGh5IG1lYXN1cmVtZW50cyB0byBwaXhlbHNcclxuICBjb252ZXJ0VHlwb2dyYXBoeVRvUGl4ZWxzKHZhbHVlKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fFxyXG4gICAgICBpc05hTih2YWx1ZSkgfHxcclxuICAgICAgIXRoaXMudW5pdENvbnZlcnRlciB8fFxyXG4gICAgICAhdGhpcy5kb2N1bWVudFVuaXRzXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9ubHkgY29udmVydCBpZiB3ZSBoYXZlIGEgc3VwcG9ydGVkIHVuaXQgYW5kIGl0J3Mgbm90IGFscmVhZHkgcGl4ZWxzXHJcbiAgICBpZiAodGhpcy51bml0Q29udmVydGVyLmlzU3VwcG9ydGVkVW5pdCh0aGlzLmRvY3VtZW50VW5pdHMpKSB7XHJcbiAgICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gdGhpcy51bml0Q29udmVydGVyLnRvUGl4ZWxzKFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRVbml0c1xyXG4gICAgICApO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg8J+TkCBDb252ZXJ0ZWQgdHlwb2dyYXBoeTogJHt2YWx1ZX0gJHt0aGlzLmRvY3VtZW50VW5pdHN9IOKGkiAke2NvbnZlcnRlZFZhbHVlfSBweGBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGNvbnZlcnRlZFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gY29udmVydCBhbiBlbnRpcmUgc3R5bGUgb2JqZWN0J3MgbWVhc3VyZW1lbnRzIHRvIHBpeGVsc1xyXG4gIGNvbnZlcnRTdHlsZU1lYXN1cmVtZW50c1RvUGl4ZWxzKHN0eWxlKSB7XHJcbiAgICBpZiAoIXRoaXMudW5pdENvbnZlcnRlciB8fCAhdGhpcy5kb2N1bWVudFVuaXRzKSB7XHJcbiAgICAgIHJldHVybiBzdHlsZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb252ZXJ0ZWRTdHlsZSA9IHsgLi4uc3R5bGUgfTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IG1lYXN1cmVtZW50cyB0aGF0IG5lZWQgcGl4ZWwgY29udmVyc2lvblxyXG4gICAgY29uc3QgbWVhc3VyZW1lbnRGaWVsZHMgPSBbXHJcbiAgICAgIFwibGVmdEluZGVudFwiLFxyXG4gICAgICBcInJpZ2h0SW5kZW50XCIsXHJcbiAgICAgIFwiZmlyc3RMaW5lSW5kZW50XCIsXHJcbiAgICAgIFwic3BhY2VCZWZvcmVcIixcclxuICAgICAgXCJzcGFjZUFmdGVyXCIsXHJcbiAgICAgIFwidHJhY2tpbmdcIixcclxuICAgICAgXCJrZXJuaW5nXCIsXHJcbiAgICBdO1xyXG5cclxuICAgIG1lYXN1cmVtZW50RmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgY29udmVydGVkU3R5bGVbZmllbGRdID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgY29udmVydGVkU3R5bGVbZmllbGRdID0gdGhpcy5jb252ZXJ0VHlwb2dyYXBoeVRvUGl4ZWxzKFxyXG4gICAgICAgICAgY29udmVydGVkU3R5bGVbZmllbGRdXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ29udmVydCBsZWFkaW5nIGlmIGl0J3MgYSBudW1lcmljIHZhbHVlXHJcbiAgICBpZiAodHlwZW9mIGNvbnZlcnRlZFN0eWxlLmxlYWRpbmcgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgY29udmVydGVkU3R5bGUubGVhZGluZyA9IHRoaXMuY29udmVydFR5cG9ncmFwaHlUb1BpeGVscyhcclxuICAgICAgICBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnZlcnRlZFN0eWxlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcGFyc2VSZXNvdXJjZUZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coYPCfk4sgUGFyc2luZyByZXNvdXJjZTogJHtmaWxlTmFtZX1gKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSB4bWxQYXJzZXIucGFyc2UoY29udGVudCk7XHJcbiAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUsIFwiLnhtbFwiKTtcclxuXHJcbiAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgcmVzb3VyY2UgdHlwZXNcclxuICAgICAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKFwiU3R5bGVzLnhtbFwiKSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdFN0eWxlcyhwYXJzZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKFwiRm9udHMueG1sXCIpKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0Rm9udHMocGFyc2VkKTtcclxuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhcIkdyYXBoaWMueG1sXCIpKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0R3JhcGhpY3MocGFyc2VkKTtcclxuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhcIlByZWZlcmVuY2VzLnhtbFwiKSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdFByZWZlcmVuY2VzKHBhcnNlZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUmVzb3VyY2UgJHtyZXNvdXJjZU5hbWV9IHBhcnNlZGApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHBhcnNpbmcgJHtmaWxlTmFtZX06YCwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHRyYWN0U3R5bGVzKHN0eWxlc0RhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBzdHlsZXMuLi5cIik7XHJcblxyXG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVzRGF0YS5TdHlsZXMgfHwgc3R5bGVzRGF0YTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IFBhcmFncmFwaCBTdHlsZXNcclxuICAgIGlmIChzdHlsZXMuUm9vdFBhcmFncmFwaFN0eWxlR3JvdXApIHtcclxuICAgICAgdGhpcy5leHRyYWN0UGFyYWdyYXBoU3R5bGVzKHN0eWxlcy5Sb290UGFyYWdyYXBoU3R5bGVHcm91cCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXh0cmFjdCBDaGFyYWN0ZXIgU3R5bGVzXHJcbiAgICBpZiAoc3R5bGVzLlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwKSB7XHJcbiAgICAgIHRoaXMuZXh0cmFjdENoYXJhY3RlclN0eWxlcyhzdHlsZXMuUm9vdENoYXJhY3RlclN0eWxlR3JvdXApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBhcmFncmFwaFN0eWxlcyhzdHlsZUdyb3VwKSB7XHJcbiAgICBjb25zdCBleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkgPSAoZ3JvdXApID0+IHtcclxuICAgICAgaWYgKGdyb3VwLlBhcmFncmFwaFN0eWxlKSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gQXJyYXkuaXNBcnJheShncm91cC5QYXJhZ3JhcGhTdHlsZSlcclxuICAgICAgICAgID8gZ3JvdXAuUGFyYWdyYXBoU3R5bGVcclxuICAgICAgICAgIDogW2dyb3VwLlBhcmFncmFwaFN0eWxlXTtcclxuXHJcbiAgICAgICAgc3R5bGVzLmZvckVhY2goKHN0eWxlKSA9PiB7XHJcbiAgICAgICAgICAvLyBDUklUSUNBTDogRXh0cmFjdCBmb250IHJlZmVyZW5jZSBmcm9tIG11bHRpcGxlIHBvc3NpYmxlIGxvY2F0aW9uc1xyXG4gICAgICAgICAgY29uc3QgZm9udFJlZiA9IHRoaXMuZXh0cmFjdEZvbnRGcm9tU3R5bGUoc3R5bGUpO1xyXG5cclxuICAgICAgICAgIC8vIEVOSEFOQ0VEOiBQcm9jZXNzIGxlYWRpbmcgd2l0aCBwcm9wZXIgSW5EZXNpZ24gbG9naWNcclxuICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfUG9pbnRTaXplXCJdKSB8fCAxMjtcclxuICAgICAgICAgIGNvbnN0IHJhd0xlYWRpbmcgPSBzdHlsZVtcIkBfTGVhZGluZ1wiXTtcclxuICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZExlYWRpbmcgPSB0aGlzLnByb2Nlc3NMZWFkaW5nVmFsdWUoXHJcbiAgICAgICAgICAgIHJhd0xlYWRpbmcsXHJcbiAgICAgICAgICAgIGZvbnRTaXplXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIEZJWEVEOiBFeHRyYWN0IHJhdyB0eXBvZ3JhcGh5IG1lYXN1cmVtZW50cyBmb3IgY29udmVyc2lvblxyXG4gICAgICAgICAgY29uc3QgcmF3TGVmdEluZGVudCA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX0xlZnRJbmRlbnRcIl0pIHx8IDA7XHJcbiAgICAgICAgICBjb25zdCByYXdSaWdodEluZGVudCA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1JpZ2h0SW5kZW50XCJdKSB8fCAwO1xyXG4gICAgICAgICAgY29uc3QgcmF3Rmlyc3RMaW5lSW5kZW50ID1cclxuICAgICAgICAgICAgcGFyc2VGbG9hdChzdHlsZVtcIkBfRmlyc3RMaW5lSW5kZW50XCJdKSB8fCAwO1xyXG4gICAgICAgICAgY29uc3QgcmF3U3BhY2VCZWZvcmUgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9TcGFjZUJlZm9yZVwiXSkgfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHJhd1NwYWNlQWZ0ZXIgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9TcGFjZUFmdGVyXCJdKSB8fCAwO1xyXG4gICAgICAgICAgY29uc3QgcmF3VHJhY2tpbmcgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9UcmFja2luZ1wiXSkgfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHJhd0tlcm5pbmcgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9LZXJuaW5nXCJdKSB8fCAwO1xyXG5cclxuICAgICAgICAgIC8vIEZJWEVEOiBDcmVhdGUgYmFzZSBzdHlsZSBvYmplY3Qgd2l0aCByYXcgdmFsdWVzXHJcbiAgICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSB7XHJcbiAgICAgICAgICAgIHNlbGY6IHN0eWxlW1wiQF9TZWxmXCJdLFxyXG4gICAgICAgICAgICBuYW1lOiBzdHlsZVtcIkBfTmFtZVwiXSB8fCBcIlwiLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6IHN0eWxlW1wiQF9Gb250U3R5bGVcIl0gfHwgXCJSZWd1bGFyXCIsXHJcbiAgICAgICAgICAgIHBvaW50U2l6ZTogZm9udFNpemUsXHJcbiAgICAgICAgICAgIGxlYWRpbmc6IHByb2Nlc3NlZExlYWRpbmcsXHJcbiAgICAgICAgICAgIGxlYWRpbmdUeXBlOiB0aGlzLmRldGVybWluZUxlYWRpbmdUeXBlKHJhd0xlYWRpbmcpLFxyXG4gICAgICAgICAgICBlZmZlY3RpdmVMaW5lSGVpZ2h0OiB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoXHJcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkTGVhZGluZyxcclxuICAgICAgICAgICAgICBmb250U2l6ZVxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IHN0eWxlW1wiQF9KdXN0aWZpY2F0aW9uXCJdIHx8IFwiTGVmdEFsaWduXCIsXHJcblxyXG4gICAgICAgICAgICAvLyBSYXcgbWVhc3VyZW1lbnRzICh3aWxsIGJlIGNvbnZlcnRlZCB0byBwaXhlbHMpXHJcbiAgICAgICAgICAgIGxlZnRJbmRlbnQ6IHJhd0xlZnRJbmRlbnQsXHJcbiAgICAgICAgICAgIHJpZ2h0SW5kZW50OiByYXdSaWdodEluZGVudCxcclxuICAgICAgICAgICAgZmlyc3RMaW5lSW5kZW50OiByYXdGaXJzdExpbmVJbmRlbnQsXHJcbiAgICAgICAgICAgIHNwYWNlQmVmb3JlOiByYXdTcGFjZUJlZm9yZSxcclxuICAgICAgICAgICAgc3BhY2VBZnRlcjogcmF3U3BhY2VBZnRlcixcclxuICAgICAgICAgICAgdHJhY2tpbmc6IHJhd1RyYWNraW5nLFxyXG4gICAgICAgICAgICBrZXJuaW5nOiByYXdLZXJuaW5nLFxyXG5cclxuICAgICAgICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgdmFsdWVzIGZvciByZWZlcmVuY2VcclxuICAgICAgICAgICAgb3JpZ2luYWxMZWZ0SW5kZW50OiByYXdMZWZ0SW5kZW50LFxyXG4gICAgICAgICAgICBvcmlnaW5hbFJpZ2h0SW5kZW50OiByYXdSaWdodEluZGVudCxcclxuICAgICAgICAgICAgb3JpZ2luYWxGaXJzdExpbmVJbmRlbnQ6IHJhd0ZpcnN0TGluZUluZGVudCxcclxuICAgICAgICAgICAgb3JpZ2luYWxTcGFjZUJlZm9yZTogcmF3U3BhY2VCZWZvcmUsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3BhY2VBZnRlcjogcmF3U3BhY2VBZnRlcixcclxuICAgICAgICAgICAgb3JpZ2luYWxUcmFja2luZzogcmF3VHJhY2tpbmcsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsS2VybmluZzogcmF3S2VybmluZyxcclxuXHJcbiAgICAgICAgICAgIGhvcml6b250YWxTY2FsZTogcGFyc2VGbG9hdChzdHlsZVtcIkBfSG9yaXpvbnRhbFNjYWxlXCJdKSB8fCAxMDAsXHJcbiAgICAgICAgICAgIHZlcnRpY2FsU2NhbGU6IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1ZlcnRpY2FsU2NhbGVcIl0pIHx8IDEwMCxcclxuXHJcbiAgICAgICAgICAgIC8vIEVOSEFOQ0VEOiBVc2UgdGhlIG5ldyBleHRyYWN0aW9uIG1ldGhvZFxyXG4gICAgICAgICAgICBhcHBsaWVkRm9udDogZm9udFJlZixcclxuICAgICAgICAgICAgb3JpZ2luYWxGb250UmVmOiBmb250UmVmLFxyXG5cclxuICAgICAgICAgICAgZmlsbENvbG9yOiBzdHlsZVtcIkBfRmlsbENvbG9yXCJdIHx8IFwiQ29sb3IvQmxhY2tcIixcclxuICAgICAgICAgICAgcmF3U3R5bGU6IHN0eWxlLFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBGSVhFRDogQXBwbHkgdW5pdCBjb252ZXJzaW9uIHRvIGNyZWF0ZSBwaXhlbC1jb252ZXJ0ZWQgc3R5bGVcclxuICAgICAgICAgIHRoaXMuc3R5bGVzLnBhcmFncmFwaFtzdHlsZVtcIkBfU2VsZlwiXV0gPVxyXG4gICAgICAgICAgICB0aGlzLmNvbnZlcnRTdHlsZU1lYXN1cmVtZW50c1RvUGl4ZWxzKGJhc2VTdHlsZSk7XHJcblxyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGDinIUgUGFyYWdyYXBoIFN0eWxlOiAke3N0eWxlW1wiQF9OYW1lXCJdfSAtPiBGb250OiBcIiR7Zm9udFJlZn1cImBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XHJcbiAgICAgICAgY29uc3Qgc3ViR3JvdXBzID0gQXJyYXkuaXNBcnJheShncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwKVxyXG4gICAgICAgICAgPyBncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwXHJcbiAgICAgICAgICA6IFtncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwXTtcclxuICAgICAgICBzdWJHcm91cHMuZm9yRWFjaChleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseShzdHlsZUdyb3VwKTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RGb250RnJvbVN0eWxlKHN0eWxlKSB7XHJcbiAgICAvLyBUcnkgZGlyZWN0IGF0dHJpYnV0ZXMgZmlyc3RcclxuICAgIGxldCBmb250UmVmID1cclxuICAgICAgc3R5bGVbXCJAX0FwcGxpZWRGb250XCJdIHx8IHN0eWxlW1wiQF9Gb250RmFtaWx5XCJdIHx8IHN0eWxlW1wiQF9Gb250XCJdIHx8IFwiXCI7XHJcblxyXG4gICAgLy8gSWYgbm90IGZvdW5kLCB0cnkgUHJvcGVydGllcyBuZXN0ZWQgc3RydWN0dXJlXHJcbiAgICBpZiAoIWZvbnRSZWYgJiYgc3R5bGUuUHJvcGVydGllcykge1xyXG4gICAgICBpZiAoc3R5bGUuUHJvcGVydGllcy5BcHBsaWVkRm9udCkge1xyXG4gICAgICAgIGZvbnRSZWYgPVxyXG4gICAgICAgICAgc3R5bGUuUHJvcGVydGllcy5BcHBsaWVkRm9udFtcIiN0ZXh0XCJdIHx8XHJcbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250IHx8XHJcbiAgICAgICAgICBcIlwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbHNvIHRyeSBvdGhlciBwcm9wZXJ0eSB2YXJpYXRpb25zXHJcbiAgICAgIGlmICghZm9udFJlZiAmJiBzdHlsZS5Qcm9wZXJ0aWVzLkZvbnRGYW1pbHkpIHtcclxuICAgICAgICBmb250UmVmID1cclxuICAgICAgICAgIHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseVtcIiN0ZXh0XCJdIHx8XHJcbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkZvbnRGYW1pbHkgfHxcclxuICAgICAgICAgIFwiXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9udFJlZiB8fCBcIlwiO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdENoYXJhY3RlclN0eWxlcyhzdHlsZUdyb3VwKSB7XHJcbiAgICBjb25zdCBleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkgPSAoZ3JvdXApID0+IHtcclxuICAgICAgaWYgKGdyb3VwLkNoYXJhY3RlclN0eWxlKSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gQXJyYXkuaXNBcnJheShncm91cC5DaGFyYWN0ZXJTdHlsZSlcclxuICAgICAgICAgID8gZ3JvdXAuQ2hhcmFjdGVyU3R5bGVcclxuICAgICAgICAgIDogW2dyb3VwLkNoYXJhY3RlclN0eWxlXTtcclxuXHJcbiAgICAgICAgc3R5bGVzLmZvckVhY2goKHN0eWxlKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBmb250UmVmID0gdGhpcy5leHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSk7XHJcblxyXG4gICAgICAgICAgdGhpcy5zdHlsZXMuY2hhcmFjdGVyW3N0eWxlW1wiQF9TZWxmXCJdXSA9IHtcclxuICAgICAgICAgICAgc2VsZjogc3R5bGVbXCJAX1NlbGZcIl0sXHJcbiAgICAgICAgICAgIG5hbWU6IHN0eWxlW1wiQF9OYW1lXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGZvbnRTdHlsZTogc3R5bGVbXCJAX0ZvbnRTdHlsZVwiXSB8fCBcIlJlZ3VsYXJcIixcclxuICAgICAgICAgICAgcG9pbnRTaXplOiBwYXJzZUZsb2F0KHN0eWxlW1wiQF9Qb2ludFNpemVcIl0pIHx8IG51bGwsXHJcblxyXG4gICAgICAgICAgICBhcHBsaWVkRm9udDogZm9udFJlZixcclxuICAgICAgICAgICAgb3JpZ2luYWxGb250UmVmOiBmb250UmVmLFxyXG5cclxuICAgICAgICAgICAgZmlsbENvbG9yOiBzdHlsZVtcIkBfRmlsbENvbG9yXCJdIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzdHlsZVtcIkBfU3Ryb2tlQ29sb3JcIl0gfHwgbnVsbCxcclxuICAgICAgICAgICAgcmF3U3R5bGU6IHN0eWxlLFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYOKchSBDaGFyYWN0ZXIgU3R5bGU6ICR7c3R5bGVbXCJAX05hbWVcIl19IC0+IEZvbnQ6IFwiJHtmb250UmVmfVwiYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGdyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXApIHtcclxuICAgICAgICBjb25zdCBzdWJHcm91cHMgPSBBcnJheS5pc0FycmF5KGdyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXApXHJcbiAgICAgICAgICA/IGdyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXBcclxuICAgICAgICAgIDogW2dyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXBdO1xyXG4gICAgICAgIHN1Ykdyb3Vwcy5mb3JFYWNoKGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KHN0eWxlR3JvdXApO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdEZvbnRzKGZvbnRzRGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIGZvbnRzIHdpdGggZW5oYW5jZWQgbWFwcGluZy4uLlwiKTtcclxuXHJcbiAgICBjb25zdCBmb250cyA9IGZvbnRzRGF0YS5Gb250cyB8fCBmb250c0RhdGE7XHJcbiAgICB0aGlzLnJlc291cmNlcy5mb250cyA9IHt9O1xyXG4gICAgdGhpcy5mb250TWFwID0gbmV3IE1hcCgpOyAvLyBHbG9iYWwgZm9udCBsb29rdXAgbWFwXHJcblxyXG4gICAgaWYgKGZvbnRzLkZvbnRGYW1pbHkpIHtcclxuICAgICAgY29uc3QgZm9udEZhbWlsaWVzID0gQXJyYXkuaXNBcnJheShmb250cy5Gb250RmFtaWx5KVxyXG4gICAgICAgID8gZm9udHMuRm9udEZhbWlseVxyXG4gICAgICAgIDogW2ZvbnRzLkZvbnRGYW1pbHldO1xyXG5cclxuICAgICAgZm9udEZhbWlsaWVzLmZvckVhY2goKGZhbWlseSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZhbWlseUluZm8gPSB7XHJcbiAgICAgICAgICBzZWxmOiBmYW1pbHlbXCJAX1NlbGZcIl0sXHJcbiAgICAgICAgICBuYW1lOiBmYW1pbHlbXCJAX05hbWVcIl0gfHwgXCJcIixcclxuICAgICAgICAgIGZvbnRzOiBbXSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoZmFtaWx5LkZvbnQpIHtcclxuICAgICAgICAgIGNvbnN0IGZvbnRMaXN0ID0gQXJyYXkuaXNBcnJheShmYW1pbHkuRm9udClcclxuICAgICAgICAgICAgPyBmYW1pbHkuRm9udFxyXG4gICAgICAgICAgICA6IFtmYW1pbHkuRm9udF07XHJcblxyXG4gICAgICAgICAgZm9udExpc3QuZm9yRWFjaCgoZm9udCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmb250SW5mbyA9IHtcclxuICAgICAgICAgICAgICBzZWxmOiBmb250W1wiQF9TZWxmXCJdLFxyXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGZvbnRbXCJAX0ZvbnRGYW1pbHlcIl0gfHwgZmFtaWx5SW5mby5uYW1lLFxyXG4gICAgICAgICAgICAgIG5hbWU6IGZvbnRbXCJAX05hbWVcIl0gfHwgXCJcIixcclxuICAgICAgICAgICAgICBwb3N0U2NyaXB0TmFtZTogZm9udFtcIkBfUG9zdFNjcmlwdE5hbWVcIl0gfHwgXCJcIixcclxuICAgICAgICAgICAgICBzdGF0dXM6IGZvbnRbXCJAX1N0YXR1c1wiXSB8fCBcIlVua25vd25cIixcclxuICAgICAgICAgICAgICBmb250U3R5bGVOYW1lOiBmb250W1wiQF9Gb250U3R5bGVOYW1lXCJdIHx8IFwiUmVndWxhclwiLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZmFtaWx5SW5mby5mb250cy5wdXNoKGZvbnRJbmZvKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBsb29rdXAgZW50cmllcyBmb3IgdGhpcyBmb250XHJcbiAgICAgICAgICAgIHRoaXMuZm9udE1hcC5zZXQoZm9udFtcIkBfU2VsZlwiXSwgZmFtaWx5SW5mby5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250W1wiQF9Qb3N0U2NyaXB0TmFtZVwiXSwgZmFtaWx5SW5mby5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250W1wiQF9OYW1lXCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX0ZvbnRGYW1pbHlcIl0sIGZhbWlseUluZm8ubmFtZSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICBgRm9udCBtYXBwaW5nOiAke2ZvbnRbXCJAX1NlbGZcIl19IC0+ICR7ZmFtaWx5SW5mby5uYW1lfWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZm9udHNbZmFtaWx5W1wiQF9TZWxmXCJdXSA9IGZhbWlseUluZm87XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBg4pyFIEZvbnRzIGV4dHJhY3RlZDogJHtPYmplY3Qua2V5cyh0aGlzLnJlc291cmNlcy5mb250cykubGVuZ3RofSBmYW1pbGllc2BcclxuICAgICk7XHJcbiAgICBjb25zb2xlLmxvZyhgRm9udCBtYXAgZW50cmllczogJHt0aGlzLmZvbnRNYXAuc2l6ZX1gKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3RHcmFwaGljcyhncmFwaGljc0RhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBncmFwaGljcyBhbmQgY29sb3JzLi4uXCIpO1xyXG5cclxuICAgIGNvbnN0IGdyYXBoaWNzID0gZ3JhcGhpY3NEYXRhLkdyYXBoaWMgfHwgZ3JhcGhpY3NEYXRhO1xyXG4gICAgdGhpcy5yZXNvdXJjZXMuY29sb3JzID0ge307XHJcbiAgICB0aGlzLnJlc291cmNlcy5ncmFkaWVudHMgPSB7fTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IENvbG9yc1xyXG4gICAgaWYgKGdyYXBoaWNzLkNvbG9yKSB7XHJcbiAgICAgIGNvbnN0IGNvbG9ycyA9IEFycmF5LmlzQXJyYXkoZ3JhcGhpY3MuQ29sb3IpXHJcbiAgICAgICAgPyBncmFwaGljcy5Db2xvclxyXG4gICAgICAgIDogW2dyYXBoaWNzLkNvbG9yXTtcclxuXHJcbiAgICAgIGNvbG9ycy5mb3JFYWNoKChjb2xvcikgPT4ge1xyXG4gICAgICAgIC8vIEV4dHJhY3QgY2hhbm5lbCB2YWx1ZXNcclxuICAgICAgICBjb25zdCBjeWFuID0gcGFyc2VGbG9hdChjb2xvcltcIkBfQ3lhblwiXSkgfHwgMDtcclxuICAgICAgICBjb25zdCBtYWdlbnRhID0gcGFyc2VGbG9hdChjb2xvcltcIkBfTWFnZW50YVwiXSkgfHwgMDtcclxuICAgICAgICBjb25zdCB5ZWxsb3cgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9ZZWxsb3dcIl0pIHx8IDA7XHJcbiAgICAgICAgY29uc3QgYmxhY2sgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9CbGFja1wiXSkgfHwgMDtcclxuICAgICAgICBjb25zdCByZWQgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9SZWRcIl0pIHx8IDA7XHJcbiAgICAgICAgY29uc3QgZ3JlZW4gPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9HcmVlblwiXSkgfHwgMDtcclxuICAgICAgICBjb25zdCBibHVlID0gcGFyc2VGbG9hdChjb2xvcltcIkBfQmx1ZVwiXSkgfHwgMDtcclxuXHJcbiAgICAgICAgLy8gRmFsbGJhY2s6IElmIG5vIENNWUsgb3IgUkdCLCBidXQgQ29sb3JWYWx1ZSBleGlzdHMsIHBhcnNlIGFzIFJHQlxyXG4gICAgICAgIGxldCBmYWxsYmFja1JHQiA9IG51bGw7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgY3lhbiA9PT0gMCAmJlxyXG4gICAgICAgICAgbWFnZW50YSA9PT0gMCAmJlxyXG4gICAgICAgICAgeWVsbG93ID09PSAwICYmXHJcbiAgICAgICAgICBibGFjayA9PT0gMCAmJlxyXG4gICAgICAgICAgcmVkID09PSAwICYmXHJcbiAgICAgICAgICBncmVlbiA9PT0gMCAmJlxyXG4gICAgICAgICAgYmx1ZSA9PT0gMCAmJlxyXG4gICAgICAgICAgY29sb3JbXCJAX0NvbG9yVmFsdWVcIl1cclxuICAgICAgICApIHtcclxuICAgICAgICAgIC8vIENvbG9yVmFsdWUgaXMgdXN1YWxseSBhIHNwYWNlLXNlcGFyYXRlZCBSR0IgdHJpcGxldCwgZS5nLiBcIjI1NSAxNDAgMFwiXHJcbiAgICAgICAgICBjb25zdCByZ2JQYXJ0cyA9IGNvbG9yW1wiQF9Db2xvclZhbHVlXCJdLnNwbGl0KC9cXHMrLykubWFwKE51bWJlcik7XHJcbiAgICAgICAgICBpZiAocmdiUGFydHMubGVuZ3RoID09PSAzICYmIHJnYlBhcnRzLmV2ZXJ5KCh2KSA9PiAhaXNOYU4odikpKSB7XHJcbiAgICAgICAgICAgIGZhbGxiYWNrUkdCID0ge1xyXG4gICAgICAgICAgICAgIHJlZDogcmdiUGFydHNbMF0sXHJcbiAgICAgICAgICAgICAgZ3JlZW46IHJnYlBhcnRzWzFdLFxyXG4gICAgICAgICAgICAgIGJsdWU6IHJnYlBhcnRzWzJdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuY29sb3JzW2NvbG9yW1wiQF9TZWxmXCJdXSA9IHtcclxuICAgICAgICAgIHNlbGY6IGNvbG9yW1wiQF9TZWxmXCJdLFxyXG4gICAgICAgICAgbmFtZTogY29sb3JbXCJAX05hbWVcIl0gfHwgXCJcIixcclxuICAgICAgICAgIG1vZGVsOiBjb2xvcltcIkBfTW9kZWxcIl0gfHwgXCJQcm9jZXNzXCIsXHJcbiAgICAgICAgICBzcGFjZTogY29sb3JbXCJAX1NwYWNlXCJdIHx8IFwiQ01ZS1wiLFxyXG4gICAgICAgICAgY3lhbixcclxuICAgICAgICAgIG1hZ2VudGEsXHJcbiAgICAgICAgICB5ZWxsb3csXHJcbiAgICAgICAgICBibGFjayxcclxuICAgICAgICAgIHJlZDogZmFsbGJhY2tSR0IgPyBmYWxsYmFja1JHQi5yZWQgOiByZWQsXHJcbiAgICAgICAgICBncmVlbjogZmFsbGJhY2tSR0IgPyBmYWxsYmFja1JHQi5ncmVlbiA6IGdyZWVuLFxyXG4gICAgICAgICAgYmx1ZTogZmFsbGJhY2tSR0IgPyBmYWxsYmFja1JHQi5ibHVlIDogYmx1ZSxcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeHRyYWN0IEdyYWRpZW50c1xyXG4gICAgaWYgKGdyYXBoaWNzLkdyYWRpZW50KSB7XHJcbiAgICAgIGNvbnN0IGdyYWRpZW50cyA9IEFycmF5LmlzQXJyYXkoZ3JhcGhpY3MuR3JhZGllbnQpXHJcbiAgICAgICAgPyBncmFwaGljcy5HcmFkaWVudFxyXG4gICAgICAgIDogW2dyYXBoaWNzLkdyYWRpZW50XTtcclxuXHJcbiAgICAgIGdyYWRpZW50cy5mb3JFYWNoKChncmFkaWVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzLmdyYWRpZW50c1tncmFkaWVudFtcIkBfU2VsZlwiXV0gPSB7XHJcbiAgICAgICAgICBzZWxmOiBncmFkaWVudFtcIkBfU2VsZlwiXSxcclxuICAgICAgICAgIG5hbWU6IGdyYWRpZW50W1wiQF9OYW1lXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgICB0eXBlOiBncmFkaWVudFtcIkBfVHlwZVwiXSB8fCBcIkxpbmVhclwiLFxyXG4gICAgICAgICAgZ3JhZGllbnRTdG9wczogdGhpcy5leHRyYWN0R3JhZGllbnRTdG9wcyhncmFkaWVudCksXHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3JhZGllbnRTdG9wcyhncmFkaWVudCkge1xyXG4gICAgY29uc3Qgc3RvcHMgPSBbXTtcclxuXHJcbiAgICBpZiAoZ3JhZGllbnQuR3JhZGllbnRTdG9wKSB7XHJcbiAgICAgIGNvbnN0IHN0b3BMaXN0ID0gQXJyYXkuaXNBcnJheShncmFkaWVudC5HcmFkaWVudFN0b3ApXHJcbiAgICAgICAgPyBncmFkaWVudC5HcmFkaWVudFN0b3BcclxuICAgICAgICA6IFtncmFkaWVudC5HcmFkaWVudFN0b3BdO1xyXG5cclxuICAgICAgc3RvcExpc3QuZm9yRWFjaCgoc3RvcCkgPT4ge1xyXG4gICAgICAgIHN0b3BzLnB1c2goe1xyXG4gICAgICAgICAgc2VsZjogc3RvcFtcIkBfU2VsZlwiXSxcclxuICAgICAgICAgIHN0b3BDb2xvcjogc3RvcFtcIkBfU3RvcENvbG9yXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgICBsb2NhdGlvbjogcGFyc2VGbG9hdChzdG9wW1wiQF9Mb2NhdGlvblwiXSkgfHwgMCxcclxuICAgICAgICAgIG1pZHBvaW50OiBwYXJzZUZsb2F0KHN0b3BbXCJAX01pZHBvaW50XCJdKSB8fCA1MCxcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0b3BzO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdFByZWZlcmVuY2VzKHByZWZlcmVuY2VzRGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIGRvY3VtZW50IHByZWZlcmVuY2VzLi4uXCIpO1xyXG5cclxuICAgIGNvbnN0IHByZWZzID0gcHJlZmVyZW5jZXNEYXRhLlByZWZlcmVuY2VzIHx8IHByZWZlcmVuY2VzRGF0YTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IHZhcmlvdXMgZG9jdW1lbnQgcHJlZmVyZW5jZXNcclxuICAgIHRoaXMuZG9jdW1lbnRJbmZvID0ge1xyXG4gICAgICBwcmVmZXJlbmNlczoge1xyXG4gICAgICAgIGRvY3VtZW50UHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdERvY3VtZW50UHJlZnMoXHJcbiAgICAgICAgICBwcmVmcy5Eb2N1bWVudFByZWZlcmVuY2VcclxuICAgICAgICApLFxyXG4gICAgICAgIHZpZXdQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0Vmlld1ByZWZzKHByZWZzLlZpZXdQcmVmZXJlbmNlKSxcclxuICAgICAgICBndWlkZVByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RHdWlkZVByZWZzKHByZWZzLkd1aWRlUHJlZmVyZW5jZSksXHJcbiAgICAgICAgZ3JpZFByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RHcmlkUHJlZnMocHJlZnMuR3JpZFByZWZlcmVuY2UpLFxyXG4gICAgICAgIG1hcmdpblByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RNYXJnaW5QcmVmcyhwcmVmcy5NYXJnaW5QcmVmZXJlbmNlKSxcclxuICAgICAgICBjb2x1bW5QcmVmZXJlbmNlczogdGhpcy5leHRyYWN0Q29sdW1uUHJlZnMocHJlZnMuQ29sdW1uUHJlZmVyZW5jZSksXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdERvY3VtZW50UHJlZnMoZG9jUHJlZikge1xyXG4gICAgaWYgKCFkb2NQcmVmKSByZXR1cm4ge307XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGFnZVdpZHRoOiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX1BhZ2VXaWR0aFwiXSkgfHwgMCxcclxuICAgICAgcGFnZUhlaWdodDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9QYWdlSGVpZ2h0XCJdKSB8fCAwLFxyXG4gICAgICBsZWZ0OiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0xlZnRcIl0pIHx8IDAsXHJcbiAgICAgIHRvcDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Ub3BcIl0pIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX1JpZ2h0XCJdKSB8fCAwLFxyXG4gICAgICBib3R0b206IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfQm90dG9tXCJdKSB8fCAwLFxyXG4gICAgICBjb2x1bW5Db3VudDogcGFyc2VJbnQoZG9jUHJlZltcIkBfQ29sdW1uQ291bnRcIl0pIHx8IDEsXHJcbiAgICAgIGNvbHVtbkd1dHRlcjogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Db2x1bW5HdXR0ZXJcIl0pIHx8IDAsXHJcbiAgICAgIGZhY2luZ1BhZ2VzOiBkb2NQcmVmW1wiQF9GYWNpbmdQYWdlc1wiXSA9PT0gdHJ1ZSxcclxuICAgICAgYWxsb3dQYWdlU2h1ZmZsZTogZG9jUHJlZltcIkBfQWxsb3dQYWdlU2h1ZmZsZVwiXSAhPT0gZmFsc2UsXHJcbiAgICAgIHNsdWdCbGVlZFR5cGU6IGRvY1ByZWZbXCJAX1NsdWdCbGVlZFR5cGVcIl0gfHwgXCJOb25lXCIsXHJcbiAgICAgIGRvY3VtZW50QmxlZWRUb3BPZmZzZXQ6XHJcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkVG9wT2Zmc2V0XCJdKSB8fCAwLFxyXG4gICAgICBkb2N1bWVudEJsZWVkQm90dG9tT2Zmc2V0OlxyXG4gICAgICAgIHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfRG9jdW1lbnRCbGVlZEJvdHRvbU9mZnNldFwiXSkgfHwgMCxcclxuICAgICAgZG9jdW1lbnRCbGVlZEluc2lkZU9yTGVmdE9mZnNldDpcclxuICAgICAgICBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0RvY3VtZW50QmxlZWRJbnNpZGVPckxlZnRPZmZzZXRcIl0pIHx8IDAsXHJcbiAgICAgIGRvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldDpcclxuICAgICAgICBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0RvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldFwiXSkgfHwgMCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0Vmlld1ByZWZzKHZpZXdQcmVmKSB7XHJcbiAgICBpZiAoIXZpZXdQcmVmKSByZXR1cm4ge307XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHM6XHJcbiAgICAgICAgdmlld1ByZWZbXCJAX0hvcml6b250YWxNZWFzdXJlbWVudFVuaXRzXCJdIHx8IFwiUG9pbnRzXCIsXHJcbiAgICAgIHZlcnRpY2FsTWVhc3VyZW1lbnRVbml0czpcclxuICAgICAgICB2aWV3UHJlZltcIkBfVmVydGljYWxNZWFzdXJlbWVudFVuaXRzXCJdIHx8IFwiUG9pbnRzXCIsXHJcbiAgICAgIHJ1bGVyT3JpZ2luOiB2aWV3UHJlZltcIkBfUnVsZXJPcmlnaW5cIl0gfHwgXCJTcHJlYWRPcmlnaW5cIixcclxuICAgICAgc2hvd1J1bGVyczogdmlld1ByZWZbXCJAX1Nob3dSdWxlcnNcIl0gIT09IGZhbHNlLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RHdWlkZVByZWZzKGd1aWRlUHJlZikge1xyXG4gICAgaWYgKCFndWlkZVByZWYpIHJldHVybiB7fTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBydWxlckd1aWRlQ29sb3I6IGd1aWRlUHJlZltcIkBfUnVsZXJHdWlkZUNvbG9yXCJdIHx8IFwiR3JlZW5cIixcclxuICAgICAgZ3VpZGVzSW5CYWNrOiBndWlkZVByZWZbXCJAX0d1aWRlc0luQmFja1wiXSA9PT0gdHJ1ZSxcclxuICAgICAgZ3VpZGVzTG9ja2VkOiBndWlkZVByZWZbXCJAX0d1aWRlc0xvY2tlZFwiXSA9PT0gdHJ1ZSxcclxuICAgICAgZ3VpZGVzU2hvd246IGd1aWRlUHJlZltcIkBfR3VpZGVzU2hvd25cIl0gIT09IGZhbHNlLFxyXG4gICAgICBndWlkZXNTbmFwdG86IGd1aWRlUHJlZltcIkBfR3VpZGVzU25hcHRvXCJdICE9PSBmYWxzZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3JpZFByZWZzKGdyaWRQcmVmKSB7XHJcbiAgICBpZiAoIWdyaWRQcmVmKSByZXR1cm4ge307XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYmFzZWxpbmVTdGFydDogcGFyc2VGbG9hdChncmlkUHJlZltcIkBfQmFzZWxpbmVTdGFydFwiXSkgfHwgMCxcclxuICAgICAgYmFzZWxpbmVEaXZpc2lvbjogcGFyc2VGbG9hdChncmlkUHJlZltcIkBfQmFzZWxpbmVEaXZpc2lvblwiXSkgfHwgMTIsXHJcbiAgICAgIGJhc2VsaW5lU2hvd246IGdyaWRQcmVmW1wiQF9CYXNlbGluZVNob3duXCJdID09PSB0cnVlLFxyXG4gICAgICBiYXNlbGluZVNuYXB0bzogZ3JpZFByZWZbXCJAX0Jhc2VsaW5lU25hcHRvXCJdID09PSB0cnVlLFxyXG4gICAgICBkb2N1bWVudEdyaWRTaG93bjogZ3JpZFByZWZbXCJAX0RvY3VtZW50R3JpZFNob3duXCJdID09PSB0cnVlLFxyXG4gICAgICBkb2N1bWVudEdyaWRTbmFwdG86IGdyaWRQcmVmW1wiQF9Eb2N1bWVudEdyaWRTbmFwdG9cIl0gPT09IHRydWUsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdE1hcmdpblByZWZzKG1hcmdpblByZWYpIHtcclxuICAgIGlmICghbWFyZ2luUHJlZikgcmV0dXJuIHt9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcDogcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9Ub3BcIl0pIHx8IDAsXHJcbiAgICAgIGJvdHRvbTogcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9Cb3R0b21cIl0pIHx8IDAsXHJcbiAgICAgIGxlZnQ6IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfTGVmdFwiXSkgfHwgMCxcclxuICAgICAgcmlnaHQ6IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfUmlnaHRcIl0pIHx8IDAsXHJcbiAgICAgIGNvbHVtbkNvdW50OiBwYXJzZUludChtYXJnaW5QcmVmW1wiQF9Db2x1bW5Db3VudFwiXSkgfHwgMSxcclxuICAgICAgY29sdW1uR3V0dGVyOiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX0NvbHVtbkd1dHRlclwiXSkgfHwgMCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0Q29sdW1uUHJlZnMoY29sdW1uUHJlZikge1xyXG4gICAgaWYgKCFjb2x1bW5QcmVmKSByZXR1cm4ge307XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dENvbHVtbkNvdW50OiBwYXJzZUludChjb2x1bW5QcmVmW1wiQF9UZXh0Q29sdW1uQ291bnRcIl0pIHx8IDEsXHJcbiAgICAgIHRleHRDb2x1bW5HdXR0ZXI6IHBhcnNlRmxvYXQoY29sdW1uUHJlZltcIkBfVGV4dENvbHVtbkd1dHRlclwiXSkgfHwgMCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXNvbHZlU3R5bGVGb3JtYXR0aW5nKGZvcm1hdHRpbmcpIHtcclxuICAgIGNvbnN0IHJlc29sdmVkID0geyAuLi5mb3JtYXR0aW5nIH07XHJcblxyXG4gICAgLy8gREVCVUc6IENoZWNrIGlmIGZvcm1hdHRpbmcgaXMgYmVpbmcgYXBwbGllZCAoZ2VuZXJpYyBjaGVjaylcclxuICAgIGNvbnN0IGhhc0FueUZvcm1hdHRpbmcgPVxyXG4gICAgICBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlIHx8XHJcbiAgICAgIGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgfHxcclxuICAgICAgZm9ybWF0dGluZy5mb250U3R5bGUgfHxcclxuICAgICAgZm9ybWF0dGluZy5mb250UmVmZXJlbmNlIHx8XHJcbiAgICAgIGZvcm1hdHRpbmcuZm9udFNpemU7XHJcblxyXG4gICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgY29uc29sZS5sb2coXCLwn5SnIFN0eWxlUGFyc2VyLnJlc29sdmVTdHlsZUZvcm1hdHRpbmcgLSBJbnB1dDpcIiwge1xyXG4gICAgICAgIHBhcmFncmFwaFN0eWxlOiBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlLFxyXG4gICAgICAgIGNoYXJhY3RlclN0eWxlOiBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlLFxyXG4gICAgICAgIGRpcmVjdEZvbnRTdHlsZTogZm9ybWF0dGluZy5mb250U3R5bGUsXHJcbiAgICAgICAgZGlyZWN0Rm9udFJlZjogZm9ybWF0dGluZy5mb250UmVmZXJlbmNlLFxyXG4gICAgICAgIGRpcmVjdEZvbnRTaXplOiBmb3JtYXR0aW5nLmZvbnRTaXplLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNvbHZlIHBhcmFncmFwaCBzdHlsZSAoYmFzZSBsYXllcilcclxuICAgIGlmIChcclxuICAgICAgZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSAmJlxyXG4gICAgICB0aGlzLnN0eWxlcy5wYXJhZ3JhcGhbZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZV1cclxuICAgICkge1xyXG4gICAgICBjb25zdCBwU3R5bGUgPSB0aGlzLnN0eWxlcy5wYXJhZ3JhcGhbZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZV07XHJcblxyXG4gICAgICBpZiAoIXJlc29sdmVkLmZvbnRTaXplICYmIHBTdHlsZS5wb2ludFNpemUpXHJcbiAgICAgICAgcmVzb2x2ZWQuZm9udFNpemUgPSBwU3R5bGUucG9pbnRTaXplO1xyXG4gICAgICBpZiAoIXJlc29sdmVkLmZpbGxDb2xvciAmJiBwU3R5bGUuZmlsbENvbG9yKVxyXG4gICAgICAgIHJlc29sdmVkLmZpbGxDb2xvciA9IHBTdHlsZS5maWxsQ29sb3I7XHJcbiAgICAgIC8vIENSSVRJQ0FMIEZJWDogQWx3YXlzIGluaGVyaXQgcGFyYWdyYXBoIGFsaWdubWVudCB1bmxlc3MgZXhwbGljaXRseSBvdmVycmlkZGVuXHJcbiAgICAgIGlmIChwU3R5bGUuYWxpZ25tZW50KSByZXNvbHZlZC5hbGlnbm1lbnQgPSBwU3R5bGUuYWxpZ25tZW50O1xyXG4gICAgICBpZiAoIXJlc29sdmVkLmZvbnRTdHlsZSAmJiBwU3R5bGUuZm9udFN0eWxlKSB7XHJcbiAgICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gcFN0eWxlLmZvbnRTdHlsZTtcclxuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGAgICBGb250U3R5bGUgZnJvbSBwYXJhZ3JhcGggc3R5bGU6IFwiJHtwU3R5bGUuZm9udFN0eWxlfVwiYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENSSVRJQ0FMOiBSZXNvbHZlIGZvbnQgZnJvbSBwYXJhZ3JhcGggc3R5bGVcclxuICAgICAgaWYgKCFyZXNvbHZlZC5mb250RmFtaWx5ICYmIHBTdHlsZS5hcHBsaWVkRm9udCkge1xyXG4gICAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLnJlc29sdmVGb250UmVmZXJlbmNlKHBTdHlsZS5hcHBsaWVkRm9udCk7XHJcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgICAgRm9udCBmcm9tIHBhcmFncmFwaCBzdHlsZTogJHtwU3R5bGUuYXBwbGllZEZvbnR9IC0+ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIG90aGVyIHBhcmFncmFwaCBwcm9wZXJ0aWVzIHdpdGggZW5oYW5jZWQgbGVhZGluZyBzdXBwb3J0XHJcbiAgICAgIHJlc29sdmVkLmxlYWRpbmcgPSBwU3R5bGUubGVhZGluZztcclxuICAgICAgcmVzb2x2ZWQubGVhZGluZ1R5cGUgPSBwU3R5bGUubGVhZGluZ1R5cGU7XHJcbiAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSBwU3R5bGUuZWZmZWN0aXZlTGluZUhlaWdodDtcclxuICAgICAgcmVzb2x2ZWQubGVmdEluZGVudCA9IHBTdHlsZS5sZWZ0SW5kZW50O1xyXG4gICAgICByZXNvbHZlZC5yaWdodEluZGVudCA9IHBTdHlsZS5yaWdodEluZGVudDtcclxuICAgICAgcmVzb2x2ZWQuZmlyc3RMaW5lSW5kZW50ID0gcFN0eWxlLmZpcnN0TGluZUluZGVudDtcclxuICAgICAgcmVzb2x2ZWQuc3BhY2VCZWZvcmUgPSBwU3R5bGUuc3BhY2VCZWZvcmU7XHJcbiAgICAgIHJlc29sdmVkLnNwYWNlQWZ0ZXIgPSBwU3R5bGUuc3BhY2VBZnRlcjtcclxuICAgICAgcmVzb2x2ZWQudHJhY2tpbmcgPSBwU3R5bGUudHJhY2tpbmc7XHJcbiAgICAgIHJlc29sdmVkLmtlcm5pbmcgPSBwU3R5bGUua2VybmluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNvbHZlIGNoYXJhY3RlciBzdHlsZSAob3ZlcnJpZGUgbGF5ZXIpXHJcbiAgICBpZiAoXHJcbiAgICAgIGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgJiZcclxuICAgICAgdGhpcy5zdHlsZXMuY2hhcmFjdGVyW2Zvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVdXHJcbiAgICApIHtcclxuICAgICAgY29uc3QgY1N0eWxlID0gdGhpcy5zdHlsZXMuY2hhcmFjdGVyW2Zvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVdO1xyXG5cclxuICAgICAgaWYgKGNTdHlsZS5wb2ludFNpemUpIHJlc29sdmVkLmZvbnRTaXplID0gY1N0eWxlLnBvaW50U2l6ZTtcclxuICAgICAgaWYgKGNTdHlsZS5maWxsQ29sb3IpIHJlc29sdmVkLmZpbGxDb2xvciA9IGNTdHlsZS5maWxsQ29sb3I7XHJcbiAgICAgIGlmIChjU3R5bGUuZm9udFN0eWxlKSB7XHJcbiAgICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gY1N0eWxlLmZvbnRTdHlsZTtcclxuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGAgICBGb250U3R5bGUgZnJvbSBjaGFyYWN0ZXIgc3R5bGU6IFwiJHtjU3R5bGUuZm9udFN0eWxlfVwiYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNTdHlsZS5zdHJva2VDb2xvcikgcmVzb2x2ZWQuc3Ryb2tlQ29sb3IgPSBjU3R5bGUuc3Ryb2tlQ29sb3I7XHJcblxyXG4gICAgICAvLyBJbmNsdWRlIGxlYWRpbmcgaW5mb3JtYXRpb24gZnJvbSBjaGFyYWN0ZXIgc3R5bGVcclxuICAgICAgaWYgKGNTdHlsZS5sZWFkaW5nKSByZXNvbHZlZC5sZWFkaW5nID0gY1N0eWxlLmxlYWRpbmc7XHJcbiAgICAgIGlmIChjU3R5bGUubGVhZGluZ1R5cGUpIHJlc29sdmVkLmxlYWRpbmdUeXBlID0gY1N0eWxlLmxlYWRpbmdUeXBlO1xyXG4gICAgICBpZiAoY1N0eWxlLmVmZmVjdGl2ZUxpbmVIZWlnaHQpXHJcbiAgICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IGNTdHlsZS5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xyXG5cclxuICAgICAgLy8gQ1JJVElDQUw6IENoYXJhY3RlciBzdHlsZSBmb250IG92ZXJyaWRlcyBwYXJhZ3JhcGggc3R5bGVcclxuICAgICAgaWYgKGNTdHlsZS5hcHBsaWVkRm9udCkge1xyXG4gICAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLnJlc29sdmVGb250UmVmZXJlbmNlKGNTdHlsZS5hcHBsaWVkRm9udCk7XHJcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgICAgRm9udCBmcm9tIGNoYXJhY3RlciBzdHlsZTogJHtjU3R5bGUuYXBwbGllZEZvbnR9IC0+ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFwcGx5IGRpcmVjdCBmb3JtYXR0aW5nIChoaWdoZXN0IHByaW9yaXR5KVxyXG4gICAgaWYgKGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSkge1xyXG4gICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UpO1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgIEZvbnQgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogJHtmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2V9IC0+ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENSSVRJQ0FMOiBBcHBseSBkaXJlY3QgZm9udFN0eWxlIGlmIHByb3ZpZGVkICh0aGlzIG1pZ2h0IGJlIHRoZSBpc3N1ZSlcclxuICAgIGlmIChmb3JtYXR0aW5nLmZvbnRTdHlsZSkge1xyXG4gICAgICByZXNvbHZlZC5mb250U3R5bGUgPSBmb3JtYXR0aW5nLmZvbnRTdHlsZTtcclxuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGAgICBGb250U3R5bGUgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogXCIke2Zvcm1hdHRpbmcuZm9udFN0eWxlfVwiYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBseSBkaXJlY3QgbGVhZGluZyBpbmZvcm1hdGlvbiAoaGlnaGVzdCBwcmlvcml0eSlcclxuICAgIGlmIChmb3JtYXR0aW5nLmxlYWRpbmcgIT09IHVuZGVmaW5lZCkgcmVzb2x2ZWQubGVhZGluZyA9IGZvcm1hdHRpbmcubGVhZGluZztcclxuICAgIGlmIChmb3JtYXR0aW5nLmxlYWRpbmdUeXBlKSByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IGZvcm1hdHRpbmcubGVhZGluZ1R5cGU7XHJcbiAgICBpZiAoZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0KVxyXG4gICAgICByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xyXG5cclxuICAgIC8vIEFwcGx5IG90aGVyIGRpcmVjdCBmb3JtYXR0aW5nIGF0dHJpYnV0ZXNcclxuICAgIGlmIChmb3JtYXR0aW5nLmZvbnRTaXplKSByZXNvbHZlZC5mb250U2l6ZSA9IGZvcm1hdHRpbmcuZm9udFNpemU7XHJcbiAgICBpZiAoZm9ybWF0dGluZy50cmFja2luZykgcmVzb2x2ZWQudHJhY2tpbmcgPSBmb3JtYXR0aW5nLnRyYWNraW5nO1xyXG4gICAgaWYgKGZvcm1hdHRpbmcua2VybmluZykgcmVzb2x2ZWQua2VybmluZyA9IGZvcm1hdHRpbmcua2VybmluZztcclxuXHJcbiAgICAvLyBDUklUSUNBTCBGSVg6IEFwcGx5IGRpcmVjdCBhbGlnbm1lbnQgaWYgZXhwbGljaXRseSBzcGVjaWZpZWQgKG92ZXJyaWRlcyBwYXJhZ3JhcGggYWxpZ25tZW50KVxyXG4gICAgaWYgKGZvcm1hdHRpbmcuYWxpZ25tZW50KSB7XHJcbiAgICAgIHJlc29sdmVkLmFsaWdubWVudCA9IGZvcm1hdHRpbmcuYWxpZ25tZW50O1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgIEFsaWdubWVudCBmcm9tIGRpcmVjdCBmb3JtYXR0aW5nOiBcIiR7Zm9ybWF0dGluZy5hbGlnbm1lbnR9XCJgXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZJWEVEOiBFbnN1cmUgZm9udFN0eWxlIGRlZmF1bHRzIHRvIFJlZ3VsYXIvbm9ybWFsIGlmIG5vdCBzZXRcclxuICAgIGlmICghcmVzb2x2ZWQuZm9udFN0eWxlIHx8IHJlc29sdmVkLmZvbnRTdHlsZSA9PT0gXCJcIikge1xyXG4gICAgICByZXNvbHZlZC5mb250U3R5bGUgPSBcIlJlZ3VsYXJcIjtcclxuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgICAgRm9udFN0eWxlIGRlZmF1bHRlZCB0bzogXCJSZWd1bGFyXCJgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFERElUSU9OQUwgRklYOiBJZiBubyBzdHlsZXMgd2VyZSBhcHBsaWVkIGZyb20gYW55IHNvdXJjZSwgZW5zdXJlIGNsZWFuIGRlZmF1bHRzXHJcbiAgICBpZiAoXHJcbiAgICAgICFmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlICYmXHJcbiAgICAgICFmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlICYmXHJcbiAgICAgICFmb3JtYXR0aW5nLmZvbnRTdHlsZSAmJlxyXG4gICAgICAhZm9ybWF0dGluZy5mb250UmVmZXJlbmNlXHJcbiAgICApIHtcclxuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gXCJSZWd1bGFyXCI7XHJcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAgIE5vIHNvdXJjZSBzdHlsZXMgZm91bmQgLSBlbnN1cmluZyBjbGVhbiBkZWZhdWx0c2ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmluYWwgZmFsbGJhY2tcclxuICAgIGlmICghcmVzb2x2ZWQuZm9udEZhbWlseSB8fCByZXNvbHZlZC5mb250RmFtaWx5ID09PSBcIlwiKSB7XHJcbiAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLmdldERlZmF1bHRGb250KCk7XHJcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAgIFVzaW5nIGZhbGxiYWNrIGZvbnQ6ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEVuc3VyZSBsaW5lIGhlaWdodCBpcyBjYWxjdWxhdGVkIGlmIG5vdCBleHBsaWNpdGx5IHNldFxyXG4gICAgaWYgKFxyXG4gICAgICAhcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCAmJlxyXG4gICAgICByZXNvbHZlZC5mb250U2l6ZSAmJlxyXG4gICAgICByZXNvbHZlZC5sZWFkaW5nXHJcbiAgICApIHtcclxuICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IHRoaXMuY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChcclxuICAgICAgICByZXNvbHZlZC5sZWFkaW5nLFxyXG4gICAgICAgIHJlc29sdmVkLmZvbnRTaXplXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgY29uc29sZS5sb2coXCLwn5SnIFN0eWxlUGFyc2VyLnJlc29sdmVTdHlsZUZvcm1hdHRpbmcgLSBGaW5hbCBPdXRwdXQ6XCIsIHtcclxuICAgICAgICBmb250U2l6ZTogcmVzb2x2ZWQuZm9udFNpemUsXHJcbiAgICAgICAgZm9udEZhbWlseTogcmVzb2x2ZWQuZm9udEZhbWlseSxcclxuICAgICAgICBmb250U3R5bGU6IHJlc29sdmVkLmZvbnRTdHlsZSxcclxuICAgICAgICBmaWxsQ29sb3I6IHJlc29sdmVkLmZpbGxDb2xvcixcclxuICAgICAgICBsZWFkaW5nOiByZXNvbHZlZC5sZWFkaW5nLFxyXG4gICAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNvbHZlZDtcclxuICB9XHJcblxyXG4gIHJlc29sdmVGb250UmVmZXJlbmNlKGZvbnRSZWYpIHtcclxuICAgIGlmICghZm9udFJlZiB8fCBmb250UmVmID09PSBcIlwiKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRW1wdHkgZm9udCByZWZlcmVuY2UsIHVzaW5nIGZhbGxiYWNrXCIpO1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0Rm9udCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSBkaXJlY3QgbG9va3VwIGluIGZvbnQgbWFwXHJcbiAgICBpZiAodGhpcy5mb250TWFwICYmIHRoaXMuZm9udE1hcC5oYXMoZm9udFJlZikpIHtcclxuICAgICAgY29uc3QgcmVzb2x2ZWRGb250ID0gdGhpcy5mb250TWFwLmdldChmb250UmVmKTtcclxuICAgICAgY29uc29sZS5sb2coYEZvbnQgcmVzb2x2ZWQ6IFwiJHtmb250UmVmfVwiIC0+IFwiJHtyZXNvbHZlZEZvbnR9XCJgKTtcclxuICAgICAgcmV0dXJuIHJlc29sdmVkRm9udDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgcGFydGlhbCBtYXRjaGluZyBmb3IgZm9udCBmYW1pbGllc1xyXG4gICAgaWYgKHRoaXMucmVzb3VyY2VzLmZvbnRzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW2ZhbWlseUlkLCBmYW1pbHlJbmZvXSBvZiBPYmplY3QuZW50cmllcyhcclxuICAgICAgICB0aGlzLnJlc291cmNlcy5mb250c1xyXG4gICAgICApKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgZmFtaWx5IG5hbWUgbWF0Y2hcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBmYW1pbHlJbmZvLm5hbWUgJiZcclxuICAgICAgICAgIChmYW1pbHlJbmZvLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmb250UmVmLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgIGZvbnRSZWYudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmYW1pbHlJbmZvLm5hbWUudG9Mb3dlckNhc2UoKSkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYEZvbnQgcGFydGlhbGx5IG1hdGNoZWQ6IFwiJHtmb250UmVmfVwiIC0+IFwiJHtmYW1pbHlJbmZvLm5hbWV9XCJgXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbWlseUluZm8ubmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGluZGl2aWR1YWwgZm9udCBtYXRjaGVzXHJcbiAgICAgICAgaWYgKGZhbWlseUluZm8uZm9udHMpIHtcclxuICAgICAgICAgIGZvciAoY29uc3QgZm9udCBvZiBmYW1pbHlJbmZvLmZvbnRzKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICBmb250LnNlbGYgPT09IGZvbnRSZWYgfHxcclxuICAgICAgICAgICAgICBmb250LnBvc3RTY3JpcHROYW1lID09PSBmb250UmVmIHx8XHJcbiAgICAgICAgICAgICAgZm9udC5uYW1lID09PSBmb250UmVmXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICAgYEZvbnQgZXhhY3RseSBtYXRjaGVkOiBcIiR7Zm9udFJlZn1cIiAtPiBcIiR7ZmFtaWx5SW5mby5uYW1lfVwiYFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbWlseUluZm8ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBGb250IG5vdCBmb3VuZDogXCIke2ZvbnRSZWZ9XCIsIHVzaW5nIGZhbGxiYWNrYCk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0Rm9udCgpIHx8IGZvbnRSZWY7XHJcbiAgfVxyXG5cclxuICBnZXREZWZhdWx0Rm9udCgpIHtcclxuICAgIGlmICh0aGlzLnJlc291cmNlcy5mb250cyAmJiBPYmplY3Qua2V5cyh0aGlzLnJlc291cmNlcy5mb250cykubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaXJzdEZhbWlseSA9IE9iamVjdC52YWx1ZXModGhpcy5yZXNvdXJjZXMuZm9udHMpWzBdO1xyXG4gICAgICByZXR1cm4gZmlyc3RGYW1pbHkubmFtZSB8fCBcIkFyaWFsXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJBcmlhbFwiO1xyXG4gIH1cclxuXHJcbiAgaW5mZXJGb250RnJvbUNvbnRleHQoKSB7XHJcbiAgICAvLyBJZiB3ZSBoYXZlIGZvbnQgZGVmaW5pdGlvbnMgYnV0IG5vIGV4cGxpY2l0IHJlZmVyZW5jZXMsXHJcbiAgICAvLyByZXR1cm4gdGhlIGZpcnN0IGF2YWlsYWJsZSBmb250IGFzIGEgZmFsbGJhY2tcclxuICAgIGlmICh0aGlzLnJlc291cmNlcy5mb250cyAmJiBPYmplY3Qua2V5cyh0aGlzLnJlc291cmNlcy5mb250cykubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaXJzdEZvbnRGYW1pbHkgPSBPYmplY3QudmFsdWVzKHRoaXMucmVzb3VyY2VzLmZvbnRzKVswXTtcclxuICAgICAgcmV0dXJuIGZpcnN0Rm9udEZhbWlseS5uYW1lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yeVN0eWxlU3VtbWFyeShzdG9yeSkge1xyXG4gICAgY29uc3Qgc3VtbWFyeSA9IHtcclxuICAgICAgZm9udFNpemU6IG51bGwsXHJcbiAgICAgIGZvbnRGYW1pbHk6IG51bGwsXHJcbiAgICAgIGFsaWdubWVudDogbnVsbCxcclxuICAgICAgZmlsbENvbG9yOiBudWxsLFxyXG4gICAgICBmb250U3R5bGU6IG51bGwsXHJcbiAgICAgIGxlYWRpbmc6IG51bGwsXHJcbiAgICAgIGxlYWRpbmdUeXBlOiBudWxsLFxyXG4gICAgICBlZmZlY3RpdmVMaW5lSGVpZ2h0OiBudWxsLFxyXG4gICAgICB0cmFja2luZzogbnVsbCxcclxuICAgICAga2VybmluZzogbnVsbCxcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2V0IHRoZSBtb3N0IGNvbW1vbiBvciBmaXJzdCBmb3JtYXR0aW5nIHZhbHVlc1xyXG4gICAgaWYgKHN0b3J5LmNvbnRlbnQ/LmZvcm1hdHRlZENvbnRlbnQ/Lmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgZmlyc3RGb3JtYXR0ZWQgPSBzdG9yeS5jb250ZW50LmZvcm1hdHRlZENvbnRlbnQuZmluZChcclxuICAgICAgICAoaXRlbSkgPT4gaXRlbS5mb3JtYXR0aW5nICYmICFpdGVtLmZvcm1hdHRpbmcuaXNCcmVha1xyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGZpcnN0Rm9ybWF0dGVkPy5mb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc3QgZm10ID0gZmlyc3RGb3JtYXR0ZWQuZm9ybWF0dGluZztcclxuICAgICAgICBzdW1tYXJ5LmZvbnRTaXplID0gZm10LmZvbnRTaXplO1xyXG4gICAgICAgIHN1bW1hcnkuZm9udEZhbWlseSA9IGZtdC5mb250RmFtaWx5O1xyXG4gICAgICAgIHN1bW1hcnkuYWxpZ25tZW50ID0gZm10LmFsaWdubWVudDtcclxuICAgICAgICBzdW1tYXJ5LmZpbGxDb2xvciA9IGZtdC5maWxsQ29sb3I7XHJcbiAgICAgICAgc3VtbWFyeS5mb250U3R5bGUgPSBmbXQuZm9udFN0eWxlO1xyXG4gICAgICAgIHN1bW1hcnkubGVhZGluZyA9IGZtdC5sZWFkaW5nO1xyXG4gICAgICAgIHN1bW1hcnkubGVhZGluZ1R5cGUgPSBmbXQubGVhZGluZ1R5cGU7XHJcbiAgICAgICAgc3VtbWFyeS5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gZm10LmVmZmVjdGl2ZUxpbmVIZWlnaHQ7XHJcbiAgICAgICAgc3VtbWFyeS50cmFja2luZyA9IGZtdC50cmFja2luZztcclxuICAgICAgICBzdW1tYXJ5Lmtlcm5pbmcgPSBmbXQua2VybmluZztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdW1tYXJ5O1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBQcm9jZXNzIGxlYWRpbmcgdmFsdWVzIHdpdGggSW5EZXNpZ24tc3BlY2lmaWMgbG9naWMgKHNoYXJlZCB3aXRoIFN0b3J5UGFyc2VyKVxyXG4gIHByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9udFNpemUpIHtcclxuICAgIGlmICghcmF3TGVhZGluZykgcmV0dXJuIFwiYXV0b1wiO1xyXG5cclxuICAgIC8vIEhhbmRsZSBcImF1dG9cIiBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZyA9PT0gXCJhdXRvXCIgfHwgcmF3TGVhZGluZyA9PT0gXCJBdXRvXCIpIHtcclxuICAgICAgcmV0dXJuIGZvbnRTaXplID8gZm9udFNpemUgKiAxLjIgOiBcImF1dG9cIjsgLy8gSW5EZXNpZ24gZGVmYXVsdCBhdXRvIGxlYWRpbmcgaXMgMTIwJVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZSBudW1lcmljIGxlYWRpbmcgKGluIHBvaW50cylcclxuICAgIGNvbnN0IG51bWVyaWNMZWFkaW5nID0gcGFyc2VGbG9hdChyYXdMZWFkaW5nKTtcclxuICAgIGlmICghaXNOYU4obnVtZXJpY0xlYWRpbmcpKSB7XHJcbiAgICAgIHJldHVybiBudW1lcmljTGVhZGluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgcGVyY2VudGFnZS1iYXNlZCBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcyhcIiVcIikpIHtcclxuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQocmF3TGVhZGluZy5yZXBsYWNlKFwiJVwiLCBcIlwiKSk7XHJcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IChmb250U2l6ZSAqIHBlcmNlbnRhZ2UpIC8gMTAwIDogXCJhdXRvXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFwiYXV0b1wiO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgbGVhZGluZyBiZWluZyB1c2VkXHJcbiAgZGV0ZXJtaW5lTGVhZGluZ1R5cGUocmF3TGVhZGluZykge1xyXG4gICAgaWYgKCFyYXdMZWFkaW5nIHx8IHJhd0xlYWRpbmcgPT09IFwiYXV0b1wiIHx8IHJhd0xlYWRpbmcgPT09IFwiQXV0b1wiKSB7XHJcbiAgICAgIHJldHVybiBcImF1dG9cIjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcyhcIiVcIikpIHtcclxuICAgICAgcmV0dXJuIFwicGVyY2VudGFnZVwiO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdChyYXdMZWFkaW5nKSkpIHtcclxuICAgICAgcmV0dXJuIFwiYWJzb2x1dGVcIjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IENhbGN1bGF0ZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgZm9yIENTUyByZW5kZXJpbmdcclxuICBjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KGxlYWRpbmcsIGZvbnRTaXplKSB7XHJcbiAgICBpZiAobGVhZGluZyA9PT0gXCJhdXRvXCIpIHtcclxuICAgICAgcmV0dXJuIDEuMjsgLy8gQ1NTIGxpbmUtaGVpZ2h0IHJhdGlvIGZvciBhdXRvXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBsZWFkaW5nID09PSBcIm51bWJlclwiICYmIGZvbnRTaXplKSB7XHJcbiAgICAgIC8vIENvbnZlcnQgcG9pbnRzIHRvIENTUyBsaW5lLWhlaWdodCByYXRpb1xyXG4gICAgICByZXR1cm4gTWF0aC5tYXgoMC44LCBsZWFkaW5nIC8gZm9udFNpemUpOyAvLyBFbnN1cmUgbWluaW11bSBsaW5lIGhlaWdodFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAxLjI7IC8vIEZhbGxiYWNrXHJcbiAgfVxyXG5cclxuICBnZXRTdHlsZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZXM7XHJcbiAgfVxyXG5cclxuICBnZXRSZXNvdXJjZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXM7XHJcbiAgfVxyXG5cclxuICBnZXRGb250TWFwKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9udE1hcDtcclxuICB9XHJcblxyXG4gIC8vIEFkZCBtZXRob2RzIHRvIHJldHVybiBzdHlsZSBhbmQgZm9udCBkZWZpbml0aW9ucyBmb3IgZGVidWdcclxuICBnZXRQYXJhZ3JhcGhTdHlsZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZXMucGFyYWdyYXBoO1xyXG4gIH1cclxuICBnZXRDaGFyYWN0ZXJTdHlsZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZXMuY2hhcmFjdGVyO1xyXG4gIH1cclxuICBnZXRGb250RGVmaW5pdGlvbnMoKSB7XHJcbiAgICAvLyBQcmVmZXIgcGxhaW4gb2JqZWN0IGZvciBkZWJ1ZyBvdXRwdXRcclxuICAgIGlmICh0aGlzLnJlc291cmNlcyAmJiB0aGlzLnJlc291cmNlcy5mb250cykge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXMuZm9udHM7XHJcbiAgICB9XHJcbiAgICAvLyBGYWxsYmFjazogY29udmVydCBmb250TWFwIHRvIG9iamVjdFxyXG4gICAgaWYgKHRoaXMuZm9udE1hcCAmJiB0eXBlb2YgdGhpcy5mb250TWFwLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuZm9udE1hcC5lbnRyaWVzKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxuXHJcbiAgLy8gRklYRUQ6IEFkZCBtZXRob2QgdG8gYWNjZXNzIGRvY3VtZW50IHByZWZlcmVuY2VzIGluY2x1ZGluZyBWaWV3UHJlZmVyZW5jZXNcclxuICBnZXREb2N1bWVudEluZm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudEluZm87XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlUGFyc2VyO1xyXG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJJRE1MVXRpbHMiLCJTdHlsZVBhcnNlciIsInNldERvY3VtZW50VW5pdHMiLCJ1bml0cyIsImRvY3VtZW50VW5pdHMiLCJjb25zb2xlIiwibG9nIiwiY29udmVydFR5cG9ncmFwaHlUb1BpeGVscyIsInZhbHVlIiwiaXNOYU4iLCJ1bml0Q29udmVydGVyIiwiaXNTdXBwb3J0ZWRVbml0IiwiY29udmVydGVkVmFsdWUiLCJ0b1BpeGVscyIsImNvbnZlcnRTdHlsZU1lYXN1cmVtZW50c1RvUGl4ZWxzIiwic3R5bGUiLCJjb252ZXJ0ZWRTdHlsZSIsIm1lYXN1cmVtZW50RmllbGRzIiwiZm9yRWFjaCIsImZpZWxkIiwibGVhZGluZyIsInBhcnNlUmVzb3VyY2VGaWxlIiwiZmlsZU5hbWUiLCJjb250ZW50IiwieG1sUGFyc2VyIiwicGFyc2VkIiwicGFyc2UiLCJyZXNvdXJjZU5hbWUiLCJiYXNlbmFtZSIsImluY2x1ZGVzIiwiZXh0cmFjdFN0eWxlcyIsImV4dHJhY3RGb250cyIsImV4dHJhY3RHcmFwaGljcyIsImV4dHJhY3RQcmVmZXJlbmNlcyIsImVycm9yIiwibWVzc2FnZSIsInN0eWxlc0RhdGEiLCJzdHlsZXMiLCJTdHlsZXMiLCJSb290UGFyYWdyYXBoU3R5bGVHcm91cCIsImV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMiLCJSb290Q2hhcmFjdGVyU3R5bGVHcm91cCIsImV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMiLCJzdHlsZUdyb3VwIiwiZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5IiwiZ3JvdXAiLCJQYXJhZ3JhcGhTdHlsZSIsIkFycmF5IiwiaXNBcnJheSIsImZvbnRSZWYiLCJleHRyYWN0Rm9udEZyb21TdHlsZSIsImZvbnRTaXplIiwicGFyc2VGbG9hdCIsInJhd0xlYWRpbmciLCJwcm9jZXNzZWRMZWFkaW5nIiwicHJvY2Vzc0xlYWRpbmdWYWx1ZSIsInJhd0xlZnRJbmRlbnQiLCJyYXdSaWdodEluZGVudCIsInJhd0ZpcnN0TGluZUluZGVudCIsInJhd1NwYWNlQmVmb3JlIiwicmF3U3BhY2VBZnRlciIsInJhd1RyYWNraW5nIiwicmF3S2VybmluZyIsImJhc2VTdHlsZSIsInNlbGYiLCJuYW1lIiwiZm9udFN0eWxlIiwicG9pbnRTaXplIiwibGVhZGluZ1R5cGUiLCJkZXRlcm1pbmVMZWFkaW5nVHlwZSIsImVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0IiwiYWxpZ25tZW50IiwibGVmdEluZGVudCIsInJpZ2h0SW5kZW50IiwiZmlyc3RMaW5lSW5kZW50Iiwic3BhY2VCZWZvcmUiLCJzcGFjZUFmdGVyIiwidHJhY2tpbmciLCJrZXJuaW5nIiwib3JpZ2luYWxMZWZ0SW5kZW50Iiwib3JpZ2luYWxSaWdodEluZGVudCIsIm9yaWdpbmFsRmlyc3RMaW5lSW5kZW50Iiwib3JpZ2luYWxTcGFjZUJlZm9yZSIsIm9yaWdpbmFsU3BhY2VBZnRlciIsIm9yaWdpbmFsVHJhY2tpbmciLCJvcmlnaW5hbEtlcm5pbmciLCJob3Jpem9udGFsU2NhbGUiLCJ2ZXJ0aWNhbFNjYWxlIiwiYXBwbGllZEZvbnQiLCJvcmlnaW5hbEZvbnRSZWYiLCJmaWxsQ29sb3IiLCJyYXdTdHlsZSIsInBhcmFncmFwaCIsIlBhcmFncmFwaFN0eWxlR3JvdXAiLCJzdWJHcm91cHMiLCJQcm9wZXJ0aWVzIiwiQXBwbGllZEZvbnQiLCJGb250RmFtaWx5IiwiQ2hhcmFjdGVyU3R5bGUiLCJjaGFyYWN0ZXIiLCJzdHJva2VDb2xvciIsIkNoYXJhY3RlclN0eWxlR3JvdXAiLCJmb250c0RhdGEiLCJmb250cyIsIkZvbnRzIiwicmVzb3VyY2VzIiwiZm9udE1hcCIsIk1hcCIsImZvbnRGYW1pbGllcyIsImZhbWlseSIsImZhbWlseUluZm8iLCJGb250IiwiZm9udExpc3QiLCJmb250IiwiZm9udEluZm8iLCJmb250RmFtaWx5IiwicG9zdFNjcmlwdE5hbWUiLCJzdGF0dXMiLCJmb250U3R5bGVOYW1lIiwicHVzaCIsInNldCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzaXplIiwiZ3JhcGhpY3NEYXRhIiwiZ3JhcGhpY3MiLCJHcmFwaGljIiwiY29sb3JzIiwiZ3JhZGllbnRzIiwiQ29sb3IiLCJjb2xvciIsImN5YW4iLCJtYWdlbnRhIiwieWVsbG93IiwiYmxhY2siLCJyZWQiLCJncmVlbiIsImJsdWUiLCJmYWxsYmFja1JHQiIsInJnYlBhcnRzIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJldmVyeSIsInYiLCJtb2RlbCIsInNwYWNlIiwiR3JhZGllbnQiLCJncmFkaWVudCIsInR5cGUiLCJncmFkaWVudFN0b3BzIiwiZXh0cmFjdEdyYWRpZW50U3RvcHMiLCJzdG9wcyIsIkdyYWRpZW50U3RvcCIsInN0b3BMaXN0Iiwic3RvcCIsInN0b3BDb2xvciIsImxvY2F0aW9uIiwibWlkcG9pbnQiLCJwcmVmZXJlbmNlc0RhdGEiLCJwcmVmcyIsIlByZWZlcmVuY2VzIiwiZG9jdW1lbnRJbmZvIiwicHJlZmVyZW5jZXMiLCJkb2N1bWVudFByZWZlcmVuY2VzIiwiZXh0cmFjdERvY3VtZW50UHJlZnMiLCJEb2N1bWVudFByZWZlcmVuY2UiLCJ2aWV3UHJlZmVyZW5jZXMiLCJleHRyYWN0Vmlld1ByZWZzIiwiVmlld1ByZWZlcmVuY2UiLCJndWlkZVByZWZlcmVuY2VzIiwiZXh0cmFjdEd1aWRlUHJlZnMiLCJHdWlkZVByZWZlcmVuY2UiLCJncmlkUHJlZmVyZW5jZXMiLCJleHRyYWN0R3JpZFByZWZzIiwiR3JpZFByZWZlcmVuY2UiLCJtYXJnaW5QcmVmZXJlbmNlcyIsImV4dHJhY3RNYXJnaW5QcmVmcyIsIk1hcmdpblByZWZlcmVuY2UiLCJjb2x1bW5QcmVmZXJlbmNlcyIsImV4dHJhY3RDb2x1bW5QcmVmcyIsIkNvbHVtblByZWZlcmVuY2UiLCJkb2NQcmVmIiwicGFnZVdpZHRoIiwicGFnZUhlaWdodCIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbHVtbkNvdW50IiwicGFyc2VJbnQiLCJjb2x1bW5HdXR0ZXIiLCJmYWNpbmdQYWdlcyIsImFsbG93UGFnZVNodWZmbGUiLCJzbHVnQmxlZWRUeXBlIiwiZG9jdW1lbnRCbGVlZFRvcE9mZnNldCIsImRvY3VtZW50QmxlZWRCb3R0b21PZmZzZXQiLCJkb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0IiwiZG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0Iiwidmlld1ByZWYiLCJob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cyIsInZlcnRpY2FsTWVhc3VyZW1lbnRVbml0cyIsInJ1bGVyT3JpZ2luIiwic2hvd1J1bGVycyIsImd1aWRlUHJlZiIsInJ1bGVyR3VpZGVDb2xvciIsImd1aWRlc0luQmFjayIsImd1aWRlc0xvY2tlZCIsImd1aWRlc1Nob3duIiwiZ3VpZGVzU25hcHRvIiwiZ3JpZFByZWYiLCJiYXNlbGluZVN0YXJ0IiwiYmFzZWxpbmVEaXZpc2lvbiIsImJhc2VsaW5lU2hvd24iLCJiYXNlbGluZVNuYXB0byIsImRvY3VtZW50R3JpZFNob3duIiwiZG9jdW1lbnRHcmlkU25hcHRvIiwibWFyZ2luUHJlZiIsImNvbHVtblByZWYiLCJ0ZXh0Q29sdW1uQ291bnQiLCJ0ZXh0Q29sdW1uR3V0dGVyIiwicmVzb2x2ZVN0eWxlRm9ybWF0dGluZyIsImZvcm1hdHRpbmciLCJyZXNvbHZlZCIsImhhc0FueUZvcm1hdHRpbmciLCJwYXJhZ3JhcGhTdHlsZSIsImNoYXJhY3RlclN0eWxlIiwiZm9udFJlZmVyZW5jZSIsImRpcmVjdEZvbnRTdHlsZSIsImRpcmVjdEZvbnRSZWYiLCJkaXJlY3RGb250U2l6ZSIsInBTdHlsZSIsInJlc29sdmVGb250UmVmZXJlbmNlIiwiY1N0eWxlIiwidW5kZWZpbmVkIiwiZ2V0RGVmYXVsdEZvbnQiLCJoYXMiLCJyZXNvbHZlZEZvbnQiLCJnZXQiLCJmYW1pbHlJZCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsImZpcnN0RmFtaWx5IiwidmFsdWVzIiwiaW5mZXJGb250RnJvbUNvbnRleHQiLCJmaXJzdEZvbnRGYW1pbHkiLCJnZXRTdG9yeVN0eWxlU3VtbWFyeSIsInN0b3J5Iiwic3VtbWFyeSIsImZvcm1hdHRlZENvbnRlbnQiLCJmaXJzdEZvcm1hdHRlZCIsImZpbmQiLCJpdGVtIiwiaXNCcmVhayIsImZtdCIsIm51bWVyaWNMZWFkaW5nIiwicGVyY2VudGFnZSIsInJlcGxhY2UiLCJNYXRoIiwibWF4IiwiZ2V0U3R5bGVzIiwiZ2V0UmVzb3VyY2VzIiwiZ2V0Rm9udE1hcCIsImdldFBhcmFncmFwaFN0eWxlcyIsImdldENoYXJhY3RlclN0eWxlcyIsImdldEZvbnREZWZpbml0aW9ucyIsImZyb21FbnRyaWVzIiwiZ2V0RG9jdW1lbnRJbmZvIiwiY29uc3RydWN0b3IiLCJvYmplY3QiLCJ0YWJsZSIsImNlbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/parsers/StyleParser.js\n"));

/***/ })

});