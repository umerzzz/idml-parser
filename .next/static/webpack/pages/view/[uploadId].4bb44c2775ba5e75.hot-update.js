"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/ElementParser.js":
/*!**************************************!*\
  !*** ./lib/parsers/ElementParser.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass ElementParser {\n    extractSpreadPages(spreadData) {\n        const pages = [];\n        if (spreadData.Page) {\n            const pageList = Array.isArray(spreadData.Page) ? spreadData.Page : [\n                spreadData.Page\n            ];\n            pageList.forEach((page, index)=>{\n                pages.push({\n                    self: page[\"@_Self\"],\n                    name: page[\"@_Name\"] || \"\",\n                    appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                    geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                    itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"])\n                });\n            });\n        } else {\n            console.log(\"No pages found in spread data\");\n        }\n        console.log(\"Extracted \".concat(pages.length, \" pages\"));\n        return pages;\n    }\n    extractPageItems(spreadData) {\n        const pageItems = [];\n        // Extract different types of page items\n        const itemTypes = [\n            \"Rectangle\",\n            \"Oval\",\n            \"Polygon\",\n            \"GraphicLine\",\n            \"TextFrame\",\n            \"Group\",\n            \"Button\",\n            \"Table\",\n            \"Image\",\n            \"EPS\",\n            \"PDF\",\n            \"PlacedItem\",\n            \"ContentFrame\" // Add these\n        ];\n        itemTypes.forEach((itemType)=>{\n            if (spreadData[itemType]) {\n                const items = Array.isArray(spreadData[itemType]) ? spreadData[itemType] : [\n                    spreadData[itemType]\n                ];\n                items.forEach((item)=>{\n                    console.log(\"Processing \".concat(itemType, \":\"), item[\"@_Self\"]);\n                    const pageItem = this.parsePageItem(item, itemType);\n                    if (pageItem) {\n                        pageItems.push(pageItem);\n                        this.elements.push(pageItem);\n                    }\n                });\n            }\n        });\n        this.checkForNestedContent(spreadData, pageItems);\n        // ALSO CHECK FOR NESTED ITEMS IN PAGES\n        if (spreadData.Page) {\n            const pages = Array.isArray(spreadData.Page) ? spreadData.Page : [\n                spreadData.Page\n            ];\n            pages.forEach((page)=>{\n                itemTypes.forEach((itemType)=>{\n                    if (page[itemType]) {\n                        console.log(\"Found \".concat(itemType, \" in page:\"), Array.isArray(page[itemType]) ? page[itemType].length : 1);\n                        const items = Array.isArray(page[itemType]) ? page[itemType] : [\n                            page[itemType]\n                        ];\n                        items.forEach((item)=>{\n                            const pageItem = this.parsePageItem(item, itemType);\n                            if (pageItem) {\n                                pageItems.push(pageItem);\n                                this.elements.push(pageItem);\n                            }\n                        });\n                    }\n                });\n            });\n        }\n        console.log(\"Total page items extracted: \".concat(pageItems.length));\n        return pageItems;\n    }\n    checkForNestedContent(spreadData, pageItems) {\n        console.log(\"\\uD83D\\uDD0D Checking for nested content in elements...\");\n        // Check rectangles for placed images\n        if (spreadData.Rectangle) {\n            const rectangles = Array.isArray(spreadData.Rectangle) ? spreadData.Rectangle : [\n                spreadData.Rectangle\n            ];\n            rectangles.forEach((rect)=>{\n                var _rect_Properties, _rect_Properties1, _rect_Properties2;\n                // Look for ANY content inside rectangle - be more aggressive\n                const possibleContent = rect.Image || rect.PlacedImage || rect.EPS || rect.PDF || ((_rect_Properties = rect.Properties) === null || _rect_Properties === void 0 ? void 0 : _rect_Properties.Image) || ((_rect_Properties1 = rect.Properties) === null || _rect_Properties1 === void 0 ? void 0 : _rect_Properties1.PlacedImage) || rect.Link || ((_rect_Properties2 = rect.Properties) === null || _rect_Properties2 === void 0 ? void 0 : _rect_Properties2.Link);\n                if (possibleContent) {\n                    console.log(\"\\uD83D\\uDCF7 Found placed content in rectangle \".concat(rect[\"@_Self\"], \":\"), possibleContent);\n                    // Update the rectangle to indicate it's a content frame\n                    const existingRect = pageItems.find((item)=>item.self === rect[\"@_Self\"]);\n                    if (existingRect) {\n                        existingRect.hasPlacedContent = true;\n                        existingRect.contentType = \"Image\";\n                        // Extract placed content details with better handling\n                        existingRect.placedContent = this.extractPlacedContent(possibleContent);\n                        // IMPORTANT: Calculate the image position within the frame\n                        existingRect.imagePosition = IDMLUtils.calculateImagePositionInFrame(existingRect.geometricBounds, existingRect.itemTransform, existingRect.placedContent);\n                    }\n                }\n            });\n        }\n    }\n    extractPlacedContent(content) {\n        if (!content) return null;\n        console.log(\"\\uD83D\\uDD0D Extracting placed content:\", content);\n        const contentItem = Array.isArray(content) ? content[0] : content;\n        console.log(\"Content item keys:\", Object.keys(contentItem));\n        // ENHANCED: Better href handling for embedded images\n        let href = contentItem[\"@_href\"] || contentItem[\"@_ActualPpi\"] || \"\";\n        let isEmbedded = false;\n        // Check if this is an embedded image reference\n        if (href && !href.startsWith(\"file://\") && !href.includes(\"/\")) {\n            // This looks like an embedded image reference\n            isEmbedded = true;\n            console.log(\"\\uD83D\\uDDBC️ Detected embedded image reference:\", href);\n        }\n        return {\n            type: contentItem[\"@_type\"] || \"Image\",\n            href: href,\n            isEmbedded: isEmbedded,\n            bounds: contentItem[\"@_GeometricBounds\"] ? IDMLUtils.parseGeometricBounds(contentItem[\"@_GeometricBounds\"]) : null,\n            transform: contentItem[\"@_ItemTransform\"] ? IDMLUtils.parseTransform(contentItem[\"@_ItemTransform\"]) : null,\n            actualPpi: contentItem[\"@_ActualPpi\"],\n            effectivePpi: contentItem[\"@_EffectivePpi\"],\n            imageTypeName: contentItem[\"@_ImageTypeName\"],\n            space: contentItem[\"@_Space\"]\n        };\n    }\n    parsePageItem(item, itemType) {\n        // ADD: Validation\n        if (!item || !item[\"@_Self\"]) {\n            console.warn(\"Invalid \".concat(itemType, \" item - missing self ID\"));\n            return null;\n        }\n        const baseItem = {\n            type: itemType,\n            self: item[\"@_Self\"],\n            name: item[\"@_Name\"] || \"\",\n            visible: item[\"@_Visible\"] !== false,\n            locked: item[\"@_Locked\"] === true,\n            geometricBounds: IDMLUtils.calculateBoundsFromPath(item),\n            itemTransform: IDMLUtils.parseTransform(item[\"@_ItemTransform\"]),\n            itemLayer: item[\"@_ItemLayer\"] || \"\",\n            fillColor: item[\"@_FillColor\"] || \"Color/None\",\n            strokeColor: item[\"@_StrokeColor\"] || \"Color/None\",\n            strokeWeight: parseFloat(item[\"@_StrokeWeight\"]) || 0,\n            parentStory: item[\"@_ParentStory\"] || null,\n            // ENHANCED: Better content frame detection\n            isContentFrame: false,\n            hasPlacedContent: false,\n            contentType: null\n        };\n        // ADD: Detect content frames more accurately\n        // ENHANCED: Better embedded image detection\n        if (itemType === \"Rectangle\") {\n            var _item_Properties, _item_Properties1;\n            // Check for embedded images more thoroughly\n            const embeddedInfo = this.detectEmbeddedImages(item);\n            if (embeddedInfo.hasEmbeddedContent || embeddedInfo.isPlaceholder) {\n                baseItem.isContentFrame = true;\n                baseItem.hasPlacedContent = embeddedInfo.hasEmbeddedContent;\n                baseItem.contentType = embeddedInfo.embeddedType || \"placeholder\";\n                baseItem.isEmbedded = embeddedInfo.hasEmbeddedContent;\n                baseItem.isPlaceholder = embeddedInfo.isPlaceholder;\n                console.log(\"\\uD83D\\uDCE6 Detected \".concat(embeddedInfo.hasEmbeddedContent ? \"embedded\" : \"placeholder\", \" content frame: \").concat(baseItem.self));\n            }\n            // Existing content frame detection logic...\n            const hasContent = !!(item.Image || item.PlacedImage || item.EPS || item.PDF || ((_item_Properties = item.Properties) === null || _item_Properties === void 0 ? void 0 : _item_Properties.Image) || ((_item_Properties1 = item.Properties) === null || _item_Properties1 === void 0 ? void 0 : _item_Properties1.PlacedImage));\n            if (hasContent && !baseItem.isContentFrame) {\n                baseItem.isContentFrame = true;\n                baseItem.hasPlacedContent = true;\n                baseItem.contentType = \"Image\";\n                // Extract placed content transform for positioning\n                const placedContent = item.Image || item.PlacedImage || item.EPS || item.PDF;\n                if (placedContent) {\n                    baseItem.placedContent = this.extractPlacedContent(placedContent);\n                }\n                console.log(\"\\uD83D\\uDCE6 Detected external content frame: \".concat(baseItem.self));\n            }\n        }\n        // Type-specific processing...\n        switch(itemType){\n            case \"TextFrame\":\n                baseItem.textFramePreferences = this.parseTextFramePreferences(item.TextFramePreference);\n                break;\n            case \"Rectangle\":\n                baseItem.cornerEffects = this.parseCornerEffects(item);\n                break;\n            case \"Group\":\n                baseItem.groupItems = this.extractGroupItems(item);\n                break;\n        }\n        return baseItem;\n    }\n    detectEmbeddedImages(element) {\n        const embeddedIndicators = {\n            hasEmbeddedContent: false,\n            embeddedType: null,\n            embeddedData: null,\n            embeddedFileName: null,\n            isPlaceholder: false\n        };\n        // Check if element name indicates placeholder\n        if (element.name && (element.name.includes(\"[YOUR IMAGE HERE]\") || element.name.includes(\"[IMAGE]\") || element.name.toLowerCase().includes(\"placeholder\"))) {\n            embeddedIndicators.isPlaceholder = true;\n            embeddedIndicators.embeddedType = \"placeholder\";\n        }\n        // ENHANCED: Check for actual embedded image data\n        if (element.placedContent) {\n            const content = element.placedContent;\n            // Check if href looks like an embedded reference\n            if (content.href && content.isEmbedded) {\n                embeddedIndicators.hasEmbeddedContent = true;\n                embeddedIndicators.embeddedType = content.imageTypeName || \"unknown\";\n                embeddedIndicators.embeddedData = content.href;\n                embeddedIndicators.embeddedFileName = \"\".concat(content.href, \".\").concat(IDMLUtils.getImageExtension(content.imageTypeName));\n            }\n        }\n        return embeddedIndicators;\n    }\n    parseTextFramePreferences(textFramePreference) {\n        var _textFramePreference__InsetSpacing, _textFramePreference__InsetSpacing1, _textFramePreference__InsetSpacing2, _textFramePreference__InsetSpacing3;\n        if (!textFramePreference) return null;\n        return {\n            textColumnCount: parseInt(textFramePreference[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(textFramePreference[\"@_TextColumnGutter\"]) || 0,\n            firstBaselineOffset: textFramePreference[\"@_FirstBaselineOffset\"] || \"AscentOffset\",\n            autoSizingReferencePoint: textFramePreference[\"@_AutoSizingReferencePoint\"] || \"CenterPoint\",\n            autoSizingType: textFramePreference[\"@_AutoSizingType\"] || \"Off\",\n            verticalJustification: textFramePreference[\"@_VerticalJustification\"] || \"TopAlign\",\n            // ENHANCED: Extract text frame insets for precise positioning\n            insetSpacing: {\n                top: parseFloat((_textFramePreference__InsetSpacing = textFramePreference[\"@_InsetSpacing\"]) === null || _textFramePreference__InsetSpacing === void 0 ? void 0 : _textFramePreference__InsetSpacing.split(\" \")[0]) || parseFloat(textFramePreference[\"@_TextInsetTop\"]) || 0,\n                right: parseFloat((_textFramePreference__InsetSpacing1 = textFramePreference[\"@_InsetSpacing\"]) === null || _textFramePreference__InsetSpacing1 === void 0 ? void 0 : _textFramePreference__InsetSpacing1.split(\" \")[1]) || parseFloat(textFramePreference[\"@_TextInsetRight\"]) || 0,\n                bottom: parseFloat((_textFramePreference__InsetSpacing2 = textFramePreference[\"@_InsetSpacing\"]) === null || _textFramePreference__InsetSpacing2 === void 0 ? void 0 : _textFramePreference__InsetSpacing2.split(\" \")[2]) || parseFloat(textFramePreference[\"@_TextInsetBottom\"]) || 0,\n                left: parseFloat((_textFramePreference__InsetSpacing3 = textFramePreference[\"@_InsetSpacing\"]) === null || _textFramePreference__InsetSpacing3 === void 0 ? void 0 : _textFramePreference__InsetSpacing3.split(\" \")[3]) || parseFloat(textFramePreference[\"@_TextInsetLeft\"]) || 0\n            },\n            // Additional InDesign-specific properties for precise text layout\n            useMinimumHeight: textFramePreference[\"@_UseMinimumHeight\"] === true,\n            minimumFirstBaselineOffset: parseFloat(textFramePreference[\"@_MinimumFirstBaselineOffset\"]) || 0,\n            ignoreWrap: textFramePreference[\"@_IgnoreWrap\"] === true\n        };\n    }\n    parseCornerEffects(item) {\n        // Parse corner effects for rectangles\n        return {\n            topLeftCornerRadius: parseFloat(item[\"@_TopLeftCornerRadius\"]) || 0,\n            topRightCornerRadius: parseFloat(item[\"@_TopRightCornerRadius\"]) || 0,\n            bottomLeftCornerRadius: parseFloat(item[\"@_BottomLeftCornerRadius\"]) || 0,\n            bottomRightCornerRadius: parseFloat(item[\"@_BottomRightCornerRadius\"]) || 0\n        };\n    }\n    extractGroupItems(groupItem) {\n        const groupItems = [];\n        // Groups can contain other page items\n        const itemTypes = [\n            \"Rectangle\",\n            \"Oval\",\n            \"Polygon\",\n            \"TextFrame\"\n        ];\n        itemTypes.forEach((itemType)=>{\n            if (groupItem[itemType]) {\n                const items = Array.isArray(groupItem[itemType]) ? groupItem[itemType] : [\n                    groupItem[itemType]\n                ];\n                items.forEach((item)=>{\n                    const parsedItem = this.parsePageItem(item, itemType);\n                    if (parsedItem) {\n                        groupItems.push(parsedItem);\n                    }\n                });\n            }\n        });\n        return groupItems;\n    }\n    parseTransparency(transparencySettings) {\n        if (!transparencySettings) return null;\n        return {\n            blendingSettings: transparencySettings.BlendingSetting ? {\n                blendMode: transparencySettings.BlendingSetting[\"@_BlendMode\"] || \"Normal\",\n                opacity: parseFloat(transparencySettings.BlendingSetting[\"@_Opacity\"]) || 100\n            } : null\n        };\n    }\n    createElementPositionMapFixed() {\n        console.log(\"Creating FIXED element position map...\");\n        // Calculate coordinate offset to handle negative coordinates\n        const coordinateOffset = IDMLUtils.calculateCoordinateOffset(this.elements);\n        console.log(\"Coordinate offset:\", coordinateOffset);\n        this.elements.forEach((element, index)=>{\n            const bounds = element.geometricBounds || element.originalBounds;\n            const transform = element.itemTransform || {\n                a: 1,\n                b: 0,\n                c: 0,\n                d: 1,\n                tx: 0,\n                ty: 0\n            };\n            // CORRECT: Apply transform to bounds, then add offset\n            let x = ((bounds === null || bounds === void 0 ? void 0 : bounds.left) || 0) + (transform.tx || 0) + coordinateOffset.x;\n            let y = ((bounds === null || bounds === void 0 ? void 0 : bounds.top) || 0) + (transform.ty || 0) + coordinateOffset.y;\n            // For the textframe with negative Y, apply special handling\n            if (y < 0) {\n                y = Math.abs(y); // Convert negative to positive\n            }\n            let width = Math.abs((bounds === null || bounds === void 0 ? void 0 : bounds.width) || 0);\n            let height = Math.abs((bounds === null || bounds === void 0 ? void 0 : bounds.height) || 0);\n            // DETAILED DEBUGGING: Track the exact coordinate calculation\n            console.log(\"\\uD83D\\uDD0D ELEMENT \".concat(index, \" [\").concat(element.type, \"] COORDINATE CALCULATION:\"));\n            console.log(\"   \\uD83D\\uDCC4 Raw bounds:\", bounds);\n            console.log(\"   \\uD83D\\uDD04 Raw transform:\", transform);\n            console.log(\"   \\uD83D\\uDCD0 Step 1 - bounds.left: \".concat(bounds === null || bounds === void 0 ? void 0 : bounds.left));\n            console.log(\"   \\uD83D\\uDCD0 Step 2 - bounds.top: \".concat(bounds === null || bounds === void 0 ? void 0 : bounds.top));\n            console.log(\"   \\uD83D\\uDCD0 Step 3 - transform.tx: \".concat(transform.tx));\n            console.log(\"   \\uD83D\\uDCD0 Step 4 - transform.ty: \".concat(transform.ty));\n            console.log(\"   \\uD83D\\uDCD0 Step 5 - coordinateOffset.x: \".concat(coordinateOffset.x));\n            console.log(\"   \\uD83D\\uDCD0 Step 6 - coordinateOffset.y: \".concat(coordinateOffset.y));\n            console.log(\"   \\uD83E\\uDDEE CALCULATION: x = \".concat(bounds === null || bounds === void 0 ? void 0 : bounds.left, \" + \").concat(transform.tx, \" + \").concat(coordinateOffset.x, \" = \").concat(x));\n            console.log(\"   \\uD83E\\uDDEE CALCULATION: y = \".concat(bounds === null || bounds === void 0 ? void 0 : bounds.top, \" + \").concat(transform.ty, \" + \").concat(coordinateOffset.y, \" = \").concat(y));\n            element.position = {\n                x: Math.round(x * 100) / 100,\n                y: Math.round(y * 100) / 100,\n                width: Math.round(width * 100) / 100,\n                height: Math.round(height * 100) / 100,\n                rotation: IDMLUtils.calculateRotation(transform)\n            };\n            console.log(\"   ✅ FINAL POSITION:\", element.position);\n        });\n    }\n    extractMasterPages(masterData) {\n        const pages = [];\n        if (masterData.Page) {\n            const pageList = Array.isArray(masterData.Page) ? masterData.Page : [\n                masterData.Page\n            ];\n            pageList.forEach((page)=>{\n                // Extract margin preferences from master page\n                let marginPreference = null;\n                if (page.MarginPreference) {\n                    marginPreference = {\n                        top: parseFloat(page.MarginPreference[\"@_Top\"]) || 0,\n                        bottom: parseFloat(page.MarginPreference[\"@_Bottom\"]) || 0,\n                        left: parseFloat(page.MarginPreference[\"@_Left\"]) || 0,\n                        right: parseFloat(page.MarginPreference[\"@_Right\"]) || 0,\n                        columnCount: parseInt(page.MarginPreference[\"@_ColumnCount\"]) || 1,\n                        columnGutter: parseFloat(page.MarginPreference[\"@_ColumnGutter\"]) || 0,\n                        columnDirection: page.MarginPreference[\"@_ColumnDirection\"] || \"Horizontal\",\n                        columnsPositions: page.MarginPreference[\"@_ColumnsPositions\"] || \"\"\n                    };\n                    console.log(\"\\uD83D\\uDCCF Extracted margin preference from master page:\", marginPreference);\n                }\n                pages.push({\n                    self: page[\"@_Self\"],\n                    name: page[\"@_Name\"] || \"\",\n                    geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                    itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"]),\n                    appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                    masterPageTransform: IDMLUtils.parseTransform(page[\"@_MasterPageTransform\"]),\n                    marginPreference: marginPreference\n                });\n            });\n        }\n        return pages;\n    }\n    getElements() {\n        return this.elements;\n    }\n    clearElements() {\n        this.elements = [];\n    }\n    getElementIndex(element) {\n        return this.elements.findIndex((el)=>el.self === element.self);\n    }\n    getPageContent(pageId) {\n        const pageElements = this.elements.filter((element)=>{\n            // Check if element belongs to this page based on its bounds\n            return true; // TODO: Implement proper page boundary checking\n        });\n        return {\n            elements: pageElements\n        };\n    }\n    constructor(){\n        this.elements = [];\n    }\n}\nmodule.exports = ElementParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0Q7UUFDL0Q7UUFFQSxPQUFPO1lBQ0w1RCxVQUFVbUk7UUFDWjtJQUNGO0lBbmNBRSxhQUFjO1FBQ1osSUFBSSxDQUFDckksUUFBUSxHQUFHLEVBQUU7SUFDcEI7QUFrY0Y7QUFFQXNJLE9BQU9DLE9BQU8sR0FBR3JLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9wYXJzZXJzL0VsZW1lbnRQYXJzZXIuanM/NWI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBJRE1MVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9JRE1MVXRpbHMnKTtcclxuXHJcbmNsYXNzIEVsZW1lbnRQYXJzZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFNwcmVhZFBhZ2VzKHNwcmVhZERhdGEpIHtcclxuICAgIGNvbnN0IHBhZ2VzID0gW107XHJcbiAgIFxyXG4gICAgaWYgKHNwcmVhZERhdGEuUGFnZSkge1xyXG4gICAgICBjb25zdCBwYWdlTGlzdCA9IEFycmF5LmlzQXJyYXkoc3ByZWFkRGF0YS5QYWdlKSA/IHNwcmVhZERhdGEuUGFnZSA6IFtzcHJlYWREYXRhLlBhZ2VdO1xyXG4gICAgICBcclxuICAgICAgcGFnZUxpc3QuZm9yRWFjaCgocGFnZSwgaW5kZXgpID0+IHtcclxuICAgICAgICBwYWdlcy5wdXNoKHtcclxuICAgICAgICAgIHNlbGY6IHBhZ2VbJ0BfU2VsZiddLFxyXG4gICAgICAgICAgbmFtZTogcGFnZVsnQF9OYW1lJ10gfHwgJycsXHJcbiAgICAgICAgICBhcHBsaWVkTWFzdGVyOiBwYWdlWydAX0FwcGxpZWRNYXN0ZXInXSB8fCAnJyxcclxuICAgICAgICAgIGdlb21ldHJpY0JvdW5kczogSURNTFV0aWxzLnBhcnNlR2VvbWV0cmljQm91bmRzKHBhZ2VbJ0BfR2VvbWV0cmljQm91bmRzJ10pLFxyXG4gICAgICAgICAgaXRlbVRyYW5zZm9ybTogSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKHBhZ2VbJ0BfSXRlbVRyYW5zZm9ybSddKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdObyBwYWdlcyBmb3VuZCBpbiBzcHJlYWQgZGF0YScpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGVkICR7cGFnZXMubGVuZ3RofSBwYWdlc2ApO1xyXG4gICAgcmV0dXJuIHBhZ2VzO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBhZ2VJdGVtcyhzcHJlYWREYXRhKSB7XHJcbiAgICBjb25zdCBwYWdlSXRlbXMgPSBbXTtcclxuICAgXHJcbiAgICAvLyBFeHRyYWN0IGRpZmZlcmVudCB0eXBlcyBvZiBwYWdlIGl0ZW1zXHJcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBbXHJcbiAgICAgICdSZWN0YW5nbGUnLCAnT3ZhbCcsICdQb2x5Z29uJywgJ0dyYXBoaWNMaW5lJywgXHJcbiAgICAgICdUZXh0RnJhbWUnLCAnR3JvdXAnLCAnQnV0dG9uJywgJ1RhYmxlJyxcclxuICAgICAgJ0ltYWdlJywgJ0VQUycsICdQREYnLCAnUGxhY2VkSXRlbScsICdDb250ZW50RnJhbWUnICAvLyBBZGQgdGhlc2VcclxuICAgIF07XHJcbiAgICBcclxuICAgIGl0ZW1UeXBlcy5mb3JFYWNoKGl0ZW1UeXBlID0+IHtcclxuICAgICAgaWYgKHNwcmVhZERhdGFbaXRlbVR5cGVdKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5pc0FycmF5KHNwcmVhZERhdGFbaXRlbVR5cGVdKSA/IHNwcmVhZERhdGFbaXRlbVR5cGVdIDogW3NwcmVhZERhdGFbaXRlbVR5cGVdXTtcclxuICAgICAgICBcclxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgJHtpdGVtVHlwZX06YCwgaXRlbVsnQF9TZWxmJ10pO1xyXG4gICAgICAgICAgY29uc3QgcGFnZUl0ZW0gPSB0aGlzLnBhcnNlUGFnZUl0ZW0oaXRlbSwgaXRlbVR5cGUpO1xyXG4gICAgICAgICAgaWYgKHBhZ2VJdGVtKSB7XHJcbiAgICAgICAgICAgIHBhZ2VJdGVtcy5wdXNoKHBhZ2VJdGVtKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKHBhZ2VJdGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5jaGVja0Zvck5lc3RlZENvbnRlbnQoc3ByZWFkRGF0YSwgcGFnZUl0ZW1zKTtcclxuICAgIFxyXG4gICAgLy8gQUxTTyBDSEVDSyBGT1IgTkVTVEVEIElURU1TIElOIFBBR0VTXHJcbiAgICBpZiAoc3ByZWFkRGF0YS5QYWdlKSB7XHJcbiAgICAgIGNvbnN0IHBhZ2VzID0gQXJyYXkuaXNBcnJheShzcHJlYWREYXRhLlBhZ2UpID8gc3ByZWFkRGF0YS5QYWdlIDogW3NwcmVhZERhdGEuUGFnZV07XHJcbiAgICAgIHBhZ2VzLmZvckVhY2gocGFnZSA9PiB7XHJcbiAgICAgIFxyXG4gICAgICAgIGl0ZW1UeXBlcy5mb3JFYWNoKGl0ZW1UeXBlID0+IHtcclxuICAgICAgICAgIGlmIChwYWdlW2l0ZW1UeXBlXSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtpdGVtVHlwZX0gaW4gcGFnZTpgLCBBcnJheS5pc0FycmF5KHBhZ2VbaXRlbVR5cGVdKSA/IHBhZ2VbaXRlbVR5cGVdLmxlbmd0aCA6IDEpO1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmlzQXJyYXkocGFnZVtpdGVtVHlwZV0pID8gcGFnZVtpdGVtVHlwZV0gOiBbcGFnZVtpdGVtVHlwZV1dO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBwYWdlSXRlbSA9IHRoaXMucGFyc2VQYWdlSXRlbShpdGVtLCBpdGVtVHlwZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHBhZ2VJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBwYWdlSXRlbXMucHVzaChwYWdlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2gocGFnZUl0ZW0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgVG90YWwgcGFnZSBpdGVtcyBleHRyYWN0ZWQ6ICR7cGFnZUl0ZW1zLmxlbmd0aH1gKTtcclxuICAgIHJldHVybiBwYWdlSXRlbXM7XHJcbiAgfVxyXG5cclxuICBjaGVja0Zvck5lc3RlZENvbnRlbnQoc3ByZWFkRGF0YSwgcGFnZUl0ZW1zKSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+UjSBDaGVja2luZyBmb3IgbmVzdGVkIGNvbnRlbnQgaW4gZWxlbWVudHMuLi4nKTtcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgcmVjdGFuZ2xlcyBmb3IgcGxhY2VkIGltYWdlc1xyXG4gICAgaWYgKHNwcmVhZERhdGEuUmVjdGFuZ2xlKSB7XHJcbiAgICAgIGNvbnN0IHJlY3RhbmdsZXMgPSBBcnJheS5pc0FycmF5KHNwcmVhZERhdGEuUmVjdGFuZ2xlKSA/IHNwcmVhZERhdGEuUmVjdGFuZ2xlIDogW3NwcmVhZERhdGEuUmVjdGFuZ2xlXTtcclxuICAgICAgXHJcbiAgICAgIHJlY3RhbmdsZXMuZm9yRWFjaChyZWN0ID0+IHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBMb29rIGZvciBBTlkgY29udGVudCBpbnNpZGUgcmVjdGFuZ2xlIC0gYmUgbW9yZSBhZ2dyZXNzaXZlXHJcbiAgICAgICAgY29uc3QgcG9zc2libGVDb250ZW50ID0gcmVjdC5JbWFnZSB8fCByZWN0LlBsYWNlZEltYWdlIHx8IHJlY3QuRVBTIHx8IHJlY3QuUERGIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0LlByb3BlcnRpZXM/LkltYWdlIHx8IHJlY3QuUHJvcGVydGllcz8uUGxhY2VkSW1hZ2UgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5MaW5rIHx8IHJlY3QuUHJvcGVydGllcz8uTGluaztcclxuICAgICAgICAgXHJcbiAgICAgICAgaWYgKHBvc3NpYmxlQ29udGVudCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfk7cgRm91bmQgcGxhY2VkIGNvbnRlbnQgaW4gcmVjdGFuZ2xlICR7cmVjdFsnQF9TZWxmJ119OmAsIHBvc3NpYmxlQ29udGVudCk7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlY3RhbmdsZSB0byBpbmRpY2F0ZSBpdCdzIGEgY29udGVudCBmcmFtZVxyXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdSZWN0ID0gcGFnZUl0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLnNlbGYgPT09IHJlY3RbJ0BfU2VsZiddKTtcclxuICAgICAgICAgIGlmIChleGlzdGluZ1JlY3QpIHtcclxuICAgICAgICAgICAgZXhpc3RpbmdSZWN0Lmhhc1BsYWNlZENvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBleGlzdGluZ1JlY3QuY29udGVudFR5cGUgPSAnSW1hZ2UnO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gRXh0cmFjdCBwbGFjZWQgY29udGVudCBkZXRhaWxzIHdpdGggYmV0dGVyIGhhbmRsaW5nXHJcbiAgICAgICAgICAgIGV4aXN0aW5nUmVjdC5wbGFjZWRDb250ZW50ID0gdGhpcy5leHRyYWN0UGxhY2VkQ29udGVudChwb3NzaWJsZUNvbnRlbnQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBDYWxjdWxhdGUgdGhlIGltYWdlIHBvc2l0aW9uIHdpdGhpbiB0aGUgZnJhbWVcclxuICAgICAgICAgICAgZXhpc3RpbmdSZWN0LmltYWdlUG9zaXRpb24gPSBJRE1MVXRpbHMuY2FsY3VsYXRlSW1hZ2VQb3NpdGlvbkluRnJhbWUoXHJcbiAgICAgICAgICAgICAgZXhpc3RpbmdSZWN0Lmdlb21ldHJpY0JvdW5kcyxcclxuICAgICAgICAgICAgICBleGlzdGluZ1JlY3QuaXRlbVRyYW5zZm9ybSxcclxuICAgICAgICAgICAgICBleGlzdGluZ1JlY3QucGxhY2VkQ29udGVudFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRyYWN0UGxhY2VkQ29udGVudChjb250ZW50KSB7XHJcbiAgICBpZiAoIWNvbnRlbnQpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygn8J+UjSBFeHRyYWN0aW5nIHBsYWNlZCBjb250ZW50OicsIGNvbnRlbnQpO1xyXG4gICAgXHJcbiAgICBjb25zdCBjb250ZW50SXRlbSA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50WzBdIDogY29udGVudDtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0NvbnRlbnQgaXRlbSBrZXlzOicsIE9iamVjdC5rZXlzKGNvbnRlbnRJdGVtKSk7XHJcbiAgICBcclxuICAgIC8vIEVOSEFOQ0VEOiBCZXR0ZXIgaHJlZiBoYW5kbGluZyBmb3IgZW1iZWRkZWQgaW1hZ2VzXHJcbiAgICBsZXQgaHJlZiA9IGNvbnRlbnRJdGVtWydAX2hyZWYnXSB8fCBjb250ZW50SXRlbVsnQF9BY3R1YWxQcGknXSB8fCAnJztcclxuICAgIGxldCBpc0VtYmVkZGVkID0gZmFsc2U7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gZW1iZWRkZWQgaW1hZ2UgcmVmZXJlbmNlXHJcbiAgICBpZiAoaHJlZiAmJiAhaHJlZi5zdGFydHNXaXRoKCdmaWxlOi8vJykgJiYgIWhyZWYuaW5jbHVkZXMoJy8nKSkge1xyXG4gICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYW4gZW1iZWRkZWQgaW1hZ2UgcmVmZXJlbmNlXHJcbiAgICAgIGlzRW1iZWRkZWQgPSB0cnVlO1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+WvO+4jyBEZXRlY3RlZCBlbWJlZGRlZCBpbWFnZSByZWZlcmVuY2U6JywgaHJlZik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IGNvbnRlbnRJdGVtWydAX3R5cGUnXSB8fCAnSW1hZ2UnLFxyXG4gICAgICBocmVmOiBocmVmLFxyXG4gICAgICBpc0VtYmVkZGVkOiBpc0VtYmVkZGVkLCAvLyBBREQgVEhJU1xyXG4gICAgICBib3VuZHM6IGNvbnRlbnRJdGVtWydAX0dlb21ldHJpY0JvdW5kcyddID8gXHJcbiAgICAgICAgSURNTFV0aWxzLnBhcnNlR2VvbWV0cmljQm91bmRzKGNvbnRlbnRJdGVtWydAX0dlb21ldHJpY0JvdW5kcyddKSA6IFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgIHRyYW5zZm9ybTogY29udGVudEl0ZW1bJ0BfSXRlbVRyYW5zZm9ybSddID8gXHJcbiAgICAgICAgSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKGNvbnRlbnRJdGVtWydAX0l0ZW1UcmFuc2Zvcm0nXSkgOiBcclxuICAgICAgICBudWxsLFxyXG4gICAgICBhY3R1YWxQcGk6IGNvbnRlbnRJdGVtWydAX0FjdHVhbFBwaSddLFxyXG4gICAgICBlZmZlY3RpdmVQcGk6IGNvbnRlbnRJdGVtWydAX0VmZmVjdGl2ZVBwaSddLFxyXG4gICAgICBpbWFnZVR5cGVOYW1lOiBjb250ZW50SXRlbVsnQF9JbWFnZVR5cGVOYW1lJ10sXHJcbiAgICAgIHNwYWNlOiBjb250ZW50SXRlbVsnQF9TcGFjZSddXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcGFyc2VQYWdlSXRlbShpdGVtLCBpdGVtVHlwZSkge1xyXG4gICAgLy8gQUREOiBWYWxpZGF0aW9uXHJcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW1bJ0BfU2VsZiddKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCAke2l0ZW1UeXBlfSBpdGVtIC0gbWlzc2luZyBzZWxmIElEYCk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBiYXNlSXRlbSA9IHtcclxuICAgICAgdHlwZTogaXRlbVR5cGUsXHJcbiAgICAgIHNlbGY6IGl0ZW1bJ0BfU2VsZiddLFxyXG4gICAgICBuYW1lOiBpdGVtWydAX05hbWUnXSB8fCAnJyxcclxuICAgICAgdmlzaWJsZTogaXRlbVsnQF9WaXNpYmxlJ10gIT09IGZhbHNlLFxyXG4gICAgICBsb2NrZWQ6IGl0ZW1bJ0BfTG9ja2VkJ10gPT09IHRydWUsXHJcbiAgICAgIFxyXG4gICAgICBnZW9tZXRyaWNCb3VuZHM6IElETUxVdGlscy5jYWxjdWxhdGVCb3VuZHNGcm9tUGF0aChpdGVtKSxcclxuICAgICAgaXRlbVRyYW5zZm9ybTogSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKGl0ZW1bJ0BfSXRlbVRyYW5zZm9ybSddKSxcclxuICAgICAgXHJcbiAgICAgIGl0ZW1MYXllcjogaXRlbVsnQF9JdGVtTGF5ZXInXSB8fCAnJyxcclxuICAgICAgZmlsbENvbG9yOiBpdGVtWydAX0ZpbGxDb2xvciddIHx8ICdDb2xvci9Ob25lJyxcclxuICAgICAgc3Ryb2tlQ29sb3I6IGl0ZW1bJ0BfU3Ryb2tlQ29sb3InXSB8fCAnQ29sb3IvTm9uZScsXHJcbiAgICAgIHN0cm9rZVdlaWdodDogcGFyc2VGbG9hdChpdGVtWydAX1N0cm9rZVdlaWdodCddKSB8fCAwLFxyXG4gICAgICBcclxuICAgICAgcGFyZW50U3Rvcnk6IGl0ZW1bJ0BfUGFyZW50U3RvcnknXSB8fCBudWxsLFxyXG4gICAgICBcclxuICAgICAgLy8gRU5IQU5DRUQ6IEJldHRlciBjb250ZW50IGZyYW1lIGRldGVjdGlvblxyXG4gICAgICBpc0NvbnRlbnRGcmFtZTogZmFsc2UsXHJcbiAgICAgIGhhc1BsYWNlZENvbnRlbnQ6IGZhbHNlLFxyXG4gICAgICBjb250ZW50VHlwZTogbnVsbFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gQUREOiBEZXRlY3QgY29udGVudCBmcmFtZXMgbW9yZSBhY2N1cmF0ZWx5XHJcbiAgIC8vIEVOSEFOQ0VEOiBCZXR0ZXIgZW1iZWRkZWQgaW1hZ2UgZGV0ZWN0aW9uXHJcbiAgaWYgKGl0ZW1UeXBlID09PSAnUmVjdGFuZ2xlJykge1xyXG4gICAgLy8gQ2hlY2sgZm9yIGVtYmVkZGVkIGltYWdlcyBtb3JlIHRob3JvdWdobHlcclxuICAgIGNvbnN0IGVtYmVkZGVkSW5mbyA9IHRoaXMuZGV0ZWN0RW1iZWRkZWRJbWFnZXMoaXRlbSk7XHJcbiAgICBcclxuICAgIGlmIChlbWJlZGRlZEluZm8uaGFzRW1iZWRkZWRDb250ZW50IHx8IGVtYmVkZGVkSW5mby5pc1BsYWNlaG9sZGVyKSB7XHJcbiAgICAgIGJhc2VJdGVtLmlzQ29udGVudEZyYW1lID0gdHJ1ZTtcclxuICAgICAgYmFzZUl0ZW0uaGFzUGxhY2VkQ29udGVudCA9IGVtYmVkZGVkSW5mby5oYXNFbWJlZGRlZENvbnRlbnQ7XHJcbiAgICAgIGJhc2VJdGVtLmNvbnRlbnRUeXBlID0gZW1iZWRkZWRJbmZvLmVtYmVkZGVkVHlwZSB8fCAncGxhY2Vob2xkZXInO1xyXG4gICAgICBiYXNlSXRlbS5pc0VtYmVkZGVkID0gZW1iZWRkZWRJbmZvLmhhc0VtYmVkZGVkQ29udGVudDtcclxuICAgICAgYmFzZUl0ZW0uaXNQbGFjZWhvbGRlciA9IGVtYmVkZGVkSW5mby5pc1BsYWNlaG9sZGVyO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYPCfk6YgRGV0ZWN0ZWQgJHtlbWJlZGRlZEluZm8uaGFzRW1iZWRkZWRDb250ZW50ID8gJ2VtYmVkZGVkJyA6ICdwbGFjZWhvbGRlcid9IGNvbnRlbnQgZnJhbWU6ICR7YmFzZUl0ZW0uc2VsZn1gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRXhpc3RpbmcgY29udGVudCBmcmFtZSBkZXRlY3Rpb24gbG9naWMuLi5cclxuICAgIGNvbnN0IGhhc0NvbnRlbnQgPSAhIShpdGVtLkltYWdlIHx8IGl0ZW0uUGxhY2VkSW1hZ2UgfHwgaXRlbS5FUFMgfHwgaXRlbS5QREYgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLlByb3BlcnRpZXM/LkltYWdlIHx8IGl0ZW0uUHJvcGVydGllcz8uUGxhY2VkSW1hZ2UpO1xyXG4gICAgXHJcbiAgICBpZiAoaGFzQ29udGVudCAmJiAhYmFzZUl0ZW0uaXNDb250ZW50RnJhbWUpIHtcclxuICAgICAgYmFzZUl0ZW0uaXNDb250ZW50RnJhbWUgPSB0cnVlO1xyXG4gICAgICBiYXNlSXRlbS5oYXNQbGFjZWRDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgYmFzZUl0ZW0uY29udGVudFR5cGUgPSAnSW1hZ2UnO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBwbGFjZWQgY29udGVudCB0cmFuc2Zvcm0gZm9yIHBvc2l0aW9uaW5nXHJcbiAgICAgIGNvbnN0IHBsYWNlZENvbnRlbnQgPSBpdGVtLkltYWdlIHx8IGl0ZW0uUGxhY2VkSW1hZ2UgfHwgaXRlbS5FUFMgfHwgaXRlbS5QREY7XHJcbiAgICAgIGlmIChwbGFjZWRDb250ZW50KSB7XHJcbiAgICAgICAgYmFzZUl0ZW0ucGxhY2VkQ29udGVudCA9IHRoaXMuZXh0cmFjdFBsYWNlZENvbnRlbnQocGxhY2VkQ29udGVudCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OmIERldGVjdGVkIGV4dGVybmFsIGNvbnRlbnQgZnJhbWU6ICR7YmFzZUl0ZW0uc2VsZn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgICBcclxuICAgIC8vIFR5cGUtc3BlY2lmaWMgcHJvY2Vzc2luZy4uLlxyXG4gICAgc3dpdGNoIChpdGVtVHlwZSkge1xyXG4gICAgICBjYXNlICdUZXh0RnJhbWUnOlxyXG4gICAgICAgIGJhc2VJdGVtLnRleHRGcmFtZVByZWZlcmVuY2VzID0gdGhpcy5wYXJzZVRleHRGcmFtZVByZWZlcmVuY2VzKGl0ZW0uVGV4dEZyYW1lUHJlZmVyZW5jZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ1JlY3RhbmdsZSc6XHJcbiAgICAgICAgYmFzZUl0ZW0uY29ybmVyRWZmZWN0cyA9IHRoaXMucGFyc2VDb3JuZXJFZmZlY3RzKGl0ZW0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdHcm91cCc6XHJcbiAgICAgICAgYmFzZUl0ZW0uZ3JvdXBJdGVtcyA9IHRoaXMuZXh0cmFjdEdyb3VwSXRlbXMoaXRlbSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBiYXNlSXRlbTtcclxuICB9XHJcblxyXG4gIGRldGVjdEVtYmVkZGVkSW1hZ2VzKGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IGVtYmVkZGVkSW5kaWNhdG9ycyA9IHtcclxuICAgICAgaGFzRW1iZWRkZWRDb250ZW50OiBmYWxzZSxcclxuICAgICAgZW1iZWRkZWRUeXBlOiBudWxsLFxyXG4gICAgICBlbWJlZGRlZERhdGE6IG51bGwsXHJcbiAgICAgIGVtYmVkZGVkRmlsZU5hbWU6IG51bGwsIC8vIEFERCBUSElTXHJcbiAgICAgIGlzUGxhY2Vob2xkZXI6IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiBlbGVtZW50IG5hbWUgaW5kaWNhdGVzIHBsYWNlaG9sZGVyXHJcbiAgICBpZiAoZWxlbWVudC5uYW1lICYmIChcclxuICAgICAgZWxlbWVudC5uYW1lLmluY2x1ZGVzKCdbWU9VUiBJTUFHRSBIRVJFXScpIHx8XHJcbiAgICAgIGVsZW1lbnQubmFtZS5pbmNsdWRlcygnW0lNQUdFXScpIHx8XHJcbiAgICAgIGVsZW1lbnQubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdwbGFjZWhvbGRlcicpXHJcbiAgICApKSB7XHJcbiAgICAgIGVtYmVkZGVkSW5kaWNhdG9ycy5pc1BsYWNlaG9sZGVyID0gdHJ1ZTtcclxuICAgICAgZW1iZWRkZWRJbmRpY2F0b3JzLmVtYmVkZGVkVHlwZSA9ICdwbGFjZWhvbGRlcic7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEVOSEFOQ0VEOiBDaGVjayBmb3IgYWN0dWFsIGVtYmVkZGVkIGltYWdlIGRhdGFcclxuICAgIGlmIChlbGVtZW50LnBsYWNlZENvbnRlbnQpIHtcclxuICAgICAgY29uc3QgY29udGVudCA9IGVsZW1lbnQucGxhY2VkQ29udGVudDtcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIGhyZWYgbG9va3MgbGlrZSBhbiBlbWJlZGRlZCByZWZlcmVuY2VcclxuICAgICAgaWYgKGNvbnRlbnQuaHJlZiAmJiBjb250ZW50LmlzRW1iZWRkZWQpIHtcclxuICAgICAgICBlbWJlZGRlZEluZGljYXRvcnMuaGFzRW1iZWRkZWRDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICBlbWJlZGRlZEluZGljYXRvcnMuZW1iZWRkZWRUeXBlID0gY29udGVudC5pbWFnZVR5cGVOYW1lIHx8ICd1bmtub3duJztcclxuICAgICAgICBlbWJlZGRlZEluZGljYXRvcnMuZW1iZWRkZWREYXRhID0gY29udGVudC5ocmVmO1xyXG4gICAgICAgIGVtYmVkZGVkSW5kaWNhdG9ycy5lbWJlZGRlZEZpbGVOYW1lID0gYCR7Y29udGVudC5ocmVmfS4ke0lETUxVdGlscy5nZXRJbWFnZUV4dGVuc2lvbihjb250ZW50LmltYWdlVHlwZU5hbWUpfWA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGVtYmVkZGVkSW5kaWNhdG9ycztcclxuICB9XHJcblxyXG4gIHBhcnNlVGV4dEZyYW1lUHJlZmVyZW5jZXModGV4dEZyYW1lUHJlZmVyZW5jZSkge1xyXG4gICAgaWYgKCF0ZXh0RnJhbWVQcmVmZXJlbmNlKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dENvbHVtbkNvdW50OiBwYXJzZUludCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX1RleHRDb2x1bW5Db3VudCddKSB8fCAxLFxyXG4gICAgICB0ZXh0Q29sdW1uR3V0dGVyOiBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfVGV4dENvbHVtbkd1dHRlciddKSB8fCAwLFxyXG4gICAgICBmaXJzdEJhc2VsaW5lT2Zmc2V0OiB0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX0ZpcnN0QmFzZWxpbmVPZmZzZXQnXSB8fCAnQXNjZW50T2Zmc2V0JyxcclxuICAgICAgYXV0b1NpemluZ1JlZmVyZW5jZVBvaW50OiB0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX0F1dG9TaXppbmdSZWZlcmVuY2VQb2ludCddIHx8ICdDZW50ZXJQb2ludCcsXHJcbiAgICAgIGF1dG9TaXppbmdUeXBlOiB0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX0F1dG9TaXppbmdUeXBlJ10gfHwgJ09mZicsXHJcbiAgICAgIHZlcnRpY2FsSnVzdGlmaWNhdGlvbjogdGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9WZXJ0aWNhbEp1c3RpZmljYXRpb24nXSB8fCAnVG9wQWxpZ24nLFxyXG4gICAgICBcclxuICAgICAgLy8gRU5IQU5DRUQ6IEV4dHJhY3QgdGV4dCBmcmFtZSBpbnNldHMgZm9yIHByZWNpc2UgcG9zaXRpb25pbmdcclxuICAgICAgaW5zZXRTcGFjaW5nOiB7XHJcbiAgICAgICAgdG9wOiBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfSW5zZXRTcGFjaW5nJ10/LnNwbGl0KCcgJylbMF0pIHx8IFxyXG4gICAgICAgICAgICAgcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX1RleHRJbnNldFRvcCddKSB8fCAwLFxyXG4gICAgICAgIHJpZ2h0OiBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfSW5zZXRTcGFjaW5nJ10/LnNwbGl0KCcgJylbMV0pIHx8IFxyXG4gICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfVGV4dEluc2V0UmlnaHQnXSkgfHwgMCxcclxuICAgICAgICBib3R0b206IHBhcnNlRmxvYXQodGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9JbnNldFNwYWNpbmcnXT8uc3BsaXQoJyAnKVsyXSkgfHwgXHJcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfVGV4dEluc2V0Qm90dG9tJ10pIHx8IDAsXHJcbiAgICAgICAgbGVmdDogcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX0luc2V0U3BhY2luZyddPy5zcGxpdCgnICcpWzNdKSB8fCBcclxuICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfVGV4dEluc2V0TGVmdCddKSB8fCAwXHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICAvLyBBZGRpdGlvbmFsIEluRGVzaWduLXNwZWNpZmljIHByb3BlcnRpZXMgZm9yIHByZWNpc2UgdGV4dCBsYXlvdXRcclxuICAgICAgdXNlTWluaW11bUhlaWdodDogdGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9Vc2VNaW5pbXVtSGVpZ2h0J10gPT09IHRydWUsXHJcbiAgICAgIG1pbmltdW1GaXJzdEJhc2VsaW5lT2Zmc2V0OiBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfTWluaW11bUZpcnN0QmFzZWxpbmVPZmZzZXQnXSkgfHwgMCxcclxuICAgICAgaWdub3JlV3JhcDogdGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9JZ25vcmVXcmFwJ10gPT09IHRydWVcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwYXJzZUNvcm5lckVmZmVjdHMoaXRlbSkge1xyXG4gICAgLy8gUGFyc2UgY29ybmVyIGVmZmVjdHMgZm9yIHJlY3RhbmdsZXNcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXM6IHBhcnNlRmxvYXQoaXRlbVsnQF9Ub3BMZWZ0Q29ybmVyUmFkaXVzJ10pIHx8IDAsXHJcbiAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiBwYXJzZUZsb2F0KGl0ZW1bJ0BfVG9wUmlnaHRDb3JuZXJSYWRpdXMnXSkgfHwgMCxcclxuICAgICAgYm90dG9tTGVmdENvcm5lclJhZGl1czogcGFyc2VGbG9hdChpdGVtWydAX0JvdHRvbUxlZnRDb3JuZXJSYWRpdXMnXSkgfHwgMCxcclxuICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM6IHBhcnNlRmxvYXQoaXRlbVsnQF9Cb3R0b21SaWdodENvcm5lclJhZGl1cyddKSB8fCAwXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdEdyb3VwSXRlbXMoZ3JvdXBJdGVtKSB7XHJcbiAgICBjb25zdCBncm91cEl0ZW1zID0gW107XHJcbiAgICBcclxuICAgIC8vIEdyb3VwcyBjYW4gY29udGFpbiBvdGhlciBwYWdlIGl0ZW1zXHJcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBbJ1JlY3RhbmdsZScsICdPdmFsJywgJ1BvbHlnb24nLCAnVGV4dEZyYW1lJ107XHJcbiAgICBcclxuICAgIGl0ZW1UeXBlcy5mb3JFYWNoKGl0ZW1UeXBlID0+IHtcclxuICAgICAgaWYgKGdyb3VwSXRlbVtpdGVtVHlwZV0pIHtcclxuICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXBJdGVtW2l0ZW1UeXBlXSkgPyBncm91cEl0ZW1baXRlbVR5cGVdIDogW2dyb3VwSXRlbVtpdGVtVHlwZV1dO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBwYXJzZWRJdGVtID0gdGhpcy5wYXJzZVBhZ2VJdGVtKGl0ZW0sIGl0ZW1UeXBlKTtcclxuICAgICAgICAgIGlmIChwYXJzZWRJdGVtKSB7XHJcbiAgICAgICAgICAgIGdyb3VwSXRlbXMucHVzaChwYXJzZWRJdGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBncm91cEl0ZW1zO1xyXG4gIH1cclxuXHJcbiAgcGFyc2VUcmFuc3BhcmVuY3kodHJhbnNwYXJlbmN5U2V0dGluZ3MpIHtcclxuICAgIGlmICghdHJhbnNwYXJlbmN5U2V0dGluZ3MpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBibGVuZGluZ1NldHRpbmdzOiB0cmFuc3BhcmVuY3lTZXR0aW5ncy5CbGVuZGluZ1NldHRpbmcgPyB7XHJcbiAgICAgICAgYmxlbmRNb2RlOiB0cmFuc3BhcmVuY3lTZXR0aW5ncy5CbGVuZGluZ1NldHRpbmdbJ0BfQmxlbmRNb2RlJ10gfHwgJ05vcm1hbCcsXHJcbiAgICAgICAgb3BhY2l0eTogcGFyc2VGbG9hdCh0cmFuc3BhcmVuY3lTZXR0aW5ncy5CbGVuZGluZ1NldHRpbmdbJ0BfT3BhY2l0eSddKSB8fCAxMDBcclxuICAgICAgfSA6IG51bGxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjcmVhdGVFbGVtZW50UG9zaXRpb25NYXBGaXhlZCgpIHtcclxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBGSVhFRCBlbGVtZW50IHBvc2l0aW9uIG1hcC4uLicpO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgY29vcmRpbmF0ZSBvZmZzZXQgdG8gaGFuZGxlIG5lZ2F0aXZlIGNvb3JkaW5hdGVzXHJcbiAgICBjb25zdCBjb29yZGluYXRlT2Zmc2V0ID0gSURNTFV0aWxzLmNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXQodGhpcy5lbGVtZW50cyk7XHJcbiAgICBjb25zb2xlLmxvZygnQ29vcmRpbmF0ZSBvZmZzZXQ6JywgY29vcmRpbmF0ZU9mZnNldCk7XHJcbiAgICBcclxuICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgYm91bmRzID0gZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMgfHwgZWxlbWVudC5vcmlnaW5hbEJvdW5kcztcclxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZWxlbWVudC5pdGVtVHJhbnNmb3JtIHx8IHsgYTogMSwgYjogMCwgYzogMCwgZDogMSwgdHg6IDAsIHR5OiAwIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBDT1JSRUNUOiBBcHBseSB0cmFuc2Zvcm0gdG8gYm91bmRzLCB0aGVuIGFkZCBvZmZzZXRcclxuICAgICAgbGV0IHggPSAoYm91bmRzPy5sZWZ0IHx8IDApICsgKHRyYW5zZm9ybS50eCB8fCAwKSArIGNvb3JkaW5hdGVPZmZzZXQueDtcclxuICAgICAgbGV0IHkgPSAoYm91bmRzPy50b3AgfHwgMCkgKyAodHJhbnNmb3JtLnR5IHx8IDApICsgY29vcmRpbmF0ZU9mZnNldC55O1xyXG4gICAgICBcclxuICAgICAgLy8gRm9yIHRoZSB0ZXh0ZnJhbWUgd2l0aCBuZWdhdGl2ZSBZLCBhcHBseSBzcGVjaWFsIGhhbmRsaW5nXHJcbiAgICAgIGlmICh5IDwgMCkge1xyXG4gICAgICAgIHkgPSBNYXRoLmFicyh5KTsgLy8gQ29udmVydCBuZWdhdGl2ZSB0byBwb3NpdGl2ZVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBsZXQgd2lkdGggPSBNYXRoLmFicyhib3VuZHM/LndpZHRoIHx8IDApO1xyXG4gICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5hYnMoYm91bmRzPy5oZWlnaHQgfHwgMCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBERVRBSUxFRCBERUJVR0dJTkc6IFRyYWNrIHRoZSBleGFjdCBjb29yZGluYXRlIGNhbGN1bGF0aW9uXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEVMRU1FTlQgJHtpbmRleH0gWyR7ZWxlbWVudC50eXBlfV0gQ09PUkRJTkFURSBDQUxDVUxBVElPTjpgKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIPCfk4QgUmF3IGJvdW5kczpgLCBib3VuZHMpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAg8J+UhCBSYXcgdHJhbnNmb3JtOmAsIHRyYW5zZm9ybSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICDwn5OQIFN0ZXAgMSAtIGJvdW5kcy5sZWZ0OiAke2JvdW5kcz8ubGVmdH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIPCfk5AgU3RlcCAyIC0gYm91bmRzLnRvcDogJHtib3VuZHM/LnRvcH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIPCfk5AgU3RlcCAzIC0gdHJhbnNmb3JtLnR4OiAke3RyYW5zZm9ybS50eH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIPCfk5AgU3RlcCA0IC0gdHJhbnNmb3JtLnR5OiAke3RyYW5zZm9ybS50eX1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIPCfk5AgU3RlcCA1IC0gY29vcmRpbmF0ZU9mZnNldC54OiAke2Nvb3JkaW5hdGVPZmZzZXQueH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIPCfk5AgU3RlcCA2IC0gY29vcmRpbmF0ZU9mZnNldC55OiAke2Nvb3JkaW5hdGVPZmZzZXQueX1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIPCfp64gQ0FMQ1VMQVRJT046IHggPSAke2JvdW5kcz8ubGVmdH0gKyAke3RyYW5zZm9ybS50eH0gKyAke2Nvb3JkaW5hdGVPZmZzZXQueH0gPSAke3h9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICDwn6euIENBTENVTEFUSU9OOiB5ID0gJHtib3VuZHM/LnRvcH0gKyAke3RyYW5zZm9ybS50eX0gKyAke2Nvb3JkaW5hdGVPZmZzZXQueX0gPSAke3l9YCk7XHJcbiAgICAgIFxyXG4gICAgICBlbGVtZW50LnBvc2l0aW9uID0ge1xyXG4gICAgICAgIHg6IE1hdGgucm91bmQoeCAqIDEwMCkgLyAxMDAsXHJcbiAgICAgICAgeTogTWF0aC5yb3VuZCh5ICogMTAwKSAvIDEwMCxcclxuICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh3aWR0aCAqIDEwMCkgLyAxMDAsXHJcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGhlaWdodCAqIDEwMCkgLyAxMDAsXHJcbiAgICAgICAgcm90YXRpb246IElETUxVdGlscy5jYWxjdWxhdGVSb3RhdGlvbih0cmFuc2Zvcm0pXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgICAg4pyFIEZJTkFMIFBPU0lUSU9OOmAsIGVsZW1lbnQucG9zaXRpb24pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0TWFzdGVyUGFnZXMobWFzdGVyRGF0YSkge1xyXG4gICAgY29uc3QgcGFnZXMgPSBbXTtcclxuICAgIFxyXG4gICAgaWYgKG1hc3RlckRhdGEuUGFnZSkge1xyXG4gICAgICBjb25zdCBwYWdlTGlzdCA9IEFycmF5LmlzQXJyYXkobWFzdGVyRGF0YS5QYWdlKSA/IG1hc3RlckRhdGEuUGFnZSA6IFttYXN0ZXJEYXRhLlBhZ2VdO1xyXG4gICAgICBcclxuICAgICAgcGFnZUxpc3QuZm9yRWFjaChwYWdlID0+IHtcclxuICAgICAgICAvLyBFeHRyYWN0IG1hcmdpbiBwcmVmZXJlbmNlcyBmcm9tIG1hc3RlciBwYWdlXHJcbiAgICAgICAgbGV0IG1hcmdpblByZWZlcmVuY2UgPSBudWxsO1xyXG4gICAgICAgIGlmIChwYWdlLk1hcmdpblByZWZlcmVuY2UpIHtcclxuICAgICAgICAgIG1hcmdpblByZWZlcmVuY2UgPSB7XHJcbiAgICAgICAgICAgIHRvcDogcGFyc2VGbG9hdChwYWdlLk1hcmdpblByZWZlcmVuY2VbJ0BfVG9wJ10pIHx8IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogcGFyc2VGbG9hdChwYWdlLk1hcmdpblByZWZlcmVuY2VbJ0BfQm90dG9tJ10pIHx8IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IHBhcnNlRmxvYXQocGFnZS5NYXJnaW5QcmVmZXJlbmNlWydAX0xlZnQnXSkgfHwgMCxcclxuICAgICAgICAgICAgcmlnaHQ6IHBhcnNlRmxvYXQocGFnZS5NYXJnaW5QcmVmZXJlbmNlWydAX1JpZ2h0J10pIHx8IDAsXHJcbiAgICAgICAgICAgIGNvbHVtbkNvdW50OiBwYXJzZUludChwYWdlLk1hcmdpblByZWZlcmVuY2VbJ0BfQ29sdW1uQ291bnQnXSkgfHwgMSxcclxuICAgICAgICAgICAgY29sdW1uR3V0dGVyOiBwYXJzZUZsb2F0KHBhZ2UuTWFyZ2luUHJlZmVyZW5jZVsnQF9Db2x1bW5HdXR0ZXInXSkgfHwgMCxcclxuICAgICAgICAgICAgY29sdW1uRGlyZWN0aW9uOiBwYWdlLk1hcmdpblByZWZlcmVuY2VbJ0BfQ29sdW1uRGlyZWN0aW9uJ10gfHwgJ0hvcml6b250YWwnLFxyXG4gICAgICAgICAgICBjb2x1bW5zUG9zaXRpb25zOiBwYWdlLk1hcmdpblByZWZlcmVuY2VbJ0BfQ29sdW1uc1Bvc2l0aW9ucyddIHx8ICcnXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfk48gRXh0cmFjdGVkIG1hcmdpbiBwcmVmZXJlbmNlIGZyb20gbWFzdGVyIHBhZ2U6JywgbWFyZ2luUHJlZmVyZW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHBhZ2VzLnB1c2goe1xyXG4gICAgICAgICAgc2VsZjogcGFnZVsnQF9TZWxmJ10sXHJcbiAgICAgICAgICBuYW1lOiBwYWdlWydAX05hbWUnXSB8fCAnJyxcclxuICAgICAgICAgIGdlb21ldHJpY0JvdW5kczogSURNTFV0aWxzLnBhcnNlR2VvbWV0cmljQm91bmRzKHBhZ2VbJ0BfR2VvbWV0cmljQm91bmRzJ10pLFxyXG4gICAgICAgICAgaXRlbVRyYW5zZm9ybTogSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKHBhZ2VbJ0BfSXRlbVRyYW5zZm9ybSddKSxcclxuICAgICAgICAgIGFwcGxpZWRNYXN0ZXI6IHBhZ2VbJ0BfQXBwbGllZE1hc3RlciddIHx8ICcnLFxyXG4gICAgICAgICAgbWFzdGVyUGFnZVRyYW5zZm9ybTogSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKHBhZ2VbJ0BfTWFzdGVyUGFnZVRyYW5zZm9ybSddKSxcclxuICAgICAgICAgIG1hcmdpblByZWZlcmVuY2U6IG1hcmdpblByZWZlcmVuY2VcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBwYWdlcztcclxuICB9XHJcblxyXG4gIGdldEVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICBjbGVhckVsZW1lbnRzKCkge1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgZ2V0RWxlbWVudEluZGV4KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmZpbmRJbmRleChlbCA9PiBlbC5zZWxmID09PSBlbGVtZW50LnNlbGYpO1xyXG4gIH1cclxuXHJcbiAgZ2V0UGFnZUNvbnRlbnQocGFnZUlkKSB7XHJcbiAgICBjb25zdCBwYWdlRWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLmZpbHRlcihlbGVtZW50ID0+IHtcclxuICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBiZWxvbmdzIHRvIHRoaXMgcGFnZSBiYXNlZCBvbiBpdHMgYm91bmRzXHJcbiAgICAgIHJldHVybiB0cnVlOyAvLyBUT0RPOiBJbXBsZW1lbnQgcHJvcGVyIHBhZ2UgYm91bmRhcnkgY2hlY2tpbmdcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlbGVtZW50czogcGFnZUVsZW1lbnRzXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50UGFyc2VyOyBcclxuIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiSURNTFV0aWxzIiwiRWxlbWVudFBhcnNlciIsImV4dHJhY3RTcHJlYWRQYWdlcyIsInNwcmVhZERhdGEiLCJwYWdlcyIsIlBhZ2UiLCJwYWdlTGlzdCIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJwYWdlIiwiaW5kZXgiLCJwdXNoIiwic2VsZiIsIm5hbWUiLCJhcHBsaWVkTWFzdGVyIiwiZ2VvbWV0cmljQm91bmRzIiwicGFyc2VHZW9tZXRyaWNCb3VuZHMiLCJpdGVtVHJhbnNmb3JtIiwicGFyc2VUcmFuc2Zvcm0iLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwiZXh0cmFjdFBhZ2VJdGVtcyIsInBhZ2VJdGVtcyIsIml0ZW1UeXBlcyIsIml0ZW1UeXBlIiwiaXRlbXMiLCJpdGVtIiwicGFnZUl0ZW0iLCJwYXJzZVBhZ2VJdGVtIiwiZWxlbWVudHMiLCJjaGVja0Zvck5lc3RlZENvbnRlbnQiLCJSZWN0YW5nbGUiLCJyZWN0YW5nbGVzIiwicmVjdCIsInBvc3NpYmxlQ29udGVudCIsIkltYWdlIiwiUGxhY2VkSW1hZ2UiLCJFUFMiLCJQREYiLCJQcm9wZXJ0aWVzIiwiTGluayIsImV4aXN0aW5nUmVjdCIsImZpbmQiLCJoYXNQbGFjZWRDb250ZW50IiwiY29udGVudFR5cGUiLCJwbGFjZWRDb250ZW50IiwiZXh0cmFjdFBsYWNlZENvbnRlbnQiLCJpbWFnZVBvc2l0aW9uIiwiY2FsY3VsYXRlSW1hZ2VQb3NpdGlvbkluRnJhbWUiLCJjb250ZW50IiwiY29udGVudEl0ZW0iLCJPYmplY3QiLCJrZXlzIiwiaHJlZiIsImlzRW1iZWRkZWQiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJ0eXBlIiwiYm91bmRzIiwidHJhbnNmb3JtIiwiYWN0dWFsUHBpIiwiZWZmZWN0aXZlUHBpIiwiaW1hZ2VUeXBlTmFtZSIsInNwYWNlIiwid2FybiIsImJhc2VJdGVtIiwidmlzaWJsZSIsImxvY2tlZCIsImNhbGN1bGF0ZUJvdW5kc0Zyb21QYXRoIiwiaXRlbUxheWVyIiwiZmlsbENvbG9yIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXZWlnaHQiLCJwYXJzZUZsb2F0IiwicGFyZW50U3RvcnkiLCJpc0NvbnRlbnRGcmFtZSIsImVtYmVkZGVkSW5mbyIsImRldGVjdEVtYmVkZGVkSW1hZ2VzIiwiaGFzRW1iZWRkZWRDb250ZW50IiwiaXNQbGFjZWhvbGRlciIsImVtYmVkZGVkVHlwZSIsImhhc0NvbnRlbnQiLCJ0ZXh0RnJhbWVQcmVmZXJlbmNlcyIsInBhcnNlVGV4dEZyYW1lUHJlZmVyZW5jZXMiLCJUZXh0RnJhbWVQcmVmZXJlbmNlIiwiY29ybmVyRWZmZWN0cyIsInBhcnNlQ29ybmVyRWZmZWN0cyIsImdyb3VwSXRlbXMiLCJleHRyYWN0R3JvdXBJdGVtcyIsImVsZW1lbnQiLCJlbWJlZGRlZEluZGljYXRvcnMiLCJlbWJlZGRlZERhdGEiLCJlbWJlZGRlZEZpbGVOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRJbWFnZUV4dGVuc2lvbiIsInRleHRGcmFtZVByZWZlcmVuY2UiLCJ0ZXh0Q29sdW1uQ291bnQiLCJwYXJzZUludCIsInRleHRDb2x1bW5HdXR0ZXIiLCJmaXJzdEJhc2VsaW5lT2Zmc2V0IiwiYXV0b1NpemluZ1JlZmVyZW5jZVBvaW50IiwiYXV0b1NpemluZ1R5cGUiLCJ2ZXJ0aWNhbEp1c3RpZmljYXRpb24iLCJpbnNldFNwYWNpbmciLCJ0b3AiLCJzcGxpdCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInVzZU1pbmltdW1IZWlnaHQiLCJtaW5pbXVtRmlyc3RCYXNlbGluZU9mZnNldCIsImlnbm9yZVdyYXAiLCJ0b3BMZWZ0Q29ybmVyUmFkaXVzIiwidG9wUmlnaHRDb3JuZXJSYWRpdXMiLCJib3R0b21MZWZ0Q29ybmVyUmFkaXVzIiwiYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMiLCJncm91cEl0ZW0iLCJwYXJzZWRJdGVtIiwicGFyc2VUcmFuc3BhcmVuY3kiLCJ0cmFuc3BhcmVuY3lTZXR0aW5ncyIsImJsZW5kaW5nU2V0dGluZ3MiLCJCbGVuZGluZ1NldHRpbmciLCJibGVuZE1vZGUiLCJvcGFjaXR5IiwiY3JlYXRlRWxlbWVudFBvc2l0aW9uTWFwRml4ZWQiLCJjb29yZGluYXRlT2Zmc2V0IiwiY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldCIsIm9yaWdpbmFsQm91bmRzIiwiYSIsImIiLCJjIiwiZCIsInR4IiwidHkiLCJ4IiwieSIsIk1hdGgiLCJhYnMiLCJ3aWR0aCIsImhlaWdodCIsInBvc2l0aW9uIiwicm91bmQiLCJyb3RhdGlvbiIsImNhbGN1bGF0ZVJvdGF0aW9uIiwiZXh0cmFjdE1hc3RlclBhZ2VzIiwibWFzdGVyRGF0YSIsIm1hcmdpblByZWZlcmVuY2UiLCJNYXJnaW5QcmVmZXJlbmNlIiwiY29sdW1uQ291bnQiLCJjb2x1bW5HdXR0ZXIiLCJjb2x1bW5EaXJlY3Rpb24iLCJjb2x1bW5zUG9zaXRpb25zIiwibWFzdGVyUGFnZVRyYW5zZm9ybSIsImdldEVsZW1lbnRzIiwiY2xlYXJFbGVtZW50cyIsImdldEVsZW1lbnRJbmRleCIsImZpbmRJbmRleCIsImVsIiwiZ2V0UGFnZUNvbnRlbnQiLCJwYWdlSWQiLCJwYWdlRWxlbWVudHMiLCJmaWx0ZXIiLCJjb25zdHJ1Y3RvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/parsers/ElementParser.js\n"));

/***/ })

});