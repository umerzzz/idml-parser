"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StyleParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StyleParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StyleParser {\n    // ADDED: Method to set document units for typography conversion\n    setDocumentUnits(units) {\n        this.documentUnits = units;\n        console.log(\"\\uD83D\\uDCD0 StyleParser: Set document units to\", units);\n    }\n    // ADDED: Method to convert typography measurements to pixels\n    convertTypographyToPixels(value) {\n        if (typeof value !== \"number\" || isNaN(value) || !this.unitConverter || !this.documentUnits) {\n            return value;\n        }\n        // Only convert if we have a supported unit and it's not already pixels\n        if (this.unitConverter.isSupportedUnit(this.documentUnits)) {\n            const convertedValue = this.unitConverter.toPixels(value, this.documentUnits);\n            console.log(\"\\uD83D\\uDCD0 Converted typography: \".concat(value, \" \").concat(this.documentUnits, \" → \").concat(convertedValue, \" px\"));\n            return convertedValue;\n        }\n        return value;\n    }\n    // ADDED: Method to convert an entire style object's measurements to pixels\n    convertStyleMeasurementsToPixels(style) {\n        if (!this.unitConverter || !this.documentUnits) {\n            return style;\n        }\n        const convertedStyle = {\n            ...style\n        };\n        // Convert measurements that need pixel conversion\n        const measurementFields = [\n            \"leftIndent\",\n            \"rightIndent\",\n            \"firstLineIndent\",\n            \"spaceBefore\",\n            \"spaceAfter\",\n            \"tracking\",\n            \"kerning\"\n        ];\n        measurementFields.forEach((field)=>{\n            if (typeof convertedStyle[field] === \"number\") {\n                convertedStyle[field] = this.convertTypographyToPixels(convertedStyle[field]);\n            }\n        });\n        // Convert leading if it's a numeric value\n        if (typeof convertedStyle.leading === \"number\") {\n            convertedStyle.leading = this.convertTypographyToPixels(convertedStyle.leading);\n        }\n        return convertedStyle;\n    }\n    async parseResourceFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCCB Parsing resource: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const resourceName = path.basename(fileName, \".xml\");\n            // Handle different resource types\n            if (fileName.includes(\"Styles.xml\")) {\n                await this.extractStyles(parsed);\n            } else if (fileName.includes(\"Fonts.xml\")) {\n                await this.extractFonts(parsed);\n            } else if (fileName.includes(\"Graphic.xml\")) {\n                await this.extractGraphics(parsed);\n            } else if (fileName.includes(\"Preferences.xml\")) {\n                await this.extractPreferences(parsed);\n            }\n            console.log(\"✅ Resource \".concat(resourceName, \" parsed\"));\n        } catch (error) {\n            console.error(\"❌ Error parsing \".concat(fileName, \":\"), error.message);\n        }\n    }\n    async extractStyles(stylesData) {\n        console.log(\"Extracting styles...\");\n        const styles = stylesData.Styles || stylesData;\n        // Extract Paragraph Styles\n        if (styles.RootParagraphStyleGroup) {\n            this.extractParagraphStyles(styles.RootParagraphStyleGroup);\n        }\n        // Extract Character Styles\n        if (styles.RootCharacterStyleGroup) {\n            this.extractCharacterStyles(styles.RootCharacterStyleGroup);\n        }\n    }\n    extractParagraphStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.ParagraphStyle) {\n                const styles = Array.isArray(group.ParagraphStyle) ? group.ParagraphStyle : [\n                    group.ParagraphStyle\n                ];\n                styles.forEach((style)=>{\n                    // CRITICAL: Extract font reference from multiple possible locations\n                    const fontRef = this.extractFontFromStyle(style);\n                    // ENHANCED: Process leading with proper InDesign logic\n                    const fontSize = parseFloat(style[\"@_PointSize\"]) || 12;\n                    const rawLeading = style[\"@_Leading\"];\n                    const processedLeading = this.processLeadingValue(rawLeading, fontSize);\n                    // FIXED: Extract raw typography measurements for conversion\n                    const rawLeftIndent = parseFloat(style[\"@_LeftIndent\"]) || 0;\n                    const rawRightIndent = parseFloat(style[\"@_RightIndent\"]) || 0;\n                    const rawFirstLineIndent = parseFloat(style[\"@_FirstLineIndent\"]) || 0;\n                    const rawSpaceBefore = parseFloat(style[\"@_SpaceBefore\"]) || 0;\n                    const rawSpaceAfter = parseFloat(style[\"@_SpaceAfter\"]) || 0;\n                    const rawTracking = parseFloat(style[\"@_Tracking\"]) || 0;\n                    const rawKerning = parseFloat(style[\"@_Kerning\"]) || 0;\n                    // FIXED: Create base style object with raw values\n                    const baseStyle = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: fontSize,\n                        leading: processedLeading,\n                        leadingType: this.determineLeadingType(rawLeading),\n                        effectiveLineHeight: this.calculateEffectiveLineHeight(processedLeading, fontSize),\n                        alignment: style[\"@_Justification\"] || \"LeftAlign\",\n                        // Raw measurements (will be converted to pixels)\n                        leftIndent: rawLeftIndent,\n                        rightIndent: rawRightIndent,\n                        firstLineIndent: rawFirstLineIndent,\n                        spaceBefore: rawSpaceBefore,\n                        spaceAfter: rawSpaceAfter,\n                        tracking: rawTracking,\n                        kerning: rawKerning,\n                        // Store original values for reference\n                        originalLeftIndent: rawLeftIndent,\n                        originalRightIndent: rawRightIndent,\n                        originalFirstLineIndent: rawFirstLineIndent,\n                        originalSpaceBefore: rawSpaceBefore,\n                        originalSpaceAfter: rawSpaceAfter,\n                        originalTracking: rawTracking,\n                        originalKerning: rawKerning,\n                        horizontalScale: parseFloat(style[\"@_HorizontalScale\"]) || 100,\n                        verticalScale: parseFloat(style[\"@_VerticalScale\"]) || 100,\n                        // ENHANCED: Use the new extraction method\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || \"Color/Black\",\n                        rawStyle: style\n                    };\n                    // FIXED: Apply unit conversion to create pixel-converted style\n                    this.styles.paragraph[style[\"@_Self\"]] = this.convertStyleMeasurementsToPixels(baseStyle);\n                    console.log(\"✅ Paragraph Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.ParagraphStyleGroup) {\n                const subGroups = Array.isArray(group.ParagraphStyleGroup) ? group.ParagraphStyleGroup : [\n                    group.ParagraphStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    extractFontFromStyle(style) {\n        // Try direct attributes first\n        let fontRef = style[\"@_AppliedFont\"] || style[\"@_FontFamily\"] || style[\"@_Font\"] || \"\";\n        // If not found, try Properties nested structure\n        if (!fontRef && style.Properties) {\n            if (style.Properties.AppliedFont) {\n                fontRef = style.Properties.AppliedFont[\"#text\"] || style.Properties.AppliedFont || \"\";\n            }\n            // Also try other property variations\n            if (!fontRef && style.Properties.FontFamily) {\n                fontRef = style.Properties.FontFamily[\"#text\"] || style.Properties.FontFamily || \"\";\n            }\n        }\n        return fontRef || \"\";\n    }\n    extractCharacterStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.CharacterStyle) {\n                const styles = Array.isArray(group.CharacterStyle) ? group.CharacterStyle : [\n                    group.CharacterStyle\n                ];\n                styles.forEach((style)=>{\n                    const fontRef = this.extractFontFromStyle(style);\n                    this.styles.character[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: parseFloat(style[\"@_PointSize\"]) || null,\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || null,\n                        strokeColor: style[\"@_StrokeColor\"] || null,\n                        rawStyle: style\n                    };\n                    console.log(\"✅ Character Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.CharacterStyleGroup) {\n                const subGroups = Array.isArray(group.CharacterStyleGroup) ? group.CharacterStyleGroup : [\n                    group.CharacterStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    async extractFonts(fontsData) {\n        console.log(\"Extracting fonts with enhanced mapping...\");\n        const fonts = fontsData.Fonts || fontsData;\n        this.resources.fonts = {};\n        this.fontMap = new Map(); // Global font lookup map\n        if (fonts.FontFamily) {\n            const fontFamilies = Array.isArray(fonts.FontFamily) ? fonts.FontFamily : [\n                fonts.FontFamily\n            ];\n            fontFamilies.forEach((family)=>{\n                const familyInfo = {\n                    self: family[\"@_Self\"],\n                    name: family[\"@_Name\"] || \"\",\n                    fonts: []\n                };\n                if (family.Font) {\n                    const fontList = Array.isArray(family.Font) ? family.Font : [\n                        family.Font\n                    ];\n                    fontList.forEach((font)=>{\n                        const fontInfo = {\n                            self: font[\"@_Self\"],\n                            fontFamily: font[\"@_FontFamily\"] || familyInfo.name,\n                            name: font[\"@_Name\"] || \"\",\n                            postScriptName: font[\"@_PostScriptName\"] || \"\",\n                            status: font[\"@_Status\"] || \"Unknown\",\n                            fontStyleName: font[\"@_FontStyleName\"] || \"Regular\"\n                        };\n                        familyInfo.fonts.push(fontInfo);\n                        // Create multiple lookup entries for this font\n                        this.fontMap.set(font[\"@_Self\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_PostScriptName\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_Name\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_FontFamily\"], familyInfo.name);\n                        console.log(\"Font mapping: \".concat(font[\"@_Self\"], \" -> \").concat(familyInfo.name));\n                    });\n                }\n                this.resources.fonts[family[\"@_Self\"]] = familyInfo;\n            });\n        }\n        console.log(\"✅ Fonts extracted: \".concat(Object.keys(this.resources.fonts).length, \" families\"));\n        console.log(\"Font map entries: \".concat(this.fontMap.size));\n    }\n    async extractGraphics(graphicsData) {\n        console.log(\"Extracting graphics and colors...\");\n        const graphics = graphicsData.Graphic || graphicsData;\n        this.resources.colors = {};\n        this.resources.gradients = {};\n        // Extract Colors\n        if (graphics.Color) {\n            const colors = Array.isArray(graphics.Color) ? graphics.Color : [\n                graphics.Color\n            ];\n            colors.forEach((color)=>{\n                this.resources.colors[color[\"@_Self\"]] = {\n                    self: color[\"@_Self\"],\n                    name: color[\"@_Name\"] || \"\",\n                    model: color[\"@_Model\"] || \"Process\",\n                    space: color[\"@_Space\"] || \"CMYK\",\n                    cyan: parseFloat(color[\"@_Cyan\"]) || 0,\n                    magenta: parseFloat(color[\"@_Magenta\"]) || 0,\n                    yellow: parseFloat(color[\"@_Yellow\"]) || 0,\n                    black: parseFloat(color[\"@_Black\"]) || 0,\n                    red: parseFloat(color[\"@_Red\"]) || 0,\n                    green: parseFloat(color[\"@_Green\"]) || 0,\n                    blue: parseFloat(color[\"@_Blue\"]) || 0\n                };\n            });\n        }\n        // Extract Gradients\n        if (graphics.Gradient) {\n            const gradients = Array.isArray(graphics.Gradient) ? graphics.Gradient : [\n                graphics.Gradient\n            ];\n            gradients.forEach((gradient)=>{\n                this.resources.gradients[gradient[\"@_Self\"]] = {\n                    self: gradient[\"@_Self\"],\n                    name: gradient[\"@_Name\"] || \"\",\n                    type: gradient[\"@_Type\"] || \"Linear\",\n                    gradientStops: this.extractGradientStops(gradient)\n                };\n            });\n        }\n    }\n    extractGradientStops(gradient) {\n        const stops = [];\n        if (gradient.GradientStop) {\n            const stopList = Array.isArray(gradient.GradientStop) ? gradient.GradientStop : [\n                gradient.GradientStop\n            ];\n            stopList.forEach((stop)=>{\n                stops.push({\n                    self: stop[\"@_Self\"],\n                    stopColor: stop[\"@_StopColor\"] || \"\",\n                    location: parseFloat(stop[\"@_Location\"]) || 0,\n                    midpoint: parseFloat(stop[\"@_Midpoint\"]) || 50\n                });\n            });\n        }\n        return stops;\n    }\n    async extractPreferences(preferencesData) {\n        console.log(\"Extracting document preferences...\");\n        const prefs = preferencesData.Preferences || preferencesData;\n        // Extract various document preferences\n        this.documentInfo = {\n            preferences: {\n                documentPreferences: this.extractDocumentPrefs(prefs.DocumentPreference),\n                viewPreferences: this.extractViewPrefs(prefs.ViewPreference),\n                guidePreferences: this.extractGuidePrefs(prefs.GuidePreference),\n                gridPreferences: this.extractGridPrefs(prefs.GridPreference),\n                marginPreferences: this.extractMarginPrefs(prefs.MarginPreference),\n                columnPreferences: this.extractColumnPrefs(prefs.ColumnPreference)\n            }\n        };\n    }\n    extractDocumentPrefs(docPref) {\n        if (!docPref) return {};\n        return {\n            pageWidth: parseFloat(docPref[\"@_PageWidth\"]) || 0,\n            pageHeight: parseFloat(docPref[\"@_PageHeight\"]) || 0,\n            left: parseFloat(docPref[\"@_Left\"]) || 0,\n            top: parseFloat(docPref[\"@_Top\"]) || 0,\n            right: parseFloat(docPref[\"@_Right\"]) || 0,\n            bottom: parseFloat(docPref[\"@_Bottom\"]) || 0,\n            columnCount: parseInt(docPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(docPref[\"@_ColumnGutter\"]) || 0,\n            facingPages: docPref[\"@_FacingPages\"] === true,\n            allowPageShuffle: docPref[\"@_AllowPageShuffle\"] !== false,\n            slugBleedType: docPref[\"@_SlugBleedType\"] || \"None\",\n            documentBleedTopOffset: parseFloat(docPref[\"@_DocumentBleedTopOffset\"]) || 0,\n            documentBleedBottomOffset: parseFloat(docPref[\"@_DocumentBleedBottomOffset\"]) || 0,\n            documentBleedInsideOrLeftOffset: parseFloat(docPref[\"@_DocumentBleedInsideOrLeftOffset\"]) || 0,\n            documentBleedOutsideOrRightOffset: parseFloat(docPref[\"@_DocumentBleedOutsideOrRightOffset\"]) || 0\n        };\n    }\n    extractViewPrefs(viewPref) {\n        if (!viewPref) return {};\n        return {\n            horizontalMeasurementUnits: viewPref[\"@_HorizontalMeasurementUnits\"] || \"Points\",\n            verticalMeasurementUnits: viewPref[\"@_VerticalMeasurementUnits\"] || \"Points\",\n            rulerOrigin: viewPref[\"@_RulerOrigin\"] || \"SpreadOrigin\",\n            showRulers: viewPref[\"@_ShowRulers\"] !== false\n        };\n    }\n    extractGuidePrefs(guidePref) {\n        if (!guidePref) return {};\n        return {\n            rulerGuideColor: guidePref[\"@_RulerGuideColor\"] || \"Green\",\n            guidesInBack: guidePref[\"@_GuidesInBack\"] === true,\n            guidesLocked: guidePref[\"@_GuidesLocked\"] === true,\n            guidesShown: guidePref[\"@_GuidesShown\"] !== false,\n            guidesSnapto: guidePref[\"@_GuidesSnapto\"] !== false\n        };\n    }\n    extractGridPrefs(gridPref) {\n        if (!gridPref) return {};\n        return {\n            baselineStart: parseFloat(gridPref[\"@_BaselineStart\"]) || 0,\n            baselineDivision: parseFloat(gridPref[\"@_BaselineDivision\"]) || 12,\n            baselineShown: gridPref[\"@_BaselineShown\"] === true,\n            baselineSnapto: gridPref[\"@_BaselineSnapto\"] === true,\n            documentGridShown: gridPref[\"@_DocumentGridShown\"] === true,\n            documentGridSnapto: gridPref[\"@_DocumentGridSnapto\"] === true\n        };\n    }\n    extractMarginPrefs(marginPref) {\n        if (!marginPref) return {};\n        return {\n            top: parseFloat(marginPref[\"@_Top\"]) || 0,\n            bottom: parseFloat(marginPref[\"@_Bottom\"]) || 0,\n            left: parseFloat(marginPref[\"@_Left\"]) || 0,\n            right: parseFloat(marginPref[\"@_Right\"]) || 0,\n            columnCount: parseInt(marginPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(marginPref[\"@_ColumnGutter\"]) || 0\n        };\n    }\n    extractColumnPrefs(columnPref) {\n        if (!columnPref) return {};\n        return {\n            textColumnCount: parseInt(columnPref[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(columnPref[\"@_TextColumnGutter\"]) || 0\n        };\n    }\n    resolveStyleFormatting(formatting) {\n        const resolved = {\n            ...formatting\n        };\n        // DEBUG: Check if formatting is being applied (generic check)\n        const hasAnyFormatting = formatting.paragraphStyle || formatting.characterStyle || formatting.fontStyle || formatting.fontReference || formatting.fontSize;\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Input:\", {\n                paragraphStyle: formatting.paragraphStyle,\n                characterStyle: formatting.characterStyle,\n                directFontStyle: formatting.fontStyle,\n                directFontRef: formatting.fontReference,\n                directFontSize: formatting.fontSize\n            });\n        }\n        // Resolve paragraph style (base layer)\n        if (formatting.paragraphStyle && this.styles.paragraph[formatting.paragraphStyle]) {\n            const pStyle = this.styles.paragraph[formatting.paragraphStyle];\n            if (!resolved.fontSize && pStyle.pointSize) resolved.fontSize = pStyle.pointSize;\n            if (!resolved.fillColor && pStyle.fillColor) resolved.fillColor = pStyle.fillColor;\n            // CRITICAL FIX: Always inherit paragraph alignment unless explicitly overridden\n            if (pStyle.alignment) resolved.alignment = pStyle.alignment;\n            if (!resolved.fontStyle && pStyle.fontStyle) {\n                resolved.fontStyle = pStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from paragraph style: \"'.concat(pStyle.fontStyle, '\"'));\n                }\n            }\n            // CRITICAL: Resolve font from paragraph style\n            if (!resolved.fontFamily && pStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(pStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from paragraph style: \".concat(pStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n            // Add other paragraph properties with enhanced leading support\n            resolved.leading = pStyle.leading;\n            resolved.leadingType = pStyle.leadingType;\n            resolved.effectiveLineHeight = pStyle.effectiveLineHeight;\n            resolved.leftIndent = pStyle.leftIndent;\n            resolved.rightIndent = pStyle.rightIndent;\n            resolved.firstLineIndent = pStyle.firstLineIndent;\n            resolved.spaceBefore = pStyle.spaceBefore;\n            resolved.spaceAfter = pStyle.spaceAfter;\n            resolved.tracking = pStyle.tracking;\n            resolved.kerning = pStyle.kerning;\n        }\n        // Resolve character style (override layer)\n        if (formatting.characterStyle && this.styles.character[formatting.characterStyle]) {\n            const cStyle = this.styles.character[formatting.characterStyle];\n            if (cStyle.pointSize) resolved.fontSize = cStyle.pointSize;\n            if (cStyle.fillColor) resolved.fillColor = cStyle.fillColor;\n            if (cStyle.fontStyle) {\n                resolved.fontStyle = cStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from character style: \"'.concat(cStyle.fontStyle, '\"'));\n                }\n            }\n            if (cStyle.strokeColor) resolved.strokeColor = cStyle.strokeColor;\n            // Include leading information from character style\n            if (cStyle.leading) resolved.leading = cStyle.leading;\n            if (cStyle.leadingType) resolved.leadingType = cStyle.leadingType;\n            if (cStyle.effectiveLineHeight) resolved.effectiveLineHeight = cStyle.effectiveLineHeight;\n            // CRITICAL: Character style font overrides paragraph style\n            if (cStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(cStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from character style: \".concat(cStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n        }\n        // Apply direct formatting (highest priority)\n        if (formatting.fontReference) {\n            resolved.fontFamily = this.resolveFontReference(formatting.fontReference);\n            if (hasAnyFormatting) {\n                console.log(\"   Font from direct formatting: \".concat(formatting.fontReference, \" -> \").concat(resolved.fontFamily));\n            }\n        }\n        // CRITICAL: Apply direct fontStyle if provided (this might be the issue)\n        if (formatting.fontStyle) {\n            resolved.fontStyle = formatting.fontStyle;\n            if (hasAnyFormatting) {\n                console.log('   FontStyle from direct formatting: \"'.concat(formatting.fontStyle, '\"'));\n            }\n        }\n        // Apply direct leading information (highest priority)\n        if (formatting.leading !== undefined) resolved.leading = formatting.leading;\n        if (formatting.leadingType) resolved.leadingType = formatting.leadingType;\n        if (formatting.effectiveLineHeight) resolved.effectiveLineHeight = formatting.effectiveLineHeight;\n        // Apply other direct formatting attributes\n        if (formatting.fontSize) resolved.fontSize = formatting.fontSize;\n        if (formatting.tracking) resolved.tracking = formatting.tracking;\n        if (formatting.kerning) resolved.kerning = formatting.kerning;\n        // CRITICAL FIX: Apply direct alignment if explicitly specified (overrides paragraph alignment)\n        if (formatting.alignment) {\n            resolved.alignment = formatting.alignment;\n            if (hasAnyFormatting) {\n                console.log('   Alignment from direct formatting: \"'.concat(formatting.alignment, '\"'));\n            }\n        }\n        // FIXED: Ensure fontStyle defaults to Regular/normal if not set\n        if (!resolved.fontStyle || resolved.fontStyle === \"\") {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log('   FontStyle defaulted to: \"Regular\"');\n            }\n        }\n        // ADDITIONAL FIX: If no styles were applied from any source, ensure clean defaults\n        if (!formatting.paragraphStyle && !formatting.characterStyle && !formatting.fontStyle && !formatting.fontReference) {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log(\"   No source styles found - ensuring clean defaults\");\n            }\n        }\n        // Final fallback\n        if (!resolved.fontFamily || resolved.fontFamily === \"\") {\n            resolved.fontFamily = this.getDefaultFont();\n            if (hasAnyFormatting) {\n                console.log(\"   Using fallback font: \".concat(resolved.fontFamily));\n            }\n        }\n        // Ensure line height is calculated if not explicitly set\n        if (!resolved.effectiveLineHeight && resolved.fontSize && resolved.leading) {\n            resolved.effectiveLineHeight = this.calculateEffectiveLineHeight(resolved.leading, resolved.fontSize);\n        }\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Final Output:\", {\n                fontSize: resolved.fontSize,\n                fontFamily: resolved.fontFamily,\n                fontStyle: resolved.fontStyle,\n                fillColor: resolved.fillColor,\n                leading: resolved.leading,\n                effectiveLineHeight: resolved.effectiveLineHeight\n            });\n        }\n        return resolved;\n    }\n    resolveFontReference(fontRef) {\n        if (!fontRef || fontRef === \"\") {\n            console.log(\"Empty font reference, using fallback\");\n            return this.getDefaultFont();\n        }\n        // Try direct lookup in font map\n        if (this.fontMap && this.fontMap.has(fontRef)) {\n            const resolvedFont = this.fontMap.get(fontRef);\n            console.log('Font resolved: \"'.concat(fontRef, '\" -> \"').concat(resolvedFont, '\"'));\n            return resolvedFont;\n        }\n        // Try partial matching for font families\n        if (this.resources.fonts) {\n            for (const [familyId, familyInfo] of Object.entries(this.resources.fonts)){\n                // Check family name match\n                if (familyInfo.name && (familyInfo.name.toLowerCase().includes(fontRef.toLowerCase()) || fontRef.toLowerCase().includes(familyInfo.name.toLowerCase()))) {\n                    console.log('Font partially matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                    return familyInfo.name;\n                }\n                // Check individual font matches\n                if (familyInfo.fonts) {\n                    for (const font of familyInfo.fonts){\n                        if (font.self === fontRef || font.postScriptName === fontRef || font.name === fontRef) {\n                            console.log('Font exactly matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                            return familyInfo.name;\n                        }\n                    }\n                }\n            }\n        }\n        console.log('Font not found: \"'.concat(fontRef, '\", using fallback'));\n        return this.getDefaultFont() || fontRef;\n    }\n    getDefaultFont() {\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFamily = Object.values(this.resources.fonts)[0];\n            return firstFamily.name || \"Arial\";\n        }\n        return \"Arial\";\n    }\n    inferFontFromContext() {\n        // If we have font definitions but no explicit references,\n        // return the first available font as a fallback\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFontFamily = Object.values(this.resources.fonts)[0];\n            return firstFontFamily.name;\n        }\n        return null;\n    }\n    getStoryStyleSummary(story) {\n        var _story_content_formattedContent, _story_content;\n        const summary = {\n            fontSize: null,\n            fontFamily: null,\n            alignment: null,\n            fillColor: null,\n            fontStyle: null,\n            leading: null,\n            leadingType: null,\n            effectiveLineHeight: null,\n            tracking: null,\n            kerning: null\n        };\n        // Get the most common or first formatting values\n        if (((_story_content = story.content) === null || _story_content === void 0 ? void 0 : (_story_content_formattedContent = _story_content.formattedContent) === null || _story_content_formattedContent === void 0 ? void 0 : _story_content_formattedContent.length) > 0) {\n            const firstFormatted = story.content.formattedContent.find((item)=>item.formatting && !item.formatting.isBreak);\n            if (firstFormatted === null || firstFormatted === void 0 ? void 0 : firstFormatted.formatting) {\n                const fmt = firstFormatted.formatting;\n                summary.fontSize = fmt.fontSize;\n                summary.fontFamily = fmt.fontFamily;\n                summary.alignment = fmt.alignment;\n                summary.fillColor = fmt.fillColor;\n                summary.fontStyle = fmt.fontStyle;\n                summary.leading = fmt.leading;\n                summary.leadingType = fmt.leadingType;\n                summary.effectiveLineHeight = fmt.effectiveLineHeight;\n                summary.tracking = fmt.tracking;\n                summary.kerning = fmt.kerning;\n            }\n        }\n        return summary;\n    }\n    // NEW: Process leading values with InDesign-specific logic (shared with StoryParser)\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = parseFloat(rawLeading);\n        if (!isNaN(numericLeading)) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (!isNaN(parseFloat(rawLeading))) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(leading, fontSize) {\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\" && fontSize) {\n            // Convert points to CSS line-height ratio\n            return Math.max(0.8, leading / fontSize); // Ensure minimum line height\n        }\n        return 1.2; // Fallback\n    }\n    getStyles() {\n        return this.styles;\n    }\n    getResources() {\n        return this.resources;\n    }\n    getFontMap() {\n        return this.fontMap;\n    }\n    // Add methods to return style and font definitions for debug\n    getParagraphStyles() {\n        return this.styles.paragraph;\n    }\n    getCharacterStyles() {\n        return this.styles.character;\n    }\n    getFontDefinitions() {\n        // Prefer plain object for debug output\n        if (this.resources && this.resources.fonts) {\n            return this.resources.fonts;\n        }\n        // Fallback: convert fontMap to object\n        if (this.fontMap && typeof this.fontMap.entries === \"function\") {\n            return Object.fromEntries(this.fontMap.entries());\n        }\n        return {};\n    }\n    // FIXED: Add method to access document preferences including ViewPreferences\n    getDocumentInfo() {\n        return this.documentInfo;\n    }\n    constructor(unitConverter = null){\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n        this.resources = {\n            fonts: {},\n            colors: {},\n            gradients: {}\n        };\n        this.fontMap = new Map(); // Global font lookup map\n        this.unitConverter = unitConverter; // ADDED: Unit converter for typography measurements\n        this.documentUnits = null; // Will be set from document units\n    }\n}\nmodule.exports = StyleParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDO1FBQ1Q7UUFDQSxJQUFJLENBQUNoSyxTQUFTLEdBQUc7WUFDZkYsT0FBTyxDQUFDO1lBQ1J5QixRQUFRLENBQUM7WUFDVEMsV0FBVyxDQUFDO1FBQ2Q7UUFDQSxJQUFJLENBQUN2QixPQUFPLEdBQUcsSUFBSUMsT0FBTyx5QkFBeUI7UUFDbkQsSUFBSSxDQUFDbEcsYUFBYSxHQUFHQSxlQUFlLG9EQUFvRDtRQUN4RixJQUFJLENBQUNOLGFBQWEsR0FBRyxNQUFNLGtDQUFrQztJQUMvRDtBQW00QkY7QUFFQXVRLE9BQU9DLE9BQU8sR0FBRzNRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9wYXJzZXJzL1N0eWxlUGFyc2VyLmpzPzY5YWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgSURNTFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL0lETUxVdGlsc1wiKTtcblxuY2xhc3MgU3R5bGVQYXJzZXIge1xuICBjb25zdHJ1Y3Rvcih1bml0Q29udmVydGVyID0gbnVsbCkge1xuICAgIHRoaXMuc3R5bGVzID0ge1xuICAgICAgcGFyYWdyYXBoOiB7fSxcbiAgICAgIGNoYXJhY3Rlcjoge30sXG4gICAgICBvYmplY3Q6IHt9LFxuICAgICAgdGFibGU6IHt9LFxuICAgICAgY2VsbDoge30sXG4gICAgfTtcbiAgICB0aGlzLnJlc291cmNlcyA9IHtcbiAgICAgIGZvbnRzOiB7fSxcbiAgICAgIGNvbG9yczoge30sXG4gICAgICBncmFkaWVudHM6IHt9LFxuICAgIH07XG4gICAgdGhpcy5mb250TWFwID0gbmV3IE1hcCgpOyAvLyBHbG9iYWwgZm9udCBsb29rdXAgbWFwXG4gICAgdGhpcy51bml0Q29udmVydGVyID0gdW5pdENvbnZlcnRlcjsgLy8gQURERUQ6IFVuaXQgY29udmVydGVyIGZvciB0eXBvZ3JhcGh5IG1lYXN1cmVtZW50c1xuICAgIHRoaXMuZG9jdW1lbnRVbml0cyA9IG51bGw7IC8vIFdpbGwgYmUgc2V0IGZyb20gZG9jdW1lbnQgdW5pdHNcbiAgfVxuXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gc2V0IGRvY3VtZW50IHVuaXRzIGZvciB0eXBvZ3JhcGh5IGNvbnZlcnNpb25cbiAgc2V0RG9jdW1lbnRVbml0cyh1bml0cykge1xuICAgIHRoaXMuZG9jdW1lbnRVbml0cyA9IHVuaXRzO1xuICAgIGNvbnNvbGUubG9nKFwi8J+TkCBTdHlsZVBhcnNlcjogU2V0IGRvY3VtZW50IHVuaXRzIHRvXCIsIHVuaXRzKTtcbiAgfVxuXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gY29udmVydCB0eXBvZ3JhcGh5IG1lYXN1cmVtZW50cyB0byBwaXhlbHNcbiAgY29udmVydFR5cG9ncmFwaHlUb1BpeGVscyh2YWx1ZSkge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fFxuICAgICAgaXNOYU4odmFsdWUpIHx8XG4gICAgICAhdGhpcy51bml0Q29udmVydGVyIHx8XG4gICAgICAhdGhpcy5kb2N1bWVudFVuaXRzXG4gICAgKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gT25seSBjb252ZXJ0IGlmIHdlIGhhdmUgYSBzdXBwb3J0ZWQgdW5pdCBhbmQgaXQncyBub3QgYWxyZWFkeSBwaXhlbHNcbiAgICBpZiAodGhpcy51bml0Q29udmVydGVyLmlzU3VwcG9ydGVkVW5pdCh0aGlzLmRvY3VtZW50VW5pdHMpKSB7XG4gICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IHRoaXMudW5pdENvbnZlcnRlci50b1BpeGVscyhcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHRoaXMuZG9jdW1lbnRVbml0c1xuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBg8J+TkCBDb252ZXJ0ZWQgdHlwb2dyYXBoeTogJHt2YWx1ZX0gJHt0aGlzLmRvY3VtZW50VW5pdHN9IOKGkiAke2NvbnZlcnRlZFZhbHVlfSBweGBcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gQURERUQ6IE1ldGhvZCB0byBjb252ZXJ0IGFuIGVudGlyZSBzdHlsZSBvYmplY3QncyBtZWFzdXJlbWVudHMgdG8gcGl4ZWxzXG4gIGNvbnZlcnRTdHlsZU1lYXN1cmVtZW50c1RvUGl4ZWxzKHN0eWxlKSB7XG4gICAgaWYgKCF0aGlzLnVuaXRDb252ZXJ0ZXIgfHwgIXRoaXMuZG9jdW1lbnRVbml0cykge1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnZlcnRlZFN0eWxlID0geyAuLi5zdHlsZSB9O1xuXG4gICAgLy8gQ29udmVydCBtZWFzdXJlbWVudHMgdGhhdCBuZWVkIHBpeGVsIGNvbnZlcnNpb25cbiAgICBjb25zdCBtZWFzdXJlbWVudEZpZWxkcyA9IFtcbiAgICAgIFwibGVmdEluZGVudFwiLFxuICAgICAgXCJyaWdodEluZGVudFwiLFxuICAgICAgXCJmaXJzdExpbmVJbmRlbnRcIixcbiAgICAgIFwic3BhY2VCZWZvcmVcIixcbiAgICAgIFwic3BhY2VBZnRlclwiLFxuICAgICAgXCJ0cmFja2luZ1wiLFxuICAgICAgXCJrZXJuaW5nXCIsXG4gICAgXTtcblxuICAgIG1lYXN1cmVtZW50RmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNvbnZlcnRlZFN0eWxlW2ZpZWxkXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBjb252ZXJ0ZWRTdHlsZVtmaWVsZF0gPSB0aGlzLmNvbnZlcnRUeXBvZ3JhcGh5VG9QaXhlbHMoXG4gICAgICAgICAgY29udmVydGVkU3R5bGVbZmllbGRdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDb252ZXJ0IGxlYWRpbmcgaWYgaXQncyBhIG51bWVyaWMgdmFsdWVcbiAgICBpZiAodHlwZW9mIGNvbnZlcnRlZFN0eWxlLmxlYWRpbmcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnZlcnRlZFN0eWxlLmxlYWRpbmcgPSB0aGlzLmNvbnZlcnRUeXBvZ3JhcGh5VG9QaXhlbHMoXG4gICAgICAgIGNvbnZlcnRlZFN0eWxlLmxlYWRpbmdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRlZFN0eWxlO1xuICB9XG5cbiAgYXN5bmMgcGFyc2VSZXNvdXJjZUZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcikge1xuICAgIGNvbnNvbGUubG9nKGDwn5OLIFBhcnNpbmcgcmVzb3VyY2U6ICR7ZmlsZU5hbWV9YCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkID0geG1sUGFyc2VyLnBhcnNlKGNvbnRlbnQpO1xuICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlTmFtZSwgXCIueG1sXCIpO1xuXG4gICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHJlc291cmNlIHR5cGVzXG4gICAgICBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoXCJTdHlsZXMueG1sXCIpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdFN0eWxlcyhwYXJzZWQpO1xuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhcIkZvbnRzLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RGb250cyhwYXJzZWQpO1xuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhcIkdyYXBoaWMueG1sXCIpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdEdyYXBoaWNzKHBhcnNlZCk7XG4gICAgICB9IGVsc2UgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKFwiUHJlZmVyZW5jZXMueG1sXCIpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdFByZWZlcmVuY2VzKHBhcnNlZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUmVzb3VyY2UgJHtyZXNvdXJjZU5hbWV9IHBhcnNlZGApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcGFyc2luZyAke2ZpbGVOYW1lfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBleHRyYWN0U3R5bGVzKHN0eWxlc0RhdGEpIHtcbiAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3Rpbmcgc3R5bGVzLi4uXCIpO1xuXG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVzRGF0YS5TdHlsZXMgfHwgc3R5bGVzRGF0YTtcblxuICAgIC8vIEV4dHJhY3QgUGFyYWdyYXBoIFN0eWxlc1xuICAgIGlmIChzdHlsZXMuUm9vdFBhcmFncmFwaFN0eWxlR3JvdXApIHtcbiAgICAgIHRoaXMuZXh0cmFjdFBhcmFncmFwaFN0eWxlcyhzdHlsZXMuUm9vdFBhcmFncmFwaFN0eWxlR3JvdXApO1xuICAgIH1cblxuICAgIC8vIEV4dHJhY3QgQ2hhcmFjdGVyIFN0eWxlc1xuICAgIGlmIChzdHlsZXMuUm9vdENoYXJhY3RlclN0eWxlR3JvdXApIHtcbiAgICAgIHRoaXMuZXh0cmFjdENoYXJhY3RlclN0eWxlcyhzdHlsZXMuUm9vdENoYXJhY3RlclN0eWxlR3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIGV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMoc3R5bGVHcm91cCkge1xuICAgIGNvbnN0IGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSA9IChncm91cCkgPT4ge1xuICAgICAgaWYgKGdyb3VwLlBhcmFncmFwaFN0eWxlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuUGFyYWdyYXBoU3R5bGUpXG4gICAgICAgICAgPyBncm91cC5QYXJhZ3JhcGhTdHlsZVxuICAgICAgICAgIDogW2dyb3VwLlBhcmFncmFwaFN0eWxlXTtcblxuICAgICAgICBzdHlsZXMuZm9yRWFjaCgoc3R5bGUpID0+IHtcbiAgICAgICAgICAvLyBDUklUSUNBTDogRXh0cmFjdCBmb250IHJlZmVyZW5jZSBmcm9tIG11bHRpcGxlIHBvc3NpYmxlIGxvY2F0aW9uc1xuICAgICAgICAgIGNvbnN0IGZvbnRSZWYgPSB0aGlzLmV4dHJhY3RGb250RnJvbVN0eWxlKHN0eWxlKTtcblxuICAgICAgICAgIC8vIEVOSEFOQ0VEOiBQcm9jZXNzIGxlYWRpbmcgd2l0aCBwcm9wZXIgSW5EZXNpZ24gbG9naWNcbiAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1BvaW50U2l6ZVwiXSkgfHwgMTI7XG4gICAgICAgICAgY29uc3QgcmF3TGVhZGluZyA9IHN0eWxlW1wiQF9MZWFkaW5nXCJdO1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZExlYWRpbmcgPSB0aGlzLnByb2Nlc3NMZWFkaW5nVmFsdWUoXG4gICAgICAgICAgICByYXdMZWFkaW5nLFxuICAgICAgICAgICAgZm9udFNpemVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gRklYRUQ6IEV4dHJhY3QgcmF3IHR5cG9ncmFwaHkgbWVhc3VyZW1lbnRzIGZvciBjb252ZXJzaW9uXG4gICAgICAgICAgY29uc3QgcmF3TGVmdEluZGVudCA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX0xlZnRJbmRlbnRcIl0pIHx8IDA7XG4gICAgICAgICAgY29uc3QgcmF3UmlnaHRJbmRlbnQgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9SaWdodEluZGVudFwiXSkgfHwgMDtcbiAgICAgICAgICBjb25zdCByYXdGaXJzdExpbmVJbmRlbnQgPVxuICAgICAgICAgICAgcGFyc2VGbG9hdChzdHlsZVtcIkBfRmlyc3RMaW5lSW5kZW50XCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1NwYWNlQmVmb3JlID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfU3BhY2VCZWZvcmVcIl0pIHx8IDA7XG4gICAgICAgICAgY29uc3QgcmF3U3BhY2VBZnRlciA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1NwYWNlQWZ0ZXJcIl0pIHx8IDA7XG4gICAgICAgICAgY29uc3QgcmF3VHJhY2tpbmcgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9UcmFja2luZ1wiXSkgfHwgMDtcbiAgICAgICAgICBjb25zdCByYXdLZXJuaW5nID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfS2VybmluZ1wiXSkgfHwgMDtcblxuICAgICAgICAgIC8vIEZJWEVEOiBDcmVhdGUgYmFzZSBzdHlsZSBvYmplY3Qgd2l0aCByYXcgdmFsdWVzXG4gICAgICAgICAgY29uc3QgYmFzZVN0eWxlID0ge1xuICAgICAgICAgICAgc2VsZjogc3R5bGVbXCJAX1NlbGZcIl0sXG4gICAgICAgICAgICBuYW1lOiBzdHlsZVtcIkBfTmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgICAgZm9udFN0eWxlOiBzdHlsZVtcIkBfRm9udFN0eWxlXCJdIHx8IFwiUmVndWxhclwiLFxuICAgICAgICAgICAgcG9pbnRTaXplOiBmb250U2l6ZSxcbiAgICAgICAgICAgIGxlYWRpbmc6IHByb2Nlc3NlZExlYWRpbmcsXG4gICAgICAgICAgICBsZWFkaW5nVHlwZTogdGhpcy5kZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSxcbiAgICAgICAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IHRoaXMuY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkTGVhZGluZyxcbiAgICAgICAgICAgICAgZm9udFNpemVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IHN0eWxlW1wiQF9KdXN0aWZpY2F0aW9uXCJdIHx8IFwiTGVmdEFsaWduXCIsXG5cbiAgICAgICAgICAgIC8vIFJhdyBtZWFzdXJlbWVudHMgKHdpbGwgYmUgY29udmVydGVkIHRvIHBpeGVscylcbiAgICAgICAgICAgIGxlZnRJbmRlbnQ6IHJhd0xlZnRJbmRlbnQsXG4gICAgICAgICAgICByaWdodEluZGVudDogcmF3UmlnaHRJbmRlbnQsXG4gICAgICAgICAgICBmaXJzdExpbmVJbmRlbnQ6IHJhd0ZpcnN0TGluZUluZGVudCxcbiAgICAgICAgICAgIHNwYWNlQmVmb3JlOiByYXdTcGFjZUJlZm9yZSxcbiAgICAgICAgICAgIHNwYWNlQWZ0ZXI6IHJhd1NwYWNlQWZ0ZXIsXG4gICAgICAgICAgICB0cmFja2luZzogcmF3VHJhY2tpbmcsXG4gICAgICAgICAgICBrZXJuaW5nOiByYXdLZXJuaW5nLFxuXG4gICAgICAgICAgICAvLyBTdG9yZSBvcmlnaW5hbCB2YWx1ZXMgZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgb3JpZ2luYWxMZWZ0SW5kZW50OiByYXdMZWZ0SW5kZW50LFxuICAgICAgICAgICAgb3JpZ2luYWxSaWdodEluZGVudDogcmF3UmlnaHRJbmRlbnQsXG4gICAgICAgICAgICBvcmlnaW5hbEZpcnN0TGluZUluZGVudDogcmF3Rmlyc3RMaW5lSW5kZW50LFxuICAgICAgICAgICAgb3JpZ2luYWxTcGFjZUJlZm9yZTogcmF3U3BhY2VCZWZvcmUsXG4gICAgICAgICAgICBvcmlnaW5hbFNwYWNlQWZ0ZXI6IHJhd1NwYWNlQWZ0ZXIsXG4gICAgICAgICAgICBvcmlnaW5hbFRyYWNraW5nOiByYXdUcmFja2luZyxcbiAgICAgICAgICAgIG9yaWdpbmFsS2VybmluZzogcmF3S2VybmluZyxcblxuICAgICAgICAgICAgaG9yaXpvbnRhbFNjYWxlOiBwYXJzZUZsb2F0KHN0eWxlW1wiQF9Ib3Jpem9udGFsU2NhbGVcIl0pIHx8IDEwMCxcbiAgICAgICAgICAgIHZlcnRpY2FsU2NhbGU6IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1ZlcnRpY2FsU2NhbGVcIl0pIHx8IDEwMCxcblxuICAgICAgICAgICAgLy8gRU5IQU5DRUQ6IFVzZSB0aGUgbmV3IGV4dHJhY3Rpb24gbWV0aG9kXG4gICAgICAgICAgICBhcHBsaWVkRm9udDogZm9udFJlZixcbiAgICAgICAgICAgIG9yaWdpbmFsRm9udFJlZjogZm9udFJlZixcblxuICAgICAgICAgICAgZmlsbENvbG9yOiBzdHlsZVtcIkBfRmlsbENvbG9yXCJdIHx8IFwiQ29sb3IvQmxhY2tcIixcbiAgICAgICAgICAgIHJhd1N0eWxlOiBzdHlsZSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gRklYRUQ6IEFwcGx5IHVuaXQgY29udmVyc2lvbiB0byBjcmVhdGUgcGl4ZWwtY29udmVydGVkIHN0eWxlXG4gICAgICAgICAgdGhpcy5zdHlsZXMucGFyYWdyYXBoW3N0eWxlW1wiQF9TZWxmXCJdXSA9XG4gICAgICAgICAgICB0aGlzLmNvbnZlcnRTdHlsZU1lYXN1cmVtZW50c1RvUGl4ZWxzKGJhc2VTdHlsZSk7XG5cbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGDinIUgUGFyYWdyYXBoIFN0eWxlOiAke3N0eWxlW1wiQF9OYW1lXCJdfSAtPiBGb250OiBcIiR7Zm9udFJlZn1cImBcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwLlBhcmFncmFwaFN0eWxlR3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3ViR3JvdXBzID0gQXJyYXkuaXNBcnJheShncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwKVxuICAgICAgICAgID8gZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cFxuICAgICAgICAgIDogW2dyb3VwLlBhcmFncmFwaFN0eWxlR3JvdXBdO1xuICAgICAgICBzdWJHcm91cHMuZm9yRWFjaChleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkoc3R5bGVHcm91cCk7XG4gIH1cblxuICBleHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSkge1xuICAgIC8vIFRyeSBkaXJlY3QgYXR0cmlidXRlcyBmaXJzdFxuICAgIGxldCBmb250UmVmID1cbiAgICAgIHN0eWxlW1wiQF9BcHBsaWVkRm9udFwiXSB8fCBzdHlsZVtcIkBfRm9udEZhbWlseVwiXSB8fCBzdHlsZVtcIkBfRm9udFwiXSB8fCBcIlwiO1xuXG4gICAgLy8gSWYgbm90IGZvdW5kLCB0cnkgUHJvcGVydGllcyBuZXN0ZWQgc3RydWN0dXJlXG4gICAgaWYgKCFmb250UmVmICYmIHN0eWxlLlByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250KSB7XG4gICAgICAgIGZvbnRSZWYgPVxuICAgICAgICAgIHN0eWxlLlByb3BlcnRpZXMuQXBwbGllZEZvbnRbXCIjdGV4dFwiXSB8fFxuICAgICAgICAgIHN0eWxlLlByb3BlcnRpZXMuQXBwbGllZEZvbnQgfHxcbiAgICAgICAgICBcIlwiO1xuICAgICAgfVxuXG4gICAgICAvLyBBbHNvIHRyeSBvdGhlciBwcm9wZXJ0eSB2YXJpYXRpb25zXG4gICAgICBpZiAoIWZvbnRSZWYgJiYgc3R5bGUuUHJvcGVydGllcy5Gb250RmFtaWx5KSB7XG4gICAgICAgIGZvbnRSZWYgPVxuICAgICAgICAgIHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseVtcIiN0ZXh0XCJdIHx8XG4gICAgICAgICAgc3R5bGUuUHJvcGVydGllcy5Gb250RmFtaWx5IHx8XG4gICAgICAgICAgXCJcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm9udFJlZiB8fCBcIlwiO1xuICB9XG5cbiAgZXh0cmFjdENoYXJhY3RlclN0eWxlcyhzdHlsZUdyb3VwKSB7XG4gICAgY29uc3QgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5ID0gKGdyb3VwKSA9PiB7XG4gICAgICBpZiAoZ3JvdXAuQ2hhcmFjdGVyU3R5bGUpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gQXJyYXkuaXNBcnJheShncm91cC5DaGFyYWN0ZXJTdHlsZSlcbiAgICAgICAgICA/IGdyb3VwLkNoYXJhY3RlclN0eWxlXG4gICAgICAgICAgOiBbZ3JvdXAuQ2hhcmFjdGVyU3R5bGVdO1xuXG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvbnRSZWYgPSB0aGlzLmV4dHJhY3RGb250RnJvbVN0eWxlKHN0eWxlKTtcblxuICAgICAgICAgIHRoaXMuc3R5bGVzLmNoYXJhY3RlcltzdHlsZVtcIkBfU2VsZlwiXV0gPSB7XG4gICAgICAgICAgICBzZWxmOiBzdHlsZVtcIkBfU2VsZlwiXSxcbiAgICAgICAgICAgIG5hbWU6IHN0eWxlW1wiQF9OYW1lXCJdIHx8IFwiXCIsXG4gICAgICAgICAgICBmb250U3R5bGU6IHN0eWxlW1wiQF9Gb250U3R5bGVcIl0gfHwgXCJSZWd1bGFyXCIsXG4gICAgICAgICAgICBwb2ludFNpemU6IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1BvaW50U2l6ZVwiXSkgfHwgbnVsbCxcblxuICAgICAgICAgICAgYXBwbGllZEZvbnQ6IGZvbnRSZWYsXG4gICAgICAgICAgICBvcmlnaW5hbEZvbnRSZWY6IGZvbnRSZWYsXG5cbiAgICAgICAgICAgIGZpbGxDb2xvcjogc3R5bGVbXCJAX0ZpbGxDb2xvclwiXSB8fCBudWxsLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHN0eWxlW1wiQF9TdHJva2VDb2xvclwiXSB8fCBudWxsLFxuICAgICAgICAgICAgcmF3U3R5bGU6IHN0eWxlLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGDinIUgQ2hhcmFjdGVyIFN0eWxlOiAke3N0eWxlW1wiQF9OYW1lXCJdfSAtPiBGb250OiBcIiR7Zm9udFJlZn1cImBcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3ViR3JvdXBzID0gQXJyYXkuaXNBcnJheShncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwKVxuICAgICAgICAgID8gZ3JvdXAuQ2hhcmFjdGVyU3R5bGVHcm91cFxuICAgICAgICAgIDogW2dyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXBdO1xuICAgICAgICBzdWJHcm91cHMuZm9yRWFjaChleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkoc3R5bGVHcm91cCk7XG4gIH1cblxuICBhc3luYyBleHRyYWN0Rm9udHMoZm9udHNEYXRhKSB7XG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIGZvbnRzIHdpdGggZW5oYW5jZWQgbWFwcGluZy4uLlwiKTtcblxuICAgIGNvbnN0IGZvbnRzID0gZm9udHNEYXRhLkZvbnRzIHx8IGZvbnRzRGF0YTtcbiAgICB0aGlzLnJlc291cmNlcy5mb250cyA9IHt9O1xuICAgIHRoaXMuZm9udE1hcCA9IG5ldyBNYXAoKTsgLy8gR2xvYmFsIGZvbnQgbG9va3VwIG1hcFxuXG4gICAgaWYgKGZvbnRzLkZvbnRGYW1pbHkpIHtcbiAgICAgIGNvbnN0IGZvbnRGYW1pbGllcyA9IEFycmF5LmlzQXJyYXkoZm9udHMuRm9udEZhbWlseSlcbiAgICAgICAgPyBmb250cy5Gb250RmFtaWx5XG4gICAgICAgIDogW2ZvbnRzLkZvbnRGYW1pbHldO1xuXG4gICAgICBmb250RmFtaWxpZXMuZm9yRWFjaCgoZmFtaWx5KSA9PiB7XG4gICAgICAgIGNvbnN0IGZhbWlseUluZm8gPSB7XG4gICAgICAgICAgc2VsZjogZmFtaWx5W1wiQF9TZWxmXCJdLFxuICAgICAgICAgIG5hbWU6IGZhbWlseVtcIkBfTmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgIGZvbnRzOiBbXSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZmFtaWx5LkZvbnQpIHtcbiAgICAgICAgICBjb25zdCBmb250TGlzdCA9IEFycmF5LmlzQXJyYXkoZmFtaWx5LkZvbnQpXG4gICAgICAgICAgICA/IGZhbWlseS5Gb250XG4gICAgICAgICAgICA6IFtmYW1pbHkuRm9udF07XG5cbiAgICAgICAgICBmb250TGlzdC5mb3JFYWNoKChmb250KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb250SW5mbyA9IHtcbiAgICAgICAgICAgICAgc2VsZjogZm9udFtcIkBfU2VsZlwiXSxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogZm9udFtcIkBfRm9udEZhbWlseVwiXSB8fCBmYW1pbHlJbmZvLm5hbWUsXG4gICAgICAgICAgICAgIG5hbWU6IGZvbnRbXCJAX05hbWVcIl0gfHwgXCJcIixcbiAgICAgICAgICAgICAgcG9zdFNjcmlwdE5hbWU6IGZvbnRbXCJAX1Bvc3RTY3JpcHROYW1lXCJdIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHN0YXR1czogZm9udFtcIkBfU3RhdHVzXCJdIHx8IFwiVW5rbm93blwiLFxuICAgICAgICAgICAgICBmb250U3R5bGVOYW1lOiBmb250W1wiQF9Gb250U3R5bGVOYW1lXCJdIHx8IFwiUmVndWxhclwiLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZmFtaWx5SW5mby5mb250cy5wdXNoKGZvbnRJbmZvKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIG11bHRpcGxlIGxvb2t1cCBlbnRyaWVzIGZvciB0aGlzIGZvbnRcbiAgICAgICAgICAgIHRoaXMuZm9udE1hcC5zZXQoZm9udFtcIkBfU2VsZlwiXSwgZmFtaWx5SW5mby5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZm9udE1hcC5zZXQoZm9udFtcIkBfUG9zdFNjcmlwdE5hbWVcIl0sIGZhbWlseUluZm8ubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX05hbWVcIl0sIGZhbWlseUluZm8ubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX0ZvbnRGYW1pbHlcIl0sIGZhbWlseUluZm8ubmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBgRm9udCBtYXBwaW5nOiAke2ZvbnRbXCJAX1NlbGZcIl19IC0+ICR7ZmFtaWx5SW5mby5uYW1lfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc291cmNlcy5mb250c1tmYW1pbHlbXCJAX1NlbGZcIl1dID0gZmFtaWx5SW5mbztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYOKchSBGb250cyBleHRyYWN0ZWQ6ICR7T2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuZm9udHMpLmxlbmd0aH0gZmFtaWxpZXNgXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhgRm9udCBtYXAgZW50cmllczogJHt0aGlzLmZvbnRNYXAuc2l6ZX1gKTtcbiAgfVxuXG4gIGFzeW5jIGV4dHJhY3RHcmFwaGljcyhncmFwaGljc0RhdGEpIHtcbiAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3RpbmcgZ3JhcGhpY3MgYW5kIGNvbG9ycy4uLlwiKTtcblxuICAgIGNvbnN0IGdyYXBoaWNzID0gZ3JhcGhpY3NEYXRhLkdyYXBoaWMgfHwgZ3JhcGhpY3NEYXRhO1xuICAgIHRoaXMucmVzb3VyY2VzLmNvbG9ycyA9IHt9O1xuICAgIHRoaXMucmVzb3VyY2VzLmdyYWRpZW50cyA9IHt9O1xuXG4gICAgLy8gRXh0cmFjdCBDb2xvcnNcbiAgICBpZiAoZ3JhcGhpY3MuQ29sb3IpIHtcbiAgICAgIGNvbnN0IGNvbG9ycyA9IEFycmF5LmlzQXJyYXkoZ3JhcGhpY3MuQ29sb3IpXG4gICAgICAgID8gZ3JhcGhpY3MuQ29sb3JcbiAgICAgICAgOiBbZ3JhcGhpY3MuQ29sb3JdO1xuXG4gICAgICBjb2xvcnMuZm9yRWFjaCgoY29sb3IpID0+IHtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuY29sb3JzW2NvbG9yW1wiQF9TZWxmXCJdXSA9IHtcbiAgICAgICAgICBzZWxmOiBjb2xvcltcIkBfU2VsZlwiXSxcbiAgICAgICAgICBuYW1lOiBjb2xvcltcIkBfTmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgIG1vZGVsOiBjb2xvcltcIkBfTW9kZWxcIl0gfHwgXCJQcm9jZXNzXCIsXG4gICAgICAgICAgc3BhY2U6IGNvbG9yW1wiQF9TcGFjZVwiXSB8fCBcIkNNWUtcIixcbiAgICAgICAgICBjeWFuOiBwYXJzZUZsb2F0KGNvbG9yW1wiQF9DeWFuXCJdKSB8fCAwLFxuICAgICAgICAgIG1hZ2VudGE6IHBhcnNlRmxvYXQoY29sb3JbXCJAX01hZ2VudGFcIl0pIHx8IDAsXG4gICAgICAgICAgeWVsbG93OiBwYXJzZUZsb2F0KGNvbG9yW1wiQF9ZZWxsb3dcIl0pIHx8IDAsXG4gICAgICAgICAgYmxhY2s6IHBhcnNlRmxvYXQoY29sb3JbXCJAX0JsYWNrXCJdKSB8fCAwLFxuICAgICAgICAgIHJlZDogcGFyc2VGbG9hdChjb2xvcltcIkBfUmVkXCJdKSB8fCAwLFxuICAgICAgICAgIGdyZWVuOiBwYXJzZUZsb2F0KGNvbG9yW1wiQF9HcmVlblwiXSkgfHwgMCxcbiAgICAgICAgICBibHVlOiBwYXJzZUZsb2F0KGNvbG9yW1wiQF9CbHVlXCJdKSB8fCAwLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBHcmFkaWVudHNcbiAgICBpZiAoZ3JhcGhpY3MuR3JhZGllbnQpIHtcbiAgICAgIGNvbnN0IGdyYWRpZW50cyA9IEFycmF5LmlzQXJyYXkoZ3JhcGhpY3MuR3JhZGllbnQpXG4gICAgICAgID8gZ3JhcGhpY3MuR3JhZGllbnRcbiAgICAgICAgOiBbZ3JhcGhpY3MuR3JhZGllbnRdO1xuXG4gICAgICBncmFkaWVudHMuZm9yRWFjaCgoZ3JhZGllbnQpID0+IHtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZ3JhZGllbnRzW2dyYWRpZW50W1wiQF9TZWxmXCJdXSA9IHtcbiAgICAgICAgICBzZWxmOiBncmFkaWVudFtcIkBfU2VsZlwiXSxcbiAgICAgICAgICBuYW1lOiBncmFkaWVudFtcIkBfTmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgIHR5cGU6IGdyYWRpZW50W1wiQF9UeXBlXCJdIHx8IFwiTGluZWFyXCIsXG4gICAgICAgICAgZ3JhZGllbnRTdG9wczogdGhpcy5leHRyYWN0R3JhZGllbnRTdG9wcyhncmFkaWVudCksXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBleHRyYWN0R3JhZGllbnRTdG9wcyhncmFkaWVudCkge1xuICAgIGNvbnN0IHN0b3BzID0gW107XG5cbiAgICBpZiAoZ3JhZGllbnQuR3JhZGllbnRTdG9wKSB7XG4gICAgICBjb25zdCBzdG9wTGlzdCA9IEFycmF5LmlzQXJyYXkoZ3JhZGllbnQuR3JhZGllbnRTdG9wKVxuICAgICAgICA/IGdyYWRpZW50LkdyYWRpZW50U3RvcFxuICAgICAgICA6IFtncmFkaWVudC5HcmFkaWVudFN0b3BdO1xuXG4gICAgICBzdG9wTGlzdC5mb3JFYWNoKChzdG9wKSA9PiB7XG4gICAgICAgIHN0b3BzLnB1c2goe1xuICAgICAgICAgIHNlbGY6IHN0b3BbXCJAX1NlbGZcIl0sXG4gICAgICAgICAgc3RvcENvbG9yOiBzdG9wW1wiQF9TdG9wQ29sb3JcIl0gfHwgXCJcIixcbiAgICAgICAgICBsb2NhdGlvbjogcGFyc2VGbG9hdChzdG9wW1wiQF9Mb2NhdGlvblwiXSkgfHwgMCxcbiAgICAgICAgICBtaWRwb2ludDogcGFyc2VGbG9hdChzdG9wW1wiQF9NaWRwb2ludFwiXSkgfHwgNTAsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3BzO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdFByZWZlcmVuY2VzKHByZWZlcmVuY2VzRGF0YSkge1xuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBkb2N1bWVudCBwcmVmZXJlbmNlcy4uLlwiKTtcblxuICAgIGNvbnN0IHByZWZzID0gcHJlZmVyZW5jZXNEYXRhLlByZWZlcmVuY2VzIHx8IHByZWZlcmVuY2VzRGF0YTtcblxuICAgIC8vIEV4dHJhY3QgdmFyaW91cyBkb2N1bWVudCBwcmVmZXJlbmNlc1xuICAgIHRoaXMuZG9jdW1lbnRJbmZvID0ge1xuICAgICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgZG9jdW1lbnRQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0RG9jdW1lbnRQcmVmcyhcbiAgICAgICAgICBwcmVmcy5Eb2N1bWVudFByZWZlcmVuY2VcbiAgICAgICAgKSxcbiAgICAgICAgdmlld1ByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RWaWV3UHJlZnMocHJlZnMuVmlld1ByZWZlcmVuY2UpLFxuICAgICAgICBndWlkZVByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RHdWlkZVByZWZzKHByZWZzLkd1aWRlUHJlZmVyZW5jZSksXG4gICAgICAgIGdyaWRQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0R3JpZFByZWZzKHByZWZzLkdyaWRQcmVmZXJlbmNlKSxcbiAgICAgICAgbWFyZ2luUHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdE1hcmdpblByZWZzKHByZWZzLk1hcmdpblByZWZlcmVuY2UpLFxuICAgICAgICBjb2x1bW5QcmVmZXJlbmNlczogdGhpcy5leHRyYWN0Q29sdW1uUHJlZnMocHJlZnMuQ29sdW1uUHJlZmVyZW5jZSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBleHRyYWN0RG9jdW1lbnRQcmVmcyhkb2NQcmVmKSB7XG4gICAgaWYgKCFkb2NQcmVmKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVdpZHRoOiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX1BhZ2VXaWR0aFwiXSkgfHwgMCxcbiAgICAgIHBhZ2VIZWlnaHQ6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfUGFnZUhlaWdodFwiXSkgfHwgMCxcbiAgICAgIGxlZnQ6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfTGVmdFwiXSkgfHwgMCxcbiAgICAgIHRvcDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Ub3BcIl0pIHx8IDAsXG4gICAgICByaWdodDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9SaWdodFwiXSkgfHwgMCxcbiAgICAgIGJvdHRvbTogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Cb3R0b21cIl0pIHx8IDAsXG4gICAgICBjb2x1bW5Db3VudDogcGFyc2VJbnQoZG9jUHJlZltcIkBfQ29sdW1uQ291bnRcIl0pIHx8IDEsXG4gICAgICBjb2x1bW5HdXR0ZXI6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfQ29sdW1uR3V0dGVyXCJdKSB8fCAwLFxuICAgICAgZmFjaW5nUGFnZXM6IGRvY1ByZWZbXCJAX0ZhY2luZ1BhZ2VzXCJdID09PSB0cnVlLFxuICAgICAgYWxsb3dQYWdlU2h1ZmZsZTogZG9jUHJlZltcIkBfQWxsb3dQYWdlU2h1ZmZsZVwiXSAhPT0gZmFsc2UsXG4gICAgICBzbHVnQmxlZWRUeXBlOiBkb2NQcmVmW1wiQF9TbHVnQmxlZWRUeXBlXCJdIHx8IFwiTm9uZVwiLFxuICAgICAgZG9jdW1lbnRCbGVlZFRvcE9mZnNldDpcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkVG9wT2Zmc2V0XCJdKSB8fCAwLFxuICAgICAgZG9jdW1lbnRCbGVlZEJvdHRvbU9mZnNldDpcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkQm90dG9tT2Zmc2V0XCJdKSB8fCAwLFxuICAgICAgZG9jdW1lbnRCbGVlZEluc2lkZU9yTGVmdE9mZnNldDpcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0XCJdKSB8fCAwLFxuICAgICAgZG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0OlxuICAgICAgICBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0RvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldFwiXSkgfHwgMCxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdFZpZXdQcmVmcyh2aWV3UHJlZikge1xuICAgIGlmICghdmlld1ByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICBob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0czpcbiAgICAgICAgdmlld1ByZWZbXCJAX0hvcml6b250YWxNZWFzdXJlbWVudFVuaXRzXCJdIHx8IFwiUG9pbnRzXCIsXG4gICAgICB2ZXJ0aWNhbE1lYXN1cmVtZW50VW5pdHM6XG4gICAgICAgIHZpZXdQcmVmW1wiQF9WZXJ0aWNhbE1lYXN1cmVtZW50VW5pdHNcIl0gfHwgXCJQb2ludHNcIixcbiAgICAgIHJ1bGVyT3JpZ2luOiB2aWV3UHJlZltcIkBfUnVsZXJPcmlnaW5cIl0gfHwgXCJTcHJlYWRPcmlnaW5cIixcbiAgICAgIHNob3dSdWxlcnM6IHZpZXdQcmVmW1wiQF9TaG93UnVsZXJzXCJdICE9PSBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdEd1aWRlUHJlZnMoZ3VpZGVQcmVmKSB7XG4gICAgaWYgKCFndWlkZVByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICBydWxlckd1aWRlQ29sb3I6IGd1aWRlUHJlZltcIkBfUnVsZXJHdWlkZUNvbG9yXCJdIHx8IFwiR3JlZW5cIixcbiAgICAgIGd1aWRlc0luQmFjazogZ3VpZGVQcmVmW1wiQF9HdWlkZXNJbkJhY2tcIl0gPT09IHRydWUsXG4gICAgICBndWlkZXNMb2NrZWQ6IGd1aWRlUHJlZltcIkBfR3VpZGVzTG9ja2VkXCJdID09PSB0cnVlLFxuICAgICAgZ3VpZGVzU2hvd246IGd1aWRlUHJlZltcIkBfR3VpZGVzU2hvd25cIl0gIT09IGZhbHNlLFxuICAgICAgZ3VpZGVzU25hcHRvOiBndWlkZVByZWZbXCJAX0d1aWRlc1NuYXB0b1wiXSAhPT0gZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGV4dHJhY3RHcmlkUHJlZnMoZ3JpZFByZWYpIHtcbiAgICBpZiAoIWdyaWRQcmVmKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZWxpbmVTdGFydDogcGFyc2VGbG9hdChncmlkUHJlZltcIkBfQmFzZWxpbmVTdGFydFwiXSkgfHwgMCxcbiAgICAgIGJhc2VsaW5lRGl2aXNpb246IHBhcnNlRmxvYXQoZ3JpZFByZWZbXCJAX0Jhc2VsaW5lRGl2aXNpb25cIl0pIHx8IDEyLFxuICAgICAgYmFzZWxpbmVTaG93bjogZ3JpZFByZWZbXCJAX0Jhc2VsaW5lU2hvd25cIl0gPT09IHRydWUsXG4gICAgICBiYXNlbGluZVNuYXB0bzogZ3JpZFByZWZbXCJAX0Jhc2VsaW5lU25hcHRvXCJdID09PSB0cnVlLFxuICAgICAgZG9jdW1lbnRHcmlkU2hvd246IGdyaWRQcmVmW1wiQF9Eb2N1bWVudEdyaWRTaG93blwiXSA9PT0gdHJ1ZSxcbiAgICAgIGRvY3VtZW50R3JpZFNuYXB0bzogZ3JpZFByZWZbXCJAX0RvY3VtZW50R3JpZFNuYXB0b1wiXSA9PT0gdHJ1ZSxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdE1hcmdpblByZWZzKG1hcmdpblByZWYpIHtcbiAgICBpZiAoIW1hcmdpblByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfVG9wXCJdKSB8fCAwLFxuICAgICAgYm90dG9tOiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX0JvdHRvbVwiXSkgfHwgMCxcbiAgICAgIGxlZnQ6IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfTGVmdFwiXSkgfHwgMCxcbiAgICAgIHJpZ2h0OiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX1JpZ2h0XCJdKSB8fCAwLFxuICAgICAgY29sdW1uQ291bnQ6IHBhcnNlSW50KG1hcmdpblByZWZbXCJAX0NvbHVtbkNvdW50XCJdKSB8fCAxLFxuICAgICAgY29sdW1uR3V0dGVyOiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX0NvbHVtbkd1dHRlclwiXSkgfHwgMCxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdENvbHVtblByZWZzKGNvbHVtblByZWYpIHtcbiAgICBpZiAoIWNvbHVtblByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0Q29sdW1uQ291bnQ6IHBhcnNlSW50KGNvbHVtblByZWZbXCJAX1RleHRDb2x1bW5Db3VudFwiXSkgfHwgMSxcbiAgICAgIHRleHRDb2x1bW5HdXR0ZXI6IHBhcnNlRmxvYXQoY29sdW1uUHJlZltcIkBfVGV4dENvbHVtbkd1dHRlclwiXSkgfHwgMCxcbiAgICB9O1xuICB9XG5cbiAgcmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB7IC4uLmZvcm1hdHRpbmcgfTtcblxuICAgIC8vIERFQlVHOiBDaGVjayBpZiBmb3JtYXR0aW5nIGlzIGJlaW5nIGFwcGxpZWQgKGdlbmVyaWMgY2hlY2spXG4gICAgY29uc3QgaGFzQW55Rm9ybWF0dGluZyA9XG4gICAgICBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlIHx8XG4gICAgICBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlIHx8XG4gICAgICBmb3JtYXR0aW5nLmZvbnRTdHlsZSB8fFxuICAgICAgZm9ybWF0dGluZy5mb250UmVmZXJlbmNlIHx8XG4gICAgICBmb3JtYXR0aW5nLmZvbnRTaXplO1xuXG4gICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBTdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nIC0gSW5wdXQ6XCIsIHtcbiAgICAgICAgcGFyYWdyYXBoU3R5bGU6IGZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGUsXG4gICAgICAgIGNoYXJhY3RlclN0eWxlOiBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlLFxuICAgICAgICBkaXJlY3RGb250U3R5bGU6IGZvcm1hdHRpbmcuZm9udFN0eWxlLFxuICAgICAgICBkaXJlY3RGb250UmVmOiBmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UsXG4gICAgICAgIGRpcmVjdEZvbnRTaXplOiBmb3JtYXR0aW5nLmZvbnRTaXplLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVzb2x2ZSBwYXJhZ3JhcGggc3R5bGUgKGJhc2UgbGF5ZXIpXG4gICAgaWYgKFxuICAgICAgZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSAmJlxuICAgICAgdGhpcy5zdHlsZXMucGFyYWdyYXBoW2Zvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVdXG4gICAgKSB7XG4gICAgICBjb25zdCBwU3R5bGUgPSB0aGlzLnN0eWxlcy5wYXJhZ3JhcGhbZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZV07XG5cbiAgICAgIGlmICghcmVzb2x2ZWQuZm9udFNpemUgJiYgcFN0eWxlLnBvaW50U2l6ZSlcbiAgICAgICAgcmVzb2x2ZWQuZm9udFNpemUgPSBwU3R5bGUucG9pbnRTaXplO1xuICAgICAgaWYgKCFyZXNvbHZlZC5maWxsQ29sb3IgJiYgcFN0eWxlLmZpbGxDb2xvcilcbiAgICAgICAgcmVzb2x2ZWQuZmlsbENvbG9yID0gcFN0eWxlLmZpbGxDb2xvcjtcbiAgICAgIC8vIENSSVRJQ0FMIEZJWDogQWx3YXlzIGluaGVyaXQgcGFyYWdyYXBoIGFsaWdubWVudCB1bmxlc3MgZXhwbGljaXRseSBvdmVycmlkZGVuXG4gICAgICBpZiAocFN0eWxlLmFsaWdubWVudCkgcmVzb2x2ZWQuYWxpZ25tZW50ID0gcFN0eWxlLmFsaWdubWVudDtcbiAgICAgIGlmICghcmVzb2x2ZWQuZm9udFN0eWxlICYmIHBTdHlsZS5mb250U3R5bGUpIHtcbiAgICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gcFN0eWxlLmZvbnRTdHlsZTtcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGAgICBGb250U3R5bGUgZnJvbSBwYXJhZ3JhcGggc3R5bGU6IFwiJHtwU3R5bGUuZm9udFN0eWxlfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ1JJVElDQUw6IFJlc29sdmUgZm9udCBmcm9tIHBhcmFncmFwaCBzdHlsZVxuICAgICAgaWYgKCFyZXNvbHZlZC5mb250RmFtaWx5ICYmIHBTdHlsZS5hcHBsaWVkRm9udCkge1xuICAgICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShwU3R5bGUuYXBwbGllZEZvbnQpO1xuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCAgIEZvbnQgZnJvbSBwYXJhZ3JhcGggc3R5bGU6ICR7cFN0eWxlLmFwcGxpZWRGb250fSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIG90aGVyIHBhcmFncmFwaCBwcm9wZXJ0aWVzIHdpdGggZW5oYW5jZWQgbGVhZGluZyBzdXBwb3J0XG4gICAgICByZXNvbHZlZC5sZWFkaW5nID0gcFN0eWxlLmxlYWRpbmc7XG4gICAgICByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IHBTdHlsZS5sZWFkaW5nVHlwZTtcbiAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSBwU3R5bGUuZWZmZWN0aXZlTGluZUhlaWdodDtcbiAgICAgIHJlc29sdmVkLmxlZnRJbmRlbnQgPSBwU3R5bGUubGVmdEluZGVudDtcbiAgICAgIHJlc29sdmVkLnJpZ2h0SW5kZW50ID0gcFN0eWxlLnJpZ2h0SW5kZW50O1xuICAgICAgcmVzb2x2ZWQuZmlyc3RMaW5lSW5kZW50ID0gcFN0eWxlLmZpcnN0TGluZUluZGVudDtcbiAgICAgIHJlc29sdmVkLnNwYWNlQmVmb3JlID0gcFN0eWxlLnNwYWNlQmVmb3JlO1xuICAgICAgcmVzb2x2ZWQuc3BhY2VBZnRlciA9IHBTdHlsZS5zcGFjZUFmdGVyO1xuICAgICAgcmVzb2x2ZWQudHJhY2tpbmcgPSBwU3R5bGUudHJhY2tpbmc7XG4gICAgICByZXNvbHZlZC5rZXJuaW5nID0gcFN0eWxlLmtlcm5pbmc7XG4gICAgfVxuXG4gICAgLy8gUmVzb2x2ZSBjaGFyYWN0ZXIgc3R5bGUgKG92ZXJyaWRlIGxheWVyKVxuICAgIGlmIChcbiAgICAgIGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgJiZcbiAgICAgIHRoaXMuc3R5bGVzLmNoYXJhY3Rlcltmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlXVxuICAgICkge1xuICAgICAgY29uc3QgY1N0eWxlID0gdGhpcy5zdHlsZXMuY2hhcmFjdGVyW2Zvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVdO1xuXG4gICAgICBpZiAoY1N0eWxlLnBvaW50U2l6ZSkgcmVzb2x2ZWQuZm9udFNpemUgPSBjU3R5bGUucG9pbnRTaXplO1xuICAgICAgaWYgKGNTdHlsZS5maWxsQ29sb3IpIHJlc29sdmVkLmZpbGxDb2xvciA9IGNTdHlsZS5maWxsQ29sb3I7XG4gICAgICBpZiAoY1N0eWxlLmZvbnRTdHlsZSkge1xuICAgICAgICByZXNvbHZlZC5mb250U3R5bGUgPSBjU3R5bGUuZm9udFN0eWxlO1xuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCAgIEZvbnRTdHlsZSBmcm9tIGNoYXJhY3RlciBzdHlsZTogXCIke2NTdHlsZS5mb250U3R5bGV9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNTdHlsZS5zdHJva2VDb2xvcikgcmVzb2x2ZWQuc3Ryb2tlQ29sb3IgPSBjU3R5bGUuc3Ryb2tlQ29sb3I7XG5cbiAgICAgIC8vIEluY2x1ZGUgbGVhZGluZyBpbmZvcm1hdGlvbiBmcm9tIGNoYXJhY3RlciBzdHlsZVxuICAgICAgaWYgKGNTdHlsZS5sZWFkaW5nKSByZXNvbHZlZC5sZWFkaW5nID0gY1N0eWxlLmxlYWRpbmc7XG4gICAgICBpZiAoY1N0eWxlLmxlYWRpbmdUeXBlKSByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IGNTdHlsZS5sZWFkaW5nVHlwZTtcbiAgICAgIGlmIChjU3R5bGUuZWZmZWN0aXZlTGluZUhlaWdodClcbiAgICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IGNTdHlsZS5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xuXG4gICAgICAvLyBDUklUSUNBTDogQ2hhcmFjdGVyIHN0eWxlIGZvbnQgb3ZlcnJpZGVzIHBhcmFncmFwaCBzdHlsZVxuICAgICAgaWYgKGNTdHlsZS5hcHBsaWVkRm9udCkge1xuICAgICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShjU3R5bGUuYXBwbGllZEZvbnQpO1xuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCAgIEZvbnQgZnJvbSBjaGFyYWN0ZXIgc3R5bGU6ICR7Y1N0eWxlLmFwcGxpZWRGb250fSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBkaXJlY3QgZm9ybWF0dGluZyAoaGlnaGVzdCBwcmlvcml0eSlcbiAgICBpZiAoZm9ybWF0dGluZy5mb250UmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UpO1xuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYCAgIEZvbnQgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogJHtmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2V9IC0+ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ1JJVElDQUw6IEFwcGx5IGRpcmVjdCBmb250U3R5bGUgaWYgcHJvdmlkZWQgKHRoaXMgbWlnaHQgYmUgdGhlIGlzc3VlKVxuICAgIGlmIChmb3JtYXR0aW5nLmZvbnRTdHlsZSkge1xuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gZm9ybWF0dGluZy5mb250U3R5bGU7XG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgICAgRm9udFN0eWxlIGZyb20gZGlyZWN0IGZvcm1hdHRpbmc6IFwiJHtmb3JtYXR0aW5nLmZvbnRTdHlsZX1cImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBkaXJlY3QgbGVhZGluZyBpbmZvcm1hdGlvbiAoaGlnaGVzdCBwcmlvcml0eSlcbiAgICBpZiAoZm9ybWF0dGluZy5sZWFkaW5nICE9PSB1bmRlZmluZWQpIHJlc29sdmVkLmxlYWRpbmcgPSBmb3JtYXR0aW5nLmxlYWRpbmc7XG4gICAgaWYgKGZvcm1hdHRpbmcubGVhZGluZ1R5cGUpIHJlc29sdmVkLmxlYWRpbmdUeXBlID0gZm9ybWF0dGluZy5sZWFkaW5nVHlwZTtcbiAgICBpZiAoZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0KVxuICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodDtcblxuICAgIC8vIEFwcGx5IG90aGVyIGRpcmVjdCBmb3JtYXR0aW5nIGF0dHJpYnV0ZXNcbiAgICBpZiAoZm9ybWF0dGluZy5mb250U2l6ZSkgcmVzb2x2ZWQuZm9udFNpemUgPSBmb3JtYXR0aW5nLmZvbnRTaXplO1xuICAgIGlmIChmb3JtYXR0aW5nLnRyYWNraW5nKSByZXNvbHZlZC50cmFja2luZyA9IGZvcm1hdHRpbmcudHJhY2tpbmc7XG4gICAgaWYgKGZvcm1hdHRpbmcua2VybmluZykgcmVzb2x2ZWQua2VybmluZyA9IGZvcm1hdHRpbmcua2VybmluZztcblxuICAgIC8vIENSSVRJQ0FMIEZJWDogQXBwbHkgZGlyZWN0IGFsaWdubWVudCBpZiBleHBsaWNpdGx5IHNwZWNpZmllZCAob3ZlcnJpZGVzIHBhcmFncmFwaCBhbGlnbm1lbnQpXG4gICAgaWYgKGZvcm1hdHRpbmcuYWxpZ25tZW50KSB7XG4gICAgICByZXNvbHZlZC5hbGlnbm1lbnQgPSBmb3JtYXR0aW5nLmFsaWdubWVudDtcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgICBBbGlnbm1lbnQgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogXCIke2Zvcm1hdHRpbmcuYWxpZ25tZW50fVwiYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZJWEVEOiBFbnN1cmUgZm9udFN0eWxlIGRlZmF1bHRzIHRvIFJlZ3VsYXIvbm9ybWFsIGlmIG5vdCBzZXRcbiAgICBpZiAoIXJlc29sdmVkLmZvbnRTdHlsZSB8fCByZXNvbHZlZC5mb250U3R5bGUgPT09IFwiXCIpIHtcbiAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IFwiUmVndWxhclwiO1xuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIEZvbnRTdHlsZSBkZWZhdWx0ZWQgdG86IFwiUmVndWxhclwiYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQURESVRJT05BTCBGSVg6IElmIG5vIHN0eWxlcyB3ZXJlIGFwcGxpZWQgZnJvbSBhbnkgc291cmNlLCBlbnN1cmUgY2xlYW4gZGVmYXVsdHNcbiAgICBpZiAoXG4gICAgICAhZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSAmJlxuICAgICAgIWZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgJiZcbiAgICAgICFmb3JtYXR0aW5nLmZvbnRTdHlsZSAmJlxuICAgICAgIWZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZVxuICAgICkge1xuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gXCJSZWd1bGFyXCI7XG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhgICAgTm8gc291cmNlIHN0eWxlcyBmb3VuZCAtIGVuc3VyaW5nIGNsZWFuIGRlZmF1bHRzYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmluYWwgZmFsbGJhY2tcbiAgICBpZiAoIXJlc29sdmVkLmZvbnRGYW1pbHkgfHwgcmVzb2x2ZWQuZm9udEZhbWlseSA9PT0gXCJcIikge1xuICAgICAgcmVzb2x2ZWQuZm9udEZhbWlseSA9IHRoaXMuZ2V0RGVmYXVsdEZvbnQoKTtcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBVc2luZyBmYWxsYmFjayBmb250OiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGxpbmUgaGVpZ2h0IGlzIGNhbGN1bGF0ZWQgaWYgbm90IGV4cGxpY2l0bHkgc2V0XG4gICAgaWYgKFxuICAgICAgIXJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgJiZcbiAgICAgIHJlc29sdmVkLmZvbnRTaXplICYmXG4gICAgICByZXNvbHZlZC5sZWFkaW5nXG4gICAgKSB7XG4gICAgICByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KFxuICAgICAgICByZXNvbHZlZC5sZWFkaW5nLFxuICAgICAgICByZXNvbHZlZC5mb250U2l6ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgY29uc29sZS5sb2coXCLwn5SnIFN0eWxlUGFyc2VyLnJlc29sdmVTdHlsZUZvcm1hdHRpbmcgLSBGaW5hbCBPdXRwdXQ6XCIsIHtcbiAgICAgICAgZm9udFNpemU6IHJlc29sdmVkLmZvbnRTaXplLFxuICAgICAgICBmb250RmFtaWx5OiByZXNvbHZlZC5mb250RmFtaWx5LFxuICAgICAgICBmb250U3R5bGU6IHJlc29sdmVkLmZvbnRTdHlsZSxcbiAgICAgICAgZmlsbENvbG9yOiByZXNvbHZlZC5maWxsQ29sb3IsXG4gICAgICAgIGxlYWRpbmc6IHJlc29sdmVkLmxlYWRpbmcsXG4gICAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cblxuICByZXNvbHZlRm9udFJlZmVyZW5jZShmb250UmVmKSB7XG4gICAgaWYgKCFmb250UmVmIHx8IGZvbnRSZWYgPT09IFwiXCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRW1wdHkgZm9udCByZWZlcmVuY2UsIHVzaW5nIGZhbGxiYWNrXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdEZvbnQoKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgZGlyZWN0IGxvb2t1cCBpbiBmb250IG1hcFxuICAgIGlmICh0aGlzLmZvbnRNYXAgJiYgdGhpcy5mb250TWFwLmhhcyhmb250UmVmKSkge1xuICAgICAgY29uc3QgcmVzb2x2ZWRGb250ID0gdGhpcy5mb250TWFwLmdldChmb250UmVmKTtcbiAgICAgIGNvbnNvbGUubG9nKGBGb250IHJlc29sdmVkOiBcIiR7Zm9udFJlZn1cIiAtPiBcIiR7cmVzb2x2ZWRGb250fVwiYCk7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRGb250O1xuICAgIH1cblxuICAgIC8vIFRyeSBwYXJ0aWFsIG1hdGNoaW5nIGZvciBmb250IGZhbWlsaWVzXG4gICAgaWYgKHRoaXMucmVzb3VyY2VzLmZvbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtmYW1pbHlJZCwgZmFtaWx5SW5mb10gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgIHRoaXMucmVzb3VyY2VzLmZvbnRzXG4gICAgICApKSB7XG4gICAgICAgIC8vIENoZWNrIGZhbWlseSBuYW1lIG1hdGNoXG4gICAgICAgIGlmIChcbiAgICAgICAgICBmYW1pbHlJbmZvLm5hbWUgJiZcbiAgICAgICAgICAoZmFtaWx5SW5mby5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZm9udFJlZi50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICAgICAgZm9udFJlZi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZhbWlseUluZm8ubmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgRm9udCBwYXJ0aWFsbHkgbWF0Y2hlZDogXCIke2ZvbnRSZWZ9XCIgLT4gXCIke2ZhbWlseUluZm8ubmFtZX1cImBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBmYW1pbHlJbmZvLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpbmRpdmlkdWFsIGZvbnQgbWF0Y2hlc1xuICAgICAgICBpZiAoZmFtaWx5SW5mby5mb250cykge1xuICAgICAgICAgIGZvciAoY29uc3QgZm9udCBvZiBmYW1pbHlJbmZvLmZvbnRzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGZvbnQuc2VsZiA9PT0gZm9udFJlZiB8fFxuICAgICAgICAgICAgICBmb250LnBvc3RTY3JpcHROYW1lID09PSBmb250UmVmIHx8XG4gICAgICAgICAgICAgIGZvbnQubmFtZSA9PT0gZm9udFJlZlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIGBGb250IGV4YWN0bHkgbWF0Y2hlZDogXCIke2ZvbnRSZWZ9XCIgLT4gXCIke2ZhbWlseUluZm8ubmFtZX1cImBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbWlseUluZm8ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgRm9udCBub3QgZm91bmQ6IFwiJHtmb250UmVmfVwiLCB1c2luZyBmYWxsYmFja2ApO1xuICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRGb250KCkgfHwgZm9udFJlZjtcbiAgfVxuXG4gIGdldERlZmF1bHRGb250KCkge1xuICAgIGlmICh0aGlzLnJlc291cmNlcy5mb250cyAmJiBPYmplY3Qua2V5cyh0aGlzLnJlc291cmNlcy5mb250cykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RGYW1pbHkgPSBPYmplY3QudmFsdWVzKHRoaXMucmVzb3VyY2VzLmZvbnRzKVswXTtcbiAgICAgIHJldHVybiBmaXJzdEZhbWlseS5uYW1lIHx8IFwiQXJpYWxcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiQXJpYWxcIjtcbiAgfVxuXG4gIGluZmVyRm9udEZyb21Db250ZXh0KCkge1xuICAgIC8vIElmIHdlIGhhdmUgZm9udCBkZWZpbml0aW9ucyBidXQgbm8gZXhwbGljaXQgcmVmZXJlbmNlcyxcbiAgICAvLyByZXR1cm4gdGhlIGZpcnN0IGF2YWlsYWJsZSBmb250IGFzIGEgZmFsbGJhY2tcbiAgICBpZiAodGhpcy5yZXNvdXJjZXMuZm9udHMgJiYgT2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuZm9udHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0Rm9udEZhbWlseSA9IE9iamVjdC52YWx1ZXModGhpcy5yZXNvdXJjZXMuZm9udHMpWzBdO1xuICAgICAgcmV0dXJuIGZpcnN0Rm9udEZhbWlseS5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFN0b3J5U3R5bGVTdW1tYXJ5KHN0b3J5KSB7XG4gICAgY29uc3Qgc3VtbWFyeSA9IHtcbiAgICAgIGZvbnRTaXplOiBudWxsLFxuICAgICAgZm9udEZhbWlseTogbnVsbCxcbiAgICAgIGFsaWdubWVudDogbnVsbCxcbiAgICAgIGZpbGxDb2xvcjogbnVsbCxcbiAgICAgIGZvbnRTdHlsZTogbnVsbCxcbiAgICAgIGxlYWRpbmc6IG51bGwsXG4gICAgICBsZWFkaW5nVHlwZTogbnVsbCxcbiAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IG51bGwsXG4gICAgICB0cmFja2luZzogbnVsbCxcbiAgICAgIGtlcm5pbmc6IG51bGwsXG4gICAgfTtcblxuICAgIC8vIEdldCB0aGUgbW9zdCBjb21tb24gb3IgZmlyc3QgZm9ybWF0dGluZyB2YWx1ZXNcbiAgICBpZiAoc3RvcnkuY29udGVudD8uZm9ybWF0dGVkQ29udGVudD8ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RGb3JtYXR0ZWQgPSBzdG9yeS5jb250ZW50LmZvcm1hdHRlZENvbnRlbnQuZmluZChcbiAgICAgICAgKGl0ZW0pID0+IGl0ZW0uZm9ybWF0dGluZyAmJiAhaXRlbS5mb3JtYXR0aW5nLmlzQnJlYWtcbiAgICAgICk7XG5cbiAgICAgIGlmIChmaXJzdEZvcm1hdHRlZD8uZm9ybWF0dGluZykge1xuICAgICAgICBjb25zdCBmbXQgPSBmaXJzdEZvcm1hdHRlZC5mb3JtYXR0aW5nO1xuICAgICAgICBzdW1tYXJ5LmZvbnRTaXplID0gZm10LmZvbnRTaXplO1xuICAgICAgICBzdW1tYXJ5LmZvbnRGYW1pbHkgPSBmbXQuZm9udEZhbWlseTtcbiAgICAgICAgc3VtbWFyeS5hbGlnbm1lbnQgPSBmbXQuYWxpZ25tZW50O1xuICAgICAgICBzdW1tYXJ5LmZpbGxDb2xvciA9IGZtdC5maWxsQ29sb3I7XG4gICAgICAgIHN1bW1hcnkuZm9udFN0eWxlID0gZm10LmZvbnRTdHlsZTtcbiAgICAgICAgc3VtbWFyeS5sZWFkaW5nID0gZm10LmxlYWRpbmc7XG4gICAgICAgIHN1bW1hcnkubGVhZGluZ1R5cGUgPSBmbXQubGVhZGluZ1R5cGU7XG4gICAgICAgIHN1bW1hcnkuZWZmZWN0aXZlTGluZUhlaWdodCA9IGZtdC5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xuICAgICAgICBzdW1tYXJ5LnRyYWNraW5nID0gZm10LnRyYWNraW5nO1xuICAgICAgICBzdW1tYXJ5Lmtlcm5pbmcgPSBmbXQua2VybmluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VtbWFyeTtcbiAgfVxuXG4gIC8vIE5FVzogUHJvY2VzcyBsZWFkaW5nIHZhbHVlcyB3aXRoIEluRGVzaWduLXNwZWNpZmljIGxvZ2ljIChzaGFyZWQgd2l0aCBTdG9yeVBhcnNlcilcbiAgcHJvY2Vzc0xlYWRpbmdWYWx1ZShyYXdMZWFkaW5nLCBmb250U2l6ZSkge1xuICAgIGlmICghcmF3TGVhZGluZykgcmV0dXJuIFwiYXV0b1wiO1xuXG4gICAgLy8gSGFuZGxlIFwiYXV0b1wiIGxlYWRpbmdcbiAgICBpZiAocmF3TGVhZGluZyA9PT0gXCJhdXRvXCIgfHwgcmF3TGVhZGluZyA9PT0gXCJBdXRvXCIpIHtcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IGZvbnRTaXplICogMS4yIDogXCJhdXRvXCI7IC8vIEluRGVzaWduIGRlZmF1bHQgYXV0byBsZWFkaW5nIGlzIDEyMCVcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbnVtZXJpYyBsZWFkaW5nIChpbiBwb2ludHMpXG4gICAgY29uc3QgbnVtZXJpY0xlYWRpbmcgPSBwYXJzZUZsb2F0KHJhd0xlYWRpbmcpO1xuICAgIGlmICghaXNOYU4obnVtZXJpY0xlYWRpbmcpKSB7XG4gICAgICByZXR1cm4gbnVtZXJpY0xlYWRpbmc7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHBlcmNlbnRhZ2UtYmFzZWQgbGVhZGluZ1xuICAgIGlmIChyYXdMZWFkaW5nLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQocmF3TGVhZGluZy5yZXBsYWNlKFwiJVwiLCBcIlwiKSk7XG4gICAgICByZXR1cm4gZm9udFNpemUgPyAoZm9udFNpemUgKiBwZXJjZW50YWdlKSAvIDEwMCA6IFwiYXV0b1wiO1xuICAgIH1cblxuICAgIHJldHVybiBcImF1dG9cIjtcbiAgfVxuXG4gIC8vIE5FVzogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGxlYWRpbmcgYmVpbmcgdXNlZFxuICBkZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSB7XG4gICAgaWYgKCFyYXdMZWFkaW5nIHx8IHJhd0xlYWRpbmcgPT09IFwiYXV0b1wiIHx8IHJhd0xlYWRpbmcgPT09IFwiQXV0b1wiKSB7XG4gICAgICByZXR1cm4gXCJhdXRvXCI7XG4gICAgfVxuXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICByZXR1cm4gXCJwZXJjZW50YWdlXCI7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KHJhd0xlYWRpbmcpKSkge1xuICAgICAgcmV0dXJuIFwiYWJzb2x1dGVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIH1cblxuICAvLyBORVc6IENhbGN1bGF0ZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgZm9yIENTUyByZW5kZXJpbmdcbiAgY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChsZWFkaW5nLCBmb250U2l6ZSkge1xuICAgIGlmIChsZWFkaW5nID09PSBcImF1dG9cIikge1xuICAgICAgcmV0dXJuIDEuMjsgLy8gQ1NTIGxpbmUtaGVpZ2h0IHJhdGlvIGZvciBhdXRvXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsZWFkaW5nID09PSBcIm51bWJlclwiICYmIGZvbnRTaXplKSB7XG4gICAgICAvLyBDb252ZXJ0IHBvaW50cyB0byBDU1MgbGluZS1oZWlnaHQgcmF0aW9cbiAgICAgIHJldHVybiBNYXRoLm1heCgwLjgsIGxlYWRpbmcgLyBmb250U2l6ZSk7IC8vIEVuc3VyZSBtaW5pbXVtIGxpbmUgaGVpZ2h0XG4gICAgfVxuXG4gICAgcmV0dXJuIDEuMjsgLy8gRmFsbGJhY2tcbiAgfVxuXG4gIGdldFN0eWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZXM7XG4gIH1cblxuICBnZXRSZXNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzO1xuICB9XG5cbiAgZ2V0Rm9udE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb250TWFwO1xuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHMgdG8gcmV0dXJuIHN0eWxlIGFuZCBmb250IGRlZmluaXRpb25zIGZvciBkZWJ1Z1xuICBnZXRQYXJhZ3JhcGhTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzLnBhcmFncmFwaDtcbiAgfVxuICBnZXRDaGFyYWN0ZXJTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzLmNoYXJhY3RlcjtcbiAgfVxuICBnZXRGb250RGVmaW5pdGlvbnMoKSB7XG4gICAgLy8gUHJlZmVyIHBsYWluIG9iamVjdCBmb3IgZGVidWcgb3V0cHV0XG4gICAgaWYgKHRoaXMucmVzb3VyY2VzICYmIHRoaXMucmVzb3VyY2VzLmZvbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXMuZm9udHM7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrOiBjb252ZXJ0IGZvbnRNYXAgdG8gb2JqZWN0XG4gICAgaWYgKHRoaXMuZm9udE1hcCAmJiB0eXBlb2YgdGhpcy5mb250TWFwLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLmZvbnRNYXAuZW50cmllcygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gRklYRUQ6IEFkZCBtZXRob2QgdG8gYWNjZXNzIGRvY3VtZW50IHByZWZlcmVuY2VzIGluY2x1ZGluZyBWaWV3UHJlZmVyZW5jZXNcbiAgZ2V0RG9jdW1lbnRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50SW5mbztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlUGFyc2VyO1xuIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiSURNTFV0aWxzIiwiU3R5bGVQYXJzZXIiLCJzZXREb2N1bWVudFVuaXRzIiwidW5pdHMiLCJkb2N1bWVudFVuaXRzIiwiY29uc29sZSIsImxvZyIsImNvbnZlcnRUeXBvZ3JhcGh5VG9QaXhlbHMiLCJ2YWx1ZSIsImlzTmFOIiwidW5pdENvbnZlcnRlciIsImlzU3VwcG9ydGVkVW5pdCIsImNvbnZlcnRlZFZhbHVlIiwidG9QaXhlbHMiLCJjb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyIsInN0eWxlIiwiY29udmVydGVkU3R5bGUiLCJtZWFzdXJlbWVudEZpZWxkcyIsImZvckVhY2giLCJmaWVsZCIsImxlYWRpbmciLCJwYXJzZVJlc291cmNlRmlsZSIsImZpbGVOYW1lIiwiY29udGVudCIsInhtbFBhcnNlciIsInBhcnNlZCIsInBhcnNlIiwicmVzb3VyY2VOYW1lIiwiYmFzZW5hbWUiLCJpbmNsdWRlcyIsImV4dHJhY3RTdHlsZXMiLCJleHRyYWN0Rm9udHMiLCJleHRyYWN0R3JhcGhpY3MiLCJleHRyYWN0UHJlZmVyZW5jZXMiLCJlcnJvciIsIm1lc3NhZ2UiLCJzdHlsZXNEYXRhIiwic3R5bGVzIiwiU3R5bGVzIiwiUm9vdFBhcmFncmFwaFN0eWxlR3JvdXAiLCJleHRyYWN0UGFyYWdyYXBoU3R5bGVzIiwiUm9vdENoYXJhY3RlclN0eWxlR3JvdXAiLCJleHRyYWN0Q2hhcmFjdGVyU3R5bGVzIiwic3R5bGVHcm91cCIsImV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSIsImdyb3VwIiwiUGFyYWdyYXBoU3R5bGUiLCJBcnJheSIsImlzQXJyYXkiLCJmb250UmVmIiwiZXh0cmFjdEZvbnRGcm9tU3R5bGUiLCJmb250U2l6ZSIsInBhcnNlRmxvYXQiLCJyYXdMZWFkaW5nIiwicHJvY2Vzc2VkTGVhZGluZyIsInByb2Nlc3NMZWFkaW5nVmFsdWUiLCJyYXdMZWZ0SW5kZW50IiwicmF3UmlnaHRJbmRlbnQiLCJyYXdGaXJzdExpbmVJbmRlbnQiLCJyYXdTcGFjZUJlZm9yZSIsInJhd1NwYWNlQWZ0ZXIiLCJyYXdUcmFja2luZyIsInJhd0tlcm5pbmciLCJiYXNlU3R5bGUiLCJzZWxmIiwibmFtZSIsImZvbnRTdHlsZSIsInBvaW50U2l6ZSIsImxlYWRpbmdUeXBlIiwiZGV0ZXJtaW5lTGVhZGluZ1R5cGUiLCJlZmZlY3RpdmVMaW5lSGVpZ2h0IiwiY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodCIsImFsaWdubWVudCIsImxlZnRJbmRlbnQiLCJyaWdodEluZGVudCIsImZpcnN0TGluZUluZGVudCIsInNwYWNlQmVmb3JlIiwic3BhY2VBZnRlciIsInRyYWNraW5nIiwia2VybmluZyIsIm9yaWdpbmFsTGVmdEluZGVudCIsIm9yaWdpbmFsUmlnaHRJbmRlbnQiLCJvcmlnaW5hbEZpcnN0TGluZUluZGVudCIsIm9yaWdpbmFsU3BhY2VCZWZvcmUiLCJvcmlnaW5hbFNwYWNlQWZ0ZXIiLCJvcmlnaW5hbFRyYWNraW5nIiwib3JpZ2luYWxLZXJuaW5nIiwiaG9yaXpvbnRhbFNjYWxlIiwidmVydGljYWxTY2FsZSIsImFwcGxpZWRGb250Iiwib3JpZ2luYWxGb250UmVmIiwiZmlsbENvbG9yIiwicmF3U3R5bGUiLCJwYXJhZ3JhcGgiLCJQYXJhZ3JhcGhTdHlsZUdyb3VwIiwic3ViR3JvdXBzIiwiUHJvcGVydGllcyIsIkFwcGxpZWRGb250IiwiRm9udEZhbWlseSIsIkNoYXJhY3RlclN0eWxlIiwiY2hhcmFjdGVyIiwic3Ryb2tlQ29sb3IiLCJDaGFyYWN0ZXJTdHlsZUdyb3VwIiwiZm9udHNEYXRhIiwiZm9udHMiLCJGb250cyIsInJlc291cmNlcyIsImZvbnRNYXAiLCJNYXAiLCJmb250RmFtaWxpZXMiLCJmYW1pbHkiLCJmYW1pbHlJbmZvIiwiRm9udCIsImZvbnRMaXN0IiwiZm9udCIsImZvbnRJbmZvIiwiZm9udEZhbWlseSIsInBvc3RTY3JpcHROYW1lIiwic3RhdHVzIiwiZm9udFN0eWxlTmFtZSIsInB1c2giLCJzZXQiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwic2l6ZSIsImdyYXBoaWNzRGF0YSIsImdyYXBoaWNzIiwiR3JhcGhpYyIsImNvbG9ycyIsImdyYWRpZW50cyIsIkNvbG9yIiwiY29sb3IiLCJtb2RlbCIsInNwYWNlIiwiY3lhbiIsIm1hZ2VudGEiLCJ5ZWxsb3ciLCJibGFjayIsInJlZCIsImdyZWVuIiwiYmx1ZSIsIkdyYWRpZW50IiwiZ3JhZGllbnQiLCJ0eXBlIiwiZ3JhZGllbnRTdG9wcyIsImV4dHJhY3RHcmFkaWVudFN0b3BzIiwic3RvcHMiLCJHcmFkaWVudFN0b3AiLCJzdG9wTGlzdCIsInN0b3AiLCJzdG9wQ29sb3IiLCJsb2NhdGlvbiIsIm1pZHBvaW50IiwicHJlZmVyZW5jZXNEYXRhIiwicHJlZnMiLCJQcmVmZXJlbmNlcyIsImRvY3VtZW50SW5mbyIsInByZWZlcmVuY2VzIiwiZG9jdW1lbnRQcmVmZXJlbmNlcyIsImV4dHJhY3REb2N1bWVudFByZWZzIiwiRG9jdW1lbnRQcmVmZXJlbmNlIiwidmlld1ByZWZlcmVuY2VzIiwiZXh0cmFjdFZpZXdQcmVmcyIsIlZpZXdQcmVmZXJlbmNlIiwiZ3VpZGVQcmVmZXJlbmNlcyIsImV4dHJhY3RHdWlkZVByZWZzIiwiR3VpZGVQcmVmZXJlbmNlIiwiZ3JpZFByZWZlcmVuY2VzIiwiZXh0cmFjdEdyaWRQcmVmcyIsIkdyaWRQcmVmZXJlbmNlIiwibWFyZ2luUHJlZmVyZW5jZXMiLCJleHRyYWN0TWFyZ2luUHJlZnMiLCJNYXJnaW5QcmVmZXJlbmNlIiwiY29sdW1uUHJlZmVyZW5jZXMiLCJleHRyYWN0Q29sdW1uUHJlZnMiLCJDb2x1bW5QcmVmZXJlbmNlIiwiZG9jUHJlZiIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJjb2x1bW5Db3VudCIsInBhcnNlSW50IiwiY29sdW1uR3V0dGVyIiwiZmFjaW5nUGFnZXMiLCJhbGxvd1BhZ2VTaHVmZmxlIiwic2x1Z0JsZWVkVHlwZSIsImRvY3VtZW50QmxlZWRUb3BPZmZzZXQiLCJkb2N1bWVudEJsZWVkQm90dG9tT2Zmc2V0IiwiZG9jdW1lbnRCbGVlZEluc2lkZU9yTGVmdE9mZnNldCIsImRvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldCIsInZpZXdQcmVmIiwiaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHMiLCJ2ZXJ0aWNhbE1lYXN1cmVtZW50VW5pdHMiLCJydWxlck9yaWdpbiIsInNob3dSdWxlcnMiLCJndWlkZVByZWYiLCJydWxlckd1aWRlQ29sb3IiLCJndWlkZXNJbkJhY2siLCJndWlkZXNMb2NrZWQiLCJndWlkZXNTaG93biIsImd1aWRlc1NuYXB0byIsImdyaWRQcmVmIiwiYmFzZWxpbmVTdGFydCIsImJhc2VsaW5lRGl2aXNpb24iLCJiYXNlbGluZVNob3duIiwiYmFzZWxpbmVTbmFwdG8iLCJkb2N1bWVudEdyaWRTaG93biIsImRvY3VtZW50R3JpZFNuYXB0byIsIm1hcmdpblByZWYiLCJjb2x1bW5QcmVmIiwidGV4dENvbHVtbkNvdW50IiwidGV4dENvbHVtbkd1dHRlciIsInJlc29sdmVTdHlsZUZvcm1hdHRpbmciLCJmb3JtYXR0aW5nIiwicmVzb2x2ZWQiLCJoYXNBbnlGb3JtYXR0aW5nIiwicGFyYWdyYXBoU3R5bGUiLCJjaGFyYWN0ZXJTdHlsZSIsImZvbnRSZWZlcmVuY2UiLCJkaXJlY3RGb250U3R5bGUiLCJkaXJlY3RGb250UmVmIiwiZGlyZWN0Rm9udFNpemUiLCJwU3R5bGUiLCJyZXNvbHZlRm9udFJlZmVyZW5jZSIsImNTdHlsZSIsInVuZGVmaW5lZCIsImdldERlZmF1bHRGb250IiwiaGFzIiwicmVzb2x2ZWRGb250IiwiZ2V0IiwiZmFtaWx5SWQiLCJlbnRyaWVzIiwidG9Mb3dlckNhc2UiLCJmaXJzdEZhbWlseSIsInZhbHVlcyIsImluZmVyRm9udEZyb21Db250ZXh0IiwiZmlyc3RGb250RmFtaWx5IiwiZ2V0U3RvcnlTdHlsZVN1bW1hcnkiLCJzdG9yeSIsInN1bW1hcnkiLCJmb3JtYXR0ZWRDb250ZW50IiwiZmlyc3RGb3JtYXR0ZWQiLCJmaW5kIiwiaXRlbSIsImlzQnJlYWsiLCJmbXQiLCJudW1lcmljTGVhZGluZyIsInBlcmNlbnRhZ2UiLCJyZXBsYWNlIiwiTWF0aCIsIm1heCIsImdldFN0eWxlcyIsImdldFJlc291cmNlcyIsImdldEZvbnRNYXAiLCJnZXRQYXJhZ3JhcGhTdHlsZXMiLCJnZXRDaGFyYWN0ZXJTdHlsZXMiLCJnZXRGb250RGVmaW5pdGlvbnMiLCJmcm9tRW50cmllcyIsImdldERvY3VtZW50SW5mbyIsImNvbnN0cnVjdG9yIiwib2JqZWN0IiwidGFibGUiLCJjZWxsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/parsers/StyleParser.js\n"));

/***/ })

});