"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StoryParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StoryParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StoryParser {\n    async parseStoryFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCDD Parsing story: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const storyId = path.basename(fileName, \".xml\");\n            const storyData = parsed.Story || parsed;\n            // ADD THESE SIMPLE LOGS FIRST:\n            console.log(\"=== SIMPLE DEBUG TEST ===\");\n            console.log(\"Story file name:\", fileName);\n            console.log(\"Parsed story keys:\", Object.keys(storyData));\n            console.log(\"Raw story data sample:\", JSON.stringify(storyData, null, 2).substring(0, 500));\n            // Extract detailed story information\n            const detailedStory = {\n                self: storyData[\"@_Self\"],\n                appliedTOCStyle: storyData[\"@_AppliedTOCStyle\"] || \"n\",\n                userText: storyData[\"@_UserText\"] !== false,\n                // Extract story content with formatting\n                content: this.extractDetailedStoryContent(storyData),\n                // Extract text formatting\n                textFormatting: this.extractTextFormatting(storyData)\n            };\n            const cleanStoryId = storyId.replace(\"Story_\", \"\");\n            this.stories[cleanStoryId] = detailedStory;\n            // Enhanced logging to show line breaks\n            const { plainText, lineBreakInfo } = detailedStory.content;\n            console.log(\"✅ Story \".concat(storyId, \" parsed:\"));\n            console.log(\"   - Characters: \".concat(plainText.length));\n            console.log(\"   - Words: \".concat(detailedStory.content.wordCount));\n            console.log(\"   - Line breaks: \".concat((lineBreakInfo === null || lineBreakInfo === void 0 ? void 0 : lineBreakInfo.lineBreakCount) || 0));\n            console.log('   - Text preview: \"'.concat(plainText.substring(0, 50).replace(/\\n/g, \"\\\\n\"), '...\"'));\n        } catch (error) {\n            console.error(\"❌ Error parsing story \".concat(fileName, \":\"), error.message);\n        }\n    }\n    // Replace the existing extractDetailedStoryContent method with this corrected version\n    extractDetailedStoryContent(storyData) {\n        var _this = this;\n        let content = \"\";\n        let formattedContent = [];\n        let textColor = null;\n        let debugInfo = [];\n        const extractTextRecursively = function(element) {\n            let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (typeof element === \"string\") {\n                content += element;\n                return;\n            }\n            if (element && typeof element === \"object\") {\n                // ENHANCED: Special handling for CharacterStyleRange with sophisticated Br detection\n                if (element.CharacterStyleRange) {\n                    const ranges = Array.isArray(element.CharacterStyleRange) ? element.CharacterStyleRange : [\n                        element.CharacterStyleRange\n                    ];\n                    // SIMPLIFIED DEBUG: Just log problematic text ranges\n                    const allRangeContent = ranges.map((r)=>r.Content ? Array.isArray(r.Content) ? r.Content.join(\"\") : String(r.Content) : \"\").join(\"\");\n                    if (allRangeContent.includes(\"pavoluptusda\") || allRangeContent.includes(\"pa\") || allRangeContent.includes(\"voluptusda\")) {\n                        console.log(\"\\uD83D\\uDEA8 FOUND RANGES WITH PROBLEMATIC TEXT:\");\n                        ranges.forEach((range, index)=>{\n                            const content = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                            console.log(\"   Range \".concat(index, ': \"').concat(content, '\"'));\n                        });\n                    }\n                    ranges.forEach((range, rangeIndex)=>{\n                        // Extract direct font references from the XML range\n                        const directFontRef = range[\"@_AppliedFont\"] || range[\"@_FontFamily\"] || range[\"@_Font\"] || \"\";\n                        const formatting = {\n                            paragraphStyle: element[\"@_AppliedParagraphStyle\"] || null,\n                            characterStyle: range[\"@_AppliedCharacterStyle\"] || null,\n                            fontSize: range[\"@_PointSize\"] ? parseFloat(range[\"@_PointSize\"]) : null,\n                            fontReference: directFontRef,\n                            fillColor: range[\"@_FillColor\"] || null,\n                            fontStyle: range[\"@_FontStyle\"] || null\n                        };\n                        // DEBUG: Log formatting extraction for any styled text (generic check)\n                        const rangeContent = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                        const hasStyleInfo = range[\"@_FontStyle\"] || range[\"@_AppliedCharacterStyle\"] || element[\"@_AppliedParagraphStyle\"] || range[\"@_AppliedFont\"];\n                        if (hasStyleInfo && rangeContent.trim()) {\n                            console.log(\"\\uD83D\\uDD27 StoryParser - Extracting formatting for range:\", JSON.stringify(rangeContent.substring(0, 30) + \"...\"), {\n                                rawRangeAttributes: Object.keys(range).filter((k)=>k.startsWith(\"@_\")),\n                                extractedFormatting: formatting,\n                                fontStyleFromXML: range[\"@_FontStyle\"],\n                                characterStyleFromXML: range[\"@_AppliedCharacterStyle\"],\n                                paragraphStyleFromXML: element[\"@_AppliedParagraphStyle\"]\n                            });\n                        }\n                        const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                        // FIXED: Process content with proper space preservation\n                        if (range.Content) {\n                            const contents = Array.isArray(range.Content) ? range.Content : [\n                                range.Content\n                            ];\n                            contents.forEach((contentItem, contentIndex)=>{\n                                const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n                                content += text;\n                                formattedContent.push({\n                                    text: text,\n                                    formatting: resolvedFormatting\n                                });\n                                // CRITICAL FIX: Check for Br elements AFTER each content item within the same range\n                                if (range.Br !== undefined && contentIndex < contents.length - 1) {\n                                    const lineBreakText = \"\\n\";\n                                    content += lineBreakText;\n                                    formattedContent.push({\n                                        text: lineBreakText,\n                                        formatting: {\n                                            isBreak: true,\n                                            breakType: \"line\",\n                                            position: \"between_content\",\n                                            source: \"Br element within range\"\n                                        }\n                                    });\n                                    debugInfo.push({\n                                        type: \"Line break detected within content\",\n                                        location: \"CharacterStyleRange[\".concat(rangeIndex, \"], between content[\").concat(contentIndex, \"] and content[\").concat(contentIndex + 1, \"]\"),\n                                        breakType: \"line\",\n                                        context: context\n                                    });\n                                }\n                            });\n                        }\n                        // Handle Br elements at the end of the range\n                        if (range.Br !== undefined && (!range.Content || Array.isArray(range.Content) === false)) {\n                            const brElements = _this.extractBrElements(range);\n                            brElements.forEach((brInfo, brIndex)=>{\n                                const lineBreakText = _this.determineLineBreakType(brInfo, context);\n                                content += lineBreakText;\n                                formattedContent.push({\n                                    text: lineBreakText,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: brInfo.type || \"line\",\n                                        position: brInfo.position || \"end\",\n                                        source: \"Br element at end of range\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Line break detected at end of range\",\n                                    location: \"CharacterStyleRange[\".concat(rangeIndex, \"], Br[\").concat(brIndex, \"]\"),\n                                    breakType: brInfo.type || \"line\",\n                                    context: context\n                                });\n                            });\n                        }\n                        // CRITICAL FIX: Add space between character style ranges if needed\n                        if (rangeIndex < ranges.length - 1) {\n                            const nextRange = ranges[rangeIndex + 1];\n                            // More robust space detection\n                            const currentText = content.slice(-10); // Check last 10 characters\n                            const currentRangeEndsWithSpace = /\\s$/.test(currentText); // Any whitespace at end\n                            const nextContent = nextRange.Content ? String(Array.isArray(nextRange.Content) ? nextRange.Content[0] : nextRange.Content) : \"\";\n                            const nextRangeStartsWithSpace = /^\\s/.test(nextContent); // Any whitespace at start\n                            // AGGRESSIVE FIX: Add space between ALL ranges unless explicitly not needed\n                            const shouldSkipSpace = currentRangeEndsWithSpace || nextRangeStartsWithSpace || _this.shouldInsertImplicitLineBreak(range, nextRange, context) || !nextRange.Content || // Skip if next range has no content\n                            nextContent.trim() === \"\"; // Skip if next content is only whitespace\n                            if (!shouldSkipSpace) {\n                                const currentStyle = range[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const nextStyle = nextRange[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const spaceText = \" \";\n                                content += spaceText;\n                                formattedContent.push({\n                                    text: spaceText,\n                                    formatting: {\n                                        isSpace: true,\n                                        source: \"between character style ranges (aggressive)\",\n                                        currentStyle,\n                                        nextStyle\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Space inserted between character styles (aggressive)\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    currentStyle,\n                                    nextStyle,\n                                    reason: \"Default space insertion - words likely split across ranges\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            } else {\n                                debugInfo.push({\n                                    type: \"Space insertion skipped\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    reason: currentRangeEndsWithSpace ? \"Current range ends with space\" : nextRangeStartsWithSpace ? \"Next range starts with space\" : !nextRange.Content ? \"Next range has no content\" : nextContent.trim() === \"\" ? \"Next content is only whitespace\" : \"Line break would be inserted\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            }\n                            // Handle explicit line breaks between ranges (for cases where shouldInsertImplicitLineBreak is true)\n                            if (_this.shouldInsertImplicitLineBreak(range, nextRange, context)) {\n                                const implicitBreak = \"\\n\";\n                                content += implicitBreak;\n                                formattedContent.push({\n                                    text: implicitBreak,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: \"implicit\",\n                                        source: \"between ranges\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Implicit line break\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1)\n                                });\n                            }\n                        }\n                    });\n                    return; // Don't continue processing to avoid duplication\n                }\n                // ENHANCED: Handle ParagraphStyleRange with context\n                if (element.ParagraphStyleRange) {\n                    const ranges = Array.isArray(element.ParagraphStyleRange) ? element.ParagraphStyleRange : [\n                        element.ParagraphStyleRange\n                    ];\n                    ranges.forEach((range, index)=>{\n                        const paragraphContext = {\n                            ...context,\n                            paragraphIndex: index,\n                            totalParagraphs: ranges.length,\n                            appliedStyle: range[\"@_AppliedParagraphStyle\"]\n                        };\n                        extractTextRecursively(range, depth + 1, paragraphContext);\n                        // Add paragraph break between paragraphs (but not after the last one)\n                        if (index < ranges.length - 1) {\n                            const paragraphBreak = \"\\n\";\n                            content += paragraphBreak;\n                            formattedContent.push({\n                                text: paragraphBreak,\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"paragraph\",\n                                    source: \"between paragraphs\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Paragraph break\",\n                                location: \"between paragraphs \".concat(index, \" and \").concat(index + 1)\n                            });\n                        }\n                    });\n                    return;\n                }\n                // Handle direct Content elements (when not inside CharacterStyleRange)\n                if (element.Content && !element.CharacterStyleRange) {\n                    let text = Array.isArray(element.Content) ? element.Content.join(\"\") : String(element.Content);\n                    text = IDMLUtils.decodeXMLEntities(text);\n                    content += text;\n                    const formatting = {\n                        paragraphStyle: element[\"@_AppliedParagraphStyle\"] || null,\n                        characterStyle: element[\"@_AppliedCharacterStyle\"] || null,\n                        fontSize: element[\"@_PointSize\"] || null,\n                        fontFamily: element[\"@_AppliedFont\"] || null,\n                        fillColor: element[\"@_FillColor\"] || null\n                    };\n                    const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                    formattedContent.push({\n                        text: text,\n                        formatting: resolvedFormatting\n                    });\n                }\n                // ENHANCED: Direct Br element handling (outside of ranges)\n                if (element.Br !== undefined) {\n                    const brElements = Array.isArray(element.Br) ? element.Br : [\n                        element.Br\n                    ];\n                    brElements.forEach((br, index)=>{\n                        const lineBreakText = \"\\n\";\n                        content += lineBreakText;\n                        formattedContent.push({\n                            text: lineBreakText,\n                            formatting: {\n                                isBreak: true,\n                                breakType: \"explicit\",\n                                source: \"direct Br element\"\n                            }\n                        });\n                        debugInfo.push({\n                            type: \"Direct Br element\",\n                            location: \"Direct element, index \".concat(index)\n                        });\n                    });\n                }\n                // Continue with other nested elements\n                Object.entries(element).forEach((param)=>{\n                    let [key, value] = param;\n                    if (!key.startsWith(\"@_\") && key !== \"Content\" && key !== \"Br\" && key !== \"CharacterStyleRange\" && key !== \"ParagraphStyleRange\") {\n                        if (Array.isArray(value)) {\n                            value.forEach((item)=>extractTextRecursively(item, depth + 1, context));\n                        } else if (typeof value === \"object\" && depth < 10) {\n                            extractTextRecursively(value, depth + 1, context);\n                        }\n                    }\n                });\n            }\n        };\n        extractTextRecursively(storyData);\n        // ENHANCED: Process and clean up the content with sophisticated line break preservation\n        const processedContent = IDMLUtils.sophisticatedLineBreakProcessing(content);\n        // DEBUG: Log space preservation results\n        console.log(\"\\uD83D\\uDCDD Text extraction results:\");\n        console.log(\"   - Original content length:\", content.length);\n        console.log(\"   - Processed content length:\", processedContent.length);\n        console.log(\"   - Space preservation events:\", debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length);\n        // SPECIFIC DEBUG: Check for the problematic \"pavoluptusda\" text (simplified)\n        if (processedContent.includes(\"pavoluptusda\") || processedContent.includes(\"pa\") && processedContent.includes(\"voluptusda\")) {\n            console.log(\"\\uD83D\\uDEA8 FOUND PROBLEMATIC TEXT:\");\n            console.log('   - Contains \"pavoluptusda\":', processedContent.includes(\"pavoluptusda\"));\n            console.log('   - Contains \"pa voluptusda\":', processedContent.includes(\"pa voluptusda\"));\n            console.log(\"   - FormattedContent breakdown:\", formattedContent.map((item)=>item.text).join(\"|\"));\n        }\n        const lineBreakInfo = {\n            hasLineBreaks: processedContent.includes(\"\\n\"),\n            lineBreakCount: (processedContent.match(/\\n/g) || []).length,\n            lineBreakTypes: this.analyzeLineBreakTypes(formattedContent),\n            debugInfo: debugInfo,\n            spacePreservationCount: debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length\n        };\n        return {\n            plainText: processedContent,\n            formattedContent: formattedContent.filter((item)=>item.text && item.text.length > 0),\n            wordCount: IDMLUtils.countWords(processedContent.replace(/\\n/g, \" \")),\n            characterCount: processedContent.length,\n            textColor: textColor,\n            lineBreakInfo: lineBreakInfo\n        };\n    }\n    // Add this helper method to better handle mixed content and Br elements\n    analyzeContentStructure(range) {\n        const structure = {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentItems: range.Content ? Array.isArray(range.Content) ? range.Content : [\n                range.Content\n            ] : [],\n            brElements: range.Br ? Array.isArray(range.Br) ? range.Br : [\n                range.Br\n            ] : []\n        };\n        console.log(\"Content structure analysis:\", structure);\n        return structure;\n    }\n    // Enhanced helper for processing interleaved content and breaks\n    processInterleavedContent(range, resolvedFormatting) {\n        const results = [];\n        let content = \"\";\n        // This method would need access to the actual XML structure to determine\n        // the exact order of Content and Br elements. For now, we'll use the \n        // approach above which handles the most common case.\n        return results;\n    }\n    // SOPHISTICATED: Helper method to extract Br elements with context\n    extractBrElements(range) {\n        const brElements = [];\n        if (range.Br !== undefined) {\n            if (Array.isArray(range.Br)) {\n                range.Br.forEach((br, index)=>{\n                    brElements.push({\n                        type: \"line\",\n                        position: index === 0 ? \"start\" : \"middle\",\n                        element: br\n                    });\n                });\n            } else {\n                brElements.push({\n                    type: \"line\",\n                    position: \"end\",\n                    element: range.Br\n                });\n            }\n        }\n        return brElements;\n    }\n    // SOPHISTICATED: Determine the appropriate line break type\n    determineLineBreakType(brInfo, context) {\n        // Different line break characters based on context\n        switch(brInfo.type){\n            case \"paragraph\":\n                return \"\\n\\n\"; // Double line break for paragraph separation\n            case \"forced\":\n                return \"\\n\"; // Forced line break (Shift+Enter equivalent)\n            case \"line\":\n            default:\n                return \"\\n\"; // Standard line break\n        }\n    }\n    // SOPHISTICATED: Determine if an implicit line break should be inserted\n    shouldInsertImplicitLineBreak(currentRange, nextRange, context) {\n        // Don't insert implicit breaks if explicit Br elements are present\n        if (currentRange.Br !== undefined || nextRange.Br !== undefined) {\n            return false;\n        }\n        // Insert breaks between different character styles in different paragraphs\n        const currentCharStyle = currentRange[\"@_AppliedCharacterStyle\"];\n        const nextCharStyle = nextRange[\"@_AppliedCharacterStyle\"];\n        // If we're in a context where styles change significantly, add a break\n        if (currentCharStyle && nextCharStyle && currentCharStyle !== nextCharStyle) {\n            // Check if this might be a title/heading followed by body text\n            const styleIndicatesBreak = this.styleIndicatesLineBreak(currentCharStyle, nextCharStyle);\n            return styleIndicatesBreak;\n        }\n        return false;\n    }\n    // SOPHISTICATED: Analyze if style change indicates a line break\n    styleIndicatesLineBreak(currentStyle, nextStyle) {\n        const titleIndicators = [\n            \"title\",\n            \"heading\",\n            \"header\"\n        ];\n        const bodyIndicators = [\n            \"body\",\n            \"text\",\n            \"normal\"\n        ];\n        const currentIsTitle = titleIndicators.some((indicator)=>currentStyle.toLowerCase().includes(indicator));\n        const nextIsBody = bodyIndicators.some((indicator)=>nextStyle.toLowerCase().includes(indicator));\n        return currentIsTitle && nextIsBody;\n    }\n    // SOPHISTICATED: Analyze line break types in formatted content\n    analyzeLineBreakTypes(formattedContent) {\n        const types = {\n            explicit: 0,\n            implicit: 0,\n            paragraph: 0,\n            direct: 0 // Direct Br elements\n        };\n        formattedContent.forEach((item)=>{\n            var _item_formatting;\n            if ((_item_formatting = item.formatting) === null || _item_formatting === void 0 ? void 0 : _item_formatting.isBreak) {\n                const breakType = item.formatting.breakType || \"unknown\";\n                if (types.hasOwnProperty(breakType)) {\n                    types[breakType]++;\n                }\n            }\n        });\n        return types;\n    }\n    extractDetailedFormattingFromRange(range) {\n        const formatting = {};\n        // Extract all possible font attributes\n        const fontAttributes = [\n            \"@_AppliedFont\",\n            \"@_FontFamily\",\n            \"@_Font\",\n            \"@_PostScriptName\",\n            \"@_FontName\"\n        ];\n        fontAttributes.forEach((attr)=>{\n            if (range[attr]) {\n                formatting.fontReference = range[attr];\n            }\n        });\n        // Extract font and size attributes\n        formatting.fontSize = IDMLUtils.parseNumeric(range[\"@_PointSize\"]);\n        // ENHANCED: Extract leading with proper processing\n        const rawLeading = range[\"@_Leading\"];\n        formatting.leading = this.processLeadingValue(rawLeading, formatting.fontSize);\n        formatting.leadingType = this.determineLeadingType(rawLeading);\n        // Extract color and style attributes\n        formatting.fillColor = range[\"@_FillColor\"];\n        formatting.strokeColor = range[\"@_StrokeColor\"];\n        formatting.fontStyle = range[\"@_FontStyle\"];\n        // Extract advanced typography attributes\n        formatting.tracking = IDMLUtils.parseNumeric(range[\"@_Tracking\"]);\n        formatting.baselineShift = IDMLUtils.parseNumeric(range[\"@_BaselineShift\"]);\n        formatting.kerning = IDMLUtils.parseNumeric(range[\"@_Kerning\"]);\n        formatting.horizontalScale = IDMLUtils.parseNumeric(range[\"@_HorizontalScale\"]) || 100;\n        formatting.verticalScale = IDMLUtils.parseNumeric(range[\"@_VerticalScale\"]) || 100;\n        // Extract paragraph-level attributes if present\n        // CRITICAL FIX: Only set alignment if explicitly specified, allowing paragraph inheritance\n        const explicitAlignment = range[\"@_Justification\"] || range[\"@_Alignment\"];\n        if (explicitAlignment) {\n            formatting.alignment = explicitAlignment;\n        }\n        formatting.leftIndent = IDMLUtils.parseNumeric(range[\"@_LeftIndent\"]);\n        formatting.rightIndent = IDMLUtils.parseNumeric(range[\"@_RightIndent\"]);\n        formatting.firstLineIndent = IDMLUtils.parseNumeric(range[\"@_FirstLineIndent\"]);\n        formatting.spaceBefore = IDMLUtils.parseNumeric(range[\"@_SpaceBefore\"]);\n        formatting.spaceAfter = IDMLUtils.parseNumeric(range[\"@_SpaceAfter\"]);\n        // Calculate effective line height for CSS\n        formatting.effectiveLineHeight = this.calculateEffectiveLineHeight(formatting);\n        return formatting;\n    }\n    // NEW: Process leading values with InDesign-specific logic\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = IDMLUtils.parseNumeric(rawLeading);\n        if (numericLeading) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (IDMLUtils.parseNumeric(rawLeading)) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(formatting) {\n        const fontSize = formatting.fontSize || 12;\n        const leading = formatting.leading;\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\") {\n            // Convert points to CSS line-height ratio\n            return leading / fontSize;\n        }\n        return 1.2; // Fallback\n    }\n    extractTextFormatting(storyData) {\n        const formatting = {\n            paragraphStyles: [],\n            characterStyles: [],\n            appliedStyles: []\n        };\n        // Extract applied paragraph styles\n        if (storyData.ParagraphStyleRange) {\n            const ranges = Array.isArray(storyData.ParagraphStyleRange) ? storyData.ParagraphStyleRange : [\n                storyData.ParagraphStyleRange\n            ];\n            ranges.forEach((range)=>{\n                const appliedStyle = range[\"@_AppliedParagraphStyle\"];\n                if (appliedStyle && !formatting.paragraphStyles.includes(appliedStyle)) {\n                    formatting.paragraphStyles.push(appliedStyle);\n                }\n                // Extract character styles within paragraph ranges\n                if (range.CharacterStyleRange) {\n                    const charRanges = Array.isArray(range.CharacterStyleRange) ? range.CharacterStyleRange : [\n                        range.CharacterStyleRange\n                    ];\n                    charRanges.forEach((charRange)=>{\n                        const charStyle = charRange[\"@_AppliedCharacterStyle\"];\n                        if (charStyle && !formatting.characterStyles.includes(charStyle)) {\n                            formatting.characterStyles.push(charStyle);\n                        }\n                    });\n                }\n            });\n        }\n        return formatting;\n    }\n    // Add this method to debug raw story content\n    debugRawStoryContent(storyData) {\n        console.log(\"\\n\\uD83D\\uDD0D RAW STORY CONTENT DEBUG:\");\n        console.log(\"Story keys:\", Object.keys(storyData));\n        const findCharacterRanges = function(obj) {\n            let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key === \"CharacterStyleRange\") {\n                        console.log(\"\\n\\uD83D\\uDCDD Found CharacterStyleRange at \".concat(path, \":\"), obj[key]);\n                        const ranges = Array.isArray(obj[key]) ? obj[key] : [\n                            obj[key]\n                        ];\n                        ranges.forEach((range, index)=>{\n                            console.log(\"  Range \".concat(index + 1, \" attributes:\"), Object.keys(range).filter((k)=>k.startsWith(\"@_\")));\n                            console.log(\"  Range \".concat(index + 1, \" font info:\"), {\n                                AppliedFont: range[\"@_AppliedFont\"],\n                                FontStyle: range[\"@_FontStyle\"],\n                                PointSize: range[\"@_PointSize\"]\n                            });\n                        });\n                    } else if (typeof obj[key] === \"object\") {\n                        findCharacterRanges(obj[key], \"\".concat(path, \".\").concat(key));\n                    }\n                });\n            }\n        };\n        findCharacterRanges(storyData);\n    }\n    getStories() {\n        return this.stories;\n    }\n    getStory(storyId) {\n        return this.stories[storyId];\n    }\n    clearStories() {\n        this.stories = {};\n    }\n    constructor(styleParser){\n        this.styleParser = styleParser;\n        this.stories = {};\n    }\n}\nmodule.exports = StoryParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcGFyc2Vycy9TdG9yeVBhcnNlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDckIsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUM7QUFFMUIsTUFBTUU7SUFNSixNQUFNQyxlQUFlQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsU0FBUyxFQUFFO1FBQ2pEQyxRQUFRQyxHQUFHLENBQUMsK0JBQThCLE9BQVRKO1FBRWpDLElBQUk7WUFDRixNQUFNSyxTQUFTSCxVQUFVSSxLQUFLLENBQUNMO1lBQy9CLE1BQU1NLFVBQVVaLEtBQUthLFFBQVEsQ0FBQ1IsVUFBVTtZQUV4QyxNQUFNUyxZQUFZSixPQUFPSyxLQUFLLElBQUlMO1lBRWxDLCtCQUErQjtZQUMvQkYsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0JKO1lBQ2hDRyxRQUFRQyxHQUFHLENBQUMsc0JBQXNCTyxPQUFPQyxJQUFJLENBQUNIO1lBQzlDTixRQUFRQyxHQUFHLENBQUMsMEJBQTBCUyxLQUFLQyxTQUFTLENBQUNMLFdBQVcsTUFBTSxHQUFHTSxTQUFTLENBQUMsR0FBRztZQUV0RixxQ0FBcUM7WUFDckMsTUFBTUMsZ0JBQWdCO2dCQUNwQkMsTUFBTVIsU0FBUyxDQUFDLFNBQVM7Z0JBQ3pCUyxpQkFBaUJULFNBQVMsQ0FBQyxvQkFBb0IsSUFBSTtnQkFDbkRVLFVBQVVWLFNBQVMsQ0FBQyxhQUFhLEtBQUs7Z0JBRXRDLHdDQUF3QztnQkFDeENSLFNBQVMsSUFBSSxDQUFDbUIsMkJBQTJCLENBQUNYO2dCQUUxQywwQkFBMEI7Z0JBQzFCWSxnQkFBZ0IsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ2I7WUFDN0M7WUFFQSxNQUFNYyxlQUFlaEIsUUFBUWlCLE9BQU8sQ0FBQyxVQUFVO1lBQy9DLElBQUksQ0FBQ0MsT0FBTyxDQUFDRixhQUFhLEdBQUdQO1lBRTdCLHVDQUF1QztZQUN2QyxNQUFNLEVBQUVVLFNBQVMsRUFBRUMsYUFBYSxFQUFFLEdBQUdYLGNBQWNmLE9BQU87WUFDMURFLFFBQVFDLEdBQUcsQ0FBQyxXQUFtQixPQUFSRyxTQUFRO1lBQy9CSixRQUFRQyxHQUFHLENBQUMsb0JBQXFDLE9BQWpCc0IsVUFBVUUsTUFBTTtZQUNoRHpCLFFBQVFDLEdBQUcsQ0FBQyxlQUErQyxPQUFoQ1ksY0FBY2YsT0FBTyxDQUFDNEIsU0FBUztZQUMxRDFCLFFBQVFDLEdBQUcsQ0FBQyxxQkFBd0QsT0FBbkN1QixDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVHLGNBQWMsS0FBSTtZQUNsRTNCLFFBQVFDLEdBQUcsQ0FBQyx1QkFBd0UsT0FBakRzQixVQUFVWCxTQUFTLENBQUMsR0FBRyxJQUFJUyxPQUFPLENBQUMsT0FBTyxRQUFPO1FBRXRGLEVBQUUsT0FBT08sT0FBTztZQUNkNUIsUUFBUTRCLEtBQUssQ0FBQyx5QkFBa0MsT0FBVC9CLFVBQVMsTUFBSStCLE1BQU1DLE9BQU87UUFDbkU7SUFDRjtJQUVBLHNGQUFzRjtJQUN0RlosNEJBQTRCWCxTQUFTLEVBQUU7O1FBQ3JDLElBQUlSLFVBQVU7UUFDZCxJQUFJZ0MsbUJBQW1CLEVBQUU7UUFDekIsSUFBSUMsWUFBWTtRQUNoQixJQUFJQyxZQUFZLEVBQUU7UUFFbEIsTUFBTUMseUJBQXlCLFNBQUNDO2dCQUFTQyx5RUFBUSxHQUFHQywyRUFBVSxDQUFDO1lBQzdELElBQUksT0FBT0YsWUFBWSxVQUFVO2dCQUMvQnBDLFdBQVdvQztnQkFDWDtZQUNGO1lBRUEsSUFBSUEsV0FBVyxPQUFPQSxZQUFZLFVBQVU7Z0JBQzFDLHFGQUFxRjtnQkFDckYsSUFBSUEsUUFBUUcsbUJBQW1CLEVBQUU7b0JBQy9CLE1BQU1DLFNBQVNDLE1BQU1DLE9BQU8sQ0FBQ04sUUFBUUcsbUJBQW1CLElBQ3RESCxRQUFRRyxtQkFBbUIsR0FBRzt3QkFBQ0gsUUFBUUcsbUJBQW1CO3FCQUFDO29CQUU3RCxxREFBcUQ7b0JBQ3JELE1BQU1JLGtCQUFrQkgsT0FBT0ksR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxPQUFPLEdBQzlDTCxNQUFNQyxPQUFPLENBQUNHLEVBQUVDLE9BQU8sSUFBSUQsRUFBRUMsT0FBTyxDQUFDQyxJQUFJLENBQUMsTUFBTUMsT0FBT0gsRUFBRUMsT0FBTyxJQUFLLElBQUlDLElBQUksQ0FBQztvQkFDakYsSUFBSUosZ0JBQWdCTSxRQUFRLENBQUMsbUJBQW1CTixnQkFBZ0JNLFFBQVEsQ0FBQyxTQUFTTixnQkFBZ0JNLFFBQVEsQ0FBQyxlQUFlO3dCQUN4SC9DLFFBQVFDLEdBQUcsQ0FBQzt3QkFDWnFDLE9BQU9VLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQzs0QkFDckIsTUFBTXBELFVBQVVtRCxNQUFNTCxPQUFPLEdBQzFCTCxNQUFNQyxPQUFPLENBQUNTLE1BQU1MLE9BQU8sSUFBSUssTUFBTUwsT0FBTyxDQUFDQyxJQUFJLENBQUMsTUFBTUMsT0FBT0csTUFBTUwsT0FBTyxJQUFLOzRCQUNwRjVDLFFBQVFDLEdBQUcsQ0FBQyxZQUF1QkgsT0FBWG9ELE9BQU0sT0FBYSxPQUFScEQsU0FBUTt3QkFDN0M7b0JBQ0Y7b0JBRUF3QyxPQUFPVSxPQUFPLENBQUMsQ0FBQ0MsT0FBT0U7d0JBQ3JCLG9EQUFvRDt3QkFDcEQsTUFBTUMsZ0JBQWdCSCxLQUFLLENBQUMsZ0JBQWdCLElBQ3ZCQSxLQUFLLENBQUMsZUFBZSxJQUNyQkEsS0FBSyxDQUFDLFNBQVMsSUFBSTt3QkFFeEMsTUFBTUksYUFBYTs0QkFDakJDLGdCQUFnQnBCLE9BQU8sQ0FBQywwQkFBMEIsSUFBSTs0QkFDdERxQixnQkFBZ0JOLEtBQUssQ0FBQywwQkFBMEIsSUFBSTs0QkFDcERPLFVBQVVQLEtBQUssQ0FBQyxjQUFjLEdBQUdRLFdBQVdSLEtBQUssQ0FBQyxjQUFjLElBQUk7NEJBQ3BFUyxlQUFlTjs0QkFDZk8sV0FBV1YsS0FBSyxDQUFDLGNBQWMsSUFBSTs0QkFDbkNXLFdBQVdYLEtBQUssQ0FBQyxjQUFjLElBQUk7d0JBQ3JDO3dCQUVBLHVFQUF1RTt3QkFDdkUsTUFBTVksZUFBZVosTUFBTUwsT0FBTyxHQUMvQkwsTUFBTUMsT0FBTyxDQUFDUyxNQUFNTCxPQUFPLElBQUlLLE1BQU1MLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLE1BQU1DLE9BQU9HLE1BQU1MLE9BQU8sSUFBSzt3QkFDcEYsTUFBTWtCLGVBQWViLEtBQUssQ0FBQyxjQUFjLElBQUlBLEtBQUssQ0FBQywwQkFBMEIsSUFDekRmLE9BQU8sQ0FBQywwQkFBMEIsSUFBSWUsS0FBSyxDQUFDLGdCQUFnQjt3QkFFaEYsSUFBSWEsZ0JBQWdCRCxhQUFhRSxJQUFJLElBQUk7NEJBQ3ZDL0QsUUFBUUMsR0FBRyxDQUFDLCtEQUFxRFMsS0FBS0MsU0FBUyxDQUFDa0QsYUFBYWpELFNBQVMsQ0FBQyxHQUFHLE1BQU0sUUFBUTtnQ0FDdEhvRCxvQkFBb0J4RCxPQUFPQyxJQUFJLENBQUN3QyxPQUFPZ0IsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxVQUFVLENBQUM7Z0NBQ2hFQyxxQkFBcUJmO2dDQUNyQmdCLGtCQUFrQnBCLEtBQUssQ0FBQyxjQUFjO2dDQUN0Q3FCLHVCQUF1QnJCLEtBQUssQ0FBQywwQkFBMEI7Z0NBQ3ZEc0IsdUJBQXVCckMsT0FBTyxDQUFDLDBCQUEwQjs0QkFDM0Q7d0JBQ0Y7d0JBRUEsTUFBTXNDLHFCQUFxQixNQUFLQyxXQUFXLENBQUNDLHNCQUFzQixDQUFDckI7d0JBRW5FLHdEQUF3RDt3QkFDeEQsSUFBSUosTUFBTUwsT0FBTyxFQUFFOzRCQUNqQixNQUFNK0IsV0FBV3BDLE1BQU1DLE9BQU8sQ0FBQ1MsTUFBTUwsT0FBTyxJQUFJSyxNQUFNTCxPQUFPLEdBQUc7Z0NBQUNLLE1BQU1MLE9BQU87NkJBQUM7NEJBQy9FK0IsU0FBUzNCLE9BQU8sQ0FBQyxDQUFDNEIsYUFBYUM7Z0NBQzdCLE1BQU1DLE9BQU9wRixVQUFVcUYsaUJBQWlCLENBQUNqQyxPQUFPOEI7Z0NBQ2hEOUUsV0FBV2dGO2dDQUNYaEQsaUJBQWlCa0QsSUFBSSxDQUFDO29DQUNwQkYsTUFBTUE7b0NBQ056QixZQUFZbUI7Z0NBQ2Q7Z0NBRUEsb0ZBQW9GO2dDQUNwRixJQUFJdkIsTUFBTWdDLEVBQUUsS0FBS0MsYUFBYUwsZUFBZUYsU0FBU2xELE1BQU0sR0FBRyxHQUFHO29DQUNoRSxNQUFNMEQsZ0JBQWdCO29DQUN0QnJGLFdBQVdxRjtvQ0FDWHJELGlCQUFpQmtELElBQUksQ0FBQzt3Q0FDcEJGLE1BQU1LO3dDQUNOOUIsWUFBWTs0Q0FDVitCLFNBQVM7NENBQ1RDLFdBQVc7NENBQ1hDLFVBQVU7NENBQ1ZDLFFBQVE7d0NBQ1Y7b0NBQ0Y7b0NBRUF2RCxVQUFVZ0QsSUFBSSxDQUFDO3dDQUNiUSxNQUFNO3dDQUNOQyxVQUFVLHVCQUF1RFosT0FBaEMxQixZQUFXLHVCQUFrRDBCLE9BQTdCQSxjQUFhLGtCQUFpQyxPQUFqQkEsZUFBZSxHQUFFO3dDQUMvR1EsV0FBVzt3Q0FDWGpELFNBQVNBO29DQUNYO2dDQUNGOzRCQUNGO3dCQUNGO3dCQUVBLDZDQUE2Qzt3QkFDN0MsSUFBSWEsTUFBTWdDLEVBQUUsS0FBS0MsYUFBYyxFQUFDakMsTUFBTUwsT0FBTyxJQUFJTCxNQUFNQyxPQUFPLENBQUNTLE1BQU1MLE9BQU8sTUFBTSxLQUFJLEdBQUk7NEJBQ3hGLE1BQU04QyxhQUFhLE1BQUtDLGlCQUFpQixDQUFDMUM7NEJBQzFDeUMsV0FBVzFDLE9BQU8sQ0FBQyxDQUFDNEMsUUFBUUM7Z0NBQzFCLE1BQU1WLGdCQUFnQixNQUFLVyxzQkFBc0IsQ0FBQ0YsUUFBUXhEO2dDQUMxRHRDLFdBQVdxRjtnQ0FFWHJELGlCQUFpQmtELElBQUksQ0FBQztvQ0FDcEJGLE1BQU1LO29DQUNOOUIsWUFBWTt3Q0FDVitCLFNBQVM7d0NBQ1RDLFdBQVdPLE9BQU9KLElBQUksSUFBSTt3Q0FDMUJGLFVBQVVNLE9BQU9OLFFBQVEsSUFBSTt3Q0FDN0JDLFFBQVE7b0NBQ1Y7Z0NBQ0Y7Z0NBRUF2RCxVQUFVZ0QsSUFBSSxDQUFDO29DQUNiUSxNQUFNO29DQUNOQyxVQUFVLHVCQUEwQ0ksT0FBbkIxQyxZQUFXLFVBQWdCLE9BQVIwQyxTQUFRO29DQUM1RFIsV0FBV08sT0FBT0osSUFBSSxJQUFJO29DQUMxQnBELFNBQVNBO2dDQUNYOzRCQUNGO3dCQUNGO3dCQUVBLG1FQUFtRTt3QkFDbkUsSUFBSWUsYUFBYWIsT0FBT2IsTUFBTSxHQUFHLEdBQUc7NEJBQ2xDLE1BQU1zRSxZQUFZekQsTUFBTSxDQUFDYSxhQUFhLEVBQUU7NEJBRXhDLDhCQUE4Qjs0QkFDOUIsTUFBTTZDLGNBQWNsRyxRQUFRbUcsS0FBSyxDQUFDLENBQUMsS0FBSywyQkFBMkI7NEJBQ25FLE1BQU1DLDRCQUE0QixNQUFNQyxJQUFJLENBQUNILGNBQWMsd0JBQXdCOzRCQUVuRixNQUFNSSxjQUFjTCxVQUFVbkQsT0FBTyxHQUNuQ0UsT0FBT1AsTUFBTUMsT0FBTyxDQUFDdUQsVUFBVW5ELE9BQU8sSUFBSW1ELFVBQVVuRCxPQUFPLENBQUMsRUFBRSxHQUFHbUQsVUFBVW5ELE9BQU8sSUFBSTs0QkFDeEYsTUFBTXlELDJCQUEyQixNQUFNRixJQUFJLENBQUNDLGNBQWMsMEJBQTBCOzRCQUVwRiw0RUFBNEU7NEJBQzVFLE1BQU1FLGtCQUFrQkosNkJBQ0RHLDRCQUNBLE1BQUtFLDZCQUE2QixDQUFDdEQsT0FBTzhDLFdBQVczRCxZQUNyRCxDQUFDMkQsVUFBVW5ELE9BQU8sSUFBSSxvQ0FBb0M7NEJBQzFEd0QsWUFBWXJDLElBQUksT0FBTyxJQUFJLDBDQUEwQzs0QkFFNUYsSUFBSSxDQUFDdUMsaUJBQWlCO2dDQUNwQixNQUFNRSxlQUFldkQsS0FBSyxDQUFDLDBCQUEwQixJQUFJO2dDQUN6RCxNQUFNd0QsWUFBWVYsU0FBUyxDQUFDLDBCQUEwQixJQUFJO2dDQUUxRCxNQUFNVyxZQUFZO2dDQUNsQjVHLFdBQVc0RztnQ0FDWDVFLGlCQUFpQmtELElBQUksQ0FBQztvQ0FDcEJGLE1BQU00QjtvQ0FDTnJELFlBQVk7d0NBQ1ZzRCxTQUFTO3dDQUNUcEIsUUFBUTt3Q0FDUmlCO3dDQUNBQztvQ0FDRjtnQ0FDRjtnQ0FFQXpFLFVBQVVnRCxJQUFJLENBQUM7b0NBQ2JRLE1BQU07b0NBQ05DLFVBQVUsa0JBQW9DdEMsT0FBbEJBLFlBQVcsU0FBc0IsT0FBZkEsYUFBYTtvQ0FDM0RxRDtvQ0FDQUM7b0NBQ0FHLFFBQVE7b0NBQ1JDLGdCQUFnQmIsWUFBWUMsS0FBSyxDQUFDLENBQUM7b0NBQ25DYSxlQUFlVixZQUFZSCxLQUFLLENBQUMsR0FBRztnQ0FDdEM7NEJBQ0YsT0FBTztnQ0FDTGpFLFVBQVVnRCxJQUFJLENBQUM7b0NBQ2JRLE1BQU07b0NBQ05DLFVBQVUsa0JBQW9DdEMsT0FBbEJBLFlBQVcsU0FBc0IsT0FBZkEsYUFBYTtvQ0FDM0R5RCxRQUFRViw0QkFBNEIsa0NBQzVCRywyQkFBMkIsaUNBQzNCLENBQUNOLFVBQVVuRCxPQUFPLEdBQUcsOEJBQ3JCd0QsWUFBWXJDLElBQUksT0FBTyxLQUFLLG9DQUFvQztvQ0FDeEU4QyxnQkFBZ0JiLFlBQVlDLEtBQUssQ0FBQyxDQUFDO29DQUNuQ2EsZUFBZVYsWUFBWUgsS0FBSyxDQUFDLEdBQUc7Z0NBQ3RDOzRCQUNGOzRCQUVBLHFHQUFxRzs0QkFDckcsSUFBSSxNQUFLTSw2QkFBNkIsQ0FBQ3RELE9BQU84QyxXQUFXM0QsVUFBVTtnQ0FDakUsTUFBTTJFLGdCQUFnQjtnQ0FDdEJqSCxXQUFXaUg7Z0NBQ1hqRixpQkFBaUJrRCxJQUFJLENBQUM7b0NBQ3BCRixNQUFNaUM7b0NBQ04xRCxZQUFZO3dDQUNWK0IsU0FBUzt3Q0FDVEMsV0FBVzt3Q0FDWEUsUUFBUTtvQ0FDVjtnQ0FDRjtnQ0FFQXZELFVBQVVnRCxJQUFJLENBQUM7b0NBQ2JRLE1BQU07b0NBQ05DLFVBQVUsa0JBQW9DdEMsT0FBbEJBLFlBQVcsU0FBc0IsT0FBZkEsYUFBYTtnQ0FDN0Q7NEJBQ0Y7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsUUFBUSxpREFBaUQ7Z0JBQzNEO2dCQUVBLG9EQUFvRDtnQkFDcEQsSUFBSWpCLFFBQVE4RSxtQkFBbUIsRUFBRTtvQkFDL0IsTUFBTTFFLFNBQVNDLE1BQU1DLE9BQU8sQ0FBQ04sUUFBUThFLG1CQUFtQixJQUN0RDlFLFFBQVE4RSxtQkFBbUIsR0FBRzt3QkFBQzlFLFFBQVE4RSxtQkFBbUI7cUJBQUM7b0JBRTdEMUUsT0FBT1UsT0FBTyxDQUFDLENBQUNDLE9BQU9DO3dCQUNyQixNQUFNK0QsbUJBQW1COzRCQUN2QixHQUFHN0UsT0FBTzs0QkFDVjhFLGdCQUFnQmhFOzRCQUNoQmlFLGlCQUFpQjdFLE9BQU9iLE1BQU07NEJBQzlCMkYsY0FBY25FLEtBQUssQ0FBQywwQkFBMEI7d0JBQ2hEO3dCQUVBaEIsdUJBQXVCZ0IsT0FBT2QsUUFBUSxHQUFHOEU7d0JBRXpDLHNFQUFzRTt3QkFDdEUsSUFBSS9ELFFBQVFaLE9BQU9iLE1BQU0sR0FBRyxHQUFHOzRCQUM3QixNQUFNNEYsaUJBQWlCOzRCQUN2QnZILFdBQVd1SDs0QkFDWHZGLGlCQUFpQmtELElBQUksQ0FBQztnQ0FDcEJGLE1BQU11QztnQ0FDTmhFLFlBQVk7b0NBQ1YrQixTQUFTO29DQUNUQyxXQUFXO29DQUNYRSxRQUFRO2dDQUNWOzRCQUNGOzRCQUNBdkQsVUFBVWdELElBQUksQ0FBQztnQ0FDYlEsTUFBTTtnQ0FDTkMsVUFBVSxzQkFBbUN2QyxPQUFiQSxPQUFNLFNBQWlCLE9BQVZBLFFBQVE7NEJBQ3ZEO3dCQUNGO29CQUNGO29CQUNBO2dCQUNGO2dCQUVBLHVFQUF1RTtnQkFDdkUsSUFBSWhCLFFBQVFVLE9BQU8sSUFBSSxDQUFDVixRQUFRRyxtQkFBbUIsRUFBRTtvQkFDbkQsSUFBSXlDLE9BQU92QyxNQUFNQyxPQUFPLENBQUNOLFFBQVFVLE9BQU8sSUFBSVYsUUFBUVUsT0FBTyxDQUFDQyxJQUFJLENBQUMsTUFBTUMsT0FBT1osUUFBUVUsT0FBTztvQkFDN0ZrQyxPQUFPcEYsVUFBVXFGLGlCQUFpQixDQUFDRDtvQkFDbkNoRixXQUFXZ0Y7b0JBRVgsTUFBTXpCLGFBQWE7d0JBQ2pCQyxnQkFBZ0JwQixPQUFPLENBQUMsMEJBQTBCLElBQUk7d0JBQ3REcUIsZ0JBQWdCckIsT0FBTyxDQUFDLDBCQUEwQixJQUFJO3dCQUN0RHNCLFVBQVV0QixPQUFPLENBQUMsY0FBYyxJQUFJO3dCQUNwQ29GLFlBQVlwRixPQUFPLENBQUMsZ0JBQWdCLElBQUk7d0JBQ3hDeUIsV0FBV3pCLE9BQU8sQ0FBQyxjQUFjLElBQUk7b0JBQ3ZDO29CQUVBLE1BQU1zQyxxQkFBcUIsTUFBS0MsV0FBVyxDQUFDQyxzQkFBc0IsQ0FBQ3JCO29CQUVuRXZCLGlCQUFpQmtELElBQUksQ0FBQzt3QkFDcEJGLE1BQU1BO3dCQUNOekIsWUFBWW1CO29CQUNkO2dCQUNGO2dCQUVBLDJEQUEyRDtnQkFDM0QsSUFBSXRDLFFBQVErQyxFQUFFLEtBQUtDLFdBQVc7b0JBQzVCLE1BQU1RLGFBQWFuRCxNQUFNQyxPQUFPLENBQUNOLFFBQVErQyxFQUFFLElBQUkvQyxRQUFRK0MsRUFBRSxHQUFHO3dCQUFDL0MsUUFBUStDLEVBQUU7cUJBQUM7b0JBQ3hFUyxXQUFXMUMsT0FBTyxDQUFDLENBQUN1RSxJQUFJckU7d0JBQ3RCLE1BQU1pQyxnQkFBZ0I7d0JBQ3RCckYsV0FBV3FGO3dCQUNYckQsaUJBQWlCa0QsSUFBSSxDQUFDOzRCQUNwQkYsTUFBTUs7NEJBQ045QixZQUFZO2dDQUNWK0IsU0FBUztnQ0FDVEMsV0FBVztnQ0FDWEUsUUFBUTs0QkFDVjt3QkFDRjt3QkFDQXZELFVBQVVnRCxJQUFJLENBQUM7NEJBQ2JRLE1BQU07NEJBQ05DLFVBQVUseUJBQStCLE9BQU52Qzt3QkFDckM7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsc0NBQXNDO2dCQUN0QzFDLE9BQU9nSCxPQUFPLENBQUN0RixTQUFTYyxPQUFPLENBQUM7d0JBQUMsQ0FBQ3lFLEtBQUtDLE1BQU07b0JBQzNDLElBQUksQ0FBQ0QsSUFBSXRELFVBQVUsQ0FBQyxTQUNoQnNELFFBQVEsYUFDUkEsUUFBUSxRQUNSQSxRQUFRLHlCQUNSQSxRQUFRLHVCQUF1Qjt3QkFDakMsSUFBSWxGLE1BQU1DLE9BQU8sQ0FBQ2tGLFFBQVE7NEJBQ3hCQSxNQUFNMUUsT0FBTyxDQUFDMkUsQ0FBQUEsT0FBUTFGLHVCQUF1QjBGLE1BQU14RixRQUFRLEdBQUdDO3dCQUNoRSxPQUFPLElBQUksT0FBT3NGLFVBQVUsWUFBWXZGLFFBQVEsSUFBSTs0QkFDbERGLHVCQUF1QnlGLE9BQU92RixRQUFRLEdBQUdDO3dCQUMzQztvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQUgsdUJBQXVCM0I7UUFFdkIsd0ZBQXdGO1FBQ3hGLE1BQU1zSCxtQkFBbUJsSSxVQUFVbUksZ0NBQWdDLENBQUMvSDtRQUVwRSx3Q0FBd0M7UUFDeENFLFFBQVFDLEdBQUcsQ0FBQztRQUNaRCxRQUFRQyxHQUFHLENBQUMsaUNBQWlDSCxRQUFRMkIsTUFBTTtRQUMzRHpCLFFBQVFDLEdBQUcsQ0FBQyxrQ0FBa0MySCxpQkFBaUJuRyxNQUFNO1FBQ3JFekIsUUFBUUMsR0FBRyxDQUFDLG1DQUFtQytCLFVBQVVpQyxNQUFNLENBQUM2RCxDQUFBQSxPQUFRQSxLQUFLdEMsSUFBSSxDQUFDekMsUUFBUSxDQUFDLG1CQUFtQnRCLE1BQU07UUFFcEgsNkVBQTZFO1FBQzdFLElBQUltRyxpQkFBaUI3RSxRQUFRLENBQUMsbUJBQW1CNkUsaUJBQWlCN0UsUUFBUSxDQUFDLFNBQVM2RSxpQkFBaUI3RSxRQUFRLENBQUMsZUFBZTtZQUMzSC9DLFFBQVFDLEdBQUcsQ0FBQztZQUNaRCxRQUFRQyxHQUFHLENBQUMsaUNBQWlDMkgsaUJBQWlCN0UsUUFBUSxDQUFDO1lBQ3ZFL0MsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQzJILGlCQUFpQjdFLFFBQVEsQ0FBQztZQUN4RS9DLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0M2QixpQkFBaUJZLEdBQUcsQ0FBQ2lGLENBQUFBLE9BQVFBLEtBQUs3QyxJQUFJLEVBQUVqQyxJQUFJLENBQUM7UUFDL0Y7UUFJQSxNQUFNckIsZ0JBQWdCO1lBQ3BCdUcsZUFBZUgsaUJBQWlCN0UsUUFBUSxDQUFDO1lBQ3pDcEIsZ0JBQWdCLENBQUNpRyxpQkFBaUJJLEtBQUssQ0FBQyxVQUFVLEVBQUUsRUFBRXZHLE1BQU07WUFDNUR3RyxnQkFBZ0IsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ3BHO1lBQzNDRSxXQUFXQTtZQUNYbUcsd0JBQXdCbkcsVUFBVWlDLE1BQU0sQ0FBQzZELENBQUFBLE9BQVFBLEtBQUt0QyxJQUFJLENBQUN6QyxRQUFRLENBQUMsbUJBQW1CdEIsTUFBTTtRQUMvRjtRQUVBLE9BQU87WUFDTEYsV0FBV3FHO1lBQ1g5RixrQkFBa0JBLGlCQUFpQm1DLE1BQU0sQ0FBQzBELENBQUFBLE9BQVFBLEtBQUs3QyxJQUFJLElBQUk2QyxLQUFLN0MsSUFBSSxDQUFDckQsTUFBTSxHQUFHO1lBQ2xGQyxXQUFXaEMsVUFBVTBJLFVBQVUsQ0FBQ1IsaUJBQWlCdkcsT0FBTyxDQUFDLE9BQU87WUFDaEVnSCxnQkFBZ0JULGlCQUFpQm5HLE1BQU07WUFDdkNNLFdBQVdBO1lBQ1hQLGVBQWVBO1FBQ2pCO0lBQ0Y7SUFFQSx3RUFBd0U7SUFDeEU4Ryx3QkFBd0JyRixLQUFLLEVBQUU7UUFDN0IsTUFBTXNGLFlBQVk7WUFDaEJDLFlBQVksQ0FBQyxDQUFDdkYsTUFBTUwsT0FBTztZQUMzQjZGLE9BQU94RixNQUFNZ0MsRUFBRSxLQUFLQztZQUNwQndELGNBQWN6RixNQUFNTCxPQUFPLEdBQUlMLE1BQU1DLE9BQU8sQ0FBQ1MsTUFBTUwsT0FBTyxJQUFJSyxNQUFNTCxPQUFPLEdBQUc7Z0JBQUNLLE1BQU1MLE9BQU87YUFBQyxHQUFJLEVBQUU7WUFDbkc4QyxZQUFZekMsTUFBTWdDLEVBQUUsR0FBSTFDLE1BQU1DLE9BQU8sQ0FBQ1MsTUFBTWdDLEVBQUUsSUFBSWhDLE1BQU1nQyxFQUFFLEdBQUc7Z0JBQUNoQyxNQUFNZ0MsRUFBRTthQUFDLEdBQUksRUFBRTtRQUMvRTtRQUVBakYsUUFBUUMsR0FBRyxDQUFDLCtCQUErQnNJO1FBQzNDLE9BQU9BO0lBQ1Q7SUFFQSxnRUFBZ0U7SUFDaEVJLDBCQUEwQjFGLEtBQUssRUFBRXVCLGtCQUFrQixFQUFFO1FBQ25ELE1BQU1vRSxVQUFVLEVBQUU7UUFDbEIsSUFBSTlJLFVBQVU7UUFFZCx5RUFBeUU7UUFDekUsc0VBQXNFO1FBQ3RFLHFEQUFxRDtRQUVyRCxPQUFPOEk7SUFDVDtJQUVBLG1FQUFtRTtJQUNuRWpELGtCQUFrQjFDLEtBQUssRUFBRTtRQUN2QixNQUFNeUMsYUFBYSxFQUFFO1FBRXJCLElBQUl6QyxNQUFNZ0MsRUFBRSxLQUFLQyxXQUFXO1lBQzFCLElBQUkzQyxNQUFNQyxPQUFPLENBQUNTLE1BQU1nQyxFQUFFLEdBQUc7Z0JBQzNCaEMsTUFBTWdDLEVBQUUsQ0FBQ2pDLE9BQU8sQ0FBQyxDQUFDdUUsSUFBSXJFO29CQUNwQndDLFdBQVdWLElBQUksQ0FBQzt3QkFDZFEsTUFBTTt3QkFDTkYsVUFBVXBDLFVBQVUsSUFBSSxVQUFVO3dCQUNsQ2hCLFNBQVNxRjtvQkFDWDtnQkFDRjtZQUNGLE9BQU87Z0JBQ0w3QixXQUFXVixJQUFJLENBQUM7b0JBQ2RRLE1BQU07b0JBQ05GLFVBQVU7b0JBQ1ZwRCxTQUFTZSxNQUFNZ0MsRUFBRTtnQkFDbkI7WUFDRjtRQUNGO1FBRUEsT0FBT1M7SUFDVDtJQUVBLDJEQUEyRDtJQUMzREksdUJBQXVCRixNQUFNLEVBQUV4RCxPQUFPLEVBQUU7UUFDdEMsbURBQW1EO1FBQ25ELE9BQVF3RCxPQUFPSixJQUFJO1lBQ2pCLEtBQUs7Z0JBQ0gsT0FBTyxRQUFRLDZDQUE2QztZQUM5RCxLQUFLO2dCQUNILE9BQU8sTUFBTSw2Q0FBNkM7WUFDNUQsS0FBSztZQUNMO2dCQUNFLE9BQU8sTUFBTSxzQkFBc0I7UUFDdkM7SUFDRjtJQUVBLHdFQUF3RTtJQUN4RWUsOEJBQThCc0MsWUFBWSxFQUFFOUMsU0FBUyxFQUFFM0QsT0FBTyxFQUFFO1FBQzlELG1FQUFtRTtRQUNuRSxJQUFJeUcsYUFBYTVELEVBQUUsS0FBS0MsYUFBYWEsVUFBVWQsRUFBRSxLQUFLQyxXQUFXO1lBQy9ELE9BQU87UUFDVDtRQUVBLDJFQUEyRTtRQUMzRSxNQUFNNEQsbUJBQW1CRCxZQUFZLENBQUMsMEJBQTBCO1FBQ2hFLE1BQU1FLGdCQUFnQmhELFNBQVMsQ0FBQywwQkFBMEI7UUFFMUQsdUVBQXVFO1FBQ3ZFLElBQUkrQyxvQkFBb0JDLGlCQUFpQkQscUJBQXFCQyxlQUFlO1lBQzNFLCtEQUErRDtZQUMvRCxNQUFNQyxzQkFBc0IsSUFBSSxDQUFDQyx1QkFBdUIsQ0FBQ0gsa0JBQWtCQztZQUMzRSxPQUFPQztRQUNUO1FBRUEsT0FBTztJQUNUO0lBRUEsZ0VBQWdFO0lBQ2hFQyx3QkFBd0J6QyxZQUFZLEVBQUVDLFNBQVMsRUFBRTtRQUMvQyxNQUFNeUMsa0JBQWtCO1lBQUM7WUFBUztZQUFXO1NBQVM7UUFDdEQsTUFBTUMsaUJBQWlCO1lBQUM7WUFBUTtZQUFRO1NBQVM7UUFFakQsTUFBTUMsaUJBQWlCRixnQkFBZ0JHLElBQUksQ0FBQ0MsQ0FBQUEsWUFDMUM5QyxhQUFhK0MsV0FBVyxHQUFHeEcsUUFBUSxDQUFDdUc7UUFDdEMsTUFBTUUsYUFBYUwsZUFBZUUsSUFBSSxDQUFDQyxDQUFBQSxZQUNyQzdDLFVBQVU4QyxXQUFXLEdBQUd4RyxRQUFRLENBQUN1RztRQUVuQyxPQUFPRixrQkFBa0JJO0lBQzNCO0lBRUEsK0RBQStEO0lBQy9EdEIsc0JBQXNCcEcsZ0JBQWdCLEVBQUU7UUFDdEMsTUFBTTJILFFBQVE7WUFDWkMsVUFBVTtZQUNWQyxVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsUUFBUSxFQUFTLHFCQUFxQjtRQUN4QztRQUVBL0gsaUJBQWlCa0IsT0FBTyxDQUFDMkUsQ0FBQUE7Z0JBQ25CQTtZQUFKLEtBQUlBLG1CQUFBQSxLQUFLdEUsVUFBVSxjQUFmc0UsdUNBQUFBLGlCQUFpQnZDLE9BQU8sRUFBRTtnQkFDNUIsTUFBTUMsWUFBWXNDLEtBQUt0RSxVQUFVLENBQUNnQyxTQUFTLElBQUk7Z0JBQy9DLElBQUlvRSxNQUFNSyxjQUFjLENBQUN6RSxZQUFZO29CQUNuQ29FLEtBQUssQ0FBQ3BFLFVBQVU7Z0JBQ2xCO1lBQ0Y7UUFDRjtRQUVBLE9BQU9vRTtJQUNUO0lBRUFNLG1DQUFtQzlHLEtBQUssRUFBRTtRQUN4QyxNQUFNSSxhQUFhLENBQUM7UUFFcEIsdUNBQXVDO1FBQ3ZDLE1BQU0yRyxpQkFBaUI7WUFDckI7WUFBaUI7WUFBZ0I7WUFDakM7WUFBb0I7U0FDckI7UUFFREEsZUFBZWhILE9BQU8sQ0FBQ2lILENBQUFBO1lBQ3JCLElBQUloSCxLQUFLLENBQUNnSCxLQUFLLEVBQUU7Z0JBQ2Y1RyxXQUFXSyxhQUFhLEdBQUdULEtBQUssQ0FBQ2dILEtBQUs7WUFDeEM7UUFDRjtRQUVBLG1DQUFtQztRQUNuQzVHLFdBQVdHLFFBQVEsR0FBRzlELFVBQVV3SyxZQUFZLENBQUNqSCxLQUFLLENBQUMsY0FBYztRQUVqRSxtREFBbUQ7UUFDbkQsTUFBTWtILGFBQWFsSCxLQUFLLENBQUMsWUFBWTtRQUNyQ0ksV0FBVytHLE9BQU8sR0FBRyxJQUFJLENBQUNDLG1CQUFtQixDQUFDRixZQUFZOUcsV0FBV0csUUFBUTtRQUM3RUgsV0FBV2lILFdBQVcsR0FBRyxJQUFJLENBQUNDLG9CQUFvQixDQUFDSjtRQUVuRCxxQ0FBcUM7UUFDckM5RyxXQUFXTSxTQUFTLEdBQUdWLEtBQUssQ0FBQyxjQUFjO1FBQzNDSSxXQUFXbUgsV0FBVyxHQUFHdkgsS0FBSyxDQUFDLGdCQUFnQjtRQUMvQ0ksV0FBV08sU0FBUyxHQUFHWCxLQUFLLENBQUMsY0FBYztRQUUzQyx5Q0FBeUM7UUFDekNJLFdBQVdvSCxRQUFRLEdBQUcvSyxVQUFVd0ssWUFBWSxDQUFDakgsS0FBSyxDQUFDLGFBQWE7UUFDaEVJLFdBQVdxSCxhQUFhLEdBQUdoTCxVQUFVd0ssWUFBWSxDQUFDakgsS0FBSyxDQUFDLGtCQUFrQjtRQUMxRUksV0FBV3NILE9BQU8sR0FBR2pMLFVBQVV3SyxZQUFZLENBQUNqSCxLQUFLLENBQUMsWUFBWTtRQUM5REksV0FBV3VILGVBQWUsR0FBR2xMLFVBQVV3SyxZQUFZLENBQUNqSCxLQUFLLENBQUMsb0JBQW9CLEtBQUs7UUFDbkZJLFdBQVd3SCxhQUFhLEdBQUduTCxVQUFVd0ssWUFBWSxDQUFDakgsS0FBSyxDQUFDLGtCQUFrQixLQUFLO1FBRS9FLGdEQUFnRDtRQUNoRCwyRkFBMkY7UUFDM0YsTUFBTTZILG9CQUFvQjdILEtBQUssQ0FBQyxrQkFBa0IsSUFBSUEsS0FBSyxDQUFDLGNBQWM7UUFDMUUsSUFBSTZILG1CQUFtQjtZQUNyQnpILFdBQVcwSCxTQUFTLEdBQUdEO1FBQ3pCO1FBQ0F6SCxXQUFXMkgsVUFBVSxHQUFHdEwsVUFBVXdLLFlBQVksQ0FBQ2pILEtBQUssQ0FBQyxlQUFlO1FBQ3BFSSxXQUFXNEgsV0FBVyxHQUFHdkwsVUFBVXdLLFlBQVksQ0FBQ2pILEtBQUssQ0FBQyxnQkFBZ0I7UUFDdEVJLFdBQVc2SCxlQUFlLEdBQUd4TCxVQUFVd0ssWUFBWSxDQUFDakgsS0FBSyxDQUFDLG9CQUFvQjtRQUM5RUksV0FBVzhILFdBQVcsR0FBR3pMLFVBQVV3SyxZQUFZLENBQUNqSCxLQUFLLENBQUMsZ0JBQWdCO1FBQ3RFSSxXQUFXK0gsVUFBVSxHQUFHMUwsVUFBVXdLLFlBQVksQ0FBQ2pILEtBQUssQ0FBQyxlQUFlO1FBRXBFLDBDQUEwQztRQUMxQ0ksV0FBV2dJLG1CQUFtQixHQUFHLElBQUksQ0FBQ0MsNEJBQTRCLENBQUNqSTtRQUVuRSxPQUFPQTtJQUNUO0lBRUEsMkRBQTJEO0lBQzNEZ0gsb0JBQW9CRixVQUFVLEVBQUUzRyxRQUFRLEVBQUU7UUFDeEMsSUFBSSxDQUFDMkcsWUFBWSxPQUFPO1FBRXhCLHdCQUF3QjtRQUN4QixJQUFJQSxlQUFlLFVBQVVBLGVBQWUsUUFBUTtZQUNsRCxPQUFPM0csV0FBV0EsV0FBVyxNQUFNLFFBQVEsd0NBQXdDO1FBQ3JGO1FBRUEscUNBQXFDO1FBQ3JDLE1BQU0rSCxpQkFBaUI3TCxVQUFVd0ssWUFBWSxDQUFDQztRQUM5QyxJQUFJb0IsZ0JBQWdCO1lBQ2xCLE9BQU9BO1FBQ1Q7UUFFQSxrQ0FBa0M7UUFDbEMsSUFBSXBCLFdBQVdwSCxRQUFRLENBQUMsTUFBTTtZQUM1QixNQUFNeUksYUFBYS9ILFdBQVcwRyxXQUFXOUksT0FBTyxDQUFDLEtBQUs7WUFDdEQsT0FBT21DLFdBQVlBLFdBQVdnSSxhQUFhLE1BQU87UUFDcEQ7UUFFQSxPQUFPO0lBQ1Q7SUFFQSxnREFBZ0Q7SUFDaERqQixxQkFBcUJKLFVBQVUsRUFBRTtRQUMvQixJQUFJLENBQUNBLGNBQWNBLGVBQWUsVUFBVUEsZUFBZSxRQUFRO1lBQ2pFLE9BQU87UUFDVDtRQUVBLElBQUlBLFdBQVdwSCxRQUFRLENBQUMsTUFBTTtZQUM1QixPQUFPO1FBQ1Q7UUFFQSxJQUFJckQsVUFBVXdLLFlBQVksQ0FBQ0MsYUFBYTtZQUN0QyxPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQSx5REFBeUQ7SUFDekRtQiw2QkFBNkJqSSxVQUFVLEVBQUU7UUFDdkMsTUFBTUcsV0FBV0gsV0FBV0csUUFBUSxJQUFJO1FBQ3hDLE1BQU00RyxVQUFVL0csV0FBVytHLE9BQU87UUFFbEMsSUFBSUEsWUFBWSxRQUFRO1lBQ3RCLE9BQU8sS0FBSyxpQ0FBaUM7UUFDL0M7UUFFQSxJQUFJLE9BQU9BLFlBQVksVUFBVTtZQUMvQiwwQ0FBMEM7WUFDMUMsT0FBT0EsVUFBVTVHO1FBQ25CO1FBRUEsT0FBTyxLQUFLLFdBQVc7SUFDekI7SUFFQXJDLHNCQUFzQmIsU0FBUyxFQUFFO1FBQy9CLE1BQU0rQyxhQUFhO1lBQ2pCb0ksaUJBQWlCLEVBQUU7WUFDbkJDLGlCQUFpQixFQUFFO1lBQ25CQyxlQUFlLEVBQUU7UUFDbkI7UUFFQSxtQ0FBbUM7UUFDbkMsSUFBSXJMLFVBQVUwRyxtQkFBbUIsRUFBRTtZQUNqQyxNQUFNMUUsU0FBU0MsTUFBTUMsT0FBTyxDQUFDbEMsVUFBVTBHLG1CQUFtQixJQUFJMUcsVUFBVTBHLG1CQUFtQixHQUFHO2dCQUFDMUcsVUFBVTBHLG1CQUFtQjthQUFDO1lBRTdIMUUsT0FBT1UsT0FBTyxDQUFDQyxDQUFBQTtnQkFDYixNQUFNbUUsZUFBZW5FLEtBQUssQ0FBQywwQkFBMEI7Z0JBQ3JELElBQUltRSxnQkFBZ0IsQ0FBQy9ELFdBQVdvSSxlQUFlLENBQUMxSSxRQUFRLENBQUNxRSxlQUFlO29CQUN0RS9ELFdBQVdvSSxlQUFlLENBQUN6RyxJQUFJLENBQUNvQztnQkFDbEM7Z0JBRUEsbURBQW1EO2dCQUNuRCxJQUFJbkUsTUFBTVosbUJBQW1CLEVBQUU7b0JBQzdCLE1BQU11SixhQUFhckosTUFBTUMsT0FBTyxDQUFDUyxNQUFNWixtQkFBbUIsSUFBSVksTUFBTVosbUJBQW1CLEdBQUc7d0JBQUNZLE1BQU1aLG1CQUFtQjtxQkFBQztvQkFFckh1SixXQUFXNUksT0FBTyxDQUFDNkksQ0FBQUE7d0JBQ2pCLE1BQU1DLFlBQVlELFNBQVMsQ0FBQywwQkFBMEI7d0JBQ3RELElBQUlDLGFBQWEsQ0FBQ3pJLFdBQVdxSSxlQUFlLENBQUMzSSxRQUFRLENBQUMrSSxZQUFZOzRCQUNoRXpJLFdBQVdxSSxlQUFlLENBQUMxRyxJQUFJLENBQUM4Rzt3QkFDbEM7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT3pJO0lBQ1Q7SUFFQSw2Q0FBNkM7SUFDN0MwSSxxQkFBcUJ6TCxTQUFTLEVBQUU7UUFDOUJOLFFBQVFDLEdBQUcsQ0FBQztRQUNaRCxRQUFRQyxHQUFHLENBQUMsZUFBZU8sT0FBT0MsSUFBSSxDQUFDSDtRQUV2QyxNQUFNMEwsc0JBQXNCLFNBQUNDO2dCQUFLek0sd0VBQU87WUFDdkMsSUFBSSxPQUFPeU0sUUFBUSxZQUFZQSxRQUFRLE1BQU07Z0JBQzNDekwsT0FBT0MsSUFBSSxDQUFDd0wsS0FBS2pKLE9BQU8sQ0FBQ3lFLENBQUFBO29CQUN2QixJQUFJQSxRQUFRLHVCQUF1Qjt3QkFDakN6SCxRQUFRQyxHQUFHLENBQUMsK0NBQTBDLE9BQUxULE1BQUssTUFBSXlNLEdBQUcsQ0FBQ3hFLElBQUk7d0JBQ2xFLE1BQU1uRixTQUFTQyxNQUFNQyxPQUFPLENBQUN5SixHQUFHLENBQUN4RSxJQUFJLElBQUl3RSxHQUFHLENBQUN4RSxJQUFJLEdBQUc7NEJBQUN3RSxHQUFHLENBQUN4RSxJQUFJO3lCQUFDO3dCQUM5RG5GLE9BQU9VLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQzs0QkFDckJsRCxRQUFRQyxHQUFHLENBQUMsV0FBcUIsT0FBVmlELFFBQVEsR0FBRSxpQkFDL0IxQyxPQUFPQyxJQUFJLENBQUN3QyxPQUFPZ0IsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxVQUFVLENBQUM7NEJBRTlDbkUsUUFBUUMsR0FBRyxDQUFDLFdBQXFCLE9BQVZpRCxRQUFRLEdBQUUsZ0JBQWM7Z0NBQzdDZ0osYUFBYWpKLEtBQUssQ0FBQyxnQkFBZ0I7Z0NBQ25Da0osV0FBV2xKLEtBQUssQ0FBQyxjQUFjO2dDQUMvQm1KLFdBQVduSixLQUFLLENBQUMsY0FBYzs0QkFDakM7d0JBQ0Y7b0JBQ0YsT0FBTyxJQUFJLE9BQU9nSixHQUFHLENBQUN4RSxJQUFJLEtBQUssVUFBVTt3QkFDdkN1RSxvQkFBb0JDLEdBQUcsQ0FBQ3hFLElBQUksRUFBRSxHQUFXQSxPQUFSakksTUFBSyxLQUFPLE9BQUppSTtvQkFDM0M7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUF1RSxvQkFBb0IxTDtJQUN0QjtJQUVBK0wsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDL0ssT0FBTztJQUNyQjtJQUVBZ0wsU0FBU2xNLE9BQU8sRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQ2tCLE9BQU8sQ0FBQ2xCLFFBQVE7SUFDOUI7SUFFQW1NLGVBQWU7UUFDYixJQUFJLENBQUNqTCxPQUFPLEdBQUcsQ0FBQztJQUNsQjtJQXRyQkFrTCxZQUFZL0gsV0FBVyxDQUFFO1FBQ3ZCLElBQUksQ0FBQ0EsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNuRCxPQUFPLEdBQUcsQ0FBQztJQUNsQjtBQW9yQkY7QUFFQW1MLE9BQU9DLE9BQU8sR0FBRy9NIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9wYXJzZXJzL1N0b3J5UGFyc2VyLmpzPzY4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3QgSURNTFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvSURNTFV0aWxzJyk7XHJcblxyXG5jbGFzcyBTdG9yeVBhcnNlciB7XHJcbiAgY29uc3RydWN0b3Ioc3R5bGVQYXJzZXIpIHtcclxuICAgIHRoaXMuc3R5bGVQYXJzZXIgPSBzdHlsZVBhcnNlcjtcclxuICAgIHRoaXMuc3RvcmllcyA9IHt9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcGFyc2VTdG9yeUZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coYPCfk50gUGFyc2luZyBzdG9yeTogJHtmaWxlTmFtZX1gKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGFyc2VkID0geG1sUGFyc2VyLnBhcnNlKGNvbnRlbnQpO1xyXG4gICAgICBjb25zdCBzdG9yeUlkID0gcGF0aC5iYXNlbmFtZShmaWxlTmFtZSwgJy54bWwnKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHN0b3J5RGF0YSA9IHBhcnNlZC5TdG9yeSB8fCBwYXJzZWQ7XHJcbiAgICAgIFxyXG4gICAgICAvLyBBREQgVEhFU0UgU0lNUExFIExPR1MgRklSU1Q6XHJcbiAgICAgIGNvbnNvbGUubG9nKCc9PT0gU0lNUExFIERFQlVHIFRFU1QgPT09Jyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdTdG9yeSBmaWxlIG5hbWU6JywgZmlsZU5hbWUpO1xyXG4gICAgICBjb25zb2xlLmxvZygnUGFyc2VkIHN0b3J5IGtleXM6JywgT2JqZWN0LmtleXMoc3RvcnlEYXRhKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdSYXcgc3RvcnkgZGF0YSBzYW1wbGU6JywgSlNPTi5zdHJpbmdpZnkoc3RvcnlEYXRhLCBudWxsLCAyKS5zdWJzdHJpbmcoMCwgNTAwKSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IGRldGFpbGVkIHN0b3J5IGluZm9ybWF0aW9uXHJcbiAgICAgIGNvbnN0IGRldGFpbGVkU3RvcnkgPSB7XHJcbiAgICAgICAgc2VsZjogc3RvcnlEYXRhWydAX1NlbGYnXSxcclxuICAgICAgICBhcHBsaWVkVE9DU3R5bGU6IHN0b3J5RGF0YVsnQF9BcHBsaWVkVE9DU3R5bGUnXSB8fCAnbicsXHJcbiAgICAgICAgdXNlclRleHQ6IHN0b3J5RGF0YVsnQF9Vc2VyVGV4dCddICE9PSBmYWxzZSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBFeHRyYWN0IHN0b3J5IGNvbnRlbnQgd2l0aCBmb3JtYXR0aW5nXHJcbiAgICAgICAgY29udGVudDogdGhpcy5leHRyYWN0RGV0YWlsZWRTdG9yeUNvbnRlbnQoc3RvcnlEYXRhKSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBFeHRyYWN0IHRleHQgZm9ybWF0dGluZ1xyXG4gICAgICAgIHRleHRGb3JtYXR0aW5nOiB0aGlzLmV4dHJhY3RUZXh0Rm9ybWF0dGluZyhzdG9yeURhdGEpXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjbGVhblN0b3J5SWQgPSBzdG9yeUlkLnJlcGxhY2UoJ1N0b3J5XycsICcnKTtcclxuICAgICAgdGhpcy5zdG9yaWVzW2NsZWFuU3RvcnlJZF0gPSBkZXRhaWxlZFN0b3J5O1xyXG4gICAgICBcclxuICAgICAgLy8gRW5oYW5jZWQgbG9nZ2luZyB0byBzaG93IGxpbmUgYnJlYWtzXHJcbiAgICAgIGNvbnN0IHsgcGxhaW5UZXh0LCBsaW5lQnJlYWtJbmZvIH0gPSBkZXRhaWxlZFN0b3J5LmNvbnRlbnQ7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgU3RvcnkgJHtzdG9yeUlkfSBwYXJzZWQ6YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIENoYXJhY3RlcnM6ICR7cGxhaW5UZXh0Lmxlbmd0aH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIC0gV29yZHM6ICR7ZGV0YWlsZWRTdG9yeS5jb250ZW50LndvcmRDb3VudH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIC0gTGluZSBicmVha3M6ICR7bGluZUJyZWFrSW5mbz8ubGluZUJyZWFrQ291bnQgfHwgMH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIC0gVGV4dCBwcmV2aWV3OiBcIiR7cGxhaW5UZXh0LnN1YnN0cmluZygwLCA1MCkucmVwbGFjZSgvXFxuL2csICdcXFxcbicpfS4uLlwiYCk7XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHBhcnNpbmcgc3RvcnkgJHtmaWxlTmFtZX06YCwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZXBsYWNlIHRoZSBleGlzdGluZyBleHRyYWN0RGV0YWlsZWRTdG9yeUNvbnRlbnQgbWV0aG9kIHdpdGggdGhpcyBjb3JyZWN0ZWQgdmVyc2lvblxyXG4gIGV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudChzdG9yeURhdGEpIHtcclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBsZXQgZm9ybWF0dGVkQ29udGVudCA9IFtdO1xyXG4gICAgbGV0IHRleHRDb2xvciA9IG51bGw7XHJcbiAgICBsZXQgZGVidWdJbmZvID0gW107XHJcbiAgICBcclxuICAgIGNvbnN0IGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkgPSAoZWxlbWVudCwgZGVwdGggPSAwLCBjb250ZXh0ID0ge30pID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnRlbnQgKz0gZWxlbWVudDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIEVOSEFOQ0VEOiBTcGVjaWFsIGhhbmRsaW5nIGZvciBDaGFyYWN0ZXJTdHlsZVJhbmdlIHdpdGggc29waGlzdGljYXRlZCBCciBkZXRlY3Rpb25cclxuICAgICAgICBpZiAoZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlKSB7XHJcbiAgICAgICAgICBjb25zdCByYW5nZXMgPSBBcnJheS5pc0FycmF5KGVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZSkgPyBcclxuICAgICAgICAgICAgZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlIDogW2VsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZV07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFNJTVBMSUZJRUQgREVCVUc6IEp1c3QgbG9nIHByb2JsZW1hdGljIHRleHQgcmFuZ2VzXHJcbiAgICAgICAgICBjb25zdCBhbGxSYW5nZUNvbnRlbnQgPSByYW5nZXMubWFwKHIgPT4gci5Db250ZW50ID8gXHJcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHIuQ29udGVudCkgPyByLkNvbnRlbnQuam9pbignJykgOiBTdHJpbmcoci5Db250ZW50KSkgOiAnJykuam9pbignJyk7XHJcbiAgICAgICAgICBpZiAoYWxsUmFuZ2VDb250ZW50LmluY2x1ZGVzKCdwYXZvbHVwdHVzZGEnKSB8fCBhbGxSYW5nZUNvbnRlbnQuaW5jbHVkZXMoJ3BhJykgfHwgYWxsUmFuZ2VDb250ZW50LmluY2x1ZGVzKCd2b2x1cHR1c2RhJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CfmqggRk9VTkQgUkFOR0VTIFdJVEggUFJPQkxFTUFUSUMgVEVYVDonKTtcclxuICAgICAgICAgICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSByYW5nZS5Db250ZW50ID8gXHJcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA/IHJhbmdlLkNvbnRlbnQuam9pbignJykgOiBTdHJpbmcocmFuZ2UuQ29udGVudCkpIDogJyc7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFJhbmdlICR7aW5kZXh9OiBcIiR7Y29udGVudH1cImApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlLCByYW5nZUluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgZGlyZWN0IGZvbnQgcmVmZXJlbmNlcyBmcm9tIHRoZSBYTUwgcmFuZ2VcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0Rm9udFJlZiA9IHJhbmdlWydAX0FwcGxpZWRGb250J10gfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWydAX0ZvbnRGYW1pbHknXSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbJ0BfRm9udCddIHx8ICcnO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgICAgICAgICBwYXJhZ3JhcGhTdHlsZTogZWxlbWVudFsnQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGUnXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgIGNoYXJhY3RlclN0eWxlOiByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgIGZvbnRTaXplOiByYW5nZVsnQF9Qb2ludFNpemUnXSA/IHBhcnNlRmxvYXQocmFuZ2VbJ0BfUG9pbnRTaXplJ10pIDogbnVsbCxcclxuICAgICAgICAgICAgICBmb250UmVmZXJlbmNlOiBkaXJlY3RGb250UmVmLFxyXG4gICAgICAgICAgICAgIGZpbGxDb2xvcjogcmFuZ2VbJ0BfRmlsbENvbG9yJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgICBmb250U3R5bGU6IHJhbmdlWydAX0ZvbnRTdHlsZSddIHx8IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIERFQlVHOiBMb2cgZm9ybWF0dGluZyBleHRyYWN0aW9uIGZvciBhbnkgc3R5bGVkIHRleHQgKGdlbmVyaWMgY2hlY2spXHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlQ29udGVudCA9IHJhbmdlLkNvbnRlbnQgPyBcclxuICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA/IHJhbmdlLkNvbnRlbnQuam9pbignJykgOiBTdHJpbmcocmFuZ2UuQ29udGVudCkpIDogJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc1N0eWxlSW5mbyA9IHJhbmdlWydAX0ZvbnRTdHlsZSddIHx8IHJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ10gfHwgcmFuZ2VbJ0BfQXBwbGllZEZvbnQnXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChoYXNTdHlsZUluZm8gJiYgcmFuZ2VDb250ZW50LnRyaW0oKSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SnIFN0b3J5UGFyc2VyIC0gRXh0cmFjdGluZyBmb3JtYXR0aW5nIGZvciByYW5nZTonLCBKU09OLnN0cmluZ2lmeShyYW5nZUNvbnRlbnQuc3Vic3RyaW5nKDAsIDMwKSArICcuLi4nKSwge1xyXG4gICAgICAgICAgICAgICAgcmF3UmFuZ2VBdHRyaWJ1dGVzOiBPYmplY3Qua2V5cyhyYW5nZSkuZmlsdGVyKGsgPT4gay5zdGFydHNXaXRoKCdAXycpKSxcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZEZvcm1hdHRpbmc6IGZvcm1hdHRpbmcsXHJcbiAgICAgICAgICAgICAgICBmb250U3R5bGVGcm9tWE1MOiByYW5nZVsnQF9Gb250U3R5bGUnXSxcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlclN0eWxlRnJvbVhNTDogcmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10sXHJcbiAgICAgICAgICAgICAgICBwYXJhZ3JhcGhTdHlsZUZyb21YTUw6IGVsZW1lbnRbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ11cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRGb3JtYXR0aW5nID0gdGhpcy5zdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nKGZvcm1hdHRpbmcpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gRklYRUQ6IFByb2Nlc3MgY29udGVudCB3aXRoIHByb3BlciBzcGFjZSBwcmVzZXJ2YXRpb25cclxuICAgICAgICAgICAgaWYgKHJhbmdlLkNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudCkgPyByYW5nZS5Db250ZW50IDogW3JhbmdlLkNvbnRlbnRdO1xyXG4gICAgICAgICAgICAgIGNvbnRlbnRzLmZvckVhY2goKGNvbnRlbnRJdGVtLCBjb250ZW50SW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBJRE1MVXRpbHMuZGVjb2RlWE1MRW50aXRpZXMoU3RyaW5nKGNvbnRlbnRJdGVtKSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IHRleHQ7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiByZXNvbHZlZEZvcm1hdHRpbmdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IENoZWNrIGZvciBCciBlbGVtZW50cyBBRlRFUiBlYWNoIGNvbnRlbnQgaXRlbSB3aXRoaW4gdGhlIHNhbWUgcmFuZ2VcclxuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5CciAhPT0gdW5kZWZpbmVkICYmIGNvbnRlbnRJbmRleCA8IGNvbnRlbnRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgbGluZUJyZWFrVGV4dCA9ICdcXG4nO1xyXG4gICAgICAgICAgICAgICAgICBjb250ZW50ICs9IGxpbmVCcmVha1RleHQ7XHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbGluZUJyZWFrVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdiZXR3ZWVuX2NvbnRlbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnQnIgZWxlbWVudCB3aXRoaW4gcmFuZ2UnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTGluZSBicmVhayBkZXRlY3RlZCB3aXRoaW4gY29udGVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBDaGFyYWN0ZXJTdHlsZVJhbmdlWyR7cmFuZ2VJbmRleH1dLCBiZXR3ZWVuIGNvbnRlbnRbJHtjb250ZW50SW5kZXh9XSBhbmQgY29udGVudFske2NvbnRlbnRJbmRleCArIDF9XWAsXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiAnbGluZScsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSGFuZGxlIEJyIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5CciAhPT0gdW5kZWZpbmVkICYmICghcmFuZ2UuQ29udGVudCB8fCBBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICBjb25zdCBickVsZW1lbnRzID0gdGhpcy5leHRyYWN0QnJFbGVtZW50cyhyYW5nZSk7XHJcbiAgICAgICAgICAgICAgYnJFbGVtZW50cy5mb3JFYWNoKChickluZm8sIGJySW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSB0aGlzLmRldGVybWluZUxpbmVCcmVha1R5cGUoYnJJbmZvLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdGV4dDogbGluZUJyZWFrVGV4dCxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzogeyBcclxuICAgICAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogYnJJbmZvLnR5cGUgfHwgJ2xpbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBickluZm8ucG9zaXRpb24gfHwgJ2VuZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnQnIgZWxlbWVudCBhdCBlbmQgb2YgcmFuZ2UnXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaW5lIGJyZWFrIGRldGVjdGVkIGF0IGVuZCBvZiByYW5nZScsXHJcbiAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQ2hhcmFjdGVyU3R5bGVSYW5nZVske3JhbmdlSW5kZXh9XSwgQnJbJHtickluZGV4fV1gLFxyXG4gICAgICAgICAgICAgICAgICBicmVha1R5cGU6IGJySW5mby50eXBlIHx8ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogQWRkIHNwYWNlIGJldHdlZW4gY2hhcmFjdGVyIHN0eWxlIHJhbmdlcyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKHJhbmdlSW5kZXggPCByYW5nZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5leHRSYW5nZSA9IHJhbmdlc1tyYW5nZUluZGV4ICsgMV07XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gTW9yZSByb2J1c3Qgc3BhY2UgZGV0ZWN0aW9uXHJcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFRleHQgPSBjb250ZW50LnNsaWNlKC0xMCk7IC8vIENoZWNrIGxhc3QgMTAgY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSYW5nZUVuZHNXaXRoU3BhY2UgPSAvXFxzJC8udGVzdChjdXJyZW50VGV4dCk7IC8vIEFueSB3aGl0ZXNwYWNlIGF0IGVuZFxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGNvbnN0IG5leHRDb250ZW50ID0gbmV4dFJhbmdlLkNvbnRlbnQgPyBcclxuICAgICAgICAgICAgICAgIFN0cmluZyhBcnJheS5pc0FycmF5KG5leHRSYW5nZS5Db250ZW50KSA/IG5leHRSYW5nZS5Db250ZW50WzBdIDogbmV4dFJhbmdlLkNvbnRlbnQpIDogJyc7XHJcbiAgICAgICAgICAgICAgY29uc3QgbmV4dFJhbmdlU3RhcnRzV2l0aFNwYWNlID0gL15cXHMvLnRlc3QobmV4dENvbnRlbnQpOyAvLyBBbnkgd2hpdGVzcGFjZSBhdCBzdGFydFxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEFHR1JFU1NJVkUgRklYOiBBZGQgc3BhY2UgYmV0d2VlbiBBTEwgcmFuZ2VzIHVubGVzcyBleHBsaWNpdGx5IG5vdCBuZWVkZWRcclxuICAgICAgICAgICAgICBjb25zdCBzaG91bGRTa2lwU3BhY2UgPSBjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJhbmdlU3RhcnRzV2l0aFNwYWNlIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayhyYW5nZSwgbmV4dFJhbmdlLCBjb250ZXh0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIW5leHRSYW5nZS5Db250ZW50IHx8IC8vIFNraXAgaWYgbmV4dCByYW5nZSBoYXMgbm8gY29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENvbnRlbnQudHJpbSgpID09PSAnJzsgLy8gU2tpcCBpZiBuZXh0IGNvbnRlbnQgaXMgb25seSB3aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgaWYgKCFzaG91bGRTa2lwU3BhY2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZSA9IHJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddIHx8ICdub25lJztcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTdHlsZSA9IG5leHRSYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNwYWNlVGV4dCA9ICcgJztcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gc3BhY2VUZXh0O1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdGV4dDogc3BhY2VUZXh0LFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTcGFjZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdiZXR3ZWVuIGNoYXJhY3RlciBzdHlsZSByYW5nZXMgKGFnZ3Jlc3NpdmUpJyxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0eWxlXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdTcGFjZSBpbnNlcnRlZCBiZXR3ZWVuIGNoYXJhY3RlciBzdHlsZXMgKGFnZ3Jlc3NpdmUpJyxcclxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBCZXR3ZWVuIHJhbmdlcyAke3JhbmdlSW5kZXh9IGFuZCAke3JhbmdlSW5kZXggKyAxfWAsXHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgbmV4dFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICByZWFzb246ICdEZWZhdWx0IHNwYWNlIGluc2VydGlvbiAtIHdvcmRzIGxpa2VseSBzcGxpdCBhY3Jvc3MgcmFuZ2VzJyxcclxuICAgICAgICAgICAgICAgICAgY3VycmVudFRleHRFbmQ6IGN1cnJlbnRUZXh0LnNsaWNlKC01KSxcclxuICAgICAgICAgICAgICAgICAgbmV4dFRleHRTdGFydDogbmV4dENvbnRlbnQuc2xpY2UoMCwgNSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdTcGFjZSBpbnNlcnRpb24gc2tpcHBlZCcsXHJcbiAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQmV0d2VlbiByYW5nZXMgJHtyYW5nZUluZGV4fSBhbmQgJHtyYW5nZUluZGV4ICsgMX1gLFxyXG4gICAgICAgICAgICAgICAgICByZWFzb246IGN1cnJlbnRSYW5nZUVuZHNXaXRoU3BhY2UgPyAnQ3VycmVudCByYW5nZSBlbmRzIHdpdGggc3BhY2UnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2UgPyAnTmV4dCByYW5nZSBzdGFydHMgd2l0aCBzcGFjZScgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICFuZXh0UmFuZ2UuQ29udGVudCA/ICdOZXh0IHJhbmdlIGhhcyBubyBjb250ZW50JyA6IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb250ZW50LnRyaW0oKSA9PT0gJycgPyAnTmV4dCBjb250ZW50IGlzIG9ubHkgd2hpdGVzcGFjZScgOiAnTGluZSBicmVhayB3b3VsZCBiZSBpbnNlcnRlZCcsXHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0RW5kOiBjdXJyZW50VGV4dC5zbGljZSgtNSksXHJcbiAgICAgICAgICAgICAgICAgIG5leHRUZXh0U3RhcnQ6IG5leHRDb250ZW50LnNsaWNlKDAsIDUpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIGV4cGxpY2l0IGxpbmUgYnJlYWtzIGJldHdlZW4gcmFuZ2VzIChmb3IgY2FzZXMgd2hlcmUgc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsgaXMgdHJ1ZSlcclxuICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayhyYW5nZSwgbmV4dFJhbmdlLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1wbGljaXRCcmVhayA9ICdcXG4nO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBpbXBsaWNpdEJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdGV4dDogaW1wbGljaXRCcmVhayxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiAnaW1wbGljaXQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ2JldHdlZW4gcmFuZ2VzJ1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnSW1wbGljaXQgbGluZSBicmVhaycsXHJcbiAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQmV0d2VlbiByYW5nZXMgJHtyYW5nZUluZGV4fSBhbmQgJHtyYW5nZUluZGV4ICsgMX1gXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBjb250aW51ZSBwcm9jZXNzaW5nIHRvIGF2b2lkIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEVOSEFOQ0VEOiBIYW5kbGUgUGFyYWdyYXBoU3R5bGVSYW5nZSB3aXRoIGNvbnRleHRcclxuICAgICAgICBpZiAoZWxlbWVudC5QYXJhZ3JhcGhTdHlsZVJhbmdlKSB7XHJcbiAgICAgICAgICBjb25zdCByYW5nZXMgPSBBcnJheS5pc0FycmF5KGVsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZSkgPyBcclxuICAgICAgICAgICAgZWxlbWVudC5QYXJhZ3JhcGhTdHlsZVJhbmdlIDogW2VsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZV07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoQ29udGV4dCA9IHtcclxuICAgICAgICAgICAgICAuLi5jb250ZXh0LFxyXG4gICAgICAgICAgICAgIHBhcmFncmFwaEluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgICB0b3RhbFBhcmFncmFwaHM6IHJhbmdlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgYXBwbGllZFN0eWxlOiByYW5nZVsnQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGUnXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZXh0cmFjdFRleHRSZWN1cnNpdmVseShyYW5nZSwgZGVwdGggKyAxLCBwYXJhZ3JhcGhDb250ZXh0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFkZCBwYXJhZ3JhcGggYnJlYWsgYmV0d2VlbiBwYXJhZ3JhcGhzIChidXQgbm90IGFmdGVyIHRoZSBsYXN0IG9uZSlcclxuICAgICAgICAgICAgaWYgKGluZGV4IDwgcmFuZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhCcmVhayA9ICdcXG4nO1xyXG4gICAgICAgICAgICAgIGNvbnRlbnQgKz0gcGFyYWdyYXBoQnJlYWs7XHJcbiAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcmFncmFwaEJyZWFrLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdwYXJhZ3JhcGgnLFxyXG4gICAgICAgICAgICAgICAgICBzb3VyY2U6ICdiZXR3ZWVuIHBhcmFncmFwaHMnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goeyBcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdQYXJhZ3JhcGggYnJlYWsnLCBcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgYmV0d2VlbiBwYXJhZ3JhcGhzICR7aW5kZXh9IGFuZCAke2luZGV4ICsgMX1gIFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSGFuZGxlIGRpcmVjdCBDb250ZW50IGVsZW1lbnRzICh3aGVuIG5vdCBpbnNpZGUgQ2hhcmFjdGVyU3R5bGVSYW5nZSlcclxuICAgICAgICBpZiAoZWxlbWVudC5Db250ZW50ICYmICFlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGxldCB0ZXh0ID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkNvbnRlbnQpID8gZWxlbWVudC5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKGVsZW1lbnQuQ29udGVudCk7XHJcbiAgICAgICAgICB0ZXh0ID0gSURNTFV0aWxzLmRlY29kZVhNTEVudGl0aWVzKHRleHQpO1xyXG4gICAgICAgICAgY29udGVudCArPSB0ZXh0O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBmb3JtYXR0aW5nID0ge1xyXG4gICAgICAgICAgICBwYXJhZ3JhcGhTdHlsZTogZWxlbWVudFsnQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGUnXSB8fCBudWxsLFxyXG4gICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZTogZWxlbWVudFsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCBudWxsLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogZWxlbWVudFsnQF9Qb2ludFNpemUnXSB8fCBudWxsLFxyXG4gICAgICAgICAgICBmb250RmFtaWx5OiBlbGVtZW50WydAX0FwcGxpZWRGb250J10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZmlsbENvbG9yOiBlbGVtZW50WydAX0ZpbGxDb2xvciddIHx8IG51bGxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRGb3JtYXR0aW5nID0gdGhpcy5zdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nKGZvcm1hdHRpbmcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICBmb3JtYXR0aW5nOiByZXNvbHZlZEZvcm1hdHRpbmdcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBFTkhBTkNFRDogRGlyZWN0IEJyIGVsZW1lbnQgaGFuZGxpbmcgKG91dHNpZGUgb2YgcmFuZ2VzKVxyXG4gICAgICAgIGlmIChlbGVtZW50LkJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGJyRWxlbWVudHMgPSBBcnJheS5pc0FycmF5KGVsZW1lbnQuQnIpID8gZWxlbWVudC5CciA6IFtlbGVtZW50LkJyXTtcclxuICAgICAgICAgIGJyRWxlbWVudHMuZm9yRWFjaCgoYnIsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSAnXFxuJztcclxuICAgICAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHQsXHJcbiAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogJ2V4cGxpY2l0JyxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogJ2RpcmVjdCBCciBlbGVtZW50J1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICB0eXBlOiAnRGlyZWN0IEJyIGVsZW1lbnQnLFxyXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiBgRGlyZWN0IGVsZW1lbnQsIGluZGV4ICR7aW5kZXh9YFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDb250aW51ZSB3aXRoIG90aGVyIG5lc3RlZCBlbGVtZW50c1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGVsZW1lbnQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aCgnQF8nKSAmJiBcclxuICAgICAgICAgICAgICBrZXkgIT09ICdDb250ZW50JyAmJiBcclxuICAgICAgICAgICAgICBrZXkgIT09ICdCcicgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQ2hhcmFjdGVyU3R5bGVSYW5nZScgJiZcclxuICAgICAgICAgICAgICBrZXkgIT09ICdQYXJhZ3JhcGhTdHlsZVJhbmdlJykge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGl0ZW0gPT4gZXh0cmFjdFRleHRSZWN1cnNpdmVseShpdGVtLCBkZXB0aCArIDEsIGNvbnRleHQpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIGRlcHRoIDwgMTApIHtcclxuICAgICAgICAgICAgICBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5KHZhbHVlLCBkZXB0aCArIDEsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkoc3RvcnlEYXRhKTtcclxuICAgIFxyXG4gICAgLy8gRU5IQU5DRUQ6IFByb2Nlc3MgYW5kIGNsZWFuIHVwIHRoZSBjb250ZW50IHdpdGggc29waGlzdGljYXRlZCBsaW5lIGJyZWFrIHByZXNlcnZhdGlvblxyXG4gICAgY29uc3QgcHJvY2Vzc2VkQ29udGVudCA9IElETUxVdGlscy5zb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyhjb250ZW50KTtcclxuICAgIFxyXG4gICAgLy8gREVCVUc6IExvZyBzcGFjZSBwcmVzZXJ2YXRpb24gcmVzdWx0c1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk50gVGV4dCBleHRyYWN0aW9uIHJlc3VsdHM6Jyk7XHJcbiAgICBjb25zb2xlLmxvZygnICAgLSBPcmlnaW5hbCBjb250ZW50IGxlbmd0aDonLCBjb250ZW50Lmxlbmd0aCk7XHJcbiAgICBjb25zb2xlLmxvZygnICAgLSBQcm9jZXNzZWQgY29udGVudCBsZW5ndGg6JywgcHJvY2Vzc2VkQ29udGVudC5sZW5ndGgpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gU3BhY2UgcHJlc2VydmF0aW9uIGV2ZW50czonLCBkZWJ1Z0luZm8uZmlsdGVyKGluZm8gPT4gaW5mby50eXBlLmluY2x1ZGVzKCdTcGFjZSBpbnNlcnRlZCcpKS5sZW5ndGgpO1xyXG4gICAgXHJcbiAgICAvLyBTUEVDSUZJQyBERUJVRzogQ2hlY2sgZm9yIHRoZSBwcm9ibGVtYXRpYyBcInBhdm9sdXB0dXNkYVwiIHRleHQgKHNpbXBsaWZpZWQpXHJcbiAgICBpZiAocHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykgfHwgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygncGEnKSAmJiBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCd2b2x1cHR1c2RhJykpIHtcclxuICAgICAgY29uc29sZS5sb2coJ/CfmqggRk9VTkQgUFJPQkxFTUFUSUMgVEVYVDonKTtcclxuICAgICAgY29uc29sZS5sb2coJyAgIC0gQ29udGFpbnMgXCJwYXZvbHVwdHVzZGFcIjonLCBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCdwYXZvbHVwdHVzZGEnKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIENvbnRhaW5zIFwicGEgdm9sdXB0dXNkYVwiOicsIHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3BhIHZvbHVwdHVzZGEnKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIEZvcm1hdHRlZENvbnRlbnQgYnJlYWtkb3duOicsIGZvcm1hdHRlZENvbnRlbnQubWFwKGl0ZW0gPT4gaXRlbS50ZXh0KS5qb2luKCd8JykpO1xyXG4gICAgfVxyXG4gICAgXHJcblxyXG4gICAgXHJcbiAgICBjb25zdCBsaW5lQnJlYWtJbmZvID0ge1xyXG4gICAgICBoYXNMaW5lQnJlYWtzOiBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCdcXG4nKSxcclxuICAgICAgbGluZUJyZWFrQ291bnQ6IChwcm9jZXNzZWRDb250ZW50Lm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aCxcclxuICAgICAgbGluZUJyZWFrVHlwZXM6IHRoaXMuYW5hbHl6ZUxpbmVCcmVha1R5cGVzKGZvcm1hdHRlZENvbnRlbnQpLFxyXG4gICAgICBkZWJ1Z0luZm86IGRlYnVnSW5mbyxcclxuICAgICAgc3BhY2VQcmVzZXJ2YXRpb25Db3VudDogZGVidWdJbmZvLmZpbHRlcihpbmZvID0+IGluZm8udHlwZS5pbmNsdWRlcygnU3BhY2UgaW5zZXJ0ZWQnKSkubGVuZ3RoXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwbGFpblRleHQ6IHByb2Nlc3NlZENvbnRlbnQsXHJcbiAgICAgIGZvcm1hdHRlZENvbnRlbnQ6IGZvcm1hdHRlZENvbnRlbnQuZmlsdGVyKGl0ZW0gPT4gaXRlbS50ZXh0ICYmIGl0ZW0udGV4dC5sZW5ndGggPiAwKSxcclxuICAgICAgd29yZENvdW50OiBJRE1MVXRpbHMuY291bnRXb3Jkcyhwcm9jZXNzZWRDb250ZW50LnJlcGxhY2UoL1xcbi9nLCAnICcpKSxcclxuICAgICAgY2hhcmFjdGVyQ291bnQ6IHByb2Nlc3NlZENvbnRlbnQubGVuZ3RoLFxyXG4gICAgICB0ZXh0Q29sb3I6IHRleHRDb2xvcixcclxuICAgICAgbGluZUJyZWFrSW5mbzogbGluZUJyZWFrSW5mb1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEFkZCB0aGlzIGhlbHBlciBtZXRob2QgdG8gYmV0dGVyIGhhbmRsZSBtaXhlZCBjb250ZW50IGFuZCBCciBlbGVtZW50c1xyXG4gIGFuYWx5emVDb250ZW50U3RydWN0dXJlKHJhbmdlKSB7XHJcbiAgICBjb25zdCBzdHJ1Y3R1cmUgPSB7XHJcbiAgICAgIGhhc0NvbnRlbnQ6ICEhcmFuZ2UuQ29udGVudCxcclxuICAgICAgaGFzQnI6IHJhbmdlLkJyICE9PSB1bmRlZmluZWQsXHJcbiAgICAgIGNvbnRlbnRJdGVtczogcmFuZ2UuQ29udGVudCA/IChBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudCA6IFtyYW5nZS5Db250ZW50XSkgOiBbXSxcclxuICAgICAgYnJFbGVtZW50czogcmFuZ2UuQnIgPyAoQXJyYXkuaXNBcnJheShyYW5nZS5CcikgPyByYW5nZS5CciA6IFtyYW5nZS5Ccl0pIDogW11cclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdDb250ZW50IHN0cnVjdHVyZSBhbmFseXNpczonLCBzdHJ1Y3R1cmUpO1xyXG4gICAgcmV0dXJuIHN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIGhlbHBlciBmb3IgcHJvY2Vzc2luZyBpbnRlcmxlYXZlZCBjb250ZW50IGFuZCBicmVha3NcclxuICBwcm9jZXNzSW50ZXJsZWF2ZWRDb250ZW50KHJhbmdlLCByZXNvbHZlZEZvcm1hdHRpbmcpIHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBcclxuICAgIC8vIFRoaXMgbWV0aG9kIHdvdWxkIG5lZWQgYWNjZXNzIHRvIHRoZSBhY3R1YWwgWE1MIHN0cnVjdHVyZSB0byBkZXRlcm1pbmVcclxuICAgIC8vIHRoZSBleGFjdCBvcmRlciBvZiBDb250ZW50IGFuZCBCciBlbGVtZW50cy4gRm9yIG5vdywgd2UnbGwgdXNlIHRoZSBcclxuICAgIC8vIGFwcHJvYWNoIGFib3ZlIHdoaWNoIGhhbmRsZXMgdGhlIG1vc3QgY29tbW9uIGNhc2UuXHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogSGVscGVyIG1ldGhvZCB0byBleHRyYWN0IEJyIGVsZW1lbnRzIHdpdGggY29udGV4dFxyXG4gIGV4dHJhY3RCckVsZW1lbnRzKHJhbmdlKSB7XHJcbiAgICBjb25zdCBickVsZW1lbnRzID0gW107XHJcbiAgICBcclxuICAgIGlmIChyYW5nZS5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhbmdlLkJyKSkge1xyXG4gICAgICAgIHJhbmdlLkJyLmZvckVhY2goKGJyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgYnJFbGVtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogaW5kZXggPT09IDAgPyAnc3RhcnQnIDogJ21pZGRsZScsXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IGJyXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBickVsZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxyXG4gICAgICAgICAgZWxlbWVudDogcmFuZ2UuQnJcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gYnJFbGVtZW50cztcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgbGluZSBicmVhayB0eXBlXHJcbiAgZGV0ZXJtaW5lTGluZUJyZWFrVHlwZShickluZm8sIGNvbnRleHQpIHtcclxuICAgIC8vIERpZmZlcmVudCBsaW5lIGJyZWFrIGNoYXJhY3RlcnMgYmFzZWQgb24gY29udGV4dFxyXG4gICAgc3dpdGNoIChickluZm8udHlwZSkge1xyXG4gICAgICBjYXNlICdwYXJhZ3JhcGgnOlxyXG4gICAgICAgIHJldHVybiAnXFxuXFxuJzsgLy8gRG91YmxlIGxpbmUgYnJlYWsgZm9yIHBhcmFncmFwaCBzZXBhcmF0aW9uXHJcbiAgICAgIGNhc2UgJ2ZvcmNlZCc6XHJcbiAgICAgICAgcmV0dXJuICdcXG4nOyAvLyBGb3JjZWQgbGluZSBicmVhayAoU2hpZnQrRW50ZXIgZXF1aXZhbGVudClcclxuICAgICAgY2FzZSAnbGluZSc6XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuICdcXG4nOyAvLyBTdGFuZGFyZCBsaW5lIGJyZWFrXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBEZXRlcm1pbmUgaWYgYW4gaW1wbGljaXQgbGluZSBicmVhayBzaG91bGQgYmUgaW5zZXJ0ZWRcclxuICBzaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayhjdXJyZW50UmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkge1xyXG4gICAgLy8gRG9uJ3QgaW5zZXJ0IGltcGxpY2l0IGJyZWFrcyBpZiBleHBsaWNpdCBCciBlbGVtZW50cyBhcmUgcHJlc2VudFxyXG4gICAgaWYgKGN1cnJlbnRSYW5nZS5CciAhPT0gdW5kZWZpbmVkIHx8IG5leHRSYW5nZS5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSW5zZXJ0IGJyZWFrcyBiZXR3ZWVuIGRpZmZlcmVudCBjaGFyYWN0ZXIgc3R5bGVzIGluIGRpZmZlcmVudCBwYXJhZ3JhcGhzXHJcbiAgICBjb25zdCBjdXJyZW50Q2hhclN0eWxlID0gY3VycmVudFJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddO1xyXG4gICAgY29uc3QgbmV4dENoYXJTdHlsZSA9IG5leHRSYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXTtcclxuICAgIFxyXG4gICAgLy8gSWYgd2UncmUgaW4gYSBjb250ZXh0IHdoZXJlIHN0eWxlcyBjaGFuZ2Ugc2lnbmlmaWNhbnRseSwgYWRkIGEgYnJlYWtcclxuICAgIGlmIChjdXJyZW50Q2hhclN0eWxlICYmIG5leHRDaGFyU3R5bGUgJiYgY3VycmVudENoYXJTdHlsZSAhPT0gbmV4dENoYXJTdHlsZSkge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIG1pZ2h0IGJlIGEgdGl0bGUvaGVhZGluZyBmb2xsb3dlZCBieSBib2R5IHRleHRcclxuICAgICAgY29uc3Qgc3R5bGVJbmRpY2F0ZXNCcmVhayA9IHRoaXMuc3R5bGVJbmRpY2F0ZXNMaW5lQnJlYWsoY3VycmVudENoYXJTdHlsZSwgbmV4dENoYXJTdHlsZSk7XHJcbiAgICAgIHJldHVybiBzdHlsZUluZGljYXRlc0JyZWFrO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBBbmFseXplIGlmIHN0eWxlIGNoYW5nZSBpbmRpY2F0ZXMgYSBsaW5lIGJyZWFrXHJcbiAgc3R5bGVJbmRpY2F0ZXNMaW5lQnJlYWsoY3VycmVudFN0eWxlLCBuZXh0U3R5bGUpIHtcclxuICAgIGNvbnN0IHRpdGxlSW5kaWNhdG9ycyA9IFsndGl0bGUnLCAnaGVhZGluZycsICdoZWFkZXInXTtcclxuICAgIGNvbnN0IGJvZHlJbmRpY2F0b3JzID0gWydib2R5JywgJ3RleHQnLCAnbm9ybWFsJ107XHJcbiAgICBcclxuICAgIGNvbnN0IGN1cnJlbnRJc1RpdGxlID0gdGl0bGVJbmRpY2F0b3JzLnNvbWUoaW5kaWNhdG9yID0+IFxyXG4gICAgICBjdXJyZW50U3R5bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhpbmRpY2F0b3IpKTtcclxuICAgIGNvbnN0IG5leHRJc0JvZHkgPSBib2R5SW5kaWNhdG9ycy5zb21lKGluZGljYXRvciA9PiBcclxuICAgICAgbmV4dFN0eWxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5kaWNhdG9yKSk7XHJcbiAgICBcclxuICAgIHJldHVybiBjdXJyZW50SXNUaXRsZSAmJiBuZXh0SXNCb2R5O1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogQW5hbHl6ZSBsaW5lIGJyZWFrIHR5cGVzIGluIGZvcm1hdHRlZCBjb250ZW50XHJcbiAgYW5hbHl6ZUxpbmVCcmVha1R5cGVzKGZvcm1hdHRlZENvbnRlbnQpIHtcclxuICAgIGNvbnN0IHR5cGVzID0ge1xyXG4gICAgICBleHBsaWNpdDogMCwgICAgICAvLyBGcm9tIDxCci8+IGVsZW1lbnRzXHJcbiAgICAgIGltcGxpY2l0OiAwLCAgICAgIC8vIEluZmVycmVkIGZyb20gc3R5bGUgY2hhbmdlc1xyXG4gICAgICBwYXJhZ3JhcGg6IDAsICAgICAvLyBCZXR3ZWVuIHBhcmFncmFwaHNcclxuICAgICAgZGlyZWN0OiAwICAgICAgICAvLyBEaXJlY3QgQnIgZWxlbWVudHNcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZvcm1hdHRlZENvbnRlbnQuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgaWYgKGl0ZW0uZm9ybWF0dGluZz8uaXNCcmVhaykge1xyXG4gICAgICAgIGNvbnN0IGJyZWFrVHlwZSA9IGl0ZW0uZm9ybWF0dGluZy5icmVha1R5cGUgfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIGlmICh0eXBlcy5oYXNPd25Qcm9wZXJ0eShicmVha1R5cGUpKSB7XHJcbiAgICAgICAgICB0eXBlc1ticmVha1R5cGVdKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHR5cGVzO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdERldGFpbGVkRm9ybWF0dGluZ0Zyb21SYW5nZShyYW5nZSkge1xyXG4gICAgY29uc3QgZm9ybWF0dGluZyA9IHt9O1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGFsbCBwb3NzaWJsZSBmb250IGF0dHJpYnV0ZXNcclxuICAgIGNvbnN0IGZvbnRBdHRyaWJ1dGVzID0gW1xyXG4gICAgICAnQF9BcHBsaWVkRm9udCcsICdAX0ZvbnRGYW1pbHknLCAnQF9Gb250JywgXHJcbiAgICAgICdAX1Bvc3RTY3JpcHROYW1lJywgJ0BfRm9udE5hbWUnXHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICBmb250QXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4ge1xyXG4gICAgICBpZiAocmFuZ2VbYXR0cl0pIHtcclxuICAgICAgICBmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UgPSByYW5nZVthdHRyXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgZm9udCBhbmQgc2l6ZSBhdHRyaWJ1dGVzXHJcbiAgICBmb3JtYXR0aW5nLmZvbnRTaXplID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9Qb2ludFNpemUnXSk7XHJcbiAgICBcclxuICAgIC8vIEVOSEFOQ0VEOiBFeHRyYWN0IGxlYWRpbmcgd2l0aCBwcm9wZXIgcHJvY2Vzc2luZ1xyXG4gICAgY29uc3QgcmF3TGVhZGluZyA9IHJhbmdlWydAX0xlYWRpbmcnXTtcclxuICAgIGZvcm1hdHRpbmcubGVhZGluZyA9IHRoaXMucHJvY2Vzc0xlYWRpbmdWYWx1ZShyYXdMZWFkaW5nLCBmb3JtYXR0aW5nLmZvbnRTaXplKTtcclxuICAgIGZvcm1hdHRpbmcubGVhZGluZ1R5cGUgPSB0aGlzLmRldGVybWluZUxlYWRpbmdUeXBlKHJhd0xlYWRpbmcpO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGNvbG9yIGFuZCBzdHlsZSBhdHRyaWJ1dGVzXHJcbiAgICBmb3JtYXR0aW5nLmZpbGxDb2xvciA9IHJhbmdlWydAX0ZpbGxDb2xvciddO1xyXG4gICAgZm9ybWF0dGluZy5zdHJva2VDb2xvciA9IHJhbmdlWydAX1N0cm9rZUNvbG9yJ107XHJcbiAgICBmb3JtYXR0aW5nLmZvbnRTdHlsZSA9IHJhbmdlWydAX0ZvbnRTdHlsZSddO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGFkdmFuY2VkIHR5cG9ncmFwaHkgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy50cmFja2luZyA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfVHJhY2tpbmcnXSk7XHJcbiAgICBmb3JtYXR0aW5nLmJhc2VsaW5lU2hpZnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0Jhc2VsaW5lU2hpZnQnXSk7XHJcbiAgICBmb3JtYXR0aW5nLmtlcm5pbmcgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0tlcm5pbmcnXSk7XHJcbiAgICBmb3JtYXR0aW5nLmhvcml6b250YWxTY2FsZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfSG9yaXpvbnRhbFNjYWxlJ10pIHx8IDEwMDtcclxuICAgIGZvcm1hdHRpbmcudmVydGljYWxTY2FsZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfVmVydGljYWxTY2FsZSddKSB8fCAxMDA7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgcGFyYWdyYXBoLWxldmVsIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxyXG4gICAgLy8gQ1JJVElDQUwgRklYOiBPbmx5IHNldCBhbGlnbm1lbnQgaWYgZXhwbGljaXRseSBzcGVjaWZpZWQsIGFsbG93aW5nIHBhcmFncmFwaCBpbmhlcml0YW5jZVxyXG4gICAgY29uc3QgZXhwbGljaXRBbGlnbm1lbnQgPSByYW5nZVsnQF9KdXN0aWZpY2F0aW9uJ10gfHwgcmFuZ2VbJ0BfQWxpZ25tZW50J107XHJcbiAgICBpZiAoZXhwbGljaXRBbGlnbm1lbnQpIHtcclxuICAgICAgZm9ybWF0dGluZy5hbGlnbm1lbnQgPSBleHBsaWNpdEFsaWdubWVudDtcclxuICAgIH1cclxuICAgIGZvcm1hdHRpbmcubGVmdEluZGVudCA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfTGVmdEluZGVudCddKTtcclxuICAgIGZvcm1hdHRpbmcucmlnaHRJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1JpZ2h0SW5kZW50J10pO1xyXG4gICAgZm9ybWF0dGluZy5maXJzdExpbmVJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0ZpcnN0TGluZUluZGVudCddKTtcclxuICAgIGZvcm1hdHRpbmcuc3BhY2VCZWZvcmUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1NwYWNlQmVmb3JlJ10pO1xyXG4gICAgZm9ybWF0dGluZy5zcGFjZUFmdGVyID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9TcGFjZUFmdGVyJ10pO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1NcclxuICAgIGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodCA9IHRoaXMuY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChmb3JtYXR0aW5nKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmc7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IFByb2Nlc3MgbGVhZGluZyB2YWx1ZXMgd2l0aCBJbkRlc2lnbi1zcGVjaWZpYyBsb2dpY1xyXG4gIHByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9udFNpemUpIHtcclxuICAgIGlmICghcmF3TGVhZGluZykgcmV0dXJuICdhdXRvJztcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIFwiYXV0b1wiIGxlYWRpbmdcclxuICAgIGlmIChyYXdMZWFkaW5nID09PSAnYXV0bycgfHwgcmF3TGVhZGluZyA9PT0gJ0F1dG8nKSB7XHJcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IGZvbnRTaXplICogMS4yIDogJ2F1dG8nOyAvLyBJbkRlc2lnbiBkZWZhdWx0IGF1dG8gbGVhZGluZyBpcyAxMjAlXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBudW1lcmljIGxlYWRpbmcgKGluIHBvaW50cylcclxuICAgIGNvbnN0IG51bWVyaWNMZWFkaW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYXdMZWFkaW5nKTtcclxuICAgIGlmIChudW1lcmljTGVhZGluZykge1xyXG4gICAgICByZXR1cm4gbnVtZXJpY0xlYWRpbmc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBwZXJjZW50YWdlLWJhc2VkIGxlYWRpbmdcclxuICAgIGlmIChyYXdMZWFkaW5nLmluY2x1ZGVzKCclJykpIHtcclxuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQocmF3TGVhZGluZy5yZXBsYWNlKCclJywgJycpKTtcclxuICAgICAgcmV0dXJuIGZvbnRTaXplID8gKGZvbnRTaXplICogcGVyY2VudGFnZSAvIDEwMCkgOiAnYXV0byc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAnYXV0byc7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IERldGVybWluZSB0aGUgdHlwZSBvZiBsZWFkaW5nIGJlaW5nIHVzZWRcclxuICBkZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcgfHwgcmF3TGVhZGluZyA9PT0gJ2F1dG8nIHx8IHJhd0xlYWRpbmcgPT09ICdBdXRvJykge1xyXG4gICAgICByZXR1cm4gJ2F1dG8nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcygnJScpKSB7XHJcbiAgICAgIHJldHVybiAncGVyY2VudGFnZSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhd0xlYWRpbmcpKSB7XHJcbiAgICAgIHJldHVybiAnYWJzb2x1dGUnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1MgcmVuZGVyaW5nXHJcbiAgY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChmb3JtYXR0aW5nKSB7XHJcbiAgICBjb25zdCBmb250U2l6ZSA9IGZvcm1hdHRpbmcuZm9udFNpemUgfHwgMTI7XHJcbiAgICBjb25zdCBsZWFkaW5nID0gZm9ybWF0dGluZy5sZWFkaW5nO1xyXG4gICAgXHJcbiAgICBpZiAobGVhZGluZyA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgIHJldHVybiAxLjI7IC8vIENTUyBsaW5lLWhlaWdodCByYXRpbyBmb3IgYXV0b1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodHlwZW9mIGxlYWRpbmcgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIC8vIENvbnZlcnQgcG9pbnRzIHRvIENTUyBsaW5lLWhlaWdodCByYXRpb1xyXG4gICAgICByZXR1cm4gbGVhZGluZyAvIGZvbnRTaXplO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gMS4yOyAvLyBGYWxsYmFja1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFRleHRGb3JtYXR0aW5nKHN0b3J5RGF0YSkge1xyXG4gICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgcGFyYWdyYXBoU3R5bGVzOiBbXSxcclxuICAgICAgY2hhcmFjdGVyU3R5bGVzOiBbXSxcclxuICAgICAgYXBwbGllZFN0eWxlczogW11cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgYXBwbGllZCBwYXJhZ3JhcGggc3R5bGVzXHJcbiAgICBpZiAoc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2UpIHtcclxuICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZSkgPyBzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZSA6IFtzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZV07XHJcbiAgICAgIFxyXG4gICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwbGllZFN0eWxlID0gcmFuZ2VbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ107XHJcbiAgICAgICAgaWYgKGFwcGxpZWRTdHlsZSAmJiAhZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZXMuaW5jbHVkZXMoYXBwbGllZFN0eWxlKSkge1xyXG4gICAgICAgICAgZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZXMucHVzaChhcHBsaWVkU3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBFeHRyYWN0IGNoYXJhY3RlciBzdHlsZXMgd2l0aGluIHBhcmFncmFwaCByYW5nZXNcclxuICAgICAgICBpZiAocmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgY2hhclJhbmdlcyA9IEFycmF5LmlzQXJyYXkocmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZSkgPyByYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlIDogW3JhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjaGFyUmFuZ2VzLmZvckVhY2goY2hhclJhbmdlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hhclN0eWxlID0gY2hhclJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddO1xyXG4gICAgICAgICAgICBpZiAoY2hhclN0eWxlICYmICFmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlcy5pbmNsdWRlcyhjaGFyU3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZXMucHVzaChjaGFyU3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZm9ybWF0dGluZztcclxuICB9XHJcblxyXG4gIC8vIEFkZCB0aGlzIG1ldGhvZCB0byBkZWJ1ZyByYXcgc3RvcnkgY29udGVudFxyXG4gIGRlYnVnUmF3U3RvcnlDb250ZW50KHN0b3J5RGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coJ1xcbvCflI0gUkFXIFNUT1JZIENPTlRFTlQgREVCVUc6Jyk7XHJcbiAgICBjb25zb2xlLmxvZygnU3Rvcnkga2V5czonLCBPYmplY3Qua2V5cyhzdG9yeURhdGEpKTtcclxuICAgIFxyXG4gICAgY29uc3QgZmluZENoYXJhY3RlclJhbmdlcyA9IChvYmosIHBhdGggPSAnJykgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICBpZiAoa2V5ID09PSAnQ2hhcmFjdGVyU3R5bGVSYW5nZScpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfk50gRm91bmQgQ2hhcmFjdGVyU3R5bGVSYW5nZSBhdCAke3BhdGh9OmAsIG9ialtrZXldKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShvYmpba2V5XSkgPyBvYmpba2V5XSA6IFtvYmpba2V5XV07XHJcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBSYW5nZSAke2luZGV4ICsgMX0gYXR0cmlidXRlczpgLCBcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhbmdlKS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoJ0BfJykpXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBSYW5nZSAke2luZGV4ICsgMX0gZm9udCBpbmZvOmAsIHtcclxuICAgICAgICAgICAgICAgIEFwcGxpZWRGb250OiByYW5nZVsnQF9BcHBsaWVkRm9udCddLFxyXG4gICAgICAgICAgICAgICAgRm9udFN0eWxlOiByYW5nZVsnQF9Gb250U3R5bGUnXSxcclxuICAgICAgICAgICAgICAgIFBvaW50U2l6ZTogcmFuZ2VbJ0BfUG9pbnRTaXplJ11cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZmluZENoYXJhY3RlclJhbmdlcyhvYmpba2V5XSwgYCR7cGF0aH0uJHtrZXl9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZpbmRDaGFyYWN0ZXJSYW5nZXMoc3RvcnlEYXRhKTtcclxuICB9XHJcblxyXG4gIGdldFN0b3JpZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdG9yaWVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3Rvcnkoc3RvcnlJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3Rvcmllc1tzdG9yeUlkXTtcclxuICB9XHJcblxyXG4gIGNsZWFyU3RvcmllcygpIHtcclxuICAgIHRoaXMuc3RvcmllcyA9IHt9O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9yeVBhcnNlcjsgIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiSURNTFV0aWxzIiwiU3RvcnlQYXJzZXIiLCJwYXJzZVN0b3J5RmlsZSIsImZpbGVOYW1lIiwiY29udGVudCIsInhtbFBhcnNlciIsImNvbnNvbGUiLCJsb2ciLCJwYXJzZWQiLCJwYXJzZSIsInN0b3J5SWQiLCJiYXNlbmFtZSIsInN0b3J5RGF0YSIsIlN0b3J5IiwiT2JqZWN0Iiwia2V5cyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdWJzdHJpbmciLCJkZXRhaWxlZFN0b3J5Iiwic2VsZiIsImFwcGxpZWRUT0NTdHlsZSIsInVzZXJUZXh0IiwiZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50IiwidGV4dEZvcm1hdHRpbmciLCJleHRyYWN0VGV4dEZvcm1hdHRpbmciLCJjbGVhblN0b3J5SWQiLCJyZXBsYWNlIiwic3RvcmllcyIsInBsYWluVGV4dCIsImxpbmVCcmVha0luZm8iLCJsZW5ndGgiLCJ3b3JkQ291bnQiLCJsaW5lQnJlYWtDb3VudCIsImVycm9yIiwibWVzc2FnZSIsImZvcm1hdHRlZENvbnRlbnQiLCJ0ZXh0Q29sb3IiLCJkZWJ1Z0luZm8iLCJleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5IiwiZWxlbWVudCIsImRlcHRoIiwiY29udGV4dCIsIkNoYXJhY3RlclN0eWxlUmFuZ2UiLCJyYW5nZXMiLCJBcnJheSIsImlzQXJyYXkiLCJhbGxSYW5nZUNvbnRlbnQiLCJtYXAiLCJyIiwiQ29udGVudCIsImpvaW4iLCJTdHJpbmciLCJpbmNsdWRlcyIsImZvckVhY2giLCJyYW5nZSIsImluZGV4IiwicmFuZ2VJbmRleCIsImRpcmVjdEZvbnRSZWYiLCJmb3JtYXR0aW5nIiwicGFyYWdyYXBoU3R5bGUiLCJjaGFyYWN0ZXJTdHlsZSIsImZvbnRTaXplIiwicGFyc2VGbG9hdCIsImZvbnRSZWZlcmVuY2UiLCJmaWxsQ29sb3IiLCJmb250U3R5bGUiLCJyYW5nZUNvbnRlbnQiLCJoYXNTdHlsZUluZm8iLCJ0cmltIiwicmF3UmFuZ2VBdHRyaWJ1dGVzIiwiZmlsdGVyIiwiayIsInN0YXJ0c1dpdGgiLCJleHRyYWN0ZWRGb3JtYXR0aW5nIiwiZm9udFN0eWxlRnJvbVhNTCIsImNoYXJhY3RlclN0eWxlRnJvbVhNTCIsInBhcmFncmFwaFN0eWxlRnJvbVhNTCIsInJlc29sdmVkRm9ybWF0dGluZyIsInN0eWxlUGFyc2VyIiwicmVzb2x2ZVN0eWxlRm9ybWF0dGluZyIsImNvbnRlbnRzIiwiY29udGVudEl0ZW0iLCJjb250ZW50SW5kZXgiLCJ0ZXh0IiwiZGVjb2RlWE1MRW50aXRpZXMiLCJwdXNoIiwiQnIiLCJ1bmRlZmluZWQiLCJsaW5lQnJlYWtUZXh0IiwiaXNCcmVhayIsImJyZWFrVHlwZSIsInBvc2l0aW9uIiwic291cmNlIiwidHlwZSIsImxvY2F0aW9uIiwiYnJFbGVtZW50cyIsImV4dHJhY3RCckVsZW1lbnRzIiwiYnJJbmZvIiwiYnJJbmRleCIsImRldGVybWluZUxpbmVCcmVha1R5cGUiLCJuZXh0UmFuZ2UiLCJjdXJyZW50VGV4dCIsInNsaWNlIiwiY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSIsInRlc3QiLCJuZXh0Q29udGVudCIsIm5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSIsInNob3VsZFNraXBTcGFjZSIsInNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrIiwiY3VycmVudFN0eWxlIiwibmV4dFN0eWxlIiwic3BhY2VUZXh0IiwiaXNTcGFjZSIsInJlYXNvbiIsImN1cnJlbnRUZXh0RW5kIiwibmV4dFRleHRTdGFydCIsImltcGxpY2l0QnJlYWsiLCJQYXJhZ3JhcGhTdHlsZVJhbmdlIiwicGFyYWdyYXBoQ29udGV4dCIsInBhcmFncmFwaEluZGV4IiwidG90YWxQYXJhZ3JhcGhzIiwiYXBwbGllZFN0eWxlIiwicGFyYWdyYXBoQnJlYWsiLCJmb250RmFtaWx5IiwiYnIiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJpdGVtIiwicHJvY2Vzc2VkQ29udGVudCIsInNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nIiwiaW5mbyIsImhhc0xpbmVCcmVha3MiLCJtYXRjaCIsImxpbmVCcmVha1R5cGVzIiwiYW5hbHl6ZUxpbmVCcmVha1R5cGVzIiwic3BhY2VQcmVzZXJ2YXRpb25Db3VudCIsImNvdW50V29yZHMiLCJjaGFyYWN0ZXJDb3VudCIsImFuYWx5emVDb250ZW50U3RydWN0dXJlIiwic3RydWN0dXJlIiwiaGFzQ29udGVudCIsImhhc0JyIiwiY29udGVudEl0ZW1zIiwicHJvY2Vzc0ludGVybGVhdmVkQ29udGVudCIsInJlc3VsdHMiLCJjdXJyZW50UmFuZ2UiLCJjdXJyZW50Q2hhclN0eWxlIiwibmV4dENoYXJTdHlsZSIsInN0eWxlSW5kaWNhdGVzQnJlYWsiLCJzdHlsZUluZGljYXRlc0xpbmVCcmVhayIsInRpdGxlSW5kaWNhdG9ycyIsImJvZHlJbmRpY2F0b3JzIiwiY3VycmVudElzVGl0bGUiLCJzb21lIiwiaW5kaWNhdG9yIiwidG9Mb3dlckNhc2UiLCJuZXh0SXNCb2R5IiwidHlwZXMiLCJleHBsaWNpdCIsImltcGxpY2l0IiwicGFyYWdyYXBoIiwiZGlyZWN0IiwiaGFzT3duUHJvcGVydHkiLCJleHRyYWN0RGV0YWlsZWRGb3JtYXR0aW5nRnJvbVJhbmdlIiwiZm9udEF0dHJpYnV0ZXMiLCJhdHRyIiwicGFyc2VOdW1lcmljIiwicmF3TGVhZGluZyIsImxlYWRpbmciLCJwcm9jZXNzTGVhZGluZ1ZhbHVlIiwibGVhZGluZ1R5cGUiLCJkZXRlcm1pbmVMZWFkaW5nVHlwZSIsInN0cm9rZUNvbG9yIiwidHJhY2tpbmciLCJiYXNlbGluZVNoaWZ0Iiwia2VybmluZyIsImhvcml6b250YWxTY2FsZSIsInZlcnRpY2FsU2NhbGUiLCJleHBsaWNpdEFsaWdubWVudCIsImFsaWdubWVudCIsImxlZnRJbmRlbnQiLCJyaWdodEluZGVudCIsImZpcnN0TGluZUluZGVudCIsInNwYWNlQmVmb3JlIiwic3BhY2VBZnRlciIsImVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0IiwibnVtZXJpY0xlYWRpbmciLCJwZXJjZW50YWdlIiwicGFyYWdyYXBoU3R5bGVzIiwiY2hhcmFjdGVyU3R5bGVzIiwiYXBwbGllZFN0eWxlcyIsImNoYXJSYW5nZXMiLCJjaGFyUmFuZ2UiLCJjaGFyU3R5bGUiLCJkZWJ1Z1Jhd1N0b3J5Q29udGVudCIsImZpbmRDaGFyYWN0ZXJSYW5nZXMiLCJvYmoiLCJBcHBsaWVkRm9udCIsIkZvbnRTdHlsZSIsIlBvaW50U2l6ZSIsImdldFN0b3JpZXMiLCJnZXRTdG9yeSIsImNsZWFyU3RvcmllcyIsImNvbnN0cnVjdG9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/parsers/StoryParser.js\n"));

/***/ })

});