"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/ColorUtils.js":
/*!*********************************!*\
  !*** ./lib/utils/ColorUtils.js ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * ColorUtils.js - Comprehensive color conversion and manipulation utilities\n * Handles CMYK, RGB, HEX, and other color format conversions for IDML processing\n */ \nclass ColorUtils {\n    /**\n   * Convert CMYK color values to RGB\n   * @param {number} c - Cyan (0-100)\n   * @param {number} m - Magenta (0-100)\n   * @param {number} y - Yellow (0-100)\n   * @param {number} k - Black/Key (0-100)\n   * @returns {object} RGB object with r, g, b values (0-255)\n   */ static cmykToRgb(c, m, y, k) {\n        // Normalize CMYK values to 0-1 range\n        const cNorm = c / 100;\n        const mNorm = m / 100;\n        const yNorm = y / 100;\n        const kNorm = k / 100;\n        // Convert to RGB using standard formula\n        const r = Math.round(255 * (1 - cNorm) * (1 - kNorm));\n        const g = Math.round(255 * (1 - mNorm) * (1 - kNorm));\n        const b = Math.round(255 * (1 - yNorm) * (1 - kNorm));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    /**\n   * Convert CMYK to RGB CSS string\n   * @param {number} c - Cyan (0-100)\n   * @param {number} m - Magenta (0-100)\n   * @param {number} y - Yellow (0-100)\n   * @param {number} k - Black/Key (0-100)\n   * @returns {string} CSS rgb() string\n   */ static cmykToRgbString(c, m, y, k) {\n        const { r, g, b } = this.cmykToRgb(c, m, y, k);\n        return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n    }\n    /**\n   * Convert RGB to HEX\n   * @param {number} r - Red (0-255)\n   * @param {number} g - Green (0-255)\n   * @param {number} b - Blue (0-255)\n   * @returns {string} HEX color string\n   */ static rgbToHex(r, g, b) {\n        const toHex = (component)=>{\n            const hex = component.toString(16);\n            return hex.length === 1 ? \"0\" + hex : hex;\n        };\n        return \"#\".concat(toHex(r)).concat(toHex(g)).concat(toHex(b));\n    }\n    /**\n   * Convert CMYK to HEX\n   * @param {number} c - Cyan (0-100)\n   * @param {number} m - Magenta (0-100)\n   * @param {number} y - Yellow (0-100)\n   * @param {number} k - Black/Key (0-100)\n   * @returns {string} HEX color string\n   */ static cmykToHex(c, m, y, k) {\n        const { r, g, b } = this.cmykToRgb(c, m, y, k);\n        return this.rgbToHex(r, g, b);\n    }\n    /**\n   * Parse CMYK values from IDML color reference string\n   * @param {string} colorRef - IDML color reference (e.g., \"Color/C=1 M=18 Y=16 K=0\")\n   * @returns {object|null} Object with c, m, y, k values or null if not parseable\n   */ static parseCmykFromColorRef(colorRef) {\n        if (!colorRef || typeof colorRef !== \"string\") {\n            return null;\n        }\n        // Match CMYK pattern in IDML color references\n        const cmykMatch = colorRef.match(/Color\\/C=([\\d.]+)\\s*M=([\\d.]+)\\s*Y=([\\d.]+)\\s*K=([\\d.]+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map((val)=>parseFloat(val));\n            return {\n                c,\n                m,\n                y,\n                k\n            };\n        }\n        return null;\n    }\n    /**\n   * Convert IDML color reference to RGB CSS string\n   * @param {string} colorRef - IDML color reference\n   * @returns {string} CSS color string (rgb, hex, or named color)\n   */ static convertIdmlColorToRgb(colorRefOrObj) {\n        if (!colorRefOrObj || colorRefOrObj === \"Color/None\") {\n            return \"transparent\";\n        }\n        // ENHANCED: Handle color objects with intelligent RGB/CMYK prioritization\n        if (typeof colorRefOrObj === \"object\") {\n            console.log(\"\\uD83C\\uDFA8 Converting color object:\", {\n                self: colorRefOrObj.self,\n                source: colorRefOrObj.colorSource,\n                hasRGB: colorRefOrObj.hasDirectRGB,\n                hasCMYK: colorRefOrObj.hasDirectCMYK,\n                space: colorRefOrObj.space\n            });\n            // PRIORITY 1: Use direct RGB values (no conversion needed)\n            if (colorRefOrObj.hasDirectRGB && colorRefOrObj.red !== undefined && colorRefOrObj.red > 0 || colorRefOrObj.green !== undefined && colorRefOrObj.green > 0 || colorRefOrObj.blue !== undefined && colorRefOrObj.blue > 0 || colorRefOrObj.red === 0 && colorRefOrObj.green === 0 && colorRefOrObj.blue === 0) {\n                const rgbString = \"rgb(\".concat(colorRefOrObj.red || 0, \", \").concat(colorRefOrObj.green || 0, \", \").concat(colorRefOrObj.blue || 0, \")\");\n                console.log(\"   ✅ Using direct RGB values: \".concat(rgbString, \" (source: \").concat(colorRefOrObj.colorSource, \")\"));\n                return rgbString;\n            }\n            // PRIORITY 2: Convert CMYK values to RGB (when RGB not available)\n            if (colorRefOrObj.hasDirectCMYK && (colorRefOrObj.cyan !== undefined || colorRefOrObj.magenta !== undefined || colorRefOrObj.yellow !== undefined || colorRefOrObj.black !== undefined)) {\n                const { r, g, b } = this.cmykToRgb(colorRefOrObj.cyan || 0, colorRefOrObj.magenta || 0, colorRefOrObj.yellow || 0, colorRefOrObj.black || 0);\n                const rgbString = \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n                console.log(\"   \\uD83D\\uDD04 Converted CMYK to RGB: C:\".concat(colorRefOrObj.cyan, \" M:\").concat(colorRefOrObj.magenta, \" Y:\").concat(colorRefOrObj.yellow, \" K:\").concat(colorRefOrObj.black, \" → \").concat(rgbString, \" (source: \").concat(colorRefOrObj.colorSource, \")\"));\n                return rgbString;\n            }\n            // FALLBACK: Legacy object handling (backward compatibility)\n            // Check for legacy red/green/blue properties\n            if (colorRefOrObj.red !== undefined && colorRefOrObj.green !== undefined && colorRefOrObj.blue !== undefined) {\n                const rgbString = \"rgb(\".concat(colorRefOrObj.red, \", \").concat(colorRefOrObj.green, \", \").concat(colorRefOrObj.blue, \")\");\n                console.log(\"   ✅ Using legacy RGB properties: \".concat(rgbString));\n                return rgbString;\n            }\n            // Check for legacy cyan/magenta/yellow/black properties\n            if (colorRefOrObj.cyan !== undefined && colorRefOrObj.magenta !== undefined && colorRefOrObj.yellow !== undefined && colorRefOrObj.black !== undefined) {\n                const { r, g, b } = this.cmykToRgb(colorRefOrObj.cyan, colorRefOrObj.magenta, colorRefOrObj.yellow, colorRefOrObj.black);\n                const rgbString = \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n                console.log(\"   \\uD83D\\uDD04 Converted legacy CMYK to RGB: \".concat(rgbString));\n                return rgbString;\n            }\n        }\n        // Handle string-based color references (color names like \"Color/Main\", \"Color/Black\", etc.)\n        if (typeof colorRefOrObj === \"string\") {\n            console.log('\\uD83C\\uDFA8 Processing string color reference: \"'.concat(colorRefOrObj, '\"'));\n            // Try to parse CMYK pattern from string\n            const cmyk = this.parseCmykFromColorRef(colorRefOrObj);\n            if (cmyk) {\n                const rgbString = this.cmykToRgbString(cmyk.c, cmyk.m, cmyk.y, cmyk.k);\n                console.log(\"   \\uD83D\\uDD04 Parsed and converted CMYK string: \".concat(colorRefOrObj, \" → \").concat(rgbString));\n                return rgbString;\n            }\n            // Check predefined named colors\n            const namedColors = {\n                \"Color/Black\": \"rgb(0, 0, 0)\",\n                \"Color/White\": \"rgb(255, 255, 255)\",\n                \"Color/Red\": \"rgb(255, 0, 0)\",\n                \"Color/Green\": \"rgb(0, 255, 0)\",\n                \"Color/Blue\": \"rgb(0, 0, 255)\",\n                \"Color/Cyan\": \"rgb(0, 255, 255)\",\n                \"Color/Magenta\": \"rgb(255, 0, 255)\",\n                \"Color/Yellow\": \"rgb(255, 255, 0)\",\n                \"Color/Paper\": \"rgb(255, 255, 255)\"\n            };\n            if (namedColors[colorRefOrObj]) {\n                console.log(\"   ✅ Using predefined named color: \".concat(colorRefOrObj, \" → \").concat(namedColors[colorRefOrObj]));\n                return namedColors[colorRefOrObj];\n            }\n        }\n        // Ultimate fallback\n        console.log(\"   ⚠️  No valid color data found, using default gray: \".concat(JSON.stringify(colorRefOrObj)));\n        return \"rgb(200, 200, 200)\";\n    }\n    /**\n   * Determine if a CMYK color is suitable for use as a background\n   * @param {number} c - Cyan (0-100)\n   * @param {number} m - Magenta (0-100)\n   * @param {number} y - Yellow (0-100)\n   * @param {number} k - Black/Key (0-100)\n   * @returns {object} Analysis result with isLightBackground boolean and reasoning\n   */ static analyzeCmykForBackground(c, m, y, k) {\n        const maxCMY = Math.max(c, m, y);\n        const avgCMY = (c + m + y) / 3;\n        const analysis = {\n            c,\n            m,\n            y,\n            k,\n            maxCMY,\n            avgCMY,\n            isLightBackground: false,\n            category: \"unknown\",\n            reasoning: \"\"\n        };\n        // Very light colors: low K and low CMY values\n        if (k <= 20 && maxCMY <= 30 && avgCMY <= 20) {\n            analysis.isLightBackground = true;\n            analysis.category = \"very_light\";\n            analysis.reasoning = \"Very light color suitable for background\";\n            return analysis;\n        }\n        // Light tinted colors: very low K, slightly higher CMY (like light pink, light blue, etc.)\n        if (k <= 10 && maxCMY <= 50 && avgCMY <= 25) {\n            analysis.isLightBackground = true;\n            analysis.category = \"light_tinted\";\n            analysis.reasoning = \"Light tinted color suitable for background\";\n            return analysis;\n        }\n        // Light gray: balanced CMY, moderate K\n        if (k >= 5 && k <= 60 && maxCMY <= 15 && Math.abs(c - m) <= 5 && Math.abs(m - y) <= 5) {\n            analysis.isLightBackground = true;\n            analysis.category = \"light_gray\";\n            analysis.reasoning = \"Light gray color suitable for background\";\n            return analysis;\n        }\n        // Not suitable for background\n        analysis.reasoning = \"Too dark or saturated for background use\";\n        return analysis;\n    }\n    /**\n   * Analyze IDML color reference for background suitability\n   * @param {string} colorRef - IDML color reference\n   * @returns {object|null} Analysis result or null if not CMYK\n   */ static analyzeIdmlColorForBackground(colorRef) {\n        // Handle Paper color specially\n        if (colorRef === \"Color/Paper\" || colorRef.includes(\"Paper\")) {\n            return {\n                isLightBackground: true,\n                category: \"paper\",\n                reasoning: \"InDesign Paper color - ideal for background\",\n                colorRef\n            };\n        }\n        const cmyk = this.parseCmykFromColorRef(colorRef);\n        if (!cmyk) {\n            return null;\n        }\n        const analysis = this.analyzeCmykForBackground(cmyk.c, cmyk.m, cmyk.y, cmyk.k);\n        analysis.colorRef = colorRef;\n        return analysis;\n    }\n    /**\n   * Get RGB brightness value (0-255, higher = brighter)\n   * @param {number} r - Red (0-255)\n   * @param {number} g - Green (0-255)\n   * @param {number} b - Blue (0-255)\n   * @returns {number} Brightness value\n   */ static getRgbBrightness(r, g, b) {\n        // Use relative luminance formula\n        return 0.299 * r + 0.587 * g + 0.114 * b;\n    }\n    /**\n   * Get brightness from CMYK values\n   * @param {number} c - Cyan (0-100)\n   * @param {number} m - Magenta (0-100)\n   * @param {number} y - Yellow (0-100)\n   * @param {number} k - Black/Key (0-100)\n   * @returns {number} Brightness value (0-255)\n   */ static getCmykBrightness(c, m, y, k) {\n        const { r, g, b } = this.cmykToRgb(c, m, y, k);\n        return this.getRgbBrightness(r, g, b);\n    }\n    /**\n   * Sort colors by lightness (lightest first)\n   * @param {Array} colorRefs - Array of IDML color references\n   * @returns {Array} Sorted array with lightest colors first\n   */ static sortColorsByLightness(colorRefs) {\n        return colorRefs.sort((a, b)=>{\n            // Analyze both colors for background suitability\n            const analysisA = this.analyzeIdmlColorForBackground(a);\n            const analysisB = this.analyzeIdmlColorForBackground(b);\n            // Prioritize actual CMYK colors over Paper color for visual interest\n            const aIsPaper = a.includes(\"Paper\");\n            const bIsPaper = b.includes(\"Paper\");\n            const aIsCmyk = !aIsPaper && analysisA && analysisA.c !== undefined;\n            const bIsCmyk = !bIsPaper && analysisB && analysisB.c !== undefined;\n            // If one is CMYK and other is Paper, prefer CMYK for visual interest\n            if (aIsCmyk && bIsPaper) return -1;\n            if (bIsCmyk && aIsPaper) return 1;\n            // If both are CMYK, sort by lightness (lower K value = lighter)\n            if (aIsCmyk && bIsCmyk) {\n                const cmykA = this.parseCmykFromColorRef(a);\n                const cmykB = this.parseCmykFromColorRef(b);\n                if (cmykA && cmykB) {\n                    // First compare by category priority (very_light > light_gray, etc.)\n                    const categoryPriority = {\n                        very_light: 1,\n                        light_gray: 2,\n                        paper: 3,\n                        unknown: 4\n                    };\n                    const priorityA = categoryPriority[analysisA.category] || 4;\n                    const priorityB = categoryPriority[analysisB.category] || 4;\n                    if (priorityA !== priorityB) {\n                        return priorityA - priorityB;\n                    }\n                    // If same category, sort by K value (lower K = lighter)\n                    return cmykA.k - cmykB.k;\n                }\n            }\n            // If both are Paper or both are unknown, maintain original order\n            return 0;\n        });\n    }\n}\n// Restore CommonJS exports\nmodule.exports = ColorUtils;\nmodule.exports.cmykToRgb = ColorUtils.cmykToRgb;\nmodule.exports.cmykToRgbString = ColorUtils.cmykToRgbString;\nmodule.exports.cmykToHex = ColorUtils.cmykToHex;\nmodule.exports.rgbToHex = ColorUtils.rgbToHex;\nmodule.exports.parseCmykFromColorRef = ColorUtils.parseCmykFromColorRef;\nmodule.exports.convertIdmlColorToRgb = ColorUtils.convertIdmlColorToRgb;\nmodule.exports.analyzeCmykForBackground = ColorUtils.analyzeCmykForBackground;\nmodule.exports.analyzeIdmlColorForBackground = ColorUtils.analyzeIdmlColorForBackground;\nmodule.exports.getRgbBrightness = ColorUtils.getRgbBrightness;\nmodule.exports.getCmykBrightness = ColorUtils.getCmykBrightness;\nmodule.exports.sortColorsByLightness = ColorUtils.sortColorsByLightness;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUd2RixXQUFXbUUsaUJBQWlCO0FBQy9Eb0Isb0NBQW9DLEdBQUd2RixXQUFXb0UscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi91dGlscy9Db2xvclV0aWxzLmpzPzU1NjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb2xvclV0aWxzLmpzIC0gQ29tcHJlaGVuc2l2ZSBjb2xvciBjb252ZXJzaW9uIGFuZCBtYW5pcHVsYXRpb24gdXRpbGl0aWVzXG4gKiBIYW5kbGVzIENNWUssIFJHQiwgSEVYLCBhbmQgb3RoZXIgY29sb3IgZm9ybWF0IGNvbnZlcnNpb25zIGZvciBJRE1MIHByb2Nlc3NpbmdcbiAqL1xuXG5jbGFzcyBDb2xvclV0aWxzIHtcbiAgLyoqXG4gICAqIENvbnZlcnQgQ01ZSyBjb2xvciB2YWx1ZXMgdG8gUkdCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gQ3lhbiAoMC0xMDApXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtIC0gTWFnZW50YSAoMC0xMDApXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWWVsbG93ICgwLTEwMClcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgLSBCbGFjay9LZXkgKDAtMTAwKVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBSR0Igb2JqZWN0IHdpdGggciwgZywgYiB2YWx1ZXMgKDAtMjU1KVxuICAgKi9cbiAgc3RhdGljIGNteWtUb1JnYihjLCBtLCB5LCBrKSB7XG4gICAgLy8gTm9ybWFsaXplIENNWUsgdmFsdWVzIHRvIDAtMSByYW5nZVxuICAgIGNvbnN0IGNOb3JtID0gYyAvIDEwMDtcbiAgICBjb25zdCBtTm9ybSA9IG0gLyAxMDA7XG4gICAgY29uc3QgeU5vcm0gPSB5IC8gMTAwO1xuICAgIGNvbnN0IGtOb3JtID0gayAvIDEwMDtcblxuICAgIC8vIENvbnZlcnQgdG8gUkdCIHVzaW5nIHN0YW5kYXJkIGZvcm11bGFcbiAgICBjb25zdCByID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIGNOb3JtKSAqICgxIC0ga05vcm0pKTtcbiAgICBjb25zdCBnID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIG1Ob3JtKSAqICgxIC0ga05vcm0pKTtcbiAgICBjb25zdCBiID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIHlOb3JtKSAqICgxIC0ga05vcm0pKTtcblxuICAgIHJldHVybiB7IHIsIGcsIGIgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IENNWUsgdG8gUkdCIENTUyBzdHJpbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBDeWFuICgwLTEwMClcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZZWxsb3cgKDAtMTAwKVxuICAgKiBAcGFyYW0ge251bWJlcn0gayAtIEJsYWNrL0tleSAoMC0xMDApXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IENTUyByZ2IoKSBzdHJpbmdcbiAgICovXG4gIHN0YXRpYyBjbXlrVG9SZ2JTdHJpbmcoYywgbSwgeSwgaykge1xuICAgIGNvbnN0IHsgciwgZywgYiB9ID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XG4gICAgcmV0dXJuIGByZ2IoJHtyfSwgJHtnfSwgJHtifSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgUkdCIHRvIEhFWFxuICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFJlZCAoMC0yNTUpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBnIC0gR3JlZW4gKDAtMjU1KVxuICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIEJsdWUgKDAtMjU1KVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBIRVggY29sb3Igc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgcmdiVG9IZXgociwgZywgYikge1xuICAgIGNvbnN0IHRvSGV4ID0gKGNvbXBvbmVudCkgPT4ge1xuICAgICAgY29uc3QgaGV4ID0gY29tcG9uZW50LnRvU3RyaW5nKDE2KTtcbiAgICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gXCIwXCIgKyBoZXggOiBoZXg7XG4gICAgfTtcbiAgICByZXR1cm4gYCMke3RvSGV4KHIpfSR7dG9IZXgoZyl9JHt0b0hleChiKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgQ01ZSyB0byBIRVhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBDeWFuICgwLTEwMClcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZZWxsb3cgKDAtMTAwKVxuICAgKiBAcGFyYW0ge251bWJlcn0gayAtIEJsYWNrL0tleSAoMC0xMDApXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEhFWCBjb2xvciBzdHJpbmdcbiAgICovXG4gIHN0YXRpYyBjbXlrVG9IZXgoYywgbSwgeSwgaykge1xuICAgIGNvbnN0IHsgciwgZywgYiB9ID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XG4gICAgcmV0dXJuIHRoaXMucmdiVG9IZXgociwgZywgYik7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgQ01ZSyB2YWx1ZXMgZnJvbSBJRE1MIGNvbG9yIHJlZmVyZW5jZSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yUmVmIC0gSURNTCBjb2xvciByZWZlcmVuY2UgKGUuZy4sIFwiQ29sb3IvQz0xIE09MTggWT0xNiBLPTBcIilcbiAgICogQHJldHVybnMge29iamVjdHxudWxsfSBPYmplY3Qgd2l0aCBjLCBtLCB5LCBrIHZhbHVlcyBvciBudWxsIGlmIG5vdCBwYXJzZWFibGVcbiAgICovXG4gIHN0YXRpYyBwYXJzZUNteWtGcm9tQ29sb3JSZWYoY29sb3JSZWYpIHtcbiAgICBpZiAoIWNvbG9yUmVmIHx8IHR5cGVvZiBjb2xvclJlZiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gTWF0Y2ggQ01ZSyBwYXR0ZXJuIGluIElETUwgY29sb3IgcmVmZXJlbmNlc1xuICAgIGNvbnN0IGNteWtNYXRjaCA9IGNvbG9yUmVmLm1hdGNoKFxuICAgICAgL0NvbG9yXFwvQz0oW1xcZC5dKylcXHMqTT0oW1xcZC5dKylcXHMqWT0oW1xcZC5dKylcXHMqSz0oW1xcZC5dKykvXG4gICAgKTtcblxuICAgIGlmIChjbXlrTWF0Y2gpIHtcbiAgICAgIGNvbnN0IFssIGMsIG0sIHksIGtdID0gY215a01hdGNoLm1hcCgodmFsKSA9PiBwYXJzZUZsb2F0KHZhbCkpO1xuICAgICAgcmV0dXJuIHsgYywgbSwgeSwgayB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSURNTCBjb2xvciByZWZlcmVuY2UgdG8gUkdCIENTUyBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yUmVmIC0gSURNTCBjb2xvciByZWZlcmVuY2VcbiAgICogQHJldHVybnMge3N0cmluZ30gQ1NTIGNvbG9yIHN0cmluZyAocmdiLCBoZXgsIG9yIG5hbWVkIGNvbG9yKVxuICAgKi9cbiAgc3RhdGljIGNvbnZlcnRJZG1sQ29sb3JUb1JnYihjb2xvclJlZk9yT2JqKSB7XG4gICAgaWYgKCFjb2xvclJlZk9yT2JqIHx8IGNvbG9yUmVmT3JPYmogPT09IFwiQ29sb3IvTm9uZVwiKSB7XG4gICAgICByZXR1cm4gXCJ0cmFuc3BhcmVudFwiO1xuICAgIH1cblxuICAgIC8vIEVOSEFOQ0VEOiBIYW5kbGUgY29sb3Igb2JqZWN0cyB3aXRoIGludGVsbGlnZW50IFJHQi9DTVlLIHByaW9yaXRpemF0aW9uXG4gICAgaWYgKHR5cGVvZiBjb2xvclJlZk9yT2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OqCBDb252ZXJ0aW5nIGNvbG9yIG9iamVjdDpgLCB7XG4gICAgICAgIHNlbGY6IGNvbG9yUmVmT3JPYmouc2VsZixcbiAgICAgICAgc291cmNlOiBjb2xvclJlZk9yT2JqLmNvbG9yU291cmNlLFxuICAgICAgICBoYXNSR0I6IGNvbG9yUmVmT3JPYmouaGFzRGlyZWN0UkdCLFxuICAgICAgICBoYXNDTVlLOiBjb2xvclJlZk9yT2JqLmhhc0RpcmVjdENNWUssXG4gICAgICAgIHNwYWNlOiBjb2xvclJlZk9yT2JqLnNwYWNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFBSSU9SSVRZIDE6IFVzZSBkaXJlY3QgUkdCIHZhbHVlcyAobm8gY29udmVyc2lvbiBuZWVkZWQpXG4gICAgICBpZiAoXG4gICAgICAgIChjb2xvclJlZk9yT2JqLmhhc0RpcmVjdFJHQiAmJlxuICAgICAgICAgIGNvbG9yUmVmT3JPYmoucmVkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBjb2xvclJlZk9yT2JqLnJlZCA+IDApIHx8XG4gICAgICAgIChjb2xvclJlZk9yT2JqLmdyZWVuICE9PSB1bmRlZmluZWQgJiYgY29sb3JSZWZPck9iai5ncmVlbiA+IDApIHx8XG4gICAgICAgIChjb2xvclJlZk9yT2JqLmJsdWUgIT09IHVuZGVmaW5lZCAmJiBjb2xvclJlZk9yT2JqLmJsdWUgPiAwKSB8fFxuICAgICAgICAoY29sb3JSZWZPck9iai5yZWQgPT09IDAgJiZcbiAgICAgICAgICBjb2xvclJlZk9yT2JqLmdyZWVuID09PSAwICYmXG4gICAgICAgICAgY29sb3JSZWZPck9iai5ibHVlID09PSAwKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHJnYlN0cmluZyA9IGByZ2IoJHtjb2xvclJlZk9yT2JqLnJlZCB8fCAwfSwgJHtcbiAgICAgICAgICBjb2xvclJlZk9yT2JqLmdyZWVuIHx8IDBcbiAgICAgICAgfSwgJHtjb2xvclJlZk9yT2JqLmJsdWUgfHwgMH0pYDtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYCAgIOKchSBVc2luZyBkaXJlY3QgUkdCIHZhbHVlczogJHtyZ2JTdHJpbmd9IChzb3VyY2U6ICR7Y29sb3JSZWZPck9iai5jb2xvclNvdXJjZX0pYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmdiU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICAvLyBQUklPUklUWSAyOiBDb252ZXJ0IENNWUsgdmFsdWVzIHRvIFJHQiAod2hlbiBSR0Igbm90IGF2YWlsYWJsZSlcbiAgICAgIGlmIChcbiAgICAgICAgY29sb3JSZWZPck9iai5oYXNEaXJlY3RDTVlLICYmXG4gICAgICAgIChjb2xvclJlZk9yT2JqLmN5YW4gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIGNvbG9yUmVmT3JPYmoubWFnZW50YSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgY29sb3JSZWZPck9iai55ZWxsb3cgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIGNvbG9yUmVmT3JPYmouYmxhY2sgIT09IHVuZGVmaW5lZClcbiAgICAgICkge1xuICAgICAgICBjb25zdCB7IHIsIGcsIGIgfSA9IHRoaXMuY215a1RvUmdiKFxuICAgICAgICAgIGNvbG9yUmVmT3JPYmouY3lhbiB8fCAwLFxuICAgICAgICAgIGNvbG9yUmVmT3JPYmoubWFnZW50YSB8fCAwLFxuICAgICAgICAgIGNvbG9yUmVmT3JPYmoueWVsbG93IHx8IDAsXG4gICAgICAgICAgY29sb3JSZWZPck9iai5ibGFjayB8fCAwXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJnYlN0cmluZyA9IGByZ2IoJHtyfSwgJHtnfSwgJHtifSlgO1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgICAg8J+UhCBDb252ZXJ0ZWQgQ01ZSyB0byBSR0I6IEM6JHtjb2xvclJlZk9yT2JqLmN5YW59IE06JHtjb2xvclJlZk9yT2JqLm1hZ2VudGF9IFk6JHtjb2xvclJlZk9yT2JqLnllbGxvd30gSzoke2NvbG9yUmVmT3JPYmouYmxhY2t9IOKGkiAke3JnYlN0cmluZ30gKHNvdXJjZTogJHtjb2xvclJlZk9yT2JqLmNvbG9yU291cmNlfSlgXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZ2JTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIC8vIEZBTExCQUNLOiBMZWdhY3kgb2JqZWN0IGhhbmRsaW5nIChiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgLy8gQ2hlY2sgZm9yIGxlZ2FjeSByZWQvZ3JlZW4vYmx1ZSBwcm9wZXJ0aWVzXG4gICAgICBpZiAoXG4gICAgICAgIGNvbG9yUmVmT3JPYmoucmVkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY29sb3JSZWZPck9iai5ncmVlbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGNvbG9yUmVmT3JPYmouYmx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgcmdiU3RyaW5nID0gYHJnYigke2NvbG9yUmVmT3JPYmoucmVkfSwgJHtjb2xvclJlZk9yT2JqLmdyZWVufSwgJHtjb2xvclJlZk9yT2JqLmJsdWV9KWA7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICDinIUgVXNpbmcgbGVnYWN5IFJHQiBwcm9wZXJ0aWVzOiAke3JnYlN0cmluZ31gKTtcbiAgICAgICAgcmV0dXJuIHJnYlN0cmluZztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGxlZ2FjeSBjeWFuL21hZ2VudGEveWVsbG93L2JsYWNrIHByb3BlcnRpZXNcbiAgICAgIGlmIChcbiAgICAgICAgY29sb3JSZWZPck9iai5jeWFuICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY29sb3JSZWZPck9iai5tYWdlbnRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY29sb3JSZWZPck9iai55ZWxsb3cgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBjb2xvclJlZk9yT2JqLmJsYWNrICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICBjb25zdCB7IHIsIGcsIGIgfSA9IHRoaXMuY215a1RvUmdiKFxuICAgICAgICAgIGNvbG9yUmVmT3JPYmouY3lhbixcbiAgICAgICAgICBjb2xvclJlZk9yT2JqLm1hZ2VudGEsXG4gICAgICAgICAgY29sb3JSZWZPck9iai55ZWxsb3csXG4gICAgICAgICAgY29sb3JSZWZPck9iai5ibGFja1xuICAgICAgICApO1xuICAgICAgICBjb25zdCByZ2JTdHJpbmcgPSBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYDtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIPCflIQgQ29udmVydGVkIGxlZ2FjeSBDTVlLIHRvIFJHQjogJHtyZ2JTdHJpbmd9YCk7XG4gICAgICAgIHJldHVybiByZ2JTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHN0cmluZy1iYXNlZCBjb2xvciByZWZlcmVuY2VzIChjb2xvciBuYW1lcyBsaWtlIFwiQ29sb3IvTWFpblwiLCBcIkNvbG9yL0JsYWNrXCIsIGV0Yy4pXG4gICAgaWYgKHR5cGVvZiBjb2xvclJlZk9yT2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OqCBQcm9jZXNzaW5nIHN0cmluZyBjb2xvciByZWZlcmVuY2U6IFwiJHtjb2xvclJlZk9yT2JqfVwiYCk7XG5cbiAgICAgIC8vIFRyeSB0byBwYXJzZSBDTVlLIHBhdHRlcm4gZnJvbSBzdHJpbmdcbiAgICAgIGNvbnN0IGNteWsgPSB0aGlzLnBhcnNlQ215a0Zyb21Db2xvclJlZihjb2xvclJlZk9yT2JqKTtcbiAgICAgIGlmIChjbXlrKSB7XG4gICAgICAgIGNvbnN0IHJnYlN0cmluZyA9IHRoaXMuY215a1RvUmdiU3RyaW5nKGNteWsuYywgY215ay5tLCBjbXlrLnksIGNteWsuayk7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgICDwn5SEIFBhcnNlZCBhbmQgY29udmVydGVkIENNWUsgc3RyaW5nOiAke2NvbG9yUmVmT3JPYmp9IOKGkiAke3JnYlN0cmluZ31gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZ2JTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHByZWRlZmluZWQgbmFtZWQgY29sb3JzXG4gICAgICBjb25zdCBuYW1lZENvbG9ycyA9IHtcbiAgICAgICAgXCJDb2xvci9CbGFja1wiOiBcInJnYigwLCAwLCAwKVwiLFxuICAgICAgICBcIkNvbG9yL1doaXRlXCI6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsXG4gICAgICAgIFwiQ29sb3IvUmVkXCI6IFwicmdiKDI1NSwgMCwgMClcIixcbiAgICAgICAgXCJDb2xvci9HcmVlblwiOiBcInJnYigwLCAyNTUsIDApXCIsXG4gICAgICAgIFwiQ29sb3IvQmx1ZVwiOiBcInJnYigwLCAwLCAyNTUpXCIsXG4gICAgICAgIFwiQ29sb3IvQ3lhblwiOiBcInJnYigwLCAyNTUsIDI1NSlcIixcbiAgICAgICAgXCJDb2xvci9NYWdlbnRhXCI6IFwicmdiKDI1NSwgMCwgMjU1KVwiLFxuICAgICAgICBcIkNvbG9yL1llbGxvd1wiOiBcInJnYigyNTUsIDI1NSwgMClcIixcbiAgICAgICAgXCJDb2xvci9QYXBlclwiOiBcInJnYigyNTUsIDI1NSwgMjU1KVwiLFxuICAgICAgfTtcblxuICAgICAgaWYgKG5hbWVkQ29sb3JzW2NvbG9yUmVmT3JPYmpdKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgICDinIUgVXNpbmcgcHJlZGVmaW5lZCBuYW1lZCBjb2xvcjogJHtjb2xvclJlZk9yT2JqfSDihpIgJHtuYW1lZENvbG9yc1tjb2xvclJlZk9yT2JqXX1gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuYW1lZENvbG9yc1tjb2xvclJlZk9yT2JqXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVbHRpbWF0ZSBmYWxsYmFja1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYCAgIOKaoO+4jyAgTm8gdmFsaWQgY29sb3IgZGF0YSBmb3VuZCwgdXNpbmcgZGVmYXVsdCBncmF5OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBjb2xvclJlZk9yT2JqXG4gICAgICApfWBcbiAgICApO1xuICAgIHJldHVybiBcInJnYigyMDAsIDIwMCwgMjAwKVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIENNWUsgY29sb3IgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyBhIGJhY2tncm91bmRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBDeWFuICgwLTEwMClcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZZWxsb3cgKDAtMTAwKVxuICAgKiBAcGFyYW0ge251bWJlcn0gayAtIEJsYWNrL0tleSAoMC0xMDApXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IEFuYWx5c2lzIHJlc3VsdCB3aXRoIGlzTGlnaHRCYWNrZ3JvdW5kIGJvb2xlYW4gYW5kIHJlYXNvbmluZ1xuICAgKi9cbiAgc3RhdGljIGFuYWx5emVDbXlrRm9yQmFja2dyb3VuZChjLCBtLCB5LCBrKSB7XG4gICAgY29uc3QgbWF4Q01ZID0gTWF0aC5tYXgoYywgbSwgeSk7XG4gICAgY29uc3QgYXZnQ01ZID0gKGMgKyBtICsgeSkgLyAzO1xuXG4gICAgY29uc3QgYW5hbHlzaXMgPSB7XG4gICAgICBjLFxuICAgICAgbSxcbiAgICAgIHksXG4gICAgICBrLFxuICAgICAgbWF4Q01ZLFxuICAgICAgYXZnQ01ZLFxuICAgICAgaXNMaWdodEJhY2tncm91bmQ6IGZhbHNlLFxuICAgICAgY2F0ZWdvcnk6IFwidW5rbm93blwiLFxuICAgICAgcmVhc29uaW5nOiBcIlwiLFxuICAgIH07XG5cbiAgICAvLyBWZXJ5IGxpZ2h0IGNvbG9yczogbG93IEsgYW5kIGxvdyBDTVkgdmFsdWVzXG4gICAgaWYgKGsgPD0gMjAgJiYgbWF4Q01ZIDw9IDMwICYmIGF2Z0NNWSA8PSAyMCkge1xuICAgICAgYW5hbHlzaXMuaXNMaWdodEJhY2tncm91bmQgPSB0cnVlO1xuICAgICAgYW5hbHlzaXMuY2F0ZWdvcnkgPSBcInZlcnlfbGlnaHRcIjtcbiAgICAgIGFuYWx5c2lzLnJlYXNvbmluZyA9IFwiVmVyeSBsaWdodCBjb2xvciBzdWl0YWJsZSBmb3IgYmFja2dyb3VuZFwiO1xuICAgICAgcmV0dXJuIGFuYWx5c2lzO1xuICAgIH1cblxuICAgIC8vIExpZ2h0IHRpbnRlZCBjb2xvcnM6IHZlcnkgbG93IEssIHNsaWdodGx5IGhpZ2hlciBDTVkgKGxpa2UgbGlnaHQgcGluaywgbGlnaHQgYmx1ZSwgZXRjLilcbiAgICBpZiAoayA8PSAxMCAmJiBtYXhDTVkgPD0gNTAgJiYgYXZnQ01ZIDw9IDI1KSB7XG4gICAgICBhbmFseXNpcy5pc0xpZ2h0QmFja2dyb3VuZCA9IHRydWU7XG4gICAgICBhbmFseXNpcy5jYXRlZ29yeSA9IFwibGlnaHRfdGludGVkXCI7XG4gICAgICBhbmFseXNpcy5yZWFzb25pbmcgPSBcIkxpZ2h0IHRpbnRlZCBjb2xvciBzdWl0YWJsZSBmb3IgYmFja2dyb3VuZFwiO1xuICAgICAgcmV0dXJuIGFuYWx5c2lzO1xuICAgIH1cblxuICAgIC8vIExpZ2h0IGdyYXk6IGJhbGFuY2VkIENNWSwgbW9kZXJhdGUgS1xuICAgIGlmIChcbiAgICAgIGsgPj0gNSAmJlxuICAgICAgayA8PSA2MCAmJlxuICAgICAgbWF4Q01ZIDw9IDE1ICYmXG4gICAgICBNYXRoLmFicyhjIC0gbSkgPD0gNSAmJlxuICAgICAgTWF0aC5hYnMobSAtIHkpIDw9IDVcbiAgICApIHtcbiAgICAgIGFuYWx5c2lzLmlzTGlnaHRCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgIGFuYWx5c2lzLmNhdGVnb3J5ID0gXCJsaWdodF9ncmF5XCI7XG4gICAgICBhbmFseXNpcy5yZWFzb25pbmcgPSBcIkxpZ2h0IGdyYXkgY29sb3Igc3VpdGFibGUgZm9yIGJhY2tncm91bmRcIjtcbiAgICAgIHJldHVybiBhbmFseXNpcztcbiAgICB9XG5cbiAgICAvLyBOb3Qgc3VpdGFibGUgZm9yIGJhY2tncm91bmRcbiAgICBhbmFseXNpcy5yZWFzb25pbmcgPSBcIlRvbyBkYXJrIG9yIHNhdHVyYXRlZCBmb3IgYmFja2dyb3VuZCB1c2VcIjtcbiAgICByZXR1cm4gYW5hbHlzaXM7XG4gIH1cblxuICAvKipcbiAgICogQW5hbHl6ZSBJRE1MIGNvbG9yIHJlZmVyZW5jZSBmb3IgYmFja2dyb3VuZCBzdWl0YWJpbGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JSZWYgLSBJRE1MIGNvbG9yIHJlZmVyZW5jZVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9IEFuYWx5c2lzIHJlc3VsdCBvciBudWxsIGlmIG5vdCBDTVlLXG4gICAqL1xuICBzdGF0aWMgYW5hbHl6ZUlkbWxDb2xvckZvckJhY2tncm91bmQoY29sb3JSZWYpIHtcbiAgICAvLyBIYW5kbGUgUGFwZXIgY29sb3Igc3BlY2lhbGx5XG4gICAgaWYgKGNvbG9yUmVmID09PSBcIkNvbG9yL1BhcGVyXCIgfHwgY29sb3JSZWYuaW5jbHVkZXMoXCJQYXBlclwiKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNMaWdodEJhY2tncm91bmQ6IHRydWUsXG4gICAgICAgIGNhdGVnb3J5OiBcInBhcGVyXCIsXG4gICAgICAgIHJlYXNvbmluZzogXCJJbkRlc2lnbiBQYXBlciBjb2xvciAtIGlkZWFsIGZvciBiYWNrZ3JvdW5kXCIsXG4gICAgICAgIGNvbG9yUmVmLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBjbXlrID0gdGhpcy5wYXJzZUNteWtGcm9tQ29sb3JSZWYoY29sb3JSZWYpO1xuICAgIGlmICghY215aykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgYW5hbHlzaXMgPSB0aGlzLmFuYWx5emVDbXlrRm9yQmFja2dyb3VuZChcbiAgICAgIGNteWsuYyxcbiAgICAgIGNteWsubSxcbiAgICAgIGNteWsueSxcbiAgICAgIGNteWsua1xuICAgICk7XG4gICAgYW5hbHlzaXMuY29sb3JSZWYgPSBjb2xvclJlZjtcbiAgICByZXR1cm4gYW5hbHlzaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFJHQiBicmlnaHRuZXNzIHZhbHVlICgwLTI1NSwgaGlnaGVyID0gYnJpZ2h0ZXIpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gUmVkICgwLTI1NSlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGcgLSBHcmVlbiAoMC0yNTUpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gQmx1ZSAoMC0yNTUpXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEJyaWdodG5lc3MgdmFsdWVcbiAgICovXG4gIHN0YXRpYyBnZXRSZ2JCcmlnaHRuZXNzKHIsIGcsIGIpIHtcbiAgICAvLyBVc2UgcmVsYXRpdmUgbHVtaW5hbmNlIGZvcm11bGFcbiAgICByZXR1cm4gMC4yOTkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBicmlnaHRuZXNzIGZyb20gQ01ZSyB2YWx1ZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBDeWFuICgwLTEwMClcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZZWxsb3cgKDAtMTAwKVxuICAgKiBAcGFyYW0ge251bWJlcn0gayAtIEJsYWNrL0tleSAoMC0xMDApXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEJyaWdodG5lc3MgdmFsdWUgKDAtMjU1KVxuICAgKi9cbiAgc3RhdGljIGdldENteWtCcmlnaHRuZXNzKGMsIG0sIHksIGspIHtcbiAgICBjb25zdCB7IHIsIGcsIGIgfSA9IHRoaXMuY215a1RvUmdiKGMsIG0sIHksIGspO1xuICAgIHJldHVybiB0aGlzLmdldFJnYkJyaWdodG5lc3MociwgZywgYik7XG4gIH1cblxuICAvKipcbiAgICogU29ydCBjb2xvcnMgYnkgbGlnaHRuZXNzIChsaWdodGVzdCBmaXJzdClcbiAgICogQHBhcmFtIHtBcnJheX0gY29sb3JSZWZzIC0gQXJyYXkgb2YgSURNTCBjb2xvciByZWZlcmVuY2VzXG4gICAqIEByZXR1cm5zIHtBcnJheX0gU29ydGVkIGFycmF5IHdpdGggbGlnaHRlc3QgY29sb3JzIGZpcnN0XG4gICAqL1xuICBzdGF0aWMgc29ydENvbG9yc0J5TGlnaHRuZXNzKGNvbG9yUmVmcykge1xuICAgIHJldHVybiBjb2xvclJlZnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgLy8gQW5hbHl6ZSBib3RoIGNvbG9ycyBmb3IgYmFja2dyb3VuZCBzdWl0YWJpbGl0eVxuICAgICAgY29uc3QgYW5hbHlzaXNBID0gdGhpcy5hbmFseXplSWRtbENvbG9yRm9yQmFja2dyb3VuZChhKTtcbiAgICAgIGNvbnN0IGFuYWx5c2lzQiA9IHRoaXMuYW5hbHl6ZUlkbWxDb2xvckZvckJhY2tncm91bmQoYik7XG5cbiAgICAgIC8vIFByaW9yaXRpemUgYWN0dWFsIENNWUsgY29sb3JzIG92ZXIgUGFwZXIgY29sb3IgZm9yIHZpc3VhbCBpbnRlcmVzdFxuICAgICAgY29uc3QgYUlzUGFwZXIgPSBhLmluY2x1ZGVzKFwiUGFwZXJcIik7XG4gICAgICBjb25zdCBiSXNQYXBlciA9IGIuaW5jbHVkZXMoXCJQYXBlclwiKTtcbiAgICAgIGNvbnN0IGFJc0NteWsgPSAhYUlzUGFwZXIgJiYgYW5hbHlzaXNBICYmIGFuYWx5c2lzQS5jICE9PSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBiSXNDbXlrID0gIWJJc1BhcGVyICYmIGFuYWx5c2lzQiAmJiBhbmFseXNpc0IuYyAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBJZiBvbmUgaXMgQ01ZSyBhbmQgb3RoZXIgaXMgUGFwZXIsIHByZWZlciBDTVlLIGZvciB2aXN1YWwgaW50ZXJlc3RcbiAgICAgIGlmIChhSXNDbXlrICYmIGJJc1BhcGVyKSByZXR1cm4gLTE7XG4gICAgICBpZiAoYklzQ215ayAmJiBhSXNQYXBlcikgcmV0dXJuIDE7XG5cbiAgICAgIC8vIElmIGJvdGggYXJlIENNWUssIHNvcnQgYnkgbGlnaHRuZXNzIChsb3dlciBLIHZhbHVlID0gbGlnaHRlcilcbiAgICAgIGlmIChhSXNDbXlrICYmIGJJc0NteWspIHtcbiAgICAgICAgY29uc3QgY215a0EgPSB0aGlzLnBhcnNlQ215a0Zyb21Db2xvclJlZihhKTtcbiAgICAgICAgY29uc3QgY215a0IgPSB0aGlzLnBhcnNlQ215a0Zyb21Db2xvclJlZihiKTtcblxuICAgICAgICBpZiAoY215a0EgJiYgY215a0IpIHtcbiAgICAgICAgICAvLyBGaXJzdCBjb21wYXJlIGJ5IGNhdGVnb3J5IHByaW9yaXR5ICh2ZXJ5X2xpZ2h0ID4gbGlnaHRfZ3JheSwgZXRjLilcbiAgICAgICAgICBjb25zdCBjYXRlZ29yeVByaW9yaXR5ID0ge1xuICAgICAgICAgICAgdmVyeV9saWdodDogMSxcbiAgICAgICAgICAgIGxpZ2h0X2dyYXk6IDIsXG4gICAgICAgICAgICBwYXBlcjogMyxcbiAgICAgICAgICAgIHVua25vd246IDQsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IHByaW9yaXR5QSA9IGNhdGVnb3J5UHJpb3JpdHlbYW5hbHlzaXNBLmNhdGVnb3J5XSB8fCA0O1xuICAgICAgICAgIGNvbnN0IHByaW9yaXR5QiA9IGNhdGVnb3J5UHJpb3JpdHlbYW5hbHlzaXNCLmNhdGVnb3J5XSB8fCA0O1xuXG4gICAgICAgICAgaWYgKHByaW9yaXR5QSAhPT0gcHJpb3JpdHlCKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpb3JpdHlBIC0gcHJpb3JpdHlCO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHNhbWUgY2F0ZWdvcnksIHNvcnQgYnkgSyB2YWx1ZSAobG93ZXIgSyA9IGxpZ2h0ZXIpXG4gICAgICAgICAgcmV0dXJuIGNteWtBLmsgLSBjbXlrQi5rO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGJvdGggYXJlIFBhcGVyIG9yIGJvdGggYXJlIHVua25vd24sIG1haW50YWluIG9yaWdpbmFsIG9yZGVyXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBSZXN0b3JlIENvbW1vbkpTIGV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gQ29sb3JVdGlscztcbm1vZHVsZS5leHBvcnRzLmNteWtUb1JnYiA9IENvbG9yVXRpbHMuY215a1RvUmdiO1xubW9kdWxlLmV4cG9ydHMuY215a1RvUmdiU3RyaW5nID0gQ29sb3JVdGlscy5jbXlrVG9SZ2JTdHJpbmc7XG5tb2R1bGUuZXhwb3J0cy5jbXlrVG9IZXggPSBDb2xvclV0aWxzLmNteWtUb0hleDtcbm1vZHVsZS5leHBvcnRzLnJnYlRvSGV4ID0gQ29sb3JVdGlscy5yZ2JUb0hleDtcbm1vZHVsZS5leHBvcnRzLnBhcnNlQ215a0Zyb21Db2xvclJlZiA9IENvbG9yVXRpbHMucGFyc2VDbXlrRnJvbUNvbG9yUmVmO1xubW9kdWxlLmV4cG9ydHMuY29udmVydElkbWxDb2xvclRvUmdiID0gQ29sb3JVdGlscy5jb252ZXJ0SWRtbENvbG9yVG9SZ2I7XG5tb2R1bGUuZXhwb3J0cy5hbmFseXplQ215a0ZvckJhY2tncm91bmQgPSBDb2xvclV0aWxzLmFuYWx5emVDbXlrRm9yQmFja2dyb3VuZDtcbm1vZHVsZS5leHBvcnRzLmFuYWx5emVJZG1sQ29sb3JGb3JCYWNrZ3JvdW5kID1cbiAgQ29sb3JVdGlscy5hbmFseXplSWRtbENvbG9yRm9yQmFja2dyb3VuZDtcbm1vZHVsZS5leHBvcnRzLmdldFJnYkJyaWdodG5lc3MgPSBDb2xvclV0aWxzLmdldFJnYkJyaWdodG5lc3M7XG5tb2R1bGUuZXhwb3J0cy5nZXRDbXlrQnJpZ2h0bmVzcyA9IENvbG9yVXRpbHMuZ2V0Q215a0JyaWdodG5lc3M7XG5tb2R1bGUuZXhwb3J0cy5zb3J0Q29sb3JzQnlMaWdodG5lc3MgPSBDb2xvclV0aWxzLnNvcnRDb2xvcnNCeUxpZ2h0bmVzcztcbiJdLCJuYW1lcyI6WyJDb2xvclV0aWxzIiwiY215a1RvUmdiIiwiYyIsIm0iLCJ5IiwiayIsImNOb3JtIiwibU5vcm0iLCJ5Tm9ybSIsImtOb3JtIiwiciIsIk1hdGgiLCJyb3VuZCIsImciLCJiIiwiY215a1RvUmdiU3RyaW5nIiwicmdiVG9IZXgiLCJ0b0hleCIsImNvbXBvbmVudCIsImhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiY215a1RvSGV4IiwicGFyc2VDbXlrRnJvbUNvbG9yUmVmIiwiY29sb3JSZWYiLCJjbXlrTWF0Y2giLCJtYXRjaCIsIm1hcCIsInZhbCIsInBhcnNlRmxvYXQiLCJjb252ZXJ0SWRtbENvbG9yVG9SZ2IiLCJjb2xvclJlZk9yT2JqIiwiY29uc29sZSIsImxvZyIsInNlbGYiLCJzb3VyY2UiLCJjb2xvclNvdXJjZSIsImhhc1JHQiIsImhhc0RpcmVjdFJHQiIsImhhc0NNWUsiLCJoYXNEaXJlY3RDTVlLIiwic3BhY2UiLCJyZWQiLCJ1bmRlZmluZWQiLCJncmVlbiIsImJsdWUiLCJyZ2JTdHJpbmciLCJjeWFuIiwibWFnZW50YSIsInllbGxvdyIsImJsYWNrIiwiY215ayIsIm5hbWVkQ29sb3JzIiwiSlNPTiIsInN0cmluZ2lmeSIsImFuYWx5emVDbXlrRm9yQmFja2dyb3VuZCIsIm1heENNWSIsIm1heCIsImF2Z0NNWSIsImFuYWx5c2lzIiwiaXNMaWdodEJhY2tncm91bmQiLCJjYXRlZ29yeSIsInJlYXNvbmluZyIsImFicyIsImFuYWx5emVJZG1sQ29sb3JGb3JCYWNrZ3JvdW5kIiwiaW5jbHVkZXMiLCJnZXRSZ2JCcmlnaHRuZXNzIiwiZ2V0Q215a0JyaWdodG5lc3MiLCJzb3J0Q29sb3JzQnlMaWdodG5lc3MiLCJjb2xvclJlZnMiLCJzb3J0IiwiYSIsImFuYWx5c2lzQSIsImFuYWx5c2lzQiIsImFJc1BhcGVyIiwiYklzUGFwZXIiLCJhSXNDbXlrIiwiYklzQ215ayIsImNteWtBIiwiY215a0IiLCJjYXRlZ29yeVByaW9yaXR5IiwidmVyeV9saWdodCIsImxpZ2h0X2dyYXkiLCJwYXBlciIsInVua25vd24iLCJwcmlvcml0eUEiLCJwcmlvcml0eUIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/utils/ColorUtils.js\n"));

/***/ })

});