"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/InDesignTextMetrics.js":
/*!******************************************!*\
  !*** ./lib/utils/InDesignTextMetrics.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * InDesignTextMetrics.js - Precise text measurement utility for 1:1 InDesign compatibility\r\n * Handles font metrics, leading calculations, and text frame insets exactly like InDesign\r\n */ \nclass InDesignTextMetrics {\n    /**\r\n   * Calculate precise text frame dimensions including InDesign-specific insets\r\n   * @param {object} textFrame - The text frame element\r\n   * @param {object} textFramePrefs - Text frame preferences from InDesign\r\n   * @returns {object} Adjusted frame dimensions\r\n   */ static calculateTextFrameInsets(textFrame, textFramePrefs) {\n        var _textFramePrefs_insetSpacing, _textFramePrefs_textInsets, _textFramePrefs_insetSpacing1, _textFramePrefs_textInsets1, _textFramePrefs_insetSpacing2, _textFramePrefs_textInsets2, _textFramePrefs_insetSpacing3, _textFramePrefs_textInsets3;\n        // InDesign default text frame insets (in points)\n        const DEFAULT_INSETS = {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        };\n        // Extract insets from preferences if available\n        const insets = {\n            top: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing === void 0 ? void 0 : _textFramePrefs_insetSpacing.top) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets === void 0 ? void 0 : _textFramePrefs_textInsets.top) || DEFAULT_INSETS.top,\n            bottom: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing1 = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing1 === void 0 ? void 0 : _textFramePrefs_insetSpacing1.bottom) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets1 = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets1 === void 0 ? void 0 : _textFramePrefs_textInsets1.bottom) || DEFAULT_INSETS.bottom,\n            left: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing2 = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing2 === void 0 ? void 0 : _textFramePrefs_insetSpacing2.left) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets2 = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets2 === void 0 ? void 0 : _textFramePrefs_textInsets2.left) || DEFAULT_INSETS.left,\n            right: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing3 = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing3 === void 0 ? void 0 : _textFramePrefs_insetSpacing3.right) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets3 = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets3 === void 0 ? void 0 : _textFramePrefs_textInsets3.right) || DEFAULT_INSETS.right\n        };\n        // Calculate content area (available for text)\n        const contentArea = {\n            width: Math.max(0, textFrame.position.width - insets.left - insets.right),\n            height: Math.max(0, textFrame.position.height - insets.top - insets.bottom),\n            offsetX: insets.left,\n            offsetY: insets.top\n        };\n        return {\n            originalFrame: textFrame.position,\n            insets,\n            contentArea,\n            hasInsets: insets.top > 0 || insets.bottom > 0 || insets.left > 0 || insets.right > 0\n        };\n    }\n    /**\r\n   * Convert InDesign leading to precise CSS line-height\r\n   * @param {number|string} leading - InDesign leading value\r\n   * @param {number} fontSize - Font size in points\r\n   * @param {string} leadingType - Type of leading (auto, absolute, percentage)\r\n   * @returns {object} CSS-compatible line height info\r\n   */ static convertLeadingToCSS(leading, fontSize) {\n        let leadingType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"auto\";\n        let cssLineHeight;\n        let lineHeightPx;\n        switch(leadingType){\n            case \"auto\":\n                // InDesign auto leading is typically 120% of font size\n                cssLineHeight = 1.2;\n                lineHeightPx = fontSize * 1.2;\n                break;\n            case \"absolute\":\n                // Leading is in points, convert to line-height ratio\n                if (typeof leading === \"number\" && leading > 0) {\n                    cssLineHeight = Math.max(0.8, leading / fontSize);\n                    lineHeightPx = leading;\n                } else {\n                    cssLineHeight = 1.2;\n                    lineHeightPx = fontSize * 1.2;\n                }\n                break;\n            case \"percentage\":\n                // Leading is percentage-based\n                const percentage = parseFloat(leading) / 100;\n                cssLineHeight = Math.max(0.8, percentage);\n                lineHeightPx = fontSize * percentage;\n                break;\n            default:\n                cssLineHeight = 1.2;\n                lineHeightPx = fontSize * 1.2;\n        }\n        return {\n            cssLineHeight: Math.round(cssLineHeight * 1000) / 1000,\n            lineHeightPx: Math.round(lineHeightPx * 100) / 100,\n            leadingType,\n            originalLeading: leading\n        };\n    }\n    /**\r\n   * Calculate first baseline offset according to InDesign rules\r\n   * @param {string} firstBaselineOffset - InDesign first baseline offset setting\r\n   * @param {number} fontSize - Font size in points\r\n   * @param {number} lineHeight - Line height in points\r\n   * @returns {number} First baseline offset in points\r\n   */ static calculateFirstBaselineOffset(firstBaselineOffset, fontSize, lineHeight) {\n        switch(firstBaselineOffset){\n            case \"AscentOffset\":\n                // Text sits at natural ascent line (default)\n                return fontSize * 0.8; // Approximate ascent for most fonts\n            case \"CapHeightOffset\":\n                // Text sits at cap height\n                return fontSize * 0.7; // Approximate cap height for most fonts\n            case \"FixedHeight\":\n                // Custom fixed height - use line height\n                return lineHeight;\n            case \"XHeightOffset\":\n                // Text sits at x-height\n                return fontSize * 0.5; // Approximate x-height for most fonts\n            default:\n                return fontSize * 0.8; // Default to ascent offset\n        }\n    }\n    /**\r\n   * Measure text accurately using canvas with InDesign-specific adjustments\r\n   * @param {string} text - Text to measure\r\n   * @param {object} textStyles - Complete text styling object\r\n   * @param {object} frameMetrics - Text frame metrics\r\n   * @returns {object} Precise text measurement data\r\n   */ static measureTextPrecisely(text, textStyles, frameMetrics) {\n        if (!text || text.trim() === \"\") {\n            return {\n                textWidth: 0,\n                textHeight: 0,\n                lineCount: 0,\n                lines: [],\n                willOverflow: false,\n                fits: true\n            };\n        }\n        // Create canvas for measurement\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        // Set font with proper fallbacks\n        const fontSize = parseFloat(textStyles.fontSize) || 12;\n        const fontFamily = textStyles.fontFamily || \"Arial, sans-serif\";\n        const fontWeight = textStyles.fontWeight || \"normal\";\n        const fontStyle = textStyles.fontStyle || \"normal\";\n        ctx.font = \"\".concat(fontStyle, \" \").concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n        // Calculate effective content width accounting for tracking\n        const tracking = textStyles.tracking || 0;\n        const trackingAdjustment = tracking * fontSize / 1000; // Convert em to px\n        const effectiveWidth = Math.max(10, frameMetrics.contentArea.width - Math.abs(trackingAdjustment) - 2); // Leave 2px margin\n        // Split text into words for accurate wrapping, preserving line breaks\n        const words = text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\").split(/(\\s+|\\n)/).filter((word)=>word.length > 0);\n        const lines = [];\n        let currentLine = \"\";\n        let currentLineWidth = 0;\n        // Measure space width once\n        const spaceWidth = ctx.measureText(\" \").width + trackingAdjustment;\n        for(let i = 0; i < words.length; i++){\n            const word = words[i];\n            // Handle explicit line breaks\n            if (word === \"\\n\") {\n                if (currentLine) {\n                    lines.push({\n                        text: currentLine,\n                        width: currentLineWidth\n                    });\n                    currentLine = \"\";\n                    currentLineWidth = 0;\n                }\n                continue;\n            }\n            // Skip pure whitespace (except spaces)\n            if (/^\\s+$/.test(word) && word !== \" \") {\n                continue;\n            }\n            const wordWidth = ctx.measureText(word).width + Math.max(0, word.length - 1) * trackingAdjustment;\n            // Check if word fits on current line\n            const wordWithSpaceWidth = currentLine && word !== \" \" ? wordWidth + spaceWidth : wordWidth;\n            if (currentLine && word !== \" \" && currentLineWidth + wordWithSpaceWidth > effectiveWidth) {\n                // Word doesn't fit, start new line\n                lines.push({\n                    text: currentLine,\n                    width: currentLineWidth\n                });\n                currentLine = word;\n                currentLineWidth = wordWidth;\n            } else {\n                // Word fits, add to current line\n                if (currentLine && word !== \" \") {\n                    currentLine += \" \" + word;\n                    currentLineWidth += wordWithSpaceWidth;\n                } else if (word !== \" \") {\n                    currentLine = word;\n                    currentLineWidth = wordWidth;\n                }\n            }\n        }\n        // Add the last line\n        if (currentLine) {\n            lines.push({\n                text: currentLine,\n                width: currentLineWidth\n            });\n        }\n        // Calculate text height using InDesign-accurate leading\n        const lineHeightInfo = this.convertLeadingToCSS(textStyles.leading, fontSize, textStyles.leadingType);\n        const lineCount = Math.max(1, lines.length);\n        const firstBaselineOffset = this.calculateFirstBaselineOffset(textStyles.firstBaselineOffset || \"AscentOffset\", fontSize, lineHeightInfo.lineHeightPx);\n        // Calculate total text height including first baseline offset\n        const textHeight = firstBaselineOffset + (lineCount - 1) * lineHeightInfo.lineHeightPx;\n        // Check if text overflows the available height\n        const willOverflow = textHeight > frameMetrics.contentArea.height;\n        return {\n            textWidth: Math.max(...lines.map((line)=>line.width)),\n            textHeight: Math.round(textHeight * 100) / 100,\n            lineCount,\n            lines,\n            lineHeightPx: lineHeightInfo.lineHeightPx,\n            firstBaselineOffset,\n            willOverflow,\n            fits: !willOverflow,\n            availableHeight: frameMetrics.contentArea.height,\n            overflowAmount: willOverflow ? textHeight - frameMetrics.contentArea.height : 0,\n            // Detailed metrics for debugging\n            metrics: {\n                fontSize,\n                leading: textStyles.leading,\n                leadingType: textStyles.leadingType,\n                effectiveWidth,\n                tracking: trackingAdjustment,\n                spaceWidth\n            }\n        };\n    }\n    /**\r\n   * Calculate optimal font size to prevent overflow while maintaining design integrity\r\n   * @param {object} textMeasurement - Result from measureTextPrecisely\r\n   * @param {object} originalStyles - Original text styles\r\n   * @param {number} maxReduction - Maximum font size reduction allowed (0.0-1.0)\r\n   * @returns {object} Adjusted text styles or null if no adjustment needed\r\n   */ static calculateOptimalFontSize(textMeasurement, originalStyles) {\n        let maxReduction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.25;\n        if (!textMeasurement.willOverflow) {\n            return null; // No adjustment needed\n        }\n        const originalFontSize = parseFloat(originalStyles.fontSize) || 12;\n        const overflowRatio = textMeasurement.textHeight / textMeasurement.availableHeight;\n        console.log(\"\\uD83D\\uDD27 calculateOptimalFontSize:\", {\n            originalFontSize,\n            textHeight: textMeasurement.textHeight,\n            availableHeight: textMeasurement.availableHeight,\n            overflowRatio,\n            overflowAmount: textMeasurement.overflowAmount\n        });\n        // Calculate required scale factor to fit exactly\n        let scaleFactor = 1 / overflowRatio;\n        // Apply maximum reduction limit to preserve design integrity\n        const minAllowedScale = 1 - maxReduction;\n        const finalScaleFactor = Math.max(minAllowedScale, scaleFactor);\n        const newFontSize = originalFontSize * finalScaleFactor;\n        console.log(\"\\uD83D\\uDD27 Scale calculation:\", {\n            requiredScale: scaleFactor,\n            maxReduction,\n            minAllowedScale,\n            finalScaleFactor,\n            newFontSize\n        });\n        // Calculate if text will still overflow after adjustment\n        const willStillOverflow = finalScaleFactor > scaleFactor;\n        return {\n            adjustedStyles: {\n                ...originalStyles,\n                fontSize: \"\".concat(Math.round(newFontSize * 100) / 100, \"px\"),\n                // Also adjust line-height proportionally if needed\n                lineHeight: overflowRatio > 1.3 ? Math.max(0.9, parseFloat(originalStyles.lineHeight || \"1.2\") * finalScaleFactor) : originalStyles.lineHeight\n            },\n            adjustmentType: willStillOverflow ? \"partial_font_reduction\" : \"font_size_optimized\",\n            scaleFactor: finalScaleFactor,\n            originalFontSize,\n            newFontSize: Math.round(newFontSize * 100) / 100,\n            stillOverflows: willStillOverflow,\n            reductionApplied: ((1 - finalScaleFactor) * 100).toFixed(1) + \"%\"\n        };\n    }\n    /**\r\n   * Generate CSS styles with InDesign-accurate typography\r\n   * @param {object} inDesignFormatting - Formatting object from InDesign\r\n   * @param {object} frameMetrics - Text frame metrics\r\n   * @returns {object} CSS styles optimized for InDesign compatibility\r\n   */ static generateInDesignCSS(inDesignFormatting, frameMetrics) {\n        const fontSize = inDesignFormatting.fontSize || 12;\n        // Convert leading to CSS\n        const lineHeightInfo = this.convertLeadingToCSS(inDesignFormatting.leading, fontSize, inDesignFormatting.leadingType);\n        // Calculate first baseline offset for positioning\n        const firstBaselineOffset = this.calculateFirstBaselineOffset(inDesignFormatting.firstBaselineOffset || \"AscentOffset\", fontSize, lineHeightInfo.lineHeightPx);\n        return {\n            // Typography\n            fontSize: \"\".concat(fontSize, \"px\"),\n            lineHeight: lineHeightInfo.cssLineHeight,\n            fontFamily: inDesignFormatting.fontFamily || \"Arial, sans-serif\",\n            fontWeight: inDesignFormatting.fontWeight || \"normal\",\n            fontStyle: inDesignFormatting.fontStyle || \"normal\",\n            // Advanced typography\n            letterSpacing: inDesignFormatting.tracking ? \"\".concat(inDesignFormatting.tracking / 1000, \"em\") : \"normal\",\n            textAlign: inDesignFormatting.textAlign || \"left\",\n            color: inDesignFormatting.color || \"black\",\n            // Layout and positioning - minimal padding to avoid excessive top spacing\n            padding: \"\".concat(Math.min(2, firstBaselineOffset * 0.2), \"px \").concat(frameMetrics.insets.right, \"px \").concat(frameMetrics.insets.bottom, \"px \").concat(frameMetrics.insets.left, \"px\"),\n            margin: 0,\n            // Overflow control\n            width: \"\".concat(frameMetrics.contentArea.width, \"px\"),\n            height: \"\".concat(frameMetrics.contentArea.height, \"px\"),\n            overflow: \"hidden\",\n            boxSizing: \"border-box\",\n            // Text layout optimization\n            whiteSpace: \"normal\",\n            wordWrap: \"break-word\",\n            overflowWrap: \"break-word\",\n            wordBreak: \"normal\",\n            // InDesign-specific adjustments\n            position: \"relative\",\n            top: frameMetrics.hasInsets ? \"\".concat(frameMetrics.offsetY, \"px\") : \"0\",\n            left: frameMetrics.hasInsets ? \"\".concat(frameMetrics.offsetX, \"px\") : \"0\",\n            // Debug info (can be removed in production)\n            \"--indesign-leading\": inDesignFormatting.leading,\n            \"--indesign-leading-type\": inDesignFormatting.leadingType,\n            \"--css-line-height\": lineHeightInfo.cssLineHeight,\n            \"--first-baseline-offset\": \"\".concat(firstBaselineOffset, \"px\")\n        };\n    }\n}\n// Export for use in other modules\nif ( true && module.exports) {\n    module.exports = InDesignTextMetrics;\n} else if (true) {\n    window.InDesignTextMetrics = InDesignTextMetrics;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFPLEVBQUMsUUFBTTtZQUM1RFosTUFBTStCLGFBQWFqQixTQUFTLEdBQUcsR0FBd0IsT0FBckJpQixhQUFhcEIsT0FBTyxFQUFDLFFBQU07WUFFN0QsNENBQTRDO1lBQzVDLHNCQUFzQmtGLG1CQUFtQjdFLE9BQU87WUFDaEQsMkJBQTJCNkUsbUJBQW1CM0UsV0FBVztZQUN6RCxxQkFBcUJpRCxlQUFlaEQsYUFBYTtZQUNqRCwyQkFBMkIsR0FBdUIsT0FBcEJPLHFCQUFvQjtRQUNwRDtJQUNGO0FBQ0Y7QUFFQSxrQ0FBa0M7QUFDbEMsSUFBSSxLQUFrQixJQUFlZ0YsT0FBT0MsT0FBTyxFQUFFO0lBQ25ERCxPQUFPQyxPQUFPLEdBQUdsSDtBQUNuQixPQUFPLElBQUksSUFBa0IsRUFBYTtJQUN4Q21ILE9BQU9uSCxtQkFBbUIsR0FBR0E7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3V0aWxzL0luRGVzaWduVGV4dE1ldHJpY3MuanM/N2U1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogSW5EZXNpZ25UZXh0TWV0cmljcy5qcyAtIFByZWNpc2UgdGV4dCBtZWFzdXJlbWVudCB1dGlsaXR5IGZvciAxOjEgSW5EZXNpZ24gY29tcGF0aWJpbGl0eVxyXG4gKiBIYW5kbGVzIGZvbnQgbWV0cmljcywgbGVhZGluZyBjYWxjdWxhdGlvbnMsIGFuZCB0ZXh0IGZyYW1lIGluc2V0cyBleGFjdGx5IGxpa2UgSW5EZXNpZ25cclxuICovXHJcblxyXG5jbGFzcyBJbkRlc2lnblRleHRNZXRyaWNzIHtcclxuICBcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgcHJlY2lzZSB0ZXh0IGZyYW1lIGRpbWVuc2lvbnMgaW5jbHVkaW5nIEluRGVzaWduLXNwZWNpZmljIGluc2V0c1xyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0ZXh0RnJhbWUgLSBUaGUgdGV4dCBmcmFtZSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHRleHRGcmFtZVByZWZzIC0gVGV4dCBmcmFtZSBwcmVmZXJlbmNlcyBmcm9tIEluRGVzaWduXHJcbiAgICogQHJldHVybnMge29iamVjdH0gQWRqdXN0ZWQgZnJhbWUgZGltZW5zaW9uc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjYWxjdWxhdGVUZXh0RnJhbWVJbnNldHModGV4dEZyYW1lLCB0ZXh0RnJhbWVQcmVmcykge1xyXG4gICAgLy8gSW5EZXNpZ24gZGVmYXVsdCB0ZXh0IGZyYW1lIGluc2V0cyAoaW4gcG9pbnRzKVxyXG4gICAgY29uc3QgREVGQVVMVF9JTlNFVFMgPSB7XHJcbiAgICAgIHRvcDogMCxcclxuICAgICAgYm90dG9tOiAwLFxyXG4gICAgICBsZWZ0OiAwLFxyXG4gICAgICByaWdodDogMFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBpbnNldHMgZnJvbSBwcmVmZXJlbmNlcyBpZiBhdmFpbGFibGVcclxuICAgIGNvbnN0IGluc2V0cyA9IHtcclxuICAgICAgdG9wOiB0ZXh0RnJhbWVQcmVmcz8uaW5zZXRTcGFjaW5nPy50b3AgfHwgdGV4dEZyYW1lUHJlZnM/LnRleHRJbnNldHM/LnRvcCB8fCBERUZBVUxUX0lOU0VUUy50b3AsXHJcbiAgICAgIGJvdHRvbTogdGV4dEZyYW1lUHJlZnM/Lmluc2V0U3BhY2luZz8uYm90dG9tIHx8IHRleHRGcmFtZVByZWZzPy50ZXh0SW5zZXRzPy5ib3R0b20gfHwgREVGQVVMVF9JTlNFVFMuYm90dG9tLFxyXG4gICAgICBsZWZ0OiB0ZXh0RnJhbWVQcmVmcz8uaW5zZXRTcGFjaW5nPy5sZWZ0IHx8IHRleHRGcmFtZVByZWZzPy50ZXh0SW5zZXRzPy5sZWZ0IHx8IERFRkFVTFRfSU5TRVRTLmxlZnQsXHJcbiAgICAgIHJpZ2h0OiB0ZXh0RnJhbWVQcmVmcz8uaW5zZXRTcGFjaW5nPy5yaWdodCB8fCB0ZXh0RnJhbWVQcmVmcz8udGV4dEluc2V0cz8ucmlnaHQgfHwgREVGQVVMVF9JTlNFVFMucmlnaHRcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBjb250ZW50IGFyZWEgKGF2YWlsYWJsZSBmb3IgdGV4dClcclxuICAgIGNvbnN0IGNvbnRlbnRBcmVhID0ge1xyXG4gICAgICB3aWR0aDogTWF0aC5tYXgoMCwgdGV4dEZyYW1lLnBvc2l0aW9uLndpZHRoIC0gaW5zZXRzLmxlZnQgLSBpbnNldHMucmlnaHQpLFxyXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIHRleHRGcmFtZS5wb3NpdGlvbi5oZWlnaHQgLSBpbnNldHMudG9wIC0gaW5zZXRzLmJvdHRvbSksXHJcbiAgICAgIG9mZnNldFg6IGluc2V0cy5sZWZ0LFxyXG4gICAgICBvZmZzZXRZOiBpbnNldHMudG9wXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvcmlnaW5hbEZyYW1lOiB0ZXh0RnJhbWUucG9zaXRpb24sXHJcbiAgICAgIGluc2V0cyxcclxuICAgICAgY29udGVudEFyZWEsXHJcbiAgICAgIGhhc0luc2V0czogaW5zZXRzLnRvcCA+IDAgfHwgaW5zZXRzLmJvdHRvbSA+IDAgfHwgaW5zZXRzLmxlZnQgPiAwIHx8IGluc2V0cy5yaWdodCA+IDBcclxuICAgIH07XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgSW5EZXNpZ24gbGVhZGluZyB0byBwcmVjaXNlIENTUyBsaW5lLWhlaWdodFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbGVhZGluZyAtIEluRGVzaWduIGxlYWRpbmcgdmFsdWVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZm9udFNpemUgLSBGb250IHNpemUgaW4gcG9pbnRzXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYWRpbmdUeXBlIC0gVHlwZSBvZiBsZWFkaW5nIChhdXRvLCBhYnNvbHV0ZSwgcGVyY2VudGFnZSlcclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDU1MtY29tcGF0aWJsZSBsaW5lIGhlaWdodCBpbmZvXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbnZlcnRMZWFkaW5nVG9DU1MobGVhZGluZywgZm9udFNpemUsIGxlYWRpbmdUeXBlID0gJ2F1dG8nKSB7XHJcbiAgICBsZXQgY3NzTGluZUhlaWdodDtcclxuICAgIGxldCBsaW5lSGVpZ2h0UHg7XHJcbiAgICBcclxuICAgIHN3aXRjaCAobGVhZGluZ1R5cGUpIHtcclxuICAgICAgY2FzZSAnYXV0byc6XHJcbiAgICAgICAgLy8gSW5EZXNpZ24gYXV0byBsZWFkaW5nIGlzIHR5cGljYWxseSAxMjAlIG9mIGZvbnQgc2l6ZVxyXG4gICAgICAgIGNzc0xpbmVIZWlnaHQgPSAxLjI7XHJcbiAgICAgICAgbGluZUhlaWdodFB4ID0gZm9udFNpemUgKiAxLjI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ2Fic29sdXRlJzpcclxuICAgICAgICAvLyBMZWFkaW5nIGlzIGluIHBvaW50cywgY29udmVydCB0byBsaW5lLWhlaWdodCByYXRpb1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGVhZGluZyA9PT0gJ251bWJlcicgJiYgbGVhZGluZyA+IDApIHtcclxuICAgICAgICAgIGNzc0xpbmVIZWlnaHQgPSBNYXRoLm1heCgwLjgsIGxlYWRpbmcgLyBmb250U2l6ZSk7XHJcbiAgICAgICAgICBsaW5lSGVpZ2h0UHggPSBsZWFkaW5nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjc3NMaW5lSGVpZ2h0ID0gMS4yO1xyXG4gICAgICAgICAgbGluZUhlaWdodFB4ID0gZm9udFNpemUgKiAxLjI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIFxyXG4gICAgICBjYXNlICdwZXJjZW50YWdlJzpcclxuICAgICAgICAvLyBMZWFkaW5nIGlzIHBlcmNlbnRhZ2UtYmFzZWRcclxuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChsZWFkaW5nKSAvIDEwMDtcclxuICAgICAgICBjc3NMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoMC44LCBwZXJjZW50YWdlKTtcclxuICAgICAgICBsaW5lSGVpZ2h0UHggPSBmb250U2l6ZSAqIHBlcmNlbnRhZ2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgY3NzTGluZUhlaWdodCA9IDEuMjtcclxuICAgICAgICBsaW5lSGVpZ2h0UHggPSBmb250U2l6ZSAqIDEuMjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY3NzTGluZUhlaWdodDogTWF0aC5yb3VuZChjc3NMaW5lSGVpZ2h0ICogMTAwMCkgLyAxMDAwLCAvLyBSb3VuZCB0byAzIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgIGxpbmVIZWlnaHRQeDogTWF0aC5yb3VuZChsaW5lSGVpZ2h0UHggKiAxMDApIC8gMTAwLCAgICAgLy8gUm91bmQgdG8gMiBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICBsZWFkaW5nVHlwZSxcclxuICAgICAgb3JpZ2luYWxMZWFkaW5nOiBsZWFkaW5nXHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgZmlyc3QgYmFzZWxpbmUgb2Zmc2V0IGFjY29yZGluZyB0byBJbkRlc2lnbiBydWxlc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaXJzdEJhc2VsaW5lT2Zmc2V0IC0gSW5EZXNpZ24gZmlyc3QgYmFzZWxpbmUgb2Zmc2V0IHNldHRpbmdcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZm9udFNpemUgLSBGb250IHNpemUgaW4gcG9pbnRzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVIZWlnaHQgLSBMaW5lIGhlaWdodCBpbiBwb2ludHNcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBGaXJzdCBiYXNlbGluZSBvZmZzZXQgaW4gcG9pbnRzXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUZpcnN0QmFzZWxpbmVPZmZzZXQoZmlyc3RCYXNlbGluZU9mZnNldCwgZm9udFNpemUsIGxpbmVIZWlnaHQpIHtcclxuICAgIHN3aXRjaCAoZmlyc3RCYXNlbGluZU9mZnNldCkge1xyXG4gICAgICBjYXNlICdBc2NlbnRPZmZzZXQnOlxyXG4gICAgICAgIC8vIFRleHQgc2l0cyBhdCBuYXR1cmFsIGFzY2VudCBsaW5lIChkZWZhdWx0KVxyXG4gICAgICAgIHJldHVybiBmb250U2l6ZSAqIDAuODsgLy8gQXBwcm94aW1hdGUgYXNjZW50IGZvciBtb3N0IGZvbnRzXHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ0NhcEhlaWdodE9mZnNldCc6XHJcbiAgICAgICAgLy8gVGV4dCBzaXRzIGF0IGNhcCBoZWlnaHRcclxuICAgICAgICByZXR1cm4gZm9udFNpemUgKiAwLjc7IC8vIEFwcHJveGltYXRlIGNhcCBoZWlnaHQgZm9yIG1vc3QgZm9udHNcclxuICAgICAgICBcclxuICAgICAgY2FzZSAnRml4ZWRIZWlnaHQnOlxyXG4gICAgICAgIC8vIEN1c3RvbSBmaXhlZCBoZWlnaHQgLSB1c2UgbGluZSBoZWlnaHRcclxuICAgICAgICByZXR1cm4gbGluZUhlaWdodDtcclxuICAgICAgICBcclxuICAgICAgY2FzZSAnWEhlaWdodE9mZnNldCc6XHJcbiAgICAgICAgLy8gVGV4dCBzaXRzIGF0IHgtaGVpZ2h0XHJcbiAgICAgICAgcmV0dXJuIGZvbnRTaXplICogMC41OyAvLyBBcHByb3hpbWF0ZSB4LWhlaWdodCBmb3IgbW9zdCBmb250c1xyXG4gICAgICAgIFxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBmb250U2l6ZSAqIDAuODsgLy8gRGVmYXVsdCB0byBhc2NlbnQgb2Zmc2V0XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIE1lYXN1cmUgdGV4dCBhY2N1cmF0ZWx5IHVzaW5nIGNhbnZhcyB3aXRoIEluRGVzaWduLXNwZWNpZmljIGFkanVzdG1lbnRzXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IHRvIG1lYXN1cmVcclxuICAgKiBAcGFyYW0ge29iamVjdH0gdGV4dFN0eWxlcyAtIENvbXBsZXRlIHRleHQgc3R5bGluZyBvYmplY3RcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZnJhbWVNZXRyaWNzIC0gVGV4dCBmcmFtZSBtZXRyaWNzXHJcbiAgICogQHJldHVybnMge29iamVjdH0gUHJlY2lzZSB0ZXh0IG1lYXN1cmVtZW50IGRhdGFcclxuICAgKi9cclxuICBzdGF0aWMgbWVhc3VyZVRleHRQcmVjaXNlbHkodGV4dCwgdGV4dFN0eWxlcywgZnJhbWVNZXRyaWNzKSB7XHJcbiAgICBpZiAoIXRleHQgfHwgdGV4dC50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGV4dFdpZHRoOiAwLFxyXG4gICAgICAgIHRleHRIZWlnaHQ6IDAsXHJcbiAgICAgICAgbGluZUNvdW50OiAwLFxyXG4gICAgICAgIGxpbmVzOiBbXSxcclxuICAgICAgICB3aWxsT3ZlcmZsb3c6IGZhbHNlLFxyXG4gICAgICAgIGZpdHM6IHRydWVcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGNhbnZhcyBmb3IgbWVhc3VyZW1lbnRcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBcclxuICAgIC8vIFNldCBmb250IHdpdGggcHJvcGVyIGZhbGxiYWNrc1xyXG4gICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUZsb2F0KHRleHRTdHlsZXMuZm9udFNpemUpIHx8IDEyO1xyXG4gICAgY29uc3QgZm9udEZhbWlseSA9IHRleHRTdHlsZXMuZm9udEZhbWlseSB8fCAnQXJpYWwsIHNhbnMtc2VyaWYnO1xyXG4gICAgY29uc3QgZm9udFdlaWdodCA9IHRleHRTdHlsZXMuZm9udFdlaWdodCB8fCAnbm9ybWFsJztcclxuICAgIGNvbnN0IGZvbnRTdHlsZSA9IHRleHRTdHlsZXMuZm9udFN0eWxlIHx8ICdub3JtYWwnO1xyXG4gICAgXHJcbiAgICBjdHguZm9udCA9IGAke2ZvbnRTdHlsZX0gJHtmb250V2VpZ2h0fSAke2ZvbnRTaXplfXB4ICR7Zm9udEZhbWlseX1gO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgZWZmZWN0aXZlIGNvbnRlbnQgd2lkdGggYWNjb3VudGluZyBmb3IgdHJhY2tpbmdcclxuICAgIGNvbnN0IHRyYWNraW5nID0gdGV4dFN0eWxlcy50cmFja2luZyB8fCAwO1xyXG4gICAgY29uc3QgdHJhY2tpbmdBZGp1c3RtZW50ID0gdHJhY2tpbmcgKiBmb250U2l6ZSAvIDEwMDA7IC8vIENvbnZlcnQgZW0gdG8gcHhcclxuICAgIGNvbnN0IGVmZmVjdGl2ZVdpZHRoID0gTWF0aC5tYXgoMTAsIGZyYW1lTWV0cmljcy5jb250ZW50QXJlYS53aWR0aCAtIE1hdGguYWJzKHRyYWNraW5nQWRqdXN0bWVudCkgLSAyKTsgLy8gTGVhdmUgMnB4IG1hcmdpblxyXG4gICAgXHJcbiAgICAvLyBTcGxpdCB0ZXh0IGludG8gd29yZHMgZm9yIGFjY3VyYXRlIHdyYXBwaW5nLCBwcmVzZXJ2aW5nIGxpbmUgYnJlYWtzXHJcbiAgICBjb25zdCB3b3JkcyA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpLnNwbGl0KC8oXFxzK3xcXG4pLykuZmlsdGVyKHdvcmQgPT4gd29yZC5sZW5ndGggPiAwKTtcclxuICAgIGNvbnN0IGxpbmVzID0gW107XHJcbiAgICBsZXQgY3VycmVudExpbmUgPSAnJztcclxuICAgIGxldCBjdXJyZW50TGluZVdpZHRoID0gMDtcclxuICAgIFxyXG4gICAgLy8gTWVhc3VyZSBzcGFjZSB3aWR0aCBvbmNlXHJcbiAgICBjb25zdCBzcGFjZVdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KCcgJykud2lkdGggKyB0cmFja2luZ0FkanVzdG1lbnQ7XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgd29yZCA9IHdvcmRzW2ldO1xyXG4gICAgICBcclxuICAgICAgLy8gSGFuZGxlIGV4cGxpY2l0IGxpbmUgYnJlYWtzXHJcbiAgICAgIGlmICh3b3JkID09PSAnXFxuJykge1xyXG4gICAgICAgIGlmIChjdXJyZW50TGluZSkge1xyXG4gICAgICAgICAgbGluZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHRleHQ6IGN1cnJlbnRMaW5lLFxyXG4gICAgICAgICAgICB3aWR0aDogY3VycmVudExpbmVXaWR0aFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBjdXJyZW50TGluZSA9ICcnO1xyXG4gICAgICAgICAgY3VycmVudExpbmVXaWR0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTa2lwIHB1cmUgd2hpdGVzcGFjZSAoZXhjZXB0IHNwYWNlcylcclxuICAgICAgaWYgKC9eXFxzKyQvLnRlc3Qod29yZCkgJiYgd29yZCAhPT0gJyAnKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHdvcmRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh3b3JkKS53aWR0aCArIE1hdGgubWF4KDAsICh3b3JkLmxlbmd0aCAtIDEpKSAqIHRyYWNraW5nQWRqdXN0bWVudDtcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcclxuICAgICAgY29uc3Qgd29yZFdpdGhTcGFjZVdpZHRoID0gY3VycmVudExpbmUgJiYgd29yZCAhPT0gJyAnID8gd29yZFdpZHRoICsgc3BhY2VXaWR0aCA6IHdvcmRXaWR0aDtcclxuICAgICAgXHJcbiAgICAgIGlmIChjdXJyZW50TGluZSAmJiB3b3JkICE9PSAnICcgJiYgKGN1cnJlbnRMaW5lV2lkdGggKyB3b3JkV2l0aFNwYWNlV2lkdGggPiBlZmZlY3RpdmVXaWR0aCkpIHtcclxuICAgICAgICAvLyBXb3JkIGRvZXNuJ3QgZml0LCBzdGFydCBuZXcgbGluZVxyXG4gICAgICAgIGxpbmVzLnB1c2goe1xyXG4gICAgICAgICAgdGV4dDogY3VycmVudExpbmUsXHJcbiAgICAgICAgICB3aWR0aDogY3VycmVudExpbmVXaWR0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGN1cnJlbnRMaW5lID0gd29yZDtcclxuICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gd29yZFdpZHRoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFdvcmQgZml0cywgYWRkIHRvIGN1cnJlbnQgbGluZVxyXG4gICAgICAgIGlmIChjdXJyZW50TGluZSAmJiB3b3JkICE9PSAnICcpIHtcclxuICAgICAgICAgIGN1cnJlbnRMaW5lICs9ICcgJyArIHdvcmQ7XHJcbiAgICAgICAgICBjdXJyZW50TGluZVdpZHRoICs9IHdvcmRXaXRoU3BhY2VXaWR0aDtcclxuICAgICAgICB9IGVsc2UgaWYgKHdvcmQgIT09ICcgJykge1xyXG4gICAgICAgICAgY3VycmVudExpbmUgPSB3b3JkO1xyXG4gICAgICAgICAgY3VycmVudExpbmVXaWR0aCA9IHdvcmRXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQWRkIHRoZSBsYXN0IGxpbmVcclxuICAgIGlmIChjdXJyZW50TGluZSkge1xyXG4gICAgICBsaW5lcy5wdXNoKHtcclxuICAgICAgICB0ZXh0OiBjdXJyZW50TGluZSxcclxuICAgICAgICB3aWR0aDogY3VycmVudExpbmVXaWR0aFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRleHQgaGVpZ2h0IHVzaW5nIEluRGVzaWduLWFjY3VyYXRlIGxlYWRpbmdcclxuICAgIGNvbnN0IGxpbmVIZWlnaHRJbmZvID0gdGhpcy5jb252ZXJ0TGVhZGluZ1RvQ1NTKFxyXG4gICAgICB0ZXh0U3R5bGVzLmxlYWRpbmcsIFxyXG4gICAgICBmb250U2l6ZSwgXHJcbiAgICAgIHRleHRTdHlsZXMubGVhZGluZ1R5cGVcclxuICAgICk7XHJcbiAgICBcclxuICAgIGNvbnN0IGxpbmVDb3VudCA9IE1hdGgubWF4KDEsIGxpbmVzLmxlbmd0aCk7XHJcbiAgICBjb25zdCBmaXJzdEJhc2VsaW5lT2Zmc2V0ID0gdGhpcy5jYWxjdWxhdGVGaXJzdEJhc2VsaW5lT2Zmc2V0KFxyXG4gICAgICB0ZXh0U3R5bGVzLmZpcnN0QmFzZWxpbmVPZmZzZXQgfHwgJ0FzY2VudE9mZnNldCcsXHJcbiAgICAgIGZvbnRTaXplLFxyXG4gICAgICBsaW5lSGVpZ2h0SW5mby5saW5lSGVpZ2h0UHhcclxuICAgICk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB0ZXh0IGhlaWdodCBpbmNsdWRpbmcgZmlyc3QgYmFzZWxpbmUgb2Zmc2V0XHJcbiAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gZmlyc3RCYXNlbGluZU9mZnNldCArICgobGluZUNvdW50IC0gMSkgKiBsaW5lSGVpZ2h0SW5mby5saW5lSGVpZ2h0UHgpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiB0ZXh0IG92ZXJmbG93cyB0aGUgYXZhaWxhYmxlIGhlaWdodFxyXG4gICAgY29uc3Qgd2lsbE92ZXJmbG93ID0gdGV4dEhlaWdodCA+IGZyYW1lTWV0cmljcy5jb250ZW50QXJlYS5oZWlnaHQ7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHRXaWR0aDogTWF0aC5tYXgoLi4ubGluZXMubWFwKGxpbmUgPT4gbGluZS53aWR0aCkpLFxyXG4gICAgICB0ZXh0SGVpZ2h0OiBNYXRoLnJvdW5kKHRleHRIZWlnaHQgKiAxMDApIC8gMTAwLFxyXG4gICAgICBsaW5lQ291bnQsXHJcbiAgICAgIGxpbmVzLFxyXG4gICAgICBsaW5lSGVpZ2h0UHg6IGxpbmVIZWlnaHRJbmZvLmxpbmVIZWlnaHRQeCxcclxuICAgICAgZmlyc3RCYXNlbGluZU9mZnNldCxcclxuICAgICAgd2lsbE92ZXJmbG93LFxyXG4gICAgICBmaXRzOiAhd2lsbE92ZXJmbG93LFxyXG4gICAgICBhdmFpbGFibGVIZWlnaHQ6IGZyYW1lTWV0cmljcy5jb250ZW50QXJlYS5oZWlnaHQsXHJcbiAgICAgIG92ZXJmbG93QW1vdW50OiB3aWxsT3ZlcmZsb3cgPyB0ZXh0SGVpZ2h0IC0gZnJhbWVNZXRyaWNzLmNvbnRlbnRBcmVhLmhlaWdodCA6IDAsXHJcbiAgICAgIC8vIERldGFpbGVkIG1ldHJpY3MgZm9yIGRlYnVnZ2luZ1xyXG4gICAgICBtZXRyaWNzOiB7XHJcbiAgICAgICAgZm9udFNpemUsXHJcbiAgICAgICAgbGVhZGluZzogdGV4dFN0eWxlcy5sZWFkaW5nLFxyXG4gICAgICAgIGxlYWRpbmdUeXBlOiB0ZXh0U3R5bGVzLmxlYWRpbmdUeXBlLFxyXG4gICAgICAgIGVmZmVjdGl2ZVdpZHRoLFxyXG4gICAgICAgIHRyYWNraW5nOiB0cmFja2luZ0FkanVzdG1lbnQsXHJcbiAgICAgICAgc3BhY2VXaWR0aFxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgb3B0aW1hbCBmb250IHNpemUgdG8gcHJldmVudCBvdmVyZmxvdyB3aGlsZSBtYWludGFpbmluZyBkZXNpZ24gaW50ZWdyaXR5XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHRleHRNZWFzdXJlbWVudCAtIFJlc3VsdCBmcm9tIG1lYXN1cmVUZXh0UHJlY2lzZWx5XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9yaWdpbmFsU3R5bGVzIC0gT3JpZ2luYWwgdGV4dCBzdHlsZXNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmVkdWN0aW9uIC0gTWF4aW11bSBmb250IHNpemUgcmVkdWN0aW9uIGFsbG93ZWQgKDAuMC0xLjApXHJcbiAgICogQHJldHVybnMge29iamVjdH0gQWRqdXN0ZWQgdGV4dCBzdHlsZXMgb3IgbnVsbCBpZiBubyBhZGp1c3RtZW50IG5lZWRlZFxyXG4gICAqL1xyXG4gIHN0YXRpYyBjYWxjdWxhdGVPcHRpbWFsRm9udFNpemUodGV4dE1lYXN1cmVtZW50LCBvcmlnaW5hbFN0eWxlcywgbWF4UmVkdWN0aW9uID0gMC4yNSkge1xyXG4gICAgaWYgKCF0ZXh0TWVhc3VyZW1lbnQud2lsbE92ZXJmbG93KSB7XHJcbiAgICAgIHJldHVybiBudWxsOyAvLyBObyBhZGp1c3RtZW50IG5lZWRlZFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBvcmlnaW5hbEZvbnRTaXplID0gcGFyc2VGbG9hdChvcmlnaW5hbFN0eWxlcy5mb250U2l6ZSkgfHwgMTI7XHJcbiAgICBjb25zdCBvdmVyZmxvd1JhdGlvID0gdGV4dE1lYXN1cmVtZW50LnRleHRIZWlnaHQgLyB0ZXh0TWVhc3VyZW1lbnQuYXZhaWxhYmxlSGVpZ2h0O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygn8J+UpyBjYWxjdWxhdGVPcHRpbWFsRm9udFNpemU6Jywge1xyXG4gICAgICBvcmlnaW5hbEZvbnRTaXplLFxyXG4gICAgICB0ZXh0SGVpZ2h0OiB0ZXh0TWVhc3VyZW1lbnQudGV4dEhlaWdodCxcclxuICAgICAgYXZhaWxhYmxlSGVpZ2h0OiB0ZXh0TWVhc3VyZW1lbnQuYXZhaWxhYmxlSGVpZ2h0LFxyXG4gICAgICBvdmVyZmxvd1JhdGlvLFxyXG4gICAgICBvdmVyZmxvd0Ftb3VudDogdGV4dE1lYXN1cmVtZW50Lm92ZXJmbG93QW1vdW50XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHJlcXVpcmVkIHNjYWxlIGZhY3RvciB0byBmaXQgZXhhY3RseVxyXG4gICAgbGV0IHNjYWxlRmFjdG9yID0gMSAvIG92ZXJmbG93UmF0aW87XHJcbiAgICBcclxuICAgIC8vIEFwcGx5IG1heGltdW0gcmVkdWN0aW9uIGxpbWl0IHRvIHByZXNlcnZlIGRlc2lnbiBpbnRlZ3JpdHlcclxuICAgIGNvbnN0IG1pbkFsbG93ZWRTY2FsZSA9IDEgLSBtYXhSZWR1Y3Rpb247XHJcbiAgICBjb25zdCBmaW5hbFNjYWxlRmFjdG9yID0gTWF0aC5tYXgobWluQWxsb3dlZFNjYWxlLCBzY2FsZUZhY3Rvcik7XHJcbiAgICBcclxuICAgIGNvbnN0IG5ld0ZvbnRTaXplID0gb3JpZ2luYWxGb250U2l6ZSAqIGZpbmFsU2NhbGVGYWN0b3I7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCfwn5SnIFNjYWxlIGNhbGN1bGF0aW9uOicsIHtcclxuICAgICAgcmVxdWlyZWRTY2FsZTogc2NhbGVGYWN0b3IsXHJcbiAgICAgIG1heFJlZHVjdGlvbixcclxuICAgICAgbWluQWxsb3dlZFNjYWxlLFxyXG4gICAgICBmaW5hbFNjYWxlRmFjdG9yLFxyXG4gICAgICBuZXdGb250U2l6ZVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBpZiB0ZXh0IHdpbGwgc3RpbGwgb3ZlcmZsb3cgYWZ0ZXIgYWRqdXN0bWVudFxyXG4gICAgY29uc3Qgd2lsbFN0aWxsT3ZlcmZsb3cgPSBmaW5hbFNjYWxlRmFjdG9yID4gc2NhbGVGYWN0b3I7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGFkanVzdGVkU3R5bGVzOiB7XHJcbiAgICAgICAgLi4ub3JpZ2luYWxTdHlsZXMsXHJcbiAgICAgICAgZm9udFNpemU6IGAke01hdGgucm91bmQobmV3Rm9udFNpemUgKiAxMDApIC8gMTAwfXB4YCxcclxuICAgICAgICAvLyBBbHNvIGFkanVzdCBsaW5lLWhlaWdodCBwcm9wb3J0aW9uYWxseSBpZiBuZWVkZWRcclxuICAgICAgICBsaW5lSGVpZ2h0OiBvdmVyZmxvd1JhdGlvID4gMS4zID8gXHJcbiAgICAgICAgICBNYXRoLm1heCgwLjksIHBhcnNlRmxvYXQob3JpZ2luYWxTdHlsZXMubGluZUhlaWdodCB8fCAnMS4yJykgKiBmaW5hbFNjYWxlRmFjdG9yKSA6XHJcbiAgICAgICAgICBvcmlnaW5hbFN0eWxlcy5saW5lSGVpZ2h0XHJcbiAgICAgIH0sXHJcbiAgICAgIGFkanVzdG1lbnRUeXBlOiB3aWxsU3RpbGxPdmVyZmxvdyA/ICdwYXJ0aWFsX2ZvbnRfcmVkdWN0aW9uJyA6ICdmb250X3NpemVfb3B0aW1pemVkJyxcclxuICAgICAgc2NhbGVGYWN0b3I6IGZpbmFsU2NhbGVGYWN0b3IsXHJcbiAgICAgIG9yaWdpbmFsRm9udFNpemUsXHJcbiAgICAgIG5ld0ZvbnRTaXplOiBNYXRoLnJvdW5kKG5ld0ZvbnRTaXplICogMTAwKSAvIDEwMCxcclxuICAgICAgc3RpbGxPdmVyZmxvd3M6IHdpbGxTdGlsbE92ZXJmbG93LFxyXG4gICAgICByZWR1Y3Rpb25BcHBsaWVkOiAoKDEgLSBmaW5hbFNjYWxlRmFjdG9yKSAqIDEwMCkudG9GaXhlZCgxKSArICclJ1xyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgQ1NTIHN0eWxlcyB3aXRoIEluRGVzaWduLWFjY3VyYXRlIHR5cG9ncmFwaHlcclxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5EZXNpZ25Gb3JtYXR0aW5nIC0gRm9ybWF0dGluZyBvYmplY3QgZnJvbSBJbkRlc2lnblxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmcmFtZU1ldHJpY3MgLSBUZXh0IGZyYW1lIG1ldHJpY3NcclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDU1Mgc3R5bGVzIG9wdGltaXplZCBmb3IgSW5EZXNpZ24gY29tcGF0aWJpbGl0eVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZW5lcmF0ZUluRGVzaWduQ1NTKGluRGVzaWduRm9ybWF0dGluZywgZnJhbWVNZXRyaWNzKSB7XHJcbiAgICBjb25zdCBmb250U2l6ZSA9IGluRGVzaWduRm9ybWF0dGluZy5mb250U2l6ZSB8fCAxMjtcclxuICAgIFxyXG4gICAgLy8gQ29udmVydCBsZWFkaW5nIHRvIENTU1xyXG4gICAgY29uc3QgbGluZUhlaWdodEluZm8gPSB0aGlzLmNvbnZlcnRMZWFkaW5nVG9DU1MoXHJcbiAgICAgIGluRGVzaWduRm9ybWF0dGluZy5sZWFkaW5nLFxyXG4gICAgICBmb250U2l6ZSxcclxuICAgICAgaW5EZXNpZ25Gb3JtYXR0aW5nLmxlYWRpbmdUeXBlXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgZmlyc3QgYmFzZWxpbmUgb2Zmc2V0IGZvciBwb3NpdGlvbmluZ1xyXG4gICAgY29uc3QgZmlyc3RCYXNlbGluZU9mZnNldCA9IHRoaXMuY2FsY3VsYXRlRmlyc3RCYXNlbGluZU9mZnNldChcclxuICAgICAgaW5EZXNpZ25Gb3JtYXR0aW5nLmZpcnN0QmFzZWxpbmVPZmZzZXQgfHwgJ0FzY2VudE9mZnNldCcsXHJcbiAgICAgIGZvbnRTaXplLFxyXG4gICAgICBsaW5lSGVpZ2h0SW5mby5saW5lSGVpZ2h0UHhcclxuICAgICk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8vIFR5cG9ncmFwaHlcclxuICAgICAgZm9udFNpemU6IGAke2ZvbnRTaXplfXB4YCxcclxuICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodEluZm8uY3NzTGluZUhlaWdodCxcclxuICAgICAgZm9udEZhbWlseTogaW5EZXNpZ25Gb3JtYXR0aW5nLmZvbnRGYW1pbHkgfHwgJ0FyaWFsLCBzYW5zLXNlcmlmJyxcclxuICAgICAgZm9udFdlaWdodDogaW5EZXNpZ25Gb3JtYXR0aW5nLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCcsXHJcbiAgICAgIGZvbnRTdHlsZTogaW5EZXNpZ25Gb3JtYXR0aW5nLmZvbnRTdHlsZSB8fCAnbm9ybWFsJyxcclxuICAgICAgXHJcbiAgICAgIC8vIEFkdmFuY2VkIHR5cG9ncmFwaHlcclxuICAgICAgbGV0dGVyU3BhY2luZzogaW5EZXNpZ25Gb3JtYXR0aW5nLnRyYWNraW5nID8gYCR7aW5EZXNpZ25Gb3JtYXR0aW5nLnRyYWNraW5nIC8gMTAwMH1lbWAgOiAnbm9ybWFsJyxcclxuICAgICAgdGV4dEFsaWduOiBpbkRlc2lnbkZvcm1hdHRpbmcudGV4dEFsaWduIHx8ICdsZWZ0JyxcclxuICAgICAgY29sb3I6IGluRGVzaWduRm9ybWF0dGluZy5jb2xvciB8fCAnYmxhY2snLFxyXG4gICAgICBcclxuICAgICAgLy8gTGF5b3V0IGFuZCBwb3NpdGlvbmluZyAtIG1pbmltYWwgcGFkZGluZyB0byBhdm9pZCBleGNlc3NpdmUgdG9wIHNwYWNpbmdcclxuICAgICAgcGFkZGluZzogYCR7TWF0aC5taW4oMiwgZmlyc3RCYXNlbGluZU9mZnNldCAqIDAuMil9cHggJHtmcmFtZU1ldHJpY3MuaW5zZXRzLnJpZ2h0fXB4ICR7ZnJhbWVNZXRyaWNzLmluc2V0cy5ib3R0b219cHggJHtmcmFtZU1ldHJpY3MuaW5zZXRzLmxlZnR9cHhgLFxyXG4gICAgICBtYXJnaW46IDAsXHJcbiAgICAgIFxyXG4gICAgICAvLyBPdmVyZmxvdyBjb250cm9sXHJcbiAgICAgIHdpZHRoOiBgJHtmcmFtZU1ldHJpY3MuY29udGVudEFyZWEud2lkdGh9cHhgLFxyXG4gICAgICBoZWlnaHQ6IGAke2ZyYW1lTWV0cmljcy5jb250ZW50QXJlYS5oZWlnaHR9cHhgLFxyXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG4gICAgICBcclxuICAgICAgLy8gVGV4dCBsYXlvdXQgb3B0aW1pemF0aW9uXHJcbiAgICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnLFxyXG4gICAgICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnLFxyXG4gICAgICBvdmVyZmxvd1dyYXA6ICdicmVhay13b3JkJyxcclxuICAgICAgd29yZEJyZWFrOiAnbm9ybWFsJyxcclxuICAgICAgXHJcbiAgICAgIC8vIEluRGVzaWduLXNwZWNpZmljIGFkanVzdG1lbnRzXHJcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICB0b3A6IGZyYW1lTWV0cmljcy5oYXNJbnNldHMgPyBgJHtmcmFtZU1ldHJpY3Mub2Zmc2V0WX1weGAgOiAnMCcsXHJcbiAgICAgIGxlZnQ6IGZyYW1lTWV0cmljcy5oYXNJbnNldHMgPyBgJHtmcmFtZU1ldHJpY3Mub2Zmc2V0WH1weGAgOiAnMCcsXHJcbiAgICAgIFxyXG4gICAgICAvLyBEZWJ1ZyBpbmZvIChjYW4gYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uKVxyXG4gICAgICAnLS1pbmRlc2lnbi1sZWFkaW5nJzogaW5EZXNpZ25Gb3JtYXR0aW5nLmxlYWRpbmcsXHJcbiAgICAgICctLWluZGVzaWduLWxlYWRpbmctdHlwZSc6IGluRGVzaWduRm9ybWF0dGluZy5sZWFkaW5nVHlwZSxcclxuICAgICAgJy0tY3NzLWxpbmUtaGVpZ2h0JzogbGluZUhlaWdodEluZm8uY3NzTGluZUhlaWdodCxcclxuICAgICAgJy0tZmlyc3QtYmFzZWxpbmUtb2Zmc2V0JzogYCR7Zmlyc3RCYXNlbGluZU9mZnNldH1weGBcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgZm9yIHVzZSBpbiBvdGhlciBtb2R1bGVzXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gSW5EZXNpZ25UZXh0TWV0cmljcztcclxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gIHdpbmRvdy5JbkRlc2lnblRleHRNZXRyaWNzID0gSW5EZXNpZ25UZXh0TWV0cmljcztcclxufSAiXSwibmFtZXMiOlsiSW5EZXNpZ25UZXh0TWV0cmljcyIsImNhbGN1bGF0ZVRleHRGcmFtZUluc2V0cyIsInRleHRGcmFtZSIsInRleHRGcmFtZVByZWZzIiwiREVGQVVMVF9JTlNFVFMiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJpbnNldHMiLCJpbnNldFNwYWNpbmciLCJ0ZXh0SW5zZXRzIiwiY29udGVudEFyZWEiLCJ3aWR0aCIsIk1hdGgiLCJtYXgiLCJwb3NpdGlvbiIsImhlaWdodCIsIm9mZnNldFgiLCJvZmZzZXRZIiwib3JpZ2luYWxGcmFtZSIsImhhc0luc2V0cyIsImNvbnZlcnRMZWFkaW5nVG9DU1MiLCJsZWFkaW5nIiwiZm9udFNpemUiLCJsZWFkaW5nVHlwZSIsImNzc0xpbmVIZWlnaHQiLCJsaW5lSGVpZ2h0UHgiLCJwZXJjZW50YWdlIiwicGFyc2VGbG9hdCIsInJvdW5kIiwib3JpZ2luYWxMZWFkaW5nIiwiY2FsY3VsYXRlRmlyc3RCYXNlbGluZU9mZnNldCIsImZpcnN0QmFzZWxpbmVPZmZzZXQiLCJsaW5lSGVpZ2h0IiwibWVhc3VyZVRleHRQcmVjaXNlbHkiLCJ0ZXh0IiwidGV4dFN0eWxlcyIsImZyYW1lTWV0cmljcyIsInRyaW0iLCJ0ZXh0V2lkdGgiLCJ0ZXh0SGVpZ2h0IiwibGluZUNvdW50IiwibGluZXMiLCJ3aWxsT3ZlcmZsb3ciLCJmaXRzIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImZvbnRGYW1pbHkiLCJmb250V2VpZ2h0IiwiZm9udFN0eWxlIiwiZm9udCIsInRyYWNraW5nIiwidHJhY2tpbmdBZGp1c3RtZW50IiwiZWZmZWN0aXZlV2lkdGgiLCJhYnMiLCJ3b3JkcyIsInJlcGxhY2UiLCJzcGxpdCIsImZpbHRlciIsIndvcmQiLCJsZW5ndGgiLCJjdXJyZW50TGluZSIsImN1cnJlbnRMaW5lV2lkdGgiLCJzcGFjZVdpZHRoIiwibWVhc3VyZVRleHQiLCJpIiwicHVzaCIsInRlc3QiLCJ3b3JkV2lkdGgiLCJ3b3JkV2l0aFNwYWNlV2lkdGgiLCJsaW5lSGVpZ2h0SW5mbyIsIm1hcCIsImxpbmUiLCJhdmFpbGFibGVIZWlnaHQiLCJvdmVyZmxvd0Ftb3VudCIsIm1ldHJpY3MiLCJjYWxjdWxhdGVPcHRpbWFsRm9udFNpemUiLCJ0ZXh0TWVhc3VyZW1lbnQiLCJvcmlnaW5hbFN0eWxlcyIsIm1heFJlZHVjdGlvbiIsIm9yaWdpbmFsRm9udFNpemUiLCJvdmVyZmxvd1JhdGlvIiwiY29uc29sZSIsImxvZyIsInNjYWxlRmFjdG9yIiwibWluQWxsb3dlZFNjYWxlIiwiZmluYWxTY2FsZUZhY3RvciIsIm5ld0ZvbnRTaXplIiwicmVxdWlyZWRTY2FsZSIsIndpbGxTdGlsbE92ZXJmbG93IiwiYWRqdXN0ZWRTdHlsZXMiLCJhZGp1c3RtZW50VHlwZSIsInN0aWxsT3ZlcmZsb3dzIiwicmVkdWN0aW9uQXBwbGllZCIsInRvRml4ZWQiLCJnZW5lcmF0ZUluRGVzaWduQ1NTIiwiaW5EZXNpZ25Gb3JtYXR0aW5nIiwibGV0dGVyU3BhY2luZyIsInRleHRBbGlnbiIsImNvbG9yIiwicGFkZGluZyIsIm1pbiIsIm1hcmdpbiIsIm92ZXJmbG93IiwiYm94U2l6aW5nIiwid2hpdGVTcGFjZSIsIndvcmRXcmFwIiwib3ZlcmZsb3dXcmFwIiwid29yZEJyZWFrIiwibW9kdWxlIiwiZXhwb3J0cyIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/utils/InDesignTextMetrics.js\n"));

/***/ })

});