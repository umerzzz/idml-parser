"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StyleParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StyleParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StyleParser {\n    // ADDED: Method to set document units for typography conversion\n    setDocumentUnits(units) {\n        this.documentUnits = units;\n        console.log(\"\\uD83D\\uDCD0 StyleParser: Set document units to\", units);\n    }\n    // ADDED: Method to convert typography measurements to pixels\n    convertTypographyToPixels(value) {\n        if (typeof value !== \"number\" || isNaN(value) || !this.unitConverter || !this.documentUnits) {\n            return value;\n        }\n        // Only convert if we have a supported unit and it's not already pixels\n        if (this.unitConverter.isSupportedUnit(this.documentUnits)) {\n            const convertedValue = this.unitConverter.toPixels(value, this.documentUnits);\n            console.log(\"\\uD83D\\uDCD0 Converted typography: \".concat(value, \" \").concat(this.documentUnits, \" → \").concat(convertedValue, \" px\"));\n            return convertedValue;\n        }\n        return value;\n    }\n    // ADDED: Method to convert an entire style object's measurements to pixels\n    convertStyleMeasurementsToPixels(style) {\n        if (!this.unitConverter || !this.documentUnits) {\n            return style;\n        }\n        const convertedStyle = {\n            ...style\n        };\n        // Convert measurements that need pixel conversion\n        const measurementFields = [\n            \"leftIndent\",\n            \"rightIndent\",\n            \"firstLineIndent\",\n            \"spaceBefore\",\n            \"spaceAfter\",\n            \"tracking\",\n            \"kerning\"\n        ];\n        measurementFields.forEach((field)=>{\n            if (typeof convertedStyle[field] === \"number\") {\n                convertedStyle[field] = this.convertTypographyToPixels(convertedStyle[field]);\n            }\n        });\n        // Convert leading if it's a numeric value\n        if (typeof convertedStyle.leading === \"number\") {\n            convertedStyle.leading = this.convertTypographyToPixels(convertedStyle.leading);\n        }\n        return convertedStyle;\n    }\n    async parseResourceFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCCB Parsing resource: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const resourceName = path.basename(fileName, \".xml\");\n            // Handle different resource types\n            if (fileName.includes(\"Styles.xml\")) {\n                await this.extractStyles(parsed);\n            } else if (fileName.includes(\"Fonts.xml\")) {\n                await this.extractFonts(parsed);\n            } else if (fileName.includes(\"Graphic.xml\")) {\n                await this.extractGraphics(parsed);\n            } else if (fileName.includes(\"Preferences.xml\")) {\n                await this.extractPreferences(parsed);\n            }\n            console.log(\"✅ Resource \".concat(resourceName, \" parsed\"));\n        } catch (error) {\n            console.error(\"❌ Error parsing \".concat(fileName, \":\"), error.message);\n        }\n    }\n    async extractStyles(stylesData) {\n        console.log(\"Extracting styles...\");\n        const styles = stylesData.Styles || stylesData;\n        // Extract Paragraph Styles\n        if (styles.RootParagraphStyleGroup) {\n            this.extractParagraphStyles(styles.RootParagraphStyleGroup);\n        }\n        // Extract Character Styles\n        if (styles.RootCharacterStyleGroup) {\n            this.extractCharacterStyles(styles.RootCharacterStyleGroup);\n        }\n    }\n    extractParagraphStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.ParagraphStyle) {\n                const styles = Array.isArray(group.ParagraphStyle) ? group.ParagraphStyle : [\n                    group.ParagraphStyle\n                ];\n                styles.forEach((style)=>{\n                    // CRITICAL: Extract font reference from multiple possible locations\n                    const fontRef = this.extractFontFromStyle(style);\n                    // ENHANCED: Process leading with proper InDesign logic\n                    const fontSize = parseFloat(style[\"@_PointSize\"]) || 12;\n                    const rawLeading = style[\"@_Leading\"];\n                    const processedLeading = this.processLeadingValue(rawLeading, fontSize);\n                    // FIXED: Extract raw typography measurements for conversion\n                    const rawLeftIndent = parseFloat(style[\"@_LeftIndent\"]) || 0;\n                    const rawRightIndent = parseFloat(style[\"@_RightIndent\"]) || 0;\n                    const rawFirstLineIndent = parseFloat(style[\"@_FirstLineIndent\"]) || 0;\n                    const rawSpaceBefore = parseFloat(style[\"@_SpaceBefore\"]) || 0;\n                    const rawSpaceAfter = parseFloat(style[\"@_SpaceAfter\"]) || 0;\n                    const rawTracking = parseFloat(style[\"@_Tracking\"]) || 0;\n                    const rawKerning = parseFloat(style[\"@_Kerning\"]) || 0;\n                    // FIXED: Create base style object with raw values\n                    const baseStyle = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: fontSize,\n                        leading: processedLeading,\n                        leadingType: this.determineLeadingType(rawLeading),\n                        effectiveLineHeight: this.calculateEffectiveLineHeight(processedLeading, fontSize),\n                        alignment: style[\"@_Justification\"] || \"LeftAlign\",\n                        // Raw measurements (will be converted to pixels)\n                        leftIndent: rawLeftIndent,\n                        rightIndent: rawRightIndent,\n                        firstLineIndent: rawFirstLineIndent,\n                        spaceBefore: rawSpaceBefore,\n                        spaceAfter: rawSpaceAfter,\n                        tracking: rawTracking,\n                        kerning: rawKerning,\n                        // Store original values for reference\n                        originalLeftIndent: rawLeftIndent,\n                        originalRightIndent: rawRightIndent,\n                        originalFirstLineIndent: rawFirstLineIndent,\n                        originalSpaceBefore: rawSpaceBefore,\n                        originalSpaceAfter: rawSpaceAfter,\n                        originalTracking: rawTracking,\n                        originalKerning: rawKerning,\n                        horizontalScale: parseFloat(style[\"@_HorizontalScale\"]) || 100,\n                        verticalScale: parseFloat(style[\"@_VerticalScale\"]) || 100,\n                        // ENHANCED: Use the new extraction method\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || \"Color/Black\",\n                        rawStyle: style\n                    };\n                    // FIXED: Apply unit conversion to create pixel-converted style\n                    this.styles.paragraph[style[\"@_Self\"]] = this.convertStyleMeasurementsToPixels(baseStyle);\n                    console.log(\"✅ Paragraph Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.ParagraphStyleGroup) {\n                const subGroups = Array.isArray(group.ParagraphStyleGroup) ? group.ParagraphStyleGroup : [\n                    group.ParagraphStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    extractFontFromStyle(style) {\n        // Try direct attributes first\n        let fontRef = style[\"@_AppliedFont\"] || style[\"@_FontFamily\"] || style[\"@_Font\"] || \"\";\n        // If not found, try Properties nested structure\n        if (!fontRef && style.Properties) {\n            if (style.Properties.AppliedFont) {\n                fontRef = style.Properties.AppliedFont[\"#text\"] || style.Properties.AppliedFont || \"\";\n            }\n            // Also try other property variations\n            if (!fontRef && style.Properties.FontFamily) {\n                fontRef = style.Properties.FontFamily[\"#text\"] || style.Properties.FontFamily || \"\";\n            }\n        }\n        return fontRef || \"\";\n    }\n    extractCharacterStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.CharacterStyle) {\n                const styles = Array.isArray(group.CharacterStyle) ? group.CharacterStyle : [\n                    group.CharacterStyle\n                ];\n                styles.forEach((style)=>{\n                    const fontRef = this.extractFontFromStyle(style);\n                    this.styles.character[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: parseFloat(style[\"@_PointSize\"]) || null,\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || null,\n                        strokeColor: style[\"@_StrokeColor\"] || null,\n                        rawStyle: style\n                    };\n                    console.log(\"✅ Character Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.CharacterStyleGroup) {\n                const subGroups = Array.isArray(group.CharacterStyleGroup) ? group.CharacterStyleGroup : [\n                    group.CharacterStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    async extractFonts(fontsData) {\n        console.log(\"Extracting fonts with enhanced mapping...\");\n        const fonts = fontsData.Fonts || fontsData;\n        this.resources.fonts = {};\n        this.fontMap = new Map(); // Global font lookup map\n        if (fonts.FontFamily) {\n            const fontFamilies = Array.isArray(fonts.FontFamily) ? fonts.FontFamily : [\n                fonts.FontFamily\n            ];\n            fontFamilies.forEach((family)=>{\n                const familyInfo = {\n                    self: family[\"@_Self\"],\n                    name: family[\"@_Name\"] || \"\",\n                    fonts: []\n                };\n                if (family.Font) {\n                    const fontList = Array.isArray(family.Font) ? family.Font : [\n                        family.Font\n                    ];\n                    fontList.forEach((font)=>{\n                        const fontInfo = {\n                            self: font[\"@_Self\"],\n                            fontFamily: font[\"@_FontFamily\"] || familyInfo.name,\n                            name: font[\"@_Name\"] || \"\",\n                            postScriptName: font[\"@_PostScriptName\"] || \"\",\n                            status: font[\"@_Status\"] || \"Unknown\",\n                            fontStyleName: font[\"@_FontStyleName\"] || \"Regular\"\n                        };\n                        familyInfo.fonts.push(fontInfo);\n                        // Create multiple lookup entries for this font\n                        this.fontMap.set(font[\"@_Self\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_PostScriptName\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_Name\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_FontFamily\"], familyInfo.name);\n                        console.log(\"Font mapping: \".concat(font[\"@_Self\"], \" -> \").concat(familyInfo.name));\n                    });\n                }\n                this.resources.fonts[family[\"@_Self\"]] = familyInfo;\n            });\n        }\n        console.log(\"✅ Fonts extracted: \".concat(Object.keys(this.resources.fonts).length, \" families\"));\n        console.log(\"Font map entries: \".concat(this.fontMap.size));\n    }\n    async extractGraphics(graphicsData) {\n        console.log(\"Extracting graphics and colors...\");\n        const graphics = graphicsData.Graphic || graphicsData;\n        this.resources.colors = {};\n        this.resources.gradients = {};\n        // Extract Colors\n        if (graphics.Color) {\n            const colors = Array.isArray(graphics.Color) ? graphics.Color : [\n                graphics.Color\n            ];\n            colors.forEach((color)=>{\n                // Extract channel values\n                const cyan = parseFloat(color[\"@_Cyan\"]) || 0;\n                const magenta = parseFloat(color[\"@_Magenta\"]) || 0;\n                const yellow = parseFloat(color[\"@_Yellow\"]) || 0;\n                const black = parseFloat(color[\"@_Black\"]) || 0;\n                const red = parseFloat(color[\"@_Red\"]) || 0;\n                const green = parseFloat(color[\"@_Green\"]) || 0;\n                const blue = parseFloat(color[\"@_Blue\"]) || 0;\n                // Fallback: If no CMYK or RGB, but ColorValue exists, parse as RGB\n                let fallbackRGB = null;\n                if (cyan === 0 && magenta === 0 && yellow === 0 && black === 0 && red === 0 && green === 0 && blue === 0 && color[\"@_ColorValue\"]) {\n                    // ColorValue is usually a space-separated RGB triplet, e.g. \"255 140 0\"\n                    const rgbParts = color[\"@_ColorValue\"].split(/\\s+/).map(Number);\n                    if (rgbParts.length === 3 && rgbParts.every((v)=>!isNaN(v))) {\n                        fallbackRGB = {\n                            red: rgbParts[0],\n                            green: rgbParts[1],\n                            blue: rgbParts[2]\n                        };\n                    }\n                }\n                this.resources.colors[color[\"@_Self\"]] = {\n                    self: color[\"@_Self\"],\n                    name: color[\"@_Name\"] || \"\",\n                    model: color[\"@_Model\"] || \"Process\",\n                    space: color[\"@_Space\"] || \"CMYK\",\n                    cyan,\n                    magenta,\n                    yellow,\n                    black,\n                    red: fallbackRGB ? fallbackRGB.red : red,\n                    green: fallbackRGB ? fallbackRGB.green : green,\n                    blue: fallbackRGB ? fallbackRGB.blue : blue\n                };\n            });\n        }\n        // Extract Gradients\n        if (graphics.Gradient) {\n            const gradients = Array.isArray(graphics.Gradient) ? graphics.Gradient : [\n                graphics.Gradient\n            ];\n            gradients.forEach((gradient)=>{\n                this.resources.gradients[gradient[\"@_Self\"]] = {\n                    self: gradient[\"@_Self\"],\n                    name: gradient[\"@_Name\"] || \"\",\n                    type: gradient[\"@_Type\"] || \"Linear\",\n                    gradientStops: this.extractGradientStops(gradient)\n                };\n            });\n        }\n    }\n    extractGradientStops(gradient) {\n        const stops = [];\n        if (gradient.GradientStop) {\n            const stopList = Array.isArray(gradient.GradientStop) ? gradient.GradientStop : [\n                gradient.GradientStop\n            ];\n            stopList.forEach((stop)=>{\n                stops.push({\n                    self: stop[\"@_Self\"],\n                    stopColor: stop[\"@_StopColor\"] || \"\",\n                    location: parseFloat(stop[\"@_Location\"]) || 0,\n                    midpoint: parseFloat(stop[\"@_Midpoint\"]) || 50\n                });\n            });\n        }\n        return stops;\n    }\n    async extractPreferences(preferencesData) {\n        console.log(\"Extracting document preferences...\");\n        const prefs = preferencesData.Preferences || preferencesData;\n        // Extract various document preferences\n        this.documentInfo = {\n            preferences: {\n                documentPreferences: this.extractDocumentPrefs(prefs.DocumentPreference),\n                viewPreferences: this.extractViewPrefs(prefs.ViewPreference),\n                guidePreferences: this.extractGuidePrefs(prefs.GuidePreference),\n                gridPreferences: this.extractGridPrefs(prefs.GridPreference),\n                marginPreferences: this.extractMarginPrefs(prefs.MarginPreference),\n                columnPreferences: this.extractColumnPrefs(prefs.ColumnPreference)\n            }\n        };\n    }\n    extractDocumentPrefs(docPref) {\n        if (!docPref) return {};\n        return {\n            pageWidth: parseFloat(docPref[\"@_PageWidth\"]) || 0,\n            pageHeight: parseFloat(docPref[\"@_PageHeight\"]) || 0,\n            left: parseFloat(docPref[\"@_Left\"]) || 0,\n            top: parseFloat(docPref[\"@_Top\"]) || 0,\n            right: parseFloat(docPref[\"@_Right\"]) || 0,\n            bottom: parseFloat(docPref[\"@_Bottom\"]) || 0,\n            columnCount: parseInt(docPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(docPref[\"@_ColumnGutter\"]) || 0,\n            facingPages: docPref[\"@_FacingPages\"] === true,\n            allowPageShuffle: docPref[\"@_AllowPageShuffle\"] !== false,\n            slugBleedType: docPref[\"@_SlugBleedType\"] || \"None\",\n            documentBleedTopOffset: parseFloat(docPref[\"@_DocumentBleedTopOffset\"]) || 0,\n            documentBleedBottomOffset: parseFloat(docPref[\"@_DocumentBleedBottomOffset\"]) || 0,\n            documentBleedInsideOrLeftOffset: parseFloat(docPref[\"@_DocumentBleedInsideOrLeftOffset\"]) || 0,\n            documentBleedOutsideOrRightOffset: parseFloat(docPref[\"@_DocumentBleedOutsideOrRightOffset\"]) || 0\n        };\n    }\n    extractViewPrefs(viewPref) {\n        if (!viewPref) return {};\n        return {\n            horizontalMeasurementUnits: viewPref[\"@_HorizontalMeasurementUnits\"] || \"Points\",\n            verticalMeasurementUnits: viewPref[\"@_VerticalMeasurementUnits\"] || \"Points\",\n            rulerOrigin: viewPref[\"@_RulerOrigin\"] || \"SpreadOrigin\",\n            showRulers: viewPref[\"@_ShowRulers\"] !== false\n        };\n    }\n    extractGuidePrefs(guidePref) {\n        if (!guidePref) return {};\n        return {\n            rulerGuideColor: guidePref[\"@_RulerGuideColor\"] || \"Green\",\n            guidesInBack: guidePref[\"@_GuidesInBack\"] === true,\n            guidesLocked: guidePref[\"@_GuidesLocked\"] === true,\n            guidesShown: guidePref[\"@_GuidesShown\"] !== false,\n            guidesSnapto: guidePref[\"@_GuidesSnapto\"] !== false\n        };\n    }\n    extractGridPrefs(gridPref) {\n        if (!gridPref) return {};\n        return {\n            baselineStart: parseFloat(gridPref[\"@_BaselineStart\"]) || 0,\n            baselineDivision: parseFloat(gridPref[\"@_BaselineDivision\"]) || 12,\n            baselineShown: gridPref[\"@_BaselineShown\"] === true,\n            baselineSnapto: gridPref[\"@_BaselineSnapto\"] === true,\n            documentGridShown: gridPref[\"@_DocumentGridShown\"] === true,\n            documentGridSnapto: gridPref[\"@_DocumentGridSnapto\"] === true\n        };\n    }\n    extractMarginPrefs(marginPref) {\n        if (!marginPref) return {};\n        return {\n            top: parseFloat(marginPref[\"@_Top\"]) || 0,\n            bottom: parseFloat(marginPref[\"@_Bottom\"]) || 0,\n            left: parseFloat(marginPref[\"@_Left\"]) || 0,\n            right: parseFloat(marginPref[\"@_Right\"]) || 0,\n            columnCount: parseInt(marginPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(marginPref[\"@_ColumnGutter\"]) || 0\n        };\n    }\n    extractColumnPrefs(columnPref) {\n        if (!columnPref) return {};\n        return {\n            textColumnCount: parseInt(columnPref[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(columnPref[\"@_TextColumnGutter\"]) || 0\n        };\n    }\n    resolveStyleFormatting(formatting) {\n        const resolved = {\n            ...formatting\n        };\n        // DEBUG: Check if formatting is being applied (generic check)\n        const hasAnyFormatting = formatting.paragraphStyle || formatting.characterStyle || formatting.fontStyle || formatting.fontReference || formatting.fontSize;\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Input:\", {\n                paragraphStyle: formatting.paragraphStyle,\n                characterStyle: formatting.characterStyle,\n                directFontStyle: formatting.fontStyle,\n                directFontRef: formatting.fontReference,\n                directFontSize: formatting.fontSize\n            });\n        }\n        // Resolve paragraph style (base layer)\n        if (formatting.paragraphStyle && this.styles.paragraph[formatting.paragraphStyle]) {\n            const pStyle = this.styles.paragraph[formatting.paragraphStyle];\n            if (!resolved.fontSize && pStyle.pointSize) resolved.fontSize = pStyle.pointSize;\n            if (!resolved.fillColor && pStyle.fillColor) resolved.fillColor = pStyle.fillColor;\n            // CRITICAL FIX: Always inherit paragraph alignment unless explicitly overridden\n            if (pStyle.alignment) resolved.alignment = pStyle.alignment;\n            if (!resolved.fontStyle && pStyle.fontStyle) {\n                resolved.fontStyle = pStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from paragraph style: \"'.concat(pStyle.fontStyle, '\"'));\n                }\n            }\n            // CRITICAL: Resolve font from paragraph style\n            if (!resolved.fontFamily && pStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(pStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from paragraph style: \".concat(pStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n            // Add other paragraph properties with enhanced leading support\n            resolved.leading = pStyle.leading;\n            resolved.leadingType = pStyle.leadingType;\n            resolved.effectiveLineHeight = pStyle.effectiveLineHeight;\n            resolved.leftIndent = pStyle.leftIndent;\n            resolved.rightIndent = pStyle.rightIndent;\n            resolved.firstLineIndent = pStyle.firstLineIndent;\n            resolved.spaceBefore = pStyle.spaceBefore;\n            resolved.spaceAfter = pStyle.spaceAfter;\n            resolved.tracking = pStyle.tracking;\n            resolved.kerning = pStyle.kerning;\n        }\n        // Resolve character style (override layer)\n        if (formatting.characterStyle && this.styles.character[formatting.characterStyle]) {\n            const cStyle = this.styles.character[formatting.characterStyle];\n            if (cStyle.pointSize) resolved.fontSize = cStyle.pointSize;\n            if (cStyle.fillColor) resolved.fillColor = cStyle.fillColor;\n            if (cStyle.fontStyle) {\n                resolved.fontStyle = cStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from character style: \"'.concat(cStyle.fontStyle, '\"'));\n                }\n            }\n            if (cStyle.strokeColor) resolved.strokeColor = cStyle.strokeColor;\n            // Include leading information from character style\n            if (cStyle.leading) resolved.leading = cStyle.leading;\n            if (cStyle.leadingType) resolved.leadingType = cStyle.leadingType;\n            if (cStyle.effectiveLineHeight) resolved.effectiveLineHeight = cStyle.effectiveLineHeight;\n            // CRITICAL: Character style font overrides paragraph style\n            if (cStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(cStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from character style: \".concat(cStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n        }\n        // Apply direct formatting (highest priority)\n        if (formatting.fontReference) {\n            resolved.fontFamily = this.resolveFontReference(formatting.fontReference);\n            if (hasAnyFormatting) {\n                console.log(\"   Font from direct formatting: \".concat(formatting.fontReference, \" -> \").concat(resolved.fontFamily));\n            }\n        }\n        // CRITICAL: Apply direct fontStyle if provided (this might be the issue)\n        if (formatting.fontStyle) {\n            resolved.fontStyle = formatting.fontStyle;\n            if (hasAnyFormatting) {\n                console.log('   FontStyle from direct formatting: \"'.concat(formatting.fontStyle, '\"'));\n            }\n        }\n        // Apply direct leading information (highest priority)\n        if (formatting.leading !== undefined) resolved.leading = formatting.leading;\n        if (formatting.leadingType) resolved.leadingType = formatting.leadingType;\n        if (formatting.effectiveLineHeight) resolved.effectiveLineHeight = formatting.effectiveLineHeight;\n        // Apply other direct formatting attributes\n        if (formatting.fontSize) resolved.fontSize = formatting.fontSize;\n        if (formatting.tracking) resolved.tracking = formatting.tracking;\n        if (formatting.kerning) resolved.kerning = formatting.kerning;\n        // CRITICAL FIX: Apply direct alignment if explicitly specified (overrides paragraph alignment)\n        if (formatting.alignment) {\n            resolved.alignment = formatting.alignment;\n            if (hasAnyFormatting) {\n                console.log('   Alignment from direct formatting: \"'.concat(formatting.alignment, '\"'));\n            }\n        }\n        // FIXED: Ensure fontStyle defaults to Regular/normal if not set\n        if (!resolved.fontStyle || resolved.fontStyle === \"\") {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log('   FontStyle defaulted to: \"Regular\"');\n            }\n        }\n        // ADDITIONAL FIX: If no styles were applied from any source, ensure clean defaults\n        if (!formatting.paragraphStyle && !formatting.characterStyle && !formatting.fontStyle && !formatting.fontReference) {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log(\"   No source styles found - ensuring clean defaults\");\n            }\n        }\n        // Final fallback\n        if (!resolved.fontFamily || resolved.fontFamily === \"\") {\n            resolved.fontFamily = this.getDefaultFont();\n            if (hasAnyFormatting) {\n                console.log(\"   Using fallback font: \".concat(resolved.fontFamily));\n            }\n        }\n        // Ensure line height is calculated if not explicitly set\n        if (!resolved.effectiveLineHeight && resolved.fontSize && resolved.leading) {\n            resolved.effectiveLineHeight = this.calculateEffectiveLineHeight(resolved.leading, resolved.fontSize);\n        }\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Final Output:\", {\n                fontSize: resolved.fontSize,\n                fontFamily: resolved.fontFamily,\n                fontStyle: resolved.fontStyle,\n                fillColor: resolved.fillColor,\n                leading: resolved.leading,\n                effectiveLineHeight: resolved.effectiveLineHeight\n            });\n        }\n        return resolved;\n    }\n    resolveFontReference(fontRef) {\n        if (!fontRef || fontRef === \"\") {\n            console.log(\"Empty font reference, using fallback\");\n            return this.getDefaultFont();\n        }\n        // Try direct lookup in font map\n        if (this.fontMap && this.fontMap.has(fontRef)) {\n            const resolvedFont = this.fontMap.get(fontRef);\n            console.log('Font resolved: \"'.concat(fontRef, '\" -> \"').concat(resolvedFont, '\"'));\n            return resolvedFont;\n        }\n        // Try partial matching for font families\n        if (this.resources.fonts) {\n            for (const [familyId, familyInfo] of Object.entries(this.resources.fonts)){\n                // Check family name match\n                if (familyInfo.name && (familyInfo.name.toLowerCase().includes(fontRef.toLowerCase()) || fontRef.toLowerCase().includes(familyInfo.name.toLowerCase()))) {\n                    console.log('Font partially matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                    return familyInfo.name;\n                }\n                // Check individual font matches\n                if (familyInfo.fonts) {\n                    for (const font of familyInfo.fonts){\n                        if (font.self === fontRef || font.postScriptName === fontRef || font.name === fontRef) {\n                            console.log('Font exactly matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                            return familyInfo.name;\n                        }\n                    }\n                }\n            }\n        }\n        console.log('Font not found: \"'.concat(fontRef, '\", using fallback'));\n        return this.getDefaultFont() || fontRef;\n    }\n    getDefaultFont() {\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFamily = Object.values(this.resources.fonts)[0];\n            return firstFamily.name || \"Arial\";\n        }\n        return \"Arial\";\n    }\n    inferFontFromContext() {\n        // If we have font definitions but no explicit references,\n        // return the first available font as a fallback\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFontFamily = Object.values(this.resources.fonts)[0];\n            return firstFontFamily.name;\n        }\n        return null;\n    }\n    getStoryStyleSummary(story) {\n        var _story_content_formattedContent, _story_content;\n        const summary = {\n            fontSize: null,\n            fontFamily: null,\n            alignment: null,\n            fillColor: null,\n            fontStyle: null,\n            leading: null,\n            leadingType: null,\n            effectiveLineHeight: null,\n            tracking: null,\n            kerning: null\n        };\n        // Get the most common or first formatting values\n        if (((_story_content = story.content) === null || _story_content === void 0 ? void 0 : (_story_content_formattedContent = _story_content.formattedContent) === null || _story_content_formattedContent === void 0 ? void 0 : _story_content_formattedContent.length) > 0) {\n            const firstFormatted = story.content.formattedContent.find((item)=>item.formatting && !item.formatting.isBreak);\n            if (firstFormatted === null || firstFormatted === void 0 ? void 0 : firstFormatted.formatting) {\n                const fmt = firstFormatted.formatting;\n                summary.fontSize = fmt.fontSize;\n                summary.fontFamily = fmt.fontFamily;\n                summary.alignment = fmt.alignment;\n                summary.fillColor = fmt.fillColor;\n                summary.fontStyle = fmt.fontStyle;\n                summary.leading = fmt.leading;\n                summary.leadingType = fmt.leadingType;\n                summary.effectiveLineHeight = fmt.effectiveLineHeight;\n                summary.tracking = fmt.tracking;\n                summary.kerning = fmt.kerning;\n            }\n        }\n        return summary;\n    }\n    // NEW: Process leading values with InDesign-specific logic (shared with StoryParser)\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = parseFloat(rawLeading);\n        if (!isNaN(numericLeading)) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (!isNaN(parseFloat(rawLeading))) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(leading, fontSize) {\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\" && fontSize) {\n            // Convert points to CSS line-height ratio\n            return Math.max(0.8, leading / fontSize); // Ensure minimum line height\n        }\n        return 1.2; // Fallback\n    }\n    getStyles() {\n        return this.styles;\n    }\n    getResources() {\n        return this.resources;\n    }\n    getFontMap() {\n        return this.fontMap;\n    }\n    // Add methods to return style and font definitions for debug\n    getParagraphStyles() {\n        return this.styles.paragraph;\n    }\n    getCharacterStyles() {\n        return this.styles.character;\n    }\n    getFontDefinitions() {\n        // Prefer plain object for debug output\n        if (this.resources && this.resources.fonts) {\n            return this.resources.fonts;\n        }\n        // Fallback: convert fontMap to object\n        if (this.fontMap && typeof this.fontMap.entries === \"function\") {\n            return Object.fromEntries(this.fontMap.entries());\n        }\n        return {};\n    }\n    // FIXED: Add method to access document preferences including ViewPreferences\n    getDocumentInfo() {\n        return this.documentInfo;\n    }\n    constructor(unitConverter = null){\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n        this.resources = {\n            fonts: {},\n            colors: {},\n            gradients: {}\n        };\n        this.fontMap = new Map(); // Global font lookup map\n        this.unitConverter = unitConverter; // ADDED: Unit converter for typography measurements\n        this.documentUnits = null; // Will be set from document units\n    }\n}\nmodule.exports = StyleParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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X0UvLi9saWIvcGFyc2Vycy9TdHlsZVBhcnNlci5qcz82OWFjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9JRE1MVXRpbHNcIik7XG5cbmNsYXNzIFN0eWxlUGFyc2VyIHtcbiAgY29uc3RydWN0b3IodW5pdENvbnZlcnRlciA9IG51bGwpIHtcbiAgICB0aGlzLnN0eWxlcyA9IHtcbiAgICAgIHBhcmFncmFwaDoge30sXG4gICAgICBjaGFyYWN0ZXI6IHt9LFxuICAgICAgb2JqZWN0OiB7fSxcbiAgICAgIHRhYmxlOiB7fSxcbiAgICAgIGNlbGw6IHt9LFxuICAgIH07XG4gICAgdGhpcy5yZXNvdXJjZXMgPSB7XG4gICAgICBmb250czoge30sXG4gICAgICBjb2xvcnM6IHt9LFxuICAgICAgZ3JhZGllbnRzOiB7fSxcbiAgICB9O1xuICAgIHRoaXMuZm9udE1hcCA9IG5ldyBNYXAoKTsgLy8gR2xvYmFsIGZvbnQgbG9va3VwIG1hcFxuICAgIHRoaXMudW5pdENvbnZlcnRlciA9IHVuaXRDb252ZXJ0ZXI7IC8vIEFEREVEOiBVbml0IGNvbnZlcnRlciBmb3IgdHlwb2dyYXBoeSBtZWFzdXJlbWVudHNcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSBudWxsOyAvLyBXaWxsIGJlIHNldCBmcm9tIGRvY3VtZW50IHVuaXRzXG4gIH1cblxuICAvLyBBRERFRDogTWV0aG9kIHRvIHNldCBkb2N1bWVudCB1bml0cyBmb3IgdHlwb2dyYXBoeSBjb252ZXJzaW9uXG4gIHNldERvY3VtZW50VW5pdHModW5pdHMpIHtcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSB1bml0cztcbiAgICBjb25zb2xlLmxvZyhcIvCfk5AgU3R5bGVQYXJzZXI6IFNldCBkb2N1bWVudCB1bml0cyB0b1wiLCB1bml0cyk7XG4gIH1cblxuICAvLyBBRERFRDogTWV0aG9kIHRvIGNvbnZlcnQgdHlwb2dyYXBoeSBtZWFzdXJlbWVudHMgdG8gcGl4ZWxzXG4gIGNvbnZlcnRUeXBvZ3JhcGh5VG9QaXhlbHModmFsdWUpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgIGlzTmFOKHZhbHVlKSB8fFxuICAgICAgIXRoaXMudW5pdENvbnZlcnRlciB8fFxuICAgICAgIXRoaXMuZG9jdW1lbnRVbml0c1xuICAgICkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIE9ubHkgY29udmVydCBpZiB3ZSBoYXZlIGEgc3VwcG9ydGVkIHVuaXQgYW5kIGl0J3Mgbm90IGFscmVhZHkgcGl4ZWxzXG4gICAgaWYgKHRoaXMudW5pdENvbnZlcnRlci5pc1N1cHBvcnRlZFVuaXQodGhpcy5kb2N1bWVudFVuaXRzKSkge1xuICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSB0aGlzLnVuaXRDb252ZXJ0ZXIudG9QaXhlbHMoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0aGlzLmRvY3VtZW50VW5pdHNcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCfk5AgQ29udmVydGVkIHR5cG9ncmFwaHk6ICR7dmFsdWV9ICR7dGhpcy5kb2N1bWVudFVuaXRzfSDihpIgJHtjb252ZXJ0ZWRWYWx1ZX0gcHhgXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbnZlcnRlZFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gY29udmVydCBhbiBlbnRpcmUgc3R5bGUgb2JqZWN0J3MgbWVhc3VyZW1lbnRzIHRvIHBpeGVsc1xuICBjb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyhzdHlsZSkge1xuICAgIGlmICghdGhpcy51bml0Q29udmVydGVyIHx8ICF0aGlzLmRvY3VtZW50VW5pdHMpIHtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICBjb25zdCBjb252ZXJ0ZWRTdHlsZSA9IHsgLi4uc3R5bGUgfTtcblxuICAgIC8vIENvbnZlcnQgbWVhc3VyZW1lbnRzIHRoYXQgbmVlZCBwaXhlbCBjb252ZXJzaW9uXG4gICAgY29uc3QgbWVhc3VyZW1lbnRGaWVsZHMgPSBbXG4gICAgICBcImxlZnRJbmRlbnRcIixcbiAgICAgIFwicmlnaHRJbmRlbnRcIixcbiAgICAgIFwiZmlyc3RMaW5lSW5kZW50XCIsXG4gICAgICBcInNwYWNlQmVmb3JlXCIsXG4gICAgICBcInNwYWNlQWZ0ZXJcIixcbiAgICAgIFwidHJhY2tpbmdcIixcbiAgICAgIFwia2VybmluZ1wiLFxuICAgIF07XG5cbiAgICBtZWFzdXJlbWVudEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjb252ZXJ0ZWRTdHlsZVtmaWVsZF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29udmVydGVkU3R5bGVbZmllbGRdID0gdGhpcy5jb252ZXJ0VHlwb2dyYXBoeVRvUGl4ZWxzKFxuICAgICAgICAgIGNvbnZlcnRlZFN0eWxlW2ZpZWxkXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ29udmVydCBsZWFkaW5nIGlmIGl0J3MgYSBudW1lcmljIHZhbHVlXG4gICAgaWYgKHR5cGVvZiBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nID0gdGhpcy5jb252ZXJ0VHlwb2dyYXBoeVRvUGl4ZWxzKFxuICAgICAgICBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0ZWRTdHlsZTtcbiAgfVxuXG4gIGFzeW5jIHBhcnNlUmVzb3VyY2VGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpIHtcbiAgICBjb25zb2xlLmxvZyhg8J+TiyBQYXJzaW5nIHJlc291cmNlOiAke2ZpbGVOYW1lfWApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcbiAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUsIFwiLnhtbFwiKTtcblxuICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCByZXNvdXJjZSB0eXBlc1xuICAgICAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKFwiU3R5bGVzLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RTdHlsZXMocGFyc2VkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoXCJGb250cy54bWxcIikpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0Rm9udHMocGFyc2VkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoXCJHcmFwaGljLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RHcmFwaGljcyhwYXJzZWQpO1xuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhcIlByZWZlcmVuY2VzLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RQcmVmZXJlbmNlcyhwYXJzZWQpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFJlc291cmNlICR7cmVzb3VyY2VOYW1lfSBwYXJzZWRgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHBhcnNpbmcgJHtmaWxlTmFtZX06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZXh0cmFjdFN0eWxlcyhzdHlsZXNEYXRhKSB7XG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIHN0eWxlcy4uLlwiKTtcblxuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlc0RhdGEuU3R5bGVzIHx8IHN0eWxlc0RhdGE7XG5cbiAgICAvLyBFeHRyYWN0IFBhcmFncmFwaCBTdHlsZXNcbiAgICBpZiAoc3R5bGVzLlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XG4gICAgICB0aGlzLmV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMoc3R5bGVzLlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwKTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IENoYXJhY3RlciBTdHlsZXNcbiAgICBpZiAoc3R5bGVzLlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwKSB7XG4gICAgICB0aGlzLmV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVzLlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwKTtcbiAgICB9XG4gIH1cblxuICBleHRyYWN0UGFyYWdyYXBoU3R5bGVzKHN0eWxlR3JvdXApIHtcbiAgICBjb25zdCBleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkgPSAoZ3JvdXApID0+IHtcbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZSkge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBBcnJheS5pc0FycmF5KGdyb3VwLlBhcmFncmFwaFN0eWxlKVxuICAgICAgICAgID8gZ3JvdXAuUGFyYWdyYXBoU3R5bGVcbiAgICAgICAgICA6IFtncm91cC5QYXJhZ3JhcGhTdHlsZV07XG5cbiAgICAgICAgc3R5bGVzLmZvckVhY2goKHN0eWxlKSA9PiB7XG4gICAgICAgICAgLy8gQ1JJVElDQUw6IEV4dHJhY3QgZm9udCByZWZlcmVuY2UgZnJvbSBtdWx0aXBsZSBwb3NzaWJsZSBsb2NhdGlvbnNcbiAgICAgICAgICBjb25zdCBmb250UmVmID0gdGhpcy5leHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSk7XG5cbiAgICAgICAgICAvLyBFTkhBTkNFRDogUHJvY2VzcyBsZWFkaW5nIHdpdGggcHJvcGVyIEluRGVzaWduIGxvZ2ljXG4gICAgICAgICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9Qb2ludFNpemVcIl0pIHx8IDEyO1xuICAgICAgICAgIGNvbnN0IHJhd0xlYWRpbmcgPSBzdHlsZVtcIkBfTGVhZGluZ1wiXTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzZWRMZWFkaW5nID0gdGhpcy5wcm9jZXNzTGVhZGluZ1ZhbHVlKFxuICAgICAgICAgICAgcmF3TGVhZGluZyxcbiAgICAgICAgICAgIGZvbnRTaXplXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIEZJWEVEOiBFeHRyYWN0IHJhdyB0eXBvZ3JhcGh5IG1lYXN1cmVtZW50cyBmb3IgY29udmVyc2lvblxuICAgICAgICAgIGNvbnN0IHJhd0xlZnRJbmRlbnQgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9MZWZ0SW5kZW50XCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1JpZ2h0SW5kZW50ID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfUmlnaHRJbmRlbnRcIl0pIHx8IDA7XG4gICAgICAgICAgY29uc3QgcmF3Rmlyc3RMaW5lSW5kZW50ID1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoc3R5bGVbXCJAX0ZpcnN0TGluZUluZGVudFwiXSkgfHwgMDtcbiAgICAgICAgICBjb25zdCByYXdTcGFjZUJlZm9yZSA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1NwYWNlQmVmb3JlXCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1NwYWNlQWZ0ZXIgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9TcGFjZUFmdGVyXCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1RyYWNraW5nID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfVHJhY2tpbmdcIl0pIHx8IDA7XG4gICAgICAgICAgY29uc3QgcmF3S2VybmluZyA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX0tlcm5pbmdcIl0pIHx8IDA7XG5cbiAgICAgICAgICAvLyBGSVhFRDogQ3JlYXRlIGJhc2Ugc3R5bGUgb2JqZWN0IHdpdGggcmF3IHZhbHVlc1xuICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHtcbiAgICAgICAgICAgIHNlbGY6IHN0eWxlW1wiQF9TZWxmXCJdLFxuICAgICAgICAgICAgbmFtZTogc3R5bGVbXCJAX05hbWVcIl0gfHwgXCJcIixcbiAgICAgICAgICAgIGZvbnRTdHlsZTogc3R5bGVbXCJAX0ZvbnRTdHlsZVwiXSB8fCBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgIHBvaW50U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgICBsZWFkaW5nOiBwcm9jZXNzZWRMZWFkaW5nLFxuICAgICAgICAgICAgbGVhZGluZ1R5cGU6IHRoaXMuZGV0ZXJtaW5lTGVhZGluZ1R5cGUocmF3TGVhZGluZyksXG4gICAgICAgICAgICBlZmZlY3RpdmVMaW5lSGVpZ2h0OiB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoXG4gICAgICAgICAgICAgIHByb2Nlc3NlZExlYWRpbmcsXG4gICAgICAgICAgICAgIGZvbnRTaXplXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYWxpZ25tZW50OiBzdHlsZVtcIkBfSnVzdGlmaWNhdGlvblwiXSB8fCBcIkxlZnRBbGlnblwiLFxuXG4gICAgICAgICAgICAvLyBSYXcgbWVhc3VyZW1lbnRzICh3aWxsIGJlIGNvbnZlcnRlZCB0byBwaXhlbHMpXG4gICAgICAgICAgICBsZWZ0SW5kZW50OiByYXdMZWZ0SW5kZW50LFxuICAgICAgICAgICAgcmlnaHRJbmRlbnQ6IHJhd1JpZ2h0SW5kZW50LFxuICAgICAgICAgICAgZmlyc3RMaW5lSW5kZW50OiByYXdGaXJzdExpbmVJbmRlbnQsXG4gICAgICAgICAgICBzcGFjZUJlZm9yZTogcmF3U3BhY2VCZWZvcmUsXG4gICAgICAgICAgICBzcGFjZUFmdGVyOiByYXdTcGFjZUFmdGVyLFxuICAgICAgICAgICAgdHJhY2tpbmc6IHJhd1RyYWNraW5nLFxuICAgICAgICAgICAga2VybmluZzogcmF3S2VybmluZyxcblxuICAgICAgICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgdmFsdWVzIGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgIG9yaWdpbmFsTGVmdEluZGVudDogcmF3TGVmdEluZGVudCxcbiAgICAgICAgICAgIG9yaWdpbmFsUmlnaHRJbmRlbnQ6IHJhd1JpZ2h0SW5kZW50LFxuICAgICAgICAgICAgb3JpZ2luYWxGaXJzdExpbmVJbmRlbnQ6IHJhd0ZpcnN0TGluZUluZGVudCxcbiAgICAgICAgICAgIG9yaWdpbmFsU3BhY2VCZWZvcmU6IHJhd1NwYWNlQmVmb3JlLFxuICAgICAgICAgICAgb3JpZ2luYWxTcGFjZUFmdGVyOiByYXdTcGFjZUFmdGVyLFxuICAgICAgICAgICAgb3JpZ2luYWxUcmFja2luZzogcmF3VHJhY2tpbmcsXG4gICAgICAgICAgICBvcmlnaW5hbEtlcm5pbmc6IHJhd0tlcm5pbmcsXG5cbiAgICAgICAgICAgIGhvcml6b250YWxTY2FsZTogcGFyc2VGbG9hdChzdHlsZVtcIkBfSG9yaXpvbnRhbFNjYWxlXCJdKSB8fCAxMDAsXG4gICAgICAgICAgICB2ZXJ0aWNhbFNjYWxlOiBwYXJzZUZsb2F0KHN0eWxlW1wiQF9WZXJ0aWNhbFNjYWxlXCJdKSB8fCAxMDAsXG5cbiAgICAgICAgICAgIC8vIEVOSEFOQ0VEOiBVc2UgdGhlIG5ldyBleHRyYWN0aW9uIG1ldGhvZFxuICAgICAgICAgICAgYXBwbGllZEZvbnQ6IGZvbnRSZWYsXG4gICAgICAgICAgICBvcmlnaW5hbEZvbnRSZWY6IGZvbnRSZWYsXG5cbiAgICAgICAgICAgIGZpbGxDb2xvcjogc3R5bGVbXCJAX0ZpbGxDb2xvclwiXSB8fCBcIkNvbG9yL0JsYWNrXCIsXG4gICAgICAgICAgICByYXdTdHlsZTogc3R5bGUsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEZJWEVEOiBBcHBseSB1bml0IGNvbnZlcnNpb24gdG8gY3JlYXRlIHBpeGVsLWNvbnZlcnRlZCBzdHlsZVxuICAgICAgICAgIHRoaXMuc3R5bGVzLnBhcmFncmFwaFtzdHlsZVtcIkBfU2VsZlwiXV0gPVxuICAgICAgICAgICAgdGhpcy5jb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyhiYXNlU3R5bGUpO1xuXG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBg4pyFIFBhcmFncmFwaCBTdHlsZTogJHtzdHlsZVtcIkBfTmFtZVwiXX0gLT4gRm9udDogXCIke2ZvbnRSZWZ9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN1Ykdyb3VwcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cClcbiAgICAgICAgICA/IGdyb3VwLlBhcmFncmFwaFN0eWxlR3JvdXBcbiAgICAgICAgICA6IFtncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwXTtcbiAgICAgICAgc3ViR3JvdXBzLmZvckVhY2goZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KHN0eWxlR3JvdXApO1xuICB9XG5cbiAgZXh0cmFjdEZvbnRGcm9tU3R5bGUoc3R5bGUpIHtcbiAgICAvLyBUcnkgZGlyZWN0IGF0dHJpYnV0ZXMgZmlyc3RcbiAgICBsZXQgZm9udFJlZiA9XG4gICAgICBzdHlsZVtcIkBfQXBwbGllZEZvbnRcIl0gfHwgc3R5bGVbXCJAX0ZvbnRGYW1pbHlcIl0gfHwgc3R5bGVbXCJAX0ZvbnRcIl0gfHwgXCJcIjtcblxuICAgIC8vIElmIG5vdCBmb3VuZCwgdHJ5IFByb3BlcnRpZXMgbmVzdGVkIHN0cnVjdHVyZVxuICAgIGlmICghZm9udFJlZiAmJiBzdHlsZS5Qcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoc3R5bGUuUHJvcGVydGllcy5BcHBsaWVkRm9udCkge1xuICAgICAgICBmb250UmVmID1cbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250W1wiI3RleHRcIl0gfHxcbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250IHx8XG4gICAgICAgICAgXCJcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWxzbyB0cnkgb3RoZXIgcHJvcGVydHkgdmFyaWF0aW9uc1xuICAgICAgaWYgKCFmb250UmVmICYmIHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseSkge1xuICAgICAgICBmb250UmVmID1cbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkZvbnRGYW1pbHlbXCIjdGV4dFwiXSB8fFxuICAgICAgICAgIHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseSB8fFxuICAgICAgICAgIFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnRSZWYgfHwgXCJcIjtcbiAgfVxuXG4gIGV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVHcm91cCkge1xuICAgIGNvbnN0IGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSA9IChncm91cCkgPT4ge1xuICAgICAgaWYgKGdyb3VwLkNoYXJhY3RlclN0eWxlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuQ2hhcmFjdGVyU3R5bGUpXG4gICAgICAgICAgPyBncm91cC5DaGFyYWN0ZXJTdHlsZVxuICAgICAgICAgIDogW2dyb3VwLkNoYXJhY3RlclN0eWxlXTtcblxuICAgICAgICBzdHlsZXMuZm9yRWFjaCgoc3R5bGUpID0+IHtcbiAgICAgICAgICBjb25zdCBmb250UmVmID0gdGhpcy5leHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSk7XG5cbiAgICAgICAgICB0aGlzLnN0eWxlcy5jaGFyYWN0ZXJbc3R5bGVbXCJAX1NlbGZcIl1dID0ge1xuICAgICAgICAgICAgc2VsZjogc3R5bGVbXCJAX1NlbGZcIl0sXG4gICAgICAgICAgICBuYW1lOiBzdHlsZVtcIkBfTmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgICAgZm9udFN0eWxlOiBzdHlsZVtcIkBfRm9udFN0eWxlXCJdIHx8IFwiUmVndWxhclwiLFxuICAgICAgICAgICAgcG9pbnRTaXplOiBwYXJzZUZsb2F0KHN0eWxlW1wiQF9Qb2ludFNpemVcIl0pIHx8IG51bGwsXG5cbiAgICAgICAgICAgIGFwcGxpZWRGb250OiBmb250UmVmLFxuICAgICAgICAgICAgb3JpZ2luYWxGb250UmVmOiBmb250UmVmLFxuXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHN0eWxlW1wiQF9GaWxsQ29sb3JcIl0gfHwgbnVsbCxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzdHlsZVtcIkBfU3Ryb2tlQ29sb3JcIl0gfHwgbnVsbCxcbiAgICAgICAgICAgIHJhd1N0eWxlOiBzdHlsZSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBg4pyFIENoYXJhY3RlciBTdHlsZTogJHtzdHlsZVtcIkBfTmFtZVwiXX0gLT4gRm9udDogXCIke2ZvbnRSZWZ9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN1Ykdyb3VwcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuQ2hhcmFjdGVyU3R5bGVHcm91cClcbiAgICAgICAgICA/IGdyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXBcbiAgICAgICAgICA6IFtncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwXTtcbiAgICAgICAgc3ViR3JvdXBzLmZvckVhY2goZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KHN0eWxlR3JvdXApO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdEZvbnRzKGZvbnRzRGF0YSkge1xuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBmb250cyB3aXRoIGVuaGFuY2VkIG1hcHBpbmcuLi5cIik7XG5cbiAgICBjb25zdCBmb250cyA9IGZvbnRzRGF0YS5Gb250cyB8fCBmb250c0RhdGE7XG4gICAgdGhpcy5yZXNvdXJjZXMuZm9udHMgPSB7fTtcbiAgICB0aGlzLmZvbnRNYXAgPSBuZXcgTWFwKCk7IC8vIEdsb2JhbCBmb250IGxvb2t1cCBtYXBcblxuICAgIGlmIChmb250cy5Gb250RmFtaWx5KSB7XG4gICAgICBjb25zdCBmb250RmFtaWxpZXMgPSBBcnJheS5pc0FycmF5KGZvbnRzLkZvbnRGYW1pbHkpXG4gICAgICAgID8gZm9udHMuRm9udEZhbWlseVxuICAgICAgICA6IFtmb250cy5Gb250RmFtaWx5XTtcblxuICAgICAgZm9udEZhbWlsaWVzLmZvckVhY2goKGZhbWlseSkgPT4ge1xuICAgICAgICBjb25zdCBmYW1pbHlJbmZvID0ge1xuICAgICAgICAgIHNlbGY6IGZhbWlseVtcIkBfU2VsZlwiXSxcbiAgICAgICAgICBuYW1lOiBmYW1pbHlbXCJAX05hbWVcIl0gfHwgXCJcIixcbiAgICAgICAgICBmb250czogW10sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZhbWlseS5Gb250KSB7XG4gICAgICAgICAgY29uc3QgZm9udExpc3QgPSBBcnJheS5pc0FycmF5KGZhbWlseS5Gb250KVxuICAgICAgICAgICAgPyBmYW1pbHkuRm9udFxuICAgICAgICAgICAgOiBbZmFtaWx5LkZvbnRdO1xuXG4gICAgICAgICAgZm9udExpc3QuZm9yRWFjaCgoZm9udCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm9udEluZm8gPSB7XG4gICAgICAgICAgICAgIHNlbGY6IGZvbnRbXCJAX1NlbGZcIl0sXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGZvbnRbXCJAX0ZvbnRGYW1pbHlcIl0gfHwgZmFtaWx5SW5mby5uYW1lLFxuICAgICAgICAgICAgICBuYW1lOiBmb250W1wiQF9OYW1lXCJdIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHBvc3RTY3JpcHROYW1lOiBmb250W1wiQF9Qb3N0U2NyaXB0TmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgICAgICBzdGF0dXM6IGZvbnRbXCJAX1N0YXR1c1wiXSB8fCBcIlVua25vd25cIixcbiAgICAgICAgICAgICAgZm9udFN0eWxlTmFtZTogZm9udFtcIkBfRm9udFN0eWxlTmFtZVwiXSB8fCBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZhbWlseUluZm8uZm9udHMucHVzaChmb250SW5mbyk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBsb29rdXAgZW50cmllcyBmb3IgdGhpcyBmb250XG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX1NlbGZcIl0sIGZhbWlseUluZm8ubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX1Bvc3RTY3JpcHROYW1lXCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250W1wiQF9OYW1lXCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250W1wiQF9Gb250RmFtaWx5XCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYEZvbnQgbWFwcGluZzogJHtmb250W1wiQF9TZWxmXCJdfSAtPiAke2ZhbWlseUluZm8ubmFtZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZm9udHNbZmFtaWx5W1wiQF9TZWxmXCJdXSA9IGZhbWlseUluZm87XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGDinIUgRm9udHMgZXh0cmFjdGVkOiAke09iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGh9IGZhbWlsaWVzYFxuICAgICk7XG4gICAgY29uc29sZS5sb2coYEZvbnQgbWFwIGVudHJpZXM6ICR7dGhpcy5mb250TWFwLnNpemV9YCk7XG4gIH1cblxuICBhc3luYyBleHRyYWN0R3JhcGhpY3MoZ3JhcGhpY3NEYXRhKSB7XG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIGdyYXBoaWNzIGFuZCBjb2xvcnMuLi5cIik7XG5cbiAgICBjb25zdCBncmFwaGljcyA9IGdyYXBoaWNzRGF0YS5HcmFwaGljIHx8IGdyYXBoaWNzRGF0YTtcbiAgICB0aGlzLnJlc291cmNlcy5jb2xvcnMgPSB7fTtcbiAgICB0aGlzLnJlc291cmNlcy5ncmFkaWVudHMgPSB7fTtcblxuICAgIC8vIEV4dHJhY3QgQ29sb3JzXG4gICAgaWYgKGdyYXBoaWNzLkNvbG9yKSB7XG4gICAgICBjb25zdCBjb2xvcnMgPSBBcnJheS5pc0FycmF5KGdyYXBoaWNzLkNvbG9yKVxuICAgICAgICA/IGdyYXBoaWNzLkNvbG9yXG4gICAgICAgIDogW2dyYXBoaWNzLkNvbG9yXTtcblxuICAgICAgY29sb3JzLmZvckVhY2goKGNvbG9yKSA9PiB7XG4gICAgICAgIC8vIEV4dHJhY3QgY2hhbm5lbCB2YWx1ZXNcbiAgICAgICAgY29uc3QgY3lhbiA9IHBhcnNlRmxvYXQoY29sb3JbXCJAX0N5YW5cIl0pIHx8IDA7XG4gICAgICAgIGNvbnN0IG1hZ2VudGEgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9NYWdlbnRhXCJdKSB8fCAwO1xuICAgICAgICBjb25zdCB5ZWxsb3cgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9ZZWxsb3dcIl0pIHx8IDA7XG4gICAgICAgIGNvbnN0IGJsYWNrID0gcGFyc2VGbG9hdChjb2xvcltcIkBfQmxhY2tcIl0pIHx8IDA7XG4gICAgICAgIGNvbnN0IHJlZCA9IHBhcnNlRmxvYXQoY29sb3JbXCJAX1JlZFwiXSkgfHwgMDtcbiAgICAgICAgY29uc3QgZ3JlZW4gPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9HcmVlblwiXSkgfHwgMDtcbiAgICAgICAgY29uc3QgYmx1ZSA9IHBhcnNlRmxvYXQoY29sb3JbXCJAX0JsdWVcIl0pIHx8IDA7XG5cbiAgICAgICAgLy8gRmFsbGJhY2s6IElmIG5vIENNWUsgb3IgUkdCLCBidXQgQ29sb3JWYWx1ZSBleGlzdHMsIHBhcnNlIGFzIFJHQlxuICAgICAgICBsZXQgZmFsbGJhY2tSR0IgPSBudWxsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY3lhbiA9PT0gMCAmJlxuICAgICAgICAgIG1hZ2VudGEgPT09IDAgJiZcbiAgICAgICAgICB5ZWxsb3cgPT09IDAgJiZcbiAgICAgICAgICBibGFjayA9PT0gMCAmJlxuICAgICAgICAgIHJlZCA9PT0gMCAmJlxuICAgICAgICAgIGdyZWVuID09PSAwICYmXG4gICAgICAgICAgYmx1ZSA9PT0gMCAmJlxuICAgICAgICAgIGNvbG9yW1wiQF9Db2xvclZhbHVlXCJdXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIENvbG9yVmFsdWUgaXMgdXN1YWxseSBhIHNwYWNlLXNlcGFyYXRlZCBSR0IgdHJpcGxldCwgZS5nLiBcIjI1NSAxNDAgMFwiXG4gICAgICAgICAgY29uc3QgcmdiUGFydHMgPSBjb2xvcltcIkBfQ29sb3JWYWx1ZVwiXS5zcGxpdCgvXFxzKy8pLm1hcChOdW1iZXIpO1xuICAgICAgICAgIGlmIChyZ2JQYXJ0cy5sZW5ndGggPT09IDMgJiYgcmdiUGFydHMuZXZlcnkoKHYpID0+ICFpc05hTih2KSkpIHtcbiAgICAgICAgICAgIGZhbGxiYWNrUkdCID0ge1xuICAgICAgICAgICAgICByZWQ6IHJnYlBhcnRzWzBdLFxuICAgICAgICAgICAgICBncmVlbjogcmdiUGFydHNbMV0sXG4gICAgICAgICAgICAgIGJsdWU6IHJnYlBhcnRzWzJdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc291cmNlcy5jb2xvcnNbY29sb3JbXCJAX1NlbGZcIl1dID0ge1xuICAgICAgICAgIHNlbGY6IGNvbG9yW1wiQF9TZWxmXCJdLFxuICAgICAgICAgIG5hbWU6IGNvbG9yW1wiQF9OYW1lXCJdIHx8IFwiXCIsXG4gICAgICAgICAgbW9kZWw6IGNvbG9yW1wiQF9Nb2RlbFwiXSB8fCBcIlByb2Nlc3NcIixcbiAgICAgICAgICBzcGFjZTogY29sb3JbXCJAX1NwYWNlXCJdIHx8IFwiQ01ZS1wiLFxuICAgICAgICAgIGN5YW4sXG4gICAgICAgICAgbWFnZW50YSxcbiAgICAgICAgICB5ZWxsb3csXG4gICAgICAgICAgYmxhY2ssXG4gICAgICAgICAgcmVkOiBmYWxsYmFja1JHQiA/IGZhbGxiYWNrUkdCLnJlZCA6IHJlZCxcbiAgICAgICAgICBncmVlbjogZmFsbGJhY2tSR0IgPyBmYWxsYmFja1JHQi5ncmVlbiA6IGdyZWVuLFxuICAgICAgICAgIGJsdWU6IGZhbGxiYWNrUkdCID8gZmFsbGJhY2tSR0IuYmx1ZSA6IGJsdWUsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IEdyYWRpZW50c1xuICAgIGlmIChncmFwaGljcy5HcmFkaWVudCkge1xuICAgICAgY29uc3QgZ3JhZGllbnRzID0gQXJyYXkuaXNBcnJheShncmFwaGljcy5HcmFkaWVudClcbiAgICAgICAgPyBncmFwaGljcy5HcmFkaWVudFxuICAgICAgICA6IFtncmFwaGljcy5HcmFkaWVudF07XG5cbiAgICAgIGdyYWRpZW50cy5mb3JFYWNoKChncmFkaWVudCkgPT4ge1xuICAgICAgICB0aGlzLnJlc291cmNlcy5ncmFkaWVudHNbZ3JhZGllbnRbXCJAX1NlbGZcIl1dID0ge1xuICAgICAgICAgIHNlbGY6IGdyYWRpZW50W1wiQF9TZWxmXCJdLFxuICAgICAgICAgIG5hbWU6IGdyYWRpZW50W1wiQF9OYW1lXCJdIHx8IFwiXCIsXG4gICAgICAgICAgdHlwZTogZ3JhZGllbnRbXCJAX1R5cGVcIl0gfHwgXCJMaW5lYXJcIixcbiAgICAgICAgICBncmFkaWVudFN0b3BzOiB0aGlzLmV4dHJhY3RHcmFkaWVudFN0b3BzKGdyYWRpZW50KSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGV4dHJhY3RHcmFkaWVudFN0b3BzKGdyYWRpZW50KSB7XG4gICAgY29uc3Qgc3RvcHMgPSBbXTtcblxuICAgIGlmIChncmFkaWVudC5HcmFkaWVudFN0b3ApIHtcbiAgICAgIGNvbnN0IHN0b3BMaXN0ID0gQXJyYXkuaXNBcnJheShncmFkaWVudC5HcmFkaWVudFN0b3ApXG4gICAgICAgID8gZ3JhZGllbnQuR3JhZGllbnRTdG9wXG4gICAgICAgIDogW2dyYWRpZW50LkdyYWRpZW50U3RvcF07XG5cbiAgICAgIHN0b3BMaXN0LmZvckVhY2goKHN0b3ApID0+IHtcbiAgICAgICAgc3RvcHMucHVzaCh7XG4gICAgICAgICAgc2VsZjogc3RvcFtcIkBfU2VsZlwiXSxcbiAgICAgICAgICBzdG9wQ29sb3I6IHN0b3BbXCJAX1N0b3BDb2xvclwiXSB8fCBcIlwiLFxuICAgICAgICAgIGxvY2F0aW9uOiBwYXJzZUZsb2F0KHN0b3BbXCJAX0xvY2F0aW9uXCJdKSB8fCAwLFxuICAgICAgICAgIG1pZHBvaW50OiBwYXJzZUZsb2F0KHN0b3BbXCJAX01pZHBvaW50XCJdKSB8fCA1MCxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RvcHM7XG4gIH1cblxuICBhc3luYyBleHRyYWN0UHJlZmVyZW5jZXMocHJlZmVyZW5jZXNEYXRhKSB7XG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIGRvY3VtZW50IHByZWZlcmVuY2VzLi4uXCIpO1xuXG4gICAgY29uc3QgcHJlZnMgPSBwcmVmZXJlbmNlc0RhdGEuUHJlZmVyZW5jZXMgfHwgcHJlZmVyZW5jZXNEYXRhO1xuXG4gICAgLy8gRXh0cmFjdCB2YXJpb3VzIGRvY3VtZW50IHByZWZlcmVuY2VzXG4gICAgdGhpcy5kb2N1bWVudEluZm8gPSB7XG4gICAgICBwcmVmZXJlbmNlczoge1xuICAgICAgICBkb2N1bWVudFByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3REb2N1bWVudFByZWZzKFxuICAgICAgICAgIHByZWZzLkRvY3VtZW50UHJlZmVyZW5jZVxuICAgICAgICApLFxuICAgICAgICB2aWV3UHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdFZpZXdQcmVmcyhwcmVmcy5WaWV3UHJlZmVyZW5jZSksXG4gICAgICAgIGd1aWRlUHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdEd1aWRlUHJlZnMocHJlZnMuR3VpZGVQcmVmZXJlbmNlKSxcbiAgICAgICAgZ3JpZFByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RHcmlkUHJlZnMocHJlZnMuR3JpZFByZWZlcmVuY2UpLFxuICAgICAgICBtYXJnaW5QcmVmZXJlbmNlczogdGhpcy5leHRyYWN0TWFyZ2luUHJlZnMocHJlZnMuTWFyZ2luUHJlZmVyZW5jZSksXG4gICAgICAgIGNvbHVtblByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RDb2x1bW5QcmVmcyhwcmVmcy5Db2x1bW5QcmVmZXJlbmNlKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGV4dHJhY3REb2N1bWVudFByZWZzKGRvY1ByZWYpIHtcbiAgICBpZiAoIWRvY1ByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYWdlV2lkdGg6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfUGFnZVdpZHRoXCJdKSB8fCAwLFxuICAgICAgcGFnZUhlaWdodDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9QYWdlSGVpZ2h0XCJdKSB8fCAwLFxuICAgICAgbGVmdDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9MZWZ0XCJdKSB8fCAwLFxuICAgICAgdG9wOiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX1RvcFwiXSkgfHwgMCxcbiAgICAgIHJpZ2h0OiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX1JpZ2h0XCJdKSB8fCAwLFxuICAgICAgYm90dG9tOiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0JvdHRvbVwiXSkgfHwgMCxcbiAgICAgIGNvbHVtbkNvdW50OiBwYXJzZUludChkb2NQcmVmW1wiQF9Db2x1bW5Db3VudFwiXSkgfHwgMSxcbiAgICAgIGNvbHVtbkd1dHRlcjogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Db2x1bW5HdXR0ZXJcIl0pIHx8IDAsXG4gICAgICBmYWNpbmdQYWdlczogZG9jUHJlZltcIkBfRmFjaW5nUGFnZXNcIl0gPT09IHRydWUsXG4gICAgICBhbGxvd1BhZ2VTaHVmZmxlOiBkb2NQcmVmW1wiQF9BbGxvd1BhZ2VTaHVmZmxlXCJdICE9PSBmYWxzZSxcbiAgICAgIHNsdWdCbGVlZFR5cGU6IGRvY1ByZWZbXCJAX1NsdWdCbGVlZFR5cGVcIl0gfHwgXCJOb25lXCIsXG4gICAgICBkb2N1bWVudEJsZWVkVG9wT2Zmc2V0OlxuICAgICAgICBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0RvY3VtZW50QmxlZWRUb3BPZmZzZXRcIl0pIHx8IDAsXG4gICAgICBkb2N1bWVudEJsZWVkQm90dG9tT2Zmc2V0OlxuICAgICAgICBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0RvY3VtZW50QmxlZWRCb3R0b21PZmZzZXRcIl0pIHx8IDAsXG4gICAgICBkb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0OlxuICAgICAgICBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0RvY3VtZW50QmxlZWRJbnNpZGVPckxlZnRPZmZzZXRcIl0pIHx8IDAsXG4gICAgICBkb2N1bWVudEJsZWVkT3V0c2lkZU9yUmlnaHRPZmZzZXQ6XG4gICAgICAgIHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfRG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0XCJdKSB8fCAwLFxuICAgIH07XG4gIH1cblxuICBleHRyYWN0Vmlld1ByZWZzKHZpZXdQcmVmKSB7XG4gICAgaWYgKCF2aWV3UHJlZikgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhvcml6b250YWxNZWFzdXJlbWVudFVuaXRzOlxuICAgICAgICB2aWV3UHJlZltcIkBfSG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHNcIl0gfHwgXCJQb2ludHNcIixcbiAgICAgIHZlcnRpY2FsTWVhc3VyZW1lbnRVbml0czpcbiAgICAgICAgdmlld1ByZWZbXCJAX1ZlcnRpY2FsTWVhc3VyZW1lbnRVbml0c1wiXSB8fCBcIlBvaW50c1wiLFxuICAgICAgcnVsZXJPcmlnaW46IHZpZXdQcmVmW1wiQF9SdWxlck9yaWdpblwiXSB8fCBcIlNwcmVhZE9yaWdpblwiLFxuICAgICAgc2hvd1J1bGVyczogdmlld1ByZWZbXCJAX1Nob3dSdWxlcnNcIl0gIT09IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICBleHRyYWN0R3VpZGVQcmVmcyhndWlkZVByZWYpIHtcbiAgICBpZiAoIWd1aWRlUHJlZikgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bGVyR3VpZGVDb2xvcjogZ3VpZGVQcmVmW1wiQF9SdWxlckd1aWRlQ29sb3JcIl0gfHwgXCJHcmVlblwiLFxuICAgICAgZ3VpZGVzSW5CYWNrOiBndWlkZVByZWZbXCJAX0d1aWRlc0luQmFja1wiXSA9PT0gdHJ1ZSxcbiAgICAgIGd1aWRlc0xvY2tlZDogZ3VpZGVQcmVmW1wiQF9HdWlkZXNMb2NrZWRcIl0gPT09IHRydWUsXG4gICAgICBndWlkZXNTaG93bjogZ3VpZGVQcmVmW1wiQF9HdWlkZXNTaG93blwiXSAhPT0gZmFsc2UsXG4gICAgICBndWlkZXNTbmFwdG86IGd1aWRlUHJlZltcIkBfR3VpZGVzU25hcHRvXCJdICE9PSBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdEdyaWRQcmVmcyhncmlkUHJlZikge1xuICAgIGlmICghZ3JpZFByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlbGluZVN0YXJ0OiBwYXJzZUZsb2F0KGdyaWRQcmVmW1wiQF9CYXNlbGluZVN0YXJ0XCJdKSB8fCAwLFxuICAgICAgYmFzZWxpbmVEaXZpc2lvbjogcGFyc2VGbG9hdChncmlkUHJlZltcIkBfQmFzZWxpbmVEaXZpc2lvblwiXSkgfHwgMTIsXG4gICAgICBiYXNlbGluZVNob3duOiBncmlkUHJlZltcIkBfQmFzZWxpbmVTaG93blwiXSA9PT0gdHJ1ZSxcbiAgICAgIGJhc2VsaW5lU25hcHRvOiBncmlkUHJlZltcIkBfQmFzZWxpbmVTbmFwdG9cIl0gPT09IHRydWUsXG4gICAgICBkb2N1bWVudEdyaWRTaG93bjogZ3JpZFByZWZbXCJAX0RvY3VtZW50R3JpZFNob3duXCJdID09PSB0cnVlLFxuICAgICAgZG9jdW1lbnRHcmlkU25hcHRvOiBncmlkUHJlZltcIkBfRG9jdW1lbnRHcmlkU25hcHRvXCJdID09PSB0cnVlLFxuICAgIH07XG4gIH1cblxuICBleHRyYWN0TWFyZ2luUHJlZnMobWFyZ2luUHJlZikge1xuICAgIGlmICghbWFyZ2luUHJlZikgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9Ub3BcIl0pIHx8IDAsXG4gICAgICBib3R0b206IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfQm90dG9tXCJdKSB8fCAwLFxuICAgICAgbGVmdDogcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9MZWZ0XCJdKSB8fCAwLFxuICAgICAgcmlnaHQ6IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfUmlnaHRcIl0pIHx8IDAsXG4gICAgICBjb2x1bW5Db3VudDogcGFyc2VJbnQobWFyZ2luUHJlZltcIkBfQ29sdW1uQ291bnRcIl0pIHx8IDEsXG4gICAgICBjb2x1bW5HdXR0ZXI6IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfQ29sdW1uR3V0dGVyXCJdKSB8fCAwLFxuICAgIH07XG4gIH1cblxuICBleHRyYWN0Q29sdW1uUHJlZnMoY29sdW1uUHJlZikge1xuICAgIGlmICghY29sdW1uUHJlZikgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHRDb2x1bW5Db3VudDogcGFyc2VJbnQoY29sdW1uUHJlZltcIkBfVGV4dENvbHVtbkNvdW50XCJdKSB8fCAxLFxuICAgICAgdGV4dENvbHVtbkd1dHRlcjogcGFyc2VGbG9hdChjb2x1bW5QcmVmW1wiQF9UZXh0Q29sdW1uR3V0dGVyXCJdKSB8fCAwLFxuICAgIH07XG4gIH1cblxuICByZXNvbHZlU3R5bGVGb3JtYXR0aW5nKGZvcm1hdHRpbmcpIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHsgLi4uZm9ybWF0dGluZyB9O1xuXG4gICAgLy8gREVCVUc6IENoZWNrIGlmIGZvcm1hdHRpbmcgaXMgYmVpbmcgYXBwbGllZCAoZ2VuZXJpYyBjaGVjaylcbiAgICBjb25zdCBoYXNBbnlGb3JtYXR0aW5nID1cbiAgICAgIGZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGUgfHxcbiAgICAgIGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgfHxcbiAgICAgIGZvcm1hdHRpbmcuZm9udFN0eWxlIHx8XG4gICAgICBmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UgfHxcbiAgICAgIGZvcm1hdHRpbmcuZm9udFNpemU7XG5cbiAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgY29uc29sZS5sb2coXCLwn5SnIFN0eWxlUGFyc2VyLnJlc29sdmVTdHlsZUZvcm1hdHRpbmcgLSBJbnB1dDpcIiwge1xuICAgICAgICBwYXJhZ3JhcGhTdHlsZTogZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSxcbiAgICAgICAgY2hhcmFjdGVyU3R5bGU6IGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUsXG4gICAgICAgIGRpcmVjdEZvbnRTdHlsZTogZm9ybWF0dGluZy5mb250U3R5bGUsXG4gICAgICAgIGRpcmVjdEZvbnRSZWY6IGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSxcbiAgICAgICAgZGlyZWN0Rm9udFNpemU6IGZvcm1hdHRpbmcuZm9udFNpemUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXNvbHZlIHBhcmFncmFwaCBzdHlsZSAoYmFzZSBsYXllcilcbiAgICBpZiAoXG4gICAgICBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlICYmXG4gICAgICB0aGlzLnN0eWxlcy5wYXJhZ3JhcGhbZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZV1cbiAgICApIHtcbiAgICAgIGNvbnN0IHBTdHlsZSA9IHRoaXMuc3R5bGVzLnBhcmFncmFwaFtmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlXTtcblxuICAgICAgaWYgKCFyZXNvbHZlZC5mb250U2l6ZSAmJiBwU3R5bGUucG9pbnRTaXplKVxuICAgICAgICByZXNvbHZlZC5mb250U2l6ZSA9IHBTdHlsZS5wb2ludFNpemU7XG4gICAgICBpZiAoIXJlc29sdmVkLmZpbGxDb2xvciAmJiBwU3R5bGUuZmlsbENvbG9yKVxuICAgICAgICByZXNvbHZlZC5maWxsQ29sb3IgPSBwU3R5bGUuZmlsbENvbG9yO1xuICAgICAgLy8gQ1JJVElDQUwgRklYOiBBbHdheXMgaW5oZXJpdCBwYXJhZ3JhcGggYWxpZ25tZW50IHVubGVzcyBleHBsaWNpdGx5IG92ZXJyaWRkZW5cbiAgICAgIGlmIChwU3R5bGUuYWxpZ25tZW50KSByZXNvbHZlZC5hbGlnbm1lbnQgPSBwU3R5bGUuYWxpZ25tZW50O1xuICAgICAgaWYgKCFyZXNvbHZlZC5mb250U3R5bGUgJiYgcFN0eWxlLmZvbnRTdHlsZSkge1xuICAgICAgICByZXNvbHZlZC5mb250U3R5bGUgPSBwU3R5bGUuZm9udFN0eWxlO1xuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCAgIEZvbnRTdHlsZSBmcm9tIHBhcmFncmFwaCBzdHlsZTogXCIke3BTdHlsZS5mb250U3R5bGV9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDUklUSUNBTDogUmVzb2x2ZSBmb250IGZyb20gcGFyYWdyYXBoIHN0eWxlXG4gICAgICBpZiAoIXJlc29sdmVkLmZvbnRGYW1pbHkgJiYgcFN0eWxlLmFwcGxpZWRGb250KSB7XG4gICAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLnJlc29sdmVGb250UmVmZXJlbmNlKHBTdHlsZS5hcHBsaWVkRm9udCk7XG4gICAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgICAgRm9udCBmcm9tIHBhcmFncmFwaCBzdHlsZTogJHtwU3R5bGUuYXBwbGllZEZvbnR9IC0+ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgb3RoZXIgcGFyYWdyYXBoIHByb3BlcnRpZXMgd2l0aCBlbmhhbmNlZCBsZWFkaW5nIHN1cHBvcnRcbiAgICAgIHJlc29sdmVkLmxlYWRpbmcgPSBwU3R5bGUubGVhZGluZztcbiAgICAgIHJlc29sdmVkLmxlYWRpbmdUeXBlID0gcFN0eWxlLmxlYWRpbmdUeXBlO1xuICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IHBTdHlsZS5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xuICAgICAgcmVzb2x2ZWQubGVmdEluZGVudCA9IHBTdHlsZS5sZWZ0SW5kZW50O1xuICAgICAgcmVzb2x2ZWQucmlnaHRJbmRlbnQgPSBwU3R5bGUucmlnaHRJbmRlbnQ7XG4gICAgICByZXNvbHZlZC5maXJzdExpbmVJbmRlbnQgPSBwU3R5bGUuZmlyc3RMaW5lSW5kZW50O1xuICAgICAgcmVzb2x2ZWQuc3BhY2VCZWZvcmUgPSBwU3R5bGUuc3BhY2VCZWZvcmU7XG4gICAgICByZXNvbHZlZC5zcGFjZUFmdGVyID0gcFN0eWxlLnNwYWNlQWZ0ZXI7XG4gICAgICByZXNvbHZlZC50cmFja2luZyA9IHBTdHlsZS50cmFja2luZztcbiAgICAgIHJlc29sdmVkLmtlcm5pbmcgPSBwU3R5bGUua2VybmluZztcbiAgICB9XG5cbiAgICAvLyBSZXNvbHZlIGNoYXJhY3RlciBzdHlsZSAob3ZlcnJpZGUgbGF5ZXIpXG4gICAgaWYgKFxuICAgICAgZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZSAmJlxuICAgICAgdGhpcy5zdHlsZXMuY2hhcmFjdGVyW2Zvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVdXG4gICAgKSB7XG4gICAgICBjb25zdCBjU3R5bGUgPSB0aGlzLnN0eWxlcy5jaGFyYWN0ZXJbZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZV07XG5cbiAgICAgIGlmIChjU3R5bGUucG9pbnRTaXplKSByZXNvbHZlZC5mb250U2l6ZSA9IGNTdHlsZS5wb2ludFNpemU7XG4gICAgICBpZiAoY1N0eWxlLmZpbGxDb2xvcikgcmVzb2x2ZWQuZmlsbENvbG9yID0gY1N0eWxlLmZpbGxDb2xvcjtcbiAgICAgIGlmIChjU3R5bGUuZm9udFN0eWxlKSB7XG4gICAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IGNTdHlsZS5mb250U3R5bGU7XG4gICAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgICAgRm9udFN0eWxlIGZyb20gY2hhcmFjdGVyIHN0eWxlOiBcIiR7Y1N0eWxlLmZvbnRTdHlsZX1cImBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY1N0eWxlLnN0cm9rZUNvbG9yKSByZXNvbHZlZC5zdHJva2VDb2xvciA9IGNTdHlsZS5zdHJva2VDb2xvcjtcblxuICAgICAgLy8gSW5jbHVkZSBsZWFkaW5nIGluZm9ybWF0aW9uIGZyb20gY2hhcmFjdGVyIHN0eWxlXG4gICAgICBpZiAoY1N0eWxlLmxlYWRpbmcpIHJlc29sdmVkLmxlYWRpbmcgPSBjU3R5bGUubGVhZGluZztcbiAgICAgIGlmIChjU3R5bGUubGVhZGluZ1R5cGUpIHJlc29sdmVkLmxlYWRpbmdUeXBlID0gY1N0eWxlLmxlYWRpbmdUeXBlO1xuICAgICAgaWYgKGNTdHlsZS5lZmZlY3RpdmVMaW5lSGVpZ2h0KVxuICAgICAgICByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gY1N0eWxlLmVmZmVjdGl2ZUxpbmVIZWlnaHQ7XG5cbiAgICAgIC8vIENSSVRJQ0FMOiBDaGFyYWN0ZXIgc3R5bGUgZm9udCBvdmVycmlkZXMgcGFyYWdyYXBoIHN0eWxlXG4gICAgICBpZiAoY1N0eWxlLmFwcGxpZWRGb250KSB7XG4gICAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLnJlc29sdmVGb250UmVmZXJlbmNlKGNTdHlsZS5hcHBsaWVkRm9udCk7XG4gICAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgICAgRm9udCBmcm9tIGNoYXJhY3RlciBzdHlsZTogJHtjU3R5bGUuYXBwbGllZEZvbnR9IC0+ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IGRpcmVjdCBmb3JtYXR0aW5nIChoaWdoZXN0IHByaW9yaXR5KVxuICAgIGlmIChmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UpIHtcbiAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLnJlc29sdmVGb250UmVmZXJlbmNlKGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSk7XG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgICAgRm9udCBmcm9tIGRpcmVjdCBmb3JtYXR0aW5nOiAke2Zvcm1hdHRpbmcuZm9udFJlZmVyZW5jZX0gLT4gJHtyZXNvbHZlZC5mb250RmFtaWx5fWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDUklUSUNBTDogQXBwbHkgZGlyZWN0IGZvbnRTdHlsZSBpZiBwcm92aWRlZCAodGhpcyBtaWdodCBiZSB0aGUgaXNzdWUpXG4gICAgaWYgKGZvcm1hdHRpbmcuZm9udFN0eWxlKSB7XG4gICAgICByZXNvbHZlZC5mb250U3R5bGUgPSBmb3JtYXR0aW5nLmZvbnRTdHlsZTtcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgICBGb250U3R5bGUgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogXCIke2Zvcm1hdHRpbmcuZm9udFN0eWxlfVwiYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IGRpcmVjdCBsZWFkaW5nIGluZm9ybWF0aW9uIChoaWdoZXN0IHByaW9yaXR5KVxuICAgIGlmIChmb3JtYXR0aW5nLmxlYWRpbmcgIT09IHVuZGVmaW5lZCkgcmVzb2x2ZWQubGVhZGluZyA9IGZvcm1hdHRpbmcubGVhZGluZztcbiAgICBpZiAoZm9ybWF0dGluZy5sZWFkaW5nVHlwZSkgcmVzb2x2ZWQubGVhZGluZ1R5cGUgPSBmb3JtYXR0aW5nLmxlYWRpbmdUeXBlO1xuICAgIGlmIChmb3JtYXR0aW5nLmVmZmVjdGl2ZUxpbmVIZWlnaHQpXG4gICAgICByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xuXG4gICAgLy8gQXBwbHkgb3RoZXIgZGlyZWN0IGZvcm1hdHRpbmcgYXR0cmlidXRlc1xuICAgIGlmIChmb3JtYXR0aW5nLmZvbnRTaXplKSByZXNvbHZlZC5mb250U2l6ZSA9IGZvcm1hdHRpbmcuZm9udFNpemU7XG4gICAgaWYgKGZvcm1hdHRpbmcudHJhY2tpbmcpIHJlc29sdmVkLnRyYWNraW5nID0gZm9ybWF0dGluZy50cmFja2luZztcbiAgICBpZiAoZm9ybWF0dGluZy5rZXJuaW5nKSByZXNvbHZlZC5rZXJuaW5nID0gZm9ybWF0dGluZy5rZXJuaW5nO1xuXG4gICAgLy8gQ1JJVElDQUwgRklYOiBBcHBseSBkaXJlY3QgYWxpZ25tZW50IGlmIGV4cGxpY2l0bHkgc3BlY2lmaWVkIChvdmVycmlkZXMgcGFyYWdyYXBoIGFsaWdubWVudClcbiAgICBpZiAoZm9ybWF0dGluZy5hbGlnbm1lbnQpIHtcbiAgICAgIHJlc29sdmVkLmFsaWdubWVudCA9IGZvcm1hdHRpbmcuYWxpZ25tZW50O1xuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYCAgIEFsaWdubWVudCBmcm9tIGRpcmVjdCBmb3JtYXR0aW5nOiBcIiR7Zm9ybWF0dGluZy5hbGlnbm1lbnR9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRklYRUQ6IEVuc3VyZSBmb250U3R5bGUgZGVmYXVsdHMgdG8gUmVndWxhci9ub3JtYWwgaWYgbm90IHNldFxuICAgIGlmICghcmVzb2x2ZWQuZm9udFN0eWxlIHx8IHJlc29sdmVkLmZvbnRTdHlsZSA9PT0gXCJcIikge1xuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gXCJSZWd1bGFyXCI7XG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhgICAgRm9udFN0eWxlIGRlZmF1bHRlZCB0bzogXCJSZWd1bGFyXCJgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBRERJVElPTkFMIEZJWDogSWYgbm8gc3R5bGVzIHdlcmUgYXBwbGllZCBmcm9tIGFueSBzb3VyY2UsIGVuc3VyZSBjbGVhbiBkZWZhdWx0c1xuICAgIGlmIChcbiAgICAgICFmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlICYmXG4gICAgICAhZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZSAmJlxuICAgICAgIWZvcm1hdHRpbmcuZm9udFN0eWxlICYmXG4gICAgICAhZm9ybWF0dGluZy5mb250UmVmZXJlbmNlXG4gICAgKSB7XG4gICAgICByZXNvbHZlZC5mb250U3R5bGUgPSBcIlJlZ3VsYXJcIjtcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBObyBzb3VyY2Ugc3R5bGVzIGZvdW5kIC0gZW5zdXJpbmcgY2xlYW4gZGVmYXVsdHNgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5hbCBmYWxsYmFja1xuICAgIGlmICghcmVzb2x2ZWQuZm9udEZhbWlseSB8fCByZXNvbHZlZC5mb250RmFtaWx5ID09PSBcIlwiKSB7XG4gICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5nZXREZWZhdWx0Rm9udCgpO1xuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIFVzaW5nIGZhbGxiYWNrIGZvbnQ6ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgbGluZSBoZWlnaHQgaXMgY2FsY3VsYXRlZCBpZiBub3QgZXhwbGljaXRseSBzZXRcbiAgICBpZiAoXG4gICAgICAhcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCAmJlxuICAgICAgcmVzb2x2ZWQuZm9udFNpemUgJiZcbiAgICAgIHJlc29sdmVkLmxlYWRpbmdcbiAgICApIHtcbiAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoXG4gICAgICAgIHJlc29sdmVkLmxlYWRpbmcsXG4gICAgICAgIHJlc29sdmVkLmZvbnRTaXplXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCflKcgU3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyAtIEZpbmFsIE91dHB1dDpcIiwge1xuICAgICAgICBmb250U2l6ZTogcmVzb2x2ZWQuZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IHJlc29sdmVkLmZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTdHlsZTogcmVzb2x2ZWQuZm9udFN0eWxlLFxuICAgICAgICBmaWxsQ29sb3I6IHJlc29sdmVkLmZpbGxDb2xvcixcbiAgICAgICAgbGVhZGluZzogcmVzb2x2ZWQubGVhZGluZyxcbiAgICAgICAgZWZmZWN0aXZlTGluZUhlaWdodDogcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfVxuXG4gIHJlc29sdmVGb250UmVmZXJlbmNlKGZvbnRSZWYpIHtcbiAgICBpZiAoIWZvbnRSZWYgfHwgZm9udFJlZiA9PT0gXCJcIikge1xuICAgICAgY29uc29sZS5sb2coXCJFbXB0eSBmb250IHJlZmVyZW5jZSwgdXNpbmcgZmFsbGJhY2tcIik7XG4gICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0Rm9udCgpO1xuICAgIH1cblxuICAgIC8vIFRyeSBkaXJlY3QgbG9va3VwIGluIGZvbnQgbWFwXG4gICAgaWYgKHRoaXMuZm9udE1hcCAmJiB0aGlzLmZvbnRNYXAuaGFzKGZvbnRSZWYpKSB7XG4gICAgICBjb25zdCByZXNvbHZlZEZvbnQgPSB0aGlzLmZvbnRNYXAuZ2V0KGZvbnRSZWYpO1xuICAgICAgY29uc29sZS5sb2coYEZvbnQgcmVzb2x2ZWQ6IFwiJHtmb250UmVmfVwiIC0+IFwiJHtyZXNvbHZlZEZvbnR9XCJgKTtcbiAgICAgIHJldHVybiByZXNvbHZlZEZvbnQ7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHBhcnRpYWwgbWF0Y2hpbmcgZm9yIGZvbnQgZmFtaWxpZXNcbiAgICBpZiAodGhpcy5yZXNvdXJjZXMuZm9udHMpIHtcbiAgICAgIGZvciAoY29uc3QgW2ZhbWlseUlkLCBmYW1pbHlJbmZvXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZm9udHNcbiAgICAgICkpIHtcbiAgICAgICAgLy8gQ2hlY2sgZmFtaWx5IG5hbWUgbWF0Y2hcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGZhbWlseUluZm8ubmFtZSAmJlxuICAgICAgICAgIChmYW1pbHlJbmZvLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmb250UmVmLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICAgICAgICBmb250UmVmLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmFtaWx5SW5mby5uYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGBGb250IHBhcnRpYWxseSBtYXRjaGVkOiBcIiR7Zm9udFJlZn1cIiAtPiBcIiR7ZmFtaWx5SW5mby5uYW1lfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGZhbWlseUluZm8ubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGluZGl2aWR1YWwgZm9udCBtYXRjaGVzXG4gICAgICAgIGlmIChmYW1pbHlJbmZvLmZvbnRzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBmb250IG9mIGZhbWlseUluZm8uZm9udHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZm9udC5zZWxmID09PSBmb250UmVmIHx8XG4gICAgICAgICAgICAgIGZvbnQucG9zdFNjcmlwdE5hbWUgPT09IGZvbnRSZWYgfHxcbiAgICAgICAgICAgICAgZm9udC5uYW1lID09PSBmb250UmVmXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYEZvbnQgZXhhY3RseSBtYXRjaGVkOiBcIiR7Zm9udFJlZn1cIiAtPiBcIiR7ZmFtaWx5SW5mby5uYW1lfVwiYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gZmFtaWx5SW5mby5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBGb250IG5vdCBmb3VuZDogXCIke2ZvbnRSZWZ9XCIsIHVzaW5nIGZhbGxiYWNrYCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdEZvbnQoKSB8fCBmb250UmVmO1xuICB9XG5cbiAgZ2V0RGVmYXVsdEZvbnQoKSB7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VzLmZvbnRzICYmIE9iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmaXJzdEZhbWlseSA9IE9iamVjdC52YWx1ZXModGhpcy5yZXNvdXJjZXMuZm9udHMpWzBdO1xuICAgICAgcmV0dXJuIGZpcnN0RmFtaWx5Lm5hbWUgfHwgXCJBcmlhbFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJBcmlhbFwiO1xuICB9XG5cbiAgaW5mZXJGb250RnJvbUNvbnRleHQoKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBmb250IGRlZmluaXRpb25zIGJ1dCBubyBleHBsaWNpdCByZWZlcmVuY2VzLFxuICAgIC8vIHJldHVybiB0aGUgZmlyc3QgYXZhaWxhYmxlIGZvbnQgYXMgYSBmYWxsYmFja1xuICAgIGlmICh0aGlzLnJlc291cmNlcy5mb250cyAmJiBPYmplY3Qua2V5cyh0aGlzLnJlc291cmNlcy5mb250cykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RGb250RmFtaWx5ID0gT2JqZWN0LnZhbHVlcyh0aGlzLnJlc291cmNlcy5mb250cylbMF07XG4gICAgICByZXR1cm4gZmlyc3RGb250RmFtaWx5Lm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0U3RvcnlTdHlsZVN1bW1hcnkoc3RvcnkpIHtcbiAgICBjb25zdCBzdW1tYXJ5ID0ge1xuICAgICAgZm9udFNpemU6IG51bGwsXG4gICAgICBmb250RmFtaWx5OiBudWxsLFxuICAgICAgYWxpZ25tZW50OiBudWxsLFxuICAgICAgZmlsbENvbG9yOiBudWxsLFxuICAgICAgZm9udFN0eWxlOiBudWxsLFxuICAgICAgbGVhZGluZzogbnVsbCxcbiAgICAgIGxlYWRpbmdUeXBlOiBudWxsLFxuICAgICAgZWZmZWN0aXZlTGluZUhlaWdodDogbnVsbCxcbiAgICAgIHRyYWNraW5nOiBudWxsLFxuICAgICAga2VybmluZzogbnVsbCxcbiAgICB9O1xuXG4gICAgLy8gR2V0IHRoZSBtb3N0IGNvbW1vbiBvciBmaXJzdCBmb3JtYXR0aW5nIHZhbHVlc1xuICAgIGlmIChzdG9yeS5jb250ZW50Py5mb3JtYXR0ZWRDb250ZW50Py5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmaXJzdEZvcm1hdHRlZCA9IHN0b3J5LmNvbnRlbnQuZm9ybWF0dGVkQ29udGVudC5maW5kKFxuICAgICAgICAoaXRlbSkgPT4gaXRlbS5mb3JtYXR0aW5nICYmICFpdGVtLmZvcm1hdHRpbmcuaXNCcmVha1xuICAgICAgKTtcblxuICAgICAgaWYgKGZpcnN0Rm9ybWF0dGVkPy5mb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnN0IGZtdCA9IGZpcnN0Rm9ybWF0dGVkLmZvcm1hdHRpbmc7XG4gICAgICAgIHN1bW1hcnkuZm9udFNpemUgPSBmbXQuZm9udFNpemU7XG4gICAgICAgIHN1bW1hcnkuZm9udEZhbWlseSA9IGZtdC5mb250RmFtaWx5O1xuICAgICAgICBzdW1tYXJ5LmFsaWdubWVudCA9IGZtdC5hbGlnbm1lbnQ7XG4gICAgICAgIHN1bW1hcnkuZmlsbENvbG9yID0gZm10LmZpbGxDb2xvcjtcbiAgICAgICAgc3VtbWFyeS5mb250U3R5bGUgPSBmbXQuZm9udFN0eWxlO1xuICAgICAgICBzdW1tYXJ5LmxlYWRpbmcgPSBmbXQubGVhZGluZztcbiAgICAgICAgc3VtbWFyeS5sZWFkaW5nVHlwZSA9IGZtdC5sZWFkaW5nVHlwZTtcbiAgICAgICAgc3VtbWFyeS5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gZm10LmVmZmVjdGl2ZUxpbmVIZWlnaHQ7XG4gICAgICAgIHN1bW1hcnkudHJhY2tpbmcgPSBmbXQudHJhY2tpbmc7XG4gICAgICAgIHN1bW1hcnkua2VybmluZyA9IGZtdC5rZXJuaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdW1tYXJ5O1xuICB9XG5cbiAgLy8gTkVXOiBQcm9jZXNzIGxlYWRpbmcgdmFsdWVzIHdpdGggSW5EZXNpZ24tc3BlY2lmaWMgbG9naWMgKHNoYXJlZCB3aXRoIFN0b3J5UGFyc2VyKVxuICBwcm9jZXNzTGVhZGluZ1ZhbHVlKHJhd0xlYWRpbmcsIGZvbnRTaXplKSB7XG4gICAgaWYgKCFyYXdMZWFkaW5nKSByZXR1cm4gXCJhdXRvXCI7XG5cbiAgICAvLyBIYW5kbGUgXCJhdXRvXCIgbGVhZGluZ1xuICAgIGlmIChyYXdMZWFkaW5nID09PSBcImF1dG9cIiB8fCByYXdMZWFkaW5nID09PSBcIkF1dG9cIikge1xuICAgICAgcmV0dXJuIGZvbnRTaXplID8gZm9udFNpemUgKiAxLjIgOiBcImF1dG9cIjsgLy8gSW5EZXNpZ24gZGVmYXVsdCBhdXRvIGxlYWRpbmcgaXMgMTIwJVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBudW1lcmljIGxlYWRpbmcgKGluIHBvaW50cylcbiAgICBjb25zdCBudW1lcmljTGVhZGluZyA9IHBhcnNlRmxvYXQocmF3TGVhZGluZyk7XG4gICAgaWYgKCFpc05hTihudW1lcmljTGVhZGluZykpIHtcbiAgICAgIHJldHVybiBudW1lcmljTGVhZGluZztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcGVyY2VudGFnZS1iYXNlZCBsZWFkaW5nXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICBjb25zdCBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChyYXdMZWFkaW5nLnJlcGxhY2UoXCIlXCIsIFwiXCIpKTtcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IChmb250U2l6ZSAqIHBlcmNlbnRhZ2UpIC8gMTAwIDogXCJhdXRvXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiYXV0b1wiO1xuICB9XG5cbiAgLy8gTkVXOiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgbGVhZGluZyBiZWluZyB1c2VkXG4gIGRldGVybWluZUxlYWRpbmdUeXBlKHJhd0xlYWRpbmcpIHtcbiAgICBpZiAoIXJhd0xlYWRpbmcgfHwgcmF3TGVhZGluZyA9PT0gXCJhdXRvXCIgfHwgcmF3TGVhZGluZyA9PT0gXCJBdXRvXCIpIHtcbiAgICAgIHJldHVybiBcImF1dG9cIjtcbiAgICB9XG5cbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHJldHVybiBcInBlcmNlbnRhZ2VcIjtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQocmF3TGVhZGluZykpKSB7XG4gICAgICByZXR1cm4gXCJhYnNvbHV0ZVwiO1xuICAgIH1cblxuICAgIHJldHVybiBcInVua25vd25cIjtcbiAgfVxuXG4gIC8vIE5FVzogQ2FsY3VsYXRlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBmb3IgQ1NTIHJlbmRlcmluZ1xuICBjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KGxlYWRpbmcsIGZvbnRTaXplKSB7XG4gICAgaWYgKGxlYWRpbmcgPT09IFwiYXV0b1wiKSB7XG4gICAgICByZXR1cm4gMS4yOyAvLyBDU1MgbGluZS1oZWlnaHQgcmF0aW8gZm9yIGF1dG9cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxlYWRpbmcgPT09IFwibnVtYmVyXCIgJiYgZm9udFNpemUpIHtcbiAgICAgIC8vIENvbnZlcnQgcG9pbnRzIHRvIENTUyBsaW5lLWhlaWdodCByYXRpb1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAuOCwgbGVhZGluZyAvIGZvbnRTaXplKTsgLy8gRW5zdXJlIG1pbmltdW0gbGluZSBoZWlnaHRcbiAgICB9XG5cbiAgICByZXR1cm4gMS4yOyAvLyBGYWxsYmFja1xuICB9XG5cbiAgZ2V0U3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlcztcbiAgfVxuXG4gIGdldFJlc291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXM7XG4gIH1cblxuICBnZXRGb250TWFwKCkge1xuICAgIHJldHVybiB0aGlzLmZvbnRNYXA7XG4gIH1cblxuICAvLyBBZGQgbWV0aG9kcyB0byByZXR1cm4gc3R5bGUgYW5kIGZvbnQgZGVmaW5pdGlvbnMgZm9yIGRlYnVnXG4gIGdldFBhcmFncmFwaFN0eWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZXMucGFyYWdyYXBoO1xuICB9XG4gIGdldENoYXJhY3RlclN0eWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZXMuY2hhcmFjdGVyO1xuICB9XG4gIGdldEZvbnREZWZpbml0aW9ucygpIHtcbiAgICAvLyBQcmVmZXIgcGxhaW4gb2JqZWN0IGZvciBkZWJ1ZyBvdXRwdXRcbiAgICBpZiAodGhpcy5yZXNvdXJjZXMgJiYgdGhpcy5yZXNvdXJjZXMuZm9udHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc291cmNlcy5mb250cztcbiAgICB9XG4gICAgLy8gRmFsbGJhY2s6IGNvbnZlcnQgZm9udE1hcCB0byBvYmplY3RcbiAgICBpZiAodGhpcy5mb250TWFwICYmIHR5cGVvZiB0aGlzLmZvbnRNYXAuZW50cmllcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuZm9udE1hcC5lbnRyaWVzKCkpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyBGSVhFRDogQWRkIG1ldGhvZCB0byBhY2Nlc3MgZG9jdW1lbnQgcHJlZmVyZW5jZXMgaW5jbHVkaW5nIFZpZXdQcmVmZXJlbmNlc1xuICBnZXREb2N1bWVudEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRJbmZvO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVQYXJzZXI7XG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJJRE1MVXRpbHMiLCJTdHlsZVBhcnNlciIsInNldERvY3VtZW50VW5pdHMiLCJ1bml0cyIsImRvY3VtZW50VW5pdHMiLCJjb25zb2xlIiwibG9nIiwiY29udmVydFR5cG9ncmFwaHlUb1BpeGVscyIsInZhbHVlIiwiaXNOYU4iLCJ1bml0Q29udmVydGVyIiwiaXNTdXBwb3J0ZWRVbml0IiwiY29udmVydGVkVmFsdWUiLCJ0b1BpeGVscyIsImNvbnZlcnRTdHlsZU1lYXN1cmVtZW50c1RvUGl4ZWxzIiwic3R5bGUiLCJjb252ZXJ0ZWRTdHlsZSIsIm1lYXN1cmVtZW50RmllbGRzIiwiZm9yRWFjaCIsImZpZWxkIiwibGVhZGluZyIsInBhcnNlUmVzb3VyY2VGaWxlIiwiZmlsZU5hbWUiLCJjb250ZW50IiwieG1sUGFyc2VyIiwicGFyc2VkIiwicGFyc2UiLCJyZXNvdXJjZU5hbWUiLCJiYXNlbmFtZSIsImluY2x1ZGVzIiwiZXh0cmFjdFN0eWxlcyIsImV4dHJhY3RGb250cyIsImV4dHJhY3RHcmFwaGljcyIsImV4dHJhY3RQcmVmZXJlbmNlcyIsImVycm9yIiwibWVzc2FnZSIsInN0eWxlc0RhdGEiLCJzdHlsZXMiLCJTdHlsZXMiLCJSb290UGFyYWdyYXBoU3R5bGVHcm91cCIsImV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMiLCJSb290Q2hhcmFjdGVyU3R5bGVHcm91cCIsImV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMiLCJzdHlsZUdyb3VwIiwiZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5IiwiZ3JvdXAiLCJQYXJhZ3JhcGhTdHlsZSIsIkFycmF5IiwiaXNBcnJheSIsImZvbnRSZWYiLCJleHRyYWN0Rm9udEZyb21TdHlsZSIsImZvbnRTaXplIiwicGFyc2VGbG9hdCIsInJhd0xlYWRpbmciLCJwcm9jZXNzZWRMZWFkaW5nIiwicHJvY2Vzc0xlYWRpbmdWYWx1ZSIsInJhd0xlZnRJbmRlbnQiLCJyYXdSaWdodEluZGVudCIsInJhd0ZpcnN0TGluZUluZGVudCIsInJhd1NwYWNlQmVmb3JlIiwicmF3U3BhY2VBZnRlciIsInJhd1RyYWNraW5nIiwicmF3S2VybmluZyIsImJhc2VTdHlsZSIsInNlbGYiLCJuYW1lIiwiZm9udFN0eWxlIiwicG9pbnRTaXplIiwibGVhZGluZ1R5cGUiLCJkZXRlcm1pbmVMZWFkaW5nVHlwZSIsImVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0IiwiYWxpZ25tZW50IiwibGVmdEluZGVudCIsInJpZ2h0SW5kZW50IiwiZmlyc3RMaW5lSW5kZW50Iiwic3BhY2VCZWZvcmUiLCJzcGFjZUFmdGVyIiwidHJhY2tpbmciLCJrZXJuaW5nIiwib3JpZ2luYWxMZWZ0SW5kZW50Iiwib3JpZ2luYWxSaWdodEluZGVudCIsIm9yaWdpbmFsRmlyc3RMaW5lSW5kZW50Iiwib3JpZ2luYWxTcGFjZUJlZm9yZSIsIm9yaWdpbmFsU3BhY2VBZnRlciIsIm9yaWdpbmFsVHJhY2tpbmciLCJvcmlnaW5hbEtlcm5pbmciLCJob3Jpem9udGFsU2NhbGUiLCJ2ZXJ0aWNhbFNjYWxlIiwiYXBwbGllZEZvbnQiLCJvcmlnaW5hbEZvbnRSZWYiLCJmaWxsQ29sb3IiLCJyYXdTdHlsZSIsInBhcmFncmFwaCIsIlBhcmFncmFwaFN0eWxlR3JvdXAiLCJzdWJHcm91cHMiLCJQcm9wZXJ0aWVzIiwiQXBwbGllZEZvbnQiLCJGb250RmFtaWx5IiwiQ2hhcmFjdGVyU3R5bGUiLCJjaGFyYWN0ZXIiLCJzdHJva2VDb2xvciIsIkNoYXJhY3RlclN0eWxlR3JvdXAiLCJmb250c0RhdGEiLCJmb250cyIsIkZvbnRzIiwicmVzb3VyY2VzIiwiZm9udE1hcCIsIk1hcCIsImZvbnRGYW1pbGllcyIsImZhbWlseSIsImZhbWlseUluZm8iLCJGb250IiwiZm9udExpc3QiLCJmb250IiwiZm9udEluZm8iLCJmb250RmFtaWx5IiwicG9zdFNjcmlwdE5hbWUiLCJzdGF0dXMiLCJmb250U3R5bGVOYW1lIiwicHVzaCIsInNldCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzaXplIiwiZ3JhcGhpY3NEYXRhIiwiZ3JhcGhpY3MiLCJHcmFwaGljIiwiY29sb3JzIiwiZ3JhZGllbnRzIiwiQ29sb3IiLCJjb2xvciIsImN5YW4iLCJtYWdlbnRhIiwieWVsbG93IiwiYmxhY2siLCJyZWQiLCJncmVlbiIsImJsdWUiLCJmYWxsYmFja1JHQiIsInJnYlBhcnRzIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJldmVyeSIsInYiLCJtb2RlbCIsInNwYWNlIiwiR3JhZGllbnQiLCJncmFkaWVudCIsInR5cGUiLCJncmFkaWVudFN0b3BzIiwiZXh0cmFjdEdyYWRpZW50U3RvcHMiLCJzdG9wcyIsIkdyYWRpZW50U3RvcCIsInN0b3BMaXN0Iiwic3RvcCIsInN0b3BDb2xvciIsImxvY2F0aW9uIiwibWlkcG9pbnQiLCJwcmVmZXJlbmNlc0RhdGEiLCJwcmVmcyIsIlByZWZlcmVuY2VzIiwiZG9jdW1lbnRJbmZvIiwicHJlZmVyZW5jZXMiLCJkb2N1bWVudFByZWZlcmVuY2VzIiwiZXh0cmFjdERvY3VtZW50UHJlZnMiLCJEb2N1bWVudFByZWZlcmVuY2UiLCJ2aWV3UHJlZmVyZW5jZXMiLCJleHRyYWN0Vmlld1ByZWZzIiwiVmlld1ByZWZlcmVuY2UiLCJndWlkZVByZWZlcmVuY2VzIiwiZXh0cmFjdEd1aWRlUHJlZnMiLCJHdWlkZVByZWZlcmVuY2UiLCJncmlkUHJlZmVyZW5jZXMiLCJleHRyYWN0R3JpZFByZWZzIiwiR3JpZFByZWZlcmVuY2UiLCJtYXJnaW5QcmVmZXJlbmNlcyIsImV4dHJhY3RNYXJnaW5QcmVmcyIsIk1hcmdpblByZWZlcmVuY2UiLCJjb2x1bW5QcmVmZXJlbmNlcyIsImV4dHJhY3RDb2x1bW5QcmVmcyIsIkNvbHVtblByZWZlcmVuY2UiLCJkb2NQcmVmIiwicGFnZVdpZHRoIiwicGFnZUhlaWdodCIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbHVtbkNvdW50IiwicGFyc2VJbnQiLCJjb2x1bW5HdXR0ZXIiLCJmYWNpbmdQYWdlcyIsImFsbG93UGFnZVNodWZmbGUiLCJzbHVnQmxlZWRUeXBlIiwiZG9jdW1lbnRCbGVlZFRvcE9mZnNldCIsImRvY3VtZW50QmxlZWRCb3R0b21PZmZzZXQiLCJkb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0IiwiZG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0Iiwidmlld1ByZWYiLCJob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cyIsInZlcnRpY2FsTWVhc3VyZW1lbnRVbml0cyIsInJ1bGVyT3JpZ2luIiwic2hvd1J1bGVycyIsImd1aWRlUHJlZiIsInJ1bGVyR3VpZGVDb2xvciIsImd1aWRlc0luQmFjayIsImd1aWRlc0xvY2tlZCIsImd1aWRlc1Nob3duIiwiZ3VpZGVzU25hcHRvIiwiZ3JpZFByZWYiLCJiYXNlbGluZVN0YXJ0IiwiYmFzZWxpbmVEaXZpc2lvbiIsImJhc2VsaW5lU2hvd24iLCJiYXNlbGluZVNuYXB0byIsImRvY3VtZW50R3JpZFNob3duIiwiZG9jdW1lbnRHcmlkU25hcHRvIiwibWFyZ2luUHJlZiIsImNvbHVtblByZWYiLCJ0ZXh0Q29sdW1uQ291bnQiLCJ0ZXh0Q29sdW1uR3V0dGVyIiwicmVzb2x2ZVN0eWxlRm9ybWF0dGluZyIsImZvcm1hdHRpbmciLCJyZXNvbHZlZCIsImhhc0FueUZvcm1hdHRpbmciLCJwYXJhZ3JhcGhTdHlsZSIsImNoYXJhY3RlclN0eWxlIiwiZm9udFJlZmVyZW5jZSIsImRpcmVjdEZvbnRTdHlsZSIsImRpcmVjdEZvbnRSZWYiLCJkaXJlY3RGb250U2l6ZSIsInBTdHlsZSIsInJlc29sdmVGb250UmVmZXJlbmNlIiwiY1N0eWxlIiwidW5kZWZpbmVkIiwiZ2V0RGVmYXVsdEZvbnQiLCJoYXMiLCJyZXNvbHZlZEZvbnQiLCJnZXQiLCJmYW1pbHlJZCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsImZpcnN0RmFtaWx5IiwidmFsdWVzIiwiaW5mZXJGb250RnJvbUNvbnRleHQiLCJmaXJzdEZvbnRGYW1pbHkiLCJnZXRTdG9yeVN0eWxlU3VtbWFyeSIsInN0b3J5Iiwic3VtbWFyeSIsImZvcm1hdHRlZENvbnRlbnQiLCJmaXJzdEZvcm1hdHRlZCIsImZpbmQiLCJpdGVtIiwiaXNCcmVhayIsImZtdCIsIm51bWVyaWNMZWFkaW5nIiwicGVyY2VudGFnZSIsInJlcGxhY2UiLCJNYXRoIiwibWF4IiwiZ2V0U3R5bGVzIiwiZ2V0UmVzb3VyY2VzIiwiZ2V0Rm9udE1hcCIsImdldFBhcmFncmFwaFN0eWxlcyIsImdldENoYXJhY3RlclN0eWxlcyIsImdldEZvbnREZWZpbml0aW9ucyIsImZyb21FbnRyaWVzIiwiZ2V0RG9jdW1lbnRJbmZvIiwiY29uc3RydWN0b3IiLCJvYmplY3QiLCJ0YWJsZSIsImNlbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/parsers/StyleParser.js\n"));

/***/ })

});