"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StoryParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StoryParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StoryParser {\n    // ADDED: Method to set document units for font size conversion\n    setDocumentUnits(units) {\n        this.documentUnits = units;\n        console.log(\"\\uD83D\\uDCD0 StoryParser: Set document units to\", units);\n    }\n    // ADDED: Method to convert font size to pixels if needed\n    convertFontSizeToPixels(fontSize) {\n        if (!fontSize || !this.unitConverter || !this.documentUnits) {\n            return fontSize;\n        }\n        // Font sizes in IDML are typically in Points, but let's use document units as fallback\n        const fontUnits = this.documentUnits === \"Pixels\" ? \"Pixels\" : \"Points\"; // Font sizes are usually points\n        if (this.unitConverter.isSupportedUnit(fontUnits)) {\n            const pixelSize = this.unitConverter.toPixels(fontSize, fontUnits);\n            console.log(\"\\uD83D\\uDCD0 Converted font size: \".concat(fontSize, \" \").concat(fontUnits, \" → \").concat(pixelSize, \" px\"));\n            return pixelSize;\n        }\n        return fontSize;\n    }\n    async parseStoryFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCDD Parsing story: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const storyId = path.basename(fileName, \".xml\");\n            const storyData = parsed.Story || parsed;\n            // ADD DEBUGGING FOR BR ELEMENTS IN RAW XML\n            console.log(\"=== RAW XML CONTENT DEBUG ===\");\n            console.log(\"Raw XML content sample:\", content.substring(0, 1000));\n            // Count Br elements in raw XML\n            const brMatches = content.match(/<Br[^>]*>/g) || [];\n            console.log(\"Found \".concat(brMatches.length, \" <Br> elements in raw XML:\"), brMatches);\n            // Look for consecutive Br elements\n            const consecutiveBrPattern = /(<Br[^>]*>\\s*){2,}/g;\n            const consecutiveBrMatches = content.match(consecutiveBrPattern) || [];\n            console.log(\"Found \".concat(consecutiveBrMatches.length, \" groups of consecutive <Br> elements:\"), consecutiveBrMatches);\n            // CRITICAL FIX: Parse raw XML to preserve document order\n            this.parseRawXMLForDocumentOrder(content, fileName);\n            // ADD THESE SIMPLE LOGS FIRST:\n            console.log(\"=== SIMPLE DEBUG TEST ===\");\n            console.log(\"Story file name:\", fileName);\n            console.log(\"Parsed story keys:\", Object.keys(storyData));\n            console.log(\"Raw story data sample:\", JSON.stringify(storyData, null, 2).substring(0, 500));\n            // Extract detailed story information\n            const detailedStory = {\n                self: storyData[\"@_Self\"],\n                appliedTOCStyle: storyData[\"@_AppliedTOCStyle\"] || \"n\",\n                userText: storyData[\"@_UserText\"] !== false,\n                // Extract story content with formatting\n                content: this.extractDetailedStoryContent(storyData, fileName),\n                // Extract text formatting\n                textFormatting: this.extractTextFormatting(storyData)\n            };\n            // ADD DEBUGGING FOR PARSED BR STRUCTURE\n            console.log(\"=== PARSED XML STRUCTURE DEBUG ===\");\n            this.debugBrElementsInParsedStructure(storyData, \"root\");\n            const cleanStoryId = storyId.replace(\"Story_\", \"\");\n            this.stories[cleanStoryId] = detailedStory;\n            // Enhanced logging to show line breaks\n            const { plainText, lineBreakInfo } = detailedStory.content;\n            console.log(\"✅ Story \".concat(storyId, \" parsed:\"));\n            console.log(\"   - Characters: \".concat(plainText.length));\n            console.log(\"   - Words: \".concat(detailedStory.content.wordCount));\n            console.log(\"   - Line breaks: \".concat((lineBreakInfo === null || lineBreakInfo === void 0 ? void 0 : lineBreakInfo.lineBreakCount) || 0));\n            console.log('   - Text preview: \"'.concat(plainText.substring(0, 50).replace(/\\n/g, \"\\\\n\"), '...\"'));\n        } catch (error) {\n            console.error(\"❌ Error parsing story \".concat(fileName, \":\"), error.message);\n        }\n    }\n    // Replace the existing extractDetailedStoryContent method with this corrected version\n    extractDetailedStoryContent(storyData) {\n        let fileName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"unknown\";\n        var _this = this;\n        let content = \"\";\n        let formattedContent = [];\n        let textColor = null;\n        let debugInfo = [];\n        const extractTextRecursively = function(element) {\n            let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (typeof element === \"string\") {\n                content += element;\n                return;\n            }\n            if (element && typeof element === \"object\") {\n                // ENHANCED: Special handling for CharacterStyleRange with sophisticated Br detection\n                if (element.CharacterStyleRange) {\n                    const ranges = Array.isArray(element.CharacterStyleRange) ? element.CharacterStyleRange : [\n                        element.CharacterStyleRange\n                    ];\n                    ranges.forEach((range, rangeIndex)=>{\n                        // Extract direct font references from the XML range\n                        const directFontRef = range[\"@_AppliedFont\"] || range[\"@_FontFamily\"] || range[\"@_Font\"] || \"\";\n                        const formatting = {\n                            paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                            characterStyle: range[\"@_AppliedCharacterStyle\"] || null,\n                            fontSize: range[\"@_PointSize\"] ? _this.convertFontSizeToPixels(parseFloat(range[\"@_PointSize\"])) // ADDED: Convert to pixels\n                             : null,\n                            originalFontSize: range[\"@_PointSize\"] ? parseFloat(range[\"@_PointSize\"]) : null,\n                            fontReference: directFontRef,\n                            fillColor: range[\"@_FillColor\"] || null,\n                            fontStyle: range[\"@_FontStyle\"] || null,\n                            // CRITICAL FIX: Inherit paragraph alignment from context if not explicitly set\n                            alignment: range[\"@_Justification\"] || range[\"@_Alignment\"] || context.paragraphAlignment || null\n                        };\n                        const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                        // CRITICAL FIX: Process Content and Br elements in document order\n                        // This handles interleaved <Content> and <Br> elements correctly\n                        content = _this.processCharacterRangeInOrder(range, resolvedFormatting, rangeIndex, ranges.length, content, formattedContent, debugInfo, context, fileName);\n                        // CRITICAL FIX: Add space between character style ranges if needed\n                        if (rangeIndex < ranges.length - 1) {\n                            const nextRange = ranges[rangeIndex + 1];\n                            // More robust space detection\n                            const currentText = content.slice(-10); // Check last 10 characters\n                            const currentRangeEndsWithSpace = /\\s$/.test(currentText); // Any whitespace at end\n                            const nextContent = nextRange.Content ? String(Array.isArray(nextRange.Content) ? nextRange.Content[0] : nextRange.Content) : \"\";\n                            const nextRangeStartsWithSpace = /^\\s/.test(nextContent); // Any whitespace at start\n                            // AGGRESSIVE FIX: Add space between ALL ranges unless explicitly not needed\n                            const shouldSkipSpace = currentRangeEndsWithSpace || nextRangeStartsWithSpace || _this.shouldInsertImplicitLineBreak(range, nextRange, context) || !nextRange.Content || // Skip if next range has no content\n                            nextContent.trim() === \"\";\n                            if (!shouldSkipSpace) {\n                                const currentStyle = range[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const nextStyle = nextRange[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const spaceText = \" \";\n                                content += spaceText;\n                                formattedContent.push({\n                                    text: spaceText,\n                                    formatting: {\n                                        isSpace: true,\n                                        source: \"between character style ranges (aggressive)\",\n                                        currentStyle,\n                                        nextStyle\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Space inserted between character styles (aggressive)\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    currentStyle,\n                                    nextStyle,\n                                    reason: \"Default space insertion - words likely split across ranges\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            } else {\n                                debugInfo.push({\n                                    type: \"Space insertion skipped\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    reason: currentRangeEndsWithSpace ? \"Current range ends with space\" : nextRangeStartsWithSpace ? \"Next range starts with space\" : !nextRange.Content ? \"Next range has no content\" : nextContent.trim() === \"\" ? \"Next content is only whitespace\" : \"Line break would be inserted\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            }\n                            // Handle explicit line breaks between ranges (for cases where shouldInsertImplicitLineBreak is true)\n                            if (_this.shouldInsertImplicitLineBreak(range, nextRange, context)) {\n                                const implicitBreak = \"\\n\";\n                                content += implicitBreak;\n                                formattedContent.push({\n                                    text: implicitBreak,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: \"implicit\",\n                                        source: \"between ranges\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Implicit line break\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1)\n                                });\n                            }\n                        }\n                    });\n                    return; // Don't continue processing to avoid duplication\n                }\n                // ENHANCED: Handle ParagraphStyleRange with context\n                if (element.ParagraphStyleRange) {\n                    const ranges = Array.isArray(element.ParagraphStyleRange) ? element.ParagraphStyleRange : [\n                        element.ParagraphStyleRange\n                    ];\n                    ranges.forEach((range, index)=>{\n                        const paragraphContext = {\n                            ...context,\n                            paragraphIndex: index,\n                            totalParagraphs: ranges.length,\n                            appliedStyle: range[\"@_AppliedParagraphStyle\"],\n                            // CRITICAL FIX: Pass down direct paragraph-level alignment\n                            paragraphAlignment: range[\"@_Justification\"] || range[\"@_Alignment\"]\n                        };\n                        // Track content length before\n                        const beforeLen = content.length;\n                        extractTextRecursively(range, depth + 1, paragraphContext);\n                        // Track content length after\n                        const afterLen = content.length;\n                        // If nothing was added, this is an empty paragraph: add a newline\n                        if (afterLen === beforeLen) {\n                            content += \"\\n\";\n                            formattedContent.push({\n                                text: \"\\n\",\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"empty-paragraph\",\n                                    source: \"empty ParagraphStyleRange\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Empty paragraph detected\",\n                                location: \"ParagraphStyleRange[\".concat(index, \"]\")\n                            });\n                        }\n                        // Add paragraph break between paragraphs (but not after the last one)\n                        if (index < ranges.length - 1) {\n                            const paragraphBreak = \"\\n\\n\"; // Use double newline for paragraph breaks\n                            content += paragraphBreak;\n                            formattedContent.push({\n                                text: paragraphBreak,\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"paragraph\",\n                                    source: \"between paragraphs\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Paragraph break\",\n                                location: \"between paragraphs \".concat(index, \" and \").concat(index + 1)\n                            });\n                        }\n                    });\n                    return;\n                }\n                // Handle direct Content elements (when not inside CharacterStyleRange)\n                if (element.Content && !element.CharacterStyleRange) {\n                    let text = Array.isArray(element.Content) ? element.Content.join(\"\") : String(element.Content);\n                    text = IDMLUtils.decodeXMLEntities(text);\n                    content += text;\n                    const formatting = {\n                        paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                        characterStyle: element[\"@_AppliedCharacterStyle\"] || null,\n                        fontSize: element[\"@_PointSize\"] || null,\n                        fontFamily: element[\"@_AppliedFont\"] || null,\n                        fillColor: element[\"@_FillColor\"] || null,\n                        // CRITICAL FIX: Inherit paragraph alignment from context if not explicitly set\n                        alignment: element[\"@_Justification\"] || element[\"@_Alignment\"] || context.paragraphAlignment || null\n                    };\n                    const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                    formattedContent.push({\n                        text: text.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                        formatting: resolvedFormatting\n                    });\n                }\n                // ENHANCED: Direct Br element handling (outside of ranges)\n                if (element.Br !== undefined) {\n                    const brElements = Array.isArray(element.Br) ? element.Br : [\n                        element.Br\n                    ];\n                    console.log(\"\\uD83D\\uDD27 Processing \".concat(brElements.length, \" direct Br elements:\"), brElements);\n                    brElements.forEach((br, index)=>{\n                        const lineBreakText = \"\\n\";\n                        console.log(\"\\uD83D\\uDD27 Direct Br element \".concat(index + 1, \"/\").concat(brElements.length, \" creates: \").concat(JSON.stringify(lineBreakText)));\n                        content += lineBreakText;\n                        formattedContent.push({\n                            text: lineBreakText,\n                            formatting: {\n                                isBreak: true,\n                                breakType: \"explicit\",\n                                source: \"direct Br element\"\n                            }\n                        });\n                        debugInfo.push({\n                            type: \"Direct Br element\",\n                            location: \"Direct element, index \".concat(index)\n                        });\n                    });\n                    console.log(\"\\uD83D\\uDD27 After processing \".concat(brElements.length, \" direct Br elements, content ends with:\"), JSON.stringify(content.slice(-10)));\n                }\n                // Continue with other nested elements\n                Object.entries(element).forEach((param)=>{\n                    let [key, value] = param;\n                    if (!key.startsWith(\"@_\") && key !== \"Content\" && key !== \"Br\" && key !== \"CharacterStyleRange\" && key !== \"ParagraphStyleRange\") {\n                        if (Array.isArray(value)) {\n                            value.forEach((item)=>extractTextRecursively(item, depth + 1, context));\n                        } else if (typeof value === \"object\" && depth < 10) {\n                            extractTextRecursively(value, depth + 1, context);\n                        }\n                    }\n                });\n            }\n        };\n        extractTextRecursively(storyData);\n        // DEBUG: Print the full raw content string with visible newlines before processing\n        console.log(\"\\uD83D\\uDCDD === COMPLETE CONTENT ANALYSIS ===\");\n        console.log(\"   - Raw content before processing:\", JSON.stringify(content));\n        console.log(\"   - Raw content newline count:\", (content.match(/\\n/g) || []).length);\n        console.log(\"   - Raw content character breakdown:\");\n        const chars = content.split(\"\").map((char, i)=>\"\".concat(i, \": \").concat(JSON.stringify(char)));\n        console.log(\"   - First 50 characters:\", chars.slice(0, 50));\n        if (content.length > 50) {\n            console.log(\"   - Last 20 characters:\", chars.slice(-20));\n        }\n        // ENHANCED: Process and clean up the content with sophisticated line break preservation\n        let processedContent = IDMLUtils.sophisticatedLineBreakProcessing(content);\n        // CRITICAL: Explicitly preserve all newlines as-is (no merging or stripping)\n        processedContent = processedContent.replace(/\\r\\n?/g, \"\\n\"); // Normalize CRLF/CR to LF\n        // Do NOT collapse multiple newlines into one; preserve as-is\n        console.log(\"\\uD83D\\uDCDD === PROCESSED CONTENT ANALYSIS ===\");\n        console.log(\"   - Processed content:\", JSON.stringify(processedContent));\n        console.log(\"   - Processed content newline count:\", (processedContent.match(/\\n/g) || []).length);\n        console.log(\"   - Content length change:\", content.length, \"→\", processedContent.length);\n        // Show differences if any\n        if (content !== processedContent) {\n            console.log(\"⚠️  CONTENT WAS MODIFIED DURING PROCESSING!\");\n            console.log(\"   - Original:\", JSON.stringify(content.slice(0, 100)));\n            console.log(\"   - Processed:\", JSON.stringify(processedContent.slice(0, 100)));\n        } else {\n            console.log(\"✅ Content preserved exactly during processing\");\n        }\n        // DEBUG: Log space preservation results\n        console.log(\"\\uD83D\\uDCDD Text extraction results:\");\n        console.log(\"   - Original content length:\", content.length);\n        console.log(\"   - Processed content length:\", processedContent.length);\n        console.log(\"   - Space preservation events:\", debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length);\n        // DEBUG: Show first 300 chars with visible newlines\n        console.log(\"   - Extracted text preview:\", JSON.stringify(processedContent.slice(0, 300)));\n        // SPECIFIC DEBUG: Check for the problematic \"pavoluptusda\" text (simplified)\n        if (processedContent.includes(\"pavoluptusda\") || processedContent.includes(\"pa\") && processedContent.includes(\"voluptusda\")) {\n            console.log(\"\\uD83D\\uDEA8 FOUND PROBLEMATIC TEXT:\");\n            console.log('   - Contains \"pavoluptusda\":', processedContent.includes(\"pavoluptusda\"));\n            console.log('   - Contains \"pa voluptusda\":', processedContent.includes(\"pa voluptusda\"));\n            console.log(\"   - FormattedContent breakdown:\", formattedContent.map((item)=>item.text).join(\"|\"));\n        }\n        const lineBreakInfo = {\n            hasLineBreaks: processedContent.includes(\"\\n\"),\n            lineBreakCount: (processedContent.match(/\\n/g) || []).length,\n            lineBreakTypes: this.analyzeLineBreakTypes(formattedContent),\n            debugInfo: debugInfo,\n            spacePreservationCount: debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length\n        };\n        return {\n            plainText: processedContent,\n            formattedContent: formattedContent.filter((item)=>item.text && item.text.length > 0),\n            wordCount: IDMLUtils.countWords(processedContent.replace(/\\n/g, \" \")),\n            characterCount: processedContent.length,\n            textColor: textColor,\n            lineBreakInfo: lineBreakInfo\n        };\n    }\n    // NEW: Process CharacterStyleRange content and breaks in document order - FULLY DYNAMIC\n    processCharacterRangeInOrder(range, resolvedFormatting, rangeIndex, totalRanges, content, formattedContent, debugInfo, context, fileName) {\n        console.log(\"\\uD83D\\uDD27 Processing CharacterStyleRange[\".concat(rangeIndex, \"] in document order:\"), {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentType: Array.isArray(range.Content) ? \"array\" : typeof range.Content,\n            brType: Array.isArray(range.Br) ? \"array\" : typeof range.Br\n        });\n        // COMPREHENSIVE EDGE CASE HANDLING\n        try {\n            // Case 1: Both Content and Br elements exist - most common case\n            if (range.Content && range.Br !== undefined) {\n                console.log(\"\\uD83D\\uDD27 Processing range with both content and breaks\");\n                return this.processInterleavedContentAndBr(range, resolvedFormatting, content, formattedContent, debugInfo, fileName);\n            } else if (range.Content && range.Br === undefined) {\n                console.log(\"\\uD83D\\uDD27 Processing range with only content\");\n                return this.processContentElements(range, resolvedFormatting, content, formattedContent, fileName);\n            } else if (!range.Content && range.Br !== undefined) {\n                console.log(\"\\uD83D\\uDD27 Processing range with only breaks\");\n                return this.processBrElements(range, content, formattedContent, debugInfo, rangeIndex, fileName);\n            } else {\n                console.log(\"⚠️ Empty range encountered - no content or breaks\");\n                return content;\n            }\n        } catch (error) {\n            // ULTIMATE FALLBACK: If anything goes wrong, try to salvage what we can\n            console.log(\"❌ Error processing CharacterStyleRange[\".concat(rangeIndex, \"]: \").concat(error.message));\n            console.log(\"\\uD83D\\uDD04 Attempting emergency content extraction...\");\n            return this.emergencyContentExtraction(range, resolvedFormatting, content, formattedContent, fileName);\n        }\n    }\n    // EMERGENCY FALLBACK: Extract content from malformed or unexpected XML structures\n    emergencyContentExtraction(range, resolvedFormatting, content, formattedContent, fileName) {\n        console.log(\"\\uD83D\\uDEA8 Emergency content extraction for unusual XML structure\");\n        try {\n            // Try to extract any text content using different approaches\n            const extractedTexts = [];\n            const extractedBreaks = [];\n            // Approach 1: Direct property access\n            if (range.Content) {\n                const contents = Array.isArray(range.Content) ? range.Content : [\n                    range.Content\n                ];\n                contents.forEach((c)=>{\n                    if (typeof c === \"string\" && c.trim()) {\n                        extractedTexts.push(c.trim());\n                    }\n                });\n            }\n            // Approach 2: Search for any text-like properties\n            Object.keys(range).forEach((key)=>{\n                if (typeof range[key] === \"string\" && range[key].trim() && key !== \"@_Self\" && !key.startsWith(\"@_\")) {\n                    extractedTexts.push(range[key].trim());\n                }\n            });\n            // Approach 3: Count any break-like properties\n            if (range.Br !== undefined) {\n                const breaks = Array.isArray(range.Br) ? range.Br : [\n                    range.Br\n                ];\n                extractedBreaks.push(...breaks);\n            }\n            // Add extracted content\n            extractedTexts.forEach((text, index)=>{\n                const cleanText = IDMLUtils.decodeXMLEntities(text);\n                content += cleanText;\n                formattedContent.push({\n                    text: cleanText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                    formatting: resolvedFormatting\n                });\n                console.log(\"\\uD83D\\uDEA8 Emergency extracted content[\".concat(index, \"]: \").concat(JSON.stringify(cleanText)));\n                // Add breaks between content items (simple 1:1 ratio)\n                if (index < extractedBreaks.length) {\n                    const lineBreakText = \"\\n\";\n                    content += lineBreakText;\n                    formattedContent.push({\n                        text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                        formatting: {\n                            isBreak: true,\n                            breakType: \"line\",\n                            source: \"emergency extraction\",\n                            emergencyIndex: index\n                        }\n                    });\n                    console.log(\"\\uD83D\\uDEA8 Emergency extracted break[\".concat(index, \"]: \").concat(JSON.stringify(lineBreakText)));\n                }\n            });\n            // Add any remaining breaks at the end\n            for(let i = extractedTexts.length; i < extractedBreaks.length; i++){\n                const lineBreakText = \"\\n\";\n                content += lineBreakText;\n                formattedContent.push({\n                    text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                    formatting: {\n                        isBreak: true,\n                        breakType: \"line\",\n                        source: \"emergency trailing break\",\n                        emergencyIndex: i\n                    }\n                });\n                console.log(\"\\uD83D\\uDEA8 Emergency extracted trailing break[\".concat(i, \"]: \").concat(JSON.stringify(lineBreakText)));\n            }\n            console.log(\"✅ Emergency extraction successful: \".concat(extractedTexts.length, \" texts, \").concat(extractedBreaks.length, \" breaks\"));\n        } catch (emergencyError) {\n            console.log(\"\\uD83D\\uDC80 Emergency extraction failed: \".concat(emergencyError.message));\n            // Last resort: just add a warning comment\n            const warningText = \"<!-- XML parsing error -->\";\n            content += warningText;\n            formattedContent.push({\n                text: warningText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: resolvedFormatting\n            });\n        }\n        return content;\n    }\n    // Process interleaved Content and Br elements - FULLY DYNAMIC\n    processInterleavedContentAndBr(range, resolvedFormatting, content, formattedContent, debugInfo, fileName) {\n        const contents = Array.isArray(range.Content) ? range.Content : [\n            range.Content\n        ];\n        const brElements = Array.isArray(range.Br) ? range.Br : [\n            range.Br\n        ];\n        console.log(\"\\uD83D\\uDD27 Processing interleaved content: \".concat(contents.length, \" content items, \").concat(brElements.length, \" Br elements\"));\n        // EDGE CASE: No content or breaks\n        if (!range.Content && !range.Br) {\n            console.log(\"⚠️ No content or breaks to process in range\");\n            return content;\n        }\n        // EDGE CASE: Only content, no breaks\n        if (range.Content && !range.Br) {\n            console.log(\"\\uD83D\\uDCDD Only content, no breaks - processing content only\");\n            return this.processContentElements(range, resolvedFormatting, content, formattedContent, fileName);\n        }\n        // EDGE CASE: Only breaks, no content\n        if (!range.Content && range.Br) {\n            console.log(\"\\uD83D\\uDD17 Only breaks, no content - processing breaks only\");\n            return this.processBrElements(range, content, formattedContent, debugInfo, 0, fileName);\n        }\n        // DYNAMIC: Try to use cached document order if available\n        const cachedOrder = this.documentOrderCache && this.documentOrderCache[fileName];\n        if (cachedOrder && cachedOrder.breakPattern && cachedOrder.breakPattern.length > 0) {\n            console.log(\"✅ Using cached document order for precise break distribution\");\n            try {\n                return this.processContentWithCachedPattern(contents, resolvedFormatting, content, formattedContent, cachedOrder.breakPattern, fileName);\n            } catch (error) {\n                console.log(\"❌ Error using cached pattern: \".concat(error.message, \", falling back to dynamic distribution\"));\n            }\n        } else {\n            console.log(\"⚠️ No cached document order available, using dynamic fallback distribution\");\n        }\n        // DYNAMIC FALLBACK: Distribute breaks intelligently based on content structure\n        return this.processInterleavedContentDynamicFallback(contents, brElements, resolvedFormatting, content, formattedContent, fileName);\n    }\n    // DYNAMIC FALLBACK: Intelligent break distribution for any content structure\n    processInterleavedContentDynamicFallback(contents, brElements, resolvedFormatting, content, formattedContent, fileName) {\n        console.log(\"\\uD83D\\uDD04 Using dynamic fallback for \".concat(contents.length, \" content items and \").concat(brElements.length, \" breaks\"));\n        let brIndex = 0;\n        const contentLength = contents.length;\n        contents.forEach((contentItem, contentIndex)=>{\n            // Add the content\n            const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n            content += text;\n            formattedContent.push({\n                text: text.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: resolvedFormatting\n            });\n            console.log(\"\\uD83D\\uDD27 Added content[\".concat(contentIndex, \"]: \").concat(JSON.stringify(text)));\n            // DYNAMIC: Calculate how many breaks to add after this content\n            const breaksToAdd = this.calculateBreaksAfterContent(contentIndex, contentLength, brElements.length);\n            // Add the calculated number of breaks\n            for(let i = 0; i < breaksToAdd && brIndex < brElements.length; i++){\n                const lineBreakText = \"\\n\";\n                content += lineBreakText;\n                formattedContent.push({\n                    text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                    formatting: {\n                        isBreak: true,\n                        breakType: \"line\",\n                        source: \"dynamic fallback distribution\",\n                        brIndex: brIndex,\n                        afterContent: contentIndex,\n                        calculatedBreaks: breaksToAdd\n                    }\n                });\n                console.log(\"\\uD83D\\uDD27 Added Br[\".concat(brIndex, \"] after content[\").concat(contentIndex, \"]: \").concat(JSON.stringify(lineBreakText)));\n                brIndex++;\n            }\n        });\n        // EDGE CASE: Handle any remaining breaks\n        if (brIndex < brElements.length) {\n            const remainingBreaks = brElements.length - brIndex;\n            console.log(\"\\uD83D\\uDD27 Adding \".concat(remainingBreaks, \" remaining breaks at the end\"));\n            while(brIndex < brElements.length){\n                const lineBreakText = \"\\n\";\n                content += lineBreakText;\n                formattedContent.push({\n                    text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                    formatting: {\n                        isBreak: true,\n                        breakType: \"line\",\n                        source: \"trailing breaks (dynamic fallback)\",\n                        brIndex: brIndex\n                    }\n                });\n                console.log(\"\\uD83D\\uDD27 Added trailing Br[\".concat(brIndex, \"]: \").concat(JSON.stringify(lineBreakText)));\n                brIndex++;\n            }\n        }\n        // VALIDATION: Ensure all breaks were processed\n        if (brIndex !== brElements.length) {\n            console.log(\"⚠️ Warning: Expected to process \".concat(brElements.length, \" breaks but processed \").concat(brIndex));\n        }\n        return content;\n    }\n    // Process content using cached document order pattern - FULLY DYNAMIC\n    processContentWithCachedPattern(contents, resolvedFormatting, content, formattedContent, breakPattern, fileName) {\n        console.log(\"\\uD83C\\uDFAF Processing \".concat(contents.length, \" content items with cached pattern (\").concat(breakPattern.length, \" pattern entries)\"));\n        // DYNAMIC: Handle any number of content items and any break distribution\n        contents.forEach((contentItem, contentIndex)=>{\n            // Add the content\n            const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n            content += text;\n            formattedContent.push({\n                text: text.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: resolvedFormatting\n            });\n            console.log(\"\\uD83D\\uDD27 Added content[\".concat(contentIndex, \"]: \").concat(JSON.stringify(text)));\n            // DYNAMIC: Find the corresponding pattern entry\n            const patternEntry = breakPattern.find((p)=>p.contentIndex === contentIndex);\n            if (patternEntry) {\n                const breaksToAdd = patternEntry.breaksAfter;\n                console.log(\"\\uD83C\\uDFAF Pattern says content[\".concat(contentIndex, \"] should have \").concat(breaksToAdd, \" breaks after it\"));\n                // DYNAMIC: Add the exact number of breaks specified in the pattern\n                for(let i = 0; i < breaksToAdd; i++){\n                    const lineBreakText = \"\\n\";\n                    content += lineBreakText;\n                    formattedContent.push({\n                        text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                        formatting: {\n                            isBreak: true,\n                            breakType: \"line\",\n                            source: \"precise document order\",\n                            contentIndex: contentIndex,\n                            breakIndex: i,\n                            totalBreaksAfterContent: breaksToAdd,\n                            patternEntry: patternEntry\n                        }\n                    });\n                    console.log(\"\\uD83C\\uDFAF Added precise Br[\".concat(i + 1, \"/\").concat(breaksToAdd, \"] after content[\").concat(contentIndex, \"]: \").concat(JSON.stringify(lineBreakText)));\n                }\n            } else {\n                console.log(\"⚠️ No pattern entry found for content[\".concat(contentIndex, \"] - this is unusual but not critical\"));\n            // DYNAMIC: If no pattern entry, don't add any breaks (the pattern should cover all content)\n            }\n        });\n        // VALIDATION: Check if we processed all expected content\n        const expectedContentCount = breakPattern.length;\n        if (contents.length !== expectedContentCount) {\n            console.log(\"⚠️ Warning: Expected \".concat(expectedContentCount, \" content items but processed \").concat(contents.length));\n        }\n        return content;\n    }\n    // DYNAMIC: Calculate breaks distribution as fallback - completely generic\n    calculateBreaksAfterContent(contentIndex, totalContent, totalBreaks) {\n        console.log(\"\\uD83D\\uDD27 FALLBACK: Calculating breaks for content[\".concat(contentIndex, \"] of \").concat(totalContent, \" total, \").concat(totalBreaks, \" total breaks\"));\n        // EDGE CASE: No breaks to distribute\n        if (totalBreaks === 0) {\n            console.log(\"\\uD83D\\uDD27 No breaks to distribute\");\n            return 0;\n        }\n        // EDGE CASE: Only one content item\n        if (totalContent === 1) {\n            console.log(\"\\uD83D\\uDD27 Single content item gets all \".concat(totalBreaks, \" breaks\"));\n            return contentIndex === 0 ? totalBreaks : 0;\n        }\n        // EDGE CASE: Last content item\n        if (contentIndex === totalContent - 1) {\n            console.log(\"\\uD83D\\uDD27 Last content item gets no breaks in standard distribution\");\n            return 0;\n        }\n        // DYNAMIC: Distribute breaks among non-last content items\n        const nonLastContentItems = totalContent - 1;\n        const baseBreaks = Math.floor(totalBreaks / nonLastContentItems);\n        const extraBreaks = totalBreaks % nonLastContentItems;\n        // DYNAMIC: Distribute extra breaks starting from the end to match common IDML patterns\n        // where later content tends to have more breaks\n        const breaksForThisContent = baseBreaks + (contentIndex >= nonLastContentItems - extraBreaks ? 1 : 0);\n        console.log(\"\\uD83D\\uDD27 Content[\".concat(contentIndex, \"] gets \").concat(breaksForThisContent, \" breaks (base: \").concat(baseBreaks, \", extra: \").concat(extraBreaks, \")\"));\n        return breaksForThisContent;\n    }\n    // Process only Content elements\n    processContentElements(range, resolvedFormatting, content, formattedContent, fileName) {\n        const contents = Array.isArray(range.Content) ? range.Content : [\n            range.Content\n        ];\n        contents.forEach((contentItem)=>{\n            const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n            content += text;\n            formattedContent.push({\n                text: text.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: resolvedFormatting\n            });\n        });\n        return content;\n    }\n    // Process only Br elements\n    processBrElements(range, content, formattedContent, debugInfo, rangeIndex, fileName) {\n        const brElements = Array.isArray(range.Br) ? range.Br : [\n            range.Br\n        ];\n        brElements.forEach((br, brIndex)=>{\n            const lineBreakText = \"\\n\";\n            content += lineBreakText;\n            formattedContent.push({\n                text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: {\n                    isBreak: true,\n                    breakType: \"line\",\n                    source: \"standalone Br element\",\n                    rangeIndex: rangeIndex,\n                    brIndex: brIndex\n                }\n            });\n            debugInfo.push({\n                type: \"Standalone Br element\",\n                location: \"CharacterStyleRange[\".concat(rangeIndex, \"], Br[\").concat(brIndex, \"]\")\n            });\n        });\n        return content;\n    }\n    // Add this helper method to better handle mixed content and Br elements\n    analyzeContentStructure(range) {\n        const structure = {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentItems: range.Content ? Array.isArray(range.Content) ? range.Content : [\n                range.Content\n            ] : [],\n            brElements: range.Br ? Array.isArray(range.Br) ? range.Br : [\n                range.Br\n            ] : []\n        };\n        console.log(\"Content structure analysis:\", structure);\n        return structure;\n    }\n    // Enhanced helper for processing interleaved content and breaks\n    processInterleavedContent(range, resolvedFormatting) {\n        const results = [];\n        let content = \"\";\n        // This method would need access to the actual XML structure to determine\n        // the exact order of Content and Br elements. For now, we'll use the\n        // approach above which handles the most common case.\n        return results;\n    }\n    // SOPHISTICATED: Helper method to extract Br elements with context\n    extractBrElements(range) {\n        const brElements = [];\n        if (range.Br !== undefined) {\n            console.log(\"\\uD83D\\uDD27 Processing Br elements:\", {\n                isArray: Array.isArray(range.Br),\n                count: Array.isArray(range.Br) ? range.Br.length : 1,\n                rawBr: range.Br\n            });\n            if (Array.isArray(range.Br)) {\n                range.Br.forEach((br, index)=>{\n                    brElements.push({\n                        type: \"line\",\n                        position: index === 0 ? \"start\" : \"middle\",\n                        element: br\n                    });\n                });\n                console.log(\"\\uD83D\\uDD27 Created \".concat(brElements.length, \" line break elements from array - EACH SHOULD CREATE ONE \\\\n\"));\n            } else {\n                brElements.push({\n                    type: \"line\",\n                    position: \"end\",\n                    element: range.Br\n                });\n                console.log(\"\\uD83D\\uDD27 Created 1 line break element from single Br\");\n            }\n        }\n        return brElements;\n    }\n    // SOPHISTICATED: Determine the appropriate line break type\n    determineLineBreakType(brInfo, context) {\n        // Different line break characters based on context\n        switch(brInfo.type){\n            case \"paragraph\":\n                return \"\\n\\n\"; // Double line break for paragraph separation\n            case \"forced\":\n                return \"\\n\"; // Forced line break (Shift+Enter equivalent)\n            case \"line\":\n            default:\n                return \"\\n\"; // Standard line break\n        }\n    }\n    // SOPHISTICATED: Determine if an implicit line break should be inserted\n    shouldInsertImplicitLineBreak(currentRange, nextRange, context) {\n        // Don't insert implicit breaks if explicit Br elements are present\n        if (currentRange.Br !== undefined || nextRange.Br !== undefined) {\n            return false;\n        }\n        // Insert breaks between different character styles in different paragraphs\n        const currentCharStyle = currentRange[\"@_AppliedCharacterStyle\"];\n        const nextCharStyle = nextRange[\"@_AppliedCharacterStyle\"];\n        // If we're in a context where styles change significantly, add a break\n        if (currentCharStyle && nextCharStyle && currentCharStyle !== nextCharStyle) {\n            // Check if this might be a title/heading followed by body text\n            const styleIndicatesBreak = this.styleIndicatesLineBreak(currentCharStyle, nextCharStyle);\n            return styleIndicatesBreak;\n        }\n        return false;\n    }\n    // SOPHISTICATED: Analyze if style change indicates a line break\n    styleIndicatesLineBreak(currentStyle, nextStyle) {\n        const titleIndicators = [\n            \"title\",\n            \"heading\",\n            \"header\"\n        ];\n        const bodyIndicators = [\n            \"body\",\n            \"text\",\n            \"normal\"\n        ];\n        const currentIsTitle = titleIndicators.some((indicator)=>currentStyle.toLowerCase().includes(indicator));\n        const nextIsBody = bodyIndicators.some((indicator)=>nextStyle.toLowerCase().includes(indicator));\n        return currentIsTitle && nextIsBody;\n    }\n    // SOPHISTICATED: Analyze line break types in formatted content\n    analyzeLineBreakTypes(formattedContent) {\n        const types = {\n            explicit: 0,\n            implicit: 0,\n            paragraph: 0,\n            direct: 0\n        };\n        formattedContent.forEach((item)=>{\n            var _item_formatting;\n            if ((_item_formatting = item.formatting) === null || _item_formatting === void 0 ? void 0 : _item_formatting.isBreak) {\n                const breakType = item.formatting.breakType || \"unknown\";\n                if (types.hasOwnProperty(breakType)) {\n                    types[breakType]++;\n                }\n            }\n        });\n        return types;\n    }\n    extractDetailedFormattingFromRange(range) {\n        const formatting = {};\n        // Extract all possible font attributes\n        const fontAttributes = [\n            \"@_AppliedFont\",\n            \"@_FontFamily\",\n            \"@_Font\",\n            \"@_PostScriptName\",\n            \"@_FontName\"\n        ];\n        fontAttributes.forEach((attr)=>{\n            if (range[attr]) {\n                formatting.fontReference = range[attr];\n            }\n        });\n        // Extract font and size attributes\n        const rawFontSize = IDMLUtils.parseNumeric(range[\"@_PointSize\"]);\n        formatting.fontSize = this.convertFontSizeToPixels(rawFontSize); // ADDED: Convert to pixels\n        formatting.originalFontSize = rawFontSize; // ADDED: Preserve original\n        // ENHANCED: Extract leading with proper processing\n        const rawLeading = range[\"@_Leading\"];\n        formatting.leading = this.processLeadingValue(rawLeading, formatting.fontSize);\n        formatting.leadingType = this.determineLeadingType(rawLeading);\n        // Extract color and style attributes\n        formatting.fillColor = range[\"@_FillColor\"];\n        formatting.strokeColor = range[\"@_StrokeColor\"];\n        formatting.fontStyle = range[\"@_FontStyle\"];\n        // Extract advanced typography attributes\n        formatting.tracking = IDMLUtils.parseNumeric(range[\"@_Tracking\"]);\n        formatting.baselineShift = IDMLUtils.parseNumeric(range[\"@_BaselineShift\"]);\n        formatting.kerning = IDMLUtils.parseNumeric(range[\"@_Kerning\"]);\n        formatting.horizontalScale = IDMLUtils.parseNumeric(range[\"@_HorizontalScale\"]) || 100;\n        formatting.verticalScale = IDMLUtils.parseNumeric(range[\"@_VerticalScale\"]) || 100;\n        // ENHANCED: Extract InDesign-specific text layout properties for precise rendering\n        formatting.baselineGridAlign = range[\"@_AlignToBaseline\"] || \"None\";\n        formatting.dropCapLines = IDMLUtils.parseNumeric(range[\"@_DropCapLines\"]) || 0;\n        formatting.dropCapCharacters = IDMLUtils.parseNumeric(range[\"@_DropCapCharacters\"]) || 0;\n        // Extract paragraph-level attributes if present\n        // CRITICAL FIX: Only set alignment if explicitly specified, allowing paragraph inheritance\n        const explicitAlignment = range[\"@_Justification\"] || range[\"@_Alignment\"];\n        if (explicitAlignment) {\n            formatting.alignment = explicitAlignment;\n        }\n        formatting.leftIndent = IDMLUtils.parseNumeric(range[\"@_LeftIndent\"]);\n        formatting.rightIndent = IDMLUtils.parseNumeric(range[\"@_RightIndent\"]);\n        formatting.firstLineIndent = IDMLUtils.parseNumeric(range[\"@_FirstLineIndent\"]);\n        formatting.spaceBefore = IDMLUtils.parseNumeric(range[\"@_SpaceBefore\"]);\n        formatting.spaceAfter = IDMLUtils.parseNumeric(range[\"@_SpaceAfter\"]);\n        // Calculate effective line height for CSS\n        formatting.effectiveLineHeight = this.calculateEffectiveLineHeight(formatting);\n        return formatting;\n    }\n    // FIXED: Process leading values with InDesign-specific logic and convert to pixels\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points) - FIXED: Convert to pixels\n        const numericLeading = IDMLUtils.parseNumeric(rawLeading);\n        if (numericLeading) {\n            // FIXED: Convert numeric leading to pixels if unitConverter is available\n            if (this.unitConverter && this.documentUnits && this.unitConverter.isSupportedUnit(this.documentUnits)) {\n                const pixelLeading = this.unitConverter.toPixels(numericLeading, this.documentUnits);\n                console.log(\"\\uD83D\\uDCD0 Converted leading: \".concat(numericLeading, \" \").concat(this.documentUnits, \" → \").concat(pixelLeading, \" px\"));\n                return pixelLeading;\n            }\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (IDMLUtils.parseNumeric(rawLeading)) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(formatting) {\n        const fontSize = formatting.fontSize || 12;\n        const leading = formatting.leading;\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\") {\n            // Convert points to CSS line-height ratio\n            return leading / fontSize;\n        }\n        return 1.2; // Fallback\n    }\n    extractTextFormatting(storyData) {\n        const formatting = {\n            paragraphStyles: [],\n            characterStyles: [],\n            appliedStyles: []\n        };\n        // Extract applied paragraph styles\n        if (storyData.ParagraphStyleRange) {\n            const ranges = Array.isArray(storyData.ParagraphStyleRange) ? storyData.ParagraphStyleRange : [\n                storyData.ParagraphStyleRange\n            ];\n            ranges.forEach((range)=>{\n                const appliedStyle = range[\"@_AppliedParagraphStyle\"];\n                if (appliedStyle && !formatting.paragraphStyles.includes(appliedStyle)) {\n                    formatting.paragraphStyles.push(appliedStyle);\n                }\n                // Extract character styles within paragraph ranges\n                if (range.CharacterStyleRange) {\n                    const charRanges = Array.isArray(range.CharacterStyleRange) ? range.CharacterStyleRange : [\n                        range.CharacterStyleRange\n                    ];\n                    charRanges.forEach((charRange)=>{\n                        const charStyle = charRange[\"@_AppliedCharacterStyle\"];\n                        if (charStyle && !formatting.characterStyles.includes(charStyle)) {\n                            formatting.characterStyles.push(charStyle);\n                        }\n                    });\n                }\n            });\n        }\n        return formatting;\n    }\n    // Add this method to debug raw story content\n    debugRawStoryContent(storyData) {\n        console.log(\"\\n\\uD83D\\uDD0D RAW STORY CONTENT DEBUG:\");\n        console.log(\"Story keys:\", Object.keys(storyData));\n        const findCharacterRanges = function(obj) {\n            let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key === \"CharacterStyleRange\") {\n                        console.log(\"\\n\\uD83D\\uDCDD Found CharacterStyleRange at \".concat(path, \":\"), obj[key]);\n                        const ranges = Array.isArray(obj[key]) ? obj[key] : [\n                            obj[key]\n                        ];\n                        ranges.forEach((range, index)=>{\n                            console.log(\"  Range \".concat(index + 1, \" attributes:\"), Object.keys(range).filter((k)=>k.startsWith(\"@_\")));\n                            console.log(\"  Range \".concat(index + 1, \" font info:\"), {\n                                AppliedFont: range[\"@_AppliedFont\"],\n                                FontStyle: range[\"@_FontStyle\"],\n                                PointSize: range[\"@_PointSize\"]\n                            });\n                        });\n                    } else if (typeof obj[key] === \"object\") {\n                        findCharacterRanges(obj[key], \"\".concat(path, \".\").concat(key));\n                    }\n                });\n            }\n        };\n        findCharacterRanges(storyData);\n    }\n    // ADD DEBUGGING FOR PARSED BR STRUCTURE\n    debugBrElementsInParsedStructure(parsedData) {\n        let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n        if (typeof parsedData === \"object\" && parsedData !== null) {\n            Object.entries(parsedData).forEach((param)=>{\n                let [key, value] = param;\n                if (key === \"Br\") {\n                    console.log(\"\".concat(path, \" has Br element:\"), value);\n                } else if (typeof value === \"object\" && value !== null) {\n                    this.debugBrElementsInParsedStructure(value, \"\".concat(path, \".\").concat(key));\n                }\n            });\n        }\n    }\n    // CRITICAL FIX: Parse raw XML to preserve exact document order - FULLY DYNAMIC\n    parseRawXMLForDocumentOrder(rawXMLContent, fileName) {\n        console.log(\"\\uD83D\\uDD0D Parsing raw XML for document order: \".concat(fileName));\n        // DYNAMIC: Handle multiple CharacterStyleRange elements\n        const charRangePattern = RegExp(\"<CharacterStyleRange[^>]*>(.*?)<\\\\/CharacterStyleRange>\", \"gs\");\n        const charRangeMatches = [\n            ...rawXMLContent.matchAll(charRangePattern)\n        ];\n        if (charRangeMatches.length === 0) {\n            console.log(\"❌ No CharacterStyleRange found in XML\");\n            return null;\n        }\n        console.log(\"\\uD83D\\uDCC4 Found \".concat(charRangeMatches.length, \" CharacterStyleRange elements\"));\n        // DYNAMIC: Process all CharacterStyleRange elements\n        const allDocumentOrder = [];\n        charRangeMatches.forEach((match, rangeIndex)=>{\n            const charRangeContent = match[1];\n            console.log(\"\\uD83D\\uDCC4 Processing CharacterStyleRange[\".concat(rangeIndex, \"]:\"), charRangeContent.substring(0, 200) + \"...\");\n            // ENHANCED: More flexible pattern to handle different XML structures\n            // Matches: <Content>text</Content>, <Content/>, <Br/>, <Br></Br>, <Br />\n            const elementPattern = /<(Content|Br)(?:\\s+[^>]*)?>([^<]*)<\\/\\1>|<(Content|Br)(?:\\s+[^>]*)?\\/?>|<(Content|Br)(?:\\s+[^>]*)?>([^<]*)/g;\n            let elementMatch;\n            const rangeElements = [];\n            while((elementMatch = elementPattern.exec(charRangeContent)) !== null){\n                const elementType = elementMatch[1] || elementMatch[3] || elementMatch[4];\n                const elementContent = elementMatch[2] || elementMatch[5] || \"\";\n                if (elementType === \"Content\") {\n                    const contentText = elementContent.trim();\n                    if (contentText) {\n                        // Only add non-empty content\n                        rangeElements.push({\n                            type: \"Content\",\n                            text: contentText,\n                            rangeIndex: rangeIndex\n                        });\n                        console.log(\"\\uD83D\\uDCDD Found Content[\".concat(rangeIndex, ']: \"').concat(contentText, '\"'));\n                    }\n                } else if (elementType === \"Br\") {\n                    rangeElements.push({\n                        type: \"Br\",\n                        rangeIndex: rangeIndex\n                    });\n                    console.log(\"\\uD83D\\uDD17 Found Br[\".concat(rangeIndex, \"]\"));\n                }\n            }\n            // Add range elements to overall document order\n            allDocumentOrder.push(...rangeElements);\n        });\n        if (allDocumentOrder.length === 0) {\n            console.log(\"❌ No Content or Br elements found in any CharacterStyleRange\");\n            return null;\n        }\n        // DYNAMIC: Analyze the break pattern for any structure\n        const breakPattern = this.analyzeBreakPatternDynamic(allDocumentOrder);\n        console.log(\"\\uD83D\\uDCCA Dynamic break pattern analysis:\", breakPattern);\n        // Store this for later use in processing\n        this.documentOrderCache = this.documentOrderCache || {};\n        this.documentOrderCache[fileName] = {\n            documentOrder: allDocumentOrder,\n            breakPattern: breakPattern,\n            totalCharacterRanges: charRangeMatches.length\n        };\n        return {\n            documentOrder: allDocumentOrder,\n            breakPattern: breakPattern,\n            totalCharacterRanges: charRangeMatches.length\n        };\n    }\n    // DYNAMIC: Analyze break pattern for any document structure\n    analyzeBreakPatternDynamic(documentOrder) {\n        const pattern = [];\n        let contentIndex = 0;\n        for(let i = 0; i < documentOrder.length; i++){\n            const element = documentOrder[i];\n            if (element.type === \"Content\") {\n                // DYNAMIC: Count consecutive breaks after this content\n                let breaksAfter = 0;\n                let j = i + 1;\n                // Count all consecutive Br elements following this Content\n                while(j < documentOrder.length && documentOrder[j].type === \"Br\"){\n                    breaksAfter++;\n                    j++;\n                }\n                pattern.push({\n                    contentIndex: contentIndex,\n                    contentText: element.text,\n                    breaksAfter: breaksAfter,\n                    rangeIndex: element.rangeIndex,\n                    documentPosition: i\n                });\n                console.log(\"\\uD83D\\uDCCB Content[\".concat(contentIndex, '] \"').concat(element.text, '\" has ').concat(breaksAfter, \" breaks after it (doc pos: \").concat(i, \")\"));\n                contentIndex++;\n            }\n        }\n        // VALIDATION: Ensure pattern makes sense\n        const totalContent = pattern.length;\n        const totalBreaks = pattern.reduce((sum, p)=>sum + p.breaksAfter, 0);\n        console.log(\"\\uD83D\\uDD0D Pattern validation: \".concat(totalContent, \" content items, \").concat(totalBreaks, \" total breaks\"));\n        if (totalContent === 0) {\n            console.log(\"⚠️ Warning: No content items found in pattern\");\n        }\n        return pattern;\n    }\n    getStories() {\n        return this.stories;\n    }\n    getStory(storyId) {\n        return this.stories[storyId];\n    }\n    clearStories() {\n        this.stories = {};\n    }\n    constructor(styleParser, unitConverter = null){\n        this.styleParser = styleParser;\n        this.unitConverter = unitConverter; // ADDED: Unit converter for font sizes and spacing\n        this.documentUnits = null; // Will be set from document units\n        this.stories = {};\n    }\n}\nmodule.exports = StoryParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDbFAsT0FBTztJQUNyQjtJQUVBbVAsU0FBUzVRLE9BQU8sRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQ3lCLE9BQU8sQ0FBQ3pCLFFBQVE7SUFDOUI7SUFFQTZRLGVBQWU7UUFDYixJQUFJLENBQUNwUCxPQUFPLEdBQUcsQ0FBQztJQUNsQjtJQS9tREFxUCxZQUFZbk4sV0FBVyxFQUFFdEUsZ0JBQWdCLElBQUksQ0FBRTtRQUM3QyxJQUFJLENBQUNzRSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ3RFLGFBQWEsR0FBR0EsZUFBZSxtREFBbUQ7UUFDdkYsSUFBSSxDQUFDTCxhQUFhLEdBQUcsTUFBTSxrQ0FBa0M7UUFDN0QsSUFBSSxDQUFDeUMsT0FBTyxHQUFHLENBQUM7SUFDbEI7QUEybURGO0FBRUFzUCxPQUFPQyxPQUFPLEdBQUduUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGFyc2Vycy9TdG9yeVBhcnNlci5qcz82OGNmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgSURNTFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL0lETUxVdGlsc1wiKTtcclxuXHJcbmNsYXNzIFN0b3J5UGFyc2VyIHtcclxuICBjb25zdHJ1Y3RvcihzdHlsZVBhcnNlciwgdW5pdENvbnZlcnRlciA9IG51bGwpIHtcclxuICAgIHRoaXMuc3R5bGVQYXJzZXIgPSBzdHlsZVBhcnNlcjtcclxuICAgIHRoaXMudW5pdENvbnZlcnRlciA9IHVuaXRDb252ZXJ0ZXI7IC8vIEFEREVEOiBVbml0IGNvbnZlcnRlciBmb3IgZm9udCBzaXplcyBhbmQgc3BhY2luZ1xyXG4gICAgdGhpcy5kb2N1bWVudFVuaXRzID0gbnVsbDsgLy8gV2lsbCBiZSBzZXQgZnJvbSBkb2N1bWVudCB1bml0c1xyXG4gICAgdGhpcy5zdG9yaWVzID0ge307XHJcbiAgfVxyXG5cclxuICAvLyBBRERFRDogTWV0aG9kIHRvIHNldCBkb2N1bWVudCB1bml0cyBmb3IgZm9udCBzaXplIGNvbnZlcnNpb25cclxuICBzZXREb2N1bWVudFVuaXRzKHVuaXRzKSB7XHJcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSB1bml0cztcclxuICAgIGNvbnNvbGUubG9nKFwi8J+TkCBTdG9yeVBhcnNlcjogU2V0IGRvY3VtZW50IHVuaXRzIHRvXCIsIHVuaXRzKTtcclxuICB9XHJcblxyXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gY29udmVydCBmb250IHNpemUgdG8gcGl4ZWxzIGlmIG5lZWRlZFxyXG4gIGNvbnZlcnRGb250U2l6ZVRvUGl4ZWxzKGZvbnRTaXplKSB7XHJcbiAgICBpZiAoIWZvbnRTaXplIHx8ICF0aGlzLnVuaXRDb252ZXJ0ZXIgfHwgIXRoaXMuZG9jdW1lbnRVbml0cykge1xyXG4gICAgICByZXR1cm4gZm9udFNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9udCBzaXplcyBpbiBJRE1MIGFyZSB0eXBpY2FsbHkgaW4gUG9pbnRzLCBidXQgbGV0J3MgdXNlIGRvY3VtZW50IHVuaXRzIGFzIGZhbGxiYWNrXHJcbiAgICBjb25zdCBmb250VW5pdHMgPSB0aGlzLmRvY3VtZW50VW5pdHMgPT09IFwiUGl4ZWxzXCIgPyBcIlBpeGVsc1wiIDogXCJQb2ludHNcIjsgLy8gRm9udCBzaXplcyBhcmUgdXN1YWxseSBwb2ludHNcclxuXHJcbiAgICBpZiAodGhpcy51bml0Q29udmVydGVyLmlzU3VwcG9ydGVkVW5pdChmb250VW5pdHMpKSB7XHJcbiAgICAgIGNvbnN0IHBpeGVsU2l6ZSA9IHRoaXMudW5pdENvbnZlcnRlci50b1BpeGVscyhmb250U2l6ZSwgZm9udFVuaXRzKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYPCfk5AgQ29udmVydGVkIGZvbnQgc2l6ZTogJHtmb250U2l6ZX0gJHtmb250VW5pdHN9IOKGkiAke3BpeGVsU2l6ZX0gcHhgXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBwaXhlbFNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvbnRTaXplO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcGFyc2VTdG9yeUZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coYPCfk50gUGFyc2luZyBzdG9yeTogJHtmaWxlTmFtZX1gKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSB4bWxQYXJzZXIucGFyc2UoY29udGVudCk7XHJcbiAgICAgIGNvbnN0IHN0b3J5SWQgPSBwYXRoLmJhc2VuYW1lKGZpbGVOYW1lLCBcIi54bWxcIik7XHJcblxyXG4gICAgICBjb25zdCBzdG9yeURhdGEgPSBwYXJzZWQuU3RvcnkgfHwgcGFyc2VkO1xyXG5cclxuICAgICAgLy8gQUREIERFQlVHR0lORyBGT1IgQlIgRUxFTUVOVFMgSU4gUkFXIFhNTFxyXG4gICAgICBjb25zb2xlLmxvZyhcIj09PSBSQVcgWE1MIENPTlRFTlQgREVCVUcgPT09XCIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlJhdyBYTUwgY29udGVudCBzYW1wbGU6XCIsIGNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMDApKTtcclxuXHJcbiAgICAgIC8vIENvdW50IEJyIGVsZW1lbnRzIGluIHJhdyBYTUxcclxuICAgICAgY29uc3QgYnJNYXRjaGVzID0gY29udGVudC5tYXRjaCgvPEJyW14+XSo+L2cpIHx8IFtdO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgRm91bmQgJHtick1hdGNoZXMubGVuZ3RofSA8QnI+IGVsZW1lbnRzIGluIHJhdyBYTUw6YCxcclxuICAgICAgICBick1hdGNoZXNcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIExvb2sgZm9yIGNvbnNlY3V0aXZlIEJyIGVsZW1lbnRzXHJcbiAgICAgIGNvbnN0IGNvbnNlY3V0aXZlQnJQYXR0ZXJuID0gLyg8QnJbXj5dKj5cXHMqKXsyLH0vZztcclxuICAgICAgY29uc3QgY29uc2VjdXRpdmVCck1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKGNvbnNlY3V0aXZlQnJQYXR0ZXJuKSB8fCBbXTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYEZvdW5kICR7Y29uc2VjdXRpdmVCck1hdGNoZXMubGVuZ3RofSBncm91cHMgb2YgY29uc2VjdXRpdmUgPEJyPiBlbGVtZW50czpgLFxyXG4gICAgICAgIGNvbnNlY3V0aXZlQnJNYXRjaGVzXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBDUklUSUNBTCBGSVg6IFBhcnNlIHJhdyBYTUwgdG8gcHJlc2VydmUgZG9jdW1lbnQgb3JkZXJcclxuICAgICAgdGhpcy5wYXJzZVJhd1hNTEZvckRvY3VtZW50T3JkZXIoY29udGVudCwgZmlsZU5hbWUpO1xyXG5cclxuICAgICAgLy8gQUREIFRIRVNFIFNJTVBMRSBMT0dTIEZJUlNUOlxyXG4gICAgICBjb25zb2xlLmxvZyhcIj09PSBTSU1QTEUgREVCVUcgVEVTVCA9PT1cIik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RvcnkgZmlsZSBuYW1lOlwiLCBmaWxlTmFtZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiUGFyc2VkIHN0b3J5IGtleXM6XCIsIE9iamVjdC5rZXlzKHN0b3J5RGF0YSkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIlJhdyBzdG9yeSBkYXRhIHNhbXBsZTpcIixcclxuICAgICAgICBKU09OLnN0cmluZ2lmeShzdG9yeURhdGEsIG51bGwsIDIpLnN1YnN0cmluZygwLCA1MDApXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IGRldGFpbGVkIHN0b3J5IGluZm9ybWF0aW9uXHJcbiAgICAgIGNvbnN0IGRldGFpbGVkU3RvcnkgPSB7XHJcbiAgICAgICAgc2VsZjogc3RvcnlEYXRhW1wiQF9TZWxmXCJdLFxyXG4gICAgICAgIGFwcGxpZWRUT0NTdHlsZTogc3RvcnlEYXRhW1wiQF9BcHBsaWVkVE9DU3R5bGVcIl0gfHwgXCJuXCIsXHJcbiAgICAgICAgdXNlclRleHQ6IHN0b3J5RGF0YVtcIkBfVXNlclRleHRcIl0gIT09IGZhbHNlLFxyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IHN0b3J5IGNvbnRlbnQgd2l0aCBmb3JtYXR0aW5nXHJcbiAgICAgICAgY29udGVudDogdGhpcy5leHRyYWN0RGV0YWlsZWRTdG9yeUNvbnRlbnQoc3RvcnlEYXRhLCBmaWxlTmFtZSksXHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgdGV4dCBmb3JtYXR0aW5nXHJcbiAgICAgICAgdGV4dEZvcm1hdHRpbmc6IHRoaXMuZXh0cmFjdFRleHRGb3JtYXR0aW5nKHN0b3J5RGF0YSksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBBREQgREVCVUdHSU5HIEZPUiBQQVJTRUQgQlIgU1RSVUNUVVJFXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiPT09IFBBUlNFRCBYTUwgU1RSVUNUVVJFIERFQlVHID09PVwiKTtcclxuICAgICAgdGhpcy5kZWJ1Z0JyRWxlbWVudHNJblBhcnNlZFN0cnVjdHVyZShzdG9yeURhdGEsIFwicm9vdFwiKTtcclxuXHJcbiAgICAgIGNvbnN0IGNsZWFuU3RvcnlJZCA9IHN0b3J5SWQucmVwbGFjZShcIlN0b3J5X1wiLCBcIlwiKTtcclxuICAgICAgdGhpcy5zdG9yaWVzW2NsZWFuU3RvcnlJZF0gPSBkZXRhaWxlZFN0b3J5O1xyXG5cclxuICAgICAgLy8gRW5oYW5jZWQgbG9nZ2luZyB0byBzaG93IGxpbmUgYnJlYWtzXHJcbiAgICAgIGNvbnN0IHsgcGxhaW5UZXh0LCBsaW5lQnJlYWtJbmZvIH0gPSBkZXRhaWxlZFN0b3J5LmNvbnRlbnQ7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgU3RvcnkgJHtzdG9yeUlkfSBwYXJzZWQ6YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIENoYXJhY3RlcnM6ICR7cGxhaW5UZXh0Lmxlbmd0aH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIC0gV29yZHM6ICR7ZGV0YWlsZWRTdG9yeS5jb250ZW50LndvcmRDb3VudH1gKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIC0gTGluZSBicmVha3M6ICR7bGluZUJyZWFrSW5mbz8ubGluZUJyZWFrQ291bnQgfHwgMH1gKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYCAgIC0gVGV4dCBwcmV2aWV3OiBcIiR7cGxhaW5UZXh0XHJcbiAgICAgICAgICAuc3Vic3RyaW5nKDAsIDUwKVxyXG4gICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpfS4uLlwiYFxyXG4gICAgICApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHBhcnNpbmcgc3RvcnkgJHtmaWxlTmFtZX06YCwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZXBsYWNlIHRoZSBleGlzdGluZyBleHRyYWN0RGV0YWlsZWRTdG9yeUNvbnRlbnQgbWV0aG9kIHdpdGggdGhpcyBjb3JyZWN0ZWQgdmVyc2lvblxyXG4gIGV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudChzdG9yeURhdGEsIGZpbGVOYW1lID0gXCJ1bmtub3duXCIpIHtcclxuICAgIGxldCBjb250ZW50ID0gXCJcIjtcclxuICAgIGxldCBmb3JtYXR0ZWRDb250ZW50ID0gW107XHJcbiAgICBsZXQgdGV4dENvbG9yID0gbnVsbDtcclxuICAgIGxldCBkZWJ1Z0luZm8gPSBbXTtcclxuXHJcbiAgICBjb25zdCBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5ID0gKGVsZW1lbnQsIGRlcHRoID0gMCwgY29udGV4dCA9IHt9KSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGNvbnRlbnQgKz0gZWxlbWVudDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IFNwZWNpYWwgaGFuZGxpbmcgZm9yIENoYXJhY3RlclN0eWxlUmFuZ2Ugd2l0aCBzb3BoaXN0aWNhdGVkIEJyIGRldGVjdGlvblxyXG4gICAgICAgIGlmIChlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlKVxyXG4gICAgICAgICAgICA/IGVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZVxyXG4gICAgICAgICAgICA6IFtlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2VdO1xyXG5cclxuICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgcmFuZ2VJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBFeHRyYWN0IGRpcmVjdCBmb250IHJlZmVyZW5jZXMgZnJvbSB0aGUgWE1MIHJhbmdlXHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdEZvbnRSZWYgPVxyXG4gICAgICAgICAgICAgIHJhbmdlW1wiQF9BcHBsaWVkRm9udFwiXSB8fFxyXG4gICAgICAgICAgICAgIHJhbmdlW1wiQF9Gb250RmFtaWx5XCJdIHx8XHJcbiAgICAgICAgICAgICAgcmFuZ2VbXCJAX0ZvbnRcIl0gfHxcclxuICAgICAgICAgICAgICBcIlwiO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgICAgICAgICBwYXJhZ3JhcGhTdHlsZTpcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRbXCJAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZVwiXSB8fFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hcHBsaWVkU3R5bGUgfHxcclxuICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgY2hhcmFjdGVyU3R5bGU6IHJhbmdlW1wiQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGVcIl0gfHwgbnVsbCxcclxuICAgICAgICAgICAgICBmb250U2l6ZTogcmFuZ2VbXCJAX1BvaW50U2l6ZVwiXVxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvbnZlcnRGb250U2l6ZVRvUGl4ZWxzKHBhcnNlRmxvYXQocmFuZ2VbXCJAX1BvaW50U2l6ZVwiXSkpIC8vIEFEREVEOiBDb252ZXJ0IHRvIHBpeGVsc1xyXG4gICAgICAgICAgICAgICAgOiBudWxsLFxyXG4gICAgICAgICAgICAgIG9yaWdpbmFsRm9udFNpemU6IHJhbmdlW1wiQF9Qb2ludFNpemVcIl1cclxuICAgICAgICAgICAgICAgID8gcGFyc2VGbG9hdChyYW5nZVtcIkBfUG9pbnRTaXplXCJdKVxyXG4gICAgICAgICAgICAgICAgOiBudWxsLCAvLyBBRERFRDogUHJlc2VydmUgb3JpZ2luYWxcclxuICAgICAgICAgICAgICBmb250UmVmZXJlbmNlOiBkaXJlY3RGb250UmVmLFxyXG4gICAgICAgICAgICAgIGZpbGxDb2xvcjogcmFuZ2VbXCJAX0ZpbGxDb2xvclwiXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgIGZvbnRTdHlsZTogcmFuZ2VbXCJAX0ZvbnRTdHlsZVwiXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogSW5oZXJpdCBwYXJhZ3JhcGggYWxpZ25tZW50IGZyb20gY29udGV4dCBpZiBub3QgZXhwbGljaXRseSBzZXRcclxuICAgICAgICAgICAgICBhbGlnbm1lbnQ6XHJcbiAgICAgICAgICAgICAgICByYW5nZVtcIkBfSnVzdGlmaWNhdGlvblwiXSB8fFxyXG4gICAgICAgICAgICAgICAgcmFuZ2VbXCJAX0FsaWdubWVudFwiXSB8fFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5wYXJhZ3JhcGhBbGlnbm1lbnQgfHxcclxuICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEZvcm1hdHRpbmcgPVxyXG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogUHJvY2VzcyBDb250ZW50IGFuZCBCciBlbGVtZW50cyBpbiBkb2N1bWVudCBvcmRlclxyXG4gICAgICAgICAgICAvLyBUaGlzIGhhbmRsZXMgaW50ZXJsZWF2ZWQgPENvbnRlbnQ+IGFuZCA8QnI+IGVsZW1lbnRzIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5wcm9jZXNzQ2hhcmFjdGVyUmFuZ2VJbk9yZGVyKFxyXG4gICAgICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgICAgIHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgICAgICAgICByYW5nZUluZGV4LFxyXG4gICAgICAgICAgICAgIHJhbmdlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgICAgICAgICAgIGRlYnVnSW5mbyxcclxuICAgICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICAgIGZpbGVOYW1lXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IEFkZCBzcGFjZSBiZXR3ZWVuIGNoYXJhY3RlciBzdHlsZSByYW5nZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChyYW5nZUluZGV4IDwgcmFuZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0UmFuZ2UgPSByYW5nZXNbcmFuZ2VJbmRleCArIDFdO1xyXG5cclxuICAgICAgICAgICAgICAvLyBNb3JlIHJvYnVzdCBzcGFjZSBkZXRlY3Rpb25cclxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGNvbnRlbnQuc2xpY2UoLTEwKTsgLy8gQ2hlY2sgbGFzdCAxMCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSA9IC9cXHMkLy50ZXN0KGN1cnJlbnRUZXh0KTsgLy8gQW55IHdoaXRlc3BhY2UgYXQgZW5kXHJcblxyXG4gICAgICAgICAgICAgIGNvbnN0IG5leHRDb250ZW50ID0gbmV4dFJhbmdlLkNvbnRlbnRcclxuICAgICAgICAgICAgICAgID8gU3RyaW5nKFxyXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkobmV4dFJhbmdlLkNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IG5leHRSYW5nZS5Db250ZW50WzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IG5leHRSYW5nZS5Db250ZW50XHJcbiAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIDogXCJcIjtcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2UgPSAvXlxccy8udGVzdChuZXh0Q29udGVudCk7IC8vIEFueSB3aGl0ZXNwYWNlIGF0IHN0YXJ0XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFHR1JFU1NJVkUgRklYOiBBZGQgc3BhY2UgYmV0d2VlbiBBTEwgcmFuZ2VzIHVubGVzcyBleHBsaWNpdGx5IG5vdCBuZWVkZWRcclxuICAgICAgICAgICAgICBjb25zdCBzaG91bGRTa2lwU3BhY2UgPVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSB8fFxyXG4gICAgICAgICAgICAgICAgbmV4dFJhbmdlU3RhcnRzV2l0aFNwYWNlIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrKHJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpIHx8XHJcbiAgICAgICAgICAgICAgICAhbmV4dFJhbmdlLkNvbnRlbnQgfHwgLy8gU2tpcCBpZiBuZXh0IHJhbmdlIGhhcyBubyBjb250ZW50XHJcbiAgICAgICAgICAgICAgICBuZXh0Q29udGVudC50cmltKCkgPT09IFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghc2hvdWxkU2tpcFNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGUgPSByYW5nZVtcIkBfQXBwbGllZENoYXJhY3RlclN0eWxlXCJdIHx8IFwibm9uZVwiO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFN0eWxlID1cclxuICAgICAgICAgICAgICAgICAgbmV4dFJhbmdlW1wiQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGVcIl0gfHwgXCJub25lXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhY2VUZXh0ID0gXCIgXCI7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IHNwYWNlVGV4dDtcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHNwYWNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzU3BhY2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcImJldHdlZW4gY2hhcmFjdGVyIHN0eWxlIHJhbmdlcyAoYWdncmVzc2l2ZSlcIixcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIlNwYWNlIGluc2VydGVkIGJldHdlZW4gY2hhcmFjdGVyIHN0eWxlcyAoYWdncmVzc2l2ZSlcIixcclxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBCZXR3ZWVuIHJhbmdlcyAke3JhbmdlSW5kZXh9IGFuZCAke1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlSW5kZXggKyAxXHJcbiAgICAgICAgICAgICAgICAgIH1gLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgIG5leHRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgcmVhc29uOlxyXG4gICAgICAgICAgICAgICAgICAgIFwiRGVmYXVsdCBzcGFjZSBpbnNlcnRpb24gLSB3b3JkcyBsaWtlbHkgc3BsaXQgYWNyb3NzIHJhbmdlc1wiLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dEVuZDogY3VycmVudFRleHQuc2xpY2UoLTUpLFxyXG4gICAgICAgICAgICAgICAgICBuZXh0VGV4dFN0YXJ0OiBuZXh0Q29udGVudC5zbGljZSgwLCA1KSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiU3BhY2UgaW5zZXJ0aW9uIHNraXBwZWRcIixcclxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBCZXR3ZWVuIHJhbmdlcyAke3JhbmdlSW5kZXh9IGFuZCAke1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlSW5kZXggKyAxXHJcbiAgICAgICAgICAgICAgICAgIH1gLFxyXG4gICAgICAgICAgICAgICAgICByZWFzb246IGN1cnJlbnRSYW5nZUVuZHNXaXRoU3BhY2VcclxuICAgICAgICAgICAgICAgICAgICA/IFwiQ3VycmVudCByYW5nZSBlbmRzIHdpdGggc3BhY2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV4dFJhbmdlU3RhcnRzV2l0aFNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBcIk5leHQgcmFuZ2Ugc3RhcnRzIHdpdGggc3BhY2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIDogIW5leHRSYW5nZS5Db250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgPyBcIk5leHQgcmFuZ2UgaGFzIG5vIGNvbnRlbnRcIlxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV4dENvbnRlbnQudHJpbSgpID09PSBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgPyBcIk5leHQgY29udGVudCBpcyBvbmx5IHdoaXRlc3BhY2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIDogXCJMaW5lIGJyZWFrIHdvdWxkIGJlIGluc2VydGVkXCIsXHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0RW5kOiBjdXJyZW50VGV4dC5zbGljZSgtNSksXHJcbiAgICAgICAgICAgICAgICAgIG5leHRUZXh0U3RhcnQ6IG5leHRDb250ZW50LnNsaWNlKDAsIDUpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBIYW5kbGUgZXhwbGljaXQgbGluZSBicmVha3MgYmV0d2VlbiByYW5nZXMgKGZvciBjYXNlcyB3aGVyZSBzaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayBpcyB0cnVlKVxyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsocmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dClcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltcGxpY2l0QnJlYWsgPSBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBpbXBsaWNpdEJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdGV4dDogaW1wbGljaXRCcmVhayxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiBcImltcGxpY2l0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcImJldHdlZW4gcmFuZ2VzXCIsXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSW1wbGljaXQgbGluZSBicmVha1wiLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VJbmRleCArIDFcclxuICAgICAgICAgICAgICAgICAgfWAsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBjb250aW51ZSBwcm9jZXNzaW5nIHRvIGF2b2lkIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFTkhBTkNFRDogSGFuZGxlIFBhcmFncmFwaFN0eWxlUmFuZ2Ugd2l0aCBjb250ZXh0XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2UpXHJcbiAgICAgICAgICAgID8gZWxlbWVudC5QYXJhZ3JhcGhTdHlsZVJhbmdlXHJcbiAgICAgICAgICAgIDogW2VsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZV07XHJcblxyXG4gICAgICAgICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhDb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgIC4uLmNvbnRleHQsXHJcbiAgICAgICAgICAgICAgcGFyYWdyYXBoSW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgIHRvdGFsUGFyYWdyYXBoczogcmFuZ2VzLmxlbmd0aCxcclxuICAgICAgICAgICAgICBhcHBsaWVkU3R5bGU6IHJhbmdlW1wiQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGVcIl0sXHJcbiAgICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBQYXNzIGRvd24gZGlyZWN0IHBhcmFncmFwaC1sZXZlbCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgICBwYXJhZ3JhcGhBbGlnbm1lbnQ6XHJcbiAgICAgICAgICAgICAgICByYW5nZVtcIkBfSnVzdGlmaWNhdGlvblwiXSB8fCByYW5nZVtcIkBfQWxpZ25tZW50XCJdLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gVHJhY2sgY29udGVudCBsZW5ndGggYmVmb3JlXHJcbiAgICAgICAgICAgIGNvbnN0IGJlZm9yZUxlbiA9IGNvbnRlbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5KHJhbmdlLCBkZXB0aCArIDEsIHBhcmFncmFwaENvbnRleHQpO1xyXG4gICAgICAgICAgICAvLyBUcmFjayBjb250ZW50IGxlbmd0aCBhZnRlclxyXG4gICAgICAgICAgICBjb25zdCBhZnRlckxlbiA9IGNvbnRlbnQubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbm90aGluZyB3YXMgYWRkZWQsIHRoaXMgaXMgYW4gZW1wdHkgcGFyYWdyYXBoOiBhZGQgYSBuZXdsaW5lXHJcbiAgICAgICAgICAgIGlmIChhZnRlckxlbiA9PT0gYmVmb3JlTGVuKSB7XHJcbiAgICAgICAgICAgICAgY29udGVudCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlxcblwiLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICBicmVha1R5cGU6IFwiZW1wdHktcGFyYWdyYXBoXCIsXHJcbiAgICAgICAgICAgICAgICAgIHNvdXJjZTogXCJlbXB0eSBQYXJhZ3JhcGhTdHlsZVJhbmdlXCIsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiRW1wdHkgcGFyYWdyYXBoIGRldGVjdGVkXCIsXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogYFBhcmFncmFwaFN0eWxlUmFuZ2VbJHtpbmRleH1dYCxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHBhcmFncmFwaCBicmVhayBiZXR3ZWVuIHBhcmFncmFwaHMgKGJ1dCBub3QgYWZ0ZXIgdGhlIGxhc3Qgb25lKVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggPCByYW5nZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaEJyZWFrID0gXCJcXG5cXG5cIjsgLy8gVXNlIGRvdWJsZSBuZXdsaW5lIGZvciBwYXJhZ3JhcGggYnJlYWtzXHJcbiAgICAgICAgICAgICAgY29udGVudCArPSBwYXJhZ3JhcGhCcmVhaztcclxuICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdGV4dDogcGFyYWdyYXBoQnJlYWssXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogXCJwYXJhZ3JhcGhcIixcclxuICAgICAgICAgICAgICAgICAgc291cmNlOiBcImJldHdlZW4gcGFyYWdyYXBoc1wiLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBhcmFncmFwaCBicmVha1wiLFxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGBiZXR3ZWVuIHBhcmFncmFwaHMgJHtpbmRleH0gYW5kICR7aW5kZXggKyAxfWAsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGRpcmVjdCBDb250ZW50IGVsZW1lbnRzICh3aGVuIG5vdCBpbnNpZGUgQ2hhcmFjdGVyU3R5bGVSYW5nZSlcclxuICAgICAgICBpZiAoZWxlbWVudC5Db250ZW50ICYmICFlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGxldCB0ZXh0ID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkNvbnRlbnQpXHJcbiAgICAgICAgICAgID8gZWxlbWVudC5Db250ZW50LmpvaW4oXCJcIilcclxuICAgICAgICAgICAgOiBTdHJpbmcoZWxlbWVudC5Db250ZW50KTtcclxuICAgICAgICAgIHRleHQgPSBJRE1MVXRpbHMuZGVjb2RlWE1MRW50aXRpZXModGV4dCk7XHJcbiAgICAgICAgICBjb250ZW50ICs9IHRleHQ7XHJcblxyXG4gICAgICAgICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGU6XHJcbiAgICAgICAgICAgICAgZWxlbWVudFtcIkBfQXBwbGllZFBhcmFncmFwaFN0eWxlXCJdIHx8XHJcbiAgICAgICAgICAgICAgY29udGV4dC5hcHBsaWVkU3R5bGUgfHxcclxuICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZTogZWxlbWVudFtcIkBfQXBwbGllZENoYXJhY3RlclN0eWxlXCJdIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiBlbGVtZW50W1wiQF9Qb2ludFNpemVcIl0gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udEZhbWlseTogZWxlbWVudFtcIkBfQXBwbGllZEZvbnRcIl0gfHwgbnVsbCxcclxuICAgICAgICAgICAgZmlsbENvbG9yOiBlbGVtZW50W1wiQF9GaWxsQ29sb3JcIl0gfHwgbnVsbCxcclxuICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBJbmhlcml0IHBhcmFncmFwaCBhbGlnbm1lbnQgZnJvbSBjb250ZXh0IGlmIG5vdCBleHBsaWNpdGx5IHNldFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ6XHJcbiAgICAgICAgICAgICAgZWxlbWVudFtcIkBfSnVzdGlmaWNhdGlvblwiXSB8fFxyXG4gICAgICAgICAgICAgIGVsZW1lbnRbXCJAX0FsaWdubWVudFwiXSB8fFxyXG4gICAgICAgICAgICAgIGNvbnRleHQucGFyYWdyYXBoQWxpZ25tZW50IHx8XHJcbiAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRGb3JtYXR0aW5nID1cclxuICAgICAgICAgICAgdGhpcy5zdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nKGZvcm1hdHRpbmcpO1xyXG5cclxuICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgIHRleHQ6IHRleHQucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgICAgICBmb3JtYXR0aW5nOiByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVOSEFOQ0VEOiBEaXJlY3QgQnIgZWxlbWVudCBoYW5kbGluZyAob3V0c2lkZSBvZiByYW5nZXMpXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY29uc3QgYnJFbGVtZW50cyA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5CcilcclxuICAgICAgICAgICAgPyBlbGVtZW50LkJyXHJcbiAgICAgICAgICAgIDogW2VsZW1lbnQuQnJdO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGDwn5SnIFByb2Nlc3NpbmcgJHtickVsZW1lbnRzLmxlbmd0aH0gZGlyZWN0IEJyIGVsZW1lbnRzOmAsXHJcbiAgICAgICAgICAgIGJyRWxlbWVudHNcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgYnJFbGVtZW50cy5mb3JFYWNoKChiciwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGluZUJyZWFrVGV4dCA9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgIGDwn5SnIERpcmVjdCBCciBlbGVtZW50ICR7aW5kZXggKyAxfS8ke1xyXG4gICAgICAgICAgICAgICAgYnJFbGVtZW50cy5sZW5ndGhcclxuICAgICAgICAgICAgICB9IGNyZWF0ZXM6ICR7SlNPTi5zdHJpbmdpZnkobGluZUJyZWFrVGV4dCl9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb250ZW50ICs9IGxpbmVCcmVha1RleHQ7XHJcbiAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgdGV4dDogbGluZUJyZWFrVGV4dCxcclxuICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYnJlYWtUeXBlOiBcImV4cGxpY2l0XCIsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwiZGlyZWN0IEJyIGVsZW1lbnRcIixcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgIHR5cGU6IFwiRGlyZWN0IEJyIGVsZW1lbnRcIixcclxuICAgICAgICAgICAgICBsb2NhdGlvbjogYERpcmVjdCBlbGVtZW50LCBpbmRleCAke2luZGV4fWAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGDwn5SnIEFmdGVyIHByb2Nlc3NpbmcgJHtickVsZW1lbnRzLmxlbmd0aH0gZGlyZWN0IEJyIGVsZW1lbnRzLCBjb250ZW50IGVuZHMgd2l0aDpgLFxyXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShjb250ZW50LnNsaWNlKC0xMCkpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciBuZXN0ZWQgZWxlbWVudHNcclxuICAgICAgICBPYmplY3QuZW50cmllcyhlbGVtZW50KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgIWtleS5zdGFydHNXaXRoKFwiQF9cIikgJiZcclxuICAgICAgICAgICAga2V5ICE9PSBcIkNvbnRlbnRcIiAmJlxyXG4gICAgICAgICAgICBrZXkgIT09IFwiQnJcIiAmJlxyXG4gICAgICAgICAgICBrZXkgIT09IFwiQ2hhcmFjdGVyU3R5bGVSYW5nZVwiICYmXHJcbiAgICAgICAgICAgIGtleSAhPT0gXCJQYXJhZ3JhcGhTdHlsZVJhbmdlXCJcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKSA9PlxyXG4gICAgICAgICAgICAgICAgZXh0cmFjdFRleHRSZWN1cnNpdmVseShpdGVtLCBkZXB0aCArIDEsIGNvbnRleHQpXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgZGVwdGggPCAxMCkge1xyXG4gICAgICAgICAgICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkodmFsdWUsIGRlcHRoICsgMSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5KHN0b3J5RGF0YSk7XHJcblxyXG4gICAgLy8gREVCVUc6IFByaW50IHRoZSBmdWxsIHJhdyBjb250ZW50IHN0cmluZyB3aXRoIHZpc2libGUgbmV3bGluZXMgYmVmb3JlIHByb2Nlc3NpbmdcclxuICAgIGNvbnNvbGUubG9nKFwi8J+TnSA9PT0gQ09NUExFVEUgQ09OVEVOVCBBTkFMWVNJUyA9PT1cIik7XHJcbiAgICBjb25zb2xlLmxvZyhcIiAgIC0gUmF3IGNvbnRlbnQgYmVmb3JlIHByb2Nlc3Npbmc6XCIsIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIiAgIC0gUmF3IGNvbnRlbnQgbmV3bGluZSBjb3VudDpcIixcclxuICAgICAgKGNvbnRlbnQubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoXHJcbiAgICApO1xyXG4gICAgY29uc29sZS5sb2coXCIgICAtIFJhdyBjb250ZW50IGNoYXJhY3RlciBicmVha2Rvd246XCIpO1xyXG4gICAgY29uc3QgY2hhcnMgPSBjb250ZW50XHJcbiAgICAgIC5zcGxpdChcIlwiKVxyXG4gICAgICAubWFwKChjaGFyLCBpKSA9PiBgJHtpfTogJHtKU09OLnN0cmluZ2lmeShjaGFyKX1gKTtcclxuICAgIGNvbnNvbGUubG9nKFwiICAgLSBGaXJzdCA1MCBjaGFyYWN0ZXJzOlwiLCBjaGFycy5zbGljZSgwLCA1MCkpO1xyXG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID4gNTApIHtcclxuICAgICAgY29uc29sZS5sb2coXCIgICAtIExhc3QgMjAgY2hhcmFjdGVyczpcIiwgY2hhcnMuc2xpY2UoLTIwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRU5IQU5DRUQ6IFByb2Nlc3MgYW5kIGNsZWFuIHVwIHRoZSBjb250ZW50IHdpdGggc29waGlzdGljYXRlZCBsaW5lIGJyZWFrIHByZXNlcnZhdGlvblxyXG4gICAgbGV0IHByb2Nlc3NlZENvbnRlbnQgPSBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmcoY29udGVudCk7XHJcblxyXG4gICAgLy8gQ1JJVElDQUw6IEV4cGxpY2l0bHkgcHJlc2VydmUgYWxsIG5ld2xpbmVzIGFzLWlzIChubyBtZXJnaW5nIG9yIHN0cmlwcGluZylcclxuICAgIHByb2Nlc3NlZENvbnRlbnQgPSBwcm9jZXNzZWRDb250ZW50LnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7IC8vIE5vcm1hbGl6ZSBDUkxGL0NSIHRvIExGXHJcbiAgICAvLyBEbyBOT1QgY29sbGFwc2UgbXVsdGlwbGUgbmV3bGluZXMgaW50byBvbmU7IHByZXNlcnZlIGFzLWlzXHJcblxyXG4gICAgY29uc29sZS5sb2coXCLwn5OdID09PSBQUk9DRVNTRUQgQ09OVEVOVCBBTkFMWVNJUyA9PT1cIik7XHJcbiAgICBjb25zb2xlLmxvZyhcIiAgIC0gUHJvY2Vzc2VkIGNvbnRlbnQ6XCIsIEpTT04uc3RyaW5naWZ5KHByb2Nlc3NlZENvbnRlbnQpKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIiAgIC0gUHJvY2Vzc2VkIGNvbnRlbnQgbmV3bGluZSBjb3VudDpcIixcclxuICAgICAgKHByb2Nlc3NlZENvbnRlbnQubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoXHJcbiAgICApO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwiICAgLSBDb250ZW50IGxlbmd0aCBjaGFuZ2U6XCIsXHJcbiAgICAgIGNvbnRlbnQubGVuZ3RoLFxyXG4gICAgICBcIuKGklwiLFxyXG4gICAgICBwcm9jZXNzZWRDb250ZW50Lmxlbmd0aFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTaG93IGRpZmZlcmVuY2VzIGlmIGFueVxyXG4gICAgaWYgKGNvbnRlbnQgIT09IHByb2Nlc3NlZENvbnRlbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coXCLimqDvuI8gIENPTlRFTlQgV0FTIE1PRElGSUVEIERVUklORyBQUk9DRVNTSU5HIVwiKTtcclxuICAgICAgY29uc29sZS5sb2coXCIgICAtIE9yaWdpbmFsOlwiLCBKU09OLnN0cmluZ2lmeShjb250ZW50LnNsaWNlKDAsIDEwMCkpKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCIgICAtIFByb2Nlc3NlZDpcIixcclxuICAgICAgICBKU09OLnN0cmluZ2lmeShwcm9jZXNzZWRDb250ZW50LnNsaWNlKDAsIDEwMCkpXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBDb250ZW50IHByZXNlcnZlZCBleGFjdGx5IGR1cmluZyBwcm9jZXNzaW5nXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERFQlVHOiBMb2cgc3BhY2UgcHJlc2VydmF0aW9uIHJlc3VsdHNcclxuICAgIGNvbnNvbGUubG9nKFwi8J+TnSBUZXh0IGV4dHJhY3Rpb24gcmVzdWx0czpcIik7XHJcbiAgICBjb25zb2xlLmxvZyhcIiAgIC0gT3JpZ2luYWwgY29udGVudCBsZW5ndGg6XCIsIGNvbnRlbnQubGVuZ3RoKTtcclxuICAgIGNvbnNvbGUubG9nKFwiICAgLSBQcm9jZXNzZWQgY29udGVudCBsZW5ndGg6XCIsIHByb2Nlc3NlZENvbnRlbnQubGVuZ3RoKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIiAgIC0gU3BhY2UgcHJlc2VydmF0aW9uIGV2ZW50czpcIixcclxuICAgICAgZGVidWdJbmZvLmZpbHRlcigoaW5mbykgPT4gaW5mby50eXBlLmluY2x1ZGVzKFwiU3BhY2UgaW5zZXJ0ZWRcIikpLmxlbmd0aFxyXG4gICAgKTtcclxuICAgIC8vIERFQlVHOiBTaG93IGZpcnN0IDMwMCBjaGFycyB3aXRoIHZpc2libGUgbmV3bGluZXNcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIiAgIC0gRXh0cmFjdGVkIHRleHQgcHJldmlldzpcIixcclxuICAgICAgSlNPTi5zdHJpbmdpZnkocHJvY2Vzc2VkQ29udGVudC5zbGljZSgwLCAzMDApKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTUEVDSUZJQyBERUJVRzogQ2hlY2sgZm9yIHRoZSBwcm9ibGVtYXRpYyBcInBhdm9sdXB0dXNkYVwiIHRleHQgKHNpbXBsaWZpZWQpXHJcbiAgICBpZiAoXHJcbiAgICAgIHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoXCJwYXZvbHVwdHVzZGFcIikgfHxcclxuICAgICAgKHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoXCJwYVwiKSAmJlxyXG4gICAgICAgIHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoXCJ2b2x1cHR1c2RhXCIpKVxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+aqCBGT1VORCBQUk9CTEVNQVRJQyBURVhUOlwiKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgJyAgIC0gQ29udGFpbnMgXCJwYXZvbHVwdHVzZGFcIjonLFxyXG4gICAgICAgIHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoXCJwYXZvbHVwdHVzZGFcIilcclxuICAgICAgKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgJyAgIC0gQ29udGFpbnMgXCJwYSB2b2x1cHR1c2RhXCI6JyxcclxuICAgICAgICBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKFwicGEgdm9sdXB0dXNkYVwiKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIiAgIC0gRm9ybWF0dGVkQ29udGVudCBicmVha2Rvd246XCIsXHJcbiAgICAgICAgZm9ybWF0dGVkQ29udGVudC5tYXAoKGl0ZW0pID0+IGl0ZW0udGV4dCkuam9pbihcInxcIilcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsaW5lQnJlYWtJbmZvID0ge1xyXG4gICAgICBoYXNMaW5lQnJlYWtzOiBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKFwiXFxuXCIpLFxyXG4gICAgICBsaW5lQnJlYWtDb3VudDogKHByb2Nlc3NlZENvbnRlbnQubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoLFxyXG4gICAgICBsaW5lQnJlYWtUeXBlczogdGhpcy5hbmFseXplTGluZUJyZWFrVHlwZXMoZm9ybWF0dGVkQ29udGVudCksXHJcbiAgICAgIGRlYnVnSW5mbzogZGVidWdJbmZvLFxyXG4gICAgICBzcGFjZVByZXNlcnZhdGlvbkNvdW50OiBkZWJ1Z0luZm8uZmlsdGVyKChpbmZvKSA9PlxyXG4gICAgICAgIGluZm8udHlwZS5pbmNsdWRlcyhcIlNwYWNlIGluc2VydGVkXCIpXHJcbiAgICAgICkubGVuZ3RoLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwbGFpblRleHQ6IHByb2Nlc3NlZENvbnRlbnQsXHJcbiAgICAgIGZvcm1hdHRlZENvbnRlbnQ6IGZvcm1hdHRlZENvbnRlbnQuZmlsdGVyKFxyXG4gICAgICAgIChpdGVtKSA9PiBpdGVtLnRleHQgJiYgaXRlbS50ZXh0Lmxlbmd0aCA+IDBcclxuICAgICAgKSxcclxuICAgICAgd29yZENvdW50OiBJRE1MVXRpbHMuY291bnRXb3Jkcyhwcm9jZXNzZWRDb250ZW50LnJlcGxhY2UoL1xcbi9nLCBcIiBcIikpLFxyXG4gICAgICBjaGFyYWN0ZXJDb3VudDogcHJvY2Vzc2VkQ29udGVudC5sZW5ndGgsXHJcbiAgICAgIHRleHRDb2xvcjogdGV4dENvbG9yLFxyXG4gICAgICBsaW5lQnJlYWtJbmZvOiBsaW5lQnJlYWtJbmZvLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIE5FVzogUHJvY2VzcyBDaGFyYWN0ZXJTdHlsZVJhbmdlIGNvbnRlbnQgYW5kIGJyZWFrcyBpbiBkb2N1bWVudCBvcmRlciAtIEZVTExZIERZTkFNSUNcclxuICBwcm9jZXNzQ2hhcmFjdGVyUmFuZ2VJbk9yZGVyKFxyXG4gICAgcmFuZ2UsXHJcbiAgICByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICByYW5nZUluZGV4LFxyXG4gICAgdG90YWxSYW5nZXMsXHJcbiAgICBjb250ZW50LFxyXG4gICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgIGRlYnVnSW5mbyxcclxuICAgIGNvbnRleHQsXHJcbiAgICBmaWxlTmFtZVxyXG4gICkge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5SnIFByb2Nlc3NpbmcgQ2hhcmFjdGVyU3R5bGVSYW5nZVske3JhbmdlSW5kZXh9XSBpbiBkb2N1bWVudCBvcmRlcjpgLFxyXG4gICAgICB7XHJcbiAgICAgICAgaGFzQ29udGVudDogISFyYW5nZS5Db250ZW50LFxyXG4gICAgICAgIGhhc0JyOiByYW5nZS5CciAhPT0gdW5kZWZpbmVkLFxyXG4gICAgICAgIGNvbnRlbnRUeXBlOiBBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpXHJcbiAgICAgICAgICA/IFwiYXJyYXlcIlxyXG4gICAgICAgICAgOiB0eXBlb2YgcmFuZ2UuQ29udGVudCxcclxuICAgICAgICBiclR5cGU6IEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpID8gXCJhcnJheVwiIDogdHlwZW9mIHJhbmdlLkJyLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIENPTVBSRUhFTlNJVkUgRURHRSBDQVNFIEhBTkRMSU5HXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDYXNlIDE6IEJvdGggQ29udGVudCBhbmQgQnIgZWxlbWVudHMgZXhpc3QgLSBtb3N0IGNvbW1vbiBjYXNlXHJcbiAgICAgIGlmIChyYW5nZS5Db250ZW50ICYmIHJhbmdlLkJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UpyBQcm9jZXNzaW5nIHJhbmdlIHdpdGggYm90aCBjb250ZW50IGFuZCBicmVha3NgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzSW50ZXJsZWF2ZWRDb250ZW50QW5kQnIoXHJcbiAgICAgICAgICByYW5nZSxcclxuICAgICAgICAgIHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgICAgICAgZGVidWdJbmZvLFxyXG4gICAgICAgICAgZmlsZU5hbWVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYXNlIDI6IE9ubHkgQ29udGVudCwgbm8gQnIgZWxlbWVudHNcclxuICAgICAgZWxzZSBpZiAocmFuZ2UuQ29udGVudCAmJiByYW5nZS5CciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYPCflKcgUHJvY2Vzc2luZyByYW5nZSB3aXRoIG9ubHkgY29udGVudGApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NDb250ZW50RWxlbWVudHMoXHJcbiAgICAgICAgICByYW5nZSxcclxuICAgICAgICAgIHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgICAgICAgZmlsZU5hbWVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYXNlIDM6IE9ubHkgQnIgZWxlbWVudHMsIG5vIENvbnRlbnRcclxuICAgICAgZWxzZSBpZiAoIXJhbmdlLkNvbnRlbnQgJiYgcmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SnIFByb2Nlc3NpbmcgcmFuZ2Ugd2l0aCBvbmx5IGJyZWFrc2ApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NCckVsZW1lbnRzKFxyXG4gICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgICAgICAgIGRlYnVnSW5mbyxcclxuICAgICAgICAgIHJhbmdlSW5kZXgsXHJcbiAgICAgICAgICBmaWxlTmFtZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhc2UgNDogTmVpdGhlciBDb250ZW50IG5vciBCciAtIGVtcHR5IHJhbmdlXHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gRW1wdHkgcmFuZ2UgZW5jb3VudGVyZWQgLSBubyBjb250ZW50IG9yIGJyZWFrc2ApO1xyXG4gICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBVTFRJTUFURSBGQUxMQkFDSzogSWYgYW55dGhpbmcgZ29lcyB3cm9uZywgdHJ5IHRvIHNhbHZhZ2Ugd2hhdCB3ZSBjYW5cclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKdjCBFcnJvciBwcm9jZXNzaW5nIENoYXJhY3RlclN0eWxlUmFuZ2VbJHtyYW5nZUluZGV4fV06ICR7ZXJyb3IubWVzc2FnZX1gXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SEIEF0dGVtcHRpbmcgZW1lcmdlbmN5IGNvbnRlbnQgZXh0cmFjdGlvbi4uLmApO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuZW1lcmdlbmN5Q29udGVudEV4dHJhY3Rpb24oXHJcbiAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgICAgICBmaWxlTmFtZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRU1FUkdFTkNZIEZBTExCQUNLOiBFeHRyYWN0IGNvbnRlbnQgZnJvbSBtYWxmb3JtZWQgb3IgdW5leHBlY3RlZCBYTUwgc3RydWN0dXJlc1xyXG4gIGVtZXJnZW5jeUNvbnRlbnRFeHRyYWN0aW9uKFxyXG4gICAgcmFuZ2UsXHJcbiAgICByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICBjb250ZW50LFxyXG4gICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgIGZpbGVOYW1lXHJcbiAgKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+aqCBFbWVyZ2VuY3kgY29udGVudCBleHRyYWN0aW9uIGZvciB1bnVzdWFsIFhNTCBzdHJ1Y3R1cmVgKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBUcnkgdG8gZXh0cmFjdCBhbnkgdGV4dCBjb250ZW50IHVzaW5nIGRpZmZlcmVudCBhcHByb2FjaGVzXHJcbiAgICAgIGNvbnN0IGV4dHJhY3RlZFRleHRzID0gW107XHJcbiAgICAgIGNvbnN0IGV4dHJhY3RlZEJyZWFrcyA9IFtdO1xyXG5cclxuICAgICAgLy8gQXBwcm9hY2ggMTogRGlyZWN0IHByb3BlcnR5IGFjY2Vzc1xyXG4gICAgICBpZiAocmFuZ2UuQ29udGVudCkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRzID0gQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KVxyXG4gICAgICAgICAgPyByYW5nZS5Db250ZW50XHJcbiAgICAgICAgICA6IFtyYW5nZS5Db250ZW50XTtcclxuICAgICAgICBjb250ZW50cy5mb3JFYWNoKChjKSA9PiB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGMgPT09IFwic3RyaW5nXCIgJiYgYy50cmltKCkpIHtcclxuICAgICAgICAgICAgZXh0cmFjdGVkVGV4dHMucHVzaChjLnRyaW0oKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFwcHJvYWNoIDI6IFNlYXJjaCBmb3IgYW55IHRleHQtbGlrZSBwcm9wZXJ0aWVzXHJcbiAgICAgIE9iamVjdC5rZXlzKHJhbmdlKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0eXBlb2YgcmFuZ2Vba2V5XSA9PT0gXCJzdHJpbmdcIiAmJlxyXG4gICAgICAgICAgcmFuZ2Vba2V5XS50cmltKCkgJiZcclxuICAgICAgICAgIGtleSAhPT0gXCJAX1NlbGZcIiAmJlxyXG4gICAgICAgICAgIWtleS5zdGFydHNXaXRoKFwiQF9cIilcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGV4dHJhY3RlZFRleHRzLnB1c2gocmFuZ2Vba2V5XS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBBcHByb2FjaCAzOiBDb3VudCBhbnkgYnJlYWstbGlrZSBwcm9wZXJ0aWVzXHJcbiAgICAgIGlmIChyYW5nZS5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uc3QgYnJlYWtzID0gQXJyYXkuaXNBcnJheShyYW5nZS5CcikgPyByYW5nZS5CciA6IFtyYW5nZS5Ccl07XHJcbiAgICAgICAgZXh0cmFjdGVkQnJlYWtzLnB1c2goLi4uYnJlYWtzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIGV4dHJhY3RlZCBjb250ZW50XHJcbiAgICAgIGV4dHJhY3RlZFRleHRzLmZvckVhY2goKHRleHQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xlYW5UZXh0ID0gSURNTFV0aWxzLmRlY29kZVhNTEVudGl0aWVzKHRleHQpO1xyXG4gICAgICAgIGNvbnRlbnQgKz0gY2xlYW5UZXh0O1xyXG4gICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICB0ZXh0OiBjbGVhblRleHQucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDwn5qoIEVtZXJnZW5jeSBleHRyYWN0ZWQgY29udGVudFske2luZGV4fV06ICR7SlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgICAgICAgIGNsZWFuVGV4dFxyXG4gICAgICAgICAgKX1gXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgaXRlbXMgKHNpbXBsZSAxOjEgcmF0aW8pXHJcbiAgICAgICAgaWYgKGluZGV4IDwgZXh0cmFjdGVkQnJlYWtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgY29uc3QgbGluZUJyZWFrVGV4dCA9IFwiXFxuXCI7XHJcbiAgICAgICAgICBjb250ZW50ICs9IGxpbmVCcmVha1RleHQ7XHJcbiAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0XHJcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXG5cIilcclxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcblxcblwiKSxcclxuICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgYnJlYWtUeXBlOiBcImxpbmVcIixcclxuICAgICAgICAgICAgICBzb3VyY2U6IFwiZW1lcmdlbmN5IGV4dHJhY3Rpb25cIixcclxuICAgICAgICAgICAgICBlbWVyZ2VuY3lJbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYPCfmqggRW1lcmdlbmN5IGV4dHJhY3RlZCBicmVha1ske2luZGV4fV06ICR7SlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgICAgICAgICAgbGluZUJyZWFrVGV4dFxyXG4gICAgICAgICAgICApfWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFkZCBhbnkgcmVtYWluaW5nIGJyZWFrcyBhdCB0aGUgZW5kXHJcbiAgICAgIGZvciAobGV0IGkgPSBleHRyYWN0ZWRUZXh0cy5sZW5ndGg7IGkgPCBleHRyYWN0ZWRCcmVha3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gXCJcXG5cIjtcclxuICAgICAgICBjb250ZW50ICs9IGxpbmVCcmVha1RleHQ7XHJcbiAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHRcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXG5cIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXG5cXG5cIiksXHJcbiAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgIGJyZWFrVHlwZTogXCJsaW5lXCIsXHJcbiAgICAgICAgICAgIHNvdXJjZTogXCJlbWVyZ2VuY3kgdHJhaWxpbmcgYnJlYWtcIixcclxuICAgICAgICAgICAgZW1lcmdlbmN5SW5kZXg6IGksXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDwn5qoIEVtZXJnZW5jeSBleHRyYWN0ZWQgdHJhaWxpbmcgYnJlYWtbJHtpfV06ICR7SlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgICAgICAgIGxpbmVCcmVha1RleHRcclxuICAgICAgICAgICl9YFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDinIUgRW1lcmdlbmN5IGV4dHJhY3Rpb24gc3VjY2Vzc2Z1bDogJHtleHRyYWN0ZWRUZXh0cy5sZW5ndGh9IHRleHRzLCAke2V4dHJhY3RlZEJyZWFrcy5sZW5ndGh9IGJyZWFrc2BcclxuICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGVtZXJnZW5jeUVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5KAIEVtZXJnZW5jeSBleHRyYWN0aW9uIGZhaWxlZDogJHtlbWVyZ2VuY3lFcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAvLyBMYXN0IHJlc29ydDoganVzdCBhZGQgYSB3YXJuaW5nIGNvbW1lbnRcclxuICAgICAgY29uc3Qgd2FybmluZ1RleHQgPSBcIjwhLS0gWE1MIHBhcnNpbmcgZXJyb3IgLS0+XCI7XHJcbiAgICAgIGNvbnRlbnQgKz0gd2FybmluZ1RleHQ7XHJcbiAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgdGV4dDogd2FybmluZ1RleHQucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgIGZvcm1hdHRpbmc6IHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICAvLyBQcm9jZXNzIGludGVybGVhdmVkIENvbnRlbnQgYW5kIEJyIGVsZW1lbnRzIC0gRlVMTFkgRFlOQU1JQ1xyXG4gIHByb2Nlc3NJbnRlcmxlYXZlZENvbnRlbnRBbmRCcihcclxuICAgIHJhbmdlLFxyXG4gICAgcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgY29udGVudCxcclxuICAgIGZvcm1hdHRlZENvbnRlbnQsXHJcbiAgICBkZWJ1Z0luZm8sXHJcbiAgICBmaWxlTmFtZVxyXG4gICkge1xyXG4gICAgY29uc3QgY29udGVudHMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpXHJcbiAgICAgID8gcmFuZ2UuQ29udGVudFxyXG4gICAgICA6IFtyYW5nZS5Db250ZW50XTtcclxuICAgIGNvbnN0IGJyRWxlbWVudHMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkJyKSA/IHJhbmdlLkJyIDogW3JhbmdlLkJyXTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCflKcgUHJvY2Vzc2luZyBpbnRlcmxlYXZlZCBjb250ZW50OiAke2NvbnRlbnRzLmxlbmd0aH0gY29udGVudCBpdGVtcywgJHtickVsZW1lbnRzLmxlbmd0aH0gQnIgZWxlbWVudHNgXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEVER0UgQ0FTRTogTm8gY29udGVudCBvciBicmVha3NcclxuICAgIGlmICghcmFuZ2UuQ29udGVudCAmJiAhcmFuZ2UuQnIpIHtcclxuICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBObyBjb250ZW50IG9yIGJyZWFrcyB0byBwcm9jZXNzIGluIHJhbmdlYCk7XHJcbiAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVER0UgQ0FTRTogT25seSBjb250ZW50LCBubyBicmVha3NcclxuICAgIGlmIChyYW5nZS5Db250ZW50ICYmICFyYW5nZS5Ccikge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TnSBPbmx5IGNvbnRlbnQsIG5vIGJyZWFrcyAtIHByb2Nlc3NpbmcgY29udGVudCBvbmx5YCk7XHJcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NDb250ZW50RWxlbWVudHMoXHJcbiAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgICAgICBmaWxlTmFtZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVER0UgQ0FTRTogT25seSBicmVha3MsIG5vIGNvbnRlbnRcclxuICAgIGlmICghcmFuZ2UuQ29udGVudCAmJiByYW5nZS5Ccikge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UlyBPbmx5IGJyZWFrcywgbm8gY29udGVudCAtIHByb2Nlc3NpbmcgYnJlYWtzIG9ubHlgKTtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0JyRWxlbWVudHMoXHJcbiAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgICAgIGRlYnVnSW5mbyxcclxuICAgICAgICAwLFxyXG4gICAgICAgIGZpbGVOYW1lXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRFlOQU1JQzogVHJ5IHRvIHVzZSBjYWNoZWQgZG9jdW1lbnQgb3JkZXIgaWYgYXZhaWxhYmxlXHJcbiAgICBjb25zdCBjYWNoZWRPcmRlciA9XHJcbiAgICAgIHRoaXMuZG9jdW1lbnRPcmRlckNhY2hlICYmIHRoaXMuZG9jdW1lbnRPcmRlckNhY2hlW2ZpbGVOYW1lXTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIGNhY2hlZE9yZGVyICYmXHJcbiAgICAgIGNhY2hlZE9yZGVyLmJyZWFrUGF0dGVybiAmJlxyXG4gICAgICBjYWNoZWRPcmRlci5icmVha1BhdHRlcm4ubGVuZ3RoID4gMFxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDinIUgVXNpbmcgY2FjaGVkIGRvY3VtZW50IG9yZGVyIGZvciBwcmVjaXNlIGJyZWFrIGRpc3RyaWJ1dGlvbmBcclxuICAgICAgKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzQ29udGVudFdpdGhDYWNoZWRQYXR0ZXJuKFxyXG4gICAgICAgICAgY29udGVudHMsXHJcbiAgICAgICAgICByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgICAgICAgIGNhY2hlZE9yZGVyLmJyZWFrUGF0dGVybixcclxuICAgICAgICAgIGZpbGVOYW1lXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDinYwgRXJyb3IgdXNpbmcgY2FjaGVkIHBhdHRlcm46ICR7ZXJyb3IubWVzc2FnZX0sIGZhbGxpbmcgYmFjayB0byBkeW5hbWljIGRpc3RyaWJ1dGlvbmBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4pqg77iPIE5vIGNhY2hlZCBkb2N1bWVudCBvcmRlciBhdmFpbGFibGUsIHVzaW5nIGR5bmFtaWMgZmFsbGJhY2sgZGlzdHJpYnV0aW9uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERZTkFNSUMgRkFMTEJBQ0s6IERpc3RyaWJ1dGUgYnJlYWtzIGludGVsbGlnZW50bHkgYmFzZWQgb24gY29udGVudCBzdHJ1Y3R1cmVcclxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NJbnRlcmxlYXZlZENvbnRlbnREeW5hbWljRmFsbGJhY2soXHJcbiAgICAgIGNvbnRlbnRzLFxyXG4gICAgICBickVsZW1lbnRzLFxyXG4gICAgICByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICAgIGNvbnRlbnQsXHJcbiAgICAgIGZvcm1hdHRlZENvbnRlbnQsXHJcbiAgICAgIGZpbGVOYW1lXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gRFlOQU1JQyBGQUxMQkFDSzogSW50ZWxsaWdlbnQgYnJlYWsgZGlzdHJpYnV0aW9uIGZvciBhbnkgY29udGVudCBzdHJ1Y3R1cmVcclxuICBwcm9jZXNzSW50ZXJsZWF2ZWRDb250ZW50RHluYW1pY0ZhbGxiYWNrKFxyXG4gICAgY29udGVudHMsXHJcbiAgICBickVsZW1lbnRzLFxyXG4gICAgcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgY29udGVudCxcclxuICAgIGZvcm1hdHRlZENvbnRlbnQsXHJcbiAgICBmaWxlTmFtZVxyXG4gICkge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5SEIFVzaW5nIGR5bmFtaWMgZmFsbGJhY2sgZm9yICR7Y29udGVudHMubGVuZ3RofSBjb250ZW50IGl0ZW1zIGFuZCAke2JyRWxlbWVudHMubGVuZ3RofSBicmVha3NgXHJcbiAgICApO1xyXG5cclxuICAgIGxldCBickluZGV4ID0gMDtcclxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBjb250ZW50cy5sZW5ndGg7XHJcblxyXG4gICAgY29udGVudHMuZm9yRWFjaCgoY29udGVudEl0ZW0sIGNvbnRlbnRJbmRleCkgPT4ge1xyXG4gICAgICAvLyBBZGQgdGhlIGNvbnRlbnRcclxuICAgICAgY29uc3QgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyhTdHJpbmcoY29udGVudEl0ZW0pKTtcclxuICAgICAgY29udGVudCArPSB0ZXh0O1xyXG4gICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgIHRleHQ6IHRleHQucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgIGZvcm1hdHRpbmc6IHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UpyBBZGRlZCBjb250ZW50WyR7Y29udGVudEluZGV4fV06ICR7SlNPTi5zdHJpbmdpZnkodGV4dCl9YCk7XHJcblxyXG4gICAgICAvLyBEWU5BTUlDOiBDYWxjdWxhdGUgaG93IG1hbnkgYnJlYWtzIHRvIGFkZCBhZnRlciB0aGlzIGNvbnRlbnRcclxuICAgICAgY29uc3QgYnJlYWtzVG9BZGQgPSB0aGlzLmNhbGN1bGF0ZUJyZWFrc0FmdGVyQ29udGVudChcclxuICAgICAgICBjb250ZW50SW5kZXgsXHJcbiAgICAgICAgY29udGVudExlbmd0aCxcclxuICAgICAgICBickVsZW1lbnRzLmxlbmd0aFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQWRkIHRoZSBjYWxjdWxhdGVkIG51bWJlciBvZiBicmVha3NcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBicmVha3NUb0FkZCAmJiBickluZGV4IDwgYnJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSBcIlxcblwiO1xyXG4gICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgdGV4dDogbGluZUJyZWFrVGV4dFxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcblxcblwiKSxcclxuICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgYnJlYWtUeXBlOiBcImxpbmVcIixcclxuICAgICAgICAgICAgc291cmNlOiBcImR5bmFtaWMgZmFsbGJhY2sgZGlzdHJpYnV0aW9uXCIsXHJcbiAgICAgICAgICAgIGJySW5kZXg6IGJySW5kZXgsXHJcbiAgICAgICAgICAgIGFmdGVyQ29udGVudDogY29udGVudEluZGV4LFxyXG4gICAgICAgICAgICBjYWxjdWxhdGVkQnJlYWtzOiBicmVha3NUb0FkZCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCflKcgQWRkZWQgQnJbJHtickluZGV4fV0gYWZ0ZXIgY29udGVudFske2NvbnRlbnRJbmRleH1dOiAke0pTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgICAgICBsaW5lQnJlYWtUZXh0XHJcbiAgICAgICAgICApfWBcclxuICAgICAgICApO1xyXG4gICAgICAgIGJySW5kZXgrKztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRURHRSBDQVNFOiBIYW5kbGUgYW55IHJlbWFpbmluZyBicmVha3NcclxuICAgIGlmIChickluZGV4IDwgYnJFbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgcmVtYWluaW5nQnJlYWtzID0gYnJFbGVtZW50cy5sZW5ndGggLSBickluZGV4O1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UpyBBZGRpbmcgJHtyZW1haW5pbmdCcmVha3N9IHJlbWFpbmluZyBicmVha3MgYXQgdGhlIGVuZGApO1xyXG5cclxuICAgICAgd2hpbGUgKGJySW5kZXggPCBickVsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSBcIlxcblwiO1xyXG4gICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgdGV4dDogbGluZUJyZWFrVGV4dFxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcblxcblwiKSxcclxuICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgYnJlYWtUeXBlOiBcImxpbmVcIixcclxuICAgICAgICAgICAgc291cmNlOiBcInRyYWlsaW5nIGJyZWFrcyAoZHluYW1pYyBmYWxsYmFjaylcIixcclxuICAgICAgICAgICAgYnJJbmRleDogYnJJbmRleCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCflKcgQWRkZWQgdHJhaWxpbmcgQnJbJHtickluZGV4fV06ICR7SlNPTi5zdHJpbmdpZnkobGluZUJyZWFrVGV4dCl9YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYnJJbmRleCsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVkFMSURBVElPTjogRW5zdXJlIGFsbCBicmVha3Mgd2VyZSBwcm9jZXNzZWRcclxuICAgIGlmIChickluZGV4ICE9PSBickVsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4pqg77iPIFdhcm5pbmc6IEV4cGVjdGVkIHRvIHByb2Nlc3MgJHtickVsZW1lbnRzLmxlbmd0aH0gYnJlYWtzIGJ1dCBwcm9jZXNzZWQgJHtickluZGV4fWBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGVudDtcclxuICB9XHJcblxyXG4gIC8vIFByb2Nlc3MgY29udGVudCB1c2luZyBjYWNoZWQgZG9jdW1lbnQgb3JkZXIgcGF0dGVybiAtIEZVTExZIERZTkFNSUNcclxuICBwcm9jZXNzQ29udGVudFdpdGhDYWNoZWRQYXR0ZXJuKFxyXG4gICAgY29udGVudHMsXHJcbiAgICByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICBjb250ZW50LFxyXG4gICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgIGJyZWFrUGF0dGVybixcclxuICAgIGZpbGVOYW1lXHJcbiAgKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCfjq8gUHJvY2Vzc2luZyAke2NvbnRlbnRzLmxlbmd0aH0gY29udGVudCBpdGVtcyB3aXRoIGNhY2hlZCBwYXR0ZXJuICgke2JyZWFrUGF0dGVybi5sZW5ndGh9IHBhdHRlcm4gZW50cmllcylgXHJcbiAgICApO1xyXG5cclxuICAgIC8vIERZTkFNSUM6IEhhbmRsZSBhbnkgbnVtYmVyIG9mIGNvbnRlbnQgaXRlbXMgYW5kIGFueSBicmVhayBkaXN0cmlidXRpb25cclxuICAgIGNvbnRlbnRzLmZvckVhY2goKGNvbnRlbnRJdGVtLCBjb250ZW50SW5kZXgpID0+IHtcclxuICAgICAgLy8gQWRkIHRoZSBjb250ZW50XHJcbiAgICAgIGNvbnN0IHRleHQgPSBJRE1MVXRpbHMuZGVjb2RlWE1MRW50aXRpZXMoU3RyaW5nKGNvbnRlbnRJdGVtKSk7XHJcbiAgICAgIGNvbnRlbnQgKz0gdGV4dDtcclxuICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICB0ZXh0OiB0ZXh0LnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXG5cIikucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcblxcblwiKSxcclxuICAgICAgICBmb3JtYXR0aW5nOiByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCflKcgQWRkZWQgY29udGVudFske2NvbnRlbnRJbmRleH1dOiAke0pTT04uc3RyaW5naWZ5KHRleHQpfWApO1xyXG5cclxuICAgICAgLy8gRFlOQU1JQzogRmluZCB0aGUgY29ycmVzcG9uZGluZyBwYXR0ZXJuIGVudHJ5XHJcbiAgICAgIGNvbnN0IHBhdHRlcm5FbnRyeSA9IGJyZWFrUGF0dGVybi5maW5kKFxyXG4gICAgICAgIChwKSA9PiBwLmNvbnRlbnRJbmRleCA9PT0gY29udGVudEluZGV4XHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChwYXR0ZXJuRW50cnkpIHtcclxuICAgICAgICBjb25zdCBicmVha3NUb0FkZCA9IHBhdHRlcm5FbnRyeS5icmVha3NBZnRlcjtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDwn46vIFBhdHRlcm4gc2F5cyBjb250ZW50WyR7Y29udGVudEluZGV4fV0gc2hvdWxkIGhhdmUgJHticmVha3NUb0FkZH0gYnJlYWtzIGFmdGVyIGl0YFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIERZTkFNSUM6IEFkZCB0aGUgZXhhY3QgbnVtYmVyIG9mIGJyZWFrcyBzcGVjaWZpZWQgaW4gdGhlIHBhdHRlcm5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJyZWFrc1RvQWRkOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSBcIlxcblwiO1xyXG4gICAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgdGV4dDogbGluZUJyZWFrVGV4dFxyXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpXHJcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXG5cXG5cIiksXHJcbiAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGJyZWFrVHlwZTogXCJsaW5lXCIsXHJcbiAgICAgICAgICAgICAgc291cmNlOiBcInByZWNpc2UgZG9jdW1lbnQgb3JkZXJcIixcclxuICAgICAgICAgICAgICBjb250ZW50SW5kZXg6IGNvbnRlbnRJbmRleCxcclxuICAgICAgICAgICAgICBicmVha0luZGV4OiBpLFxyXG4gICAgICAgICAgICAgIHRvdGFsQnJlYWtzQWZ0ZXJDb250ZW50OiBicmVha3NUb0FkZCxcclxuICAgICAgICAgICAgICBwYXR0ZXJuRW50cnk6IHBhdHRlcm5FbnRyeSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBg8J+OryBBZGRlZCBwcmVjaXNlIEJyWyR7XHJcbiAgICAgICAgICAgICAgaSArIDFcclxuICAgICAgICAgICAgfS8ke2JyZWFrc1RvQWRkfV0gYWZ0ZXIgY29udGVudFske2NvbnRlbnRJbmRleH1dOiAke0pTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgICAgICAgIGxpbmVCcmVha1RleHRcclxuICAgICAgICAgICAgKX1gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDimqDvuI8gTm8gcGF0dGVybiBlbnRyeSBmb3VuZCBmb3IgY29udGVudFske2NvbnRlbnRJbmRleH1dIC0gdGhpcyBpcyB1bnVzdWFsIGJ1dCBub3QgY3JpdGljYWxgXHJcbiAgICAgICAgKTtcclxuICAgICAgICAvLyBEWU5BTUlDOiBJZiBubyBwYXR0ZXJuIGVudHJ5LCBkb24ndCBhZGQgYW55IGJyZWFrcyAodGhlIHBhdHRlcm4gc2hvdWxkIGNvdmVyIGFsbCBjb250ZW50KVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBWQUxJREFUSU9OOiBDaGVjayBpZiB3ZSBwcm9jZXNzZWQgYWxsIGV4cGVjdGVkIGNvbnRlbnRcclxuICAgIGNvbnN0IGV4cGVjdGVkQ29udGVudENvdW50ID0gYnJlYWtQYXR0ZXJuLmxlbmd0aDtcclxuICAgIGlmIChjb250ZW50cy5sZW5ndGggIT09IGV4cGVjdGVkQ29udGVudENvdW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDimqDvuI8gV2FybmluZzogRXhwZWN0ZWQgJHtleHBlY3RlZENvbnRlbnRDb3VudH0gY29udGVudCBpdGVtcyBidXQgcHJvY2Vzc2VkICR7Y29udGVudHMubGVuZ3RofWBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGVudDtcclxuICB9XHJcblxyXG4gIC8vIERZTkFNSUM6IENhbGN1bGF0ZSBicmVha3MgZGlzdHJpYnV0aW9uIGFzIGZhbGxiYWNrIC0gY29tcGxldGVseSBnZW5lcmljXHJcbiAgY2FsY3VsYXRlQnJlYWtzQWZ0ZXJDb250ZW50KGNvbnRlbnRJbmRleCwgdG90YWxDb250ZW50LCB0b3RhbEJyZWFrcykge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5SnIEZBTExCQUNLOiBDYWxjdWxhdGluZyBicmVha3MgZm9yIGNvbnRlbnRbJHtjb250ZW50SW5kZXh9XSBvZiAke3RvdGFsQ29udGVudH0gdG90YWwsICR7dG90YWxCcmVha3N9IHRvdGFsIGJyZWFrc2BcclxuICAgICk7XHJcblxyXG4gICAgLy8gRURHRSBDQVNFOiBObyBicmVha3MgdG8gZGlzdHJpYnV0ZVxyXG4gICAgaWYgKHRvdGFsQnJlYWtzID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SnIE5vIGJyZWFrcyB0byBkaXN0cmlidXRlYCk7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVER0UgQ0FTRTogT25seSBvbmUgY29udGVudCBpdGVtXHJcbiAgICBpZiAodG90YWxDb250ZW50ID09PSAxKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SnIFNpbmdsZSBjb250ZW50IGl0ZW0gZ2V0cyBhbGwgJHt0b3RhbEJyZWFrc30gYnJlYWtzYCk7XHJcbiAgICAgIHJldHVybiBjb250ZW50SW5kZXggPT09IDAgPyB0b3RhbEJyZWFrcyA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRURHRSBDQVNFOiBMYXN0IGNvbnRlbnQgaXRlbVxyXG4gICAgaWYgKGNvbnRlbnRJbmRleCA9PT0gdG90YWxDb250ZW50IC0gMSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg8J+UpyBMYXN0IGNvbnRlbnQgaXRlbSBnZXRzIG5vIGJyZWFrcyBpbiBzdGFuZGFyZCBkaXN0cmlidXRpb25gXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERZTkFNSUM6IERpc3RyaWJ1dGUgYnJlYWtzIGFtb25nIG5vbi1sYXN0IGNvbnRlbnQgaXRlbXNcclxuICAgIGNvbnN0IG5vbkxhc3RDb250ZW50SXRlbXMgPSB0b3RhbENvbnRlbnQgLSAxO1xyXG4gICAgY29uc3QgYmFzZUJyZWFrcyA9IE1hdGguZmxvb3IodG90YWxCcmVha3MgLyBub25MYXN0Q29udGVudEl0ZW1zKTtcclxuICAgIGNvbnN0IGV4dHJhQnJlYWtzID0gdG90YWxCcmVha3MgJSBub25MYXN0Q29udGVudEl0ZW1zO1xyXG5cclxuICAgIC8vIERZTkFNSUM6IERpc3RyaWJ1dGUgZXh0cmEgYnJlYWtzIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCB0byBtYXRjaCBjb21tb24gSURNTCBwYXR0ZXJuc1xyXG4gICAgLy8gd2hlcmUgbGF0ZXIgY29udGVudCB0ZW5kcyB0byBoYXZlIG1vcmUgYnJlYWtzXHJcbiAgICBjb25zdCBicmVha3NGb3JUaGlzQ29udGVudCA9XHJcbiAgICAgIGJhc2VCcmVha3MgKyAoY29udGVudEluZGV4ID49IG5vbkxhc3RDb250ZW50SXRlbXMgLSBleHRyYUJyZWFrcyA/IDEgOiAwKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCflKcgQ29udGVudFske2NvbnRlbnRJbmRleH1dIGdldHMgJHticmVha3NGb3JUaGlzQ29udGVudH0gYnJlYWtzIChiYXNlOiAke2Jhc2VCcmVha3N9LCBleHRyYTogJHtleHRyYUJyZWFrc30pYFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gYnJlYWtzRm9yVGhpc0NvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICAvLyBQcm9jZXNzIG9ubHkgQ29udGVudCBlbGVtZW50c1xyXG4gIHByb2Nlc3NDb250ZW50RWxlbWVudHMoXHJcbiAgICByYW5nZSxcclxuICAgIHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgZmlsZU5hbWVcclxuICApIHtcclxuICAgIGNvbnN0IGNvbnRlbnRzID0gQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KVxyXG4gICAgICA/IHJhbmdlLkNvbnRlbnRcclxuICAgICAgOiBbcmFuZ2UuQ29udGVudF07XHJcblxyXG4gICAgY29udGVudHMuZm9yRWFjaCgoY29udGVudEl0ZW0pID0+IHtcclxuICAgICAgY29uc3QgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyhTdHJpbmcoY29udGVudEl0ZW0pKTtcclxuICAgICAgY29udGVudCArPSB0ZXh0O1xyXG4gICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgIHRleHQ6IHRleHQucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgIGZvcm1hdHRpbmc6IHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gUHJvY2VzcyBvbmx5IEJyIGVsZW1lbnRzXHJcbiAgcHJvY2Vzc0JyRWxlbWVudHMoXHJcbiAgICByYW5nZSxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgZGVidWdJbmZvLFxyXG4gICAgcmFuZ2VJbmRleCxcclxuICAgIGZpbGVOYW1lXHJcbiAgKSB7XHJcbiAgICBjb25zdCBickVsZW1lbnRzID0gQXJyYXkuaXNBcnJheShyYW5nZS5CcikgPyByYW5nZS5CciA6IFtyYW5nZS5Ccl07XHJcblxyXG4gICAgYnJFbGVtZW50cy5mb3JFYWNoKChiciwgYnJJbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gXCJcXG5cIjtcclxuICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHQucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICBicmVha1R5cGU6IFwibGluZVwiLFxyXG4gICAgICAgICAgc291cmNlOiBcInN0YW5kYWxvbmUgQnIgZWxlbWVudFwiLFxyXG4gICAgICAgICAgcmFuZ2VJbmRleDogcmFuZ2VJbmRleCxcclxuICAgICAgICAgIGJySW5kZXg6IGJySW5kZXgsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgdHlwZTogXCJTdGFuZGFsb25lIEJyIGVsZW1lbnRcIixcclxuICAgICAgICBsb2NhdGlvbjogYENoYXJhY3RlclN0eWxlUmFuZ2VbJHtyYW5nZUluZGV4fV0sIEJyWyR7YnJJbmRleH1dYCxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHRoaXMgaGVscGVyIG1ldGhvZCB0byBiZXR0ZXIgaGFuZGxlIG1peGVkIGNvbnRlbnQgYW5kIEJyIGVsZW1lbnRzXHJcbiAgYW5hbHl6ZUNvbnRlbnRTdHJ1Y3R1cmUocmFuZ2UpIHtcclxuICAgIGNvbnN0IHN0cnVjdHVyZSA9IHtcclxuICAgICAgaGFzQ29udGVudDogISFyYW5nZS5Db250ZW50LFxyXG4gICAgICBoYXNCcjogcmFuZ2UuQnIgIT09IHVuZGVmaW5lZCxcclxuICAgICAgY29udGVudEl0ZW1zOiByYW5nZS5Db250ZW50XHJcbiAgICAgICAgPyBBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpXHJcbiAgICAgICAgICA/IHJhbmdlLkNvbnRlbnRcclxuICAgICAgICAgIDogW3JhbmdlLkNvbnRlbnRdXHJcbiAgICAgICAgOiBbXSxcclxuICAgICAgYnJFbGVtZW50czogcmFuZ2UuQnJcclxuICAgICAgICA/IEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpXHJcbiAgICAgICAgICA/IHJhbmdlLkJyXHJcbiAgICAgICAgICA6IFtyYW5nZS5Ccl1cclxuICAgICAgICA6IFtdLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIkNvbnRlbnQgc3RydWN0dXJlIGFuYWx5c2lzOlwiLCBzdHJ1Y3R1cmUpO1xyXG4gICAgcmV0dXJuIHN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIGhlbHBlciBmb3IgcHJvY2Vzc2luZyBpbnRlcmxlYXZlZCBjb250ZW50IGFuZCBicmVha3NcclxuICBwcm9jZXNzSW50ZXJsZWF2ZWRDb250ZW50KHJhbmdlLCByZXNvbHZlZEZvcm1hdHRpbmcpIHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgIGxldCBjb250ZW50ID0gXCJcIjtcclxuXHJcbiAgICAvLyBUaGlzIG1ldGhvZCB3b3VsZCBuZWVkIGFjY2VzcyB0byB0aGUgYWN0dWFsIFhNTCBzdHJ1Y3R1cmUgdG8gZGV0ZXJtaW5lXHJcbiAgICAvLyB0aGUgZXhhY3Qgb3JkZXIgb2YgQ29udGVudCBhbmQgQnIgZWxlbWVudHMuIEZvciBub3csIHdlJ2xsIHVzZSB0aGVcclxuICAgIC8vIGFwcHJvYWNoIGFib3ZlIHdoaWNoIGhhbmRsZXMgdGhlIG1vc3QgY29tbW9uIGNhc2UuXHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBIZWxwZXIgbWV0aG9kIHRvIGV4dHJhY3QgQnIgZWxlbWVudHMgd2l0aCBjb250ZXh0XHJcbiAgZXh0cmFjdEJyRWxlbWVudHMocmFuZ2UpIHtcclxuICAgIGNvbnN0IGJyRWxlbWVudHMgPSBbXTtcclxuXHJcbiAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCflKcgUHJvY2Vzc2luZyBCciBlbGVtZW50czpcIiwge1xyXG4gICAgICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpLFxyXG4gICAgICAgIGNvdW50OiBBcnJheS5pc0FycmF5KHJhbmdlLkJyKSA/IHJhbmdlLkJyLmxlbmd0aCA6IDEsXHJcbiAgICAgICAgcmF3QnI6IHJhbmdlLkJyLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhbmdlLkJyKSkge1xyXG4gICAgICAgIHJhbmdlLkJyLmZvckVhY2goKGJyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgYnJFbGVtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogXCJsaW5lXCIsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBpbmRleCA9PT0gMCA/IFwic3RhcnRcIiA6IFwibWlkZGxlXCIsXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IGJyLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBg8J+UpyBDcmVhdGVkICR7YnJFbGVtZW50cy5sZW5ndGh9IGxpbmUgYnJlYWsgZWxlbWVudHMgZnJvbSBhcnJheSAtIEVBQ0ggU0hPVUxEIENSRUFURSBPTkUgXFxcXG5gXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBickVsZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXHJcbiAgICAgICAgICBwb3NpdGlvbjogXCJlbmRcIixcclxuICAgICAgICAgIGVsZW1lbnQ6IHJhbmdlLkJyLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBDcmVhdGVkIDEgbGluZSBicmVhayBlbGVtZW50IGZyb20gc2luZ2xlIEJyXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJyRWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGxpbmUgYnJlYWsgdHlwZVxyXG4gIGRldGVybWluZUxpbmVCcmVha1R5cGUoYnJJbmZvLCBjb250ZXh0KSB7XHJcbiAgICAvLyBEaWZmZXJlbnQgbGluZSBicmVhayBjaGFyYWN0ZXJzIGJhc2VkIG9uIGNvbnRleHRcclxuICAgIHN3aXRjaCAoYnJJbmZvLnR5cGUpIHtcclxuICAgICAgY2FzZSBcInBhcmFncmFwaFwiOlxyXG4gICAgICAgIHJldHVybiBcIlxcblxcblwiOyAvLyBEb3VibGUgbGluZSBicmVhayBmb3IgcGFyYWdyYXBoIHNlcGFyYXRpb25cclxuICAgICAgY2FzZSBcImZvcmNlZFwiOlxyXG4gICAgICAgIHJldHVybiBcIlxcblwiOyAvLyBGb3JjZWQgbGluZSBicmVhayAoU2hpZnQrRW50ZXIgZXF1aXZhbGVudClcclxuICAgICAgY2FzZSBcImxpbmVcIjpcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gXCJcXG5cIjsgLy8gU3RhbmRhcmQgbGluZSBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogRGV0ZXJtaW5lIGlmIGFuIGltcGxpY2l0IGxpbmUgYnJlYWsgc2hvdWxkIGJlIGluc2VydGVkXHJcbiAgc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsoY3VycmVudFJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpIHtcclxuICAgIC8vIERvbid0IGluc2VydCBpbXBsaWNpdCBicmVha3MgaWYgZXhwbGljaXQgQnIgZWxlbWVudHMgYXJlIHByZXNlbnRcclxuICAgIGlmIChjdXJyZW50UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCB8fCBuZXh0UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5zZXJ0IGJyZWFrcyBiZXR3ZWVuIGRpZmZlcmVudCBjaGFyYWN0ZXIgc3R5bGVzIGluIGRpZmZlcmVudCBwYXJhZ3JhcGhzXHJcbiAgICBjb25zdCBjdXJyZW50Q2hhclN0eWxlID0gY3VycmVudFJhbmdlW1wiQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGVcIl07XHJcbiAgICBjb25zdCBuZXh0Q2hhclN0eWxlID0gbmV4dFJhbmdlW1wiQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGVcIl07XHJcblxyXG4gICAgLy8gSWYgd2UncmUgaW4gYSBjb250ZXh0IHdoZXJlIHN0eWxlcyBjaGFuZ2Ugc2lnbmlmaWNhbnRseSwgYWRkIGEgYnJlYWtcclxuICAgIGlmIChcclxuICAgICAgY3VycmVudENoYXJTdHlsZSAmJlxyXG4gICAgICBuZXh0Q2hhclN0eWxlICYmXHJcbiAgICAgIGN1cnJlbnRDaGFyU3R5bGUgIT09IG5leHRDaGFyU3R5bGVcclxuICAgICkge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIG1pZ2h0IGJlIGEgdGl0bGUvaGVhZGluZyBmb2xsb3dlZCBieSBib2R5IHRleHRcclxuICAgICAgY29uc3Qgc3R5bGVJbmRpY2F0ZXNCcmVhayA9IHRoaXMuc3R5bGVJbmRpY2F0ZXNMaW5lQnJlYWsoXHJcbiAgICAgICAgY3VycmVudENoYXJTdHlsZSxcclxuICAgICAgICBuZXh0Q2hhclN0eWxlXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBzdHlsZUluZGljYXRlc0JyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEFuYWx5emUgaWYgc3R5bGUgY2hhbmdlIGluZGljYXRlcyBhIGxpbmUgYnJlYWtcclxuICBzdHlsZUluZGljYXRlc0xpbmVCcmVhayhjdXJyZW50U3R5bGUsIG5leHRTdHlsZSkge1xyXG4gICAgY29uc3QgdGl0bGVJbmRpY2F0b3JzID0gW1widGl0bGVcIiwgXCJoZWFkaW5nXCIsIFwiaGVhZGVyXCJdO1xyXG4gICAgY29uc3QgYm9keUluZGljYXRvcnMgPSBbXCJib2R5XCIsIFwidGV4dFwiLCBcIm5vcm1hbFwiXTtcclxuXHJcbiAgICBjb25zdCBjdXJyZW50SXNUaXRsZSA9IHRpdGxlSW5kaWNhdG9ycy5zb21lKChpbmRpY2F0b3IpID0+XHJcbiAgICAgIGN1cnJlbnRTdHlsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGluZGljYXRvcilcclxuICAgICk7XHJcbiAgICBjb25zdCBuZXh0SXNCb2R5ID0gYm9keUluZGljYXRvcnMuc29tZSgoaW5kaWNhdG9yKSA9PlxyXG4gICAgICBuZXh0U3R5bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhpbmRpY2F0b3IpXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBjdXJyZW50SXNUaXRsZSAmJiBuZXh0SXNCb2R5O1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogQW5hbHl6ZSBsaW5lIGJyZWFrIHR5cGVzIGluIGZvcm1hdHRlZCBjb250ZW50XHJcbiAgYW5hbHl6ZUxpbmVCcmVha1R5cGVzKGZvcm1hdHRlZENvbnRlbnQpIHtcclxuICAgIGNvbnN0IHR5cGVzID0ge1xyXG4gICAgICBleHBsaWNpdDogMCwgLy8gRnJvbSA8QnIvPiBlbGVtZW50c1xyXG4gICAgICBpbXBsaWNpdDogMCwgLy8gSW5mZXJyZWQgZnJvbSBzdHlsZSBjaGFuZ2VzXHJcbiAgICAgIHBhcmFncmFwaDogMCwgLy8gQmV0d2VlbiBwYXJhZ3JhcGhzXHJcbiAgICAgIGRpcmVjdDogMCwgLy8gRGlyZWN0IEJyIGVsZW1lbnRzXHJcbiAgICB9O1xyXG5cclxuICAgIGZvcm1hdHRlZENvbnRlbnQuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICBpZiAoaXRlbS5mb3JtYXR0aW5nPy5pc0JyZWFrKSB7XHJcbiAgICAgICAgY29uc3QgYnJlYWtUeXBlID0gaXRlbS5mb3JtYXR0aW5nLmJyZWFrVHlwZSB8fCBcInVua25vd25cIjtcclxuICAgICAgICBpZiAodHlwZXMuaGFzT3duUHJvcGVydHkoYnJlYWtUeXBlKSkge1xyXG4gICAgICAgICAgdHlwZXNbYnJlYWtUeXBlXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHR5cGVzO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdERldGFpbGVkRm9ybWF0dGluZ0Zyb21SYW5nZShyYW5nZSkge1xyXG4gICAgY29uc3QgZm9ybWF0dGluZyA9IHt9O1xyXG5cclxuICAgIC8vIEV4dHJhY3QgYWxsIHBvc3NpYmxlIGZvbnQgYXR0cmlidXRlc1xyXG4gICAgY29uc3QgZm9udEF0dHJpYnV0ZXMgPSBbXHJcbiAgICAgIFwiQF9BcHBsaWVkRm9udFwiLFxyXG4gICAgICBcIkBfRm9udEZhbWlseVwiLFxyXG4gICAgICBcIkBfRm9udFwiLFxyXG4gICAgICBcIkBfUG9zdFNjcmlwdE5hbWVcIixcclxuICAgICAgXCJAX0ZvbnROYW1lXCIsXHJcbiAgICBdO1xyXG5cclxuICAgIGZvbnRBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcclxuICAgICAgaWYgKHJhbmdlW2F0dHJdKSB7XHJcbiAgICAgICAgZm9ybWF0dGluZy5mb250UmVmZXJlbmNlID0gcmFuZ2VbYXR0cl07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgZm9udCBhbmQgc2l6ZSBhdHRyaWJ1dGVzXHJcbiAgICBjb25zdCByYXdGb250U2l6ZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbXCJAX1BvaW50U2l6ZVwiXSk7XHJcbiAgICBmb3JtYXR0aW5nLmZvbnRTaXplID0gdGhpcy5jb252ZXJ0Rm9udFNpemVUb1BpeGVscyhyYXdGb250U2l6ZSk7IC8vIEFEREVEOiBDb252ZXJ0IHRvIHBpeGVsc1xyXG4gICAgZm9ybWF0dGluZy5vcmlnaW5hbEZvbnRTaXplID0gcmF3Rm9udFNpemU7IC8vIEFEREVEOiBQcmVzZXJ2ZSBvcmlnaW5hbFxyXG5cclxuICAgIC8vIEVOSEFOQ0VEOiBFeHRyYWN0IGxlYWRpbmcgd2l0aCBwcm9wZXIgcHJvY2Vzc2luZ1xyXG4gICAgY29uc3QgcmF3TGVhZGluZyA9IHJhbmdlW1wiQF9MZWFkaW5nXCJdO1xyXG4gICAgZm9ybWF0dGluZy5sZWFkaW5nID0gdGhpcy5wcm9jZXNzTGVhZGluZ1ZhbHVlKFxyXG4gICAgICByYXdMZWFkaW5nLFxyXG4gICAgICBmb3JtYXR0aW5nLmZvbnRTaXplXHJcbiAgICApO1xyXG4gICAgZm9ybWF0dGluZy5sZWFkaW5nVHlwZSA9IHRoaXMuZGV0ZXJtaW5lTGVhZGluZ1R5cGUocmF3TGVhZGluZyk7XHJcblxyXG4gICAgLy8gRXh0cmFjdCBjb2xvciBhbmQgc3R5bGUgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy5maWxsQ29sb3IgPSByYW5nZVtcIkBfRmlsbENvbG9yXCJdO1xyXG4gICAgZm9ybWF0dGluZy5zdHJva2VDb2xvciA9IHJhbmdlW1wiQF9TdHJva2VDb2xvclwiXTtcclxuICAgIGZvcm1hdHRpbmcuZm9udFN0eWxlID0gcmFuZ2VbXCJAX0ZvbnRTdHlsZVwiXTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IGFkdmFuY2VkIHR5cG9ncmFwaHkgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy50cmFja2luZyA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbXCJAX1RyYWNraW5nXCJdKTtcclxuICAgIGZvcm1hdHRpbmcuYmFzZWxpbmVTaGlmdCA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbXCJAX0Jhc2VsaW5lU2hpZnRcIl0pO1xyXG4gICAgZm9ybWF0dGluZy5rZXJuaW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfS2VybmluZ1wiXSk7XHJcbiAgICBmb3JtYXR0aW5nLmhvcml6b250YWxTY2FsZSA9XHJcbiAgICAgIElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbXCJAX0hvcml6b250YWxTY2FsZVwiXSkgfHwgMTAwO1xyXG4gICAgZm9ybWF0dGluZy52ZXJ0aWNhbFNjYWxlID1cclxuICAgICAgSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfVmVydGljYWxTY2FsZVwiXSkgfHwgMTAwO1xyXG5cclxuICAgIC8vIEVOSEFOQ0VEOiBFeHRyYWN0IEluRGVzaWduLXNwZWNpZmljIHRleHQgbGF5b3V0IHByb3BlcnRpZXMgZm9yIHByZWNpc2UgcmVuZGVyaW5nXHJcbiAgICBmb3JtYXR0aW5nLmJhc2VsaW5lR3JpZEFsaWduID0gcmFuZ2VbXCJAX0FsaWduVG9CYXNlbGluZVwiXSB8fCBcIk5vbmVcIjtcclxuICAgIGZvcm1hdHRpbmcuZHJvcENhcExpbmVzID1cclxuICAgICAgSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfRHJvcENhcExpbmVzXCJdKSB8fCAwO1xyXG4gICAgZm9ybWF0dGluZy5kcm9wQ2FwQ2hhcmFjdGVycyA9XHJcbiAgICAgIElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbXCJAX0Ryb3BDYXBDaGFyYWN0ZXJzXCJdKSB8fCAwO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgcGFyYWdyYXBoLWxldmVsIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxyXG4gICAgLy8gQ1JJVElDQUwgRklYOiBPbmx5IHNldCBhbGlnbm1lbnQgaWYgZXhwbGljaXRseSBzcGVjaWZpZWQsIGFsbG93aW5nIHBhcmFncmFwaCBpbmhlcml0YW5jZVxyXG4gICAgY29uc3QgZXhwbGljaXRBbGlnbm1lbnQgPSByYW5nZVtcIkBfSnVzdGlmaWNhdGlvblwiXSB8fCByYW5nZVtcIkBfQWxpZ25tZW50XCJdO1xyXG4gICAgaWYgKGV4cGxpY2l0QWxpZ25tZW50KSB7XHJcbiAgICAgIGZvcm1hdHRpbmcuYWxpZ25tZW50ID0gZXhwbGljaXRBbGlnbm1lbnQ7XHJcbiAgICB9XHJcbiAgICBmb3JtYXR0aW5nLmxlZnRJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlW1wiQF9MZWZ0SW5kZW50XCJdKTtcclxuICAgIGZvcm1hdHRpbmcucmlnaHRJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlW1wiQF9SaWdodEluZGVudFwiXSk7XHJcbiAgICBmb3JtYXR0aW5nLmZpcnN0TGluZUluZGVudCA9IElETUxVdGlscy5wYXJzZU51bWVyaWMoXHJcbiAgICAgIHJhbmdlW1wiQF9GaXJzdExpbmVJbmRlbnRcIl1cclxuICAgICk7XHJcbiAgICBmb3JtYXR0aW5nLnNwYWNlQmVmb3JlID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfU3BhY2VCZWZvcmVcIl0pO1xyXG4gICAgZm9ybWF0dGluZy5zcGFjZUFmdGVyID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfU3BhY2VBZnRlclwiXSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBmb3IgQ1NTXHJcbiAgICBmb3JtYXR0aW5nLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPVxyXG4gICAgICB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoZm9ybWF0dGluZyk7XHJcblxyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmc7XHJcbiAgfVxyXG5cclxuICAvLyBGSVhFRDogUHJvY2VzcyBsZWFkaW5nIHZhbHVlcyB3aXRoIEluRGVzaWduLXNwZWNpZmljIGxvZ2ljIGFuZCBjb252ZXJ0IHRvIHBpeGVsc1xyXG4gIHByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9udFNpemUpIHtcclxuICAgIGlmICghcmF3TGVhZGluZykgcmV0dXJuIFwiYXV0b1wiO1xyXG5cclxuICAgIC8vIEhhbmRsZSBcImF1dG9cIiBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZyA9PT0gXCJhdXRvXCIgfHwgcmF3TGVhZGluZyA9PT0gXCJBdXRvXCIpIHtcclxuICAgICAgcmV0dXJuIGZvbnRTaXplID8gZm9udFNpemUgKiAxLjIgOiBcImF1dG9cIjsgLy8gSW5EZXNpZ24gZGVmYXVsdCBhdXRvIGxlYWRpbmcgaXMgMTIwJVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZSBudW1lcmljIGxlYWRpbmcgKGluIHBvaW50cykgLSBGSVhFRDogQ29udmVydCB0byBwaXhlbHNcclxuICAgIGNvbnN0IG51bWVyaWNMZWFkaW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYXdMZWFkaW5nKTtcclxuICAgIGlmIChudW1lcmljTGVhZGluZykge1xyXG4gICAgICAvLyBGSVhFRDogQ29udmVydCBudW1lcmljIGxlYWRpbmcgdG8gcGl4ZWxzIGlmIHVuaXRDb252ZXJ0ZXIgaXMgYXZhaWxhYmxlXHJcbiAgICAgIGlmIChcclxuICAgICAgICB0aGlzLnVuaXRDb252ZXJ0ZXIgJiZcclxuICAgICAgICB0aGlzLmRvY3VtZW50VW5pdHMgJiZcclxuICAgICAgICB0aGlzLnVuaXRDb252ZXJ0ZXIuaXNTdXBwb3J0ZWRVbml0KHRoaXMuZG9jdW1lbnRVbml0cylcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc3QgcGl4ZWxMZWFkaW5nID0gdGhpcy51bml0Q29udmVydGVyLnRvUGl4ZWxzKFxyXG4gICAgICAgICAgbnVtZXJpY0xlYWRpbmcsXHJcbiAgICAgICAgICB0aGlzLmRvY3VtZW50VW5pdHNcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfk5AgQ29udmVydGVkIGxlYWRpbmc6ICR7bnVtZXJpY0xlYWRpbmd9ICR7dGhpcy5kb2N1bWVudFVuaXRzfSDihpIgJHtwaXhlbExlYWRpbmd9IHB4YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHBpeGVsTGVhZGluZztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVtZXJpY0xlYWRpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIHBlcmNlbnRhZ2UtYmFzZWQgbGVhZGluZ1xyXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoXCIlXCIpKSB7XHJcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KHJhd0xlYWRpbmcucmVwbGFjZShcIiVcIiwgXCJcIikpO1xyXG4gICAgICByZXR1cm4gZm9udFNpemUgPyAoZm9udFNpemUgKiBwZXJjZW50YWdlKSAvIDEwMCA6IFwiYXV0b1wiO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBcImF1dG9cIjtcclxuICB9XHJcblxyXG4gIC8vIE5FVzogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGxlYWRpbmcgYmVpbmcgdXNlZFxyXG4gIGRldGVybWluZUxlYWRpbmdUeXBlKHJhd0xlYWRpbmcpIHtcclxuICAgIGlmICghcmF3TGVhZGluZyB8fCByYXdMZWFkaW5nID09PSBcImF1dG9cIiB8fCByYXdMZWFkaW5nID09PSBcIkF1dG9cIikge1xyXG4gICAgICByZXR1cm4gXCJhdXRvXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoXCIlXCIpKSB7XHJcbiAgICAgIHJldHVybiBcInBlcmNlbnRhZ2VcIjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYXdMZWFkaW5nKSkge1xyXG4gICAgICByZXR1cm4gXCJhYnNvbHV0ZVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBcInVua25vd25cIjtcclxuICB9XHJcblxyXG4gIC8vIE5FVzogQ2FsY3VsYXRlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBmb3IgQ1NTIHJlbmRlcmluZ1xyXG4gIGNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoZm9ybWF0dGluZykge1xyXG4gICAgY29uc3QgZm9udFNpemUgPSBmb3JtYXR0aW5nLmZvbnRTaXplIHx8IDEyO1xyXG4gICAgY29uc3QgbGVhZGluZyA9IGZvcm1hdHRpbmcubGVhZGluZztcclxuXHJcbiAgICBpZiAobGVhZGluZyA9PT0gXCJhdXRvXCIpIHtcclxuICAgICAgcmV0dXJuIDEuMjsgLy8gQ1NTIGxpbmUtaGVpZ2h0IHJhdGlvIGZvciBhdXRvXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBsZWFkaW5nID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIC8vIENvbnZlcnQgcG9pbnRzIHRvIENTUyBsaW5lLWhlaWdodCByYXRpb1xyXG4gICAgICByZXR1cm4gbGVhZGluZyAvIGZvbnRTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAxLjI7IC8vIEZhbGxiYWNrXHJcbiAgfVxyXG5cclxuICBleHRyYWN0VGV4dEZvcm1hdHRpbmcoc3RvcnlEYXRhKSB7XHJcbiAgICBjb25zdCBmb3JtYXR0aW5nID0ge1xyXG4gICAgICBwYXJhZ3JhcGhTdHlsZXM6IFtdLFxyXG4gICAgICBjaGFyYWN0ZXJTdHlsZXM6IFtdLFxyXG4gICAgICBhcHBsaWVkU3R5bGVzOiBbXSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gRXh0cmFjdCBhcHBsaWVkIHBhcmFncmFwaCBzdHlsZXNcclxuICAgIGlmIChzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZSkge1xyXG4gICAgICBjb25zdCByYW5nZXMgPSBBcnJheS5pc0FycmF5KHN0b3J5RGF0YS5QYXJhZ3JhcGhTdHlsZVJhbmdlKVxyXG4gICAgICAgID8gc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2VcclxuICAgICAgICA6IFtzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZV07XHJcblxyXG4gICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcclxuICAgICAgICBjb25zdCBhcHBsaWVkU3R5bGUgPSByYW5nZVtcIkBfQXBwbGllZFBhcmFncmFwaFN0eWxlXCJdO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGFwcGxpZWRTdHlsZSAmJlxyXG4gICAgICAgICAgIWZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVzLmluY2x1ZGVzKGFwcGxpZWRTdHlsZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVzLnB1c2goYXBwbGllZFN0eWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgY2hhcmFjdGVyIHN0eWxlcyB3aXRoaW4gcGFyYWdyYXBoIHJhbmdlc1xyXG4gICAgICAgIGlmIChyYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlKSB7XHJcbiAgICAgICAgICBjb25zdCBjaGFyUmFuZ2VzID0gQXJyYXkuaXNBcnJheShyYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlKVxyXG4gICAgICAgICAgICA/IHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2VcclxuICAgICAgICAgICAgOiBbcmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZV07XHJcblxyXG4gICAgICAgICAgY2hhclJhbmdlcy5mb3JFYWNoKChjaGFyUmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hhclN0eWxlID0gY2hhclJhbmdlW1wiQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGVcIl07XHJcbiAgICAgICAgICAgIGlmIChjaGFyU3R5bGUgJiYgIWZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVzLmluY2x1ZGVzKGNoYXJTdHlsZSkpIHtcclxuICAgICAgICAgICAgICBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlcy5wdXNoKGNoYXJTdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmc7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgdGhpcyBtZXRob2QgdG8gZGVidWcgcmF3IHN0b3J5IGNvbnRlbnRcclxuICBkZWJ1Z1Jhd1N0b3J5Q29udGVudChzdG9yeURhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiXFxu8J+UjSBSQVcgU1RPUlkgQ09OVEVOVCBERUJVRzpcIik7XHJcbiAgICBjb25zb2xlLmxvZyhcIlN0b3J5IGtleXM6XCIsIE9iamVjdC5rZXlzKHN0b3J5RGF0YSkpO1xyXG5cclxuICAgIGNvbnN0IGZpbmRDaGFyYWN0ZXJSYW5nZXMgPSAob2JqLCBwYXRoID0gXCJcIikgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGtleSA9PT0gXCJDaGFyYWN0ZXJTdHlsZVJhbmdlXCIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfk50gRm91bmQgQ2hhcmFjdGVyU3R5bGVSYW5nZSBhdCAke3BhdGh9OmAsIG9ialtrZXldKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShvYmpba2V5XSkgPyBvYmpba2V5XSA6IFtvYmpba2V5XV07XHJcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgIGAgIFJhbmdlICR7aW5kZXggKyAxfSBhdHRyaWJ1dGVzOmAsXHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyYW5nZSkuZmlsdGVyKChrKSA9PiBrLnN0YXJ0c1dpdGgoXCJAX1wiKSlcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgIFJhbmdlICR7aW5kZXggKyAxfSBmb250IGluZm86YCwge1xyXG4gICAgICAgICAgICAgICAgQXBwbGllZEZvbnQ6IHJhbmdlW1wiQF9BcHBsaWVkRm9udFwiXSxcclxuICAgICAgICAgICAgICAgIEZvbnRTdHlsZTogcmFuZ2VbXCJAX0ZvbnRTdHlsZVwiXSxcclxuICAgICAgICAgICAgICAgIFBvaW50U2l6ZTogcmFuZ2VbXCJAX1BvaW50U2l6ZVwiXSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBmaW5kQ2hhcmFjdGVyUmFuZ2VzKG9ialtrZXldLCBgJHtwYXRofS4ke2tleX1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmaW5kQ2hhcmFjdGVyUmFuZ2VzKHN0b3J5RGF0YSk7XHJcbiAgfVxyXG5cclxuICAvLyBBREQgREVCVUdHSU5HIEZPUiBQQVJTRUQgQlIgU1RSVUNUVVJFXHJcbiAgZGVidWdCckVsZW1lbnRzSW5QYXJzZWRTdHJ1Y3R1cmUocGFyc2VkRGF0YSwgcGF0aCA9IFwiXCIpIHtcclxuICAgIGlmICh0eXBlb2YgcGFyc2VkRGF0YSA9PT0gXCJvYmplY3RcIiAmJiBwYXJzZWREYXRhICE9PSBudWxsKSB7XHJcbiAgICAgIE9iamVjdC5lbnRyaWVzKHBhcnNlZERhdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiQnJcIikge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCR7cGF0aH0gaGFzIEJyIGVsZW1lbnQ6YCwgdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICB0aGlzLmRlYnVnQnJFbGVtZW50c0luUGFyc2VkU3RydWN0dXJlKHZhbHVlLCBgJHtwYXRofS4ke2tleX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ1JJVElDQUwgRklYOiBQYXJzZSByYXcgWE1MIHRvIHByZXNlcnZlIGV4YWN0IGRvY3VtZW50IG9yZGVyIC0gRlVMTFkgRFlOQU1JQ1xyXG4gIHBhcnNlUmF3WE1MRm9yRG9jdW1lbnRPcmRlcihyYXdYTUxDb250ZW50LCBmaWxlTmFtZSkge1xyXG4gICAgY29uc29sZS5sb2coYPCflI0gUGFyc2luZyByYXcgWE1MIGZvciBkb2N1bWVudCBvcmRlcjogJHtmaWxlTmFtZX1gKTtcclxuXHJcbiAgICAvLyBEWU5BTUlDOiBIYW5kbGUgbXVsdGlwbGUgQ2hhcmFjdGVyU3R5bGVSYW5nZSBlbGVtZW50c1xyXG4gICAgY29uc3QgY2hhclJhbmdlUGF0dGVybiA9XHJcbiAgICAgIC88Q2hhcmFjdGVyU3R5bGVSYW5nZVtePl0qPiguKj8pPFxcL0NoYXJhY3RlclN0eWxlUmFuZ2U+L2dzO1xyXG4gICAgY29uc3QgY2hhclJhbmdlTWF0Y2hlcyA9IFsuLi5yYXdYTUxDb250ZW50Lm1hdGNoQWxsKGNoYXJSYW5nZVBhdHRlcm4pXTtcclxuXHJcbiAgICBpZiAoY2hhclJhbmdlTWF0Y2hlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coXCLinYwgTm8gQ2hhcmFjdGVyU3R5bGVSYW5nZSBmb3VuZCBpbiBYTUxcIik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBg8J+ThCBGb3VuZCAke2NoYXJSYW5nZU1hdGNoZXMubGVuZ3RofSBDaGFyYWN0ZXJTdHlsZVJhbmdlIGVsZW1lbnRzYFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBEWU5BTUlDOiBQcm9jZXNzIGFsbCBDaGFyYWN0ZXJTdHlsZVJhbmdlIGVsZW1lbnRzXHJcbiAgICBjb25zdCBhbGxEb2N1bWVudE9yZGVyID0gW107XHJcblxyXG4gICAgY2hhclJhbmdlTWF0Y2hlcy5mb3JFYWNoKChtYXRjaCwgcmFuZ2VJbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBjaGFyUmFuZ2VDb250ZW50ID0gbWF0Y2hbMV07XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDwn5OEIFByb2Nlc3NpbmcgQ2hhcmFjdGVyU3R5bGVSYW5nZVske3JhbmdlSW5kZXh9XTpgLFxyXG4gICAgICAgIGNoYXJSYW5nZUNvbnRlbnQuc3Vic3RyaW5nKDAsIDIwMCkgKyBcIi4uLlwiXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBFTkhBTkNFRDogTW9yZSBmbGV4aWJsZSBwYXR0ZXJuIHRvIGhhbmRsZSBkaWZmZXJlbnQgWE1MIHN0cnVjdHVyZXNcclxuICAgICAgLy8gTWF0Y2hlczogPENvbnRlbnQ+dGV4dDwvQ29udGVudD4sIDxDb250ZW50Lz4sIDxCci8+LCA8QnI+PC9Ccj4sIDxCciAvPlxyXG4gICAgICBjb25zdCBlbGVtZW50UGF0dGVybiA9XHJcbiAgICAgICAgLzwoQ29udGVudHxCcikoPzpcXHMrW14+XSopPz4oW148XSopPFxcL1xcMT58PChDb250ZW50fEJyKSg/OlxccytbXj5dKik/XFwvPz58PChDb250ZW50fEJyKSg/OlxccytbXj5dKik/PihbXjxdKikvZztcclxuXHJcbiAgICAgIGxldCBlbGVtZW50TWF0Y2g7XHJcbiAgICAgIGNvbnN0IHJhbmdlRWxlbWVudHMgPSBbXTtcclxuXHJcbiAgICAgIHdoaWxlICgoZWxlbWVudE1hdGNoID0gZWxlbWVudFBhdHRlcm4uZXhlYyhjaGFyUmFuZ2VDb250ZW50KSkgIT09IG51bGwpIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9XHJcbiAgICAgICAgICBlbGVtZW50TWF0Y2hbMV0gfHwgZWxlbWVudE1hdGNoWzNdIHx8IGVsZW1lbnRNYXRjaFs0XTtcclxuICAgICAgICBjb25zdCBlbGVtZW50Q29udGVudCA9IGVsZW1lbnRNYXRjaFsyXSB8fCBlbGVtZW50TWF0Y2hbNV0gfHwgXCJcIjtcclxuXHJcbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSBcIkNvbnRlbnRcIikge1xyXG4gICAgICAgICAgY29uc3QgY29udGVudFRleHQgPSBlbGVtZW50Q29udGVudC50cmltKCk7XHJcbiAgICAgICAgICBpZiAoY29udGVudFRleHQpIHtcclxuICAgICAgICAgICAgLy8gT25seSBhZGQgbm9uLWVtcHR5IGNvbnRlbnRcclxuICAgICAgICAgICAgcmFuZ2VFbGVtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICB0eXBlOiBcIkNvbnRlbnRcIixcclxuICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50VGV4dCxcclxuICAgICAgICAgICAgICByYW5nZUluZGV4OiByYW5nZUluZGV4LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk50gRm91bmQgQ29udGVudFske3JhbmdlSW5kZXh9XTogXCIke2NvbnRlbnRUZXh0fVwiYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gXCJCclwiKSB7XHJcbiAgICAgICAgICByYW5nZUVsZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiBcIkJyXCIsXHJcbiAgICAgICAgICAgIHJhbmdlSW5kZXg6IHJhbmdlSW5kZXgsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SXIEZvdW5kIEJyWyR7cmFuZ2VJbmRleH1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgcmFuZ2UgZWxlbWVudHMgdG8gb3ZlcmFsbCBkb2N1bWVudCBvcmRlclxyXG4gICAgICBhbGxEb2N1bWVudE9yZGVyLnB1c2goLi4ucmFuZ2VFbGVtZW50cyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoYWxsRG9jdW1lbnRPcmRlci5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCLinYwgTm8gQ29udGVudCBvciBCciBlbGVtZW50cyBmb3VuZCBpbiBhbnkgQ2hhcmFjdGVyU3R5bGVSYW5nZVwiXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERZTkFNSUM6IEFuYWx5emUgdGhlIGJyZWFrIHBhdHRlcm4gZm9yIGFueSBzdHJ1Y3R1cmVcclxuICAgIGNvbnN0IGJyZWFrUGF0dGVybiA9IHRoaXMuYW5hbHl6ZUJyZWFrUGF0dGVybkR5bmFtaWMoYWxsRG9jdW1lbnRPcmRlcik7XHJcbiAgICBjb25zb2xlLmxvZyhcIvCfk4ogRHluYW1pYyBicmVhayBwYXR0ZXJuIGFuYWx5c2lzOlwiLCBicmVha1BhdHRlcm4pO1xyXG5cclxuICAgIC8vIFN0b3JlIHRoaXMgZm9yIGxhdGVyIHVzZSBpbiBwcm9jZXNzaW5nXHJcbiAgICB0aGlzLmRvY3VtZW50T3JkZXJDYWNoZSA9IHRoaXMuZG9jdW1lbnRPcmRlckNhY2hlIHx8IHt9O1xyXG4gICAgdGhpcy5kb2N1bWVudE9yZGVyQ2FjaGVbZmlsZU5hbWVdID0ge1xyXG4gICAgICBkb2N1bWVudE9yZGVyOiBhbGxEb2N1bWVudE9yZGVyLFxyXG4gICAgICBicmVha1BhdHRlcm46IGJyZWFrUGF0dGVybixcclxuICAgICAgdG90YWxDaGFyYWN0ZXJSYW5nZXM6IGNoYXJSYW5nZU1hdGNoZXMubGVuZ3RoLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkb2N1bWVudE9yZGVyOiBhbGxEb2N1bWVudE9yZGVyLFxyXG4gICAgICBicmVha1BhdHRlcm46IGJyZWFrUGF0dGVybixcclxuICAgICAgdG90YWxDaGFyYWN0ZXJSYW5nZXM6IGNoYXJSYW5nZU1hdGNoZXMubGVuZ3RoLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIERZTkFNSUM6IEFuYWx5emUgYnJlYWsgcGF0dGVybiBmb3IgYW55IGRvY3VtZW50IHN0cnVjdHVyZVxyXG4gIGFuYWx5emVCcmVha1BhdHRlcm5EeW5hbWljKGRvY3VtZW50T3JkZXIpIHtcclxuICAgIGNvbnN0IHBhdHRlcm4gPSBbXTtcclxuICAgIGxldCBjb250ZW50SW5kZXggPSAwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jdW1lbnRPcmRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnRPcmRlcltpXTtcclxuXHJcbiAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiQ29udGVudFwiKSB7XHJcbiAgICAgICAgLy8gRFlOQU1JQzogQ291bnQgY29uc2VjdXRpdmUgYnJlYWtzIGFmdGVyIHRoaXMgY29udGVudFxyXG4gICAgICAgIGxldCBicmVha3NBZnRlciA9IDA7XHJcbiAgICAgICAgbGV0IGogPSBpICsgMTtcclxuXHJcbiAgICAgICAgLy8gQ291bnQgYWxsIGNvbnNlY3V0aXZlIEJyIGVsZW1lbnRzIGZvbGxvd2luZyB0aGlzIENvbnRlbnRcclxuICAgICAgICB3aGlsZSAoaiA8IGRvY3VtZW50T3JkZXIubGVuZ3RoICYmIGRvY3VtZW50T3JkZXJbal0udHlwZSA9PT0gXCJCclwiKSB7XHJcbiAgICAgICAgICBicmVha3NBZnRlcisrO1xyXG4gICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGF0dGVybi5wdXNoKHtcclxuICAgICAgICAgIGNvbnRlbnRJbmRleDogY29udGVudEluZGV4LFxyXG4gICAgICAgICAgY29udGVudFRleHQ6IGVsZW1lbnQudGV4dCxcclxuICAgICAgICAgIGJyZWFrc0FmdGVyOiBicmVha3NBZnRlcixcclxuICAgICAgICAgIHJhbmdlSW5kZXg6IGVsZW1lbnQucmFuZ2VJbmRleCxcclxuICAgICAgICAgIGRvY3VtZW50UG9zaXRpb246IGksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfk4sgQ29udGVudFske2NvbnRlbnRJbmRleH1dIFwiJHtlbGVtZW50LnRleHR9XCIgaGFzICR7YnJlYWtzQWZ0ZXJ9IGJyZWFrcyBhZnRlciBpdCAoZG9jIHBvczogJHtpfSlgXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb250ZW50SW5kZXgrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFZBTElEQVRJT046IEVuc3VyZSBwYXR0ZXJuIG1ha2VzIHNlbnNlXHJcbiAgICBjb25zdCB0b3RhbENvbnRlbnQgPSBwYXR0ZXJuLmxlbmd0aDtcclxuICAgIGNvbnN0IHRvdGFsQnJlYWtzID0gcGF0dGVybi5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5icmVha3NBZnRlciwgMCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5SNIFBhdHRlcm4gdmFsaWRhdGlvbjogJHt0b3RhbENvbnRlbnR9IGNvbnRlbnQgaXRlbXMsICR7dG90YWxCcmVha3N9IHRvdGFsIGJyZWFrc2BcclxuICAgICk7XHJcblxyXG4gICAgaWYgKHRvdGFsQ29udGVudCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuKaoO+4jyBXYXJuaW5nOiBObyBjb250ZW50IGl0ZW1zIGZvdW5kIGluIHBhdHRlcm5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhdHRlcm47XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yaWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmllcztcclxuICB9XHJcblxyXG4gIGdldFN0b3J5KHN0b3J5SWQpIHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JpZXNbc3RvcnlJZF07XHJcbiAgfVxyXG5cclxuICBjbGVhclN0b3JpZXMoKSB7XHJcbiAgICB0aGlzLnN0b3JpZXMgPSB7fTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RvcnlQYXJzZXI7XHJcbiJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIklETUxVdGlscyIsIlN0b3J5UGFyc2VyIiwic2V0RG9jdW1lbnRVbml0cyIsInVuaXRzIiwiZG9jdW1lbnRVbml0cyIsImNvbnNvbGUiLCJsb2ciLCJjb252ZXJ0Rm9udFNpemVUb1BpeGVscyIsImZvbnRTaXplIiwidW5pdENvbnZlcnRlciIsImZvbnRVbml0cyIsImlzU3VwcG9ydGVkVW5pdCIsInBpeGVsU2l6ZSIsInRvUGl4ZWxzIiwicGFyc2VTdG9yeUZpbGUiLCJmaWxlTmFtZSIsImNvbnRlbnQiLCJ4bWxQYXJzZXIiLCJwYXJzZWQiLCJwYXJzZSIsInN0b3J5SWQiLCJiYXNlbmFtZSIsInN0b3J5RGF0YSIsIlN0b3J5Iiwic3Vic3RyaW5nIiwiYnJNYXRjaGVzIiwibWF0Y2giLCJsZW5ndGgiLCJjb25zZWN1dGl2ZUJyUGF0dGVybiIsImNvbnNlY3V0aXZlQnJNYXRjaGVzIiwicGFyc2VSYXdYTUxGb3JEb2N1bWVudE9yZGVyIiwiT2JqZWN0Iiwia2V5cyIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZXRhaWxlZFN0b3J5Iiwic2VsZiIsImFwcGxpZWRUT0NTdHlsZSIsInVzZXJUZXh0IiwiZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50IiwidGV4dEZvcm1hdHRpbmciLCJleHRyYWN0VGV4dEZvcm1hdHRpbmciLCJkZWJ1Z0JyRWxlbWVudHNJblBhcnNlZFN0cnVjdHVyZSIsImNsZWFuU3RvcnlJZCIsInJlcGxhY2UiLCJzdG9yaWVzIiwicGxhaW5UZXh0IiwibGluZUJyZWFrSW5mbyIsIndvcmRDb3VudCIsImxpbmVCcmVha0NvdW50IiwiZXJyb3IiLCJtZXNzYWdlIiwiZm9ybWF0dGVkQ29udGVudCIsInRleHRDb2xvciIsImRlYnVnSW5mbyIsImV4dHJhY3RUZXh0UmVjdXJzaXZlbHkiLCJlbGVtZW50IiwiZGVwdGgiLCJjb250ZXh0IiwiQ2hhcmFjdGVyU3R5bGVSYW5nZSIsInJhbmdlcyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJyYW5nZSIsInJhbmdlSW5kZXgiLCJkaXJlY3RGb250UmVmIiwiZm9ybWF0dGluZyIsInBhcmFncmFwaFN0eWxlIiwiYXBwbGllZFN0eWxlIiwiY2hhcmFjdGVyU3R5bGUiLCJwYXJzZUZsb2F0Iiwib3JpZ2luYWxGb250U2l6ZSIsImZvbnRSZWZlcmVuY2UiLCJmaWxsQ29sb3IiLCJmb250U3R5bGUiLCJhbGlnbm1lbnQiLCJwYXJhZ3JhcGhBbGlnbm1lbnQiLCJyZXNvbHZlZEZvcm1hdHRpbmciLCJzdHlsZVBhcnNlciIsInJlc29sdmVTdHlsZUZvcm1hdHRpbmciLCJwcm9jZXNzQ2hhcmFjdGVyUmFuZ2VJbk9yZGVyIiwibmV4dFJhbmdlIiwiY3VycmVudFRleHQiLCJzbGljZSIsImN1cnJlbnRSYW5nZUVuZHNXaXRoU3BhY2UiLCJ0ZXN0IiwibmV4dENvbnRlbnQiLCJDb250ZW50IiwiU3RyaW5nIiwibmV4dFJhbmdlU3RhcnRzV2l0aFNwYWNlIiwic2hvdWxkU2tpcFNwYWNlIiwic2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsiLCJ0cmltIiwiY3VycmVudFN0eWxlIiwibmV4dFN0eWxlIiwic3BhY2VUZXh0IiwicHVzaCIsInRleHQiLCJpc1NwYWNlIiwic291cmNlIiwidHlwZSIsImxvY2F0aW9uIiwicmVhc29uIiwiY3VycmVudFRleHRFbmQiLCJuZXh0VGV4dFN0YXJ0IiwiaW1wbGljaXRCcmVhayIsImlzQnJlYWsiLCJicmVha1R5cGUiLCJQYXJhZ3JhcGhTdHlsZVJhbmdlIiwiaW5kZXgiLCJwYXJhZ3JhcGhDb250ZXh0IiwicGFyYWdyYXBoSW5kZXgiLCJ0b3RhbFBhcmFncmFwaHMiLCJiZWZvcmVMZW4iLCJhZnRlckxlbiIsInBhcmFncmFwaEJyZWFrIiwiam9pbiIsImRlY29kZVhNTEVudGl0aWVzIiwiZm9udEZhbWlseSIsIkJyIiwidW5kZWZpbmVkIiwiYnJFbGVtZW50cyIsImJyIiwibGluZUJyZWFrVGV4dCIsImVudHJpZXMiLCJrZXkiLCJ2YWx1ZSIsInN0YXJ0c1dpdGgiLCJpdGVtIiwiY2hhcnMiLCJzcGxpdCIsIm1hcCIsImNoYXIiLCJpIiwicHJvY2Vzc2VkQ29udGVudCIsInNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nIiwiZmlsdGVyIiwiaW5mbyIsImluY2x1ZGVzIiwiaGFzTGluZUJyZWFrcyIsImxpbmVCcmVha1R5cGVzIiwiYW5hbHl6ZUxpbmVCcmVha1R5cGVzIiwic3BhY2VQcmVzZXJ2YXRpb25Db3VudCIsImNvdW50V29yZHMiLCJjaGFyYWN0ZXJDb3VudCIsInRvdGFsUmFuZ2VzIiwiaGFzQ29udGVudCIsImhhc0JyIiwiY29udGVudFR5cGUiLCJiclR5cGUiLCJwcm9jZXNzSW50ZXJsZWF2ZWRDb250ZW50QW5kQnIiLCJwcm9jZXNzQ29udGVudEVsZW1lbnRzIiwicHJvY2Vzc0JyRWxlbWVudHMiLCJlbWVyZ2VuY3lDb250ZW50RXh0cmFjdGlvbiIsImV4dHJhY3RlZFRleHRzIiwiZXh0cmFjdGVkQnJlYWtzIiwiY29udGVudHMiLCJjIiwiYnJlYWtzIiwiY2xlYW5UZXh0IiwiZW1lcmdlbmN5SW5kZXgiLCJlbWVyZ2VuY3lFcnJvciIsIndhcm5pbmdUZXh0IiwiY2FjaGVkT3JkZXIiLCJkb2N1bWVudE9yZGVyQ2FjaGUiLCJicmVha1BhdHRlcm4iLCJwcm9jZXNzQ29udGVudFdpdGhDYWNoZWRQYXR0ZXJuIiwicHJvY2Vzc0ludGVybGVhdmVkQ29udGVudER5bmFtaWNGYWxsYmFjayIsImJySW5kZXgiLCJjb250ZW50TGVuZ3RoIiwiY29udGVudEl0ZW0iLCJjb250ZW50SW5kZXgiLCJicmVha3NUb0FkZCIsImNhbGN1bGF0ZUJyZWFrc0FmdGVyQ29udGVudCIsImFmdGVyQ29udGVudCIsImNhbGN1bGF0ZWRCcmVha3MiLCJyZW1haW5pbmdCcmVha3MiLCJwYXR0ZXJuRW50cnkiLCJmaW5kIiwicCIsImJyZWFrc0FmdGVyIiwiYnJlYWtJbmRleCIsInRvdGFsQnJlYWtzQWZ0ZXJDb250ZW50IiwiZXhwZWN0ZWRDb250ZW50Q291bnQiLCJ0b3RhbENvbnRlbnQiLCJ0b3RhbEJyZWFrcyIsIm5vbkxhc3RDb250ZW50SXRlbXMiLCJiYXNlQnJlYWtzIiwiTWF0aCIsImZsb29yIiwiZXh0cmFCcmVha3MiLCJicmVha3NGb3JUaGlzQ29udGVudCIsImFuYWx5emVDb250ZW50U3RydWN0dXJlIiwic3RydWN0dXJlIiwiY29udGVudEl0ZW1zIiwicHJvY2Vzc0ludGVybGVhdmVkQ29udGVudCIsInJlc3VsdHMiLCJleHRyYWN0QnJFbGVtZW50cyIsImNvdW50IiwicmF3QnIiLCJwb3NpdGlvbiIsImRldGVybWluZUxpbmVCcmVha1R5cGUiLCJickluZm8iLCJjdXJyZW50UmFuZ2UiLCJjdXJyZW50Q2hhclN0eWxlIiwibmV4dENoYXJTdHlsZSIsInN0eWxlSW5kaWNhdGVzQnJlYWsiLCJzdHlsZUluZGljYXRlc0xpbmVCcmVhayIsInRpdGxlSW5kaWNhdG9ycyIsImJvZHlJbmRpY2F0b3JzIiwiY3VycmVudElzVGl0bGUiLCJzb21lIiwiaW5kaWNhdG9yIiwidG9Mb3dlckNhc2UiLCJuZXh0SXNCb2R5IiwidHlwZXMiLCJleHBsaWNpdCIsImltcGxpY2l0IiwicGFyYWdyYXBoIiwiZGlyZWN0IiwiaGFzT3duUHJvcGVydHkiLCJleHRyYWN0RGV0YWlsZWRGb3JtYXR0aW5nRnJvbVJhbmdlIiwiZm9udEF0dHJpYnV0ZXMiLCJhdHRyIiwicmF3Rm9udFNpemUiLCJwYXJzZU51bWVyaWMiLCJyYXdMZWFkaW5nIiwibGVhZGluZyIsInByb2Nlc3NMZWFkaW5nVmFsdWUiLCJsZWFkaW5nVHlwZSIsImRldGVybWluZUxlYWRpbmdUeXBlIiwic3Ryb2tlQ29sb3IiLCJ0cmFja2luZyIsImJhc2VsaW5lU2hpZnQiLCJrZXJuaW5nIiwiaG9yaXpvbnRhbFNjYWxlIiwidmVydGljYWxTY2FsZSIsImJhc2VsaW5lR3JpZEFsaWduIiwiZHJvcENhcExpbmVzIiwiZHJvcENhcENoYXJhY3RlcnMiLCJleHBsaWNpdEFsaWdubWVudCIsImxlZnRJbmRlbnQiLCJyaWdodEluZGVudCIsImZpcnN0TGluZUluZGVudCIsInNwYWNlQmVmb3JlIiwic3BhY2VBZnRlciIsImVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0IiwibnVtZXJpY0xlYWRpbmciLCJwaXhlbExlYWRpbmciLCJwZXJjZW50YWdlIiwicGFyYWdyYXBoU3R5bGVzIiwiY2hhcmFjdGVyU3R5bGVzIiwiYXBwbGllZFN0eWxlcyIsImNoYXJSYW5nZXMiLCJjaGFyUmFuZ2UiLCJjaGFyU3R5bGUiLCJkZWJ1Z1Jhd1N0b3J5Q29udGVudCIsImZpbmRDaGFyYWN0ZXJSYW5nZXMiLCJvYmoiLCJrIiwiQXBwbGllZEZvbnQiLCJGb250U3R5bGUiLCJQb2ludFNpemUiLCJwYXJzZWREYXRhIiwicmF3WE1MQ29udGVudCIsImNoYXJSYW5nZVBhdHRlcm4iLCJjaGFyUmFuZ2VNYXRjaGVzIiwibWF0Y2hBbGwiLCJhbGxEb2N1bWVudE9yZGVyIiwiY2hhclJhbmdlQ29udGVudCIsImVsZW1lbnRQYXR0ZXJuIiwiZWxlbWVudE1hdGNoIiwicmFuZ2VFbGVtZW50cyIsImV4ZWMiLCJlbGVtZW50VHlwZSIsImVsZW1lbnRDb250ZW50IiwiY29udGVudFRleHQiLCJhbmFseXplQnJlYWtQYXR0ZXJuRHluYW1pYyIsImRvY3VtZW50T3JkZXIiLCJ0b3RhbENoYXJhY3RlclJhbmdlcyIsInBhdHRlcm4iLCJqIiwiZG9jdW1lbnRQb3NpdGlvbiIsInJlZHVjZSIsInN1bSIsImdldFN0b3JpZXMiLCJnZXRTdG9yeSIsImNsZWFyU3RvcmllcyIsImNvbnN0cnVjdG9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/parsers/StoryParser.js\n"));

/***/ })

});