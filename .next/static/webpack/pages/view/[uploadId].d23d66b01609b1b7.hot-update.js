"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StyleParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StyleParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StyleParser {\n    // ADDED: Method to set document units for typography conversion\n    setDocumentUnits(units) {\n        this.documentUnits = units;\n        console.log(\"\\uD83D\\uDCD0 StyleParser: Set document units to\", units);\n    }\n    // ADDED: Method to convert typography measurements to pixels\n    convertTypographyToPixels(value) {\n        if (typeof value !== \"number\" || isNaN(value) || !this.unitConverter || !this.documentUnits) {\n            return value;\n        }\n        // Only convert if we have a supported unit and it's not already pixels\n        if (this.unitConverter.isSupportedUnit(this.documentUnits)) {\n            const convertedValue = this.unitConverter.toPixels(value, this.documentUnits);\n            console.log(\"\\uD83D\\uDCD0 Converted typography: \".concat(value, \" \").concat(this.documentUnits, \" → \").concat(convertedValue, \" px\"));\n            return convertedValue;\n        }\n        return value;\n    }\n    // ADDED: Method to convert an entire style object's measurements to pixels\n    convertStyleMeasurementsToPixels(style) {\n        if (!this.unitConverter || !this.documentUnits) {\n            return style;\n        }\n        const convertedStyle = {\n            ...style\n        };\n        // Convert measurements that need pixel conversion\n        const measurementFields = [\n            \"leftIndent\",\n            \"rightIndent\",\n            \"firstLineIndent\",\n            \"spaceBefore\",\n            \"spaceAfter\",\n            \"tracking\",\n            \"kerning\"\n        ];\n        measurementFields.forEach((field)=>{\n            if (typeof convertedStyle[field] === \"number\") {\n                convertedStyle[field] = this.convertTypographyToPixels(convertedStyle[field]);\n            }\n        });\n        // Convert leading if it's a numeric value\n        if (typeof convertedStyle.leading === \"number\") {\n            convertedStyle.leading = this.convertTypographyToPixels(convertedStyle.leading);\n        }\n        return convertedStyle;\n    }\n    async parseResourceFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCCB Parsing resource: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const resourceName = path.basename(fileName, \".xml\");\n            // Handle different resource types\n            if (fileName.includes(\"Styles.xml\")) {\n                await this.extractStyles(parsed);\n            } else if (fileName.includes(\"Fonts.xml\")) {\n                await this.extractFonts(parsed);\n            } else if (fileName.includes(\"Graphic.xml\")) {\n                await this.extractGraphics(parsed);\n            } else if (fileName.includes(\"Preferences.xml\")) {\n                await this.extractPreferences(parsed);\n            }\n            console.log(\"✅ Resource \".concat(resourceName, \" parsed\"));\n        } catch (error) {\n            console.error(\"❌ Error parsing \".concat(fileName, \":\"), error.message);\n        }\n    }\n    async extractStyles(stylesData) {\n        console.log(\"Extracting styles...\");\n        const styles = stylesData.Styles || stylesData;\n        // Extract Paragraph Styles\n        if (styles.RootParagraphStyleGroup) {\n            this.extractParagraphStyles(styles.RootParagraphStyleGroup);\n        }\n        // Extract Character Styles\n        if (styles.RootCharacterStyleGroup) {\n            this.extractCharacterStyles(styles.RootCharacterStyleGroup);\n        }\n    }\n    extractParagraphStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.ParagraphStyle) {\n                const styles = Array.isArray(group.ParagraphStyle) ? group.ParagraphStyle : [\n                    group.ParagraphStyle\n                ];\n                styles.forEach((style)=>{\n                    // CRITICAL: Extract font reference from multiple possible locations\n                    const fontRef = this.extractFontFromStyle(style);\n                    // ENHANCED: Process leading with proper InDesign logic\n                    const fontSize = parseFloat(style[\"@_PointSize\"]) || 12;\n                    const rawLeading = style[\"@_Leading\"];\n                    const processedLeading = this.processLeadingValue(rawLeading, fontSize);\n                    // FIXED: Extract raw typography measurements for conversion\n                    const rawLeftIndent = parseFloat(style[\"@_LeftIndent\"]) || 0;\n                    const rawRightIndent = parseFloat(style[\"@_RightIndent\"]) || 0;\n                    const rawFirstLineIndent = parseFloat(style[\"@_FirstLineIndent\"]) || 0;\n                    const rawSpaceBefore = parseFloat(style[\"@_SpaceBefore\"]) || 0;\n                    const rawSpaceAfter = parseFloat(style[\"@_SpaceAfter\"]) || 0;\n                    const rawTracking = parseFloat(style[\"@_Tracking\"]) || 0;\n                    const rawKerning = parseFloat(style[\"@_Kerning\"]) || 0;\n                    // FIXED: Create base style object with raw values\n                    const baseStyle = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: fontSize,\n                        leading: processedLeading,\n                        leadingType: this.determineLeadingType(rawLeading),\n                        effectiveLineHeight: this.calculateEffectiveLineHeight(processedLeading, fontSize),\n                        alignment: style[\"@_Justification\"] || \"LeftAlign\",\n                        // Raw measurements (will be converted to pixels)\n                        leftIndent: rawLeftIndent,\n                        rightIndent: rawRightIndent,\n                        firstLineIndent: rawFirstLineIndent,\n                        spaceBefore: rawSpaceBefore,\n                        spaceAfter: rawSpaceAfter,\n                        tracking: rawTracking,\n                        kerning: rawKerning,\n                        // Store original values for reference\n                        originalLeftIndent: rawLeftIndent,\n                        originalRightIndent: rawRightIndent,\n                        originalFirstLineIndent: rawFirstLineIndent,\n                        originalSpaceBefore: rawSpaceBefore,\n                        originalSpaceAfter: rawSpaceAfter,\n                        originalTracking: rawTracking,\n                        originalKerning: rawKerning,\n                        horizontalScale: parseFloat(style[\"@_HorizontalScale\"]) || 100,\n                        verticalScale: parseFloat(style[\"@_VerticalScale\"]) || 100,\n                        // ENHANCED: Use the new extraction method\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || \"Color/Black\",\n                        rawStyle: style\n                    };\n                    // FIXED: Apply unit conversion to create pixel-converted style\n                    this.styles.paragraph[style[\"@_Self\"]] = this.convertStyleMeasurementsToPixels(baseStyle);\n                    console.log(\"✅ Paragraph Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.ParagraphStyleGroup) {\n                const subGroups = Array.isArray(group.ParagraphStyleGroup) ? group.ParagraphStyleGroup : [\n                    group.ParagraphStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    extractFontFromStyle(style) {\n        // Try direct attributes first\n        let fontRef = style[\"@_AppliedFont\"] || style[\"@_FontFamily\"] || style[\"@_Font\"] || \"\";\n        // If not found, try Properties nested structure\n        if (!fontRef && style.Properties) {\n            if (style.Properties.AppliedFont) {\n                fontRef = style.Properties.AppliedFont[\"#text\"] || style.Properties.AppliedFont || \"\";\n            }\n            // Also try other property variations\n            if (!fontRef && style.Properties.FontFamily) {\n                fontRef = style.Properties.FontFamily[\"#text\"] || style.Properties.FontFamily || \"\";\n            }\n        }\n        return fontRef || \"\";\n    }\n    extractCharacterStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.CharacterStyle) {\n                const styles = Array.isArray(group.CharacterStyle) ? group.CharacterStyle : [\n                    group.CharacterStyle\n                ];\n                styles.forEach((style)=>{\n                    const fontRef = this.extractFontFromStyle(style);\n                    this.styles.character[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: parseFloat(style[\"@_PointSize\"]) || null,\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || null,\n                        strokeColor: style[\"@_StrokeColor\"] || null,\n                        rawStyle: style\n                    };\n                    console.log(\"✅ Character Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.CharacterStyleGroup) {\n                const subGroups = Array.isArray(group.CharacterStyleGroup) ? group.CharacterStyleGroup : [\n                    group.CharacterStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    async extractFonts(fontsData) {\n        console.log(\"Extracting fonts with enhanced mapping...\");\n        const fonts = fontsData.Fonts || fontsData;\n        this.resources.fonts = {};\n        this.fontMap = new Map(); // Global font lookup map\n        if (fonts.FontFamily) {\n            const fontFamilies = Array.isArray(fonts.FontFamily) ? fonts.FontFamily : [\n                fonts.FontFamily\n            ];\n            fontFamilies.forEach((family)=>{\n                const familyInfo = {\n                    self: family[\"@_Self\"],\n                    name: family[\"@_Name\"] || \"\",\n                    fonts: []\n                };\n                if (family.Font) {\n                    const fontList = Array.isArray(family.Font) ? family.Font : [\n                        family.Font\n                    ];\n                    fontList.forEach((font)=>{\n                        const fontInfo = {\n                            self: font[\"@_Self\"],\n                            fontFamily: font[\"@_FontFamily\"] || familyInfo.name,\n                            name: font[\"@_Name\"] || \"\",\n                            postScriptName: font[\"@_PostScriptName\"] || \"\",\n                            status: font[\"@_Status\"] || \"Unknown\",\n                            fontStyleName: font[\"@_FontStyleName\"] || \"Regular\"\n                        };\n                        familyInfo.fonts.push(fontInfo);\n                        // Create multiple lookup entries for this font\n                        this.fontMap.set(font[\"@_Self\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_PostScriptName\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_Name\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_FontFamily\"], familyInfo.name);\n                        console.log(\"Font mapping: \".concat(font[\"@_Self\"], \" -> \").concat(familyInfo.name));\n                    });\n                }\n                this.resources.fonts[family[\"@_Self\"]] = familyInfo;\n            });\n        }\n        console.log(\"✅ Fonts extracted: \".concat(Object.keys(this.resources.fonts).length, \" families\"));\n        console.log(\"Font map entries: \".concat(this.fontMap.size));\n    }\n    async extractGraphics(graphicsData) {\n        console.log(\"Extracting graphics and colors...\");\n        const graphics = graphicsData.Graphic || graphicsData;\n        this.resources.colors = {};\n        this.resources.gradients = {};\n        // Extract Colors\n        if (graphics.Color) {\n            const colors = Array.isArray(graphics.Color) ? graphics.Color : [\n                graphics.Color\n            ];\n            colors.forEach((color)=>{\n                // Extract individual channel values from attributes (if present)\n                const cyan = parseFloat(color[\"@_Cyan\"]) || 0;\n                const magenta = parseFloat(color[\"@_Magenta\"]) || 0;\n                const yellow = parseFloat(color[\"@_Yellow\"]) || 0;\n                const black = parseFloat(color[\"@_Black\"]) || 0;\n                const red = parseFloat(color[\"@_Red\"]) || 0;\n                const green = parseFloat(color[\"@_Green\"]) || 0;\n                const blue = parseFloat(color[\"@_Blue\"]) || 0;\n                // Get color space and model information\n                const colorSpace = color[\"@_Space\"] || \"CMYK\";\n                const colorModel = color[\"@_Model\"] || \"Process\";\n                const colorValue = color[\"@_ColorValue\"];\n                console.log(\"\\uD83C\\uDFA8 Processing color: \".concat(color[\"@_Self\"]));\n                console.log(\"   Space: \".concat(colorSpace, \", Model: \").concat(colorModel));\n                console.log('   ColorValue: \"'.concat(colorValue, '\"'));\n                console.log(\"   Individual channels - C:\".concat(cyan, \" M:\").concat(magenta, \" Y:\").concat(yellow, \" K:\").concat(black, \" R:\").concat(red, \" G:\").concat(green, \" B:\").concat(blue));\n                // Initialize color data structure\n                let finalColorData = {\n                    self: color[\"@_Self\"],\n                    name: color[\"@_Name\"] || \"\",\n                    model: colorModel,\n                    space: colorSpace,\n                    cyan: 0,\n                    magenta: 0,\n                    yellow: 0,\n                    black: 0,\n                    red: 0,\n                    green: 0,\n                    blue: 0,\n                    // Additional fields to track color source\n                    colorSource: \"unknown\",\n                    hasDirectRGB: false,\n                    hasDirectCMYK: false,\n                    hasColorValue: !!colorValue\n                };\n                // STRATEGY 1: Check for direct RGB values in individual attributes\n                if (red > 0 || green > 0 || blue > 0) {\n                    console.log(\"   ✅ Using direct RGB from individual channels: R:\".concat(red, \" G:\").concat(green, \" B:\").concat(blue));\n                    finalColorData.red = red;\n                    finalColorData.green = green;\n                    finalColorData.blue = blue;\n                    finalColorData.colorSource = \"direct_rgb_channels\";\n                    finalColorData.hasDirectRGB = true;\n                } else if (cyan > 0 || magenta > 0 || yellow > 0 || black > 0) {\n                    console.log(\"   ✅ Using direct CMYK from individual channels: C:\".concat(cyan, \" M:\").concat(magenta, \" Y:\").concat(yellow, \" K:\").concat(black));\n                    finalColorData.cyan = cyan;\n                    finalColorData.magenta = magenta;\n                    finalColorData.yellow = yellow;\n                    finalColorData.black = black;\n                    finalColorData.colorSource = \"direct_cmyk_channels\";\n                    finalColorData.hasDirectCMYK = true;\n                } else if (colorValue) {\n                    console.log('   \\uD83D\\uDD0D Parsing ColorValue: \"'.concat(colorValue, '\"'));\n                    // Split ColorValue into numeric parts\n                    const valueParts = colorValue.split(/\\s+/).map(Number).filter((v)=>!isNaN(v));\n                    if (valueParts.length === 3 && colorSpace === \"RGB\") {\n                        // RGB ColorValue: \"255 137 0\" -> R:255 G:137 B:0\n                        console.log(\"   ✅ Using RGB ColorValue: R:\".concat(valueParts[0], \" G:\").concat(valueParts[1], \" B:\").concat(valueParts[2]));\n                        finalColorData.red = valueParts[0];\n                        finalColorData.green = valueParts[1];\n                        finalColorData.blue = valueParts[2];\n                        finalColorData.colorSource = \"colorvalue_rgb\";\n                        finalColorData.hasDirectRGB = true;\n                    } else if (valueParts.length === 4 && colorSpace === \"CMYK\") {\n                        // CMYK ColorValue: \"0 0 0 100\" -> C:0 M:0 Y:0 K:100\n                        console.log(\"   ✅ Using CMYK ColorValue: C:\".concat(valueParts[0], \" M:\").concat(valueParts[1], \" Y:\").concat(valueParts[2], \" K:\").concat(valueParts[3]));\n                        finalColorData.cyan = valueParts[0];\n                        finalColorData.magenta = valueParts[1];\n                        finalColorData.yellow = valueParts[2];\n                        finalColorData.black = valueParts[3];\n                        finalColorData.colorSource = \"colorvalue_cmyk\";\n                        finalColorData.hasDirectCMYK = true;\n                    } else if (valueParts.length === 3) {\n                        // Assume RGB if space is unknown but we have 3 values\n                        console.log(\"   ⚠️  Assuming RGB for 3-value ColorValue: R:\".concat(valueParts[0], \" G:\").concat(valueParts[1], \" B:\").concat(valueParts[2]));\n                        finalColorData.red = valueParts[0];\n                        finalColorData.green = valueParts[1];\n                        finalColorData.blue = valueParts[2];\n                        finalColorData.space = \"RGB\";\n                        finalColorData.colorSource = \"colorvalue_assumed_rgb\";\n                        finalColorData.hasDirectRGB = true;\n                    } else if (valueParts.length === 4) {\n                        // Assume CMYK if space is unknown but we have 4 values\n                        console.log(\"   ⚠️  Assuming CMYK for 4-value ColorValue: C:\".concat(valueParts[0], \" M:\").concat(valueParts[1], \" Y:\").concat(valueParts[2], \" K:\").concat(valueParts[3]));\n                        finalColorData.cyan = valueParts[0];\n                        finalColorData.magenta = valueParts[1];\n                        finalColorData.yellow = valueParts[2];\n                        finalColorData.black = valueParts[3];\n                        finalColorData.space = \"CMYK\";\n                        finalColorData.colorSource = \"colorvalue_assumed_cmyk\";\n                        finalColorData.hasDirectCMYK = true;\n                    } else {\n                        console.log('   ⚠️  Could not parse ColorValue: \"'.concat(colorValue, '\" (').concat(valueParts.length, \" parts)\"));\n                        finalColorData.colorSource = \"colorvalue_unparseable\";\n                    }\n                }\n                // STRATEGY 4: Handle special color types (fallback)\n                if (finalColorData.colorSource === \"unknown\") {\n                    console.log(\"   \\uD83D\\uDD04 Using fallback handling for color: \".concat(color[\"@_Self\"]));\n                    finalColorData.colorSource = \"fallback\";\n                }\n                // Store the color data\n                this.resources.colors[color[\"@_Self\"]] = finalColorData;\n                console.log(\"   \\uD83D\\uDCBE Stored color data:\", {\n                    self: finalColorData.self,\n                    source: finalColorData.colorSource,\n                    hasRGB: finalColorData.hasDirectRGB,\n                    hasCMYK: finalColorData.hasDirectCMYK,\n                    rgb: \"\".concat(finalColorData.red, \",\").concat(finalColorData.green, \",\").concat(finalColorData.blue),\n                    cmyk: \"\".concat(finalColorData.cyan, \",\").concat(finalColorData.magenta, \",\").concat(finalColorData.yellow, \",\").concat(finalColorData.black)\n                });\n            });\n        }\n        // Extract Gradients\n        if (graphics.Gradient) {\n            const gradients = Array.isArray(graphics.Gradient) ? graphics.Gradient : [\n                graphics.Gradient\n            ];\n            gradients.forEach((gradient)=>{\n                this.resources.gradients[gradient[\"@_Self\"]] = {\n                    self: gradient[\"@_Self\"],\n                    name: gradient[\"@_Name\"] || \"\",\n                    type: gradient[\"@_Type\"] || \"Linear\",\n                    gradientStops: this.extractGradientStops(gradient)\n                };\n            });\n        }\n        console.log(\"✅ Graphics extraction complete. Colors: \".concat(Object.keys(this.resources.colors).length, \", Gradients: \").concat(Object.keys(this.resources.gradients).length));\n    }\n    extractGradientStops(gradient) {\n        const stops = [];\n        if (gradient.GradientStop) {\n            const stopList = Array.isArray(gradient.GradientStop) ? gradient.GradientStop : [\n                gradient.GradientStop\n            ];\n            stopList.forEach((stop)=>{\n                stops.push({\n                    self: stop[\"@_Self\"],\n                    stopColor: stop[\"@_StopColor\"] || \"\",\n                    location: parseFloat(stop[\"@_Location\"]) || 0,\n                    midpoint: parseFloat(stop[\"@_Midpoint\"]) || 50\n                });\n            });\n        }\n        return stops;\n    }\n    async extractPreferences(preferencesData) {\n        console.log(\"Extracting document preferences...\");\n        const prefs = preferencesData.Preferences || preferencesData;\n        // Extract various document preferences\n        this.documentInfo = {\n            preferences: {\n                documentPreferences: this.extractDocumentPrefs(prefs.DocumentPreference),\n                viewPreferences: this.extractViewPrefs(prefs.ViewPreference),\n                guidePreferences: this.extractGuidePrefs(prefs.GuidePreference),\n                gridPreferences: this.extractGridPrefs(prefs.GridPreference),\n                marginPreferences: this.extractMarginPrefs(prefs.MarginPreference),\n                columnPreferences: this.extractColumnPrefs(prefs.ColumnPreference)\n            }\n        };\n    }\n    extractDocumentPrefs(docPref) {\n        if (!docPref) return {};\n        return {\n            pageWidth: parseFloat(docPref[\"@_PageWidth\"]) || 0,\n            pageHeight: parseFloat(docPref[\"@_PageHeight\"]) || 0,\n            left: parseFloat(docPref[\"@_Left\"]) || 0,\n            top: parseFloat(docPref[\"@_Top\"]) || 0,\n            right: parseFloat(docPref[\"@_Right\"]) || 0,\n            bottom: parseFloat(docPref[\"@_Bottom\"]) || 0,\n            columnCount: parseInt(docPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(docPref[\"@_ColumnGutter\"]) || 0,\n            facingPages: docPref[\"@_FacingPages\"] === true,\n            allowPageShuffle: docPref[\"@_AllowPageShuffle\"] !== false,\n            slugBleedType: docPref[\"@_SlugBleedType\"] || \"None\",\n            documentBleedTopOffset: parseFloat(docPref[\"@_DocumentBleedTopOffset\"]) || 0,\n            documentBleedBottomOffset: parseFloat(docPref[\"@_DocumentBleedBottomOffset\"]) || 0,\n            documentBleedInsideOrLeftOffset: parseFloat(docPref[\"@_DocumentBleedInsideOrLeftOffset\"]) || 0,\n            documentBleedOutsideOrRightOffset: parseFloat(docPref[\"@_DocumentBleedOutsideOrRightOffset\"]) || 0\n        };\n    }\n    extractViewPrefs(viewPref) {\n        if (!viewPref) return {};\n        return {\n            horizontalMeasurementUnits: viewPref[\"@_HorizontalMeasurementUnits\"] || \"Points\",\n            verticalMeasurementUnits: viewPref[\"@_VerticalMeasurementUnits\"] || \"Points\",\n            rulerOrigin: viewPref[\"@_RulerOrigin\"] || \"SpreadOrigin\",\n            showRulers: viewPref[\"@_ShowRulers\"] !== false\n        };\n    }\n    extractGuidePrefs(guidePref) {\n        if (!guidePref) return {};\n        return {\n            rulerGuideColor: guidePref[\"@_RulerGuideColor\"] || \"Green\",\n            guidesInBack: guidePref[\"@_GuidesInBack\"] === true,\n            guidesLocked: guidePref[\"@_GuidesLocked\"] === true,\n            guidesShown: guidePref[\"@_GuidesShown\"] !== false,\n            guidesSnapto: guidePref[\"@_GuidesSnapto\"] !== false\n        };\n    }\n    extractGridPrefs(gridPref) {\n        if (!gridPref) return {};\n        return {\n            baselineStart: parseFloat(gridPref[\"@_BaselineStart\"]) || 0,\n            baselineDivision: parseFloat(gridPref[\"@_BaselineDivision\"]) || 12,\n            baselineShown: gridPref[\"@_BaselineShown\"] === true,\n            baselineSnapto: gridPref[\"@_BaselineSnapto\"] === true,\n            documentGridShown: gridPref[\"@_DocumentGridShown\"] === true,\n            documentGridSnapto: gridPref[\"@_DocumentGridSnapto\"] === true\n        };\n    }\n    extractMarginPrefs(marginPref) {\n        if (!marginPref) return {};\n        return {\n            top: parseFloat(marginPref[\"@_Top\"]) || 0,\n            bottom: parseFloat(marginPref[\"@_Bottom\"]) || 0,\n            left: parseFloat(marginPref[\"@_Left\"]) || 0,\n            right: parseFloat(marginPref[\"@_Right\"]) || 0,\n            columnCount: parseInt(marginPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(marginPref[\"@_ColumnGutter\"]) || 0\n        };\n    }\n    extractColumnPrefs(columnPref) {\n        if (!columnPref) return {};\n        return {\n            textColumnCount: parseInt(columnPref[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(columnPref[\"@_TextColumnGutter\"]) || 0\n        };\n    }\n    resolveStyleFormatting(formatting) {\n        const resolved = {\n            ...formatting\n        };\n        // DEBUG: Check if formatting is being applied (generic check)\n        const hasAnyFormatting = formatting.paragraphStyle || formatting.characterStyle || formatting.fontStyle || formatting.fontReference || formatting.fontSize;\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Input:\", {\n                paragraphStyle: formatting.paragraphStyle,\n                characterStyle: formatting.characterStyle,\n                directFontStyle: formatting.fontStyle,\n                directFontRef: formatting.fontReference,\n                directFontSize: formatting.fontSize\n            });\n        }\n        // Resolve paragraph style (base layer)\n        if (formatting.paragraphStyle && this.styles.paragraph[formatting.paragraphStyle]) {\n            const pStyle = this.styles.paragraph[formatting.paragraphStyle];\n            if (!resolved.fontSize && pStyle.pointSize) resolved.fontSize = pStyle.pointSize;\n            if (!resolved.fillColor && pStyle.fillColor) resolved.fillColor = pStyle.fillColor;\n            // CRITICAL FIX: Always inherit paragraph alignment unless explicitly overridden\n            if (pStyle.alignment) resolved.alignment = pStyle.alignment;\n            if (!resolved.fontStyle && pStyle.fontStyle) {\n                resolved.fontStyle = pStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from paragraph style: \"'.concat(pStyle.fontStyle, '\"'));\n                }\n            }\n            // CRITICAL: Resolve font from paragraph style\n            if (!resolved.fontFamily && pStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(pStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from paragraph style: \".concat(pStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n            // Add other paragraph properties with enhanced leading support\n            resolved.leading = pStyle.leading;\n            resolved.leadingType = pStyle.leadingType;\n            resolved.effectiveLineHeight = pStyle.effectiveLineHeight;\n            resolved.leftIndent = pStyle.leftIndent;\n            resolved.rightIndent = pStyle.rightIndent;\n            resolved.firstLineIndent = pStyle.firstLineIndent;\n            resolved.spaceBefore = pStyle.spaceBefore;\n            resolved.spaceAfter = pStyle.spaceAfter;\n            resolved.tracking = pStyle.tracking;\n            resolved.kerning = pStyle.kerning;\n        }\n        // Resolve character style (override layer)\n        if (formatting.characterStyle && this.styles.character[formatting.characterStyle]) {\n            const cStyle = this.styles.character[formatting.characterStyle];\n            if (cStyle.pointSize) resolved.fontSize = cStyle.pointSize;\n            if (cStyle.fillColor) resolved.fillColor = cStyle.fillColor;\n            if (cStyle.fontStyle) {\n                resolved.fontStyle = cStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from character style: \"'.concat(cStyle.fontStyle, '\"'));\n                }\n            }\n            if (cStyle.strokeColor) resolved.strokeColor = cStyle.strokeColor;\n            // Include leading information from character style\n            if (cStyle.leading) resolved.leading = cStyle.leading;\n            if (cStyle.leadingType) resolved.leadingType = cStyle.leadingType;\n            if (cStyle.effectiveLineHeight) resolved.effectiveLineHeight = cStyle.effectiveLineHeight;\n            // CRITICAL: Character style font overrides paragraph style\n            if (cStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(cStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from character style: \".concat(cStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n        }\n        // Apply direct formatting (highest priority)\n        if (formatting.fontReference) {\n            resolved.fontFamily = this.resolveFontReference(formatting.fontReference);\n            if (hasAnyFormatting) {\n                console.log(\"   Font from direct formatting: \".concat(formatting.fontReference, \" -> \").concat(resolved.fontFamily));\n            }\n        }\n        // CRITICAL: Apply direct fontStyle if provided (this might be the issue)\n        if (formatting.fontStyle) {\n            resolved.fontStyle = formatting.fontStyle;\n            if (hasAnyFormatting) {\n                console.log('   FontStyle from direct formatting: \"'.concat(formatting.fontStyle, '\"'));\n            }\n        }\n        // Apply direct leading information (highest priority)\n        if (formatting.leading !== undefined) resolved.leading = formatting.leading;\n        if (formatting.leadingType) resolved.leadingType = formatting.leadingType;\n        if (formatting.effectiveLineHeight) resolved.effectiveLineHeight = formatting.effectiveLineHeight;\n        // Apply other direct formatting attributes\n        if (formatting.fontSize) resolved.fontSize = formatting.fontSize;\n        if (formatting.tracking) resolved.tracking = formatting.tracking;\n        if (formatting.kerning) resolved.kerning = formatting.kerning;\n        // CRITICAL FIX: Apply direct alignment if explicitly specified (overrides paragraph alignment)\n        if (formatting.alignment) {\n            resolved.alignment = formatting.alignment;\n            if (hasAnyFormatting) {\n                console.log('   Alignment from direct formatting: \"'.concat(formatting.alignment, '\"'));\n            }\n        }\n        // FIXED: Ensure fontStyle defaults to Regular/normal if not set\n        if (!resolved.fontStyle || resolved.fontStyle === \"\") {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log('   FontStyle defaulted to: \"Regular\"');\n            }\n        }\n        // ADDITIONAL FIX: If no styles were applied from any source, ensure clean defaults\n        if (!formatting.paragraphStyle && !formatting.characterStyle && !formatting.fontStyle && !formatting.fontReference) {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log(\"   No source styles found - ensuring clean defaults\");\n            }\n        }\n        // Final fallback\n        if (!resolved.fontFamily || resolved.fontFamily === \"\") {\n            resolved.fontFamily = this.getDefaultFont();\n            if (hasAnyFormatting) {\n                console.log(\"   Using fallback font: \".concat(resolved.fontFamily));\n            }\n        }\n        // Ensure line height is calculated if not explicitly set\n        if (!resolved.effectiveLineHeight && resolved.fontSize && resolved.leading) {\n            resolved.effectiveLineHeight = this.calculateEffectiveLineHeight(resolved.leading, resolved.fontSize);\n        }\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Final Output:\", {\n                fontSize: resolved.fontSize,\n                fontFamily: resolved.fontFamily,\n                fontStyle: resolved.fontStyle,\n                fillColor: resolved.fillColor,\n                leading: resolved.leading,\n                effectiveLineHeight: resolved.effectiveLineHeight\n            });\n        }\n        return resolved;\n    }\n    resolveFontReference(fontRef) {\n        if (!fontRef || fontRef === \"\") {\n            console.log(\"Empty font reference, using fallback\");\n            return this.getDefaultFont();\n        }\n        // Try direct lookup in font map\n        if (this.fontMap && this.fontMap.has(fontRef)) {\n            const resolvedFont = this.fontMap.get(fontRef);\n            console.log('Font resolved: \"'.concat(fontRef, '\" -> \"').concat(resolvedFont, '\"'));\n            return resolvedFont;\n        }\n        // Try partial matching for font families\n        if (this.resources.fonts) {\n            for (const [familyId, familyInfo] of Object.entries(this.resources.fonts)){\n                // Check family name match\n                if (familyInfo.name && (familyInfo.name.toLowerCase().includes(fontRef.toLowerCase()) || fontRef.toLowerCase().includes(familyInfo.name.toLowerCase()))) {\n                    console.log('Font partially matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                    return familyInfo.name;\n                }\n                // Check individual font matches\n                if (familyInfo.fonts) {\n                    for (const font of familyInfo.fonts){\n                        if (font.self === fontRef || font.postScriptName === fontRef || font.name === fontRef) {\n                            console.log('Font exactly matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                            return familyInfo.name;\n                        }\n                    }\n                }\n            }\n        }\n        console.log('Font not found: \"'.concat(fontRef, '\", using fallback'));\n        return this.getDefaultFont() || fontRef;\n    }\n    getDefaultFont() {\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFamily = Object.values(this.resources.fonts)[0];\n            return firstFamily.name || \"Arial\";\n        }\n        return \"Arial\";\n    }\n    inferFontFromContext() {\n        // If we have font definitions but no explicit references,\n        // return the first available font as a fallback\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFontFamily = Object.values(this.resources.fonts)[0];\n            return firstFontFamily.name;\n        }\n        return null;\n    }\n    getStoryStyleSummary(story) {\n        var _story_content_formattedContent, _story_content;\n        const summary = {\n            fontSize: null,\n            fontFamily: null,\n            alignment: null,\n            fillColor: null,\n            fontStyle: null,\n            leading: null,\n            leadingType: null,\n            effectiveLineHeight: null,\n            tracking: null,\n            kerning: null\n        };\n        // Get the most common or first formatting values\n        if (((_story_content = story.content) === null || _story_content === void 0 ? void 0 : (_story_content_formattedContent = _story_content.formattedContent) === null || _story_content_formattedContent === void 0 ? void 0 : _story_content_formattedContent.length) > 0) {\n            const firstFormatted = story.content.formattedContent.find((item)=>item.formatting && !item.formatting.isBreak);\n            if (firstFormatted === null || firstFormatted === void 0 ? void 0 : firstFormatted.formatting) {\n                const fmt = firstFormatted.formatting;\n                summary.fontSize = fmt.fontSize;\n                summary.fontFamily = fmt.fontFamily;\n                summary.alignment = fmt.alignment;\n                summary.fillColor = fmt.fillColor;\n                summary.fontStyle = fmt.fontStyle;\n                summary.leading = fmt.leading;\n                summary.leadingType = fmt.leadingType;\n                summary.effectiveLineHeight = fmt.effectiveLineHeight;\n                summary.tracking = fmt.tracking;\n                summary.kerning = fmt.kerning;\n            }\n        }\n        return summary;\n    }\n    // NEW: Process leading values with InDesign-specific logic (shared with StoryParser)\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = parseFloat(rawLeading);\n        if (!isNaN(numericLeading)) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (!isNaN(parseFloat(rawLeading))) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(leading, fontSize) {\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\" && fontSize) {\n            // Convert points to CSS line-height ratio\n            return Math.max(0.8, leading / fontSize); // Ensure minimum line height\n        }\n        return 1.2; // Fallback\n    }\n    getStyles() {\n        return this.styles;\n    }\n    getResources() {\n        return this.resources;\n    }\n    getFontMap() {\n        return this.fontMap;\n    }\n    // Add methods to return style and font definitions for debug\n    getParagraphStyles() {\n        return this.styles.paragraph;\n    }\n    getCharacterStyles() {\n        return this.styles.character;\n    }\n    getFontDefinitions() {\n        // Prefer plain object for debug output\n        if (this.resources && this.resources.fonts) {\n            return this.resources.fonts;\n        }\n        // Fallback: convert fontMap to object\n        if (this.fontMap && typeof this.fontMap.entries === \"function\") {\n            return Object.fromEntries(this.fontMap.entries());\n        }\n        return {};\n    }\n    // FIXED: Add method to access document preferences including ViewPreferences\n    getDocumentInfo() {\n        return this.documentInfo;\n    }\n    constructor(unitConverter = null){\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n        this.resources = {\n            fonts: {},\n            colors: {},\n            gradients: {}\n        };\n        this.fontMap = new Map(); // Global font lookup map\n        this.unitConverter = unitConverter; // ADDED: Unit converter for typography measurements\n        this.documentUnits = null; // Will be set from document units\n    }\n}\nmodule.exports = StyleParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtRQUNoQixPQUFPLElBQUksQ0FBQ3pHLFlBQVk7SUFDMUI7SUE1aENBMEcsWUFBWWhSLGdCQUFnQixJQUFJLENBQUU7UUFDaEMsSUFBSSxDQUFDMkIsTUFBTSxHQUFHO1lBQ1p3RCxXQUFXLENBQUM7WUFDWk8sV0FBVyxDQUFDO1lBQ1p1TCxRQUFRLENBQUM7WUFDVEMsT0FBTyxDQUFDO1lBQ1JDLE1BQU0sQ0FBQztRQUNUO1FBQ0EsSUFBSSxDQUFDbkwsU0FBUyxHQUFHO1lBQ2ZGLE9BQU8sQ0FBQztZQUNSeUIsUUFBUSxDQUFDO1lBQ1RDLFdBQVcsQ0FBQztRQUNkO1FBQ0EsSUFBSSxDQUFDdkIsT0FBTyxHQUFHLElBQUlDLE9BQU8seUJBQXlCO1FBQ25ELElBQUksQ0FBQ2xHLGFBQWEsR0FBR0EsZUFBZSxvREFBb0Q7UUFDeEYsSUFBSSxDQUFDTixhQUFhLEdBQUcsTUFBTSxrQ0FBa0M7SUFDL0Q7QUE2Z0NGO0FBRUEwUixPQUFPQyxPQUFPLEdBQUc5UiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGFyc2Vycy9TdHlsZVBhcnNlci5qcz82OWFjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9JRE1MVXRpbHNcIik7XG5cbmNsYXNzIFN0eWxlUGFyc2VyIHtcbiAgY29uc3RydWN0b3IodW5pdENvbnZlcnRlciA9IG51bGwpIHtcbiAgICB0aGlzLnN0eWxlcyA9IHtcbiAgICAgIHBhcmFncmFwaDoge30sXG4gICAgICBjaGFyYWN0ZXI6IHt9LFxuICAgICAgb2JqZWN0OiB7fSxcbiAgICAgIHRhYmxlOiB7fSxcbiAgICAgIGNlbGw6IHt9LFxuICAgIH07XG4gICAgdGhpcy5yZXNvdXJjZXMgPSB7XG4gICAgICBmb250czoge30sXG4gICAgICBjb2xvcnM6IHt9LFxuICAgICAgZ3JhZGllbnRzOiB7fSxcbiAgICB9O1xuICAgIHRoaXMuZm9udE1hcCA9IG5ldyBNYXAoKTsgLy8gR2xvYmFsIGZvbnQgbG9va3VwIG1hcFxuICAgIHRoaXMudW5pdENvbnZlcnRlciA9IHVuaXRDb252ZXJ0ZXI7IC8vIEFEREVEOiBVbml0IGNvbnZlcnRlciBmb3IgdHlwb2dyYXBoeSBtZWFzdXJlbWVudHNcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSBudWxsOyAvLyBXaWxsIGJlIHNldCBmcm9tIGRvY3VtZW50IHVuaXRzXG4gIH1cblxuICAvLyBBRERFRDogTWV0aG9kIHRvIHNldCBkb2N1bWVudCB1bml0cyBmb3IgdHlwb2dyYXBoeSBjb252ZXJzaW9uXG4gIHNldERvY3VtZW50VW5pdHModW5pdHMpIHtcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSB1bml0cztcbiAgICBjb25zb2xlLmxvZyhcIvCfk5AgU3R5bGVQYXJzZXI6IFNldCBkb2N1bWVudCB1bml0cyB0b1wiLCB1bml0cyk7XG4gIH1cblxuICAvLyBBRERFRDogTWV0aG9kIHRvIGNvbnZlcnQgdHlwb2dyYXBoeSBtZWFzdXJlbWVudHMgdG8gcGl4ZWxzXG4gIGNvbnZlcnRUeXBvZ3JhcGh5VG9QaXhlbHModmFsdWUpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgIGlzTmFOKHZhbHVlKSB8fFxuICAgICAgIXRoaXMudW5pdENvbnZlcnRlciB8fFxuICAgICAgIXRoaXMuZG9jdW1lbnRVbml0c1xuICAgICkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIE9ubHkgY29udmVydCBpZiB3ZSBoYXZlIGEgc3VwcG9ydGVkIHVuaXQgYW5kIGl0J3Mgbm90IGFscmVhZHkgcGl4ZWxzXG4gICAgaWYgKHRoaXMudW5pdENvbnZlcnRlci5pc1N1cHBvcnRlZFVuaXQodGhpcy5kb2N1bWVudFVuaXRzKSkge1xuICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSB0aGlzLnVuaXRDb252ZXJ0ZXIudG9QaXhlbHMoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0aGlzLmRvY3VtZW50VW5pdHNcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCfk5AgQ29udmVydGVkIHR5cG9ncmFwaHk6ICR7dmFsdWV9ICR7dGhpcy5kb2N1bWVudFVuaXRzfSDihpIgJHtjb252ZXJ0ZWRWYWx1ZX0gcHhgXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbnZlcnRlZFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gY29udmVydCBhbiBlbnRpcmUgc3R5bGUgb2JqZWN0J3MgbWVhc3VyZW1lbnRzIHRvIHBpeGVsc1xuICBjb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyhzdHlsZSkge1xuICAgIGlmICghdGhpcy51bml0Q29udmVydGVyIHx8ICF0aGlzLmRvY3VtZW50VW5pdHMpIHtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICBjb25zdCBjb252ZXJ0ZWRTdHlsZSA9IHsgLi4uc3R5bGUgfTtcblxuICAgIC8vIENvbnZlcnQgbWVhc3VyZW1lbnRzIHRoYXQgbmVlZCBwaXhlbCBjb252ZXJzaW9uXG4gICAgY29uc3QgbWVhc3VyZW1lbnRGaWVsZHMgPSBbXG4gICAgICBcImxlZnRJbmRlbnRcIixcbiAgICAgIFwicmlnaHRJbmRlbnRcIixcbiAgICAgIFwiZmlyc3RMaW5lSW5kZW50XCIsXG4gICAgICBcInNwYWNlQmVmb3JlXCIsXG4gICAgICBcInNwYWNlQWZ0ZXJcIixcbiAgICAgIFwidHJhY2tpbmdcIixcbiAgICAgIFwia2VybmluZ1wiLFxuICAgIF07XG5cbiAgICBtZWFzdXJlbWVudEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjb252ZXJ0ZWRTdHlsZVtmaWVsZF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29udmVydGVkU3R5bGVbZmllbGRdID0gdGhpcy5jb252ZXJ0VHlwb2dyYXBoeVRvUGl4ZWxzKFxuICAgICAgICAgIGNvbnZlcnRlZFN0eWxlW2ZpZWxkXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ29udmVydCBsZWFkaW5nIGlmIGl0J3MgYSBudW1lcmljIHZhbHVlXG4gICAgaWYgKHR5cGVvZiBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nID0gdGhpcy5jb252ZXJ0VHlwb2dyYXBoeVRvUGl4ZWxzKFxuICAgICAgICBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0ZWRTdHlsZTtcbiAgfVxuXG4gIGFzeW5jIHBhcnNlUmVzb3VyY2VGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpIHtcbiAgICBjb25zb2xlLmxvZyhg8J+TiyBQYXJzaW5nIHJlc291cmNlOiAke2ZpbGVOYW1lfWApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcbiAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUsIFwiLnhtbFwiKTtcblxuICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCByZXNvdXJjZSB0eXBlc1xuICAgICAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKFwiU3R5bGVzLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RTdHlsZXMocGFyc2VkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoXCJGb250cy54bWxcIikpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0Rm9udHMocGFyc2VkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoXCJHcmFwaGljLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RHcmFwaGljcyhwYXJzZWQpO1xuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhcIlByZWZlcmVuY2VzLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RQcmVmZXJlbmNlcyhwYXJzZWQpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFJlc291cmNlICR7cmVzb3VyY2VOYW1lfSBwYXJzZWRgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHBhcnNpbmcgJHtmaWxlTmFtZX06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZXh0cmFjdFN0eWxlcyhzdHlsZXNEYXRhKSB7XG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIHN0eWxlcy4uLlwiKTtcblxuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlc0RhdGEuU3R5bGVzIHx8IHN0eWxlc0RhdGE7XG5cbiAgICAvLyBFeHRyYWN0IFBhcmFncmFwaCBTdHlsZXNcbiAgICBpZiAoc3R5bGVzLlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XG4gICAgICB0aGlzLmV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMoc3R5bGVzLlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwKTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IENoYXJhY3RlciBTdHlsZXNcbiAgICBpZiAoc3R5bGVzLlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwKSB7XG4gICAgICB0aGlzLmV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVzLlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwKTtcbiAgICB9XG4gIH1cblxuICBleHRyYWN0UGFyYWdyYXBoU3R5bGVzKHN0eWxlR3JvdXApIHtcbiAgICBjb25zdCBleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkgPSAoZ3JvdXApID0+IHtcbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZSkge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBBcnJheS5pc0FycmF5KGdyb3VwLlBhcmFncmFwaFN0eWxlKVxuICAgICAgICAgID8gZ3JvdXAuUGFyYWdyYXBoU3R5bGVcbiAgICAgICAgICA6IFtncm91cC5QYXJhZ3JhcGhTdHlsZV07XG5cbiAgICAgICAgc3R5bGVzLmZvckVhY2goKHN0eWxlKSA9PiB7XG4gICAgICAgICAgLy8gQ1JJVElDQUw6IEV4dHJhY3QgZm9udCByZWZlcmVuY2UgZnJvbSBtdWx0aXBsZSBwb3NzaWJsZSBsb2NhdGlvbnNcbiAgICAgICAgICBjb25zdCBmb250UmVmID0gdGhpcy5leHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSk7XG5cbiAgICAgICAgICAvLyBFTkhBTkNFRDogUHJvY2VzcyBsZWFkaW5nIHdpdGggcHJvcGVyIEluRGVzaWduIGxvZ2ljXG4gICAgICAgICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9Qb2ludFNpemVcIl0pIHx8IDEyO1xuICAgICAgICAgIGNvbnN0IHJhd0xlYWRpbmcgPSBzdHlsZVtcIkBfTGVhZGluZ1wiXTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzZWRMZWFkaW5nID0gdGhpcy5wcm9jZXNzTGVhZGluZ1ZhbHVlKFxuICAgICAgICAgICAgcmF3TGVhZGluZyxcbiAgICAgICAgICAgIGZvbnRTaXplXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIEZJWEVEOiBFeHRyYWN0IHJhdyB0eXBvZ3JhcGh5IG1lYXN1cmVtZW50cyBmb3IgY29udmVyc2lvblxuICAgICAgICAgIGNvbnN0IHJhd0xlZnRJbmRlbnQgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9MZWZ0SW5kZW50XCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1JpZ2h0SW5kZW50ID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfUmlnaHRJbmRlbnRcIl0pIHx8IDA7XG4gICAgICAgICAgY29uc3QgcmF3Rmlyc3RMaW5lSW5kZW50ID1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoc3R5bGVbXCJAX0ZpcnN0TGluZUluZGVudFwiXSkgfHwgMDtcbiAgICAgICAgICBjb25zdCByYXdTcGFjZUJlZm9yZSA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1NwYWNlQmVmb3JlXCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1NwYWNlQWZ0ZXIgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9TcGFjZUFmdGVyXCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1RyYWNraW5nID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfVHJhY2tpbmdcIl0pIHx8IDA7XG4gICAgICAgICAgY29uc3QgcmF3S2VybmluZyA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX0tlcm5pbmdcIl0pIHx8IDA7XG5cbiAgICAgICAgICAvLyBGSVhFRDogQ3JlYXRlIGJhc2Ugc3R5bGUgb2JqZWN0IHdpdGggcmF3IHZhbHVlc1xuICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHtcbiAgICAgICAgICAgIHNlbGY6IHN0eWxlW1wiQF9TZWxmXCJdLFxuICAgICAgICAgICAgbmFtZTogc3R5bGVbXCJAX05hbWVcIl0gfHwgXCJcIixcbiAgICAgICAgICAgIGZvbnRTdHlsZTogc3R5bGVbXCJAX0ZvbnRTdHlsZVwiXSB8fCBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgIHBvaW50U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgICBsZWFkaW5nOiBwcm9jZXNzZWRMZWFkaW5nLFxuICAgICAgICAgICAgbGVhZGluZ1R5cGU6IHRoaXMuZGV0ZXJtaW5lTGVhZGluZ1R5cGUocmF3TGVhZGluZyksXG4gICAgICAgICAgICBlZmZlY3RpdmVMaW5lSGVpZ2h0OiB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoXG4gICAgICAgICAgICAgIHByb2Nlc3NlZExlYWRpbmcsXG4gICAgICAgICAgICAgIGZvbnRTaXplXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYWxpZ25tZW50OiBzdHlsZVtcIkBfSnVzdGlmaWNhdGlvblwiXSB8fCBcIkxlZnRBbGlnblwiLFxuXG4gICAgICAgICAgICAvLyBSYXcgbWVhc3VyZW1lbnRzICh3aWxsIGJlIGNvbnZlcnRlZCB0byBwaXhlbHMpXG4gICAgICAgICAgICBsZWZ0SW5kZW50OiByYXdMZWZ0SW5kZW50LFxuICAgICAgICAgICAgcmlnaHRJbmRlbnQ6IHJhd1JpZ2h0SW5kZW50LFxuICAgICAgICAgICAgZmlyc3RMaW5lSW5kZW50OiByYXdGaXJzdExpbmVJbmRlbnQsXG4gICAgICAgICAgICBzcGFjZUJlZm9yZTogcmF3U3BhY2VCZWZvcmUsXG4gICAgICAgICAgICBzcGFjZUFmdGVyOiByYXdTcGFjZUFmdGVyLFxuICAgICAgICAgICAgdHJhY2tpbmc6IHJhd1RyYWNraW5nLFxuICAgICAgICAgICAga2VybmluZzogcmF3S2VybmluZyxcblxuICAgICAgICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgdmFsdWVzIGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgIG9yaWdpbmFsTGVmdEluZGVudDogcmF3TGVmdEluZGVudCxcbiAgICAgICAgICAgIG9yaWdpbmFsUmlnaHRJbmRlbnQ6IHJhd1JpZ2h0SW5kZW50LFxuICAgICAgICAgICAgb3JpZ2luYWxGaXJzdExpbmVJbmRlbnQ6IHJhd0ZpcnN0TGluZUluZGVudCxcbiAgICAgICAgICAgIG9yaWdpbmFsU3BhY2VCZWZvcmU6IHJhd1NwYWNlQmVmb3JlLFxuICAgICAgICAgICAgb3JpZ2luYWxTcGFjZUFmdGVyOiByYXdTcGFjZUFmdGVyLFxuICAgICAgICAgICAgb3JpZ2luYWxUcmFja2luZzogcmF3VHJhY2tpbmcsXG4gICAgICAgICAgICBvcmlnaW5hbEtlcm5pbmc6IHJhd0tlcm5pbmcsXG5cbiAgICAgICAgICAgIGhvcml6b250YWxTY2FsZTogcGFyc2VGbG9hdChzdHlsZVtcIkBfSG9yaXpvbnRhbFNjYWxlXCJdKSB8fCAxMDAsXG4gICAgICAgICAgICB2ZXJ0aWNhbFNjYWxlOiBwYXJzZUZsb2F0KHN0eWxlW1wiQF9WZXJ0aWNhbFNjYWxlXCJdKSB8fCAxMDAsXG5cbiAgICAgICAgICAgIC8vIEVOSEFOQ0VEOiBVc2UgdGhlIG5ldyBleHRyYWN0aW9uIG1ldGhvZFxuICAgICAgICAgICAgYXBwbGllZEZvbnQ6IGZvbnRSZWYsXG4gICAgICAgICAgICBvcmlnaW5hbEZvbnRSZWY6IGZvbnRSZWYsXG5cbiAgICAgICAgICAgIGZpbGxDb2xvcjogc3R5bGVbXCJAX0ZpbGxDb2xvclwiXSB8fCBcIkNvbG9yL0JsYWNrXCIsXG4gICAgICAgICAgICByYXdTdHlsZTogc3R5bGUsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEZJWEVEOiBBcHBseSB1bml0IGNvbnZlcnNpb24gdG8gY3JlYXRlIHBpeGVsLWNvbnZlcnRlZCBzdHlsZVxuICAgICAgICAgIHRoaXMuc3R5bGVzLnBhcmFncmFwaFtzdHlsZVtcIkBfU2VsZlwiXV0gPVxuICAgICAgICAgICAgdGhpcy5jb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyhiYXNlU3R5bGUpO1xuXG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBg4pyFIFBhcmFncmFwaCBTdHlsZTogJHtzdHlsZVtcIkBfTmFtZVwiXX0gLT4gRm9udDogXCIke2ZvbnRSZWZ9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN1Ykdyb3VwcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cClcbiAgICAgICAgICA/IGdyb3VwLlBhcmFncmFwaFN0eWxlR3JvdXBcbiAgICAgICAgICA6IFtncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwXTtcbiAgICAgICAgc3ViR3JvdXBzLmZvckVhY2goZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KHN0eWxlR3JvdXApO1xuICB9XG5cbiAgZXh0cmFjdEZvbnRGcm9tU3R5bGUoc3R5bGUpIHtcbiAgICAvLyBUcnkgZGlyZWN0IGF0dHJpYnV0ZXMgZmlyc3RcbiAgICBsZXQgZm9udFJlZiA9XG4gICAgICBzdHlsZVtcIkBfQXBwbGllZEZvbnRcIl0gfHwgc3R5bGVbXCJAX0ZvbnRGYW1pbHlcIl0gfHwgc3R5bGVbXCJAX0ZvbnRcIl0gfHwgXCJcIjtcblxuICAgIC8vIElmIG5vdCBmb3VuZCwgdHJ5IFByb3BlcnRpZXMgbmVzdGVkIHN0cnVjdHVyZVxuICAgIGlmICghZm9udFJlZiAmJiBzdHlsZS5Qcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoc3R5bGUuUHJvcGVydGllcy5BcHBsaWVkRm9udCkge1xuICAgICAgICBmb250UmVmID1cbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250W1wiI3RleHRcIl0gfHxcbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250IHx8XG4gICAgICAgICAgXCJcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWxzbyB0cnkgb3RoZXIgcHJvcGVydHkgdmFyaWF0aW9uc1xuICAgICAgaWYgKCFmb250UmVmICYmIHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseSkge1xuICAgICAgICBmb250UmVmID1cbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkZvbnRGYW1pbHlbXCIjdGV4dFwiXSB8fFxuICAgICAgICAgIHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseSB8fFxuICAgICAgICAgIFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnRSZWYgfHwgXCJcIjtcbiAgfVxuXG4gIGV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVHcm91cCkge1xuICAgIGNvbnN0IGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSA9IChncm91cCkgPT4ge1xuICAgICAgaWYgKGdyb3VwLkNoYXJhY3RlclN0eWxlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuQ2hhcmFjdGVyU3R5bGUpXG4gICAgICAgICAgPyBncm91cC5DaGFyYWN0ZXJTdHlsZVxuICAgICAgICAgIDogW2dyb3VwLkNoYXJhY3RlclN0eWxlXTtcblxuICAgICAgICBzdHlsZXMuZm9yRWFjaCgoc3R5bGUpID0+IHtcbiAgICAgICAgICBjb25zdCBmb250UmVmID0gdGhpcy5leHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSk7XG5cbiAgICAgICAgICB0aGlzLnN0eWxlcy5jaGFyYWN0ZXJbc3R5bGVbXCJAX1NlbGZcIl1dID0ge1xuICAgICAgICAgICAgc2VsZjogc3R5bGVbXCJAX1NlbGZcIl0sXG4gICAgICAgICAgICBuYW1lOiBzdHlsZVtcIkBfTmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgICAgZm9udFN0eWxlOiBzdHlsZVtcIkBfRm9udFN0eWxlXCJdIHx8IFwiUmVndWxhclwiLFxuICAgICAgICAgICAgcG9pbnRTaXplOiBwYXJzZUZsb2F0KHN0eWxlW1wiQF9Qb2ludFNpemVcIl0pIHx8IG51bGwsXG5cbiAgICAgICAgICAgIGFwcGxpZWRGb250OiBmb250UmVmLFxuICAgICAgICAgICAgb3JpZ2luYWxGb250UmVmOiBmb250UmVmLFxuXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHN0eWxlW1wiQF9GaWxsQ29sb3JcIl0gfHwgbnVsbCxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzdHlsZVtcIkBfU3Ryb2tlQ29sb3JcIl0gfHwgbnVsbCxcbiAgICAgICAgICAgIHJhd1N0eWxlOiBzdHlsZSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBg4pyFIENoYXJhY3RlciBTdHlsZTogJHtzdHlsZVtcIkBfTmFtZVwiXX0gLT4gRm9udDogXCIke2ZvbnRSZWZ9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN1Ykdyb3VwcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuQ2hhcmFjdGVyU3R5bGVHcm91cClcbiAgICAgICAgICA/IGdyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXBcbiAgICAgICAgICA6IFtncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwXTtcbiAgICAgICAgc3ViR3JvdXBzLmZvckVhY2goZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KHN0eWxlR3JvdXApO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdEZvbnRzKGZvbnRzRGF0YSkge1xuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBmb250cyB3aXRoIGVuaGFuY2VkIG1hcHBpbmcuLi5cIik7XG5cbiAgICBjb25zdCBmb250cyA9IGZvbnRzRGF0YS5Gb250cyB8fCBmb250c0RhdGE7XG4gICAgdGhpcy5yZXNvdXJjZXMuZm9udHMgPSB7fTtcbiAgICB0aGlzLmZvbnRNYXAgPSBuZXcgTWFwKCk7IC8vIEdsb2JhbCBmb250IGxvb2t1cCBtYXBcblxuICAgIGlmIChmb250cy5Gb250RmFtaWx5KSB7XG4gICAgICBjb25zdCBmb250RmFtaWxpZXMgPSBBcnJheS5pc0FycmF5KGZvbnRzLkZvbnRGYW1pbHkpXG4gICAgICAgID8gZm9udHMuRm9udEZhbWlseVxuICAgICAgICA6IFtmb250cy5Gb250RmFtaWx5XTtcblxuICAgICAgZm9udEZhbWlsaWVzLmZvckVhY2goKGZhbWlseSkgPT4ge1xuICAgICAgICBjb25zdCBmYW1pbHlJbmZvID0ge1xuICAgICAgICAgIHNlbGY6IGZhbWlseVtcIkBfU2VsZlwiXSxcbiAgICAgICAgICBuYW1lOiBmYW1pbHlbXCJAX05hbWVcIl0gfHwgXCJcIixcbiAgICAgICAgICBmb250czogW10sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZhbWlseS5Gb250KSB7XG4gICAgICAgICAgY29uc3QgZm9udExpc3QgPSBBcnJheS5pc0FycmF5KGZhbWlseS5Gb250KVxuICAgICAgICAgICAgPyBmYW1pbHkuRm9udFxuICAgICAgICAgICAgOiBbZmFtaWx5LkZvbnRdO1xuXG4gICAgICAgICAgZm9udExpc3QuZm9yRWFjaCgoZm9udCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm9udEluZm8gPSB7XG4gICAgICAgICAgICAgIHNlbGY6IGZvbnRbXCJAX1NlbGZcIl0sXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGZvbnRbXCJAX0ZvbnRGYW1pbHlcIl0gfHwgZmFtaWx5SW5mby5uYW1lLFxuICAgICAgICAgICAgICBuYW1lOiBmb250W1wiQF9OYW1lXCJdIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHBvc3RTY3JpcHROYW1lOiBmb250W1wiQF9Qb3N0U2NyaXB0TmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgICAgICBzdGF0dXM6IGZvbnRbXCJAX1N0YXR1c1wiXSB8fCBcIlVua25vd25cIixcbiAgICAgICAgICAgICAgZm9udFN0eWxlTmFtZTogZm9udFtcIkBfRm9udFN0eWxlTmFtZVwiXSB8fCBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZhbWlseUluZm8uZm9udHMucHVzaChmb250SW5mbyk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBsb29rdXAgZW50cmllcyBmb3IgdGhpcyBmb250XG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX1NlbGZcIl0sIGZhbWlseUluZm8ubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX1Bvc3RTY3JpcHROYW1lXCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250W1wiQF9OYW1lXCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250W1wiQF9Gb250RmFtaWx5XCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYEZvbnQgbWFwcGluZzogJHtmb250W1wiQF9TZWxmXCJdfSAtPiAke2ZhbWlseUluZm8ubmFtZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZm9udHNbZmFtaWx5W1wiQF9TZWxmXCJdXSA9IGZhbWlseUluZm87XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGDinIUgRm9udHMgZXh0cmFjdGVkOiAke09iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGh9IGZhbWlsaWVzYFxuICAgICk7XG4gICAgY29uc29sZS5sb2coYEZvbnQgbWFwIGVudHJpZXM6ICR7dGhpcy5mb250TWFwLnNpemV9YCk7XG4gIH1cblxuICBhc3luYyBleHRyYWN0R3JhcGhpY3MoZ3JhcGhpY3NEYXRhKSB7XG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIGdyYXBoaWNzIGFuZCBjb2xvcnMuLi5cIik7XG5cbiAgICBjb25zdCBncmFwaGljcyA9IGdyYXBoaWNzRGF0YS5HcmFwaGljIHx8IGdyYXBoaWNzRGF0YTtcbiAgICB0aGlzLnJlc291cmNlcy5jb2xvcnMgPSB7fTtcbiAgICB0aGlzLnJlc291cmNlcy5ncmFkaWVudHMgPSB7fTtcblxuICAgIC8vIEV4dHJhY3QgQ29sb3JzXG4gICAgaWYgKGdyYXBoaWNzLkNvbG9yKSB7XG4gICAgICBjb25zdCBjb2xvcnMgPSBBcnJheS5pc0FycmF5KGdyYXBoaWNzLkNvbG9yKVxuICAgICAgICA/IGdyYXBoaWNzLkNvbG9yXG4gICAgICAgIDogW2dyYXBoaWNzLkNvbG9yXTtcblxuICAgICAgY29sb3JzLmZvckVhY2goKGNvbG9yKSA9PiB7XG4gICAgICAgIC8vIEV4dHJhY3QgaW5kaXZpZHVhbCBjaGFubmVsIHZhbHVlcyBmcm9tIGF0dHJpYnV0ZXMgKGlmIHByZXNlbnQpXG4gICAgICAgIGNvbnN0IGN5YW4gPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9DeWFuXCJdKSB8fCAwO1xuICAgICAgICBjb25zdCBtYWdlbnRhID0gcGFyc2VGbG9hdChjb2xvcltcIkBfTWFnZW50YVwiXSkgfHwgMDtcbiAgICAgICAgY29uc3QgeWVsbG93ID0gcGFyc2VGbG9hdChjb2xvcltcIkBfWWVsbG93XCJdKSB8fCAwO1xuICAgICAgICBjb25zdCBibGFjayA9IHBhcnNlRmxvYXQoY29sb3JbXCJAX0JsYWNrXCJdKSB8fCAwO1xuICAgICAgICBjb25zdCByZWQgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9SZWRcIl0pIHx8IDA7XG4gICAgICAgIGNvbnN0IGdyZWVuID0gcGFyc2VGbG9hdChjb2xvcltcIkBfR3JlZW5cIl0pIHx8IDA7XG4gICAgICAgIGNvbnN0IGJsdWUgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9CbHVlXCJdKSB8fCAwO1xuXG4gICAgICAgIC8vIEdldCBjb2xvciBzcGFjZSBhbmQgbW9kZWwgaW5mb3JtYXRpb25cbiAgICAgICAgY29uc3QgY29sb3JTcGFjZSA9IGNvbG9yW1wiQF9TcGFjZVwiXSB8fCBcIkNNWUtcIjtcbiAgICAgICAgY29uc3QgY29sb3JNb2RlbCA9IGNvbG9yW1wiQF9Nb2RlbFwiXSB8fCBcIlByb2Nlc3NcIjtcbiAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IGNvbG9yW1wiQF9Db2xvclZhbHVlXCJdO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46oIFByb2Nlc3NpbmcgY29sb3I6ICR7Y29sb3JbXCJAX1NlbGZcIl19YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBTcGFjZTogJHtjb2xvclNwYWNlfSwgTW9kZWw6ICR7Y29sb3JNb2RlbH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIENvbG9yVmFsdWU6IFwiJHtjb2xvclZhbHVlfVwiYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgICBJbmRpdmlkdWFsIGNoYW5uZWxzIC0gQzoke2N5YW59IE06JHttYWdlbnRhfSBZOiR7eWVsbG93fSBLOiR7YmxhY2t9IFI6JHtyZWR9IEc6JHtncmVlbn0gQjoke2JsdWV9YFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgY29sb3IgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgbGV0IGZpbmFsQ29sb3JEYXRhID0ge1xuICAgICAgICAgIHNlbGY6IGNvbG9yW1wiQF9TZWxmXCJdLFxuICAgICAgICAgIG5hbWU6IGNvbG9yW1wiQF9OYW1lXCJdIHx8IFwiXCIsXG4gICAgICAgICAgbW9kZWw6IGNvbG9yTW9kZWwsXG4gICAgICAgICAgc3BhY2U6IGNvbG9yU3BhY2UsXG4gICAgICAgICAgY3lhbjogMCxcbiAgICAgICAgICBtYWdlbnRhOiAwLFxuICAgICAgICAgIHllbGxvdzogMCxcbiAgICAgICAgICBibGFjazogMCxcbiAgICAgICAgICByZWQ6IDAsXG4gICAgICAgICAgZ3JlZW46IDAsXG4gICAgICAgICAgYmx1ZTogMCxcbiAgICAgICAgICAvLyBBZGRpdGlvbmFsIGZpZWxkcyB0byB0cmFjayBjb2xvciBzb3VyY2VcbiAgICAgICAgICBjb2xvclNvdXJjZTogXCJ1bmtub3duXCIsXG4gICAgICAgICAgaGFzRGlyZWN0UkdCOiBmYWxzZSxcbiAgICAgICAgICBoYXNEaXJlY3RDTVlLOiBmYWxzZSxcbiAgICAgICAgICBoYXNDb2xvclZhbHVlOiAhIWNvbG9yVmFsdWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU1RSQVRFR1kgMTogQ2hlY2sgZm9yIGRpcmVjdCBSR0IgdmFsdWVzIGluIGluZGl2aWR1YWwgYXR0cmlidXRlc1xuICAgICAgICBpZiAocmVkID4gMCB8fCBncmVlbiA+IDAgfHwgYmx1ZSA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGAgICDinIUgVXNpbmcgZGlyZWN0IFJHQiBmcm9tIGluZGl2aWR1YWwgY2hhbm5lbHM6IFI6JHtyZWR9IEc6JHtncmVlbn0gQjoke2JsdWV9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEucmVkID0gcmVkO1xuICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmdyZWVuID0gZ3JlZW47XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuYmx1ZSA9IGJsdWU7XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImRpcmVjdF9yZ2JfY2hhbm5lbHNcIjtcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RSR0IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNUUkFURUdZIDI6IENoZWNrIGZvciBkaXJlY3QgQ01ZSyB2YWx1ZXMgaW4gaW5kaXZpZHVhbCBhdHRyaWJ1dGVzXG4gICAgICAgIGVsc2UgaWYgKGN5YW4gPiAwIHx8IG1hZ2VudGEgPiAwIHx8IHllbGxvdyA+IDAgfHwgYmxhY2sgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgICAg4pyFIFVzaW5nIGRpcmVjdCBDTVlLIGZyb20gaW5kaXZpZHVhbCBjaGFubmVsczogQzoke2N5YW59IE06JHttYWdlbnRhfSBZOiR7eWVsbG93fSBLOiR7YmxhY2t9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuY3lhbiA9IGN5YW47XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEubWFnZW50YSA9IG1hZ2VudGE7XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEueWVsbG93ID0geWVsbG93O1xuICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmJsYWNrID0gYmxhY2s7XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImRpcmVjdF9jbXlrX2NoYW5uZWxzXCI7XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuaGFzRGlyZWN0Q01ZSyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU1RSQVRFR1kgMzogUGFyc2UgQ29sb3JWYWx1ZSBhdHRyaWJ1dGUgKHN1cHBvcnRzIGJvdGggUkdCIGFuZCBDTVlLKVxuICAgICAgICBlbHNlIGlmIChjb2xvclZhbHVlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIPCflI0gUGFyc2luZyBDb2xvclZhbHVlOiBcIiR7Y29sb3JWYWx1ZX1cImApO1xuXG4gICAgICAgICAgLy8gU3BsaXQgQ29sb3JWYWx1ZSBpbnRvIG51bWVyaWMgcGFydHNcbiAgICAgICAgICBjb25zdCB2YWx1ZVBhcnRzID0gY29sb3JWYWx1ZVxuICAgICAgICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgLmZpbHRlcigodikgPT4gIWlzTmFOKHYpKTtcblxuICAgICAgICAgIGlmICh2YWx1ZVBhcnRzLmxlbmd0aCA9PT0gMyAmJiBjb2xvclNwYWNlID09PSBcIlJHQlwiKSB7XG4gICAgICAgICAgICAvLyBSR0IgQ29sb3JWYWx1ZTogXCIyNTUgMTM3IDBcIiAtPiBSOjI1NSBHOjEzNyBCOjBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBgICAg4pyFIFVzaW5nIFJHQiBDb2xvclZhbHVlOiBSOiR7dmFsdWVQYXJ0c1swXX0gRzoke3ZhbHVlUGFydHNbMV19IEI6JHt2YWx1ZVBhcnRzWzJdfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5yZWQgPSB2YWx1ZVBhcnRzWzBdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuZ3JlZW4gPSB2YWx1ZVBhcnRzWzFdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuYmx1ZSA9IHZhbHVlUGFydHNbMl07XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiY29sb3J2YWx1ZV9yZ2JcIjtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmhhc0RpcmVjdFJHQiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVBhcnRzLmxlbmd0aCA9PT0gNCAmJiBjb2xvclNwYWNlID09PSBcIkNNWUtcIikge1xuICAgICAgICAgICAgLy8gQ01ZSyBDb2xvclZhbHVlOiBcIjAgMCAwIDEwMFwiIC0+IEM6MCBNOjAgWTowIEs6MTAwXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYCAgIOKchSBVc2luZyBDTVlLIENvbG9yVmFsdWU6IEM6JHt2YWx1ZVBhcnRzWzBdfSBNOiR7dmFsdWVQYXJ0c1sxXX0gWToke3ZhbHVlUGFydHNbMl19IEs6JHt2YWx1ZVBhcnRzWzNdfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jeWFuID0gdmFsdWVQYXJ0c1swXTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLm1hZ2VudGEgPSB2YWx1ZVBhcnRzWzFdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEueWVsbG93ID0gdmFsdWVQYXJ0c1syXTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmJsYWNrID0gdmFsdWVQYXJ0c1szXTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlID0gXCJjb2xvcnZhbHVlX2NteWtcIjtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmhhc0RpcmVjdENNWUsgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVQYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSBSR0IgaWYgc3BhY2UgaXMgdW5rbm93biBidXQgd2UgaGF2ZSAzIHZhbHVlc1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIGAgICDimqDvuI8gIEFzc3VtaW5nIFJHQiBmb3IgMy12YWx1ZSBDb2xvclZhbHVlOiBSOiR7dmFsdWVQYXJ0c1swXX0gRzoke3ZhbHVlUGFydHNbMV19IEI6JHt2YWx1ZVBhcnRzWzJdfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5yZWQgPSB2YWx1ZVBhcnRzWzBdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuZ3JlZW4gPSB2YWx1ZVBhcnRzWzFdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuYmx1ZSA9IHZhbHVlUGFydHNbMl07XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5zcGFjZSA9IFwiUkdCXCI7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiY29sb3J2YWx1ZV9hc3N1bWVkX3JnYlwiO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuaGFzRGlyZWN0UkdCID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlUGFydHMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgQ01ZSyBpZiBzcGFjZSBpcyB1bmtub3duIGJ1dCB3ZSBoYXZlIDQgdmFsdWVzXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYCAgIOKaoO+4jyAgQXNzdW1pbmcgQ01ZSyBmb3IgNC12YWx1ZSBDb2xvclZhbHVlOiBDOiR7dmFsdWVQYXJ0c1swXX0gTToke3ZhbHVlUGFydHNbMV19IFk6JHt2YWx1ZVBhcnRzWzJdfSBLOiR7dmFsdWVQYXJ0c1szXX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuY3lhbiA9IHZhbHVlUGFydHNbMF07XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5tYWdlbnRhID0gdmFsdWVQYXJ0c1sxXTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLnllbGxvdyA9IHZhbHVlUGFydHNbMl07XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5ibGFjayA9IHZhbHVlUGFydHNbM107XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5zcGFjZSA9IFwiQ01ZS1wiO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImNvbG9ydmFsdWVfYXNzdW1lZF9jbXlrXCI7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RDTVlLID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIGAgICDimqDvuI8gIENvdWxkIG5vdCBwYXJzZSBDb2xvclZhbHVlOiBcIiR7Y29sb3JWYWx1ZX1cIiAoJHt2YWx1ZVBhcnRzLmxlbmd0aH0gcGFydHMpYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlID0gXCJjb2xvcnZhbHVlX3VucGFyc2VhYmxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU1RSQVRFR1kgNDogSGFuZGxlIHNwZWNpYWwgY29sb3IgdHlwZXMgKGZhbGxiYWNrKVxuICAgICAgICBpZiAoZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPT09IFwidW5rbm93blwiKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgICAg8J+UhCBVc2luZyBmYWxsYmFjayBoYW5kbGluZyBmb3IgY29sb3I6ICR7Y29sb3JbXCJAX1NlbGZcIl19YFxuICAgICAgICAgICk7XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImZhbGxiYWNrXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSB0aGUgY29sb3IgZGF0YVxuICAgICAgICB0aGlzLnJlc291cmNlcy5jb2xvcnNbY29sb3JbXCJAX1NlbGZcIl1dID0gZmluYWxDb2xvckRhdGE7XG5cbiAgICAgICAgY29uc29sZS5sb2coYCAgIPCfkr4gU3RvcmVkIGNvbG9yIGRhdGE6YCwge1xuICAgICAgICAgIHNlbGY6IGZpbmFsQ29sb3JEYXRhLnNlbGYsXG4gICAgICAgICAgc291cmNlOiBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSxcbiAgICAgICAgICBoYXNSR0I6IGZpbmFsQ29sb3JEYXRhLmhhc0RpcmVjdFJHQixcbiAgICAgICAgICBoYXNDTVlLOiBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RDTVlLLFxuICAgICAgICAgIHJnYjogYCR7ZmluYWxDb2xvckRhdGEucmVkfSwke2ZpbmFsQ29sb3JEYXRhLmdyZWVufSwke2ZpbmFsQ29sb3JEYXRhLmJsdWV9YCxcbiAgICAgICAgICBjbXlrOiBgJHtmaW5hbENvbG9yRGF0YS5jeWFufSwke2ZpbmFsQ29sb3JEYXRhLm1hZ2VudGF9LCR7ZmluYWxDb2xvckRhdGEueWVsbG93fSwke2ZpbmFsQ29sb3JEYXRhLmJsYWNrfWAsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBHcmFkaWVudHNcbiAgICBpZiAoZ3JhcGhpY3MuR3JhZGllbnQpIHtcbiAgICAgIGNvbnN0IGdyYWRpZW50cyA9IEFycmF5LmlzQXJyYXkoZ3JhcGhpY3MuR3JhZGllbnQpXG4gICAgICAgID8gZ3JhcGhpY3MuR3JhZGllbnRcbiAgICAgICAgOiBbZ3JhcGhpY3MuR3JhZGllbnRdO1xuXG4gICAgICBncmFkaWVudHMuZm9yRWFjaCgoZ3JhZGllbnQpID0+IHtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZ3JhZGllbnRzW2dyYWRpZW50W1wiQF9TZWxmXCJdXSA9IHtcbiAgICAgICAgICBzZWxmOiBncmFkaWVudFtcIkBfU2VsZlwiXSxcbiAgICAgICAgICBuYW1lOiBncmFkaWVudFtcIkBfTmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgIHR5cGU6IGdyYWRpZW50W1wiQF9UeXBlXCJdIHx8IFwiTGluZWFyXCIsXG4gICAgICAgICAgZ3JhZGllbnRTdG9wczogdGhpcy5leHRyYWN0R3JhZGllbnRTdG9wcyhncmFkaWVudCksXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGDinIUgR3JhcGhpY3MgZXh0cmFjdGlvbiBjb21wbGV0ZS4gQ29sb3JzOiAke1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnJlc291cmNlcy5jb2xvcnMpLmxlbmd0aFxuICAgICAgfSwgR3JhZGllbnRzOiAke09iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmdyYWRpZW50cykubGVuZ3RofWBcbiAgICApO1xuICB9XG5cbiAgZXh0cmFjdEdyYWRpZW50U3RvcHMoZ3JhZGllbnQpIHtcbiAgICBjb25zdCBzdG9wcyA9IFtdO1xuXG4gICAgaWYgKGdyYWRpZW50LkdyYWRpZW50U3RvcCkge1xuICAgICAgY29uc3Qgc3RvcExpc3QgPSBBcnJheS5pc0FycmF5KGdyYWRpZW50LkdyYWRpZW50U3RvcClcbiAgICAgICAgPyBncmFkaWVudC5HcmFkaWVudFN0b3BcbiAgICAgICAgOiBbZ3JhZGllbnQuR3JhZGllbnRTdG9wXTtcblxuICAgICAgc3RvcExpc3QuZm9yRWFjaCgoc3RvcCkgPT4ge1xuICAgICAgICBzdG9wcy5wdXNoKHtcbiAgICAgICAgICBzZWxmOiBzdG9wW1wiQF9TZWxmXCJdLFxuICAgICAgICAgIHN0b3BDb2xvcjogc3RvcFtcIkBfU3RvcENvbG9yXCJdIHx8IFwiXCIsXG4gICAgICAgICAgbG9jYXRpb246IHBhcnNlRmxvYXQoc3RvcFtcIkBfTG9jYXRpb25cIl0pIHx8IDAsXG4gICAgICAgICAgbWlkcG9pbnQ6IHBhcnNlRmxvYXQoc3RvcFtcIkBfTWlkcG9pbnRcIl0pIHx8IDUwLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdG9wcztcbiAgfVxuXG4gIGFzeW5jIGV4dHJhY3RQcmVmZXJlbmNlcyhwcmVmZXJlbmNlc0RhdGEpIHtcbiAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3RpbmcgZG9jdW1lbnQgcHJlZmVyZW5jZXMuLi5cIik7XG5cbiAgICBjb25zdCBwcmVmcyA9IHByZWZlcmVuY2VzRGF0YS5QcmVmZXJlbmNlcyB8fCBwcmVmZXJlbmNlc0RhdGE7XG5cbiAgICAvLyBFeHRyYWN0IHZhcmlvdXMgZG9jdW1lbnQgcHJlZmVyZW5jZXNcbiAgICB0aGlzLmRvY3VtZW50SW5mbyA9IHtcbiAgICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGRvY3VtZW50UHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdERvY3VtZW50UHJlZnMoXG4gICAgICAgICAgcHJlZnMuRG9jdW1lbnRQcmVmZXJlbmNlXG4gICAgICAgICksXG4gICAgICAgIHZpZXdQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0Vmlld1ByZWZzKHByZWZzLlZpZXdQcmVmZXJlbmNlKSxcbiAgICAgICAgZ3VpZGVQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0R3VpZGVQcmVmcyhwcmVmcy5HdWlkZVByZWZlcmVuY2UpLFxuICAgICAgICBncmlkUHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdEdyaWRQcmVmcyhwcmVmcy5HcmlkUHJlZmVyZW5jZSksXG4gICAgICAgIG1hcmdpblByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RNYXJnaW5QcmVmcyhwcmVmcy5NYXJnaW5QcmVmZXJlbmNlKSxcbiAgICAgICAgY29sdW1uUHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdENvbHVtblByZWZzKHByZWZzLkNvbHVtblByZWZlcmVuY2UpLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdERvY3VtZW50UHJlZnMoZG9jUHJlZikge1xuICAgIGlmICghZG9jUHJlZikgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VXaWR0aDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9QYWdlV2lkdGhcIl0pIHx8IDAsXG4gICAgICBwYWdlSGVpZ2h0OiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX1BhZ2VIZWlnaHRcIl0pIHx8IDAsXG4gICAgICBsZWZ0OiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0xlZnRcIl0pIHx8IDAsXG4gICAgICB0b3A6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfVG9wXCJdKSB8fCAwLFxuICAgICAgcmlnaHQ6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfUmlnaHRcIl0pIHx8IDAsXG4gICAgICBib3R0b206IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfQm90dG9tXCJdKSB8fCAwLFxuICAgICAgY29sdW1uQ291bnQ6IHBhcnNlSW50KGRvY1ByZWZbXCJAX0NvbHVtbkNvdW50XCJdKSB8fCAxLFxuICAgICAgY29sdW1uR3V0dGVyOiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0NvbHVtbkd1dHRlclwiXSkgfHwgMCxcbiAgICAgIGZhY2luZ1BhZ2VzOiBkb2NQcmVmW1wiQF9GYWNpbmdQYWdlc1wiXSA9PT0gdHJ1ZSxcbiAgICAgIGFsbG93UGFnZVNodWZmbGU6IGRvY1ByZWZbXCJAX0FsbG93UGFnZVNodWZmbGVcIl0gIT09IGZhbHNlLFxuICAgICAgc2x1Z0JsZWVkVHlwZTogZG9jUHJlZltcIkBfU2x1Z0JsZWVkVHlwZVwiXSB8fCBcIk5vbmVcIixcbiAgICAgIGRvY3VtZW50QmxlZWRUb3BPZmZzZXQ6XG4gICAgICAgIHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfRG9jdW1lbnRCbGVlZFRvcE9mZnNldFwiXSkgfHwgMCxcbiAgICAgIGRvY3VtZW50QmxlZWRCb3R0b21PZmZzZXQ6XG4gICAgICAgIHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfRG9jdW1lbnRCbGVlZEJvdHRvbU9mZnNldFwiXSkgfHwgMCxcbiAgICAgIGRvY3VtZW50QmxlZWRJbnNpZGVPckxlZnRPZmZzZXQ6XG4gICAgICAgIHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfRG9jdW1lbnRCbGVlZEluc2lkZU9yTGVmdE9mZnNldFwiXSkgfHwgMCxcbiAgICAgIGRvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldDpcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkT3V0c2lkZU9yUmlnaHRPZmZzZXRcIl0pIHx8IDAsXG4gICAgfTtcbiAgfVxuXG4gIGV4dHJhY3RWaWV3UHJlZnModmlld1ByZWYpIHtcbiAgICBpZiAoIXZpZXdQcmVmKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHM6XG4gICAgICAgIHZpZXdQcmVmW1wiQF9Ib3Jpem9udGFsTWVhc3VyZW1lbnRVbml0c1wiXSB8fCBcIlBvaW50c1wiLFxuICAgICAgdmVydGljYWxNZWFzdXJlbWVudFVuaXRzOlxuICAgICAgICB2aWV3UHJlZltcIkBfVmVydGljYWxNZWFzdXJlbWVudFVuaXRzXCJdIHx8IFwiUG9pbnRzXCIsXG4gICAgICBydWxlck9yaWdpbjogdmlld1ByZWZbXCJAX1J1bGVyT3JpZ2luXCJdIHx8IFwiU3ByZWFkT3JpZ2luXCIsXG4gICAgICBzaG93UnVsZXJzOiB2aWV3UHJlZltcIkBfU2hvd1J1bGVyc1wiXSAhPT0gZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGV4dHJhY3RHdWlkZVByZWZzKGd1aWRlUHJlZikge1xuICAgIGlmICghZ3VpZGVQcmVmKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgcnVsZXJHdWlkZUNvbG9yOiBndWlkZVByZWZbXCJAX1J1bGVyR3VpZGVDb2xvclwiXSB8fCBcIkdyZWVuXCIsXG4gICAgICBndWlkZXNJbkJhY2s6IGd1aWRlUHJlZltcIkBfR3VpZGVzSW5CYWNrXCJdID09PSB0cnVlLFxuICAgICAgZ3VpZGVzTG9ja2VkOiBndWlkZVByZWZbXCJAX0d1aWRlc0xvY2tlZFwiXSA9PT0gdHJ1ZSxcbiAgICAgIGd1aWRlc1Nob3duOiBndWlkZVByZWZbXCJAX0d1aWRlc1Nob3duXCJdICE9PSBmYWxzZSxcbiAgICAgIGd1aWRlc1NuYXB0bzogZ3VpZGVQcmVmW1wiQF9HdWlkZXNTbmFwdG9cIl0gIT09IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICBleHRyYWN0R3JpZFByZWZzKGdyaWRQcmVmKSB7XG4gICAgaWYgKCFncmlkUHJlZikgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VsaW5lU3RhcnQ6IHBhcnNlRmxvYXQoZ3JpZFByZWZbXCJAX0Jhc2VsaW5lU3RhcnRcIl0pIHx8IDAsXG4gICAgICBiYXNlbGluZURpdmlzaW9uOiBwYXJzZUZsb2F0KGdyaWRQcmVmW1wiQF9CYXNlbGluZURpdmlzaW9uXCJdKSB8fCAxMixcbiAgICAgIGJhc2VsaW5lU2hvd246IGdyaWRQcmVmW1wiQF9CYXNlbGluZVNob3duXCJdID09PSB0cnVlLFxuICAgICAgYmFzZWxpbmVTbmFwdG86IGdyaWRQcmVmW1wiQF9CYXNlbGluZVNuYXB0b1wiXSA9PT0gdHJ1ZSxcbiAgICAgIGRvY3VtZW50R3JpZFNob3duOiBncmlkUHJlZltcIkBfRG9jdW1lbnRHcmlkU2hvd25cIl0gPT09IHRydWUsXG4gICAgICBkb2N1bWVudEdyaWRTbmFwdG86IGdyaWRQcmVmW1wiQF9Eb2N1bWVudEdyaWRTbmFwdG9cIl0gPT09IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIGV4dHJhY3RNYXJnaW5QcmVmcyhtYXJnaW5QcmVmKSB7XG4gICAgaWYgKCFtYXJnaW5QcmVmKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX1RvcFwiXSkgfHwgMCxcbiAgICAgIGJvdHRvbTogcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9Cb3R0b21cIl0pIHx8IDAsXG4gICAgICBsZWZ0OiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX0xlZnRcIl0pIHx8IDAsXG4gICAgICByaWdodDogcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9SaWdodFwiXSkgfHwgMCxcbiAgICAgIGNvbHVtbkNvdW50OiBwYXJzZUludChtYXJnaW5QcmVmW1wiQF9Db2x1bW5Db3VudFwiXSkgfHwgMSxcbiAgICAgIGNvbHVtbkd1dHRlcjogcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9Db2x1bW5HdXR0ZXJcIl0pIHx8IDAsXG4gICAgfTtcbiAgfVxuXG4gIGV4dHJhY3RDb2x1bW5QcmVmcyhjb2x1bW5QcmVmKSB7XG4gICAgaWYgKCFjb2x1bW5QcmVmKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dENvbHVtbkNvdW50OiBwYXJzZUludChjb2x1bW5QcmVmW1wiQF9UZXh0Q29sdW1uQ291bnRcIl0pIHx8IDEsXG4gICAgICB0ZXh0Q29sdW1uR3V0dGVyOiBwYXJzZUZsb2F0KGNvbHVtblByZWZbXCJAX1RleHRDb2x1bW5HdXR0ZXJcIl0pIHx8IDAsXG4gICAgfTtcbiAgfVxuXG4gIHJlc29sdmVTdHlsZUZvcm1hdHRpbmcoZm9ybWF0dGluZykge1xuICAgIGNvbnN0IHJlc29sdmVkID0geyAuLi5mb3JtYXR0aW5nIH07XG5cbiAgICAvLyBERUJVRzogQ2hlY2sgaWYgZm9ybWF0dGluZyBpcyBiZWluZyBhcHBsaWVkIChnZW5lcmljIGNoZWNrKVxuICAgIGNvbnN0IGhhc0FueUZvcm1hdHRpbmcgPVxuICAgICAgZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSB8fFxuICAgICAgZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZSB8fFxuICAgICAgZm9ybWF0dGluZy5mb250U3R5bGUgfHxcbiAgICAgIGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSB8fFxuICAgICAgZm9ybWF0dGluZy5mb250U2l6ZTtcblxuICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCflKcgU3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyAtIElucHV0OlwiLCB7XG4gICAgICAgIHBhcmFncmFwaFN0eWxlOiBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlLFxuICAgICAgICBjaGFyYWN0ZXJTdHlsZTogZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZSxcbiAgICAgICAgZGlyZWN0Rm9udFN0eWxlOiBmb3JtYXR0aW5nLmZvbnRTdHlsZSxcbiAgICAgICAgZGlyZWN0Rm9udFJlZjogZm9ybWF0dGluZy5mb250UmVmZXJlbmNlLFxuICAgICAgICBkaXJlY3RGb250U2l6ZTogZm9ybWF0dGluZy5mb250U2l6ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlc29sdmUgcGFyYWdyYXBoIHN0eWxlIChiYXNlIGxheWVyKVxuICAgIGlmIChcbiAgICAgIGZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGUgJiZcbiAgICAgIHRoaXMuc3R5bGVzLnBhcmFncmFwaFtmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlXVxuICAgICkge1xuICAgICAgY29uc3QgcFN0eWxlID0gdGhpcy5zdHlsZXMucGFyYWdyYXBoW2Zvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVdO1xuXG4gICAgICBpZiAoIXJlc29sdmVkLmZvbnRTaXplICYmIHBTdHlsZS5wb2ludFNpemUpXG4gICAgICAgIHJlc29sdmVkLmZvbnRTaXplID0gcFN0eWxlLnBvaW50U2l6ZTtcbiAgICAgIGlmICghcmVzb2x2ZWQuZmlsbENvbG9yICYmIHBTdHlsZS5maWxsQ29sb3IpXG4gICAgICAgIHJlc29sdmVkLmZpbGxDb2xvciA9IHBTdHlsZS5maWxsQ29sb3I7XG4gICAgICAvLyBDUklUSUNBTCBGSVg6IEFsd2F5cyBpbmhlcml0IHBhcmFncmFwaCBhbGlnbm1lbnQgdW5sZXNzIGV4cGxpY2l0bHkgb3ZlcnJpZGRlblxuICAgICAgaWYgKHBTdHlsZS5hbGlnbm1lbnQpIHJlc29sdmVkLmFsaWdubWVudCA9IHBTdHlsZS5hbGlnbm1lbnQ7XG4gICAgICBpZiAoIXJlc29sdmVkLmZvbnRTdHlsZSAmJiBwU3R5bGUuZm9udFN0eWxlKSB7XG4gICAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IHBTdHlsZS5mb250U3R5bGU7XG4gICAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgICAgRm9udFN0eWxlIGZyb20gcGFyYWdyYXBoIHN0eWxlOiBcIiR7cFN0eWxlLmZvbnRTdHlsZX1cImBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENSSVRJQ0FMOiBSZXNvbHZlIGZvbnQgZnJvbSBwYXJhZ3JhcGggc3R5bGVcbiAgICAgIGlmICghcmVzb2x2ZWQuZm9udEZhbWlseSAmJiBwU3R5bGUuYXBwbGllZEZvbnQpIHtcbiAgICAgICAgcmVzb2x2ZWQuZm9udEZhbWlseSA9IHRoaXMucmVzb2x2ZUZvbnRSZWZlcmVuY2UocFN0eWxlLmFwcGxpZWRGb250KTtcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGAgICBGb250IGZyb20gcGFyYWdyYXBoIHN0eWxlOiAke3BTdHlsZS5hcHBsaWVkRm9udH0gLT4gJHtyZXNvbHZlZC5mb250RmFtaWx5fWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBvdGhlciBwYXJhZ3JhcGggcHJvcGVydGllcyB3aXRoIGVuaGFuY2VkIGxlYWRpbmcgc3VwcG9ydFxuICAgICAgcmVzb2x2ZWQubGVhZGluZyA9IHBTdHlsZS5sZWFkaW5nO1xuICAgICAgcmVzb2x2ZWQubGVhZGluZ1R5cGUgPSBwU3R5bGUubGVhZGluZ1R5cGU7XG4gICAgICByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gcFN0eWxlLmVmZmVjdGl2ZUxpbmVIZWlnaHQ7XG4gICAgICByZXNvbHZlZC5sZWZ0SW5kZW50ID0gcFN0eWxlLmxlZnRJbmRlbnQ7XG4gICAgICByZXNvbHZlZC5yaWdodEluZGVudCA9IHBTdHlsZS5yaWdodEluZGVudDtcbiAgICAgIHJlc29sdmVkLmZpcnN0TGluZUluZGVudCA9IHBTdHlsZS5maXJzdExpbmVJbmRlbnQ7XG4gICAgICByZXNvbHZlZC5zcGFjZUJlZm9yZSA9IHBTdHlsZS5zcGFjZUJlZm9yZTtcbiAgICAgIHJlc29sdmVkLnNwYWNlQWZ0ZXIgPSBwU3R5bGUuc3BhY2VBZnRlcjtcbiAgICAgIHJlc29sdmVkLnRyYWNraW5nID0gcFN0eWxlLnRyYWNraW5nO1xuICAgICAgcmVzb2x2ZWQua2VybmluZyA9IHBTdHlsZS5rZXJuaW5nO1xuICAgIH1cblxuICAgIC8vIFJlc29sdmUgY2hhcmFjdGVyIHN0eWxlIChvdmVycmlkZSBsYXllcilcbiAgICBpZiAoXG4gICAgICBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlICYmXG4gICAgICB0aGlzLnN0eWxlcy5jaGFyYWN0ZXJbZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZV1cbiAgICApIHtcbiAgICAgIGNvbnN0IGNTdHlsZSA9IHRoaXMuc3R5bGVzLmNoYXJhY3Rlcltmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlXTtcblxuICAgICAgaWYgKGNTdHlsZS5wb2ludFNpemUpIHJlc29sdmVkLmZvbnRTaXplID0gY1N0eWxlLnBvaW50U2l6ZTtcbiAgICAgIGlmIChjU3R5bGUuZmlsbENvbG9yKSByZXNvbHZlZC5maWxsQ29sb3IgPSBjU3R5bGUuZmlsbENvbG9yO1xuICAgICAgaWYgKGNTdHlsZS5mb250U3R5bGUpIHtcbiAgICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gY1N0eWxlLmZvbnRTdHlsZTtcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGAgICBGb250U3R5bGUgZnJvbSBjaGFyYWN0ZXIgc3R5bGU6IFwiJHtjU3R5bGUuZm9udFN0eWxlfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjU3R5bGUuc3Ryb2tlQ29sb3IpIHJlc29sdmVkLnN0cm9rZUNvbG9yID0gY1N0eWxlLnN0cm9rZUNvbG9yO1xuXG4gICAgICAvLyBJbmNsdWRlIGxlYWRpbmcgaW5mb3JtYXRpb24gZnJvbSBjaGFyYWN0ZXIgc3R5bGVcbiAgICAgIGlmIChjU3R5bGUubGVhZGluZykgcmVzb2x2ZWQubGVhZGluZyA9IGNTdHlsZS5sZWFkaW5nO1xuICAgICAgaWYgKGNTdHlsZS5sZWFkaW5nVHlwZSkgcmVzb2x2ZWQubGVhZGluZ1R5cGUgPSBjU3R5bGUubGVhZGluZ1R5cGU7XG4gICAgICBpZiAoY1N0eWxlLmVmZmVjdGl2ZUxpbmVIZWlnaHQpXG4gICAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSBjU3R5bGUuZWZmZWN0aXZlTGluZUhlaWdodDtcblxuICAgICAgLy8gQ1JJVElDQUw6IENoYXJhY3RlciBzdHlsZSBmb250IG92ZXJyaWRlcyBwYXJhZ3JhcGggc3R5bGVcbiAgICAgIGlmIChjU3R5bGUuYXBwbGllZEZvbnQpIHtcbiAgICAgICAgcmVzb2x2ZWQuZm9udEZhbWlseSA9IHRoaXMucmVzb2x2ZUZvbnRSZWZlcmVuY2UoY1N0eWxlLmFwcGxpZWRGb250KTtcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGAgICBGb250IGZyb20gY2hhcmFjdGVyIHN0eWxlOiAke2NTdHlsZS5hcHBsaWVkRm9udH0gLT4gJHtyZXNvbHZlZC5mb250RmFtaWx5fWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgZGlyZWN0IGZvcm1hdHRpbmcgKGhpZ2hlc3QgcHJpb3JpdHkpXG4gICAgaWYgKGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSkge1xuICAgICAgcmVzb2x2ZWQuZm9udEZhbWlseSA9IHRoaXMucmVzb2x2ZUZvbnRSZWZlcmVuY2UoZm9ybWF0dGluZy5mb250UmVmZXJlbmNlKTtcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgICBGb250IGZyb20gZGlyZWN0IGZvcm1hdHRpbmc6ICR7Zm9ybWF0dGluZy5mb250UmVmZXJlbmNlfSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENSSVRJQ0FMOiBBcHBseSBkaXJlY3QgZm9udFN0eWxlIGlmIHByb3ZpZGVkICh0aGlzIG1pZ2h0IGJlIHRoZSBpc3N1ZSlcbiAgICBpZiAoZm9ybWF0dGluZy5mb250U3R5bGUpIHtcbiAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IGZvcm1hdHRpbmcuZm9udFN0eWxlO1xuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYCAgIEZvbnRTdHlsZSBmcm9tIGRpcmVjdCBmb3JtYXR0aW5nOiBcIiR7Zm9ybWF0dGluZy5mb250U3R5bGV9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgZGlyZWN0IGxlYWRpbmcgaW5mb3JtYXRpb24gKGhpZ2hlc3QgcHJpb3JpdHkpXG4gICAgaWYgKGZvcm1hdHRpbmcubGVhZGluZyAhPT0gdW5kZWZpbmVkKSByZXNvbHZlZC5sZWFkaW5nID0gZm9ybWF0dGluZy5sZWFkaW5nO1xuICAgIGlmIChmb3JtYXR0aW5nLmxlYWRpbmdUeXBlKSByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IGZvcm1hdHRpbmcubGVhZGluZ1R5cGU7XG4gICAgaWYgKGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodClcbiAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSBmb3JtYXR0aW5nLmVmZmVjdGl2ZUxpbmVIZWlnaHQ7XG5cbiAgICAvLyBBcHBseSBvdGhlciBkaXJlY3QgZm9ybWF0dGluZyBhdHRyaWJ1dGVzXG4gICAgaWYgKGZvcm1hdHRpbmcuZm9udFNpemUpIHJlc29sdmVkLmZvbnRTaXplID0gZm9ybWF0dGluZy5mb250U2l6ZTtcbiAgICBpZiAoZm9ybWF0dGluZy50cmFja2luZykgcmVzb2x2ZWQudHJhY2tpbmcgPSBmb3JtYXR0aW5nLnRyYWNraW5nO1xuICAgIGlmIChmb3JtYXR0aW5nLmtlcm5pbmcpIHJlc29sdmVkLmtlcm5pbmcgPSBmb3JtYXR0aW5nLmtlcm5pbmc7XG5cbiAgICAvLyBDUklUSUNBTCBGSVg6IEFwcGx5IGRpcmVjdCBhbGlnbm1lbnQgaWYgZXhwbGljaXRseSBzcGVjaWZpZWQgKG92ZXJyaWRlcyBwYXJhZ3JhcGggYWxpZ25tZW50KVxuICAgIGlmIChmb3JtYXR0aW5nLmFsaWdubWVudCkge1xuICAgICAgcmVzb2x2ZWQuYWxpZ25tZW50ID0gZm9ybWF0dGluZy5hbGlnbm1lbnQ7XG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgICAgQWxpZ25tZW50IGZyb20gZGlyZWN0IGZvcm1hdHRpbmc6IFwiJHtmb3JtYXR0aW5nLmFsaWdubWVudH1cImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGSVhFRDogRW5zdXJlIGZvbnRTdHlsZSBkZWZhdWx0cyB0byBSZWd1bGFyL25vcm1hbCBpZiBub3Qgc2V0XG4gICAgaWYgKCFyZXNvbHZlZC5mb250U3R5bGUgfHwgcmVzb2x2ZWQuZm9udFN0eWxlID09PSBcIlwiKSB7XG4gICAgICByZXNvbHZlZC5mb250U3R5bGUgPSBcIlJlZ3VsYXJcIjtcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBGb250U3R5bGUgZGVmYXVsdGVkIHRvOiBcIlJlZ3VsYXJcImApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFERElUSU9OQUwgRklYOiBJZiBubyBzdHlsZXMgd2VyZSBhcHBsaWVkIGZyb20gYW55IHNvdXJjZSwgZW5zdXJlIGNsZWFuIGRlZmF1bHRzXG4gICAgaWYgKFxuICAgICAgIWZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGUgJiZcbiAgICAgICFmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlICYmXG4gICAgICAhZm9ybWF0dGluZy5mb250U3R5bGUgJiZcbiAgICAgICFmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2VcbiAgICApIHtcbiAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IFwiUmVndWxhclwiO1xuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIE5vIHNvdXJjZSBzdHlsZXMgZm91bmQgLSBlbnN1cmluZyBjbGVhbiBkZWZhdWx0c2ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmFsIGZhbGxiYWNrXG4gICAgaWYgKCFyZXNvbHZlZC5mb250RmFtaWx5IHx8IHJlc29sdmVkLmZvbnRGYW1pbHkgPT09IFwiXCIpIHtcbiAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLmdldERlZmF1bHRGb250KCk7XG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhgICAgVXNpbmcgZmFsbGJhY2sgZm9udDogJHtyZXNvbHZlZC5mb250RmFtaWx5fWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVuc3VyZSBsaW5lIGhlaWdodCBpcyBjYWxjdWxhdGVkIGlmIG5vdCBleHBsaWNpdGx5IHNldFxuICAgIGlmIChcbiAgICAgICFyZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ICYmXG4gICAgICByZXNvbHZlZC5mb250U2l6ZSAmJlxuICAgICAgcmVzb2x2ZWQubGVhZGluZ1xuICAgICkge1xuICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IHRoaXMuY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChcbiAgICAgICAgcmVzb2x2ZWQubGVhZGluZyxcbiAgICAgICAgcmVzb2x2ZWQuZm9udFNpemVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBTdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nIC0gRmluYWwgT3V0cHV0OlwiLCB7XG4gICAgICAgIGZvbnRTaXplOiByZXNvbHZlZC5mb250U2l6ZSxcbiAgICAgICAgZm9udEZhbWlseTogcmVzb2x2ZWQuZm9udEZhbWlseSxcbiAgICAgICAgZm9udFN0eWxlOiByZXNvbHZlZC5mb250U3R5bGUsXG4gICAgICAgIGZpbGxDb2xvcjogcmVzb2x2ZWQuZmlsbENvbG9yLFxuICAgICAgICBsZWFkaW5nOiByZXNvbHZlZC5sZWFkaW5nLFxuICAgICAgICBlZmZlY3RpdmVMaW5lSGVpZ2h0OiByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc29sdmVkO1xuICB9XG5cbiAgcmVzb2x2ZUZvbnRSZWZlcmVuY2UoZm9udFJlZikge1xuICAgIGlmICghZm9udFJlZiB8fCBmb250UmVmID09PSBcIlwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkVtcHR5IGZvbnQgcmVmZXJlbmNlLCB1c2luZyBmYWxsYmFja1wiKTtcbiAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRGb250KCk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IGRpcmVjdCBsb29rdXAgaW4gZm9udCBtYXBcbiAgICBpZiAodGhpcy5mb250TWFwICYmIHRoaXMuZm9udE1hcC5oYXMoZm9udFJlZikpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkRm9udCA9IHRoaXMuZm9udE1hcC5nZXQoZm9udFJlZik7XG4gICAgICBjb25zb2xlLmxvZyhgRm9udCByZXNvbHZlZDogXCIke2ZvbnRSZWZ9XCIgLT4gXCIke3Jlc29sdmVkRm9udH1cImApO1xuICAgICAgcmV0dXJuIHJlc29sdmVkRm9udDtcbiAgICB9XG5cbiAgICAvLyBUcnkgcGFydGlhbCBtYXRjaGluZyBmb3IgZm9udCBmYW1pbGllc1xuICAgIGlmICh0aGlzLnJlc291cmNlcy5mb250cykge1xuICAgICAgZm9yIChjb25zdCBbZmFtaWx5SWQsIGZhbWlseUluZm9dIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgICB0aGlzLnJlc291cmNlcy5mb250c1xuICAgICAgKSkge1xuICAgICAgICAvLyBDaGVjayBmYW1pbHkgbmFtZSBtYXRjaFxuICAgICAgICBpZiAoXG4gICAgICAgICAgZmFtaWx5SW5mby5uYW1lICYmXG4gICAgICAgICAgKGZhbWlseUluZm8ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZvbnRSZWYudG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgICAgICAgIGZvbnRSZWYudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmYW1pbHlJbmZvLm5hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYEZvbnQgcGFydGlhbGx5IG1hdGNoZWQ6IFwiJHtmb250UmVmfVwiIC0+IFwiJHtmYW1pbHlJbmZvLm5hbWV9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZmFtaWx5SW5mby5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaW5kaXZpZHVhbCBmb250IG1hdGNoZXNcbiAgICAgICAgaWYgKGZhbWlseUluZm8uZm9udHMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZvbnQgb2YgZmFtaWx5SW5mby5mb250cykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBmb250LnNlbGYgPT09IGZvbnRSZWYgfHxcbiAgICAgICAgICAgICAgZm9udC5wb3N0U2NyaXB0TmFtZSA9PT0gZm9udFJlZiB8fFxuICAgICAgICAgICAgICBmb250Lm5hbWUgPT09IGZvbnRSZWZcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBgRm9udCBleGFjdGx5IG1hdGNoZWQ6IFwiJHtmb250UmVmfVwiIC0+IFwiJHtmYW1pbHlJbmZvLm5hbWV9XCJgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBmYW1pbHlJbmZvLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYEZvbnQgbm90IGZvdW5kOiBcIiR7Zm9udFJlZn1cIiwgdXNpbmcgZmFsbGJhY2tgKTtcbiAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0Rm9udCgpIHx8IGZvbnRSZWY7XG4gIH1cblxuICBnZXREZWZhdWx0Rm9udCgpIHtcbiAgICBpZiAodGhpcy5yZXNvdXJjZXMuZm9udHMgJiYgT2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuZm9udHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0RmFtaWx5ID0gT2JqZWN0LnZhbHVlcyh0aGlzLnJlc291cmNlcy5mb250cylbMF07XG4gICAgICByZXR1cm4gZmlyc3RGYW1pbHkubmFtZSB8fCBcIkFyaWFsXCI7XG4gICAgfVxuICAgIHJldHVybiBcIkFyaWFsXCI7XG4gIH1cblxuICBpbmZlckZvbnRGcm9tQ29udGV4dCgpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGZvbnQgZGVmaW5pdGlvbnMgYnV0IG5vIGV4cGxpY2l0IHJlZmVyZW5jZXMsXG4gICAgLy8gcmV0dXJuIHRoZSBmaXJzdCBhdmFpbGFibGUgZm9udCBhcyBhIGZhbGxiYWNrXG4gICAgaWYgKHRoaXMucmVzb3VyY2VzLmZvbnRzICYmIE9iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmaXJzdEZvbnRGYW1pbHkgPSBPYmplY3QudmFsdWVzKHRoaXMucmVzb3VyY2VzLmZvbnRzKVswXTtcbiAgICAgIHJldHVybiBmaXJzdEZvbnRGYW1pbHkubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRTdG9yeVN0eWxlU3VtbWFyeShzdG9yeSkge1xuICAgIGNvbnN0IHN1bW1hcnkgPSB7XG4gICAgICBmb250U2l6ZTogbnVsbCxcbiAgICAgIGZvbnRGYW1pbHk6IG51bGwsXG4gICAgICBhbGlnbm1lbnQ6IG51bGwsXG4gICAgICBmaWxsQ29sb3I6IG51bGwsXG4gICAgICBmb250U3R5bGU6IG51bGwsXG4gICAgICBsZWFkaW5nOiBudWxsLFxuICAgICAgbGVhZGluZ1R5cGU6IG51bGwsXG4gICAgICBlZmZlY3RpdmVMaW5lSGVpZ2h0OiBudWxsLFxuICAgICAgdHJhY2tpbmc6IG51bGwsXG4gICAgICBrZXJuaW5nOiBudWxsLFxuICAgIH07XG5cbiAgICAvLyBHZXQgdGhlIG1vc3QgY29tbW9uIG9yIGZpcnN0IGZvcm1hdHRpbmcgdmFsdWVzXG4gICAgaWYgKHN0b3J5LmNvbnRlbnQ/LmZvcm1hdHRlZENvbnRlbnQ/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0Rm9ybWF0dGVkID0gc3RvcnkuY29udGVudC5mb3JtYXR0ZWRDb250ZW50LmZpbmQoXG4gICAgICAgIChpdGVtKSA9PiBpdGVtLmZvcm1hdHRpbmcgJiYgIWl0ZW0uZm9ybWF0dGluZy5pc0JyZWFrXG4gICAgICApO1xuXG4gICAgICBpZiAoZmlyc3RGb3JtYXR0ZWQ/LmZvcm1hdHRpbmcpIHtcbiAgICAgICAgY29uc3QgZm10ID0gZmlyc3RGb3JtYXR0ZWQuZm9ybWF0dGluZztcbiAgICAgICAgc3VtbWFyeS5mb250U2l6ZSA9IGZtdC5mb250U2l6ZTtcbiAgICAgICAgc3VtbWFyeS5mb250RmFtaWx5ID0gZm10LmZvbnRGYW1pbHk7XG4gICAgICAgIHN1bW1hcnkuYWxpZ25tZW50ID0gZm10LmFsaWdubWVudDtcbiAgICAgICAgc3VtbWFyeS5maWxsQ29sb3IgPSBmbXQuZmlsbENvbG9yO1xuICAgICAgICBzdW1tYXJ5LmZvbnRTdHlsZSA9IGZtdC5mb250U3R5bGU7XG4gICAgICAgIHN1bW1hcnkubGVhZGluZyA9IGZtdC5sZWFkaW5nO1xuICAgICAgICBzdW1tYXJ5LmxlYWRpbmdUeXBlID0gZm10LmxlYWRpbmdUeXBlO1xuICAgICAgICBzdW1tYXJ5LmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSBmbXQuZWZmZWN0aXZlTGluZUhlaWdodDtcbiAgICAgICAgc3VtbWFyeS50cmFja2luZyA9IGZtdC50cmFja2luZztcbiAgICAgICAgc3VtbWFyeS5rZXJuaW5nID0gZm10Lmtlcm5pbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bW1hcnk7XG4gIH1cblxuICAvLyBORVc6IFByb2Nlc3MgbGVhZGluZyB2YWx1ZXMgd2l0aCBJbkRlc2lnbi1zcGVjaWZpYyBsb2dpYyAoc2hhcmVkIHdpdGggU3RvcnlQYXJzZXIpXG4gIHByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9udFNpemUpIHtcbiAgICBpZiAoIXJhd0xlYWRpbmcpIHJldHVybiBcImF1dG9cIjtcblxuICAgIC8vIEhhbmRsZSBcImF1dG9cIiBsZWFkaW5nXG4gICAgaWYgKHJhd0xlYWRpbmcgPT09IFwiYXV0b1wiIHx8IHJhd0xlYWRpbmcgPT09IFwiQXV0b1wiKSB7XG4gICAgICByZXR1cm4gZm9udFNpemUgPyBmb250U2l6ZSAqIDEuMiA6IFwiYXV0b1wiOyAvLyBJbkRlc2lnbiBkZWZhdWx0IGF1dG8gbGVhZGluZyBpcyAxMjAlXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG51bWVyaWMgbGVhZGluZyAoaW4gcG9pbnRzKVxuICAgIGNvbnN0IG51bWVyaWNMZWFkaW5nID0gcGFyc2VGbG9hdChyYXdMZWFkaW5nKTtcbiAgICBpZiAoIWlzTmFOKG51bWVyaWNMZWFkaW5nKSkge1xuICAgICAgcmV0dXJuIG51bWVyaWNMZWFkaW5nO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwZXJjZW50YWdlLWJhc2VkIGxlYWRpbmdcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KHJhd0xlYWRpbmcucmVwbGFjZShcIiVcIiwgXCJcIikpO1xuICAgICAgcmV0dXJuIGZvbnRTaXplID8gKGZvbnRTaXplICogcGVyY2VudGFnZSkgLyAxMDAgOiBcImF1dG9cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJhdXRvXCI7XG4gIH1cblxuICAvLyBORVc6IERldGVybWluZSB0aGUgdHlwZSBvZiBsZWFkaW5nIGJlaW5nIHVzZWRcbiAgZGV0ZXJtaW5lTGVhZGluZ1R5cGUocmF3TGVhZGluZykge1xuICAgIGlmICghcmF3TGVhZGluZyB8fCByYXdMZWFkaW5nID09PSBcImF1dG9cIiB8fCByYXdMZWFkaW5nID09PSBcIkF1dG9cIikge1xuICAgICAgcmV0dXJuIFwiYXV0b1wiO1xuICAgIH1cblxuICAgIGlmIChyYXdMZWFkaW5nLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgcmV0dXJuIFwicGVyY2VudGFnZVwiO1xuICAgIH1cblxuICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdChyYXdMZWFkaW5nKSkpIHtcbiAgICAgIHJldHVybiBcImFic29sdXRlXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xuICB9XG5cbiAgLy8gTkVXOiBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1MgcmVuZGVyaW5nXG4gIGNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQobGVhZGluZywgZm9udFNpemUpIHtcbiAgICBpZiAobGVhZGluZyA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIHJldHVybiAxLjI7IC8vIENTUyBsaW5lLWhlaWdodCByYXRpbyBmb3IgYXV0b1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbGVhZGluZyA9PT0gXCJudW1iZXJcIiAmJiBmb250U2l6ZSkge1xuICAgICAgLy8gQ29udmVydCBwb2ludHMgdG8gQ1NTIGxpbmUtaGVpZ2h0IHJhdGlvXG4gICAgICByZXR1cm4gTWF0aC5tYXgoMC44LCBsZWFkaW5nIC8gZm9udFNpemUpOyAvLyBFbnN1cmUgbWluaW11bSBsaW5lIGhlaWdodFxuICAgIH1cblxuICAgIHJldHVybiAxLjI7IC8vIEZhbGxiYWNrXG4gIH1cblxuICBnZXRTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzO1xuICB9XG5cbiAgZ2V0UmVzb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc291cmNlcztcbiAgfVxuXG4gIGdldEZvbnRNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9udE1hcDtcbiAgfVxuXG4gIC8vIEFkZCBtZXRob2RzIHRvIHJldHVybiBzdHlsZSBhbmQgZm9udCBkZWZpbml0aW9ucyBmb3IgZGVidWdcbiAgZ2V0UGFyYWdyYXBoU3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlcy5wYXJhZ3JhcGg7XG4gIH1cbiAgZ2V0Q2hhcmFjdGVyU3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlcy5jaGFyYWN0ZXI7XG4gIH1cbiAgZ2V0Rm9udERlZmluaXRpb25zKCkge1xuICAgIC8vIFByZWZlciBwbGFpbiBvYmplY3QgZm9yIGRlYnVnIG91dHB1dFxuICAgIGlmICh0aGlzLnJlc291cmNlcyAmJiB0aGlzLnJlc291cmNlcy5mb250cykge1xuICAgICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzLmZvbnRzO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjazogY29udmVydCBmb250TWFwIHRvIG9iamVjdFxuICAgIGlmICh0aGlzLmZvbnRNYXAgJiYgdHlwZW9mIHRoaXMuZm9udE1hcC5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5mb250TWFwLmVudHJpZXMoKSk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vIEZJWEVEOiBBZGQgbWV0aG9kIHRvIGFjY2VzcyBkb2N1bWVudCBwcmVmZXJlbmNlcyBpbmNsdWRpbmcgVmlld1ByZWZlcmVuY2VzXG4gIGdldERvY3VtZW50SW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudEluZm87XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZVBhcnNlcjtcbiJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIklETUxVdGlscyIsIlN0eWxlUGFyc2VyIiwic2V0RG9jdW1lbnRVbml0cyIsInVuaXRzIiwiZG9jdW1lbnRVbml0cyIsImNvbnNvbGUiLCJsb2ciLCJjb252ZXJ0VHlwb2dyYXBoeVRvUGl4ZWxzIiwidmFsdWUiLCJpc05hTiIsInVuaXRDb252ZXJ0ZXIiLCJpc1N1cHBvcnRlZFVuaXQiLCJjb252ZXJ0ZWRWYWx1ZSIsInRvUGl4ZWxzIiwiY29udmVydFN0eWxlTWVhc3VyZW1lbnRzVG9QaXhlbHMiLCJzdHlsZSIsImNvbnZlcnRlZFN0eWxlIiwibWVhc3VyZW1lbnRGaWVsZHMiLCJmb3JFYWNoIiwiZmllbGQiLCJsZWFkaW5nIiwicGFyc2VSZXNvdXJjZUZpbGUiLCJmaWxlTmFtZSIsImNvbnRlbnQiLCJ4bWxQYXJzZXIiLCJwYXJzZWQiLCJwYXJzZSIsInJlc291cmNlTmFtZSIsImJhc2VuYW1lIiwiaW5jbHVkZXMiLCJleHRyYWN0U3R5bGVzIiwiZXh0cmFjdEZvbnRzIiwiZXh0cmFjdEdyYXBoaWNzIiwiZXh0cmFjdFByZWZlcmVuY2VzIiwiZXJyb3IiLCJtZXNzYWdlIiwic3R5bGVzRGF0YSIsInN0eWxlcyIsIlN0eWxlcyIsIlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwIiwiZXh0cmFjdFBhcmFncmFwaFN0eWxlcyIsIlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwIiwiZXh0cmFjdENoYXJhY3RlclN0eWxlcyIsInN0eWxlR3JvdXAiLCJleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkiLCJncm91cCIsIlBhcmFncmFwaFN0eWxlIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9udFJlZiIsImV4dHJhY3RGb250RnJvbVN0eWxlIiwiZm9udFNpemUiLCJwYXJzZUZsb2F0IiwicmF3TGVhZGluZyIsInByb2Nlc3NlZExlYWRpbmciLCJwcm9jZXNzTGVhZGluZ1ZhbHVlIiwicmF3TGVmdEluZGVudCIsInJhd1JpZ2h0SW5kZW50IiwicmF3Rmlyc3RMaW5lSW5kZW50IiwicmF3U3BhY2VCZWZvcmUiLCJyYXdTcGFjZUFmdGVyIiwicmF3VHJhY2tpbmciLCJyYXdLZXJuaW5nIiwiYmFzZVN0eWxlIiwic2VsZiIsIm5hbWUiLCJmb250U3R5bGUiLCJwb2ludFNpemUiLCJsZWFkaW5nVHlwZSIsImRldGVybWluZUxlYWRpbmdUeXBlIiwiZWZmZWN0aXZlTGluZUhlaWdodCIsImNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJhbGlnbm1lbnQiLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJmaXJzdExpbmVJbmRlbnQiLCJzcGFjZUJlZm9yZSIsInNwYWNlQWZ0ZXIiLCJ0cmFja2luZyIsImtlcm5pbmciLCJvcmlnaW5hbExlZnRJbmRlbnQiLCJvcmlnaW5hbFJpZ2h0SW5kZW50Iiwib3JpZ2luYWxGaXJzdExpbmVJbmRlbnQiLCJvcmlnaW5hbFNwYWNlQmVmb3JlIiwib3JpZ2luYWxTcGFjZUFmdGVyIiwib3JpZ2luYWxUcmFja2luZyIsIm9yaWdpbmFsS2VybmluZyIsImhvcml6b250YWxTY2FsZSIsInZlcnRpY2FsU2NhbGUiLCJhcHBsaWVkRm9udCIsIm9yaWdpbmFsRm9udFJlZiIsImZpbGxDb2xvciIsInJhd1N0eWxlIiwicGFyYWdyYXBoIiwiUGFyYWdyYXBoU3R5bGVHcm91cCIsInN1Ykdyb3VwcyIsIlByb3BlcnRpZXMiLCJBcHBsaWVkRm9udCIsIkZvbnRGYW1pbHkiLCJDaGFyYWN0ZXJTdHlsZSIsImNoYXJhY3RlciIsInN0cm9rZUNvbG9yIiwiQ2hhcmFjdGVyU3R5bGVHcm91cCIsImZvbnRzRGF0YSIsImZvbnRzIiwiRm9udHMiLCJyZXNvdXJjZXMiLCJmb250TWFwIiwiTWFwIiwiZm9udEZhbWlsaWVzIiwiZmFtaWx5IiwiZmFtaWx5SW5mbyIsIkZvbnQiLCJmb250TGlzdCIsImZvbnQiLCJmb250SW5mbyIsImZvbnRGYW1pbHkiLCJwb3N0U2NyaXB0TmFtZSIsInN0YXR1cyIsImZvbnRTdHlsZU5hbWUiLCJwdXNoIiwic2V0IiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInNpemUiLCJncmFwaGljc0RhdGEiLCJncmFwaGljcyIsIkdyYXBoaWMiLCJjb2xvcnMiLCJncmFkaWVudHMiLCJDb2xvciIsImNvbG9yIiwiY3lhbiIsIm1hZ2VudGEiLCJ5ZWxsb3ciLCJibGFjayIsInJlZCIsImdyZWVuIiwiYmx1ZSIsImNvbG9yU3BhY2UiLCJjb2xvck1vZGVsIiwiY29sb3JWYWx1ZSIsImZpbmFsQ29sb3JEYXRhIiwibW9kZWwiLCJzcGFjZSIsImNvbG9yU291cmNlIiwiaGFzRGlyZWN0UkdCIiwiaGFzRGlyZWN0Q01ZSyIsImhhc0NvbG9yVmFsdWUiLCJ2YWx1ZVBhcnRzIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJmaWx0ZXIiLCJ2Iiwic291cmNlIiwiaGFzUkdCIiwiaGFzQ01ZSyIsInJnYiIsImNteWsiLCJHcmFkaWVudCIsImdyYWRpZW50IiwidHlwZSIsImdyYWRpZW50U3RvcHMiLCJleHRyYWN0R3JhZGllbnRTdG9wcyIsInN0b3BzIiwiR3JhZGllbnRTdG9wIiwic3RvcExpc3QiLCJzdG9wIiwic3RvcENvbG9yIiwibG9jYXRpb24iLCJtaWRwb2ludCIsInByZWZlcmVuY2VzRGF0YSIsInByZWZzIiwiUHJlZmVyZW5jZXMiLCJkb2N1bWVudEluZm8iLCJwcmVmZXJlbmNlcyIsImRvY3VtZW50UHJlZmVyZW5jZXMiLCJleHRyYWN0RG9jdW1lbnRQcmVmcyIsIkRvY3VtZW50UHJlZmVyZW5jZSIsInZpZXdQcmVmZXJlbmNlcyIsImV4dHJhY3RWaWV3UHJlZnMiLCJWaWV3UHJlZmVyZW5jZSIsImd1aWRlUHJlZmVyZW5jZXMiLCJleHRyYWN0R3VpZGVQcmVmcyIsIkd1aWRlUHJlZmVyZW5jZSIsImdyaWRQcmVmZXJlbmNlcyIsImV4dHJhY3RHcmlkUHJlZnMiLCJHcmlkUHJlZmVyZW5jZSIsIm1hcmdpblByZWZlcmVuY2VzIiwiZXh0cmFjdE1hcmdpblByZWZzIiwiTWFyZ2luUHJlZmVyZW5jZSIsImNvbHVtblByZWZlcmVuY2VzIiwiZXh0cmFjdENvbHVtblByZWZzIiwiQ29sdW1uUHJlZmVyZW5jZSIsImRvY1ByZWYiLCJwYWdlV2lkdGgiLCJwYWdlSGVpZ2h0IiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY29sdW1uQ291bnQiLCJwYXJzZUludCIsImNvbHVtbkd1dHRlciIsImZhY2luZ1BhZ2VzIiwiYWxsb3dQYWdlU2h1ZmZsZSIsInNsdWdCbGVlZFR5cGUiLCJkb2N1bWVudEJsZWVkVG9wT2Zmc2V0IiwiZG9jdW1lbnRCbGVlZEJvdHRvbU9mZnNldCIsImRvY3VtZW50QmxlZWRJbnNpZGVPckxlZnRPZmZzZXQiLCJkb2N1bWVudEJsZWVkT3V0c2lkZU9yUmlnaHRPZmZzZXQiLCJ2aWV3UHJlZiIsImhvcml6b250YWxNZWFzdXJlbWVudFVuaXRzIiwidmVydGljYWxNZWFzdXJlbWVudFVuaXRzIiwicnVsZXJPcmlnaW4iLCJzaG93UnVsZXJzIiwiZ3VpZGVQcmVmIiwicnVsZXJHdWlkZUNvbG9yIiwiZ3VpZGVzSW5CYWNrIiwiZ3VpZGVzTG9ja2VkIiwiZ3VpZGVzU2hvd24iLCJndWlkZXNTbmFwdG8iLCJncmlkUHJlZiIsImJhc2VsaW5lU3RhcnQiLCJiYXNlbGluZURpdmlzaW9uIiwiYmFzZWxpbmVTaG93biIsImJhc2VsaW5lU25hcHRvIiwiZG9jdW1lbnRHcmlkU2hvd24iLCJkb2N1bWVudEdyaWRTbmFwdG8iLCJtYXJnaW5QcmVmIiwiY29sdW1uUHJlZiIsInRleHRDb2x1bW5Db3VudCIsInRleHRDb2x1bW5HdXR0ZXIiLCJyZXNvbHZlU3R5bGVGb3JtYXR0aW5nIiwiZm9ybWF0dGluZyIsInJlc29sdmVkIiwiaGFzQW55Rm9ybWF0dGluZyIsInBhcmFncmFwaFN0eWxlIiwiY2hhcmFjdGVyU3R5bGUiLCJmb250UmVmZXJlbmNlIiwiZGlyZWN0Rm9udFN0eWxlIiwiZGlyZWN0Rm9udFJlZiIsImRpcmVjdEZvbnRTaXplIiwicFN0eWxlIiwicmVzb2x2ZUZvbnRSZWZlcmVuY2UiLCJjU3R5bGUiLCJ1bmRlZmluZWQiLCJnZXREZWZhdWx0Rm9udCIsImhhcyIsInJlc29sdmVkRm9udCIsImdldCIsImZhbWlseUlkIiwiZW50cmllcyIsInRvTG93ZXJDYXNlIiwiZmlyc3RGYW1pbHkiLCJ2YWx1ZXMiLCJpbmZlckZvbnRGcm9tQ29udGV4dCIsImZpcnN0Rm9udEZhbWlseSIsImdldFN0b3J5U3R5bGVTdW1tYXJ5Iiwic3RvcnkiLCJzdW1tYXJ5IiwiZm9ybWF0dGVkQ29udGVudCIsImZpcnN0Rm9ybWF0dGVkIiwiZmluZCIsIml0ZW0iLCJpc0JyZWFrIiwiZm10IiwibnVtZXJpY0xlYWRpbmciLCJwZXJjZW50YWdlIiwicmVwbGFjZSIsIk1hdGgiLCJtYXgiLCJnZXRTdHlsZXMiLCJnZXRSZXNvdXJjZXMiLCJnZXRGb250TWFwIiwiZ2V0UGFyYWdyYXBoU3R5bGVzIiwiZ2V0Q2hhcmFjdGVyU3R5bGVzIiwiZ2V0Rm9udERlZmluaXRpb25zIiwiZnJvbUVudHJpZXMiLCJnZXREb2N1bWVudEluZm8iLCJjb25zdHJ1Y3RvciIsIm9iamVjdCIsInRhYmxlIiwiY2VsbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/parsers/StyleParser.js\n"));

/***/ })

});