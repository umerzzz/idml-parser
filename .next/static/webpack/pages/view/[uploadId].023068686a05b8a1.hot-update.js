"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StoryParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StoryParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StoryParser {\n    async parseStoryFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCDD Parsing story: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const storyId = path.basename(fileName, \".xml\");\n            const storyData = parsed.Story || parsed;\n            // ADD THESE SIMPLE LOGS FIRST:\n            console.log(\"=== SIMPLE DEBUG TEST ===\");\n            console.log(\"Story file name:\", fileName);\n            console.log(\"Parsed story keys:\", Object.keys(storyData));\n            console.log(\"Raw story data sample:\", JSON.stringify(storyData, null, 2).substring(0, 500));\n            // Extract detailed story information\n            const detailedStory = {\n                self: storyData[\"@_Self\"],\n                appliedTOCStyle: storyData[\"@_AppliedTOCStyle\"] || \"n\",\n                userText: storyData[\"@_UserText\"] !== false,\n                // Extract story content with formatting\n                content: this.extractDetailedStoryContent(storyData),\n                // Extract text formatting\n                textFormatting: this.extractTextFormatting(storyData)\n            };\n            const cleanStoryId = storyId.replace(\"Story_\", \"\");\n            this.stories[cleanStoryId] = detailedStory;\n            // Enhanced logging to show line breaks\n            const { plainText, lineBreakInfo } = detailedStory.content;\n            console.log(\"✅ Story \".concat(storyId, \" parsed:\"));\n            console.log(\"   - Characters: \".concat(plainText.length));\n            console.log(\"   - Words: \".concat(detailedStory.content.wordCount));\n            console.log(\"   - Line breaks: \".concat((lineBreakInfo === null || lineBreakInfo === void 0 ? void 0 : lineBreakInfo.lineBreakCount) || 0));\n            console.log('   - Text preview: \"'.concat(plainText.substring(0, 50).replace(/\\n/g, \"\\\\n\"), '...\"'));\n        } catch (error) {\n            console.error(\"❌ Error parsing story \".concat(fileName, \":\"), error.message);\n        }\n    }\n    // Replace the existing extractDetailedStoryContent method with this corrected version\n    extractDetailedStoryContent(storyData) {\n        var _this = this;\n        let content = \"\";\n        let formattedContent = [];\n        let textColor = null;\n        let debugInfo = [];\n        const extractTextRecursively = function(element) {\n            let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (typeof element === \"string\") {\n                content += element;\n                return;\n            }\n            if (element && typeof element === \"object\") {\n                // ENHANCED: Special handling for CharacterStyleRange with sophisticated Br detection\n                if (element.CharacterStyleRange) {\n                    const ranges = Array.isArray(element.CharacterStyleRange) ? element.CharacterStyleRange : [\n                        element.CharacterStyleRange\n                    ];\n                    // SIMPLIFIED DEBUG: Just log problematic text ranges\n                    const allRangeContent = ranges.map((r)=>r.Content ? Array.isArray(r.Content) ? r.Content.join(\"\") : String(r.Content) : \"\").join(\"\");\n                    if (allRangeContent.includes(\"pavoluptusda\") || allRangeContent.includes(\"pa\") || allRangeContent.includes(\"voluptusda\")) {\n                        console.log(\"\\uD83D\\uDEA8 FOUND RANGES WITH PROBLEMATIC TEXT:\");\n                        ranges.forEach((range, index)=>{\n                            const content = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                            console.log(\"   Range \".concat(index, ': \"').concat(content, '\"'));\n                        });\n                    }\n                    ranges.forEach((range, rangeIndex)=>{\n                        // Extract direct font references from the XML range\n                        const directFontRef = range[\"@_AppliedFont\"] || range[\"@_FontFamily\"] || range[\"@_Font\"] || \"\";\n                        const formatting = {\n                            paragraphStyle: element[\"@_AppliedParagraphStyle\"] || null,\n                            characterStyle: range[\"@_AppliedCharacterStyle\"] || null,\n                            fontSize: range[\"@_PointSize\"] ? parseFloat(range[\"@_PointSize\"]) : null,\n                            fontReference: directFontRef,\n                            fillColor: range[\"@_FillColor\"] || null,\n                            fontStyle: range[\"@_FontStyle\"] || null\n                        };\n                        // DEBUG: Log formatting extraction for any styled text (generic check)\n                        const rangeContent = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                        const hasStyleInfo = range[\"@_FontStyle\"] || range[\"@_AppliedCharacterStyle\"] || element[\"@_AppliedParagraphStyle\"] || range[\"@_AppliedFont\"];\n                        if (hasStyleInfo && rangeContent.trim()) {\n                            console.log(\"\\uD83D\\uDD27 StoryParser - Extracting formatting for range:\", JSON.stringify(rangeContent.substring(0, 30) + \"...\"), {\n                                rawRangeAttributes: Object.keys(range).filter((k)=>k.startsWith(\"@_\")),\n                                extractedFormatting: formatting,\n                                fontStyleFromXML: range[\"@_FontStyle\"],\n                                characterStyleFromXML: range[\"@_AppliedCharacterStyle\"],\n                                paragraphStyleFromXML: element[\"@_AppliedParagraphStyle\"]\n                            });\n                        }\n                        const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                        // FIXED: Process content with proper space preservation\n                        if (range.Content) {\n                            const contents = Array.isArray(range.Content) ? range.Content : [\n                                range.Content\n                            ];\n                            contents.forEach((contentItem, contentIndex)=>{\n                                const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n                                content += text;\n                                formattedContent.push({\n                                    text: text,\n                                    formatting: resolvedFormatting\n                                });\n                                // CRITICAL FIX: Check for Br elements AFTER each content item within the same range\n                                if (range.Br !== undefined && contentIndex < contents.length - 1) {\n                                    const lineBreakText = \"\\n\";\n                                    content += lineBreakText;\n                                    formattedContent.push({\n                                        text: lineBreakText,\n                                        formatting: {\n                                            isBreak: true,\n                                            breakType: \"line\",\n                                            position: \"between_content\",\n                                            source: \"Br element within range\"\n                                        }\n                                    });\n                                    debugInfo.push({\n                                        type: \"Line break detected within content\",\n                                        location: \"CharacterStyleRange[\".concat(rangeIndex, \"], between content[\").concat(contentIndex, \"] and content[\").concat(contentIndex + 1, \"]\"),\n                                        breakType: \"line\",\n                                        context: context\n                                    });\n                                }\n                            });\n                        }\n                        // Handle Br elements at the end of the range\n                        if (range.Br !== undefined && (!range.Content || Array.isArray(range.Content) === false)) {\n                            const brElements = _this.extractBrElements(range);\n                            brElements.forEach((brInfo, brIndex)=>{\n                                const lineBreakText = _this.determineLineBreakType(brInfo, context);\n                                content += lineBreakText;\n                                formattedContent.push({\n                                    text: lineBreakText,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: brInfo.type || \"line\",\n                                        position: brInfo.position || \"end\",\n                                        source: \"Br element at end of range\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Line break detected at end of range\",\n                                    location: \"CharacterStyleRange[\".concat(rangeIndex, \"], Br[\").concat(brIndex, \"]\"),\n                                    breakType: brInfo.type || \"line\",\n                                    context: context\n                                });\n                            });\n                        }\n                        // CRITICAL FIX: Add space between character style ranges if needed\n                        if (rangeIndex < ranges.length - 1) {\n                            const nextRange = ranges[rangeIndex + 1];\n                            // More robust space detection\n                            const currentText = content.slice(-10); // Check last 10 characters\n                            const currentRangeEndsWithSpace = /\\s$/.test(currentText); // Any whitespace at end\n                            const nextContent = nextRange.Content ? String(Array.isArray(nextRange.Content) ? nextRange.Content[0] : nextRange.Content) : \"\";\n                            const nextRangeStartsWithSpace = /^\\s/.test(nextContent); // Any whitespace at start\n                            // AGGRESSIVE FIX: Add space between ALL ranges unless explicitly not needed\n                            const shouldSkipSpace = currentRangeEndsWithSpace || nextRangeStartsWithSpace || _this.shouldInsertImplicitLineBreak(range, nextRange, context) || !nextRange.Content || // Skip if next range has no content\n                            nextContent.trim() === \"\"; // Skip if next content is only whitespace\n                            if (!shouldSkipSpace) {\n                                const currentStyle = range[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const nextStyle = nextRange[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const spaceText = \" \";\n                                content += spaceText;\n                                formattedContent.push({\n                                    text: spaceText,\n                                    formatting: {\n                                        isSpace: true,\n                                        source: \"between character style ranges (aggressive)\",\n                                        currentStyle,\n                                        nextStyle\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Space inserted between character styles (aggressive)\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    currentStyle,\n                                    nextStyle,\n                                    reason: \"Default space insertion - words likely split across ranges\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            } else {\n                                debugInfo.push({\n                                    type: \"Space insertion skipped\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    reason: currentRangeEndsWithSpace ? \"Current range ends with space\" : nextRangeStartsWithSpace ? \"Next range starts with space\" : !nextRange.Content ? \"Next range has no content\" : nextContent.trim() === \"\" ? \"Next content is only whitespace\" : \"Line break would be inserted\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            }\n                            // Handle explicit line breaks between ranges (for cases where shouldInsertImplicitLineBreak is true)\n                            if (_this.shouldInsertImplicitLineBreak(range, nextRange, context)) {\n                                const implicitBreak = \"\\n\";\n                                content += implicitBreak;\n                                formattedContent.push({\n                                    text: implicitBreak,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: \"implicit\",\n                                        source: \"between ranges\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Implicit line break\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1)\n                                });\n                            }\n                        }\n                    });\n                    return; // Don't continue processing to avoid duplication\n                }\n                // ENHANCED: Handle ParagraphStyleRange with context\n                if (element.ParagraphStyleRange) {\n                    const ranges = Array.isArray(element.ParagraphStyleRange) ? element.ParagraphStyleRange : [\n                        element.ParagraphStyleRange\n                    ];\n                    ranges.forEach((range, index)=>{\n                        const paragraphContext = {\n                            ...context,\n                            paragraphIndex: index,\n                            totalParagraphs: ranges.length,\n                            appliedStyle: range[\"@_AppliedParagraphStyle\"]\n                        };\n                        extractTextRecursively(range, depth + 1, paragraphContext);\n                        // Add paragraph break between paragraphs (but not after the last one)\n                        if (index < ranges.length - 1) {\n                            const paragraphBreak = \"\\n\";\n                            content += paragraphBreak;\n                            formattedContent.push({\n                                text: paragraphBreak,\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"paragraph\",\n                                    source: \"between paragraphs\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Paragraph break\",\n                                location: \"between paragraphs \".concat(index, \" and \").concat(index + 1)\n                            });\n                        }\n                    });\n                    return;\n                }\n                // Handle direct Content elements (when not inside CharacterStyleRange)\n                if (element.Content && !element.CharacterStyleRange) {\n                    let text = Array.isArray(element.Content) ? element.Content.join(\"\") : String(element.Content);\n                    text = IDMLUtils.decodeXMLEntities(text);\n                    content += text;\n                    const formatting = {\n                        paragraphStyle: element[\"@_AppliedParagraphStyle\"] || null,\n                        characterStyle: element[\"@_AppliedCharacterStyle\"] || null,\n                        fontSize: element[\"@_PointSize\"] || null,\n                        fontFamily: element[\"@_AppliedFont\"] || null,\n                        fillColor: element[\"@_FillColor\"] || null\n                    };\n                    const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                    formattedContent.push({\n                        text: text,\n                        formatting: resolvedFormatting\n                    });\n                }\n                // ENHANCED: Direct Br element handling (outside of ranges)\n                if (element.Br !== undefined) {\n                    const brElements = Array.isArray(element.Br) ? element.Br : [\n                        element.Br\n                    ];\n                    brElements.forEach((br, index)=>{\n                        const lineBreakText = \"\\n\";\n                        content += lineBreakText;\n                        formattedContent.push({\n                            text: lineBreakText,\n                            formatting: {\n                                isBreak: true,\n                                breakType: \"explicit\",\n                                source: \"direct Br element\"\n                            }\n                        });\n                        debugInfo.push({\n                            type: \"Direct Br element\",\n                            location: \"Direct element, index \".concat(index)\n                        });\n                    });\n                }\n                // Continue with other nested elements\n                Object.entries(element).forEach((param)=>{\n                    let [key, value] = param;\n                    if (!key.startsWith(\"@_\") && key !== \"Content\" && key !== \"Br\" && key !== \"CharacterStyleRange\" && key !== \"ParagraphStyleRange\") {\n                        if (Array.isArray(value)) {\n                            value.forEach((item)=>extractTextRecursively(item, depth + 1, context));\n                        } else if (typeof value === \"object\" && depth < 10) {\n                            extractTextRecursively(value, depth + 1, context);\n                        }\n                    }\n                });\n            }\n        };\n        extractTextRecursively(storyData);\n        // ENHANCED: Process and clean up the content with sophisticated line break preservation\n        const processedContent = IDMLUtils.sophisticatedLineBreakProcessing(content);\n        // DEBUG: Log space preservation results\n        console.log(\"\\uD83D\\uDCDD Text extraction results:\");\n        console.log(\"   - Original content length:\", content.length);\n        console.log(\"   - Processed content length:\", processedContent.length);\n        console.log(\"   - Space preservation events:\", debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length);\n        // SPECIFIC DEBUG: Check for the problematic \"pavoluptusda\" text (simplified)\n        if (processedContent.includes(\"pavoluptusda\") || processedContent.includes(\"pa\") && processedContent.includes(\"voluptusda\")) {\n            console.log(\"\\uD83D\\uDEA8 FOUND PROBLEMATIC TEXT:\");\n            console.log('   - Contains \"pavoluptusda\":', processedContent.includes(\"pavoluptusda\"));\n            console.log('   - Contains \"pa voluptusda\":', processedContent.includes(\"pa voluptusda\"));\n            console.log(\"   - FormattedContent breakdown:\", formattedContent.map((item)=>item.text).join(\"|\"));\n        }\n        const lineBreakInfo = {\n            hasLineBreaks: processedContent.includes(\"\\n\"),\n            lineBreakCount: (processedContent.match(/\\n/g) || []).length,\n            lineBreakTypes: this.analyzeLineBreakTypes(formattedContent),\n            debugInfo: debugInfo,\n            spacePreservationCount: debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length\n        };\n        return {\n            plainText: processedContent,\n            formattedContent: formattedContent.filter((item)=>item.text && item.text.length > 0),\n            wordCount: IDMLUtils.countWords(processedContent.replace(/\\n/g, \" \")),\n            characterCount: processedContent.length,\n            textColor: textColor,\n            lineBreakInfo: lineBreakInfo\n        };\n    }\n    // Add this helper method to better handle mixed content and Br elements\n    analyzeContentStructure(range) {\n        const structure = {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentItems: range.Content ? Array.isArray(range.Content) ? range.Content : [\n                range.Content\n            ] : [],\n            brElements: range.Br ? Array.isArray(range.Br) ? range.Br : [\n                range.Br\n            ] : []\n        };\n        console.log(\"Content structure analysis:\", structure);\n        return structure;\n    }\n    // Enhanced helper for processing interleaved content and breaks\n    processInterleavedContent(range, resolvedFormatting) {\n        const results = [];\n        let content = \"\";\n        // This method would need access to the actual XML structure to determine\n        // the exact order of Content and Br elements. For now, we'll use the \n        // approach above which handles the most common case.\n        return results;\n    }\n    // SOPHISTICATED: Helper method to extract Br elements with context\n    extractBrElements(range) {\n        const brElements = [];\n        if (range.Br !== undefined) {\n            if (Array.isArray(range.Br)) {\n                range.Br.forEach((br, index)=>{\n                    brElements.push({\n                        type: \"line\",\n                        position: index === 0 ? \"start\" : \"middle\",\n                        element: br\n                    });\n                });\n            } else {\n                brElements.push({\n                    type: \"line\",\n                    position: \"end\",\n                    element: range.Br\n                });\n            }\n        }\n        return brElements;\n    }\n    // SOPHISTICATED: Determine the appropriate line break type\n    determineLineBreakType(brInfo, context) {\n        // Different line break characters based on context\n        switch(brInfo.type){\n            case \"paragraph\":\n                return \"\\n\\n\"; // Double line break for paragraph separation\n            case \"forced\":\n                return \"\\n\"; // Forced line break (Shift+Enter equivalent)\n            case \"line\":\n            default:\n                return \"\\n\"; // Standard line break\n        }\n    }\n    // SOPHISTICATED: Determine if an implicit line break should be inserted\n    shouldInsertImplicitLineBreak(currentRange, nextRange, context) {\n        // Don't insert implicit breaks if explicit Br elements are present\n        if (currentRange.Br !== undefined || nextRange.Br !== undefined) {\n            return false;\n        }\n        // Insert breaks between different character styles in different paragraphs\n        const currentCharStyle = currentRange[\"@_AppliedCharacterStyle\"];\n        const nextCharStyle = nextRange[\"@_AppliedCharacterStyle\"];\n        // If we're in a context where styles change significantly, add a break\n        if (currentCharStyle && nextCharStyle && currentCharStyle !== nextCharStyle) {\n            // Check if this might be a title/heading followed by body text\n            const styleIndicatesBreak = this.styleIndicatesLineBreak(currentCharStyle, nextCharStyle);\n            return styleIndicatesBreak;\n        }\n        return false;\n    }\n    // SOPHISTICATED: Analyze if style change indicates a line break\n    styleIndicatesLineBreak(currentStyle, nextStyle) {\n        const titleIndicators = [\n            \"title\",\n            \"heading\",\n            \"header\"\n        ];\n        const bodyIndicators = [\n            \"body\",\n            \"text\",\n            \"normal\"\n        ];\n        const currentIsTitle = titleIndicators.some((indicator)=>currentStyle.toLowerCase().includes(indicator));\n        const nextIsBody = bodyIndicators.some((indicator)=>nextStyle.toLowerCase().includes(indicator));\n        return currentIsTitle && nextIsBody;\n    }\n    // SOPHISTICATED: Analyze line break types in formatted content\n    analyzeLineBreakTypes(formattedContent) {\n        const types = {\n            explicit: 0,\n            implicit: 0,\n            paragraph: 0,\n            direct: 0 // Direct Br elements\n        };\n        formattedContent.forEach((item)=>{\n            var _item_formatting;\n            if ((_item_formatting = item.formatting) === null || _item_formatting === void 0 ? void 0 : _item_formatting.isBreak) {\n                const breakType = item.formatting.breakType || \"unknown\";\n                if (types.hasOwnProperty(breakType)) {\n                    types[breakType]++;\n                }\n            }\n        });\n        return types;\n    }\n    extractDetailedFormattingFromRange(range) {\n        const formatting = {};\n        // Extract all possible font attributes\n        const fontAttributes = [\n            \"@_AppliedFont\",\n            \"@_FontFamily\",\n            \"@_Font\",\n            \"@_PostScriptName\",\n            \"@_FontName\"\n        ];\n        fontAttributes.forEach((attr)=>{\n            if (range[attr]) {\n                formatting.fontReference = range[attr];\n            }\n        });\n        // Extract font and size attributes\n        formatting.fontSize = IDMLUtils.parseNumeric(range[\"@_PointSize\"]);\n        // ENHANCED: Extract leading with proper processing\n        const rawLeading = range[\"@_Leading\"];\n        formatting.leading = this.processLeadingValue(rawLeading, formatting.fontSize);\n        formatting.leadingType = this.determineLeadingType(rawLeading);\n        // Extract color and style attributes\n        formatting.fillColor = range[\"@_FillColor\"];\n        formatting.strokeColor = range[\"@_StrokeColor\"];\n        formatting.fontStyle = range[\"@_FontStyle\"];\n        // Extract advanced typography attributes\n        formatting.tracking = IDMLUtils.parseNumeric(range[\"@_Tracking\"]);\n        formatting.baselineShift = IDMLUtils.parseNumeric(range[\"@_BaselineShift\"]);\n        formatting.kerning = IDMLUtils.parseNumeric(range[\"@_Kerning\"]);\n        formatting.horizontalScale = IDMLUtils.parseNumeric(range[\"@_HorizontalScale\"]) || 100;\n        formatting.verticalScale = IDMLUtils.parseNumeric(range[\"@_VerticalScale\"]) || 100;\n        // Extract paragraph-level attributes if present\n        // CRITICAL FIX: Only set alignment if explicitly specified, allowing paragraph inheritance\n        const explicitAlignment = range[\"@_Justification\"] || range[\"@_Alignment\"];\n        if (explicitAlignment && explicitAlignment !== \"LeftAlign\") {\n            formatting.alignment = explicitAlignment;\n        }\n        formatting.leftIndent = IDMLUtils.parseNumeric(range[\"@_LeftIndent\"]);\n        formatting.rightIndent = IDMLUtils.parseNumeric(range[\"@_RightIndent\"]);\n        formatting.firstLineIndent = IDMLUtils.parseNumeric(range[\"@_FirstLineIndent\"]);\n        formatting.spaceBefore = IDMLUtils.parseNumeric(range[\"@_SpaceBefore\"]);\n        formatting.spaceAfter = IDMLUtils.parseNumeric(range[\"@_SpaceAfter\"]);\n        // Calculate effective line height for CSS\n        formatting.effectiveLineHeight = this.calculateEffectiveLineHeight(formatting);\n        return formatting;\n    }\n    // NEW: Process leading values with InDesign-specific logic\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = IDMLUtils.parseNumeric(rawLeading);\n        if (numericLeading) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (IDMLUtils.parseNumeric(rawLeading)) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(formatting) {\n        const fontSize = formatting.fontSize || 12;\n        const leading = formatting.leading;\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\") {\n            // Convert points to CSS line-height ratio\n            return leading / fontSize;\n        }\n        return 1.2; // Fallback\n    }\n    extractTextFormatting(storyData) {\n        const formatting = {\n            paragraphStyles: [],\n            characterStyles: [],\n            appliedStyles: []\n        };\n        // Extract applied paragraph styles\n        if (storyData.ParagraphStyleRange) {\n            const ranges = Array.isArray(storyData.ParagraphStyleRange) ? storyData.ParagraphStyleRange : [\n                storyData.ParagraphStyleRange\n            ];\n            ranges.forEach((range)=>{\n                const appliedStyle = range[\"@_AppliedParagraphStyle\"];\n                if (appliedStyle && !formatting.paragraphStyles.includes(appliedStyle)) {\n                    formatting.paragraphStyles.push(appliedStyle);\n                }\n                // Extract character styles within paragraph ranges\n                if (range.CharacterStyleRange) {\n                    const charRanges = Array.isArray(range.CharacterStyleRange) ? range.CharacterStyleRange : [\n                        range.CharacterStyleRange\n                    ];\n                    charRanges.forEach((charRange)=>{\n                        const charStyle = charRange[\"@_AppliedCharacterStyle\"];\n                        if (charStyle && !formatting.characterStyles.includes(charStyle)) {\n                            formatting.characterStyles.push(charStyle);\n                        }\n                    });\n                }\n            });\n        }\n        return formatting;\n    }\n    // Add this method to debug raw story content\n    debugRawStoryContent(storyData) {\n        console.log(\"\\n\\uD83D\\uDD0D RAW STORY CONTENT DEBUG:\");\n        console.log(\"Story keys:\", Object.keys(storyData));\n        const findCharacterRanges = function(obj) {\n            let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key === \"CharacterStyleRange\") {\n                        console.log(\"\\n\\uD83D\\uDCDD Found CharacterStyleRange at \".concat(path, \":\"), obj[key]);\n                        const ranges = Array.isArray(obj[key]) ? obj[key] : [\n                            obj[key]\n                        ];\n                        ranges.forEach((range, index)=>{\n                            console.log(\"  Range \".concat(index + 1, \" attributes:\"), Object.keys(range).filter((k)=>k.startsWith(\"@_\")));\n                            console.log(\"  Range \".concat(index + 1, \" font info:\"), {\n                                AppliedFont: range[\"@_AppliedFont\"],\n                                FontStyle: range[\"@_FontStyle\"],\n                                PointSize: range[\"@_PointSize\"]\n                            });\n                        });\n                    } else if (typeof obj[key] === \"object\") {\n                        findCharacterRanges(obj[key], \"\".concat(path, \".\").concat(key));\n                    }\n                });\n            }\n        };\n        findCharacterRanges(storyData);\n    }\n    getStories() {\n        return this.stories;\n    }\n    getStory(storyId) {\n        return this.stories[storyId];\n    }\n    clearStories() {\n        this.stories = {};\n    }\n    constructor(styleParser){\n        this.styleParser = styleParser;\n        this.stories = {};\n    }\n}\nmodule.exports = StoryParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VUFBVSxDQUFDOzRCQUU5Q25FLFFBQVFDLEdBQUcsQ0FBQyxXQUFxQixPQUFWaUQsUUFBUSxHQUFFLGdCQUFjO2dDQUM3Q2dKLGFBQWFqSixLQUFLLENBQUMsZ0JBQWdCO2dDQUNuQ2tKLFdBQVdsSixLQUFLLENBQUMsY0FBYztnQ0FDL0JtSixXQUFXbkosS0FBSyxDQUFDLGNBQWM7NEJBQ2pDO3dCQUNGO29CQUNGLE9BQU8sSUFBSSxPQUFPZ0osR0FBRyxDQUFDeEUsSUFBSSxLQUFLLFVBQVU7d0JBQ3ZDdUUsb0JBQW9CQyxHQUFHLENBQUN4RSxJQUFJLEVBQUUsR0FBV0EsT0FBUmpJLE1BQUssS0FBTyxPQUFKaUk7b0JBQzNDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBdUUsb0JBQW9CMUw7SUFDdEI7SUFFQStMLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQy9LLE9BQU87SUFDckI7SUFFQWdMLFNBQVNsTSxPQUFPLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNrQixPQUFPLENBQUNsQixRQUFRO0lBQzlCO0lBRUFtTSxlQUFlO1FBQ2IsSUFBSSxDQUFDakwsT0FBTyxHQUFHLENBQUM7SUFDbEI7SUF0ckJBa0wsWUFBWS9ILFdBQVcsQ0FBRTtRQUN2QixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDbkQsT0FBTyxHQUFHLENBQUM7SUFDbEI7QUFvckJGO0FBRUFtTCxPQUFPQyxPQUFPLEdBQUcvTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGFyc2Vycy9TdG9yeVBhcnNlci5qcz82OGNmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL0lETUxVdGlscycpO1xyXG5cclxuY2xhc3MgU3RvcnlQYXJzZXIge1xyXG4gIGNvbnN0cnVjdG9yKHN0eWxlUGFyc2VyKSB7XHJcbiAgICB0aGlzLnN0eWxlUGFyc2VyID0gc3R5bGVQYXJzZXI7XHJcbiAgICB0aGlzLnN0b3JpZXMgPSB7fTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHBhcnNlU3RvcnlGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OdIFBhcnNpbmcgc3Rvcnk6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcclxuICAgICAgY29uc3Qgc3RvcnlJZCA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUsICcueG1sJyk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzdG9yeURhdGEgPSBwYXJzZWQuU3RvcnkgfHwgcGFyc2VkO1xyXG4gICAgICBcclxuICAgICAgLy8gQUREIFRIRVNFIFNJTVBMRSBMT0dTIEZJUlNUOlxyXG4gICAgICBjb25zb2xlLmxvZygnPT09IFNJTVBMRSBERUJVRyBURVNUID09PScpO1xyXG4gICAgICBjb25zb2xlLmxvZygnU3RvcnkgZmlsZSBuYW1lOicsIGZpbGVOYW1lKTtcclxuICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCBzdG9yeSBrZXlzOicsIE9iamVjdC5rZXlzKHN0b3J5RGF0YSkpO1xyXG4gICAgICBjb25zb2xlLmxvZygnUmF3IHN0b3J5IGRhdGEgc2FtcGxlOicsIEpTT04uc3RyaW5naWZ5KHN0b3J5RGF0YSwgbnVsbCwgMikuc3Vic3RyaW5nKDAsIDUwMCkpO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBkZXRhaWxlZCBzdG9yeSBpbmZvcm1hdGlvblxyXG4gICAgICBjb25zdCBkZXRhaWxlZFN0b3J5ID0ge1xyXG4gICAgICAgIHNlbGY6IHN0b3J5RGF0YVsnQF9TZWxmJ10sXHJcbiAgICAgICAgYXBwbGllZFRPQ1N0eWxlOiBzdG9yeURhdGFbJ0BfQXBwbGllZFRPQ1N0eWxlJ10gfHwgJ24nLFxyXG4gICAgICAgIHVzZXJUZXh0OiBzdG9yeURhdGFbJ0BfVXNlclRleHQnXSAhPT0gZmFsc2UsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXh0cmFjdCBzdG9yeSBjb250ZW50IHdpdGggZm9ybWF0dGluZ1xyXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50KHN0b3J5RGF0YSksXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXh0cmFjdCB0ZXh0IGZvcm1hdHRpbmdcclxuICAgICAgICB0ZXh0Rm9ybWF0dGluZzogdGhpcy5leHRyYWN0VGV4dEZvcm1hdHRpbmcoc3RvcnlEYXRhKVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2xlYW5TdG9yeUlkID0gc3RvcnlJZC5yZXBsYWNlKCdTdG9yeV8nLCAnJyk7XHJcbiAgICAgIHRoaXMuc3Rvcmllc1tjbGVhblN0b3J5SWRdID0gZGV0YWlsZWRTdG9yeTtcclxuICAgICAgXHJcbiAgICAgIC8vIEVuaGFuY2VkIGxvZ2dpbmcgdG8gc2hvdyBsaW5lIGJyZWFrc1xyXG4gICAgICBjb25zdCB7IHBsYWluVGV4dCwgbGluZUJyZWFrSW5mbyB9ID0gZGV0YWlsZWRTdG9yeS5jb250ZW50O1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFN0b3J5ICR7c3RvcnlJZH0gcGFyc2VkOmApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBDaGFyYWN0ZXJzOiAke3BsYWluVGV4dC5sZW5ndGh9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIFdvcmRzOiAke2RldGFpbGVkU3RvcnkuY29udGVudC53b3JkQ291bnR9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIExpbmUgYnJlYWtzOiAke2xpbmVCcmVha0luZm8/LmxpbmVCcmVha0NvdW50IHx8IDB9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIFRleHQgcHJldmlldzogXCIke3BsYWluVGV4dC5zdWJzdHJpbmcoMCwgNTApLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKX0uLi5cImApO1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBwYXJzaW5nIHN0b3J5ICR7ZmlsZU5hbWV9OmAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVwbGFjZSB0aGUgZXhpc3RpbmcgZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50IG1ldGhvZCB3aXRoIHRoaXMgY29ycmVjdGVkIHZlcnNpb25cclxuICBleHRyYWN0RGV0YWlsZWRTdG9yeUNvbnRlbnQoc3RvcnlEYXRhKSB7XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgbGV0IGZvcm1hdHRlZENvbnRlbnQgPSBbXTtcclxuICAgIGxldCB0ZXh0Q29sb3IgPSBudWxsO1xyXG4gICAgbGV0IGRlYnVnSW5mbyA9IFtdO1xyXG4gICAgXHJcbiAgICBjb25zdCBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5ID0gKGVsZW1lbnQsIGRlcHRoID0gMCwgY29udGV4dCA9IHt9KSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb250ZW50ICs9IGVsZW1lbnQ7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyBFTkhBTkNFRDogU3BlY2lhbCBoYW5kbGluZyBmb3IgQ2hhcmFjdGVyU3R5bGVSYW5nZSB3aXRoIHNvcGhpc3RpY2F0ZWQgQnIgZGV0ZWN0aW9uXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpID8gXHJcbiAgICAgICAgICAgIGVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZSA6IFtlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTSU1QTElGSUVEIERFQlVHOiBKdXN0IGxvZyBwcm9ibGVtYXRpYyB0ZXh0IHJhbmdlc1xyXG4gICAgICAgICAgY29uc3QgYWxsUmFuZ2VDb250ZW50ID0gcmFuZ2VzLm1hcChyID0+IHIuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShyLkNvbnRlbnQpID8gci5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKHIuQ29udGVudCkpIDogJycpLmpvaW4oJycpO1xyXG4gICAgICAgICAgaWYgKGFsbFJhbmdlQ29udGVudC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykgfHwgYWxsUmFuZ2VDb250ZW50LmluY2x1ZGVzKCdwYScpIHx8IGFsbFJhbmdlQ29udGVudC5pbmNsdWRlcygndm9sdXB0dXNkYScpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5qoIEZPVU5EIFJBTkdFUyBXSVRIIFBST0JMRU1BVElDIFRFWFQ6Jyk7XHJcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmFuZ2UuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudCkgPyByYW5nZS5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKHJhbmdlLkNvbnRlbnQpKSA6ICcnO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBSYW5nZSAke2luZGV4fTogXCIke2NvbnRlbnR9XCJgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgcmFuZ2VJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBFeHRyYWN0IGRpcmVjdCBmb250IHJlZmVyZW5jZXMgZnJvbSB0aGUgWE1MIHJhbmdlXHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdEZvbnRSZWYgPSByYW5nZVsnQF9BcHBsaWVkRm9udCddIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVsnQF9Gb250RmFtaWx5J10gfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWydAX0ZvbnQnXSB8fCAnJztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7XHJcbiAgICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZTogcmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgICBmb250U2l6ZTogcmFuZ2VbJ0BfUG9pbnRTaXplJ10gPyBwYXJzZUZsb2F0KHJhbmdlWydAX1BvaW50U2l6ZSddKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgZm9udFJlZmVyZW5jZTogZGlyZWN0Rm9udFJlZixcclxuICAgICAgICAgICAgICBmaWxsQ29sb3I6IHJhbmdlWydAX0ZpbGxDb2xvciddIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgZm9udFN0eWxlOiByYW5nZVsnQF9Gb250U3R5bGUnXSB8fCBudWxsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBERUJVRzogTG9nIGZvcm1hdHRpbmcgZXh0cmFjdGlvbiBmb3IgYW55IHN0eWxlZCB0ZXh0IChnZW5lcmljIGNoZWNrKVxyXG4gICAgICAgICAgICBjb25zdCByYW5nZUNvbnRlbnQgPSByYW5nZS5Db250ZW50ID8gXHJcbiAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudCkgPyByYW5nZS5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKHJhbmdlLkNvbnRlbnQpKSA6ICcnO1xyXG4gICAgICAgICAgICBjb25zdCBoYXNTdHlsZUluZm8gPSByYW5nZVsnQF9Gb250U3R5bGUnXSB8fCByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50WydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddIHx8IHJhbmdlWydAX0FwcGxpZWRGb250J107XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaGFzU3R5bGVJbmZvICYmIHJhbmdlQ29udGVudC50cmltKCkpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UpyBTdG9yeVBhcnNlciAtIEV4dHJhY3RpbmcgZm9ybWF0dGluZyBmb3IgcmFuZ2U6JywgSlNPTi5zdHJpbmdpZnkocmFuZ2VDb250ZW50LnN1YnN0cmluZygwLCAzMCkgKyAnLi4uJyksIHtcclxuICAgICAgICAgICAgICAgIHJhd1JhbmdlQXR0cmlidXRlczogT2JqZWN0LmtleXMocmFuZ2UpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnQF8nKSksXHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRGb3JtYXR0aW5nOiBmb3JtYXR0aW5nLFxyXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlRnJvbVhNTDogcmFuZ2VbJ0BfRm9udFN0eWxlJ10sXHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZUZyb21YTUw6IHJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddLFxyXG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGVGcm9tWE1MOiBlbGVtZW50WydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkRm9ybWF0dGluZyA9IHRoaXMuc3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZJWEVEOiBQcm9jZXNzIGNvbnRlbnQgd2l0aCBwcm9wZXIgc3BhY2UgcHJlc2VydmF0aW9uXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5Db250ZW50KSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudCA6IFtyYW5nZS5Db250ZW50XTtcclxuICAgICAgICAgICAgICBjb250ZW50cy5mb3JFYWNoKChjb250ZW50SXRlbSwgY29udGVudEluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gSURNTFV0aWxzLmRlY29kZVhNTEVudGl0aWVzKFN0cmluZyhjb250ZW50SXRlbSkpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBDaGVjayBmb3IgQnIgZWxlbWVudHMgQUZURVIgZWFjaCBjb250ZW50IGl0ZW0gd2l0aGluIHRoZSBzYW1lIHJhbmdlXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCAmJiBjb250ZW50SW5kZXggPCBjb250ZW50cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSAnXFxuJztcclxuICAgICAgICAgICAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzogeyBcclxuICAgICAgICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYmV0d2Vlbl9jb250ZW50JyxcclxuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ0JyIGVsZW1lbnQgd2l0aGluIHJhbmdlJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0xpbmUgYnJlYWsgZGV0ZWN0ZWQgd2l0aGluIGNvbnRlbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQ2hhcmFjdGVyU3R5bGVSYW5nZVske3JhbmdlSW5kZXh9XSwgYmV0d2VlbiBjb250ZW50WyR7Y29udGVudEluZGV4fV0gYW5kIGNvbnRlbnRbJHtjb250ZW50SW5kZXggKyAxfV1gLFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBCciBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSByYW5nZVxyXG4gICAgICAgICAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCAmJiAoIXJhbmdlLkNvbnRlbnQgfHwgQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA9PT0gZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgYnJFbGVtZW50cyA9IHRoaXMuZXh0cmFjdEJyRWxlbWVudHMocmFuZ2UpO1xyXG4gICAgICAgICAgICAgIGJyRWxlbWVudHMuZm9yRWFjaCgoYnJJbmZvLCBickluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gdGhpcy5kZXRlcm1pbmVMaW5lQnJlYWtUeXBlKGJySW5mbywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGxpbmVCcmVha1RleHQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHQsXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHsgXHJcbiAgICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6IGJySW5mby50eXBlIHx8ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYnJJbmZvLnBvc2l0aW9uIHx8ICdlbmQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ0JyIGVsZW1lbnQgYXQgZW5kIG9mIHJhbmdlJ1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnTGluZSBicmVhayBkZXRlY3RlZCBhdCBlbmQgb2YgcmFuZ2UnLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYENoYXJhY3RlclN0eWxlUmFuZ2VbJHtyYW5nZUluZGV4fV0sIEJyWyR7YnJJbmRleH1dYCxcclxuICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiBickluZm8udHlwZSB8fCAnbGluZScsXHJcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IEFkZCBzcGFjZSBiZXR3ZWVuIGNoYXJhY3RlciBzdHlsZSByYW5nZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChyYW5nZUluZGV4IDwgcmFuZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0UmFuZ2UgPSByYW5nZXNbcmFuZ2VJbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIE1vcmUgcm9idXN0IHNwYWNlIGRldGVjdGlvblxyXG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gY29udGVudC5zbGljZSgtMTApOyAvLyBDaGVjayBsYXN0IDEwIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlID0gL1xccyQvLnRlc3QoY3VycmVudFRleHQpOyAvLyBBbnkgd2hpdGVzcGFjZSBhdCBlbmRcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0Q29udGVudCA9IG5leHRSYW5nZS5Db250ZW50ID8gXHJcbiAgICAgICAgICAgICAgICBTdHJpbmcoQXJyYXkuaXNBcnJheShuZXh0UmFuZ2UuQ29udGVudCkgPyBuZXh0UmFuZ2UuQ29udGVudFswXSA6IG5leHRSYW5nZS5Db250ZW50KSA6ICcnO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSA9IC9eXFxzLy50ZXN0KG5leHRDb250ZW50KTsgLy8gQW55IHdoaXRlc3BhY2UgYXQgc3RhcnRcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBBR0dSRVNTSVZFIEZJWDogQWRkIHNwYWNlIGJldHdlZW4gQUxMIHJhbmdlcyB1bmxlc3MgZXhwbGljaXRseSBub3QgbmVlZGVkXHJcbiAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2tpcFNwYWNlID0gY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsocmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFuZXh0UmFuZ2UuQ29udGVudCB8fCAvLyBTa2lwIGlmIG5leHQgcmFuZ2UgaGFzIG5vIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb250ZW50LnRyaW0oKSA9PT0gJyc7IC8vIFNraXAgaWYgbmV4dCBjb250ZW50IGlzIG9ubHkgd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGlmICghc2hvdWxkU2tpcFNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGUgPSByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U3R5bGUgPSBuZXh0UmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFjZVRleHQgPSAnICc7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IHNwYWNlVGV4dDtcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHNwYWNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzU3BhY2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGUgcmFuZ2VzIChhZ2dyZXNzaXZlKScsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdHlsZVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnU3BhY2UgaW5zZXJ0ZWQgYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGVzIChhZ2dyZXNzaXZlKScsXHJcbiAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQmV0d2VlbiByYW5nZXMgJHtyYW5nZUluZGV4fSBhbmQgJHtyYW5nZUluZGV4ICsgMX1gLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgIG5leHRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgcmVhc29uOiAnRGVmYXVsdCBzcGFjZSBpbnNlcnRpb24gLSB3b3JkcyBsaWtlbHkgc3BsaXQgYWNyb3NzIHJhbmdlcycsXHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0RW5kOiBjdXJyZW50VGV4dC5zbGljZSgtNSksXHJcbiAgICAgICAgICAgICAgICAgIG5leHRUZXh0U3RhcnQ6IG5leHRDb250ZW50LnNsaWNlKDAsIDUpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnU3BhY2UgaW5zZXJ0aW9uIHNraXBwZWQnLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7cmFuZ2VJbmRleCArIDF9YCxcclxuICAgICAgICAgICAgICAgICAgcmVhc29uOiBjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlID8gJ0N1cnJlbnQgcmFuZ2UgZW5kcyB3aXRoIHNwYWNlJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJhbmdlU3RhcnRzV2l0aFNwYWNlID8gJ05leHQgcmFuZ2Ugc3RhcnRzIHdpdGggc3BhY2UnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAhbmV4dFJhbmdlLkNvbnRlbnQgPyAnTmV4dCByYW5nZSBoYXMgbm8gY29udGVudCcgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29udGVudC50cmltKCkgPT09ICcnID8gJ05leHQgY29udGVudCBpcyBvbmx5IHdoaXRlc3BhY2UnIDogJ0xpbmUgYnJlYWsgd291bGQgYmUgaW5zZXJ0ZWQnLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dEVuZDogY3VycmVudFRleHQuc2xpY2UoLTUpLFxyXG4gICAgICAgICAgICAgICAgICBuZXh0VGV4dFN0YXJ0OiBuZXh0Q29udGVudC5zbGljZSgwLCA1KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBleHBsaWNpdCBsaW5lIGJyZWFrcyBiZXR3ZWVuIHJhbmdlcyAoZm9yIGNhc2VzIHdoZXJlIHNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrIGlzIHRydWUpXHJcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsocmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltcGxpY2l0QnJlYWsgPSAnXFxuJztcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gaW1wbGljaXRCcmVhaztcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGltcGxpY2l0QnJlYWssXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogJ2ltcGxpY2l0JyxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdiZXR3ZWVuIHJhbmdlcydcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ0ltcGxpY2l0IGxpbmUgYnJlYWsnLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7cmFuZ2VJbmRleCArIDF9YFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgY29udGludWUgcHJvY2Vzc2luZyB0byBhdm9pZCBkdXBsaWNhdGlvblxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBFTkhBTkNFRDogSGFuZGxlIFBhcmFncmFwaFN0eWxlUmFuZ2Ugd2l0aCBjb250ZXh0XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2UpID8gXHJcbiAgICAgICAgICAgIGVsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZSA6IFtlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaENvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgLi4uY29udGV4dCxcclxuICAgICAgICAgICAgICBwYXJhZ3JhcGhJbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgdG90YWxQYXJhZ3JhcGhzOiByYW5nZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgIGFwcGxpZWRTdHlsZTogcmFuZ2VbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkocmFuZ2UsIGRlcHRoICsgMSwgcGFyYWdyYXBoQ29udGV4dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBZGQgcGFyYWdyYXBoIGJyZWFrIGJldHdlZW4gcGFyYWdyYXBocyAoYnV0IG5vdCBhZnRlciB0aGUgbGFzdCBvbmUpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHJhbmdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoQnJlYWsgPSAnXFxuJztcclxuICAgICAgICAgICAgICBjb250ZW50ICs9IHBhcmFncmFwaEJyZWFrO1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhZ3JhcGhCcmVhayxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiAncGFyYWdyYXBoJyxcclxuICAgICAgICAgICAgICAgICAgc291cmNlOiAnYmV0d2VlbiBwYXJhZ3JhcGhzJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHsgXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUGFyYWdyYXBoIGJyZWFrJywgXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogYGJldHdlZW4gcGFyYWdyYXBocyAke2luZGV4fSBhbmQgJHtpbmRleCArIDF9YCBcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEhhbmRsZSBkaXJlY3QgQ29udGVudCBlbGVtZW50cyAod2hlbiBub3QgaW5zaWRlIENoYXJhY3RlclN0eWxlUmFuZ2UpXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuQ29udGVudCAmJiAhZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlKSB7XHJcbiAgICAgICAgICBsZXQgdGV4dCA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5Db250ZW50KSA/IGVsZW1lbnQuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhlbGVtZW50LkNvbnRlbnQpO1xyXG4gICAgICAgICAgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyh0ZXh0KTtcclxuICAgICAgICAgIGNvbnRlbnQgKz0gdGV4dDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgY2hhcmFjdGVyU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udFNpemU6IGVsZW1lbnRbJ0BfUG9pbnRTaXplJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udEZhbWlseTogZWxlbWVudFsnQF9BcHBsaWVkRm9udCddIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogZWxlbWVudFsnQF9GaWxsQ29sb3InXSB8fCBudWxsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IHJlc29sdmVkRm9ybWF0dGluZyA9IHRoaXMuc3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IERpcmVjdCBCciBlbGVtZW50IGhhbmRsaW5nIChvdXRzaWRlIG9mIHJhbmdlcylcclxuICAgICAgICBpZiAoZWxlbWVudC5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zdCBickVsZW1lbnRzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkJyKSA/IGVsZW1lbnQuQnIgOiBbZWxlbWVudC5Ccl07XHJcbiAgICAgICAgICBickVsZW1lbnRzLmZvckVhY2goKGJyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gJ1xcbic7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0LFxyXG4gICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdleHBsaWNpdCcsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICdkaXJlY3QgQnIgZWxlbWVudCdcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0RpcmVjdCBCciBlbGVtZW50JyxcclxuICAgICAgICAgICAgICBsb2NhdGlvbjogYERpcmVjdCBlbGVtZW50LCBpbmRleCAke2luZGV4fWBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciBuZXN0ZWQgZWxlbWVudHNcclxuICAgICAgICBPYmplY3QuZW50cmllcyhlbGVtZW50KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJ0BfJykgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQ29udGVudCcgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQnInICYmIFxyXG4gICAgICAgICAgICAgIGtleSAhPT0gJ0NoYXJhY3RlclN0eWxlUmFuZ2UnICYmXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnUGFyYWdyYXBoU3R5bGVSYW5nZScpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChpdGVtID0+IGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkoaXRlbSwgZGVwdGggKyAxLCBjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBkZXB0aCA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgZXh0cmFjdFRleHRSZWN1cnNpdmVseSh2YWx1ZSwgZGVwdGggKyAxLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5KHN0b3J5RGF0YSk7XHJcbiAgICBcclxuICAgIC8vIEVOSEFOQ0VEOiBQcm9jZXNzIGFuZCBjbGVhbiB1cCB0aGUgY29udGVudCB3aXRoIHNvcGhpc3RpY2F0ZWQgbGluZSBicmVhayBwcmVzZXJ2YXRpb25cclxuICAgIGNvbnN0IHByb2Nlc3NlZENvbnRlbnQgPSBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmcoY29udGVudCk7XHJcbiAgICBcclxuICAgIC8vIERFQlVHOiBMb2cgc3BhY2UgcHJlc2VydmF0aW9uIHJlc3VsdHNcclxuICAgIGNvbnNvbGUubG9nKCfwn5OdIFRleHQgZXh0cmFjdGlvbiByZXN1bHRzOicpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gT3JpZ2luYWwgY29udGVudCBsZW5ndGg6JywgY29udGVudC5sZW5ndGgpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gUHJvY2Vzc2VkIGNvbnRlbnQgbGVuZ3RoOicsIHByb2Nlc3NlZENvbnRlbnQubGVuZ3RoKTtcclxuICAgIGNvbnNvbGUubG9nKCcgICAtIFNwYWNlIHByZXNlcnZhdGlvbiBldmVudHM6JywgZGVidWdJbmZvLmZpbHRlcihpbmZvID0+IGluZm8udHlwZS5pbmNsdWRlcygnU3BhY2UgaW5zZXJ0ZWQnKSkubGVuZ3RoKTtcclxuICAgIFxyXG4gICAgLy8gU1BFQ0lGSUMgREVCVUc6IENoZWNrIGZvciB0aGUgcHJvYmxlbWF0aWMgXCJwYXZvbHVwdHVzZGFcIiB0ZXh0IChzaW1wbGlmaWVkKVxyXG4gICAgaWYgKHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3Bhdm9sdXB0dXNkYScpIHx8IHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3BhJykgJiYgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygndm9sdXB0dXNkYScpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qoIEZPVU5EIFBST0JMRU1BVElDIFRFWFQ6Jyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIENvbnRhaW5zIFwicGF2b2x1cHR1c2RhXCI6JywgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBDb250YWlucyBcInBhIHZvbHVwdHVzZGFcIjonLCBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCdwYSB2b2x1cHR1c2RhJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBGb3JtYXR0ZWRDb250ZW50IGJyZWFrZG93bjonLCBmb3JtYXR0ZWRDb250ZW50Lm1hcChpdGVtID0+IGl0ZW0udGV4dCkuam9pbignfCcpKTtcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIFxyXG4gICAgY29uc3QgbGluZUJyZWFrSW5mbyA9IHtcclxuICAgICAgaGFzTGluZUJyZWFrczogcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygnXFxuJyksXHJcbiAgICAgIGxpbmVCcmVha0NvdW50OiAocHJvY2Vzc2VkQ29udGVudC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGgsXHJcbiAgICAgIGxpbmVCcmVha1R5cGVzOiB0aGlzLmFuYWx5emVMaW5lQnJlYWtUeXBlcyhmb3JtYXR0ZWRDb250ZW50KSxcclxuICAgICAgZGVidWdJbmZvOiBkZWJ1Z0luZm8sXHJcbiAgICAgIHNwYWNlUHJlc2VydmF0aW9uQ291bnQ6IGRlYnVnSW5mby5maWx0ZXIoaW5mbyA9PiBpbmZvLnR5cGUuaW5jbHVkZXMoJ1NwYWNlIGluc2VydGVkJykpLmxlbmd0aFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGxhaW5UZXh0OiBwcm9jZXNzZWRDb250ZW50LFxyXG4gICAgICBmb3JtYXR0ZWRDb250ZW50OiBmb3JtYXR0ZWRDb250ZW50LmZpbHRlcihpdGVtID0+IGl0ZW0udGV4dCAmJiBpdGVtLnRleHQubGVuZ3RoID4gMCksXHJcbiAgICAgIHdvcmRDb3VudDogSURNTFV0aWxzLmNvdW50V29yZHMocHJvY2Vzc2VkQ29udGVudC5yZXBsYWNlKC9cXG4vZywgJyAnKSksXHJcbiAgICAgIGNoYXJhY3RlckNvdW50OiBwcm9jZXNzZWRDb250ZW50Lmxlbmd0aCxcclxuICAgICAgdGV4dENvbG9yOiB0ZXh0Q29sb3IsXHJcbiAgICAgIGxpbmVCcmVha0luZm86IGxpbmVCcmVha0luZm9cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgdGhpcyBoZWxwZXIgbWV0aG9kIHRvIGJldHRlciBoYW5kbGUgbWl4ZWQgY29udGVudCBhbmQgQnIgZWxlbWVudHNcclxuICBhbmFseXplQ29udGVudFN0cnVjdHVyZShyYW5nZSkge1xyXG4gICAgY29uc3Qgc3RydWN0dXJlID0ge1xyXG4gICAgICBoYXNDb250ZW50OiAhIXJhbmdlLkNvbnRlbnQsXHJcbiAgICAgIGhhc0JyOiByYW5nZS5CciAhPT0gdW5kZWZpbmVkLFxyXG4gICAgICBjb250ZW50SXRlbXM6IHJhbmdlLkNvbnRlbnQgPyAoQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA/IHJhbmdlLkNvbnRlbnQgOiBbcmFuZ2UuQ29udGVudF0pIDogW10sXHJcbiAgICAgIGJyRWxlbWVudHM6IHJhbmdlLkJyID8gKEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpID8gcmFuZ2UuQnIgOiBbcmFuZ2UuQnJdKSA6IFtdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQ29udGVudCBzdHJ1Y3R1cmUgYW5hbHlzaXM6Jywgc3RydWN0dXJlKTtcclxuICAgIHJldHVybiBzdHJ1Y3R1cmU7XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBoZWxwZXIgZm9yIHByb2Nlc3NpbmcgaW50ZXJsZWF2ZWQgY29udGVudCBhbmQgYnJlYWtzXHJcbiAgcHJvY2Vzc0ludGVybGVhdmVkQ29udGVudChyYW5nZSwgcmVzb2x2ZWRGb3JtYXR0aW5nKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgXHJcbiAgICAvLyBUaGlzIG1ldGhvZCB3b3VsZCBuZWVkIGFjY2VzcyB0byB0aGUgYWN0dWFsIFhNTCBzdHJ1Y3R1cmUgdG8gZGV0ZXJtaW5lXHJcbiAgICAvLyB0aGUgZXhhY3Qgb3JkZXIgb2YgQ29udGVudCBhbmQgQnIgZWxlbWVudHMuIEZvciBub3csIHdlJ2xsIHVzZSB0aGUgXHJcbiAgICAvLyBhcHByb2FjaCBhYm92ZSB3aGljaCBoYW5kbGVzIHRoZSBtb3N0IGNvbW1vbiBjYXNlLlxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEhlbHBlciBtZXRob2QgdG8gZXh0cmFjdCBCciBlbGVtZW50cyB3aXRoIGNvbnRleHRcclxuICBleHRyYWN0QnJFbGVtZW50cyhyYW5nZSkge1xyXG4gICAgY29uc3QgYnJFbGVtZW50cyA9IFtdO1xyXG4gICAgXHJcbiAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyYW5nZS5CcikpIHtcclxuICAgICAgICByYW5nZS5Cci5mb3JFYWNoKChiciwgaW5kZXgpID0+IHtcclxuICAgICAgICAgIGJyRWxlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgcG9zaXRpb246IGluZGV4ID09PSAwID8gJ3N0YXJ0JyA6ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICBlbGVtZW50OiBiclxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJFbGVtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJyxcclxuICAgICAgICAgIGVsZW1lbnQ6IHJhbmdlLkJyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGJyRWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGxpbmUgYnJlYWsgdHlwZVxyXG4gIGRldGVybWluZUxpbmVCcmVha1R5cGUoYnJJbmZvLCBjb250ZXh0KSB7XHJcbiAgICAvLyBEaWZmZXJlbnQgbGluZSBicmVhayBjaGFyYWN0ZXJzIGJhc2VkIG9uIGNvbnRleHRcclxuICAgIHN3aXRjaCAoYnJJbmZvLnR5cGUpIHtcclxuICAgICAgY2FzZSAncGFyYWdyYXBoJzpcclxuICAgICAgICByZXR1cm4gJ1xcblxcbic7IC8vIERvdWJsZSBsaW5lIGJyZWFrIGZvciBwYXJhZ3JhcGggc2VwYXJhdGlvblxyXG4gICAgICBjYXNlICdmb3JjZWQnOlxyXG4gICAgICAgIHJldHVybiAnXFxuJzsgLy8gRm9yY2VkIGxpbmUgYnJlYWsgKFNoaWZ0K0VudGVyIGVxdWl2YWxlbnQpXHJcbiAgICAgIGNhc2UgJ2xpbmUnOlxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAnXFxuJzsgLy8gU3RhbmRhcmQgbGluZSBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogRGV0ZXJtaW5lIGlmIGFuIGltcGxpY2l0IGxpbmUgYnJlYWsgc2hvdWxkIGJlIGluc2VydGVkXHJcbiAgc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsoY3VycmVudFJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpIHtcclxuICAgIC8vIERvbid0IGluc2VydCBpbXBsaWNpdCBicmVha3MgaWYgZXhwbGljaXQgQnIgZWxlbWVudHMgYXJlIHByZXNlbnRcclxuICAgIGlmIChjdXJyZW50UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCB8fCBuZXh0UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEluc2VydCBicmVha3MgYmV0d2VlbiBkaWZmZXJlbnQgY2hhcmFjdGVyIHN0eWxlcyBpbiBkaWZmZXJlbnQgcGFyYWdyYXBoc1xyXG4gICAgY29uc3QgY3VycmVudENoYXJTdHlsZSA9IGN1cnJlbnRSYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXTtcclxuICAgIGNvbnN0IG5leHRDaGFyU3R5bGUgPSBuZXh0UmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ107XHJcbiAgICBcclxuICAgIC8vIElmIHdlJ3JlIGluIGEgY29udGV4dCB3aGVyZSBzdHlsZXMgY2hhbmdlIHNpZ25pZmljYW50bHksIGFkZCBhIGJyZWFrXHJcbiAgICBpZiAoY3VycmVudENoYXJTdHlsZSAmJiBuZXh0Q2hhclN0eWxlICYmIGN1cnJlbnRDaGFyU3R5bGUgIT09IG5leHRDaGFyU3R5bGUpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBtaWdodCBiZSBhIHRpdGxlL2hlYWRpbmcgZm9sbG93ZWQgYnkgYm9keSB0ZXh0XHJcbiAgICAgIGNvbnN0IHN0eWxlSW5kaWNhdGVzQnJlYWsgPSB0aGlzLnN0eWxlSW5kaWNhdGVzTGluZUJyZWFrKGN1cnJlbnRDaGFyU3R5bGUsIG5leHRDaGFyU3R5bGUpO1xyXG4gICAgICByZXR1cm4gc3R5bGVJbmRpY2F0ZXNCcmVhaztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogQW5hbHl6ZSBpZiBzdHlsZSBjaGFuZ2UgaW5kaWNhdGVzIGEgbGluZSBicmVha1xyXG4gIHN0eWxlSW5kaWNhdGVzTGluZUJyZWFrKGN1cnJlbnRTdHlsZSwgbmV4dFN0eWxlKSB7XHJcbiAgICBjb25zdCB0aXRsZUluZGljYXRvcnMgPSBbJ3RpdGxlJywgJ2hlYWRpbmcnLCAnaGVhZGVyJ107XHJcbiAgICBjb25zdCBib2R5SW5kaWNhdG9ycyA9IFsnYm9keScsICd0ZXh0JywgJ25vcm1hbCddO1xyXG4gICAgXHJcbiAgICBjb25zdCBjdXJyZW50SXNUaXRsZSA9IHRpdGxlSW5kaWNhdG9ycy5zb21lKGluZGljYXRvciA9PiBcclxuICAgICAgY3VycmVudFN0eWxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5kaWNhdG9yKSk7XHJcbiAgICBjb25zdCBuZXh0SXNCb2R5ID0gYm9keUluZGljYXRvcnMuc29tZShpbmRpY2F0b3IgPT4gXHJcbiAgICAgIG5leHRTdHlsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGluZGljYXRvcikpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gY3VycmVudElzVGl0bGUgJiYgbmV4dElzQm9keTtcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEFuYWx5emUgbGluZSBicmVhayB0eXBlcyBpbiBmb3JtYXR0ZWQgY29udGVudFxyXG4gIGFuYWx5emVMaW5lQnJlYWtUeXBlcyhmb3JtYXR0ZWRDb250ZW50KSB7XHJcbiAgICBjb25zdCB0eXBlcyA9IHtcclxuICAgICAgZXhwbGljaXQ6IDAsICAgICAgLy8gRnJvbSA8QnIvPiBlbGVtZW50c1xyXG4gICAgICBpbXBsaWNpdDogMCwgICAgICAvLyBJbmZlcnJlZCBmcm9tIHN0eWxlIGNoYW5nZXNcclxuICAgICAgcGFyYWdyYXBoOiAwLCAgICAgLy8gQmV0d2VlbiBwYXJhZ3JhcGhzXHJcbiAgICAgIGRpcmVjdDogMCAgICAgICAgLy8gRGlyZWN0IEJyIGVsZW1lbnRzXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmb3JtYXR0ZWRDb250ZW50LmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGlmIChpdGVtLmZvcm1hdHRpbmc/LmlzQnJlYWspIHtcclxuICAgICAgICBjb25zdCBicmVha1R5cGUgPSBpdGVtLmZvcm1hdHRpbmcuYnJlYWtUeXBlIHx8ICd1bmtub3duJztcclxuICAgICAgICBpZiAodHlwZXMuaGFzT3duUHJvcGVydHkoYnJlYWtUeXBlKSkge1xyXG4gICAgICAgICAgdHlwZXNbYnJlYWtUeXBlXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB0eXBlcztcclxuICB9XHJcblxyXG4gIGV4dHJhY3REZXRhaWxlZEZvcm1hdHRpbmdGcm9tUmFuZ2UocmFuZ2UpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7fTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBhbGwgcG9zc2libGUgZm9udCBhdHRyaWJ1dGVzXHJcbiAgICBjb25zdCBmb250QXR0cmlidXRlcyA9IFtcclxuICAgICAgJ0BfQXBwbGllZEZvbnQnLCAnQF9Gb250RmFtaWx5JywgJ0BfRm9udCcsIFxyXG4gICAgICAnQF9Qb3N0U2NyaXB0TmFtZScsICdAX0ZvbnROYW1lJ1xyXG4gICAgXTtcclxuICAgIFxyXG4gICAgZm9udEF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHtcclxuICAgICAgaWYgKHJhbmdlW2F0dHJdKSB7XHJcbiAgICAgICAgZm9ybWF0dGluZy5mb250UmVmZXJlbmNlID0gcmFuZ2VbYXR0cl07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGZvbnQgYW5kIHNpemUgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy5mb250U2l6ZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfUG9pbnRTaXplJ10pO1xyXG4gICAgXHJcbiAgICAvLyBFTkhBTkNFRDogRXh0cmFjdCBsZWFkaW5nIHdpdGggcHJvcGVyIHByb2Nlc3NpbmdcclxuICAgIGNvbnN0IHJhd0xlYWRpbmcgPSByYW5nZVsnQF9MZWFkaW5nJ107XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmcgPSB0aGlzLnByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9ybWF0dGluZy5mb250U2l6ZSk7XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmdUeXBlID0gdGhpcy5kZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBjb2xvciBhbmQgc3R5bGUgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy5maWxsQ29sb3IgPSByYW5nZVsnQF9GaWxsQ29sb3InXTtcclxuICAgIGZvcm1hdHRpbmcuc3Ryb2tlQ29sb3IgPSByYW5nZVsnQF9TdHJva2VDb2xvciddO1xyXG4gICAgZm9ybWF0dGluZy5mb250U3R5bGUgPSByYW5nZVsnQF9Gb250U3R5bGUnXTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBhZHZhbmNlZCB0eXBvZ3JhcGh5IGF0dHJpYnV0ZXNcclxuICAgIGZvcm1hdHRpbmcudHJhY2tpbmcgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1RyYWNraW5nJ10pO1xyXG4gICAgZm9ybWF0dGluZy5iYXNlbGluZVNoaWZ0ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9CYXNlbGluZVNoaWZ0J10pO1xyXG4gICAgZm9ybWF0dGluZy5rZXJuaW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9LZXJuaW5nJ10pO1xyXG4gICAgZm9ybWF0dGluZy5ob3Jpem9udGFsU2NhbGUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0hvcml6b250YWxTY2FsZSddKSB8fCAxMDA7XHJcbiAgICBmb3JtYXR0aW5nLnZlcnRpY2FsU2NhbGUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1ZlcnRpY2FsU2NhbGUnXSkgfHwgMTAwO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IHBhcmFncmFwaC1sZXZlbCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcclxuICAgIC8vIENSSVRJQ0FMIEZJWDogT25seSBzZXQgYWxpZ25tZW50IGlmIGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBhbGxvd2luZyBwYXJhZ3JhcGggaW5oZXJpdGFuY2VcclxuICAgIGNvbnN0IGV4cGxpY2l0QWxpZ25tZW50ID0gcmFuZ2VbJ0BfSnVzdGlmaWNhdGlvbiddIHx8IHJhbmdlWydAX0FsaWdubWVudCddO1xyXG4gICAgaWYgKGV4cGxpY2l0QWxpZ25tZW50ICYmIGV4cGxpY2l0QWxpZ25tZW50ICE9PSAnTGVmdEFsaWduJykge1xyXG4gICAgICBmb3JtYXR0aW5nLmFsaWdubWVudCA9IGV4cGxpY2l0QWxpZ25tZW50O1xyXG4gICAgfVxyXG4gICAgZm9ybWF0dGluZy5sZWZ0SW5kZW50ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9MZWZ0SW5kZW50J10pO1xyXG4gICAgZm9ybWF0dGluZy5yaWdodEluZGVudCA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfUmlnaHRJbmRlbnQnXSk7XHJcbiAgICBmb3JtYXR0aW5nLmZpcnN0TGluZUluZGVudCA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfRmlyc3RMaW5lSW5kZW50J10pO1xyXG4gICAgZm9ybWF0dGluZy5zcGFjZUJlZm9yZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfU3BhY2VCZWZvcmUnXSk7XHJcbiAgICBmb3JtYXR0aW5nLnNwYWNlQWZ0ZXIgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1NwYWNlQWZ0ZXInXSk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgZm9yIENTU1xyXG4gICAgZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KGZvcm1hdHRpbmcpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZm9ybWF0dGluZztcclxuICB9XHJcblxyXG4gIC8vIE5FVzogUHJvY2VzcyBsZWFkaW5nIHZhbHVlcyB3aXRoIEluRGVzaWduLXNwZWNpZmljIGxvZ2ljXHJcbiAgcHJvY2Vzc0xlYWRpbmdWYWx1ZShyYXdMZWFkaW5nLCBmb250U2l6ZSkge1xyXG4gICAgaWYgKCFyYXdMZWFkaW5nKSByZXR1cm4gJ2F1dG8nO1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgXCJhdXRvXCIgbGVhZGluZ1xyXG4gICAgaWYgKHJhd0xlYWRpbmcgPT09ICdhdXRvJyB8fCByYXdMZWFkaW5nID09PSAnQXV0bycpIHtcclxuICAgICAgcmV0dXJuIGZvbnRTaXplID8gZm9udFNpemUgKiAxLjIgOiAnYXV0byc7IC8vIEluRGVzaWduIGRlZmF1bHQgYXV0byBsZWFkaW5nIGlzIDEyMCVcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIG51bWVyaWMgbGVhZGluZyAoaW4gcG9pbnRzKVxyXG4gICAgY29uc3QgbnVtZXJpY0xlYWRpbmcgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhd0xlYWRpbmcpO1xyXG4gICAgaWYgKG51bWVyaWNMZWFkaW5nKSB7XHJcbiAgICAgIHJldHVybiBudW1lcmljTGVhZGluZztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIHBlcmNlbnRhZ2UtYmFzZWQgbGVhZGluZ1xyXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoJyUnKSkge1xyXG4gICAgICBjb25zdCBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChyYXdMZWFkaW5nLnJlcGxhY2UoJyUnLCAnJykpO1xyXG4gICAgICByZXR1cm4gZm9udFNpemUgPyAoZm9udFNpemUgKiBwZXJjZW50YWdlIC8gMTAwKSA6ICdhdXRvJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuICdhdXRvJztcclxuICB9XHJcblxyXG4gIC8vIE5FVzogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGxlYWRpbmcgYmVpbmcgdXNlZFxyXG4gIGRldGVybWluZUxlYWRpbmdUeXBlKHJhd0xlYWRpbmcpIHtcclxuICAgIGlmICghcmF3TGVhZGluZyB8fCByYXdMZWFkaW5nID09PSAnYXV0bycgfHwgcmF3TGVhZGluZyA9PT0gJ0F1dG8nKSB7XHJcbiAgICAgIHJldHVybiAnYXV0byc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChyYXdMZWFkaW5nLmluY2x1ZGVzKCclJykpIHtcclxuICAgICAgcmV0dXJuICdwZXJjZW50YWdlJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKElETUxVdGlscy5wYXJzZU51bWVyaWMocmF3TGVhZGluZykpIHtcclxuICAgICAgcmV0dXJuICdhYnNvbHV0ZSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAndW5rbm93bic7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IENhbGN1bGF0ZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgZm9yIENTUyByZW5kZXJpbmdcclxuICBjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KGZvcm1hdHRpbmcpIHtcclxuICAgIGNvbnN0IGZvbnRTaXplID0gZm9ybWF0dGluZy5mb250U2l6ZSB8fCAxMjtcclxuICAgIGNvbnN0IGxlYWRpbmcgPSBmb3JtYXR0aW5nLmxlYWRpbmc7XHJcbiAgICBcclxuICAgIGlmIChsZWFkaW5nID09PSAnYXV0bycpIHtcclxuICAgICAgcmV0dXJuIDEuMjsgLy8gQ1NTIGxpbmUtaGVpZ2h0IHJhdGlvIGZvciBhdXRvXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0eXBlb2YgbGVhZGluZyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgLy8gQ29udmVydCBwb2ludHMgdG8gQ1NTIGxpbmUtaGVpZ2h0IHJhdGlvXHJcbiAgICAgIHJldHVybiBsZWFkaW5nIC8gZm9udFNpemU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAxLjI7IC8vIEZhbGxiYWNrXHJcbiAgfVxyXG5cclxuICBleHRyYWN0VGV4dEZvcm1hdHRpbmcoc3RvcnlEYXRhKSB7XHJcbiAgICBjb25zdCBmb3JtYXR0aW5nID0ge1xyXG4gICAgICBwYXJhZ3JhcGhTdHlsZXM6IFtdLFxyXG4gICAgICBjaGFyYWN0ZXJTdHlsZXM6IFtdLFxyXG4gICAgICBhcHBsaWVkU3R5bGVzOiBbXVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBhcHBsaWVkIHBhcmFncmFwaCBzdHlsZXNcclxuICAgIGlmIChzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZSkge1xyXG4gICAgICBjb25zdCByYW5nZXMgPSBBcnJheS5pc0FycmF5KHN0b3J5RGF0YS5QYXJhZ3JhcGhTdHlsZVJhbmdlKSA/IHN0b3J5RGF0YS5QYXJhZ3JhcGhTdHlsZVJhbmdlIDogW3N0b3J5RGF0YS5QYXJhZ3JhcGhTdHlsZVJhbmdlXTtcclxuICAgICAgXHJcbiAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcclxuICAgICAgICBjb25zdCBhcHBsaWVkU3R5bGUgPSByYW5nZVsnQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGUnXTtcclxuICAgICAgICBpZiAoYXBwbGllZFN0eWxlICYmICFmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlcy5pbmNsdWRlcyhhcHBsaWVkU3R5bGUpKSB7XHJcbiAgICAgICAgICBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlcy5wdXNoKGFwcGxpZWRTdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEV4dHJhY3QgY2hhcmFjdGVyIHN0eWxlcyB3aXRoaW4gcGFyYWdyYXBoIHJhbmdlc1xyXG4gICAgICAgIGlmIChyYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlKSB7XHJcbiAgICAgICAgICBjb25zdCBjaGFyUmFuZ2VzID0gQXJyYXkuaXNBcnJheShyYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlKSA/IHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2UgOiBbcmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZV07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNoYXJSYW5nZXMuZm9yRWFjaChjaGFyUmFuZ2UgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFyU3R5bGUgPSBjaGFyUmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ107XHJcbiAgICAgICAgICAgIGlmIChjaGFyU3R5bGUgJiYgIWZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVzLmluY2x1ZGVzKGNoYXJTdHlsZSkpIHtcclxuICAgICAgICAgICAgICBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlcy5wdXNoKGNoYXJTdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBmb3JtYXR0aW5nO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHRoaXMgbWV0aG9kIHRvIGRlYnVnIHJhdyBzdG9yeSBjb250ZW50XHJcbiAgZGVidWdSYXdTdG9yeUNvbnRlbnQoc3RvcnlEYXRhKSB7XHJcbiAgICBjb25zb2xlLmxvZygnXFxu8J+UjSBSQVcgU1RPUlkgQ09OVEVOVCBERUJVRzonKTtcclxuICAgIGNvbnNvbGUubG9nKCdTdG9yeSBrZXlzOicsIE9iamVjdC5rZXlzKHN0b3J5RGF0YSkpO1xyXG4gICAgXHJcbiAgICBjb25zdCBmaW5kQ2hhcmFjdGVyUmFuZ2VzID0gKG9iaiwgcGF0aCA9ICcnKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgIGlmIChrZXkgPT09ICdDaGFyYWN0ZXJTdHlsZVJhbmdlJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgXFxu8J+TnSBGb3VuZCBDaGFyYWN0ZXJTdHlsZVJhbmdlIGF0ICR7cGF0aH06YCwgb2JqW2tleV0pO1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZXMgPSBBcnJheS5pc0FycmF5KG9ialtrZXldKSA/IG9ialtrZXldIDogW29ialtrZXldXTtcclxuICAgICAgICAgICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgIFJhbmdlICR7aW5kZXggKyAxfSBhdHRyaWJ1dGVzOmAsIFxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmFuZ2UpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnQF8nKSlcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgIFJhbmdlICR7aW5kZXggKyAxfSBmb250IGluZm86YCwge1xyXG4gICAgICAgICAgICAgICAgQXBwbGllZEZvbnQ6IHJhbmdlWydAX0FwcGxpZWRGb250J10sXHJcbiAgICAgICAgICAgICAgICBGb250U3R5bGU6IHJhbmdlWydAX0ZvbnRTdHlsZSddLFxyXG4gICAgICAgICAgICAgICAgUG9pbnRTaXplOiByYW5nZVsnQF9Qb2ludFNpemUnXVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBmaW5kQ2hhcmFjdGVyUmFuZ2VzKG9ialtrZXldLCBgJHtwYXRofS4ke2tleX1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZmluZENoYXJhY3RlclJhbmdlcyhzdG9yeURhdGEpO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3RvcmllcygpIHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JpZXM7XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yeShzdG9yeUlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdG9yaWVzW3N0b3J5SWRdO1xyXG4gIH1cclxuXHJcbiAgY2xlYXJTdG9yaWVzKCkge1xyXG4gICAgdGhpcy5zdG9yaWVzID0ge307XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3J5UGFyc2VyOyAiXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJJRE1MVXRpbHMiLCJTdG9yeVBhcnNlciIsInBhcnNlU3RvcnlGaWxlIiwiZmlsZU5hbWUiLCJjb250ZW50IiwieG1sUGFyc2VyIiwiY29uc29sZSIsImxvZyIsInBhcnNlZCIsInBhcnNlIiwic3RvcnlJZCIsImJhc2VuYW1lIiwic3RvcnlEYXRhIiwiU3RvcnkiLCJPYmplY3QiLCJrZXlzIiwiSlNPTiIsInN0cmluZ2lmeSIsInN1YnN0cmluZyIsImRldGFpbGVkU3RvcnkiLCJzZWxmIiwiYXBwbGllZFRPQ1N0eWxlIiwidXNlclRleHQiLCJleHRyYWN0RGV0YWlsZWRTdG9yeUNvbnRlbnQiLCJ0ZXh0Rm9ybWF0dGluZyIsImV4dHJhY3RUZXh0Rm9ybWF0dGluZyIsImNsZWFuU3RvcnlJZCIsInJlcGxhY2UiLCJzdG9yaWVzIiwicGxhaW5UZXh0IiwibGluZUJyZWFrSW5mbyIsImxlbmd0aCIsIndvcmRDb3VudCIsImxpbmVCcmVha0NvdW50IiwiZXJyb3IiLCJtZXNzYWdlIiwiZm9ybWF0dGVkQ29udGVudCIsInRleHRDb2xvciIsImRlYnVnSW5mbyIsImV4dHJhY3RUZXh0UmVjdXJzaXZlbHkiLCJlbGVtZW50IiwiZGVwdGgiLCJjb250ZXh0IiwiQ2hhcmFjdGVyU3R5bGVSYW5nZSIsInJhbmdlcyIsIkFycmF5IiwiaXNBcnJheSIsImFsbFJhbmdlQ29udGVudCIsIm1hcCIsInIiLCJDb250ZW50Iiwiam9pbiIsIlN0cmluZyIsImluY2x1ZGVzIiwiZm9yRWFjaCIsInJhbmdlIiwiaW5kZXgiLCJyYW5nZUluZGV4IiwiZGlyZWN0Rm9udFJlZiIsImZvcm1hdHRpbmciLCJwYXJhZ3JhcGhTdHlsZSIsImNoYXJhY3RlclN0eWxlIiwiZm9udFNpemUiLCJwYXJzZUZsb2F0IiwiZm9udFJlZmVyZW5jZSIsImZpbGxDb2xvciIsImZvbnRTdHlsZSIsInJhbmdlQ29udGVudCIsImhhc1N0eWxlSW5mbyIsInRyaW0iLCJyYXdSYW5nZUF0dHJpYnV0ZXMiLCJmaWx0ZXIiLCJrIiwic3RhcnRzV2l0aCIsImV4dHJhY3RlZEZvcm1hdHRpbmciLCJmb250U3R5bGVGcm9tWE1MIiwiY2hhcmFjdGVyU3R5bGVGcm9tWE1MIiwicGFyYWdyYXBoU3R5bGVGcm9tWE1MIiwicmVzb2x2ZWRGb3JtYXR0aW5nIiwic3R5bGVQYXJzZXIiLCJyZXNvbHZlU3R5bGVGb3JtYXR0aW5nIiwiY29udGVudHMiLCJjb250ZW50SXRlbSIsImNvbnRlbnRJbmRleCIsInRleHQiLCJkZWNvZGVYTUxFbnRpdGllcyIsInB1c2giLCJCciIsInVuZGVmaW5lZCIsImxpbmVCcmVha1RleHQiLCJpc0JyZWFrIiwiYnJlYWtUeXBlIiwicG9zaXRpb24iLCJzb3VyY2UiLCJ0eXBlIiwibG9jYXRpb24iLCJickVsZW1lbnRzIiwiZXh0cmFjdEJyRWxlbWVudHMiLCJickluZm8iLCJickluZGV4IiwiZGV0ZXJtaW5lTGluZUJyZWFrVHlwZSIsIm5leHRSYW5nZSIsImN1cnJlbnRUZXh0Iiwic2xpY2UiLCJjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlIiwidGVzdCIsIm5leHRDb250ZW50IiwibmV4dFJhbmdlU3RhcnRzV2l0aFNwYWNlIiwic2hvdWxkU2tpcFNwYWNlIiwic2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsiLCJjdXJyZW50U3R5bGUiLCJuZXh0U3R5bGUiLCJzcGFjZVRleHQiLCJpc1NwYWNlIiwicmVhc29uIiwiY3VycmVudFRleHRFbmQiLCJuZXh0VGV4dFN0YXJ0IiwiaW1wbGljaXRCcmVhayIsIlBhcmFncmFwaFN0eWxlUmFuZ2UiLCJwYXJhZ3JhcGhDb250ZXh0IiwicGFyYWdyYXBoSW5kZXgiLCJ0b3RhbFBhcmFncmFwaHMiLCJhcHBsaWVkU3R5bGUiLCJwYXJhZ3JhcGhCcmVhayIsImZvbnRGYW1pbHkiLCJiciIsImVudHJpZXMiLCJrZXkiLCJ2YWx1ZSIsIml0ZW0iLCJwcm9jZXNzZWRDb250ZW50Iiwic29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmciLCJpbmZvIiwiaGFzTGluZUJyZWFrcyIsIm1hdGNoIiwibGluZUJyZWFrVHlwZXMiLCJhbmFseXplTGluZUJyZWFrVHlwZXMiLCJzcGFjZVByZXNlcnZhdGlvbkNvdW50IiwiY291bnRXb3JkcyIsImNoYXJhY3RlckNvdW50IiwiYW5hbHl6ZUNvbnRlbnRTdHJ1Y3R1cmUiLCJzdHJ1Y3R1cmUiLCJoYXNDb250ZW50IiwiaGFzQnIiLCJjb250ZW50SXRlbXMiLCJwcm9jZXNzSW50ZXJsZWF2ZWRDb250ZW50IiwicmVzdWx0cyIsImN1cnJlbnRSYW5nZSIsImN1cnJlbnRDaGFyU3R5bGUiLCJuZXh0Q2hhclN0eWxlIiwic3R5bGVJbmRpY2F0ZXNCcmVhayIsInN0eWxlSW5kaWNhdGVzTGluZUJyZWFrIiwidGl0bGVJbmRpY2F0b3JzIiwiYm9keUluZGljYXRvcnMiLCJjdXJyZW50SXNUaXRsZSIsInNvbWUiLCJpbmRpY2F0b3IiLCJ0b0xvd2VyQ2FzZSIsIm5leHRJc0JvZHkiLCJ0eXBlcyIsImV4cGxpY2l0IiwiaW1wbGljaXQiLCJwYXJhZ3JhcGgiLCJkaXJlY3QiLCJoYXNPd25Qcm9wZXJ0eSIsImV4dHJhY3REZXRhaWxlZEZvcm1hdHRpbmdGcm9tUmFuZ2UiLCJmb250QXR0cmlidXRlcyIsImF0dHIiLCJwYXJzZU51bWVyaWMiLCJyYXdMZWFkaW5nIiwibGVhZGluZyIsInByb2Nlc3NMZWFkaW5nVmFsdWUiLCJsZWFkaW5nVHlwZSIsImRldGVybWluZUxlYWRpbmdUeXBlIiwic3Ryb2tlQ29sb3IiLCJ0cmFja2luZyIsImJhc2VsaW5lU2hpZnQiLCJrZXJuaW5nIiwiaG9yaXpvbnRhbFNjYWxlIiwidmVydGljYWxTY2FsZSIsImV4cGxpY2l0QWxpZ25tZW50IiwiYWxpZ25tZW50IiwibGVmdEluZGVudCIsInJpZ2h0SW5kZW50IiwiZmlyc3RMaW5lSW5kZW50Iiwic3BhY2VCZWZvcmUiLCJzcGFjZUFmdGVyIiwiZWZmZWN0aXZlTGluZUhlaWdodCIsImNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJudW1lcmljTGVhZGluZyIsInBlcmNlbnRhZ2UiLCJwYXJhZ3JhcGhTdHlsZXMiLCJjaGFyYWN0ZXJTdHlsZXMiLCJhcHBsaWVkU3R5bGVzIiwiY2hhclJhbmdlcyIsImNoYXJSYW5nZSIsImNoYXJTdHlsZSIsImRlYnVnUmF3U3RvcnlDb250ZW50IiwiZmluZENoYXJhY3RlclJhbmdlcyIsIm9iaiIsIkFwcGxpZWRGb250IiwiRm9udFN0eWxlIiwiUG9pbnRTaXplIiwiZ2V0U3RvcmllcyIsImdldFN0b3J5IiwiY2xlYXJTdG9yaWVzIiwiY29uc3RydWN0b3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/parsers/StoryParser.js\n"));

/***/ })

});