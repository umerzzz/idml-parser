"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/ElementParser.js":
/*!**************************************!*\
  !*** ./lib/parsers/ElementParser.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass ElementParser {\n    extractSpreadPages(spreadData) {\n        const pages = [];\n        if (spreadData.Page) {\n            const pageList = Array.isArray(spreadData.Page) ? spreadData.Page : [\n                spreadData.Page\n            ];\n            pageList.forEach((page, index)=>{\n                pages.push({\n                    self: page[\"@_Self\"],\n                    name: page[\"@_Name\"] || \"\",\n                    appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                    geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                    itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"])\n                });\n            });\n        } else {\n            console.log(\"No pages found in spread data\");\n        }\n        console.log(\"Extracted \".concat(pages.length, \" pages\"));\n        return pages;\n    }\n    extractPageItems(spreadData) {\n        const pageItems = [];\n        // Extract different types of page items\n        const itemTypes = [\n            \"Rectangle\",\n            \"Oval\",\n            \"Polygon\",\n            \"GraphicLine\",\n            \"TextFrame\",\n            \"Group\",\n            \"Button\",\n            \"Table\",\n            \"Image\",\n            \"EPS\",\n            \"PDF\",\n            \"PlacedItem\",\n            \"ContentFrame\" // Add these\n        ];\n        itemTypes.forEach((itemType)=>{\n            if (spreadData[itemType]) {\n                const items = Array.isArray(spreadData[itemType]) ? spreadData[itemType] : [\n                    spreadData[itemType]\n                ];\n                items.forEach((item)=>{\n                    console.log(\"Processing \".concat(itemType, \":\"), item[\"@_Self\"]);\n                    const pageItem = this.parsePageItem(item, itemType);\n                    if (pageItem) {\n                        pageItems.push(pageItem);\n                        this.elements.push(pageItem);\n                    }\n                });\n            }\n        });\n        this.checkForNestedContent(spreadData, pageItems);\n        // ALSO CHECK FOR NESTED ITEMS IN PAGES\n        if (spreadData.Page) {\n            const pages = Array.isArray(spreadData.Page) ? spreadData.Page : [\n                spreadData.Page\n            ];\n            pages.forEach((page)=>{\n                itemTypes.forEach((itemType)=>{\n                    if (page[itemType]) {\n                        console.log(\"Found \".concat(itemType, \" in page:\"), Array.isArray(page[itemType]) ? page[itemType].length : 1);\n                        const items = Array.isArray(page[itemType]) ? page[itemType] : [\n                            page[itemType]\n                        ];\n                        items.forEach((item)=>{\n                            const pageItem = this.parsePageItem(item, itemType);\n                            if (pageItem) {\n                                pageItems.push(pageItem);\n                                this.elements.push(pageItem);\n                            }\n                        });\n                    }\n                });\n            });\n        }\n        console.log(\"Total page items extracted: \".concat(pageItems.length));\n        return pageItems;\n    }\n    checkForNestedContent(spreadData, pageItems) {\n        console.log(\"\\uD83D\\uDD0D Checking for nested content in elements...\");\n        // Check rectangles for placed images\n        if (spreadData.Rectangle) {\n            const rectangles = Array.isArray(spreadData.Rectangle) ? spreadData.Rectangle : [\n                spreadData.Rectangle\n            ];\n            rectangles.forEach((rect)=>{\n                var _rect_Properties, _rect_Properties1, _rect_Properties2;\n                // Look for ANY content inside rectangle - be more aggressive\n                const possibleContent = rect.Image || rect.PlacedImage || rect.EPS || rect.PDF || ((_rect_Properties = rect.Properties) === null || _rect_Properties === void 0 ? void 0 : _rect_Properties.Image) || ((_rect_Properties1 = rect.Properties) === null || _rect_Properties1 === void 0 ? void 0 : _rect_Properties1.PlacedImage) || rect.Link || ((_rect_Properties2 = rect.Properties) === null || _rect_Properties2 === void 0 ? void 0 : _rect_Properties2.Link);\n                if (possibleContent) {\n                    console.log(\"\\uD83D\\uDCF7 Found placed content in rectangle \".concat(rect[\"@_Self\"], \":\"), possibleContent);\n                    // Update the rectangle to indicate it's a content frame\n                    const existingRect = pageItems.find((item)=>item.self === rect[\"@_Self\"]);\n                    if (existingRect) {\n                        existingRect.hasPlacedContent = true;\n                        existingRect.contentType = \"Image\";\n                        // Extract placed content details with better handling\n                        existingRect.placedContent = this.extractPlacedContent(possibleContent);\n                        // IMPORTANT: Calculate the image position within the frame\n                        existingRect.imagePosition = IDMLUtils.calculateImagePositionInFrame(existingRect.geometricBounds, existingRect.itemTransform, existingRect.placedContent);\n                    }\n                }\n            });\n        }\n    }\n    extractPlacedContent(content) {\n        if (!content) return null;\n        console.log(\"\\uD83D\\uDD0D Extracting placed content:\", content);\n        const contentItem = Array.isArray(content) ? content[0] : content;\n        console.log(\"Content item keys:\", Object.keys(contentItem));\n        // ENHANCED: Better href handling for embedded images\n        let href = contentItem[\"@_href\"] || contentItem[\"@_ActualPpi\"] || \"\";\n        let isEmbedded = false;\n        // Check if this is an embedded image reference\n        if (href && !href.startsWith(\"file://\") && !href.includes(\"/\")) {\n            // This looks like an embedded image reference\n            isEmbedded = true;\n            console.log(\"\\uD83D\\uDDBCÔ∏è Detected embedded image reference:\", href);\n        }\n        return {\n            type: contentItem[\"@_type\"] || \"Image\",\n            href: href,\n            isEmbedded: isEmbedded,\n            bounds: contentItem[\"@_GeometricBounds\"] ? IDMLUtils.parseGeometricBounds(contentItem[\"@_GeometricBounds\"]) : null,\n            transform: contentItem[\"@_ItemTransform\"] ? IDMLUtils.parseTransform(contentItem[\"@_ItemTransform\"]) : null,\n            actualPpi: contentItem[\"@_ActualPpi\"],\n            effectivePpi: contentItem[\"@_EffectivePpi\"],\n            imageTypeName: contentItem[\"@_ImageTypeName\"],\n            space: contentItem[\"@_Space\"]\n        };\n    }\n    parsePageItem(item, itemType) {\n        // ADD: Validation\n        if (!item || !item[\"@_Self\"]) {\n            console.warn(\"Invalid \".concat(itemType, \" item - missing self ID\"));\n            return null;\n        }\n        const baseItem = {\n            type: itemType,\n            self: item[\"@_Self\"],\n            name: item[\"@_Name\"] || \"\",\n            visible: item[\"@_Visible\"] !== false,\n            locked: item[\"@_Locked\"] === true,\n            geometricBounds: IDMLUtils.calculateBoundsFromPath(item),\n            itemTransform: IDMLUtils.parseTransform(item[\"@_ItemTransform\"]),\n            itemLayer: item[\"@_ItemLayer\"] || \"\",\n            fillColor: item[\"@_FillColor\"] || \"Color/None\",\n            strokeColor: item[\"@_StrokeColor\"] || \"Color/None\",\n            strokeWeight: parseFloat(item[\"@_StrokeWeight\"]) || 0,\n            parentStory: item[\"@_ParentStory\"] || null,\n            // ENHANCED: Better content frame detection\n            isContentFrame: false,\n            hasPlacedContent: false,\n            contentType: null\n        };\n        // ADD: Detect content frames more accurately\n        // ENHANCED: Better embedded image detection\n        if (itemType === \"Rectangle\") {\n            var _item_Properties, _item_Properties1;\n            // Check for embedded images more thoroughly\n            const embeddedInfo = this.detectEmbeddedImages(item);\n            if (embeddedInfo.hasEmbeddedContent || embeddedInfo.isPlaceholder) {\n                baseItem.isContentFrame = true;\n                baseItem.hasPlacedContent = embeddedInfo.hasEmbeddedContent;\n                baseItem.contentType = embeddedInfo.embeddedType || \"placeholder\";\n                baseItem.isEmbedded = embeddedInfo.hasEmbeddedContent;\n                baseItem.isPlaceholder = embeddedInfo.isPlaceholder;\n                console.log(\"\\uD83D\\uDCE6 Detected \".concat(embeddedInfo.hasEmbeddedContent ? \"embedded\" : \"placeholder\", \" content frame: \").concat(baseItem.self));\n            }\n            // Existing content frame detection logic...\n            const hasContent = !!(item.Image || item.PlacedImage || item.EPS || item.PDF || ((_item_Properties = item.Properties) === null || _item_Properties === void 0 ? void 0 : _item_Properties.Image) || ((_item_Properties1 = item.Properties) === null || _item_Properties1 === void 0 ? void 0 : _item_Properties1.PlacedImage));\n            if (hasContent && !baseItem.isContentFrame) {\n                baseItem.isContentFrame = true;\n                baseItem.hasPlacedContent = true;\n                baseItem.contentType = \"Image\";\n                // Extract placed content transform for positioning\n                const placedContent = item.Image || item.PlacedImage || item.EPS || item.PDF;\n                if (placedContent) {\n                    baseItem.placedContent = this.extractPlacedContent(placedContent);\n                }\n                console.log(\"\\uD83D\\uDCE6 Detected external content frame: \".concat(baseItem.self));\n            }\n        }\n        // Type-specific processing...\n        switch(itemType){\n            case \"TextFrame\":\n                baseItem.textFramePreferences = this.parseTextFramePreferences(item.TextFramePreference);\n                break;\n            case \"Rectangle\":\n                baseItem.cornerEffects = this.parseCornerEffects(item);\n                break;\n            case \"Group\":\n                baseItem.groupItems = this.extractGroupItems(item);\n                break;\n        }\n        return baseItem;\n    }\n    detectEmbeddedImages(element) {\n        const embeddedIndicators = {\n            hasEmbeddedContent: false,\n            embeddedType: null,\n            embeddedData: null,\n            embeddedFileName: null,\n            isPlaceholder: false\n        };\n        // Check if element name indicates placeholder\n        if (element.name && (element.name.includes(\"[YOUR IMAGE HERE]\") || element.name.includes(\"[IMAGE]\") || element.name.toLowerCase().includes(\"placeholder\"))) {\n            embeddedIndicators.isPlaceholder = true;\n            embeddedIndicators.embeddedType = \"placeholder\";\n        }\n        // ENHANCED: Check for actual embedded image data\n        if (element.placedContent) {\n            const content = element.placedContent;\n            // Check if href looks like an embedded reference\n            if (content.href && content.isEmbedded) {\n                embeddedIndicators.hasEmbeddedContent = true;\n                embeddedIndicators.embeddedType = content.imageTypeName || \"unknown\";\n                embeddedIndicators.embeddedData = content.href;\n                embeddedIndicators.embeddedFileName = \"\".concat(content.href, \".\").concat(IDMLUtils.getImageExtension(content.imageTypeName));\n            }\n        }\n        return embeddedIndicators;\n    }\n    parseTextFramePreferences(textFramePreference) {\n        var _textFramePreference__InsetSpacing, _textFramePreference__InsetSpacing1, _textFramePreference__InsetSpacing2, _textFramePreference__InsetSpacing3;\n        if (!textFramePreference) return null;\n        return {\n            textColumnCount: parseInt(textFramePreference[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(textFramePreference[\"@_TextColumnGutter\"]) || 0,\n            firstBaselineOffset: textFramePreference[\"@_FirstBaselineOffset\"] || \"AscentOffset\",\n            autoSizingReferencePoint: textFramePreference[\"@_AutoSizingReferencePoint\"] || \"CenterPoint\",\n            autoSizingType: textFramePreference[\"@_AutoSizingType\"] || \"Off\",\n            verticalJustification: textFramePreference[\"@_VerticalJustification\"] || \"TopAlign\",\n            // ENHANCED: Extract text frame insets for precise positioning\n            insetSpacing: {\n                top: parseFloat((_textFramePreference__InsetSpacing = textFramePreference[\"@_InsetSpacing\"]) === null || _textFramePreference__InsetSpacing === void 0 ? void 0 : _textFramePreference__InsetSpacing.split(\" \")[0]) || parseFloat(textFramePreference[\"@_TextInsetTop\"]) || 0,\n                right: parseFloat((_textFramePreference__InsetSpacing1 = textFramePreference[\"@_InsetSpacing\"]) === null || _textFramePreference__InsetSpacing1 === void 0 ? void 0 : _textFramePreference__InsetSpacing1.split(\" \")[1]) || parseFloat(textFramePreference[\"@_TextInsetRight\"]) || 0,\n                bottom: parseFloat((_textFramePreference__InsetSpacing2 = textFramePreference[\"@_InsetSpacing\"]) === null || _textFramePreference__InsetSpacing2 === void 0 ? void 0 : _textFramePreference__InsetSpacing2.split(\" \")[2]) || parseFloat(textFramePreference[\"@_TextInsetBottom\"]) || 0,\n                left: parseFloat((_textFramePreference__InsetSpacing3 = textFramePreference[\"@_InsetSpacing\"]) === null || _textFramePreference__InsetSpacing3 === void 0 ? void 0 : _textFramePreference__InsetSpacing3.split(\" \")[3]) || parseFloat(textFramePreference[\"@_TextInsetLeft\"]) || 0\n            },\n            // Additional InDesign-specific properties for precise text layout\n            useMinimumHeight: textFramePreference[\"@_UseMinimumHeight\"] === true,\n            minimumFirstBaselineOffset: parseFloat(textFramePreference[\"@_MinimumFirstBaselineOffset\"]) || 0,\n            ignoreWrap: textFramePreference[\"@_IgnoreWrap\"] === true\n        };\n    }\n    parseCornerEffects(item) {\n        // Parse corner effects for rectangles\n        return {\n            topLeftCornerRadius: parseFloat(item[\"@_TopLeftCornerRadius\"]) || 0,\n            topRightCornerRadius: parseFloat(item[\"@_TopRightCornerRadius\"]) || 0,\n            bottomLeftCornerRadius: parseFloat(item[\"@_BottomLeftCornerRadius\"]) || 0,\n            bottomRightCornerRadius: parseFloat(item[\"@_BottomRightCornerRadius\"]) || 0\n        };\n    }\n    extractGroupItems(groupItem) {\n        const groupItems = [];\n        // Groups can contain other page items\n        const itemTypes = [\n            \"Rectangle\",\n            \"Oval\",\n            \"Polygon\",\n            \"TextFrame\"\n        ];\n        itemTypes.forEach((itemType)=>{\n            if (groupItem[itemType]) {\n                const items = Array.isArray(groupItem[itemType]) ? groupItem[itemType] : [\n                    groupItem[itemType]\n                ];\n                items.forEach((item)=>{\n                    const parsedItem = this.parsePageItem(item, itemType);\n                    if (parsedItem) {\n                        groupItems.push(parsedItem);\n                    }\n                });\n            }\n        });\n        return groupItems;\n    }\n    parseTransparency(transparencySettings) {\n        if (!transparencySettings) return null;\n        return {\n            blendingSettings: transparencySettings.BlendingSetting ? {\n                blendMode: transparencySettings.BlendingSetting[\"@_BlendMode\"] || \"Normal\",\n                opacity: parseFloat(transparencySettings.BlendingSetting[\"@_Opacity\"]) || 100\n            } : null\n        };\n    }\n    createElementPositionMapFixed() {\n        console.log(\"Creating FIXED element position map...\");\n        // Calculate coordinate offset to handle negative coordinates\n        const coordinateOffset = IDMLUtils.calculateCoordinateOffset(this.elements);\n        console.log(\"Coordinate offset:\", coordinateOffset);\n        this.elements.forEach((element, index)=>{\n            const bounds = element.geometricBounds || element.originalBounds;\n            const transform = element.itemTransform || {\n                a: 1,\n                b: 0,\n                c: 0,\n                d: 1,\n                tx: 0,\n                ty: 0\n            };\n            // CORRECT: Apply transform to bounds, then add offset\n            let x = ((bounds === null || bounds === void 0 ? void 0 : bounds.left) || 0) + (transform.tx || 0) + coordinateOffset.x;\n            let y = ((bounds === null || bounds === void 0 ? void 0 : bounds.top) || 0) + (transform.ty || 0) + coordinateOffset.y;\n            // For the textframe with negative Y, apply special handling\n            if (y < 0) {\n                y = Math.abs(y); // Convert negative to positive\n            }\n            let width = Math.abs((bounds === null || bounds === void 0 ? void 0 : bounds.width) || 0);\n            let height = Math.abs((bounds === null || bounds === void 0 ? void 0 : bounds.height) || 0);\n            element.position = {\n                x: Math.round(x * 100) / 100,\n                y: Math.round(y * 100) / 100,\n                width: Math.round(width * 100) / 100,\n                height: Math.round(height * 100) / 100,\n                rotation: IDMLUtils.calculateRotation(transform)\n            };\n        });\n    }\n    extractMasterPages(masterData) {\n        const pages = [];\n        if (masterData.Page) {\n            const pageList = Array.isArray(masterData.Page) ? masterData.Page : [\n                masterData.Page\n            ];\n            pageList.forEach((page)=>{\n                pages.push({\n                    self: page[\"@_Self\"],\n                    name: page[\"@_Name\"] || \"\",\n                    geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                    itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"]),\n                    appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                    masterPageTransform: IDMLUtils.parseTransform(page[\"@_MasterPageTransform\"])\n                });\n            });\n        }\n        return pages;\n    }\n    getElements() {\n        return this.elements;\n    }\n    clearElements() {\n        this.elements = [];\n    }\n    getElementIndex(element) {\n        return this.elements.findIndex((el)=>el.self === element.self);\n    }\n    getPageContent(pageId) {\n        const pageElements = this.elements.filter((element)=>{\n            // Check if element belongs to this page based on its bounds\n            return true; // TODO: Implement proper page boundary checking\n        });\n        return {\n            elements: pageElements\n        };\n    }\n    constructor(){\n        this.elements = [];\n    }\n}\nmodule.exports = ElementParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFDMUMwSSxxQkFBcUJwSixVQUFVbUIsY0FBYyxDQUFDVCxJQUFJLENBQUMsd0JBQXdCO2dCQUM3RTtZQUNGO1FBQ0Y7UUFFQSxPQUFPTjtJQUNUO0lBRUFpSixjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUN0SCxRQUFRO0lBQ3RCO0lBRUF1SCxnQkFBZ0I7UUFDZCxJQUFJLENBQUN2SCxRQUFRLEdBQUcsRUFBRTtJQUNwQjtJQUVBd0gsZ0JBQWdCNUQsT0FBTyxFQUFFO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDNUQsUUFBUSxDQUFDeUgsU0FBUyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHNUksSUFBSSxLQUFLOEUsUUFBUTlFLElBQUk7SUFDL0Q7SUFFQTZJLGVBQWVDLE1BQU0sRUFBRTtRQUNyQixNQUFNQyxlQUFlLElBQUksQ0FBQzdILFFBQVEsQ0FBQzhILE1BQU0sQ0FBQ2xFLENBQUFBO1lBQ3hDLDREQUE0RDtZQUM1RCxPQUFPLE1BQU0sZ0RBQWdEO1FBQy9EO1FBRUEsT0FBTztZQUNMNUQsVUFBVTZIO1FBQ1o7SUFDRjtJQW5hQUUsYUFBYztRQUNaLElBQUksQ0FBQy9ILFFBQVEsR0FBRyxFQUFFO0lBQ3BCO0FBa2FGO0FBRUFnSSxPQUFPQyxPQUFPLEdBQUcvSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGFyc2Vycy9FbGVtZW50UGFyc2VyLmpzPzViNzUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3QgSURNTFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvSURNTFV0aWxzJyk7XHJcblxyXG5jbGFzcyBFbGVtZW50UGFyc2VyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RTcHJlYWRQYWdlcyhzcHJlYWREYXRhKSB7XHJcbiAgICBjb25zdCBwYWdlcyA9IFtdO1xyXG4gICBcclxuICAgIGlmIChzcHJlYWREYXRhLlBhZ2UpIHtcclxuICAgICAgY29uc3QgcGFnZUxpc3QgPSBBcnJheS5pc0FycmF5KHNwcmVhZERhdGEuUGFnZSkgPyBzcHJlYWREYXRhLlBhZ2UgOiBbc3ByZWFkRGF0YS5QYWdlXTtcclxuICAgICAgXHJcbiAgICAgIHBhZ2VMaXN0LmZvckVhY2goKHBhZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgcGFnZXMucHVzaCh7XHJcbiAgICAgICAgICBzZWxmOiBwYWdlWydAX1NlbGYnXSxcclxuICAgICAgICAgIG5hbWU6IHBhZ2VbJ0BfTmFtZSddIHx8ICcnLFxyXG4gICAgICAgICAgYXBwbGllZE1hc3RlcjogcGFnZVsnQF9BcHBsaWVkTWFzdGVyJ10gfHwgJycsXHJcbiAgICAgICAgICBnZW9tZXRyaWNCb3VuZHM6IElETUxVdGlscy5wYXJzZUdlb21ldHJpY0JvdW5kcyhwYWdlWydAX0dlb21ldHJpY0JvdW5kcyddKSxcclxuICAgICAgICAgIGl0ZW1UcmFuc2Zvcm06IElETUxVdGlscy5wYXJzZVRyYW5zZm9ybShwYWdlWydAX0l0ZW1UcmFuc2Zvcm0nXSlcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZygnTm8gcGFnZXMgZm91bmQgaW4gc3ByZWFkIGRhdGEnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYEV4dHJhY3RlZCAke3BhZ2VzLmxlbmd0aH0gcGFnZXNgKTtcclxuICAgIHJldHVybiBwYWdlcztcclxuICB9XHJcblxyXG4gIGV4dHJhY3RQYWdlSXRlbXMoc3ByZWFkRGF0YSkge1xyXG4gICAgY29uc3QgcGFnZUl0ZW1zID0gW107XHJcbiAgIFxyXG4gICAgLy8gRXh0cmFjdCBkaWZmZXJlbnQgdHlwZXMgb2YgcGFnZSBpdGVtc1xyXG4gICAgY29uc3QgaXRlbVR5cGVzID0gW1xyXG4gICAgICAnUmVjdGFuZ2xlJywgJ092YWwnLCAnUG9seWdvbicsICdHcmFwaGljTGluZScsIFxyXG4gICAgICAnVGV4dEZyYW1lJywgJ0dyb3VwJywgJ0J1dHRvbicsICdUYWJsZScsXHJcbiAgICAgICdJbWFnZScsICdFUFMnLCAnUERGJywgJ1BsYWNlZEl0ZW0nLCAnQ29udGVudEZyYW1lJyAgLy8gQWRkIHRoZXNlXHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICBpdGVtVHlwZXMuZm9yRWFjaChpdGVtVHlwZSA9PiB7XHJcbiAgICAgIGlmIChzcHJlYWREYXRhW2l0ZW1UeXBlXSkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuaXNBcnJheShzcHJlYWREYXRhW2l0ZW1UeXBlXSkgPyBzcHJlYWREYXRhW2l0ZW1UeXBlXSA6IFtzcHJlYWREYXRhW2l0ZW1UeXBlXV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nICR7aXRlbVR5cGV9OmAsIGl0ZW1bJ0BfU2VsZiddKTtcclxuICAgICAgICAgIGNvbnN0IHBhZ2VJdGVtID0gdGhpcy5wYXJzZVBhZ2VJdGVtKGl0ZW0sIGl0ZW1UeXBlKTtcclxuICAgICAgICAgIGlmIChwYWdlSXRlbSkge1xyXG4gICAgICAgICAgICBwYWdlSXRlbXMucHVzaChwYWdlSXRlbSk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaChwYWdlSXRlbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuY2hlY2tGb3JOZXN0ZWRDb250ZW50KHNwcmVhZERhdGEsIHBhZ2VJdGVtcyk7XHJcbiAgICBcclxuICAgIC8vIEFMU08gQ0hFQ0sgRk9SIE5FU1RFRCBJVEVNUyBJTiBQQUdFU1xyXG4gICAgaWYgKHNwcmVhZERhdGEuUGFnZSkge1xyXG4gICAgICBjb25zdCBwYWdlcyA9IEFycmF5LmlzQXJyYXkoc3ByZWFkRGF0YS5QYWdlKSA/IHNwcmVhZERhdGEuUGFnZSA6IFtzcHJlYWREYXRhLlBhZ2VdO1xyXG4gICAgICBwYWdlcy5mb3JFYWNoKHBhZ2UgPT4ge1xyXG4gICAgICBcclxuICAgICAgICBpdGVtVHlwZXMuZm9yRWFjaChpdGVtVHlwZSA9PiB7XHJcbiAgICAgICAgICBpZiAocGFnZVtpdGVtVHlwZV0pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7aXRlbVR5cGV9IGluIHBhZ2U6YCwgQXJyYXkuaXNBcnJheShwYWdlW2l0ZW1UeXBlXSkgPyBwYWdlW2l0ZW1UeXBlXS5sZW5ndGggOiAxKTtcclxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5pc0FycmF5KHBhZ2VbaXRlbVR5cGVdKSA/IHBhZ2VbaXRlbVR5cGVdIDogW3BhZ2VbaXRlbVR5cGVdXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcGFnZUl0ZW0gPSB0aGlzLnBhcnNlUGFnZUl0ZW0oaXRlbSwgaXRlbVR5cGUpO1xyXG4gICAgICAgICAgICAgIGlmIChwYWdlSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcGFnZUl0ZW1zLnB1c2gocGFnZUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKHBhZ2VJdGVtKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYFRvdGFsIHBhZ2UgaXRlbXMgZXh0cmFjdGVkOiAke3BhZ2VJdGVtcy5sZW5ndGh9YCk7XHJcbiAgICByZXR1cm4gcGFnZUl0ZW1zO1xyXG4gIH1cclxuXHJcbiAgY2hlY2tGb3JOZXN0ZWRDb250ZW50KHNwcmVhZERhdGEsIHBhZ2VJdGVtcykge1xyXG4gICAgY29uc29sZS5sb2coJ/CflI0gQ2hlY2tpbmcgZm9yIG5lc3RlZCBjb250ZW50IGluIGVsZW1lbnRzLi4uJyk7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIHJlY3RhbmdsZXMgZm9yIHBsYWNlZCBpbWFnZXNcclxuICAgIGlmIChzcHJlYWREYXRhLlJlY3RhbmdsZSkge1xyXG4gICAgICBjb25zdCByZWN0YW5nbGVzID0gQXJyYXkuaXNBcnJheShzcHJlYWREYXRhLlJlY3RhbmdsZSkgPyBzcHJlYWREYXRhLlJlY3RhbmdsZSA6IFtzcHJlYWREYXRhLlJlY3RhbmdsZV07XHJcbiAgICAgIFxyXG4gICAgICByZWN0YW5nbGVzLmZvckVhY2gocmVjdCA9PiB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9vayBmb3IgQU5ZIGNvbnRlbnQgaW5zaWRlIHJlY3RhbmdsZSAtIGJlIG1vcmUgYWdncmVzc2l2ZVxyXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlQ29udGVudCA9IHJlY3QuSW1hZ2UgfHwgcmVjdC5QbGFjZWRJbWFnZSB8fCByZWN0LkVQUyB8fCByZWN0LlBERiB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5Qcm9wZXJ0aWVzPy5JbWFnZSB8fCByZWN0LlByb3BlcnRpZXM/LlBsYWNlZEltYWdlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QuTGluayB8fCByZWN0LlByb3BlcnRpZXM/Lkxpbms7XHJcbiAgICAgICAgIFxyXG4gICAgICAgIGlmIChwb3NzaWJsZUNvbnRlbnQpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5O3IEZvdW5kIHBsYWNlZCBjb250ZW50IGluIHJlY3RhbmdsZSAke3JlY3RbJ0BfU2VsZiddfTpgLCBwb3NzaWJsZUNvbnRlbnQpO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSByZWN0YW5nbGUgdG8gaW5kaWNhdGUgaXQncyBhIGNvbnRlbnQgZnJhbWVcclxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUmVjdCA9IHBhZ2VJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5zZWxmID09PSByZWN0WydAX1NlbGYnXSk7XHJcbiAgICAgICAgICBpZiAoZXhpc3RpbmdSZWN0KSB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nUmVjdC5oYXNQbGFjZWRDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgZXhpc3RpbmdSZWN0LmNvbnRlbnRUeXBlID0gJ0ltYWdlJztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgcGxhY2VkIGNvbnRlbnQgZGV0YWlscyB3aXRoIGJldHRlciBoYW5kbGluZ1xyXG4gICAgICAgICAgICBleGlzdGluZ1JlY3QucGxhY2VkQ29udGVudCA9IHRoaXMuZXh0cmFjdFBsYWNlZENvbnRlbnQocG9zc2libGVDb250ZW50KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogQ2FsY3VsYXRlIHRoZSBpbWFnZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGZyYW1lXHJcbiAgICAgICAgICAgIGV4aXN0aW5nUmVjdC5pbWFnZVBvc2l0aW9uID0gSURNTFV0aWxzLmNhbGN1bGF0ZUltYWdlUG9zaXRpb25JbkZyYW1lKFxyXG4gICAgICAgICAgICAgIGV4aXN0aW5nUmVjdC5nZW9tZXRyaWNCb3VuZHMsXHJcbiAgICAgICAgICAgICAgZXhpc3RpbmdSZWN0Lml0ZW1UcmFuc2Zvcm0sXHJcbiAgICAgICAgICAgICAgZXhpc3RpbmdSZWN0LnBsYWNlZENvbnRlbnRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBsYWNlZENvbnRlbnQoY29udGVudCkge1xyXG4gICAgaWYgKCFjb250ZW50KSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ/CflI0gRXh0cmFjdGluZyBwbGFjZWQgY29udGVudDonLCBjb250ZW50KTtcclxuICAgIFxyXG4gICAgY29uc3QgY29udGVudEl0ZW0gPSBBcnJheS5pc0FycmF5KGNvbnRlbnQpID8gY29udGVudFswXSA6IGNvbnRlbnQ7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdDb250ZW50IGl0ZW0ga2V5czonLCBPYmplY3Qua2V5cyhjb250ZW50SXRlbSkpO1xyXG4gICAgXHJcbiAgICAvLyBFTkhBTkNFRDogQmV0dGVyIGhyZWYgaGFuZGxpbmcgZm9yIGVtYmVkZGVkIGltYWdlc1xyXG4gICAgbGV0IGhyZWYgPSBjb250ZW50SXRlbVsnQF9ocmVmJ10gfHwgY29udGVudEl0ZW1bJ0BfQWN0dWFsUHBpJ10gfHwgJyc7XHJcbiAgICBsZXQgaXNFbWJlZGRlZCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGVtYmVkZGVkIGltYWdlIHJlZmVyZW5jZVxyXG4gICAgaWYgKGhyZWYgJiYgIWhyZWYuc3RhcnRzV2l0aCgnZmlsZTovLycpICYmICFocmVmLmluY2x1ZGVzKCcvJykpIHtcclxuICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIGFuIGVtYmVkZGVkIGltYWdlIHJlZmVyZW5jZVxyXG4gICAgICBpc0VtYmVkZGVkID0gdHJ1ZTtcclxuICAgICAgY29uc29sZS5sb2coJ/CflrzvuI8gRGV0ZWN0ZWQgZW1iZWRkZWQgaW1hZ2UgcmVmZXJlbmNlOicsIGhyZWYpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBjb250ZW50SXRlbVsnQF90eXBlJ10gfHwgJ0ltYWdlJyxcclxuICAgICAgaHJlZjogaHJlZixcclxuICAgICAgaXNFbWJlZGRlZDogaXNFbWJlZGRlZCwgLy8gQUREIFRISVNcclxuICAgICAgYm91bmRzOiBjb250ZW50SXRlbVsnQF9HZW9tZXRyaWNCb3VuZHMnXSA/IFxyXG4gICAgICAgIElETUxVdGlscy5wYXJzZUdlb21ldHJpY0JvdW5kcyhjb250ZW50SXRlbVsnQF9HZW9tZXRyaWNCb3VuZHMnXSkgOiBcclxuICAgICAgICBudWxsLFxyXG4gICAgICB0cmFuc2Zvcm06IGNvbnRlbnRJdGVtWydAX0l0ZW1UcmFuc2Zvcm0nXSA/IFxyXG4gICAgICAgIElETUxVdGlscy5wYXJzZVRyYW5zZm9ybShjb250ZW50SXRlbVsnQF9JdGVtVHJhbnNmb3JtJ10pIDogXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgYWN0dWFsUHBpOiBjb250ZW50SXRlbVsnQF9BY3R1YWxQcGknXSxcclxuICAgICAgZWZmZWN0aXZlUHBpOiBjb250ZW50SXRlbVsnQF9FZmZlY3RpdmVQcGknXSxcclxuICAgICAgaW1hZ2VUeXBlTmFtZTogY29udGVudEl0ZW1bJ0BfSW1hZ2VUeXBlTmFtZSddLFxyXG4gICAgICBzcGFjZTogY29udGVudEl0ZW1bJ0BfU3BhY2UnXVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHBhcnNlUGFnZUl0ZW0oaXRlbSwgaXRlbVR5cGUpIHtcclxuICAgIC8vIEFERDogVmFsaWRhdGlvblxyXG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtWydAX1NlbGYnXSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgJHtpdGVtVHlwZX0gaXRlbSAtIG1pc3Npbmcgc2VsZiBJRGApO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgYmFzZUl0ZW0gPSB7XHJcbiAgICAgIHR5cGU6IGl0ZW1UeXBlLFxyXG4gICAgICBzZWxmOiBpdGVtWydAX1NlbGYnXSxcclxuICAgICAgbmFtZTogaXRlbVsnQF9OYW1lJ10gfHwgJycsXHJcbiAgICAgIHZpc2libGU6IGl0ZW1bJ0BfVmlzaWJsZSddICE9PSBmYWxzZSxcclxuICAgICAgbG9ja2VkOiBpdGVtWydAX0xvY2tlZCddID09PSB0cnVlLFxyXG4gICAgICBcclxuICAgICAgZ2VvbWV0cmljQm91bmRzOiBJRE1MVXRpbHMuY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgoaXRlbSksXHJcbiAgICAgIGl0ZW1UcmFuc2Zvcm06IElETUxVdGlscy5wYXJzZVRyYW5zZm9ybShpdGVtWydAX0l0ZW1UcmFuc2Zvcm0nXSksXHJcbiAgICAgIFxyXG4gICAgICBpdGVtTGF5ZXI6IGl0ZW1bJ0BfSXRlbUxheWVyJ10gfHwgJycsXHJcbiAgICAgIGZpbGxDb2xvcjogaXRlbVsnQF9GaWxsQ29sb3InXSB8fCAnQ29sb3IvTm9uZScsXHJcbiAgICAgIHN0cm9rZUNvbG9yOiBpdGVtWydAX1N0cm9rZUNvbG9yJ10gfHwgJ0NvbG9yL05vbmUnLFxyXG4gICAgICBzdHJva2VXZWlnaHQ6IHBhcnNlRmxvYXQoaXRlbVsnQF9TdHJva2VXZWlnaHQnXSkgfHwgMCxcclxuICAgICAgXHJcbiAgICAgIHBhcmVudFN0b3J5OiBpdGVtWydAX1BhcmVudFN0b3J5J10gfHwgbnVsbCxcclxuICAgICAgXHJcbiAgICAgIC8vIEVOSEFOQ0VEOiBCZXR0ZXIgY29udGVudCBmcmFtZSBkZXRlY3Rpb25cclxuICAgICAgaXNDb250ZW50RnJhbWU6IGZhbHNlLFxyXG4gICAgICBoYXNQbGFjZWRDb250ZW50OiBmYWxzZSxcclxuICAgICAgY29udGVudFR5cGU6IG51bGxcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEFERDogRGV0ZWN0IGNvbnRlbnQgZnJhbWVzIG1vcmUgYWNjdXJhdGVseVxyXG4gICAvLyBFTkhBTkNFRDogQmV0dGVyIGVtYmVkZGVkIGltYWdlIGRldGVjdGlvblxyXG4gIGlmIChpdGVtVHlwZSA9PT0gJ1JlY3RhbmdsZScpIHtcclxuICAgIC8vIENoZWNrIGZvciBlbWJlZGRlZCBpbWFnZXMgbW9yZSB0aG9yb3VnaGx5XHJcbiAgICBjb25zdCBlbWJlZGRlZEluZm8gPSB0aGlzLmRldGVjdEVtYmVkZGVkSW1hZ2VzKGl0ZW0pO1xyXG4gICAgXHJcbiAgICBpZiAoZW1iZWRkZWRJbmZvLmhhc0VtYmVkZGVkQ29udGVudCB8fCBlbWJlZGRlZEluZm8uaXNQbGFjZWhvbGRlcikge1xyXG4gICAgICBiYXNlSXRlbS5pc0NvbnRlbnRGcmFtZSA9IHRydWU7XHJcbiAgICAgIGJhc2VJdGVtLmhhc1BsYWNlZENvbnRlbnQgPSBlbWJlZGRlZEluZm8uaGFzRW1iZWRkZWRDb250ZW50O1xyXG4gICAgICBiYXNlSXRlbS5jb250ZW50VHlwZSA9IGVtYmVkZGVkSW5mby5lbWJlZGRlZFR5cGUgfHwgJ3BsYWNlaG9sZGVyJztcclxuICAgICAgYmFzZUl0ZW0uaXNFbWJlZGRlZCA9IGVtYmVkZGVkSW5mby5oYXNFbWJlZGRlZENvbnRlbnQ7XHJcbiAgICAgIGJhc2VJdGVtLmlzUGxhY2Vob2xkZXIgPSBlbWJlZGRlZEluZm8uaXNQbGFjZWhvbGRlcjtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OmIERldGVjdGVkICR7ZW1iZWRkZWRJbmZvLmhhc0VtYmVkZGVkQ29udGVudCA/ICdlbWJlZGRlZCcgOiAncGxhY2Vob2xkZXInfSBjb250ZW50IGZyYW1lOiAke2Jhc2VJdGVtLnNlbGZ9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEV4aXN0aW5nIGNvbnRlbnQgZnJhbWUgZGV0ZWN0aW9uIGxvZ2ljLi4uXHJcbiAgICBjb25zdCBoYXNDb250ZW50ID0gISEoaXRlbS5JbWFnZSB8fCBpdGVtLlBsYWNlZEltYWdlIHx8IGl0ZW0uRVBTIHx8IGl0ZW0uUERGIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5Qcm9wZXJ0aWVzPy5JbWFnZSB8fCBpdGVtLlByb3BlcnRpZXM/LlBsYWNlZEltYWdlKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc0NvbnRlbnQgJiYgIWJhc2VJdGVtLmlzQ29udGVudEZyYW1lKSB7XHJcbiAgICAgIGJhc2VJdGVtLmlzQ29udGVudEZyYW1lID0gdHJ1ZTtcclxuICAgICAgYmFzZUl0ZW0uaGFzUGxhY2VkQ29udGVudCA9IHRydWU7XHJcbiAgICAgIGJhc2VJdGVtLmNvbnRlbnRUeXBlID0gJ0ltYWdlJztcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgcGxhY2VkIGNvbnRlbnQgdHJhbnNmb3JtIGZvciBwb3NpdGlvbmluZ1xyXG4gICAgICBjb25zdCBwbGFjZWRDb250ZW50ID0gaXRlbS5JbWFnZSB8fCBpdGVtLlBsYWNlZEltYWdlIHx8IGl0ZW0uRVBTIHx8IGl0ZW0uUERGO1xyXG4gICAgICBpZiAocGxhY2VkQ29udGVudCkge1xyXG4gICAgICAgIGJhc2VJdGVtLnBsYWNlZENvbnRlbnQgPSB0aGlzLmV4dHJhY3RQbGFjZWRDb250ZW50KHBsYWNlZENvbnRlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TpiBEZXRlY3RlZCBleHRlcm5hbCBjb250ZW50IGZyYW1lOiAke2Jhc2VJdGVtLnNlbGZ9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gICAgXHJcbiAgICAvLyBUeXBlLXNwZWNpZmljIHByb2Nlc3NpbmcuLi5cclxuICAgIHN3aXRjaCAoaXRlbVR5cGUpIHtcclxuICAgICAgY2FzZSAnVGV4dEZyYW1lJzpcclxuICAgICAgICBiYXNlSXRlbS50ZXh0RnJhbWVQcmVmZXJlbmNlcyA9IHRoaXMucGFyc2VUZXh0RnJhbWVQcmVmZXJlbmNlcyhpdGVtLlRleHRGcmFtZVByZWZlcmVuY2UpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdSZWN0YW5nbGUnOlxyXG4gICAgICAgIGJhc2VJdGVtLmNvcm5lckVmZmVjdHMgPSB0aGlzLnBhcnNlQ29ybmVyRWZmZWN0cyhpdGVtKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnR3JvdXAnOlxyXG4gICAgICAgIGJhc2VJdGVtLmdyb3VwSXRlbXMgPSB0aGlzLmV4dHJhY3RHcm91cEl0ZW1zKGl0ZW0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gYmFzZUl0ZW07XHJcbiAgfVxyXG5cclxuICBkZXRlY3RFbWJlZGRlZEltYWdlcyhlbGVtZW50KSB7XHJcbiAgICBjb25zdCBlbWJlZGRlZEluZGljYXRvcnMgPSB7XHJcbiAgICAgIGhhc0VtYmVkZGVkQ29udGVudDogZmFsc2UsXHJcbiAgICAgIGVtYmVkZGVkVHlwZTogbnVsbCxcclxuICAgICAgZW1iZWRkZWREYXRhOiBudWxsLFxyXG4gICAgICBlbWJlZGRlZEZpbGVOYW1lOiBudWxsLCAvLyBBREQgVEhJU1xyXG4gICAgICBpc1BsYWNlaG9sZGVyOiBmYWxzZVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBuYW1lIGluZGljYXRlcyBwbGFjZWhvbGRlclxyXG4gICAgaWYgKGVsZW1lbnQubmFtZSAmJiAoXHJcbiAgICAgIGVsZW1lbnQubmFtZS5pbmNsdWRlcygnW1lPVVIgSU1BR0UgSEVSRV0nKSB8fFxyXG4gICAgICBlbGVtZW50Lm5hbWUuaW5jbHVkZXMoJ1tJTUFHRV0nKSB8fFxyXG4gICAgICBlbGVtZW50Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygncGxhY2Vob2xkZXInKVxyXG4gICAgKSkge1xyXG4gICAgICBlbWJlZGRlZEluZGljYXRvcnMuaXNQbGFjZWhvbGRlciA9IHRydWU7XHJcbiAgICAgIGVtYmVkZGVkSW5kaWNhdG9ycy5lbWJlZGRlZFR5cGUgPSAncGxhY2Vob2xkZXInO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBFTkhBTkNFRDogQ2hlY2sgZm9yIGFjdHVhbCBlbWJlZGRlZCBpbWFnZSBkYXRhXHJcbiAgICBpZiAoZWxlbWVudC5wbGFjZWRDb250ZW50KSB7XHJcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbGVtZW50LnBsYWNlZENvbnRlbnQ7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiBocmVmIGxvb2tzIGxpa2UgYW4gZW1iZWRkZWQgcmVmZXJlbmNlXHJcbiAgICAgIGlmIChjb250ZW50LmhyZWYgJiYgY29udGVudC5pc0VtYmVkZGVkKSB7XHJcbiAgICAgICAgZW1iZWRkZWRJbmRpY2F0b3JzLmhhc0VtYmVkZGVkQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgZW1iZWRkZWRJbmRpY2F0b3JzLmVtYmVkZGVkVHlwZSA9IGNvbnRlbnQuaW1hZ2VUeXBlTmFtZSB8fCAndW5rbm93bic7XHJcbiAgICAgICAgZW1iZWRkZWRJbmRpY2F0b3JzLmVtYmVkZGVkRGF0YSA9IGNvbnRlbnQuaHJlZjtcclxuICAgICAgICBlbWJlZGRlZEluZGljYXRvcnMuZW1iZWRkZWRGaWxlTmFtZSA9IGAke2NvbnRlbnQuaHJlZn0uJHtJRE1MVXRpbHMuZ2V0SW1hZ2VFeHRlbnNpb24oY29udGVudC5pbWFnZVR5cGVOYW1lKX1gO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBlbWJlZGRlZEluZGljYXRvcnM7XHJcbiAgfVxyXG5cclxuICBwYXJzZVRleHRGcmFtZVByZWZlcmVuY2VzKHRleHRGcmFtZVByZWZlcmVuY2UpIHtcclxuICAgIGlmICghdGV4dEZyYW1lUHJlZmVyZW5jZSkgcmV0dXJuIG51bGw7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHRDb2x1bW5Db3VudDogcGFyc2VJbnQodGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9UZXh0Q29sdW1uQ291bnQnXSkgfHwgMSxcclxuICAgICAgdGV4dENvbHVtbkd1dHRlcjogcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX1RleHRDb2x1bW5HdXR0ZXInXSkgfHwgMCxcclxuICAgICAgZmlyc3RCYXNlbGluZU9mZnNldDogdGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9GaXJzdEJhc2VsaW5lT2Zmc2V0J10gfHwgJ0FzY2VudE9mZnNldCcsXHJcbiAgICAgIGF1dG9TaXppbmdSZWZlcmVuY2VQb2ludDogdGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9BdXRvU2l6aW5nUmVmZXJlbmNlUG9pbnQnXSB8fCAnQ2VudGVyUG9pbnQnLFxyXG4gICAgICBhdXRvU2l6aW5nVHlwZTogdGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9BdXRvU2l6aW5nVHlwZSddIHx8ICdPZmYnLFxyXG4gICAgICB2ZXJ0aWNhbEp1c3RpZmljYXRpb246IHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfVmVydGljYWxKdXN0aWZpY2F0aW9uJ10gfHwgJ1RvcEFsaWduJyxcclxuICAgICAgXHJcbiAgICAgIC8vIEVOSEFOQ0VEOiBFeHRyYWN0IHRleHQgZnJhbWUgaW5zZXRzIGZvciBwcmVjaXNlIHBvc2l0aW9uaW5nXHJcbiAgICAgIGluc2V0U3BhY2luZzoge1xyXG4gICAgICAgIHRvcDogcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX0luc2V0U3BhY2luZyddPy5zcGxpdCgnICcpWzBdKSB8fCBcclxuICAgICAgICAgICAgIHBhcnNlRmxvYXQodGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9UZXh0SW5zZXRUb3AnXSkgfHwgMCxcclxuICAgICAgICByaWdodDogcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX0luc2V0U3BhY2luZyddPy5zcGxpdCgnICcpWzFdKSB8fCBcclxuICAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX1RleHRJbnNldFJpZ2h0J10pIHx8IDAsXHJcbiAgICAgICAgYm90dG9tOiBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfSW5zZXRTcGFjaW5nJ10/LnNwbGl0KCcgJylbMl0pIHx8IFxyXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX1RleHRJbnNldEJvdHRvbSddKSB8fCAwLFxyXG4gICAgICAgIGxlZnQ6IHBhcnNlRmxvYXQodGV4dEZyYW1lUHJlZmVyZW5jZVsnQF9JbnNldFNwYWNpbmcnXT8uc3BsaXQoJyAnKVszXSkgfHwgXHJcbiAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX1RleHRJbnNldExlZnQnXSkgfHwgMFxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgLy8gQWRkaXRpb25hbCBJbkRlc2lnbi1zcGVjaWZpYyBwcm9wZXJ0aWVzIGZvciBwcmVjaXNlIHRleHQgbGF5b3V0XHJcbiAgICAgIHVzZU1pbmltdW1IZWlnaHQ6IHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfVXNlTWluaW11bUhlaWdodCddID09PSB0cnVlLFxyXG4gICAgICBtaW5pbXVtRmlyc3RCYXNlbGluZU9mZnNldDogcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlWydAX01pbmltdW1GaXJzdEJhc2VsaW5lT2Zmc2V0J10pIHx8IDAsXHJcbiAgICAgIGlnbm9yZVdyYXA6IHRleHRGcmFtZVByZWZlcmVuY2VbJ0BfSWdub3JlV3JhcCddID09PSB0cnVlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcGFyc2VDb3JuZXJFZmZlY3RzKGl0ZW0pIHtcclxuICAgIC8vIFBhcnNlIGNvcm5lciBlZmZlY3RzIGZvciByZWN0YW5nbGVzXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzOiBwYXJzZUZsb2F0KGl0ZW1bJ0BfVG9wTGVmdENvcm5lclJhZGl1cyddKSB8fCAwLFxyXG4gICAgICB0b3BSaWdodENvcm5lclJhZGl1czogcGFyc2VGbG9hdChpdGVtWydAX1RvcFJpZ2h0Q29ybmVyUmFkaXVzJ10pIHx8IDAsXHJcbiAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6IHBhcnNlRmxvYXQoaXRlbVsnQF9Cb3R0b21MZWZ0Q29ybmVyUmFkaXVzJ10pIHx8IDAsXHJcbiAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiBwYXJzZUZsb2F0KGl0ZW1bJ0BfQm90dG9tUmlnaHRDb3JuZXJSYWRpdXMnXSkgfHwgMFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RHcm91cEl0ZW1zKGdyb3VwSXRlbSkge1xyXG4gICAgY29uc3QgZ3JvdXBJdGVtcyA9IFtdO1xyXG4gICAgXHJcbiAgICAvLyBHcm91cHMgY2FuIGNvbnRhaW4gb3RoZXIgcGFnZSBpdGVtc1xyXG4gICAgY29uc3QgaXRlbVR5cGVzID0gWydSZWN0YW5nbGUnLCAnT3ZhbCcsICdQb2x5Z29uJywgJ1RleHRGcmFtZSddO1xyXG4gICAgXHJcbiAgICBpdGVtVHlwZXMuZm9yRWFjaChpdGVtVHlwZSA9PiB7XHJcbiAgICAgIGlmIChncm91cEl0ZW1baXRlbVR5cGVdKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5pc0FycmF5KGdyb3VwSXRlbVtpdGVtVHlwZV0pID8gZ3JvdXBJdGVtW2l0ZW1UeXBlXSA6IFtncm91cEl0ZW1baXRlbVR5cGVdXTtcclxuICAgICAgICBcclxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgY29uc3QgcGFyc2VkSXRlbSA9IHRoaXMucGFyc2VQYWdlSXRlbShpdGVtLCBpdGVtVHlwZSk7XHJcbiAgICAgICAgICBpZiAocGFyc2VkSXRlbSkge1xyXG4gICAgICAgICAgICBncm91cEl0ZW1zLnB1c2gocGFyc2VkSXRlbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZ3JvdXBJdGVtcztcclxuICB9XHJcblxyXG4gIHBhcnNlVHJhbnNwYXJlbmN5KHRyYW5zcGFyZW5jeVNldHRpbmdzKSB7XHJcbiAgICBpZiAoIXRyYW5zcGFyZW5jeVNldHRpbmdzKSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYmxlbmRpbmdTZXR0aW5nczogdHJhbnNwYXJlbmN5U2V0dGluZ3MuQmxlbmRpbmdTZXR0aW5nID8ge1xyXG4gICAgICAgIGJsZW5kTW9kZTogdHJhbnNwYXJlbmN5U2V0dGluZ3MuQmxlbmRpbmdTZXR0aW5nWydAX0JsZW5kTW9kZSddIHx8ICdOb3JtYWwnLFxyXG4gICAgICAgIG9wYWNpdHk6IHBhcnNlRmxvYXQodHJhbnNwYXJlbmN5U2V0dGluZ3MuQmxlbmRpbmdTZXR0aW5nWydAX09wYWNpdHknXSkgfHwgMTAwXHJcbiAgICAgIH0gOiBudWxsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlRWxlbWVudFBvc2l0aW9uTWFwRml4ZWQoKSB7XHJcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgRklYRUQgZWxlbWVudCBwb3NpdGlvbiBtYXAuLi4nKTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGNvb3JkaW5hdGUgb2Zmc2V0IHRvIGhhbmRsZSBuZWdhdGl2ZSBjb29yZGluYXRlc1xyXG4gICAgY29uc3QgY29vcmRpbmF0ZU9mZnNldCA9IElETUxVdGlscy5jYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KHRoaXMuZWxlbWVudHMpO1xyXG4gICAgY29uc29sZS5sb2coJ0Nvb3JkaW5hdGUgb2Zmc2V0OicsIGNvb3JkaW5hdGVPZmZzZXQpO1xyXG4gICAgXHJcbiAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGJvdW5kcyA9IGVsZW1lbnQuZ2VvbWV0cmljQm91bmRzIHx8IGVsZW1lbnQub3JpZ2luYWxCb3VuZHM7XHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVsZW1lbnQuaXRlbVRyYW5zZm9ybSB8fCB7IGE6IDEsIGI6IDAsIGM6IDAsIGQ6IDEsIHR4OiAwLCB0eTogMCB9O1xyXG4gICAgICBcclxuICAgICAgLy8gQ09SUkVDVDogQXBwbHkgdHJhbnNmb3JtIHRvIGJvdW5kcywgdGhlbiBhZGQgb2Zmc2V0XHJcbiAgICAgIGxldCB4ID0gKGJvdW5kcz8ubGVmdCB8fCAwKSArICh0cmFuc2Zvcm0udHggfHwgMCkgKyBjb29yZGluYXRlT2Zmc2V0Lng7XHJcbiAgICAgIGxldCB5ID0gKGJvdW5kcz8udG9wIHx8IDApICsgKHRyYW5zZm9ybS50eSB8fCAwKSArIGNvb3JkaW5hdGVPZmZzZXQueTtcclxuICAgICAgXHJcbiAgICAgIC8vIEZvciB0aGUgdGV4dGZyYW1lIHdpdGggbmVnYXRpdmUgWSwgYXBwbHkgc3BlY2lhbCBoYW5kbGluZ1xyXG4gICAgICBpZiAoeSA8IDApIHtcclxuICAgICAgICB5ID0gTWF0aC5hYnMoeSk7IC8vIENvbnZlcnQgbmVnYXRpdmUgdG8gcG9zaXRpdmVcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgbGV0IHdpZHRoID0gTWF0aC5hYnMoYm91bmRzPy53aWR0aCB8fCAwKTtcclxuICAgICAgbGV0IGhlaWdodCA9IE1hdGguYWJzKGJvdW5kcz8uaGVpZ2h0IHx8IDApO1xyXG4gICAgICBcclxuICAgICAgZWxlbWVudC5wb3NpdGlvbiA9IHtcclxuICAgICAgICB4OiBNYXRoLnJvdW5kKHggKiAxMDApIC8gMTAwLFxyXG4gICAgICAgIHk6IE1hdGgucm91bmQoeSAqIDEwMCkgLyAxMDAsXHJcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQod2lkdGggKiAxMDApIC8gMTAwLFxyXG4gICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChoZWlnaHQgKiAxMDApIC8gMTAwLFxyXG4gICAgICAgIHJvdGF0aW9uOiBJRE1MVXRpbHMuY2FsY3VsYXRlUm90YXRpb24odHJhbnNmb3JtKVxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0TWFzdGVyUGFnZXMobWFzdGVyRGF0YSkge1xyXG4gICAgY29uc3QgcGFnZXMgPSBbXTtcclxuICAgIFxyXG4gICAgaWYgKG1hc3RlckRhdGEuUGFnZSkge1xyXG4gICAgICBjb25zdCBwYWdlTGlzdCA9IEFycmF5LmlzQXJyYXkobWFzdGVyRGF0YS5QYWdlKSA/IG1hc3RlckRhdGEuUGFnZSA6IFttYXN0ZXJEYXRhLlBhZ2VdO1xyXG4gICAgICBcclxuICAgICAgcGFnZUxpc3QuZm9yRWFjaChwYWdlID0+IHtcclxuICAgICAgICBwYWdlcy5wdXNoKHtcclxuICAgICAgICAgIHNlbGY6IHBhZ2VbJ0BfU2VsZiddLFxyXG4gICAgICAgICAgbmFtZTogcGFnZVsnQF9OYW1lJ10gfHwgJycsXHJcbiAgICAgICAgICBnZW9tZXRyaWNCb3VuZHM6IElETUxVdGlscy5wYXJzZUdlb21ldHJpY0JvdW5kcyhwYWdlWydAX0dlb21ldHJpY0JvdW5kcyddKSxcclxuICAgICAgICAgIGl0ZW1UcmFuc2Zvcm06IElETUxVdGlscy5wYXJzZVRyYW5zZm9ybShwYWdlWydAX0l0ZW1UcmFuc2Zvcm0nXSksXHJcbiAgICAgICAgICBhcHBsaWVkTWFzdGVyOiBwYWdlWydAX0FwcGxpZWRNYXN0ZXInXSB8fCAnJyxcclxuICAgICAgICAgIG1hc3RlclBhZ2VUcmFuc2Zvcm06IElETUxVdGlscy5wYXJzZVRyYW5zZm9ybShwYWdlWydAX01hc3RlclBhZ2VUcmFuc2Zvcm0nXSlcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBwYWdlcztcclxuICB9XHJcblxyXG4gIGdldEVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICBjbGVhckVsZW1lbnRzKCkge1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgZ2V0RWxlbWVudEluZGV4KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmZpbmRJbmRleChlbCA9PiBlbC5zZWxmID09PSBlbGVtZW50LnNlbGYpO1xyXG4gIH1cclxuXHJcbiAgZ2V0UGFnZUNvbnRlbnQocGFnZUlkKSB7XHJcbiAgICBjb25zdCBwYWdlRWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLmZpbHRlcihlbGVtZW50ID0+IHtcclxuICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBiZWxvbmdzIHRvIHRoaXMgcGFnZSBiYXNlZCBvbiBpdHMgYm91bmRzXHJcbiAgICAgIHJldHVybiB0cnVlOyAvLyBUT0RPOiBJbXBsZW1lbnQgcHJvcGVyIHBhZ2UgYm91bmRhcnkgY2hlY2tpbmdcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlbGVtZW50czogcGFnZUVsZW1lbnRzXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50UGFyc2VyOyAiXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJJRE1MVXRpbHMiLCJFbGVtZW50UGFyc2VyIiwiZXh0cmFjdFNwcmVhZFBhZ2VzIiwic3ByZWFkRGF0YSIsInBhZ2VzIiwiUGFnZSIsInBhZ2VMaXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInBhZ2UiLCJpbmRleCIsInB1c2giLCJzZWxmIiwibmFtZSIsImFwcGxpZWRNYXN0ZXIiLCJnZW9tZXRyaWNCb3VuZHMiLCJwYXJzZUdlb21ldHJpY0JvdW5kcyIsIml0ZW1UcmFuc2Zvcm0iLCJwYXJzZVRyYW5zZm9ybSIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJleHRyYWN0UGFnZUl0ZW1zIiwicGFnZUl0ZW1zIiwiaXRlbVR5cGVzIiwiaXRlbVR5cGUiLCJpdGVtcyIsIml0ZW0iLCJwYWdlSXRlbSIsInBhcnNlUGFnZUl0ZW0iLCJlbGVtZW50cyIsImNoZWNrRm9yTmVzdGVkQ29udGVudCIsIlJlY3RhbmdsZSIsInJlY3RhbmdsZXMiLCJyZWN0IiwicG9zc2libGVDb250ZW50IiwiSW1hZ2UiLCJQbGFjZWRJbWFnZSIsIkVQUyIsIlBERiIsIlByb3BlcnRpZXMiLCJMaW5rIiwiZXhpc3RpbmdSZWN0IiwiZmluZCIsImhhc1BsYWNlZENvbnRlbnQiLCJjb250ZW50VHlwZSIsInBsYWNlZENvbnRlbnQiLCJleHRyYWN0UGxhY2VkQ29udGVudCIsImltYWdlUG9zaXRpb24iLCJjYWxjdWxhdGVJbWFnZVBvc2l0aW9uSW5GcmFtZSIsImNvbnRlbnQiLCJjb250ZW50SXRlbSIsIk9iamVjdCIsImtleXMiLCJocmVmIiwiaXNFbWJlZGRlZCIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsInR5cGUiLCJib3VuZHMiLCJ0cmFuc2Zvcm0iLCJhY3R1YWxQcGkiLCJlZmZlY3RpdmVQcGkiLCJpbWFnZVR5cGVOYW1lIiwic3BhY2UiLCJ3YXJuIiwiYmFzZUl0ZW0iLCJ2aXNpYmxlIiwibG9ja2VkIiwiY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgiLCJpdGVtTGF5ZXIiLCJmaWxsQ29sb3IiLCJzdHJva2VDb2xvciIsInN0cm9rZVdlaWdodCIsInBhcnNlRmxvYXQiLCJwYXJlbnRTdG9yeSIsImlzQ29udGVudEZyYW1lIiwiZW1iZWRkZWRJbmZvIiwiZGV0ZWN0RW1iZWRkZWRJbWFnZXMiLCJoYXNFbWJlZGRlZENvbnRlbnQiLCJpc1BsYWNlaG9sZGVyIiwiZW1iZWRkZWRUeXBlIiwiaGFzQ29udGVudCIsInRleHRGcmFtZVByZWZlcmVuY2VzIiwicGFyc2VUZXh0RnJhbWVQcmVmZXJlbmNlcyIsIlRleHRGcmFtZVByZWZlcmVuY2UiLCJjb3JuZXJFZmZlY3RzIiwicGFyc2VDb3JuZXJFZmZlY3RzIiwiZ3JvdXBJdGVtcyIsImV4dHJhY3RHcm91cEl0ZW1zIiwiZWxlbWVudCIsImVtYmVkZGVkSW5kaWNhdG9ycyIsImVtYmVkZGVkRGF0YSIsImVtYmVkZGVkRmlsZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdldEltYWdlRXh0ZW5zaW9uIiwidGV4dEZyYW1lUHJlZmVyZW5jZSIsInRleHRDb2x1bW5Db3VudCIsInBhcnNlSW50IiwidGV4dENvbHVtbkd1dHRlciIsImZpcnN0QmFzZWxpbmVPZmZzZXQiLCJhdXRvU2l6aW5nUmVmZXJlbmNlUG9pbnQiLCJhdXRvU2l6aW5nVHlwZSIsInZlcnRpY2FsSnVzdGlmaWNhdGlvbiIsImluc2V0U3BhY2luZyIsInRvcCIsInNwbGl0IiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwidXNlTWluaW11bUhlaWdodCIsIm1pbmltdW1GaXJzdEJhc2VsaW5lT2Zmc2V0IiwiaWdub3JlV3JhcCIsInRvcExlZnRDb3JuZXJSYWRpdXMiLCJ0b3BSaWdodENvcm5lclJhZGl1cyIsImJvdHRvbUxlZnRDb3JuZXJSYWRpdXMiLCJib3R0b21SaWdodENvcm5lclJhZGl1cyIsImdyb3VwSXRlbSIsInBhcnNlZEl0ZW0iLCJwYXJzZVRyYW5zcGFyZW5jeSIsInRyYW5zcGFyZW5jeVNldHRpbmdzIiwiYmxlbmRpbmdTZXR0aW5ncyIsIkJsZW5kaW5nU2V0dGluZyIsImJsZW5kTW9kZSIsIm9wYWNpdHkiLCJjcmVhdGVFbGVtZW50UG9zaXRpb25NYXBGaXhlZCIsImNvb3JkaW5hdGVPZmZzZXQiLCJjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0Iiwib3JpZ2luYWxCb3VuZHMiLCJhIiwiYiIsImMiLCJkIiwidHgiLCJ0eSIsIngiLCJ5IiwiTWF0aCIsImFicyIsIndpZHRoIiwiaGVpZ2h0IiwicG9zaXRpb24iLCJyb3VuZCIsInJvdGF0aW9uIiwiY2FsY3VsYXRlUm90YXRpb24iLCJleHRyYWN0TWFzdGVyUGFnZXMiLCJtYXN0ZXJEYXRhIiwibWFzdGVyUGFnZVRyYW5zZm9ybSIsImdldEVsZW1lbnRzIiwiY2xlYXJFbGVtZW50cyIsImdldEVsZW1lbnRJbmRleCIsImZpbmRJbmRleCIsImVsIiwiZ2V0UGFnZUNvbnRlbnQiLCJwYWdlSWQiLCJwYWdlRWxlbWVudHMiLCJmaWx0ZXIiLCJjb25zdHJ1Y3RvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/parsers/ElementParser.js\n"));

/***/ })

});