"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StyleParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StyleParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StyleParser {\n    async parseResourceFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCCB Parsing resource: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const resourceName = path.basename(fileName, \".xml\");\n            // Handle different resource types\n            if (fileName.includes(\"Styles.xml\")) {\n                await this.extractStyles(parsed);\n            } else if (fileName.includes(\"Fonts.xml\")) {\n                await this.extractFonts(parsed);\n            } else if (fileName.includes(\"Graphic.xml\")) {\n                await this.extractGraphics(parsed);\n            } else if (fileName.includes(\"Preferences.xml\")) {\n                await this.extractPreferences(parsed);\n            }\n            console.log(\"✅ Resource \".concat(resourceName, \" parsed\"));\n        } catch (error) {\n            console.error(\"❌ Error parsing \".concat(fileName, \":\"), error.message);\n        }\n    }\n    async extractStyles(stylesData) {\n        console.log(\"Extracting styles...\");\n        const styles = stylesData.Styles || stylesData;\n        // Extract Paragraph Styles\n        if (styles.RootParagraphStyleGroup) {\n            this.extractParagraphStyles(styles.RootParagraphStyleGroup);\n        }\n        // Extract Character Styles  \n        if (styles.RootCharacterStyleGroup) {\n            this.extractCharacterStyles(styles.RootCharacterStyleGroup);\n        }\n    }\n    extractParagraphStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.ParagraphStyle) {\n                const styles = Array.isArray(group.ParagraphStyle) ? group.ParagraphStyle : [\n                    group.ParagraphStyle\n                ];\n                styles.forEach((style)=>{\n                    // CRITICAL: Extract font reference from multiple possible locations\n                    const fontRef = this.extractFontFromStyle(style);\n                    // ENHANCED: Process leading with proper InDesign logic\n                    const fontSize = parseFloat(style[\"@_PointSize\"]) || 12;\n                    const rawLeading = style[\"@_Leading\"];\n                    const processedLeading = this.processLeadingValue(rawLeading, fontSize);\n                    this.styles.paragraph[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: fontSize,\n                        leading: processedLeading,\n                        leadingType: this.determineLeadingType(rawLeading),\n                        effectiveLineHeight: this.calculateEffectiveLineHeight(processedLeading, fontSize),\n                        alignment: style[\"@_Justification\"] || \"LeftAlign\",\n                        leftIndent: parseFloat(style[\"@_LeftIndent\"]) || 0,\n                        rightIndent: parseFloat(style[\"@_RightIndent\"]) || 0,\n                        firstLineIndent: parseFloat(style[\"@_FirstLineIndent\"]) || 0,\n                        spaceBefore: parseFloat(style[\"@_SpaceBefore\"]) || 0,\n                        spaceAfter: parseFloat(style[\"@_SpaceAfter\"]) || 0,\n                        // Typography enhancements\n                        tracking: parseFloat(style[\"@_Tracking\"]) || 0,\n                        kerning: parseFloat(style[\"@_Kerning\"]) || 0,\n                        horizontalScale: parseFloat(style[\"@_HorizontalScale\"]) || 100,\n                        verticalScale: parseFloat(style[\"@_VerticalScale\"]) || 100,\n                        // ENHANCED: Use the new extraction method\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || \"Color/Black\",\n                        rawStyle: style\n                    };\n                    console.log(\"✅ Paragraph Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.ParagraphStyleGroup) {\n                const subGroups = Array.isArray(group.ParagraphStyleGroup) ? group.ParagraphStyleGroup : [\n                    group.ParagraphStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    extractFontFromStyle(style) {\n        // Try direct attributes first\n        let fontRef = style[\"@_AppliedFont\"] || style[\"@_FontFamily\"] || style[\"@_Font\"] || \"\";\n        // If not found, try Properties nested structure\n        if (!fontRef && style.Properties) {\n            if (style.Properties.AppliedFont) {\n                fontRef = style.Properties.AppliedFont[\"#text\"] || style.Properties.AppliedFont || \"\";\n            }\n            // Also try other property variations\n            if (!fontRef && style.Properties.FontFamily) {\n                fontRef = style.Properties.FontFamily[\"#text\"] || style.Properties.FontFamily || \"\";\n            }\n        }\n        return fontRef || \"\";\n    }\n    extractCharacterStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.CharacterStyle) {\n                const styles = Array.isArray(group.CharacterStyle) ? group.CharacterStyle : [\n                    group.CharacterStyle\n                ];\n                styles.forEach((style)=>{\n                    const fontRef = this.extractFontFromStyle(style);\n                    this.styles.character[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: parseFloat(style[\"@_PointSize\"]) || null,\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || null,\n                        strokeColor: style[\"@_StrokeColor\"] || null,\n                        rawStyle: style\n                    };\n                    console.log(\"✅ Character Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.CharacterStyleGroup) {\n                const subGroups = Array.isArray(group.CharacterStyleGroup) ? group.CharacterStyleGroup : [\n                    group.CharacterStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    async extractFonts(fontsData) {\n        console.log(\"Extracting fonts with enhanced mapping...\");\n        const fonts = fontsData.Fonts || fontsData;\n        this.resources.fonts = {};\n        this.fontMap = new Map(); // Global font lookup map\n        if (fonts.FontFamily) {\n            const fontFamilies = Array.isArray(fonts.FontFamily) ? fonts.FontFamily : [\n                fonts.FontFamily\n            ];\n            fontFamilies.forEach((family)=>{\n                const familyInfo = {\n                    self: family[\"@_Self\"],\n                    name: family[\"@_Name\"] || \"\",\n                    fonts: []\n                };\n                if (family.Font) {\n                    const fontList = Array.isArray(family.Font) ? family.Font : [\n                        family.Font\n                    ];\n                    fontList.forEach((font)=>{\n                        const fontInfo = {\n                            self: font[\"@_Self\"],\n                            fontFamily: font[\"@_FontFamily\"] || familyInfo.name,\n                            name: font[\"@_Name\"] || \"\",\n                            postScriptName: font[\"@_PostScriptName\"] || \"\",\n                            status: font[\"@_Status\"] || \"Unknown\",\n                            fontStyleName: font[\"@_FontStyleName\"] || \"Regular\"\n                        };\n                        familyInfo.fonts.push(fontInfo);\n                        // Create multiple lookup entries for this font\n                        this.fontMap.set(font[\"@_Self\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_PostScriptName\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_Name\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_FontFamily\"], familyInfo.name);\n                        console.log(\"Font mapping: \".concat(font[\"@_Self\"], \" -> \").concat(familyInfo.name));\n                    });\n                }\n                this.resources.fonts[family[\"@_Self\"]] = familyInfo;\n            });\n        }\n        console.log(\"✅ Fonts extracted: \".concat(Object.keys(this.resources.fonts).length, \" families\"));\n        console.log(\"Font map entries: \".concat(this.fontMap.size));\n    }\n    async extractGraphics(graphicsData) {\n        console.log(\"Extracting graphics and colors...\");\n        const graphics = graphicsData.Graphic || graphicsData;\n        this.resources.colors = {};\n        this.resources.gradients = {};\n        // Extract Colors\n        if (graphics.Color) {\n            const colors = Array.isArray(graphics.Color) ? graphics.Color : [\n                graphics.Color\n            ];\n            colors.forEach((color)=>{\n                this.resources.colors[color[\"@_Self\"]] = {\n                    self: color[\"@_Self\"],\n                    name: color[\"@_Name\"] || \"\",\n                    model: color[\"@_Model\"] || \"Process\",\n                    space: color[\"@_Space\"] || \"CMYK\",\n                    cyan: parseFloat(color[\"@_Cyan\"]) || 0,\n                    magenta: parseFloat(color[\"@_Magenta\"]) || 0,\n                    yellow: parseFloat(color[\"@_Yellow\"]) || 0,\n                    black: parseFloat(color[\"@_Black\"]) || 0,\n                    red: parseFloat(color[\"@_Red\"]) || 0,\n                    green: parseFloat(color[\"@_Green\"]) || 0,\n                    blue: parseFloat(color[\"@_Blue\"]) || 0\n                };\n            });\n        }\n        // Extract Gradients\n        if (graphics.Gradient) {\n            const gradients = Array.isArray(graphics.Gradient) ? graphics.Gradient : [\n                graphics.Gradient\n            ];\n            gradients.forEach((gradient)=>{\n                this.resources.gradients[gradient[\"@_Self\"]] = {\n                    self: gradient[\"@_Self\"],\n                    name: gradient[\"@_Name\"] || \"\",\n                    type: gradient[\"@_Type\"] || \"Linear\",\n                    gradientStops: this.extractGradientStops(gradient)\n                };\n            });\n        }\n    }\n    extractGradientStops(gradient) {\n        const stops = [];\n        if (gradient.GradientStop) {\n            const stopList = Array.isArray(gradient.GradientStop) ? gradient.GradientStop : [\n                gradient.GradientStop\n            ];\n            stopList.forEach((stop)=>{\n                stops.push({\n                    self: stop[\"@_Self\"],\n                    stopColor: stop[\"@_StopColor\"] || \"\",\n                    location: parseFloat(stop[\"@_Location\"]) || 0,\n                    midpoint: parseFloat(stop[\"@_Midpoint\"]) || 50\n                });\n            });\n        }\n        return stops;\n    }\n    async extractPreferences(preferencesData) {\n        console.log(\"Extracting document preferences...\");\n        const prefs = preferencesData.Preferences || preferencesData;\n        // Extract various document preferences\n        this.documentInfo = {\n            preferences: {\n                documentPreferences: this.extractDocumentPrefs(prefs.DocumentPreference),\n                viewPreferences: this.extractViewPrefs(prefs.ViewPreference),\n                guidePreferences: this.extractGuidePrefs(prefs.GuidePreference),\n                gridPreferences: this.extractGridPrefs(prefs.GridPreference),\n                marginPreferences: this.extractMarginPrefs(prefs.MarginPreference),\n                columnPreferences: this.extractColumnPrefs(prefs.ColumnPreference)\n            }\n        };\n    }\n    extractDocumentPrefs(docPref) {\n        if (!docPref) return {};\n        return {\n            pageWidth: parseFloat(docPref[\"@_PageWidth\"]) || 0,\n            pageHeight: parseFloat(docPref[\"@_PageHeight\"]) || 0,\n            left: parseFloat(docPref[\"@_Left\"]) || 0,\n            top: parseFloat(docPref[\"@_Top\"]) || 0,\n            right: parseFloat(docPref[\"@_Right\"]) || 0,\n            bottom: parseFloat(docPref[\"@_Bottom\"]) || 0,\n            columnCount: parseInt(docPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(docPref[\"@_ColumnGutter\"]) || 0,\n            facingPages: docPref[\"@_FacingPages\"] === true,\n            allowPageShuffle: docPref[\"@_AllowPageShuffle\"] !== false,\n            slugBleedType: docPref[\"@_SlugBleedType\"] || \"None\",\n            documentBleedTopOffset: parseFloat(docPref[\"@_DocumentBleedTopOffset\"]) || 0,\n            documentBleedBottomOffset: parseFloat(docPref[\"@_DocumentBleedBottomOffset\"]) || 0,\n            documentBleedInsideOrLeftOffset: parseFloat(docPref[\"@_DocumentBleedInsideOrLeftOffset\"]) || 0,\n            documentBleedOutsideOrRightOffset: parseFloat(docPref[\"@_DocumentBleedOutsideOrRightOffset\"]) || 0\n        };\n    }\n    extractViewPrefs(viewPref) {\n        if (!viewPref) return {};\n        return {\n            horizontalMeasurementUnits: viewPref[\"@_HorizontalMeasurementUnits\"] || \"Points\",\n            verticalMeasurementUnits: viewPref[\"@_VerticalMeasurementUnits\"] || \"Points\",\n            rulerOrigin: viewPref[\"@_RulerOrigin\"] || \"SpreadOrigin\",\n            showRulers: viewPref[\"@_ShowRulers\"] !== false\n        };\n    }\n    extractGuidePrefs(guidePref) {\n        if (!guidePref) return {};\n        return {\n            rulerGuideColor: guidePref[\"@_RulerGuideColor\"] || \"Green\",\n            guidesInBack: guidePref[\"@_GuidesInBack\"] === true,\n            guidesLocked: guidePref[\"@_GuidesLocked\"] === true,\n            guidesShown: guidePref[\"@_GuidesShown\"] !== false,\n            guidesSnapto: guidePref[\"@_GuidesSnapto\"] !== false\n        };\n    }\n    extractGridPrefs(gridPref) {\n        if (!gridPref) return {};\n        return {\n            baselineStart: parseFloat(gridPref[\"@_BaselineStart\"]) || 0,\n            baselineDivision: parseFloat(gridPref[\"@_BaselineDivision\"]) || 12,\n            baselineShown: gridPref[\"@_BaselineShown\"] === true,\n            baselineSnapto: gridPref[\"@_BaselineSnapto\"] === true,\n            documentGridShown: gridPref[\"@_DocumentGridShown\"] === true,\n            documentGridSnapto: gridPref[\"@_DocumentGridSnapto\"] === true\n        };\n    }\n    extractMarginPrefs(marginPref) {\n        if (!marginPref) return {};\n        return {\n            top: parseFloat(marginPref[\"@_Top\"]) || 0,\n            bottom: parseFloat(marginPref[\"@_Bottom\"]) || 0,\n            left: parseFloat(marginPref[\"@_Left\"]) || 0,\n            right: parseFloat(marginPref[\"@_Right\"]) || 0,\n            columnCount: parseInt(marginPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(marginPref[\"@_ColumnGutter\"]) || 0\n        };\n    }\n    extractColumnPrefs(columnPref) {\n        if (!columnPref) return {};\n        return {\n            textColumnCount: parseInt(columnPref[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(columnPref[\"@_TextColumnGutter\"]) || 0\n        };\n    }\n    resolveStyleFormatting(formatting) {\n        const resolved = {\n            ...formatting\n        };\n        // DEBUG: Check if formatting is being applied (generic check)\n        const hasAnyFormatting = formatting.paragraphStyle || formatting.characterStyle || formatting.fontStyle || formatting.fontReference || formatting.fontSize;\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Input:\", {\n                paragraphStyle: formatting.paragraphStyle,\n                characterStyle: formatting.characterStyle,\n                directFontStyle: formatting.fontStyle,\n                directFontRef: formatting.fontReference,\n                directFontSize: formatting.fontSize\n            });\n        }\n        // Resolve paragraph style (base layer)\n        if (formatting.paragraphStyle && this.styles.paragraph[formatting.paragraphStyle]) {\n            const pStyle = this.styles.paragraph[formatting.paragraphStyle];\n            if (!resolved.fontSize && pStyle.pointSize) resolved.fontSize = pStyle.pointSize;\n            if (!resolved.fillColor && pStyle.fillColor) resolved.fillColor = pStyle.fillColor;\n            // CRITICAL FIX: Always inherit paragraph alignment unless explicitly overridden\n            if (pStyle.alignment) resolved.alignment = pStyle.alignment;\n            if (!resolved.fontStyle && pStyle.fontStyle) {\n                resolved.fontStyle = pStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from paragraph style: \"'.concat(pStyle.fontStyle, '\"'));\n                }\n            }\n            // CRITICAL: Resolve font from paragraph style\n            if (!resolved.fontFamily && pStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(pStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from paragraph style: \".concat(pStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n            // Add other paragraph properties with enhanced leading support\n            resolved.leading = pStyle.leading;\n            resolved.leadingType = pStyle.leadingType;\n            resolved.effectiveLineHeight = pStyle.effectiveLineHeight;\n            resolved.leftIndent = pStyle.leftIndent;\n            resolved.rightIndent = pStyle.rightIndent;\n            resolved.firstLineIndent = pStyle.firstLineIndent;\n            resolved.spaceBefore = pStyle.spaceBefore;\n            resolved.spaceAfter = pStyle.spaceAfter;\n            resolved.tracking = pStyle.tracking;\n            resolved.kerning = pStyle.kerning;\n        }\n        // Resolve character style (override layer)\n        if (formatting.characterStyle && this.styles.character[formatting.characterStyle]) {\n            const cStyle = this.styles.character[formatting.characterStyle];\n            if (cStyle.pointSize) resolved.fontSize = cStyle.pointSize;\n            if (cStyle.fillColor) resolved.fillColor = cStyle.fillColor;\n            if (cStyle.fontStyle) {\n                resolved.fontStyle = cStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from character style: \"'.concat(cStyle.fontStyle, '\"'));\n                }\n            }\n            if (cStyle.strokeColor) resolved.strokeColor = cStyle.strokeColor;\n            // Include leading information from character style\n            if (cStyle.leading) resolved.leading = cStyle.leading;\n            if (cStyle.leadingType) resolved.leadingType = cStyle.leadingType;\n            if (cStyle.effectiveLineHeight) resolved.effectiveLineHeight = cStyle.effectiveLineHeight;\n            // CRITICAL: Character style font overrides paragraph style\n            if (cStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(cStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from character style: \".concat(cStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n        }\n        // Apply direct formatting (highest priority)\n        if (formatting.fontReference) {\n            resolved.fontFamily = this.resolveFontReference(formatting.fontReference);\n            if (hasAnyFormatting) {\n                console.log(\"   Font from direct formatting: \".concat(formatting.fontReference, \" -> \").concat(resolved.fontFamily));\n            }\n        }\n        // CRITICAL: Apply direct fontStyle if provided (this might be the issue)\n        if (formatting.fontStyle) {\n            resolved.fontStyle = formatting.fontStyle;\n            if (hasAnyFormatting) {\n                console.log('   FontStyle from direct formatting: \"'.concat(formatting.fontStyle, '\"'));\n            }\n        }\n        // Apply direct leading information (highest priority)\n        if (formatting.leading !== undefined) resolved.leading = formatting.leading;\n        if (formatting.leadingType) resolved.leadingType = formatting.leadingType;\n        if (formatting.effectiveLineHeight) resolved.effectiveLineHeight = formatting.effectiveLineHeight;\n        // Apply other direct formatting attributes\n        if (formatting.fontSize) resolved.fontSize = formatting.fontSize;\n        if (formatting.tracking) resolved.tracking = formatting.tracking;\n        if (formatting.kerning) resolved.kerning = formatting.kerning;\n        // FIXED: Ensure fontStyle defaults to Regular/normal if not set\n        if (!resolved.fontStyle || resolved.fontStyle === \"\") {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log('   FontStyle defaulted to: \"Regular\"');\n            }\n        }\n        // ADDITIONAL FIX: If no styles were applied from any source, ensure clean defaults\n        if (!formatting.paragraphStyle && !formatting.characterStyle && !formatting.fontStyle && !formatting.fontReference) {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log(\"   No source styles found - ensuring clean defaults\");\n            }\n        }\n        // Final fallback\n        if (!resolved.fontFamily || resolved.fontFamily === \"\") {\n            resolved.fontFamily = this.getDefaultFont();\n            if (hasAnyFormatting) {\n                console.log(\"   Using fallback font: \".concat(resolved.fontFamily));\n            }\n        }\n        // Ensure line height is calculated if not explicitly set\n        if (!resolved.effectiveLineHeight && resolved.fontSize && resolved.leading) {\n            resolved.effectiveLineHeight = this.calculateEffectiveLineHeight(resolved.leading, resolved.fontSize);\n        }\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Final Output:\", {\n                fontSize: resolved.fontSize,\n                fontFamily: resolved.fontFamily,\n                fontStyle: resolved.fontStyle,\n                fillColor: resolved.fillColor,\n                leading: resolved.leading,\n                effectiveLineHeight: resolved.effectiveLineHeight\n            });\n        }\n        return resolved;\n    }\n    resolveFontReference(fontRef) {\n        if (!fontRef || fontRef === \"\") {\n            console.log(\"Empty font reference, using fallback\");\n            return this.getDefaultFont();\n        }\n        // Try direct lookup in font map\n        if (this.fontMap && this.fontMap.has(fontRef)) {\n            const resolvedFont = this.fontMap.get(fontRef);\n            console.log('Font resolved: \"'.concat(fontRef, '\" -> \"').concat(resolvedFont, '\"'));\n            return resolvedFont;\n        }\n        // Try partial matching for font families\n        if (this.resources.fonts) {\n            for (const [familyId, familyInfo] of Object.entries(this.resources.fonts)){\n                // Check family name match\n                if (familyInfo.name && (familyInfo.name.toLowerCase().includes(fontRef.toLowerCase()) || fontRef.toLowerCase().includes(familyInfo.name.toLowerCase()))) {\n                    console.log('Font partially matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                    return familyInfo.name;\n                }\n                // Check individual font matches\n                if (familyInfo.fonts) {\n                    for (const font of familyInfo.fonts){\n                        if (font.self === fontRef || font.postScriptName === fontRef || font.name === fontRef) {\n                            console.log('Font exactly matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                            return familyInfo.name;\n                        }\n                    }\n                }\n            }\n        }\n        console.log('Font not found: \"'.concat(fontRef, '\", using fallback'));\n        return this.getDefaultFont() || fontRef;\n    }\n    getDefaultFont() {\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFamily = Object.values(this.resources.fonts)[0];\n            return firstFamily.name || \"Arial\";\n        }\n        return \"Arial\";\n    }\n    inferFontFromContext() {\n        // If we have font definitions but no explicit references, \n        // return the first available font as a fallback\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFontFamily = Object.values(this.resources.fonts)[0];\n            return firstFontFamily.name;\n        }\n        return null;\n    }\n    getStoryStyleSummary(story) {\n        var _story_content_formattedContent, _story_content;\n        const summary = {\n            fontSize: null,\n            fontFamily: null,\n            alignment: null,\n            fillColor: null,\n            fontStyle: null,\n            leading: null,\n            leadingType: null,\n            effectiveLineHeight: null,\n            tracking: null,\n            kerning: null\n        };\n        // Get the most common or first formatting values\n        if (((_story_content = story.content) === null || _story_content === void 0 ? void 0 : (_story_content_formattedContent = _story_content.formattedContent) === null || _story_content_formattedContent === void 0 ? void 0 : _story_content_formattedContent.length) > 0) {\n            const firstFormatted = story.content.formattedContent.find((item)=>item.formatting && !item.formatting.isBreak);\n            if (firstFormatted === null || firstFormatted === void 0 ? void 0 : firstFormatted.formatting) {\n                const fmt = firstFormatted.formatting;\n                summary.fontSize = fmt.fontSize;\n                summary.fontFamily = fmt.fontFamily;\n                summary.alignment = fmt.alignment;\n                summary.fillColor = fmt.fillColor;\n                summary.fontStyle = fmt.fontStyle;\n                summary.leading = fmt.leading;\n                summary.leadingType = fmt.leadingType;\n                summary.effectiveLineHeight = fmt.effectiveLineHeight;\n                summary.tracking = fmt.tracking;\n                summary.kerning = fmt.kerning;\n            }\n        }\n        return summary;\n    }\n    // NEW: Process leading values with InDesign-specific logic (shared with StoryParser)\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = parseFloat(rawLeading);\n        if (!isNaN(numericLeading)) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (!isNaN(parseFloat(rawLeading))) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(leading, fontSize) {\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\" && fontSize) {\n            // Convert points to CSS line-height ratio\n            return Math.max(0.8, leading / fontSize); // Ensure minimum line height\n        }\n        return 1.2; // Fallback\n    }\n    getStyles() {\n        return this.styles;\n    }\n    getResources() {\n        return this.resources;\n    }\n    getFontMap() {\n        return this.fontMap;\n    }\n    constructor(){\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n        this.resources = {\n            fonts: {},\n            colors: {},\n            gradients: {}\n        };\n        this.fontMap = new Map(); // Global font lookup map\n    }\n}\nmodule.exports = StyleParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU87SUFDVDtJQUVBLHlEQUF5RDtJQUN6RFksNkJBQTZCSixPQUFPLEVBQUVWLFFBQVEsRUFBRTtRQUM5QyxJQUFJVSxZQUFZLFFBQVE7WUFDdEIsT0FBTyxLQUFLLGlDQUFpQztRQUMvQztRQUVBLElBQUksT0FBT0EsWUFBWSxZQUFZVixVQUFVO1lBQzNDLDBDQUEwQztZQUMxQyxPQUFPNkwsS0FBS0MsR0FBRyxDQUFDLEtBQUtwTCxVQUFVVixXQUFXLDZCQUE2QjtRQUN6RTtRQUVBLE9BQU8sS0FBSyxXQUFXO0lBQ3pCO0lBRUErTCxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUMvTSxNQUFNO0lBQ3BCO0lBRUFnTixlQUFlO1FBQ2IsT0FBTyxJQUFJLENBQUN2SixTQUFTO0lBQ3ZCO0lBRUF3SixhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUN2SixPQUFPO0lBQ3JCO0lBdHJCQXdKLGFBQWM7UUFDWixJQUFJLENBQUNsTixNQUFNLEdBQUc7WUFDWnFCLFdBQVcsQ0FBQztZQUNaOEIsV0FBVyxDQUFDO1lBQ1pnSyxRQUFRLENBQUM7WUFDVEMsT0FBTyxDQUFDO1lBQ1JDLE1BQU0sQ0FBQztRQUNUO1FBQ0EsSUFBSSxDQUFDNUosU0FBUyxHQUFHO1lBQ2ZGLE9BQU8sQ0FBQztZQUNSeUIsUUFBUSxDQUFDO1lBQ1RDLFdBQVcsQ0FBQztRQUNkO1FBQ0EsSUFBSSxDQUFDdkIsT0FBTyxHQUFHLElBQUlDLE9BQU8seUJBQXlCO0lBQ3JEO0FBeXFCRjtBQUVBMkosT0FBT0MsT0FBTyxHQUFHMU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3BhcnNlcnMvU3R5bGVQYXJzZXIuanM/NjlhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBJRE1MVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9JRE1MVXRpbHMnKTtcclxuXHJcbmNsYXNzIFN0eWxlUGFyc2VyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuc3R5bGVzID0ge1xyXG4gICAgICBwYXJhZ3JhcGg6IHt9LFxyXG4gICAgICBjaGFyYWN0ZXI6IHt9LFxyXG4gICAgICBvYmplY3Q6IHt9LFxyXG4gICAgICB0YWJsZToge30sXHJcbiAgICAgIGNlbGw6IHt9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5yZXNvdXJjZXMgPSB7XHJcbiAgICAgIGZvbnRzOiB7fSxcclxuICAgICAgY29sb3JzOiB7fSxcclxuICAgICAgZ3JhZGllbnRzOiB7fVxyXG4gICAgfTtcclxuICAgIHRoaXMuZm9udE1hcCA9IG5ldyBNYXAoKTsgLy8gR2xvYmFsIGZvbnQgbG9va3VwIG1hcFxyXG4gIH1cclxuXHJcbiAgYXN5bmMgcGFyc2VSZXNvdXJjZUZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coYPCfk4sgUGFyc2luZyByZXNvdXJjZTogJHtmaWxlTmFtZX1gKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGFyc2VkID0geG1sUGFyc2VyLnBhcnNlKGNvbnRlbnQpO1xyXG4gICAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVOYW1lLCAnLnhtbCcpO1xyXG4gICAgICBcclxuICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCByZXNvdXJjZSB0eXBlc1xyXG4gICAgICBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoJ1N0eWxlcy54bWwnKSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdFN0eWxlcyhwYXJzZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKCdGb250cy54bWwnKSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdEZvbnRzKHBhcnNlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoJ0dyYXBoaWMueG1sJykpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RHcmFwaGljcyhwYXJzZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKCdQcmVmZXJlbmNlcy54bWwnKSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdFByZWZlcmVuY2VzKHBhcnNlZCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUmVzb3VyY2UgJHtyZXNvdXJjZU5hbWV9IHBhcnNlZGApO1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBwYXJzaW5nICR7ZmlsZU5hbWV9OmAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdFN0eWxlcyhzdHlsZXNEYXRhKSB7XHJcbiAgICBjb25zb2xlLmxvZygnRXh0cmFjdGluZyBzdHlsZXMuLi4nKTtcclxuICAgIFxyXG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVzRGF0YS5TdHlsZXMgfHwgc3R5bGVzRGF0YTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBQYXJhZ3JhcGggU3R5bGVzXHJcbiAgICBpZiAoc3R5bGVzLlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XHJcbiAgICAgIHRoaXMuZXh0cmFjdFBhcmFncmFwaFN0eWxlcyhzdHlsZXMuUm9vdFBhcmFncmFwaFN0eWxlR3JvdXApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IENoYXJhY3RlciBTdHlsZXMgIFxyXG4gICAgaWYgKHN0eWxlcy5Sb290Q2hhcmFjdGVyU3R5bGVHcm91cCkge1xyXG4gICAgICB0aGlzLmV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVzLlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMoc3R5bGVHcm91cCkge1xyXG4gICAgY29uc3QgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5ID0gKGdyb3VwKSA9PiB7XHJcbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZSkge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuUGFyYWdyYXBoU3R5bGUpID8gZ3JvdXAuUGFyYWdyYXBoU3R5bGUgOiBbZ3JvdXAuUGFyYWdyYXBoU3R5bGVdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcclxuICAgICAgICAgIC8vIENSSVRJQ0FMOiBFeHRyYWN0IGZvbnQgcmVmZXJlbmNlIGZyb20gbXVsdGlwbGUgcG9zc2libGUgbG9jYXRpb25zXHJcbiAgICAgICAgICBjb25zdCBmb250UmVmID0gdGhpcy5leHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEVOSEFOQ0VEOiBQcm9jZXNzIGxlYWRpbmcgd2l0aCBwcm9wZXIgSW5EZXNpZ24gbG9naWNcclxuICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gcGFyc2VGbG9hdChzdHlsZVsnQF9Qb2ludFNpemUnXSkgfHwgMTI7XHJcbiAgICAgICAgICBjb25zdCByYXdMZWFkaW5nID0gc3R5bGVbJ0BfTGVhZGluZyddO1xyXG4gICAgICAgICAgY29uc3QgcHJvY2Vzc2VkTGVhZGluZyA9IHRoaXMucHJvY2Vzc0xlYWRpbmdWYWx1ZShyYXdMZWFkaW5nLCBmb250U2l6ZSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHRoaXMuc3R5bGVzLnBhcmFncmFwaFtzdHlsZVsnQF9TZWxmJ11dID0ge1xyXG4gICAgICAgICAgICBzZWxmOiBzdHlsZVsnQF9TZWxmJ10sXHJcbiAgICAgICAgICAgIG5hbWU6IHN0eWxlWydAX05hbWUnXSB8fCAnJyxcclxuICAgICAgICAgICAgZm9udFN0eWxlOiBzdHlsZVsnQF9Gb250U3R5bGUnXSB8fCAnUmVndWxhcicsXHJcbiAgICAgICAgICAgIHBvaW50U2l6ZTogZm9udFNpemUsXHJcbiAgICAgICAgICAgIGxlYWRpbmc6IHByb2Nlc3NlZExlYWRpbmcsXHJcbiAgICAgICAgICAgIGxlYWRpbmdUeXBlOiB0aGlzLmRldGVybWluZUxlYWRpbmdUeXBlKHJhd0xlYWRpbmcpLFxyXG4gICAgICAgICAgICBlZmZlY3RpdmVMaW5lSGVpZ2h0OiB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQocHJvY2Vzc2VkTGVhZGluZywgZm9udFNpemUpLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IHN0eWxlWydAX0p1c3RpZmljYXRpb24nXSB8fCAnTGVmdEFsaWduJyxcclxuICAgICAgICAgICAgbGVmdEluZGVudDogcGFyc2VGbG9hdChzdHlsZVsnQF9MZWZ0SW5kZW50J10pIHx8IDAsXHJcbiAgICAgICAgICAgIHJpZ2h0SW5kZW50OiBwYXJzZUZsb2F0KHN0eWxlWydAX1JpZ2h0SW5kZW50J10pIHx8IDAsXHJcbiAgICAgICAgICAgIGZpcnN0TGluZUluZGVudDogcGFyc2VGbG9hdChzdHlsZVsnQF9GaXJzdExpbmVJbmRlbnQnXSkgfHwgMCxcclxuICAgICAgICAgICAgc3BhY2VCZWZvcmU6IHBhcnNlRmxvYXQoc3R5bGVbJ0BfU3BhY2VCZWZvcmUnXSkgfHwgMCxcclxuICAgICAgICAgICAgc3BhY2VBZnRlcjogcGFyc2VGbG9hdChzdHlsZVsnQF9TcGFjZUFmdGVyJ10pIHx8IDAsXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBUeXBvZ3JhcGh5IGVuaGFuY2VtZW50c1xyXG4gICAgICAgICAgICB0cmFja2luZzogcGFyc2VGbG9hdChzdHlsZVsnQF9UcmFja2luZyddKSB8fCAwLFxyXG4gICAgICAgICAgICBrZXJuaW5nOiBwYXJzZUZsb2F0KHN0eWxlWydAX0tlcm5pbmcnXSkgfHwgMCxcclxuICAgICAgICAgICAgaG9yaXpvbnRhbFNjYWxlOiBwYXJzZUZsb2F0KHN0eWxlWydAX0hvcml6b250YWxTY2FsZSddKSB8fCAxMDAsXHJcbiAgICAgICAgICAgIHZlcnRpY2FsU2NhbGU6IHBhcnNlRmxvYXQoc3R5bGVbJ0BfVmVydGljYWxTY2FsZSddKSB8fCAxMDAsXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBFTkhBTkNFRDogVXNlIHRoZSBuZXcgZXh0cmFjdGlvbiBtZXRob2RcclxuICAgICAgICAgICAgYXBwbGllZEZvbnQ6IGZvbnRSZWYsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsRm9udFJlZjogZm9udFJlZixcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogc3R5bGVbJ0BfRmlsbENvbG9yJ10gfHwgJ0NvbG9yL0JsYWNrJyxcclxuICAgICAgICAgICAgcmF3U3R5bGU6IHN0eWxlXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFBhcmFncmFwaCBTdHlsZTogJHtzdHlsZVsnQF9OYW1lJ119IC0+IEZvbnQ6IFwiJHtmb250UmVmfVwiYCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XHJcbiAgICAgICAgY29uc3Qgc3ViR3JvdXBzID0gQXJyYXkuaXNBcnJheShncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwKSA/IGdyb3VwLlBhcmFncmFwaFN0eWxlR3JvdXAgOiBbZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cF07XHJcbiAgICAgICAgc3ViR3JvdXBzLmZvckVhY2goZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KHN0eWxlR3JvdXApO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdEZvbnRGcm9tU3R5bGUoc3R5bGUpIHtcclxuICAgIC8vIFRyeSBkaXJlY3QgYXR0cmlidXRlcyBmaXJzdFxyXG4gICAgbGV0IGZvbnRSZWYgPSBzdHlsZVsnQF9BcHBsaWVkRm9udCddIHx8IFxyXG4gICAgICAgICAgICAgICAgIHN0eWxlWydAX0ZvbnRGYW1pbHknXSB8fCBcclxuICAgICAgICAgICAgICAgICBzdHlsZVsnQF9Gb250J10gfHwgJyc7XHJcbiAgICBcclxuICAgIC8vIElmIG5vdCBmb3VuZCwgdHJ5IFByb3BlcnRpZXMgbmVzdGVkIHN0cnVjdHVyZVxyXG4gICAgaWYgKCFmb250UmVmICYmIHN0eWxlLlByb3BlcnRpZXMpIHtcclxuICAgICAgaWYgKHN0eWxlLlByb3BlcnRpZXMuQXBwbGllZEZvbnQpIHtcclxuICAgICAgICBmb250UmVmID0gc3R5bGUuUHJvcGVydGllcy5BcHBsaWVkRm9udFsnI3RleHQnXSB8fCBcclxuICAgICAgICAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250IHx8ICcnO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBBbHNvIHRyeSBvdGhlciBwcm9wZXJ0eSB2YXJpYXRpb25zXHJcbiAgICAgIGlmICghZm9udFJlZiAmJiBzdHlsZS5Qcm9wZXJ0aWVzLkZvbnRGYW1pbHkpIHtcclxuICAgICAgICBmb250UmVmID0gc3R5bGUuUHJvcGVydGllcy5Gb250RmFtaWx5WycjdGV4dCddIHx8IFxyXG4gICAgICAgICAgICAgICAgIHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseSB8fCAnJztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZm9udFJlZiB8fCAnJztcclxuICB9XHJcblxyXG4gIGV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVHcm91cCkge1xyXG4gICAgY29uc3QgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5ID0gKGdyb3VwKSA9PiB7XHJcbiAgICAgIGlmIChncm91cC5DaGFyYWN0ZXJTdHlsZSkge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuQ2hhcmFjdGVyU3R5bGUpID8gZ3JvdXAuQ2hhcmFjdGVyU3R5bGUgOiBbZ3JvdXAuQ2hhcmFjdGVyU3R5bGVdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcclxuICAgICAgICAgIGNvbnN0IGZvbnRSZWYgPSB0aGlzLmV4dHJhY3RGb250RnJvbVN0eWxlKHN0eWxlKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgdGhpcy5zdHlsZXMuY2hhcmFjdGVyW3N0eWxlWydAX1NlbGYnXV0gPSB7XHJcbiAgICAgICAgICAgIHNlbGY6IHN0eWxlWydAX1NlbGYnXSxcclxuICAgICAgICAgICAgbmFtZTogc3R5bGVbJ0BfTmFtZSddIHx8ICcnLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6IHN0eWxlWydAX0ZvbnRTdHlsZSddIHx8ICdSZWd1bGFyJyxcclxuICAgICAgICAgICAgcG9pbnRTaXplOiBwYXJzZUZsb2F0KHN0eWxlWydAX1BvaW50U2l6ZSddKSB8fCBudWxsLFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYXBwbGllZEZvbnQ6IGZvbnRSZWYsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsRm9udFJlZjogZm9udFJlZixcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogc3R5bGVbJ0BfRmlsbENvbG9yJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHN0eWxlWydAX1N0cm9rZUNvbG9yJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgcmF3U3R5bGU6IHN0eWxlXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIENoYXJhY3RlciBTdHlsZTogJHtzdHlsZVsnQF9OYW1lJ119IC0+IEZvbnQ6IFwiJHtmb250UmVmfVwiYCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwKSB7XHJcbiAgICAgICAgY29uc3Qgc3ViR3JvdXBzID0gQXJyYXkuaXNBcnJheShncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwKSA/IGdyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXAgOiBbZ3JvdXAuQ2hhcmFjdGVyU3R5bGVHcm91cF07XHJcbiAgICAgICAgc3ViR3JvdXBzLmZvckVhY2goZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KHN0eWxlR3JvdXApO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdEZvbnRzKGZvbnRzRGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coJ0V4dHJhY3RpbmcgZm9udHMgd2l0aCBlbmhhbmNlZCBtYXBwaW5nLi4uJyk7XHJcbiAgICBcclxuICAgIGNvbnN0IGZvbnRzID0gZm9udHNEYXRhLkZvbnRzIHx8IGZvbnRzRGF0YTtcclxuICAgIHRoaXMucmVzb3VyY2VzLmZvbnRzID0ge307XHJcbiAgICB0aGlzLmZvbnRNYXAgPSBuZXcgTWFwKCk7IC8vIEdsb2JhbCBmb250IGxvb2t1cCBtYXBcclxuICAgIFxyXG4gICAgaWYgKGZvbnRzLkZvbnRGYW1pbHkpIHtcclxuICAgICAgY29uc3QgZm9udEZhbWlsaWVzID0gQXJyYXkuaXNBcnJheShmb250cy5Gb250RmFtaWx5KSA/IGZvbnRzLkZvbnRGYW1pbHkgOiBbZm9udHMuRm9udEZhbWlseV07XHJcbiAgICAgIFxyXG4gICAgICBmb250RmFtaWxpZXMuZm9yRWFjaChmYW1pbHkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZhbWlseUluZm8gPSB7XHJcbiAgICAgICAgICBzZWxmOiBmYW1pbHlbJ0BfU2VsZiddLFxyXG4gICAgICAgICAgbmFtZTogZmFtaWx5WydAX05hbWUnXSB8fCAnJyxcclxuICAgICAgICAgIGZvbnRzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGZhbWlseS5Gb250KSB7XHJcbiAgICAgICAgICBjb25zdCBmb250TGlzdCA9IEFycmF5LmlzQXJyYXkoZmFtaWx5LkZvbnQpID8gZmFtaWx5LkZvbnQgOiBbZmFtaWx5LkZvbnRdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBmb250TGlzdC5mb3JFYWNoKGZvbnQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmb250SW5mbyA9IHtcclxuICAgICAgICAgICAgICBzZWxmOiBmb250WydAX1NlbGYnXSxcclxuICAgICAgICAgICAgICBmb250RmFtaWx5OiBmb250WydAX0ZvbnRGYW1pbHknXSB8fCBmYW1pbHlJbmZvLm5hbWUsXHJcbiAgICAgICAgICAgICAgbmFtZTogZm9udFsnQF9OYW1lJ10gfHwgJycsXHJcbiAgICAgICAgICAgICAgcG9zdFNjcmlwdE5hbWU6IGZvbnRbJ0BfUG9zdFNjcmlwdE5hbWUnXSB8fCAnJyxcclxuICAgICAgICAgICAgICBzdGF0dXM6IGZvbnRbJ0BfU3RhdHVzJ10gfHwgJ1Vua25vd24nLFxyXG4gICAgICAgICAgICAgIGZvbnRTdHlsZU5hbWU6IGZvbnRbJ0BfRm9udFN0eWxlTmFtZSddIHx8ICdSZWd1bGFyJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZmFtaWx5SW5mby5mb250cy5wdXNoKGZvbnRJbmZvKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBsb29rdXAgZW50cmllcyBmb3IgdGhpcyBmb250XHJcbiAgICAgICAgICAgIHRoaXMuZm9udE1hcC5zZXQoZm9udFsnQF9TZWxmJ10sIGZhbWlseUluZm8ubmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udE1hcC5zZXQoZm9udFsnQF9Qb3N0U2NyaXB0TmFtZSddLCBmYW1pbHlJbmZvLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbJ0BfTmFtZSddLCBmYW1pbHlJbmZvLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbJ0BfRm9udEZhbWlseSddLCBmYW1pbHlJbmZvLm5hbWUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEZvbnQgbWFwcGluZzogJHtmb250WydAX1NlbGYnXX0gLT4gJHtmYW1pbHlJbmZvLm5hbWV9YCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZm9udHNbZmFtaWx5WydAX1NlbGYnXV0gPSBmYW1pbHlJbmZvO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYOKchSBGb250cyBleHRyYWN0ZWQ6ICR7T2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuZm9udHMpLmxlbmd0aH0gZmFtaWxpZXNgKTtcclxuICAgIGNvbnNvbGUubG9nKGBGb250IG1hcCBlbnRyaWVzOiAke3RoaXMuZm9udE1hcC5zaXplfWApO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdEdyYXBoaWNzKGdyYXBoaWNzRGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coJ0V4dHJhY3RpbmcgZ3JhcGhpY3MgYW5kIGNvbG9ycy4uLicpO1xyXG4gICAgXHJcbiAgICBjb25zdCBncmFwaGljcyA9IGdyYXBoaWNzRGF0YS5HcmFwaGljIHx8IGdyYXBoaWNzRGF0YTtcclxuICAgIHRoaXMucmVzb3VyY2VzLmNvbG9ycyA9IHt9O1xyXG4gICAgdGhpcy5yZXNvdXJjZXMuZ3JhZGllbnRzID0ge307XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgQ29sb3JzXHJcbiAgICBpZiAoZ3JhcGhpY3MuQ29sb3IpIHtcclxuICAgICAgY29uc3QgY29sb3JzID0gQXJyYXkuaXNBcnJheShncmFwaGljcy5Db2xvcikgPyBncmFwaGljcy5Db2xvciA6IFtncmFwaGljcy5Db2xvcl07XHJcbiAgICAgIFxyXG4gICAgICBjb2xvcnMuZm9yRWFjaChjb2xvciA9PiB7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuY29sb3JzW2NvbG9yWydAX1NlbGYnXV0gPSB7XHJcbiAgICAgICAgICBzZWxmOiBjb2xvclsnQF9TZWxmJ10sXHJcbiAgICAgICAgICBuYW1lOiBjb2xvclsnQF9OYW1lJ10gfHwgJycsXHJcbiAgICAgICAgICBtb2RlbDogY29sb3JbJ0BfTW9kZWwnXSB8fCAnUHJvY2VzcycsXHJcbiAgICAgICAgICBzcGFjZTogY29sb3JbJ0BfU3BhY2UnXSB8fCAnQ01ZSycsXHJcbiAgICAgICAgICBjeWFuOiBwYXJzZUZsb2F0KGNvbG9yWydAX0N5YW4nXSkgfHwgMCxcclxuICAgICAgICAgIG1hZ2VudGE6IHBhcnNlRmxvYXQoY29sb3JbJ0BfTWFnZW50YSddKSB8fCAwLFxyXG4gICAgICAgICAgeWVsbG93OiBwYXJzZUZsb2F0KGNvbG9yWydAX1llbGxvdyddKSB8fCAwLFxyXG4gICAgICAgICAgYmxhY2s6IHBhcnNlRmxvYXQoY29sb3JbJ0BfQmxhY2snXSkgfHwgMCxcclxuICAgICAgICAgIHJlZDogcGFyc2VGbG9hdChjb2xvclsnQF9SZWQnXSkgfHwgMCxcclxuICAgICAgICAgIGdyZWVuOiBwYXJzZUZsb2F0KGNvbG9yWydAX0dyZWVuJ10pIHx8IDAsXHJcbiAgICAgICAgICBibHVlOiBwYXJzZUZsb2F0KGNvbG9yWydAX0JsdWUnXSkgfHwgMFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IEdyYWRpZW50c1xyXG4gICAgaWYgKGdyYXBoaWNzLkdyYWRpZW50KSB7XHJcbiAgICAgIGNvbnN0IGdyYWRpZW50cyA9IEFycmF5LmlzQXJyYXkoZ3JhcGhpY3MuR3JhZGllbnQpID8gZ3JhcGhpY3MuR3JhZGllbnQgOiBbZ3JhcGhpY3MuR3JhZGllbnRdO1xyXG4gICAgICBcclxuICAgICAgZ3JhZGllbnRzLmZvckVhY2goZ3JhZGllbnQgPT4ge1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzLmdyYWRpZW50c1tncmFkaWVudFsnQF9TZWxmJ11dID0ge1xyXG4gICAgICAgICAgc2VsZjogZ3JhZGllbnRbJ0BfU2VsZiddLFxyXG4gICAgICAgICAgbmFtZTogZ3JhZGllbnRbJ0BfTmFtZSddIHx8ICcnLFxyXG4gICAgICAgICAgdHlwZTogZ3JhZGllbnRbJ0BfVHlwZSddIHx8ICdMaW5lYXInLFxyXG4gICAgICAgICAgZ3JhZGllbnRTdG9wczogdGhpcy5leHRyYWN0R3JhZGllbnRTdG9wcyhncmFkaWVudClcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4dHJhY3RHcmFkaWVudFN0b3BzKGdyYWRpZW50KSB7XHJcbiAgICBjb25zdCBzdG9wcyA9IFtdO1xyXG4gICAgXHJcbiAgICBpZiAoZ3JhZGllbnQuR3JhZGllbnRTdG9wKSB7XHJcbiAgICAgIGNvbnN0IHN0b3BMaXN0ID0gQXJyYXkuaXNBcnJheShncmFkaWVudC5HcmFkaWVudFN0b3ApID8gZ3JhZGllbnQuR3JhZGllbnRTdG9wIDogW2dyYWRpZW50LkdyYWRpZW50U3RvcF07XHJcbiAgICAgIFxyXG4gICAgICBzdG9wTGlzdC5mb3JFYWNoKHN0b3AgPT4ge1xyXG4gICAgICAgIHN0b3BzLnB1c2goe1xyXG4gICAgICAgICAgc2VsZjogc3RvcFsnQF9TZWxmJ10sXHJcbiAgICAgICAgICBzdG9wQ29sb3I6IHN0b3BbJ0BfU3RvcENvbG9yJ10gfHwgJycsXHJcbiAgICAgICAgICBsb2NhdGlvbjogcGFyc2VGbG9hdChzdG9wWydAX0xvY2F0aW9uJ10pIHx8IDAsXHJcbiAgICAgICAgICBtaWRwb2ludDogcGFyc2VGbG9hdChzdG9wWydAX01pZHBvaW50J10pIHx8IDUwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gc3RvcHM7XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHRyYWN0UHJlZmVyZW5jZXMocHJlZmVyZW5jZXNEYXRhKSB7XHJcbiAgICBjb25zb2xlLmxvZygnRXh0cmFjdGluZyBkb2N1bWVudCBwcmVmZXJlbmNlcy4uLicpO1xyXG4gICAgXHJcbiAgICBjb25zdCBwcmVmcyA9IHByZWZlcmVuY2VzRGF0YS5QcmVmZXJlbmNlcyB8fCBwcmVmZXJlbmNlc0RhdGE7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgdmFyaW91cyBkb2N1bWVudCBwcmVmZXJlbmNlc1xyXG4gICAgdGhpcy5kb2N1bWVudEluZm8gPSB7XHJcbiAgICAgIHByZWZlcmVuY2VzOiB7XHJcbiAgICAgICAgZG9jdW1lbnRQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0RG9jdW1lbnRQcmVmcyhwcmVmcy5Eb2N1bWVudFByZWZlcmVuY2UpLFxyXG4gICAgICAgIHZpZXdQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0Vmlld1ByZWZzKHByZWZzLlZpZXdQcmVmZXJlbmNlKSxcclxuICAgICAgICBndWlkZVByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RHdWlkZVByZWZzKHByZWZzLkd1aWRlUHJlZmVyZW5jZSksXHJcbiAgICAgICAgZ3JpZFByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RHcmlkUHJlZnMocHJlZnMuR3JpZFByZWZlcmVuY2UpLFxyXG4gICAgICAgIG1hcmdpblByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RNYXJnaW5QcmVmcyhwcmVmcy5NYXJnaW5QcmVmZXJlbmNlKSxcclxuICAgICAgICBjb2x1bW5QcmVmZXJlbmNlczogdGhpcy5leHRyYWN0Q29sdW1uUHJlZnMocHJlZnMuQ29sdW1uUHJlZmVyZW5jZSlcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3REb2N1bWVudFByZWZzKGRvY1ByZWYpIHtcclxuICAgIGlmICghZG9jUHJlZikgcmV0dXJuIHt9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwYWdlV2lkdGg6IHBhcnNlRmxvYXQoZG9jUHJlZlsnQF9QYWdlV2lkdGgnXSkgfHwgMCxcclxuICAgICAgcGFnZUhlaWdodDogcGFyc2VGbG9hdChkb2NQcmVmWydAX1BhZ2VIZWlnaHQnXSkgfHwgMCxcclxuICAgICAgbGVmdDogcGFyc2VGbG9hdChkb2NQcmVmWydAX0xlZnQnXSkgfHwgMCxcclxuICAgICAgdG9wOiBwYXJzZUZsb2F0KGRvY1ByZWZbJ0BfVG9wJ10pIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBwYXJzZUZsb2F0KGRvY1ByZWZbJ0BfUmlnaHQnXSkgfHwgMCxcclxuICAgICAgYm90dG9tOiBwYXJzZUZsb2F0KGRvY1ByZWZbJ0BfQm90dG9tJ10pIHx8IDAsXHJcbiAgICAgIGNvbHVtbkNvdW50OiBwYXJzZUludChkb2NQcmVmWydAX0NvbHVtbkNvdW50J10pIHx8IDEsXHJcbiAgICAgIGNvbHVtbkd1dHRlcjogcGFyc2VGbG9hdChkb2NQcmVmWydAX0NvbHVtbkd1dHRlciddKSB8fCAwLFxyXG4gICAgICBmYWNpbmdQYWdlczogZG9jUHJlZlsnQF9GYWNpbmdQYWdlcyddID09PSB0cnVlLFxyXG4gICAgICBhbGxvd1BhZ2VTaHVmZmxlOiBkb2NQcmVmWydAX0FsbG93UGFnZVNodWZmbGUnXSAhPT0gZmFsc2UsXHJcbiAgICAgIHNsdWdCbGVlZFR5cGU6IGRvY1ByZWZbJ0BfU2x1Z0JsZWVkVHlwZSddIHx8ICdOb25lJyxcclxuICAgICAgZG9jdW1lbnRCbGVlZFRvcE9mZnNldDogcGFyc2VGbG9hdChkb2NQcmVmWydAX0RvY3VtZW50QmxlZWRUb3BPZmZzZXQnXSkgfHwgMCxcclxuICAgICAgZG9jdW1lbnRCbGVlZEJvdHRvbU9mZnNldDogcGFyc2VGbG9hdChkb2NQcmVmWydAX0RvY3VtZW50QmxlZWRCb3R0b21PZmZzZXQnXSkgfHwgMCxcclxuICAgICAgZG9jdW1lbnRCbGVlZEluc2lkZU9yTGVmdE9mZnNldDogcGFyc2VGbG9hdChkb2NQcmVmWydAX0RvY3VtZW50QmxlZWRJbnNpZGVPckxlZnRPZmZzZXQnXSkgfHwgMCxcclxuICAgICAgZG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0OiBwYXJzZUZsb2F0KGRvY1ByZWZbJ0BfRG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0J10pIHx8IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0Vmlld1ByZWZzKHZpZXdQcmVmKSB7XHJcbiAgICBpZiAoIXZpZXdQcmVmKSByZXR1cm4ge307XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGhvcml6b250YWxNZWFzdXJlbWVudFVuaXRzOiB2aWV3UHJlZlsnQF9Ib3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cyddIHx8ICdQb2ludHMnLFxyXG4gICAgICB2ZXJ0aWNhbE1lYXN1cmVtZW50VW5pdHM6IHZpZXdQcmVmWydAX1ZlcnRpY2FsTWVhc3VyZW1lbnRVbml0cyddIHx8ICdQb2ludHMnLFxyXG4gICAgICBydWxlck9yaWdpbjogdmlld1ByZWZbJ0BfUnVsZXJPcmlnaW4nXSB8fCAnU3ByZWFkT3JpZ2luJyxcclxuICAgICAgc2hvd1J1bGVyczogdmlld1ByZWZbJ0BfU2hvd1J1bGVycyddICE9PSBmYWxzZVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RHdWlkZVByZWZzKGd1aWRlUHJlZikge1xyXG4gICAgaWYgKCFndWlkZVByZWYpIHJldHVybiB7fTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcnVsZXJHdWlkZUNvbG9yOiBndWlkZVByZWZbJ0BfUnVsZXJHdWlkZUNvbG9yJ10gfHwgJ0dyZWVuJyxcclxuICAgICAgZ3VpZGVzSW5CYWNrOiBndWlkZVByZWZbJ0BfR3VpZGVzSW5CYWNrJ10gPT09IHRydWUsXHJcbiAgICAgIGd1aWRlc0xvY2tlZDogZ3VpZGVQcmVmWydAX0d1aWRlc0xvY2tlZCddID09PSB0cnVlLFxyXG4gICAgICBndWlkZXNTaG93bjogZ3VpZGVQcmVmWydAX0d1aWRlc1Nob3duJ10gIT09IGZhbHNlLFxyXG4gICAgICBndWlkZXNTbmFwdG86IGd1aWRlUHJlZlsnQF9HdWlkZXNTbmFwdG8nXSAhPT0gZmFsc2VcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3JpZFByZWZzKGdyaWRQcmVmKSB7XHJcbiAgICBpZiAoIWdyaWRQcmVmKSByZXR1cm4ge307XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJhc2VsaW5lU3RhcnQ6IHBhcnNlRmxvYXQoZ3JpZFByZWZbJ0BfQmFzZWxpbmVTdGFydCddKSB8fCAwLFxyXG4gICAgICBiYXNlbGluZURpdmlzaW9uOiBwYXJzZUZsb2F0KGdyaWRQcmVmWydAX0Jhc2VsaW5lRGl2aXNpb24nXSkgfHwgMTIsXHJcbiAgICAgIGJhc2VsaW5lU2hvd246IGdyaWRQcmVmWydAX0Jhc2VsaW5lU2hvd24nXSA9PT0gdHJ1ZSxcclxuICAgICAgYmFzZWxpbmVTbmFwdG86IGdyaWRQcmVmWydAX0Jhc2VsaW5lU25hcHRvJ10gPT09IHRydWUsXHJcbiAgICAgIGRvY3VtZW50R3JpZFNob3duOiBncmlkUHJlZlsnQF9Eb2N1bWVudEdyaWRTaG93biddID09PSB0cnVlLFxyXG4gICAgICBkb2N1bWVudEdyaWRTbmFwdG86IGdyaWRQcmVmWydAX0RvY3VtZW50R3JpZFNuYXB0byddID09PSB0cnVlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdE1hcmdpblByZWZzKG1hcmdpblByZWYpIHtcclxuICAgIGlmICghbWFyZ2luUHJlZikgcmV0dXJuIHt9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IHBhcnNlRmxvYXQobWFyZ2luUHJlZlsnQF9Ub3AnXSkgfHwgMCxcclxuICAgICAgYm90dG9tOiBwYXJzZUZsb2F0KG1hcmdpblByZWZbJ0BfQm90dG9tJ10pIHx8IDAsXHJcbiAgICAgIGxlZnQ6IHBhcnNlRmxvYXQobWFyZ2luUHJlZlsnQF9MZWZ0J10pIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBwYXJzZUZsb2F0KG1hcmdpblByZWZbJ0BfUmlnaHQnXSkgfHwgMCxcclxuICAgICAgY29sdW1uQ291bnQ6IHBhcnNlSW50KG1hcmdpblByZWZbJ0BfQ29sdW1uQ291bnQnXSkgfHwgMSxcclxuICAgICAgY29sdW1uR3V0dGVyOiBwYXJzZUZsb2F0KG1hcmdpblByZWZbJ0BfQ29sdW1uR3V0dGVyJ10pIHx8IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0Q29sdW1uUHJlZnMoY29sdW1uUHJlZikge1xyXG4gICAgaWYgKCFjb2x1bW5QcmVmKSByZXR1cm4ge307XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHRDb2x1bW5Db3VudDogcGFyc2VJbnQoY29sdW1uUHJlZlsnQF9UZXh0Q29sdW1uQ291bnQnXSkgfHwgMSxcclxuICAgICAgdGV4dENvbHVtbkd1dHRlcjogcGFyc2VGbG9hdChjb2x1bW5QcmVmWydAX1RleHRDb2x1bW5HdXR0ZXInXSkgfHwgMFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJlc29sdmVTdHlsZUZvcm1hdHRpbmcoZm9ybWF0dGluZykge1xyXG4gICAgY29uc3QgcmVzb2x2ZWQgPSB7IC4uLmZvcm1hdHRpbmcgfTtcclxuICAgIFxyXG4gICAgLy8gREVCVUc6IENoZWNrIGlmIGZvcm1hdHRpbmcgaXMgYmVpbmcgYXBwbGllZCAoZ2VuZXJpYyBjaGVjaylcclxuICAgIGNvbnN0IGhhc0FueUZvcm1hdHRpbmcgPSBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlIHx8IGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmcuZm9udFN0eWxlIHx8IGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSB8fCBmb3JtYXR0aW5nLmZvbnRTaXplO1xyXG4gICAgXHJcbiAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UpyBTdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nIC0gSW5wdXQ6Jywge1xyXG4gICAgICAgIHBhcmFncmFwaFN0eWxlOiBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlLFxyXG4gICAgICAgIGNoYXJhY3RlclN0eWxlOiBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlLFxyXG4gICAgICAgIGRpcmVjdEZvbnRTdHlsZTogZm9ybWF0dGluZy5mb250U3R5bGUsXHJcbiAgICAgICAgZGlyZWN0Rm9udFJlZjogZm9ybWF0dGluZy5mb250UmVmZXJlbmNlLFxyXG4gICAgICAgIGRpcmVjdEZvbnRTaXplOiBmb3JtYXR0aW5nLmZvbnRTaXplXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZXNvbHZlIHBhcmFncmFwaCBzdHlsZSAoYmFzZSBsYXllcilcclxuICAgIGlmIChmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlICYmIHRoaXMuc3R5bGVzLnBhcmFncmFwaFtmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlXSkge1xyXG4gICAgICBjb25zdCBwU3R5bGUgPSB0aGlzLnN0eWxlcy5wYXJhZ3JhcGhbZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZV07XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXJlc29sdmVkLmZvbnRTaXplICYmIHBTdHlsZS5wb2ludFNpemUpIHJlc29sdmVkLmZvbnRTaXplID0gcFN0eWxlLnBvaW50U2l6ZTtcclxuICAgICAgaWYgKCFyZXNvbHZlZC5maWxsQ29sb3IgJiYgcFN0eWxlLmZpbGxDb2xvcikgcmVzb2x2ZWQuZmlsbENvbG9yID0gcFN0eWxlLmZpbGxDb2xvcjtcclxuICAgICAgLy8gQ1JJVElDQUwgRklYOiBBbHdheXMgaW5oZXJpdCBwYXJhZ3JhcGggYWxpZ25tZW50IHVubGVzcyBleHBsaWNpdGx5IG92ZXJyaWRkZW5cclxuICAgICAgaWYgKHBTdHlsZS5hbGlnbm1lbnQpIHJlc29sdmVkLmFsaWdubWVudCA9IHBTdHlsZS5hbGlnbm1lbnQ7XHJcbiAgICAgIGlmICghcmVzb2x2ZWQuZm9udFN0eWxlICYmIHBTdHlsZS5mb250U3R5bGUpIHtcclxuICAgICAgICByZXNvbHZlZC5mb250U3R5bGUgPSBwU3R5bGUuZm9udFN0eWxlO1xyXG4gICAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICAgRm9udFN0eWxlIGZyb20gcGFyYWdyYXBoIHN0eWxlOiBcIiR7cFN0eWxlLmZvbnRTdHlsZX1cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ1JJVElDQUw6IFJlc29sdmUgZm9udCBmcm9tIHBhcmFncmFwaCBzdHlsZVxyXG4gICAgICBpZiAoIXJlc29sdmVkLmZvbnRGYW1pbHkgJiYgcFN0eWxlLmFwcGxpZWRGb250KSB7XHJcbiAgICAgICAgcmVzb2x2ZWQuZm9udEZhbWlseSA9IHRoaXMucmVzb2x2ZUZvbnRSZWZlcmVuY2UocFN0eWxlLmFwcGxpZWRGb250KTtcclxuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIEZvbnQgZnJvbSBwYXJhZ3JhcGggc3R5bGU6ICR7cFN0eWxlLmFwcGxpZWRGb250fSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBBZGQgb3RoZXIgcGFyYWdyYXBoIHByb3BlcnRpZXMgd2l0aCBlbmhhbmNlZCBsZWFkaW5nIHN1cHBvcnRcclxuICAgICAgcmVzb2x2ZWQubGVhZGluZyA9IHBTdHlsZS5sZWFkaW5nO1xyXG4gICAgICByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IHBTdHlsZS5sZWFkaW5nVHlwZTtcclxuICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IHBTdHlsZS5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xyXG4gICAgICByZXNvbHZlZC5sZWZ0SW5kZW50ID0gcFN0eWxlLmxlZnRJbmRlbnQ7XHJcbiAgICAgIHJlc29sdmVkLnJpZ2h0SW5kZW50ID0gcFN0eWxlLnJpZ2h0SW5kZW50O1xyXG4gICAgICByZXNvbHZlZC5maXJzdExpbmVJbmRlbnQgPSBwU3R5bGUuZmlyc3RMaW5lSW5kZW50O1xyXG4gICAgICByZXNvbHZlZC5zcGFjZUJlZm9yZSA9IHBTdHlsZS5zcGFjZUJlZm9yZTtcclxuICAgICAgcmVzb2x2ZWQuc3BhY2VBZnRlciA9IHBTdHlsZS5zcGFjZUFmdGVyO1xyXG4gICAgICByZXNvbHZlZC50cmFja2luZyA9IHBTdHlsZS50cmFja2luZztcclxuICAgICAgcmVzb2x2ZWQua2VybmluZyA9IHBTdHlsZS5rZXJuaW5nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZXNvbHZlIGNoYXJhY3RlciBzdHlsZSAob3ZlcnJpZGUgbGF5ZXIpXHJcbiAgICBpZiAoZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZSAmJiB0aGlzLnN0eWxlcy5jaGFyYWN0ZXJbZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZV0pIHtcclxuICAgICAgY29uc3QgY1N0eWxlID0gdGhpcy5zdHlsZXMuY2hhcmFjdGVyW2Zvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVdO1xyXG4gICAgICBcclxuICAgICAgaWYgKGNTdHlsZS5wb2ludFNpemUpIHJlc29sdmVkLmZvbnRTaXplID0gY1N0eWxlLnBvaW50U2l6ZTtcclxuICAgICAgaWYgKGNTdHlsZS5maWxsQ29sb3IpIHJlc29sdmVkLmZpbGxDb2xvciA9IGNTdHlsZS5maWxsQ29sb3I7XHJcbiAgICAgIGlmIChjU3R5bGUuZm9udFN0eWxlKSB7XHJcbiAgICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gY1N0eWxlLmZvbnRTdHlsZTtcclxuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIEZvbnRTdHlsZSBmcm9tIGNoYXJhY3RlciBzdHlsZTogXCIke2NTdHlsZS5mb250U3R5bGV9XCJgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNTdHlsZS5zdHJva2VDb2xvcikgcmVzb2x2ZWQuc3Ryb2tlQ29sb3IgPSBjU3R5bGUuc3Ryb2tlQ29sb3I7XHJcbiAgICAgIFxyXG4gICAgICAvLyBJbmNsdWRlIGxlYWRpbmcgaW5mb3JtYXRpb24gZnJvbSBjaGFyYWN0ZXIgc3R5bGVcclxuICAgICAgaWYgKGNTdHlsZS5sZWFkaW5nKSByZXNvbHZlZC5sZWFkaW5nID0gY1N0eWxlLmxlYWRpbmc7XHJcbiAgICAgIGlmIChjU3R5bGUubGVhZGluZ1R5cGUpIHJlc29sdmVkLmxlYWRpbmdUeXBlID0gY1N0eWxlLmxlYWRpbmdUeXBlO1xyXG4gICAgICBpZiAoY1N0eWxlLmVmZmVjdGl2ZUxpbmVIZWlnaHQpIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSBjU3R5bGUuZWZmZWN0aXZlTGluZUhlaWdodDtcclxuICAgICAgXHJcbiAgICAgIC8vIENSSVRJQ0FMOiBDaGFyYWN0ZXIgc3R5bGUgZm9udCBvdmVycmlkZXMgcGFyYWdyYXBoIHN0eWxlXHJcbiAgICAgIGlmIChjU3R5bGUuYXBwbGllZEZvbnQpIHtcclxuICAgICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShjU3R5bGUuYXBwbGllZEZvbnQpO1xyXG4gICAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICAgRm9udCBmcm9tIGNoYXJhY3RlciBzdHlsZTogJHtjU3R5bGUuYXBwbGllZEZvbnR9IC0+ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQXBwbHkgZGlyZWN0IGZvcm1hdHRpbmcgKGhpZ2hlc3QgcHJpb3JpdHkpXHJcbiAgICBpZiAoZm9ybWF0dGluZy5mb250UmVmZXJlbmNlKSB7XHJcbiAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLnJlc29sdmVGb250UmVmZXJlbmNlKGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSk7XHJcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAgIEZvbnQgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogJHtmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2V9IC0+ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDUklUSUNBTDogQXBwbHkgZGlyZWN0IGZvbnRTdHlsZSBpZiBwcm92aWRlZCAodGhpcyBtaWdodCBiZSB0aGUgaXNzdWUpXHJcbiAgICBpZiAoZm9ybWF0dGluZy5mb250U3R5bGUpIHtcclxuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gZm9ybWF0dGluZy5mb250U3R5bGU7XHJcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAgIEZvbnRTdHlsZSBmcm9tIGRpcmVjdCBmb3JtYXR0aW5nOiBcIiR7Zm9ybWF0dGluZy5mb250U3R5bGV9XCJgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBcHBseSBkaXJlY3QgbGVhZGluZyBpbmZvcm1hdGlvbiAoaGlnaGVzdCBwcmlvcml0eSlcclxuICAgIGlmIChmb3JtYXR0aW5nLmxlYWRpbmcgIT09IHVuZGVmaW5lZCkgcmVzb2x2ZWQubGVhZGluZyA9IGZvcm1hdHRpbmcubGVhZGluZztcclxuICAgIGlmIChmb3JtYXR0aW5nLmxlYWRpbmdUeXBlKSByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IGZvcm1hdHRpbmcubGVhZGluZ1R5cGU7XHJcbiAgICBpZiAoZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0KSByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xyXG4gICAgXHJcbiAgICAvLyBBcHBseSBvdGhlciBkaXJlY3QgZm9ybWF0dGluZyBhdHRyaWJ1dGVzXHJcbiAgICBpZiAoZm9ybWF0dGluZy5mb250U2l6ZSkgcmVzb2x2ZWQuZm9udFNpemUgPSBmb3JtYXR0aW5nLmZvbnRTaXplO1xyXG4gICAgaWYgKGZvcm1hdHRpbmcudHJhY2tpbmcpIHJlc29sdmVkLnRyYWNraW5nID0gZm9ybWF0dGluZy50cmFja2luZztcclxuICAgIGlmIChmb3JtYXR0aW5nLmtlcm5pbmcpIHJlc29sdmVkLmtlcm5pbmcgPSBmb3JtYXR0aW5nLmtlcm5pbmc7XHJcbiAgICBcclxuICAgIC8vIEZJWEVEOiBFbnN1cmUgZm9udFN0eWxlIGRlZmF1bHRzIHRvIFJlZ3VsYXIvbm9ybWFsIGlmIG5vdCBzZXRcclxuICAgIGlmICghcmVzb2x2ZWQuZm9udFN0eWxlIHx8IHJlc29sdmVkLmZvbnRTdHlsZSA9PT0gJycpIHtcclxuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gJ1JlZ3VsYXInO1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBGb250U3R5bGUgZGVmYXVsdGVkIHRvOiBcIlJlZ3VsYXJcImApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEFERElUSU9OQUwgRklYOiBJZiBubyBzdHlsZXMgd2VyZSBhcHBsaWVkIGZyb20gYW55IHNvdXJjZSwgZW5zdXJlIGNsZWFuIGRlZmF1bHRzXHJcbiAgICBpZiAoIWZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGUgJiYgIWZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgJiYgIWZvcm1hdHRpbmcuZm9udFN0eWxlICYmICFmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UpIHtcclxuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gJ1JlZ3VsYXInO1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBObyBzb3VyY2Ugc3R5bGVzIGZvdW5kIC0gZW5zdXJpbmcgY2xlYW4gZGVmYXVsdHNgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBGaW5hbCBmYWxsYmFja1xyXG4gICAgaWYgKCFyZXNvbHZlZC5mb250RmFtaWx5IHx8IHJlc29sdmVkLmZvbnRGYW1pbHkgPT09ICcnKSB7XHJcbiAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLmdldERlZmF1bHRGb250KCk7XHJcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAgIFVzaW5nIGZhbGxiYWNrIGZvbnQ6ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBFbnN1cmUgbGluZSBoZWlnaHQgaXMgY2FsY3VsYXRlZCBpZiBub3QgZXhwbGljaXRseSBzZXRcclxuICAgIGlmICghcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCAmJiByZXNvbHZlZC5mb250U2l6ZSAmJiByZXNvbHZlZC5sZWFkaW5nKSB7XHJcbiAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQocmVzb2x2ZWQubGVhZGluZywgcmVzb2x2ZWQuZm9udFNpemUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UpyBTdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nIC0gRmluYWwgT3V0cHV0OicsIHtcclxuICAgICAgICBmb250U2l6ZTogcmVzb2x2ZWQuZm9udFNpemUsXHJcbiAgICAgICAgZm9udEZhbWlseTogcmVzb2x2ZWQuZm9udEZhbWlseSxcclxuICAgICAgICBmb250U3R5bGU6IHJlc29sdmVkLmZvbnRTdHlsZSxcclxuICAgICAgICBmaWxsQ29sb3I6IHJlc29sdmVkLmZpbGxDb2xvcixcclxuICAgICAgICBsZWFkaW5nOiByZXNvbHZlZC5sZWFkaW5nLFxyXG4gICAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXNvbHZlZDtcclxuICB9XHJcblxyXG4gIHJlc29sdmVGb250UmVmZXJlbmNlKGZvbnRSZWYpIHtcclxuICAgIGlmICghZm9udFJlZiB8fCBmb250UmVmID09PSAnJykge1xyXG4gICAgICBjb25zb2xlLmxvZygnRW1wdHkgZm9udCByZWZlcmVuY2UsIHVzaW5nIGZhbGxiYWNrJyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRGb250KCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFRyeSBkaXJlY3QgbG9va3VwIGluIGZvbnQgbWFwXHJcbiAgICBpZiAodGhpcy5mb250TWFwICYmIHRoaXMuZm9udE1hcC5oYXMoZm9udFJlZikpIHtcclxuICAgICAgY29uc3QgcmVzb2x2ZWRGb250ID0gdGhpcy5mb250TWFwLmdldChmb250UmVmKTtcclxuICAgICAgY29uc29sZS5sb2coYEZvbnQgcmVzb2x2ZWQ6IFwiJHtmb250UmVmfVwiIC0+IFwiJHtyZXNvbHZlZEZvbnR9XCJgKTtcclxuICAgICAgcmV0dXJuIHJlc29sdmVkRm9udDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVHJ5IHBhcnRpYWwgbWF0Y2hpbmcgZm9yIGZvbnQgZmFtaWxpZXNcclxuICAgIGlmICh0aGlzLnJlc291cmNlcy5mb250cykge1xyXG4gICAgICBmb3IgKGNvbnN0IFtmYW1pbHlJZCwgZmFtaWx5SW5mb10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5yZXNvdXJjZXMuZm9udHMpKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgZmFtaWx5IG5hbWUgbWF0Y2hcclxuICAgICAgICBpZiAoZmFtaWx5SW5mby5uYW1lICYmIFxyXG4gICAgICAgICAgICAoZmFtaWx5SW5mby5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZm9udFJlZi50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgZm9udFJlZi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZhbWlseUluZm8ubmFtZS50b0xvd2VyQ2FzZSgpKSkpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb250IHBhcnRpYWxseSBtYXRjaGVkOiBcIiR7Zm9udFJlZn1cIiAtPiBcIiR7ZmFtaWx5SW5mby5uYW1lfVwiYCk7XHJcbiAgICAgICAgICByZXR1cm4gZmFtaWx5SW5mby5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpbmRpdmlkdWFsIGZvbnQgbWF0Y2hlc1xyXG4gICAgICAgIGlmIChmYW1pbHlJbmZvLmZvbnRzKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IGZvbnQgb2YgZmFtaWx5SW5mby5mb250cykge1xyXG4gICAgICAgICAgICBpZiAoZm9udC5zZWxmID09PSBmb250UmVmIHx8IFxyXG4gICAgICAgICAgICAgICAgZm9udC5wb3N0U2NyaXB0TmFtZSA9PT0gZm9udFJlZiB8fCBcclxuICAgICAgICAgICAgICAgIGZvbnQubmFtZSA9PT0gZm9udFJlZikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb250IGV4YWN0bHkgbWF0Y2hlZDogXCIke2ZvbnRSZWZ9XCIgLT4gXCIke2ZhbWlseUluZm8ubmFtZX1cImApO1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYW1pbHlJbmZvLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYEZvbnQgbm90IGZvdW5kOiBcIiR7Zm9udFJlZn1cIiwgdXNpbmcgZmFsbGJhY2tgKTtcclxuICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRGb250KCkgfHwgZm9udFJlZjtcclxuICB9XHJcblxyXG4gIGdldERlZmF1bHRGb250KCkge1xyXG4gICAgaWYgKHRoaXMucmVzb3VyY2VzLmZvbnRzICYmIE9iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGZpcnN0RmFtaWx5ID0gT2JqZWN0LnZhbHVlcyh0aGlzLnJlc291cmNlcy5mb250cylbMF07XHJcbiAgICAgIHJldHVybiBmaXJzdEZhbWlseS5uYW1lIHx8ICdBcmlhbCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ0FyaWFsJztcclxuICB9XHJcblxyXG4gIGluZmVyRm9udEZyb21Db250ZXh0KCkge1xyXG4gICAgLy8gSWYgd2UgaGF2ZSBmb250IGRlZmluaXRpb25zIGJ1dCBubyBleHBsaWNpdCByZWZlcmVuY2VzLCBcclxuICAgIC8vIHJldHVybiB0aGUgZmlyc3QgYXZhaWxhYmxlIGZvbnQgYXMgYSBmYWxsYmFja1xyXG4gICAgaWYgKHRoaXMucmVzb3VyY2VzLmZvbnRzICYmIE9iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGZpcnN0Rm9udEZhbWlseSA9IE9iamVjdC52YWx1ZXModGhpcy5yZXNvdXJjZXMuZm9udHMpWzBdO1xyXG4gICAgICByZXR1cm4gZmlyc3RGb250RmFtaWx5Lm5hbWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGdldFN0b3J5U3R5bGVTdW1tYXJ5KHN0b3J5KSB7XHJcbiAgICBjb25zdCBzdW1tYXJ5ID0ge1xyXG4gICAgICBmb250U2l6ZTogbnVsbCxcclxuICAgICAgZm9udEZhbWlseTogbnVsbCxcclxuICAgICAgYWxpZ25tZW50OiBudWxsLFxyXG4gICAgICBmaWxsQ29sb3I6IG51bGwsXHJcbiAgICAgIGZvbnRTdHlsZTogbnVsbCxcclxuICAgICAgbGVhZGluZzogbnVsbCxcclxuICAgICAgbGVhZGluZ1R5cGU6IG51bGwsXHJcbiAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IG51bGwsXHJcbiAgICAgIHRyYWNraW5nOiBudWxsLFxyXG4gICAgICBrZXJuaW5nOiBudWxsXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBHZXQgdGhlIG1vc3QgY29tbW9uIG9yIGZpcnN0IGZvcm1hdHRpbmcgdmFsdWVzXHJcbiAgICBpZiAoc3RvcnkuY29udGVudD8uZm9ybWF0dGVkQ29udGVudD8ubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaXJzdEZvcm1hdHRlZCA9IHN0b3J5LmNvbnRlbnQuZm9ybWF0dGVkQ29udGVudC5maW5kKGl0ZW0gPT4gXHJcbiAgICAgICAgaXRlbS5mb3JtYXR0aW5nICYmICFpdGVtLmZvcm1hdHRpbmcuaXNCcmVha1xyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgaWYgKGZpcnN0Rm9ybWF0dGVkPy5mb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc3QgZm10ID0gZmlyc3RGb3JtYXR0ZWQuZm9ybWF0dGluZztcclxuICAgICAgICBzdW1tYXJ5LmZvbnRTaXplID0gZm10LmZvbnRTaXplO1xyXG4gICAgICAgIHN1bW1hcnkuZm9udEZhbWlseSA9IGZtdC5mb250RmFtaWx5O1xyXG4gICAgICAgIHN1bW1hcnkuYWxpZ25tZW50ID0gZm10LmFsaWdubWVudDtcclxuICAgICAgICBzdW1tYXJ5LmZpbGxDb2xvciA9IGZtdC5maWxsQ29sb3I7XHJcbiAgICAgICAgc3VtbWFyeS5mb250U3R5bGUgPSBmbXQuZm9udFN0eWxlO1xyXG4gICAgICAgIHN1bW1hcnkubGVhZGluZyA9IGZtdC5sZWFkaW5nO1xyXG4gICAgICAgIHN1bW1hcnkubGVhZGluZ1R5cGUgPSBmbXQubGVhZGluZ1R5cGU7XHJcbiAgICAgICAgc3VtbWFyeS5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gZm10LmVmZmVjdGl2ZUxpbmVIZWlnaHQ7XHJcbiAgICAgICAgc3VtbWFyeS50cmFja2luZyA9IGZtdC50cmFja2luZztcclxuICAgICAgICBzdW1tYXJ5Lmtlcm5pbmcgPSBmbXQua2VybmluZztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gc3VtbWFyeTtcclxuICB9XHJcblxyXG4gIC8vIE5FVzogUHJvY2VzcyBsZWFkaW5nIHZhbHVlcyB3aXRoIEluRGVzaWduLXNwZWNpZmljIGxvZ2ljIChzaGFyZWQgd2l0aCBTdG9yeVBhcnNlcilcclxuICBwcm9jZXNzTGVhZGluZ1ZhbHVlKHJhd0xlYWRpbmcsIGZvbnRTaXplKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcpIHJldHVybiAnYXV0byc7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBcImF1dG9cIiBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZyA9PT0gJ2F1dG8nIHx8IHJhd0xlYWRpbmcgPT09ICdBdXRvJykge1xyXG4gICAgICByZXR1cm4gZm9udFNpemUgPyBmb250U2l6ZSAqIDEuMiA6ICdhdXRvJzsgLy8gSW5EZXNpZ24gZGVmYXVsdCBhdXRvIGxlYWRpbmcgaXMgMTIwJVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgbnVtZXJpYyBsZWFkaW5nIChpbiBwb2ludHMpXHJcbiAgICBjb25zdCBudW1lcmljTGVhZGluZyA9IHBhcnNlRmxvYXQocmF3TGVhZGluZyk7XHJcbiAgICBpZiAoIWlzTmFOKG51bWVyaWNMZWFkaW5nKSkge1xyXG4gICAgICByZXR1cm4gbnVtZXJpY0xlYWRpbmc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBwZXJjZW50YWdlLWJhc2VkIGxlYWRpbmdcclxuICAgIGlmIChyYXdMZWFkaW5nLmluY2x1ZGVzKCclJykpIHtcclxuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQocmF3TGVhZGluZy5yZXBsYWNlKCclJywgJycpKTtcclxuICAgICAgcmV0dXJuIGZvbnRTaXplID8gKGZvbnRTaXplICogcGVyY2VudGFnZSAvIDEwMCkgOiAnYXV0byc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAnYXV0byc7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IERldGVybWluZSB0aGUgdHlwZSBvZiBsZWFkaW5nIGJlaW5nIHVzZWRcclxuICBkZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcgfHwgcmF3TGVhZGluZyA9PT0gJ2F1dG8nIHx8IHJhd0xlYWRpbmcgPT09ICdBdXRvJykge1xyXG4gICAgICByZXR1cm4gJ2F1dG8nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcygnJScpKSB7XHJcbiAgICAgIHJldHVybiAncGVyY2VudGFnZSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdChyYXdMZWFkaW5nKSkpIHtcclxuICAgICAgcmV0dXJuICdhYnNvbHV0ZSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAndW5rbm93bic7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IENhbGN1bGF0ZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgZm9yIENTUyByZW5kZXJpbmdcclxuICBjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KGxlYWRpbmcsIGZvbnRTaXplKSB7XHJcbiAgICBpZiAobGVhZGluZyA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgIHJldHVybiAxLjI7IC8vIENTUyBsaW5lLWhlaWdodCByYXRpbyBmb3IgYXV0b1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodHlwZW9mIGxlYWRpbmcgPT09ICdudW1iZXInICYmIGZvbnRTaXplKSB7XHJcbiAgICAgIC8vIENvbnZlcnQgcG9pbnRzIHRvIENTUyBsaW5lLWhlaWdodCByYXRpb1xyXG4gICAgICByZXR1cm4gTWF0aC5tYXgoMC44LCBsZWFkaW5nIC8gZm9udFNpemUpOyAvLyBFbnN1cmUgbWluaW11bSBsaW5lIGhlaWdodFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gMS4yOyAvLyBGYWxsYmFja1xyXG4gIH1cclxuXHJcbiAgZ2V0U3R5bGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmVzb3VyY2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzO1xyXG4gIH1cclxuXHJcbiAgZ2V0Rm9udE1hcCgpIHtcclxuICAgIHJldHVybiB0aGlzLmZvbnRNYXA7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlUGFyc2VyOyAiXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJJRE1MVXRpbHMiLCJTdHlsZVBhcnNlciIsInBhcnNlUmVzb3VyY2VGaWxlIiwiZmlsZU5hbWUiLCJjb250ZW50IiwieG1sUGFyc2VyIiwiY29uc29sZSIsImxvZyIsInBhcnNlZCIsInBhcnNlIiwicmVzb3VyY2VOYW1lIiwiYmFzZW5hbWUiLCJpbmNsdWRlcyIsImV4dHJhY3RTdHlsZXMiLCJleHRyYWN0Rm9udHMiLCJleHRyYWN0R3JhcGhpY3MiLCJleHRyYWN0UHJlZmVyZW5jZXMiLCJlcnJvciIsIm1lc3NhZ2UiLCJzdHlsZXNEYXRhIiwic3R5bGVzIiwiU3R5bGVzIiwiUm9vdFBhcmFncmFwaFN0eWxlR3JvdXAiLCJleHRyYWN0UGFyYWdyYXBoU3R5bGVzIiwiUm9vdENoYXJhY3RlclN0eWxlR3JvdXAiLCJleHRyYWN0Q2hhcmFjdGVyU3R5bGVzIiwic3R5bGVHcm91cCIsImV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSIsImdyb3VwIiwiUGFyYWdyYXBoU3R5bGUiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwic3R5bGUiLCJmb250UmVmIiwiZXh0cmFjdEZvbnRGcm9tU3R5bGUiLCJmb250U2l6ZSIsInBhcnNlRmxvYXQiLCJyYXdMZWFkaW5nIiwicHJvY2Vzc2VkTGVhZGluZyIsInByb2Nlc3NMZWFkaW5nVmFsdWUiLCJwYXJhZ3JhcGgiLCJzZWxmIiwibmFtZSIsImZvbnRTdHlsZSIsInBvaW50U2l6ZSIsImxlYWRpbmciLCJsZWFkaW5nVHlwZSIsImRldGVybWluZUxlYWRpbmdUeXBlIiwiZWZmZWN0aXZlTGluZUhlaWdodCIsImNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJhbGlnbm1lbnQiLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJmaXJzdExpbmVJbmRlbnQiLCJzcGFjZUJlZm9yZSIsInNwYWNlQWZ0ZXIiLCJ0cmFja2luZyIsImtlcm5pbmciLCJob3Jpem9udGFsU2NhbGUiLCJ2ZXJ0aWNhbFNjYWxlIiwiYXBwbGllZEZvbnQiLCJvcmlnaW5hbEZvbnRSZWYiLCJmaWxsQ29sb3IiLCJyYXdTdHlsZSIsIlBhcmFncmFwaFN0eWxlR3JvdXAiLCJzdWJHcm91cHMiLCJQcm9wZXJ0aWVzIiwiQXBwbGllZEZvbnQiLCJGb250RmFtaWx5IiwiQ2hhcmFjdGVyU3R5bGUiLCJjaGFyYWN0ZXIiLCJzdHJva2VDb2xvciIsIkNoYXJhY3RlclN0eWxlR3JvdXAiLCJmb250c0RhdGEiLCJmb250cyIsIkZvbnRzIiwicmVzb3VyY2VzIiwiZm9udE1hcCIsIk1hcCIsImZvbnRGYW1pbGllcyIsImZhbWlseSIsImZhbWlseUluZm8iLCJGb250IiwiZm9udExpc3QiLCJmb250IiwiZm9udEluZm8iLCJmb250RmFtaWx5IiwicG9zdFNjcmlwdE5hbWUiLCJzdGF0dXMiLCJmb250U3R5bGVOYW1lIiwicHVzaCIsInNldCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzaXplIiwiZ3JhcGhpY3NEYXRhIiwiZ3JhcGhpY3MiLCJHcmFwaGljIiwiY29sb3JzIiwiZ3JhZGllbnRzIiwiQ29sb3IiLCJjb2xvciIsIm1vZGVsIiwic3BhY2UiLCJjeWFuIiwibWFnZW50YSIsInllbGxvdyIsImJsYWNrIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwiR3JhZGllbnQiLCJncmFkaWVudCIsInR5cGUiLCJncmFkaWVudFN0b3BzIiwiZXh0cmFjdEdyYWRpZW50U3RvcHMiLCJzdG9wcyIsIkdyYWRpZW50U3RvcCIsInN0b3BMaXN0Iiwic3RvcCIsInN0b3BDb2xvciIsImxvY2F0aW9uIiwibWlkcG9pbnQiLCJwcmVmZXJlbmNlc0RhdGEiLCJwcmVmcyIsIlByZWZlcmVuY2VzIiwiZG9jdW1lbnRJbmZvIiwicHJlZmVyZW5jZXMiLCJkb2N1bWVudFByZWZlcmVuY2VzIiwiZXh0cmFjdERvY3VtZW50UHJlZnMiLCJEb2N1bWVudFByZWZlcmVuY2UiLCJ2aWV3UHJlZmVyZW5jZXMiLCJleHRyYWN0Vmlld1ByZWZzIiwiVmlld1ByZWZlcmVuY2UiLCJndWlkZVByZWZlcmVuY2VzIiwiZXh0cmFjdEd1aWRlUHJlZnMiLCJHdWlkZVByZWZlcmVuY2UiLCJncmlkUHJlZmVyZW5jZXMiLCJleHRyYWN0R3JpZFByZWZzIiwiR3JpZFByZWZlcmVuY2UiLCJtYXJnaW5QcmVmZXJlbmNlcyIsImV4dHJhY3RNYXJnaW5QcmVmcyIsIk1hcmdpblByZWZlcmVuY2UiLCJjb2x1bW5QcmVmZXJlbmNlcyIsImV4dHJhY3RDb2x1bW5QcmVmcyIsIkNvbHVtblByZWZlcmVuY2UiLCJkb2NQcmVmIiwicGFnZVdpZHRoIiwicGFnZUhlaWdodCIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbHVtbkNvdW50IiwicGFyc2VJbnQiLCJjb2x1bW5HdXR0ZXIiLCJmYWNpbmdQYWdlcyIsImFsbG93UGFnZVNodWZmbGUiLCJzbHVnQmxlZWRUeXBlIiwiZG9jdW1lbnRCbGVlZFRvcE9mZnNldCIsImRvY3VtZW50QmxlZWRCb3R0b21PZmZzZXQiLCJkb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0IiwiZG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0Iiwidmlld1ByZWYiLCJob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cyIsInZlcnRpY2FsTWVhc3VyZW1lbnRVbml0cyIsInJ1bGVyT3JpZ2luIiwic2hvd1J1bGVycyIsImd1aWRlUHJlZiIsInJ1bGVyR3VpZGVDb2xvciIsImd1aWRlc0luQmFjayIsImd1aWRlc0xvY2tlZCIsImd1aWRlc1Nob3duIiwiZ3VpZGVzU25hcHRvIiwiZ3JpZFByZWYiLCJiYXNlbGluZVN0YXJ0IiwiYmFzZWxpbmVEaXZpc2lvbiIsImJhc2VsaW5lU2hvd24iLCJiYXNlbGluZVNuYXB0byIsImRvY3VtZW50R3JpZFNob3duIiwiZG9jdW1lbnRHcmlkU25hcHRvIiwibWFyZ2luUHJlZiIsImNvbHVtblByZWYiLCJ0ZXh0Q29sdW1uQ291bnQiLCJ0ZXh0Q29sdW1uR3V0dGVyIiwicmVzb2x2ZVN0eWxlRm9ybWF0dGluZyIsImZvcm1hdHRpbmciLCJyZXNvbHZlZCIsImhhc0FueUZvcm1hdHRpbmciLCJwYXJhZ3JhcGhTdHlsZSIsImNoYXJhY3RlclN0eWxlIiwiZm9udFJlZmVyZW5jZSIsImRpcmVjdEZvbnRTdHlsZSIsImRpcmVjdEZvbnRSZWYiLCJkaXJlY3RGb250U2l6ZSIsInBTdHlsZSIsInJlc29sdmVGb250UmVmZXJlbmNlIiwiY1N0eWxlIiwidW5kZWZpbmVkIiwiZ2V0RGVmYXVsdEZvbnQiLCJoYXMiLCJyZXNvbHZlZEZvbnQiLCJnZXQiLCJmYW1pbHlJZCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsImZpcnN0RmFtaWx5IiwidmFsdWVzIiwiaW5mZXJGb250RnJvbUNvbnRleHQiLCJmaXJzdEZvbnRGYW1pbHkiLCJnZXRTdG9yeVN0eWxlU3VtbWFyeSIsInN0b3J5Iiwic3VtbWFyeSIsImZvcm1hdHRlZENvbnRlbnQiLCJmaXJzdEZvcm1hdHRlZCIsImZpbmQiLCJpdGVtIiwiaXNCcmVhayIsImZtdCIsIm51bWVyaWNMZWFkaW5nIiwiaXNOYU4iLCJwZXJjZW50YWdlIiwicmVwbGFjZSIsIk1hdGgiLCJtYXgiLCJnZXRTdHlsZXMiLCJnZXRSZXNvdXJjZXMiLCJnZXRGb250TWFwIiwiY29uc3RydWN0b3IiLCJvYmplY3QiLCJ0YWJsZSIsImNlbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/parsers/StyleParser.js\n"));

/***/ })

});