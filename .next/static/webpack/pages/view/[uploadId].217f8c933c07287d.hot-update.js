"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/ColorUtils.js":
/*!*********************************!*\
  !*** ./lib/utils/ColorUtils.js ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * ColorUtils.js - Comprehensive color conversion and manipulation utilities\r\n * Handles CMYK, RGB, HEX, and other color format conversions for IDML processing\r\n */ \nclass ColorUtils {\n    /**\r\n   * Convert CMYK color values to RGB\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {object} RGB object with r, g, b values (0-255)\r\n   */ static cmykToRgb(c, m, y, k) {\n        // Normalize CMYK values to 0-1 range\n        const cNorm = c / 100;\n        const mNorm = m / 100;\n        const yNorm = y / 100;\n        const kNorm = k / 100;\n        // Convert to RGB using standard formula\n        const r = Math.round(255 * (1 - cNorm) * (1 - kNorm));\n        const g = Math.round(255 * (1 - mNorm) * (1 - kNorm));\n        const b = Math.round(255 * (1 - yNorm) * (1 - kNorm));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    /**\r\n   * Convert CMYK to RGB CSS string\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {string} CSS rgb() string\r\n   */ static cmykToRgbString(c, m, y, k) {\n        const { r, g, b } = this.cmykToRgb(c, m, y, k);\n        return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n    }\n    /**\r\n   * Convert RGB to HEX\r\n   * @param {number} r - Red (0-255)\r\n   * @param {number} g - Green (0-255)\r\n   * @param {number} b - Blue (0-255)\r\n   * @returns {string} HEX color string\r\n   */ static rgbToHex(r, g, b) {\n        const toHex = (component)=>{\n            const hex = component.toString(16);\n            return hex.length === 1 ? \"0\" + hex : hex;\n        };\n        return \"#\".concat(toHex(r)).concat(toHex(g)).concat(toHex(b));\n    }\n    /**\r\n   * Convert CMYK to HEX\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {string} HEX color string\r\n   */ static cmykToHex(c, m, y, k) {\n        const { r, g, b } = this.cmykToRgb(c, m, y, k);\n        return this.rgbToHex(r, g, b);\n    }\n    /**\r\n   * Parse CMYK values from IDML color reference string\r\n   * @param {string} colorRef - IDML color reference (e.g., \"Color/C=1 M=18 Y=16 K=0\")\r\n   * @returns {object|null} Object with c, m, y, k values or null if not parseable\r\n   */ static parseCmykFromColorRef(colorRef) {\n        if (!colorRef || typeof colorRef !== \"string\") {\n            return null;\n        }\n        // Match CMYK pattern in IDML color references\n        const cmykMatch = colorRef.match(/Color\\/C=([\\d.]+)\\s*M=([\\d.]+)\\s*Y=([\\d.]+)\\s*K=([\\d.]+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map((val)=>parseFloat(val));\n            return {\n                c,\n                m,\n                y,\n                k\n            };\n        }\n        return null;\n    }\n    /**\r\n   * Convert IDML color reference to RGB CSS string\r\n   * @param {string} colorRef - IDML color reference\r\n   * @returns {string} CSS color string (rgb, hex, or named color)\r\n   */ static convertIdmlColorToRgb(colorRefOrObj) {\n        if (!colorRefOrObj || colorRefOrObj === \"Color/None\") {\n            return \"transparent\";\n        }\n        // PATCH: If colorRefOrObj is an object with red/green/blue, use those directly\n        if (typeof colorRefOrObj === \"object\" && colorRefOrObj.red !== undefined && colorRefOrObj.green !== undefined && colorRefOrObj.blue !== undefined) {\n            return \"rgb(\".concat(colorRefOrObj.red, \", \").concat(colorRefOrObj.green, \", \").concat(colorRefOrObj.blue, \")\");\n        }\n        // Try to parse CMYK first\n        const cmyk = this.parseCmykFromColorRef(colorRefOrObj);\n        if (cmyk) {\n            console.log(\"\\uD83C\\uDFA8 Converting CMYK color: C=\".concat(cmyk.c, \" M=\").concat(cmyk.m, \" Y=\").concat(cmyk.y, \" K=\").concat(cmyk.k));\n            const rgbString = this.cmykToRgbString(cmyk.c, cmyk.m, cmyk.y, cmyk.k);\n            console.log(\"\\uD83C\\uDFA8 CMYK to RGB result: \".concat(rgbString));\n            return rgbString;\n        }\n        // Fallback to predefined named colors\n        const namedColors = {\n            \"Color/Black\": \"rgb(0, 0, 0)\",\n            \"Color/White\": \"rgb(255, 255, 255)\",\n            \"Color/Red\": \"rgb(255, 0, 0)\",\n            \"Color/Green\": \"rgb(0, 255, 0)\",\n            \"Color/Blue\": \"rgb(0, 0, 255)\",\n            \"Color/Cyan\": \"rgb(0, 255, 255)\",\n            \"Color/Magenta\": \"rgb(255, 0, 255)\",\n            \"Color/Yellow\": \"rgb(255, 255, 0)\",\n            \"Color/Paper\": \"rgb(255, 255, 255)\"\n        };\n        return namedColors[colorRefOrObj] || \"rgb(200, 200, 200)\";\n    }\n    /**\r\n   * Determine if a CMYK color is suitable for use as a background\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {object} Analysis result with isLightBackground boolean and reasoning\r\n   */ static analyzeCmykForBackground(c, m, y, k) {\n        const maxCMY = Math.max(c, m, y);\n        const avgCMY = (c + m + y) / 3;\n        const analysis = {\n            c,\n            m,\n            y,\n            k,\n            maxCMY,\n            avgCMY,\n            isLightBackground: false,\n            category: \"unknown\",\n            reasoning: \"\"\n        };\n        // Very light colors: low K and low CMY values\n        if (k <= 20 && maxCMY <= 30 && avgCMY <= 20) {\n            analysis.isLightBackground = true;\n            analysis.category = \"very_light\";\n            analysis.reasoning = \"Very light color suitable for background\";\n            return analysis;\n        }\n        // Light tinted colors: very low K, slightly higher CMY (like light pink, light blue, etc.)\n        if (k <= 10 && maxCMY <= 50 && avgCMY <= 25) {\n            analysis.isLightBackground = true;\n            analysis.category = \"light_tinted\";\n            analysis.reasoning = \"Light tinted color suitable for background\";\n            return analysis;\n        }\n        // Light gray: balanced CMY, moderate K\n        if (k >= 5 && k <= 60 && maxCMY <= 15 && Math.abs(c - m) <= 5 && Math.abs(m - y) <= 5) {\n            analysis.isLightBackground = true;\n            analysis.category = \"light_gray\";\n            analysis.reasoning = \"Light gray color suitable for background\";\n            return analysis;\n        }\n        // Not suitable for background\n        analysis.reasoning = \"Too dark or saturated for background use\";\n        return analysis;\n    }\n    /**\r\n   * Analyze IDML color reference for background suitability\r\n   * @param {string} colorRef - IDML color reference\r\n   * @returns {object|null} Analysis result or null if not CMYK\r\n   */ static analyzeIdmlColorForBackground(colorRef) {\n        // Handle Paper color specially\n        if (colorRef === \"Color/Paper\" || colorRef.includes(\"Paper\")) {\n            return {\n                isLightBackground: true,\n                category: \"paper\",\n                reasoning: \"InDesign Paper color - ideal for background\",\n                colorRef\n            };\n        }\n        const cmyk = this.parseCmykFromColorRef(colorRef);\n        if (!cmyk) {\n            return null;\n        }\n        const analysis = this.analyzeCmykForBackground(cmyk.c, cmyk.m, cmyk.y, cmyk.k);\n        analysis.colorRef = colorRef;\n        return analysis;\n    }\n    /**\r\n   * Get RGB brightness value (0-255, higher = brighter)\r\n   * @param {number} r - Red (0-255)\r\n   * @param {number} g - Green (0-255)\r\n   * @param {number} b - Blue (0-255)\r\n   * @returns {number} Brightness value\r\n   */ static getRgbBrightness(r, g, b) {\n        // Use relative luminance formula\n        return 0.299 * r + 0.587 * g + 0.114 * b;\n    }\n    /**\r\n   * Get brightness from CMYK values\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {number} Brightness value (0-255)\r\n   */ static getCmykBrightness(c, m, y, k) {\n        const { r, g, b } = this.cmykToRgb(c, m, y, k);\n        return this.getRgbBrightness(r, g, b);\n    }\n    /**\r\n   * Sort colors by lightness (lightest first)\r\n   * @param {Array} colorRefs - Array of IDML color references\r\n   * @returns {Array} Sorted array with lightest colors first\r\n   */ static sortColorsByLightness(colorRefs) {\n        return colorRefs.sort((a, b)=>{\n            // Analyze both colors for background suitability\n            const analysisA = this.analyzeIdmlColorForBackground(a);\n            const analysisB = this.analyzeIdmlColorForBackground(b);\n            // Prioritize actual CMYK colors over Paper color for visual interest\n            const aIsPaper = a.includes(\"Paper\");\n            const bIsPaper = b.includes(\"Paper\");\n            const aIsCmyk = !aIsPaper && analysisA && analysisA.c !== undefined;\n            const bIsCmyk = !bIsPaper && analysisB && analysisB.c !== undefined;\n            // If one is CMYK and other is Paper, prefer CMYK for visual interest\n            if (aIsCmyk && bIsPaper) return -1;\n            if (bIsCmyk && aIsPaper) return 1;\n            // If both are CMYK, sort by lightness (lower K value = lighter)\n            if (aIsCmyk && bIsCmyk) {\n                const cmykA = this.parseCmykFromColorRef(a);\n                const cmykB = this.parseCmykFromColorRef(b);\n                if (cmykA && cmykB) {\n                    // First compare by category priority (very_light > light_gray, etc.)\n                    const categoryPriority = {\n                        very_light: 1,\n                        light_gray: 2,\n                        paper: 3,\n                        unknown: 4\n                    };\n                    const priorityA = categoryPriority[analysisA.category] || 4;\n                    const priorityB = categoryPriority[analysisB.category] || 4;\n                    if (priorityA !== priorityB) {\n                        return priorityA - priorityB;\n                    }\n                    // If same category, sort by K value (lower K = lighter)\n                    return cmykA.k - cmykB.k;\n                }\n            }\n            // If both are Paper or both are unknown, maintain original order\n            return 0;\n        });\n    }\n}\n// Restore CommonJS exports\nmodule.exports = ColorUtils;\nmodule.exports.cmykToRgb = ColorUtils.cmykToRgb;\nmodule.exports.cmykToRgbString = ColorUtils.cmykToRgbString;\nmodule.exports.cmykToHex = ColorUtils.cmykToHex;\nmodule.exports.rgbToHex = ColorUtils.rgbToHex;\nmodule.exports.parseCmykFromColorRef = ColorUtils.parseCmykFromColorRef;\nmodule.exports.convertIdmlColorToRgb = ColorUtils.convertIdmlColorToRgb;\nmodule.exports.analyzeCmykForBackground = ColorUtils.analyzeCmykForBackground;\nmodule.exports.analyzeIdmlColorForBackground = ColorUtils.analyzeIdmlColorForBackground;\nmodule.exports.getRgbBrightness = ColorUtils.getRgbBrightness;\nmodule.exports.getCmykBrightness = ColorUtils.getCmykBrightness;\nmodule.exports.sortColorsByLightness = ColorUtils.sortColorsByLightness;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bHMuanM/NTU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29sb3JVdGlscy5qcyAtIENvbXByZWhlbnNpdmUgY29sb3IgY29udmVyc2lvbiBhbmQgbWFuaXB1bGF0aW9uIHV0aWxpdGllc1xyXG4gKiBIYW5kbGVzIENNWUssIFJHQiwgSEVYLCBhbmQgb3RoZXIgY29sb3IgZm9ybWF0IGNvbnZlcnNpb25zIGZvciBJRE1MIHByb2Nlc3NpbmdcclxuICovXHJcblxyXG5jbGFzcyBDb2xvclV0aWxzIHtcclxuICAvKipcclxuICAgKiBDb252ZXJ0IENNWUsgY29sb3IgdmFsdWVzIHRvIFJHQlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gQ3lhbiAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFllbGxvdyAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgLSBCbGFjay9LZXkgKDAtMTAwKVxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFJHQiBvYmplY3Qgd2l0aCByLCBnLCBiIHZhbHVlcyAoMC0yNTUpXHJcbiAgICovXHJcbiAgc3RhdGljIGNteWtUb1JnYihjLCBtLCB5LCBrKSB7XHJcbiAgICAvLyBOb3JtYWxpemUgQ01ZSyB2YWx1ZXMgdG8gMC0xIHJhbmdlXHJcbiAgICBjb25zdCBjTm9ybSA9IGMgLyAxMDA7XHJcbiAgICBjb25zdCBtTm9ybSA9IG0gLyAxMDA7XHJcbiAgICBjb25zdCB5Tm9ybSA9IHkgLyAxMDA7XHJcbiAgICBjb25zdCBrTm9ybSA9IGsgLyAxMDA7XHJcblxyXG4gICAgLy8gQ29udmVydCB0byBSR0IgdXNpbmcgc3RhbmRhcmQgZm9ybXVsYVxyXG4gICAgY29uc3QgciA9IE1hdGgucm91bmQoMjU1ICogKDEgLSBjTm9ybSkgKiAoMSAtIGtOb3JtKSk7XHJcbiAgICBjb25zdCBnID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIG1Ob3JtKSAqICgxIC0ga05vcm0pKTtcclxuICAgIGNvbnN0IGIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0geU5vcm0pICogKDEgLSBrTm9ybSkpO1xyXG5cclxuICAgIHJldHVybiB7IHIsIGcsIGIgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgQ01ZSyB0byBSR0IgQ1NTIHN0cmluZ1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gQ3lhbiAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFllbGxvdyAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgLSBCbGFjay9LZXkgKDAtMTAwKVxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IENTUyByZ2IoKSBzdHJpbmdcclxuICAgKi9cclxuICBzdGF0aWMgY215a1RvUmdiU3RyaW5nKGMsIG0sIHksIGspIHtcclxuICAgIGNvbnN0IHsgciwgZywgYiB9ID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XHJcbiAgICByZXR1cm4gYHJnYigke3J9LCAke2d9LCAke2J9KWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IFJHQiB0byBIRVhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFJlZCAoMC0yNTUpXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGcgLSBHcmVlbiAoMC0yNTUpXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBCbHVlICgwLTI1NSlcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBIRVggY29sb3Igc3RyaW5nXHJcbiAgICovXHJcbiAgc3RhdGljIHJnYlRvSGV4KHIsIGcsIGIpIHtcclxuICAgIGNvbnN0IHRvSGV4ID0gKGNvbXBvbmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBoZXggPSBjb21wb25lbnQudG9TdHJpbmcoMTYpO1xyXG4gICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgaGV4IDogaGV4O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBgIyR7dG9IZXgocil9JHt0b0hleChnKX0ke3RvSGV4KGIpfWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IENNWUsgdG8gSEVYXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBDeWFuICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbSAtIE1hZ2VudGEgKDAtMTAwKVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWWVsbG93ICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayAtIEJsYWNrL0tleSAoMC0xMDApXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gSEVYIGNvbG9yIHN0cmluZ1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjbXlrVG9IZXgoYywgbSwgeSwgaykge1xyXG4gICAgY29uc3QgeyByLCBnLCBiIH0gPSB0aGlzLmNteWtUb1JnYihjLCBtLCB5LCBrKTtcclxuICAgIHJldHVybiB0aGlzLnJnYlRvSGV4KHIsIGcsIGIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2UgQ01ZSyB2YWx1ZXMgZnJvbSBJRE1MIGNvbG9yIHJlZmVyZW5jZSBzdHJpbmdcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JSZWYgLSBJRE1MIGNvbG9yIHJlZmVyZW5jZSAoZS5nLiwgXCJDb2xvci9DPTEgTT0xOCBZPTE2IEs9MFwiKVxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH0gT2JqZWN0IHdpdGggYywgbSwgeSwgayB2YWx1ZXMgb3IgbnVsbCBpZiBub3QgcGFyc2VhYmxlXHJcbiAgICovXHJcbiAgc3RhdGljIHBhcnNlQ215a0Zyb21Db2xvclJlZihjb2xvclJlZikge1xyXG4gICAgaWYgKCFjb2xvclJlZiB8fCB0eXBlb2YgY29sb3JSZWYgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWF0Y2ggQ01ZSyBwYXR0ZXJuIGluIElETUwgY29sb3IgcmVmZXJlbmNlc1xyXG4gICAgY29uc3QgY215a01hdGNoID0gY29sb3JSZWYubWF0Y2goXHJcbiAgICAgIC9Db2xvclxcL0M9KFtcXGQuXSspXFxzKk09KFtcXGQuXSspXFxzKlk9KFtcXGQuXSspXFxzKks9KFtcXGQuXSspL1xyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoY215a01hdGNoKSB7XHJcbiAgICAgIGNvbnN0IFssIGMsIG0sIHksIGtdID0gY215a01hdGNoLm1hcCgodmFsKSA9PiBwYXJzZUZsb2F0KHZhbCkpO1xyXG4gICAgICByZXR1cm4geyBjLCBtLCB5LCBrIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IElETUwgY29sb3IgcmVmZXJlbmNlIHRvIFJHQiBDU1Mgc3RyaW5nXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yUmVmIC0gSURNTCBjb2xvciByZWZlcmVuY2VcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDU1MgY29sb3Igc3RyaW5nIChyZ2IsIGhleCwgb3IgbmFtZWQgY29sb3IpXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbnZlcnRJZG1sQ29sb3JUb1JnYihjb2xvclJlZk9yT2JqKSB7XHJcbiAgICBpZiAoIWNvbG9yUmVmT3JPYmogfHwgY29sb3JSZWZPck9iaiA9PT0gXCJDb2xvci9Ob25lXCIpIHtcclxuICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQQVRDSDogSWYgY29sb3JSZWZPck9iaiBpcyBhbiBvYmplY3Qgd2l0aCByZWQvZ3JlZW4vYmx1ZSwgdXNlIHRob3NlIGRpcmVjdGx5XHJcbiAgICBpZiAoXHJcbiAgICAgIHR5cGVvZiBjb2xvclJlZk9yT2JqID09PSBcIm9iamVjdFwiICYmXHJcbiAgICAgIGNvbG9yUmVmT3JPYmoucmVkICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgY29sb3JSZWZPck9iai5ncmVlbiAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgIGNvbG9yUmVmT3JPYmouYmx1ZSAhPT0gdW5kZWZpbmVkXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIGByZ2IoJHtjb2xvclJlZk9yT2JqLnJlZH0sICR7Y29sb3JSZWZPck9iai5ncmVlbn0sICR7Y29sb3JSZWZPck9iai5ibHVlfSlgO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB0byBwYXJzZSBDTVlLIGZpcnN0XHJcbiAgICBjb25zdCBjbXlrID0gdGhpcy5wYXJzZUNteWtGcm9tQ29sb3JSZWYoY29sb3JSZWZPck9iaik7XHJcbiAgICBpZiAoY215aykge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg8J+OqCBDb252ZXJ0aW5nIENNWUsgY29sb3I6IEM9JHtjbXlrLmN9IE09JHtjbXlrLm19IFk9JHtjbXlrLnl9IEs9JHtjbXlrLmt9YFxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCByZ2JTdHJpbmcgPSB0aGlzLmNteWtUb1JnYlN0cmluZyhjbXlrLmMsIGNteWsubSwgY215ay55LCBjbXlrLmspO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+OqCBDTVlLIHRvIFJHQiByZXN1bHQ6ICR7cmdiU3RyaW5nfWApO1xyXG4gICAgICByZXR1cm4gcmdiU3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZhbGxiYWNrIHRvIHByZWRlZmluZWQgbmFtZWQgY29sb3JzXHJcbiAgICBjb25zdCBuYW1lZENvbG9ycyA9IHtcclxuICAgICAgXCJDb2xvci9CbGFja1wiOiBcInJnYigwLCAwLCAwKVwiLFxyXG4gICAgICBcIkNvbG9yL1doaXRlXCI6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvUmVkXCI6IFwicmdiKDI1NSwgMCwgMClcIixcclxuICAgICAgXCJDb2xvci9HcmVlblwiOiBcInJnYigwLCAyNTUsIDApXCIsXHJcbiAgICAgIFwiQ29sb3IvQmx1ZVwiOiBcInJnYigwLCAwLCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvQ3lhblwiOiBcInJnYigwLCAyNTUsIDI1NSlcIixcclxuICAgICAgXCJDb2xvci9NYWdlbnRhXCI6IFwicmdiKDI1NSwgMCwgMjU1KVwiLFxyXG4gICAgICBcIkNvbG9yL1llbGxvd1wiOiBcInJnYigyNTUsIDI1NSwgMClcIixcclxuICAgICAgXCJDb2xvci9QYXBlclwiOiBcInJnYigyNTUsIDI1NSwgMjU1KVwiLCAvLyBJbkRlc2lnbidzIHBhcGVyIGNvbG9yXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuYW1lZENvbG9yc1tjb2xvclJlZk9yT2JqXSB8fCBcInJnYigyMDAsIDIwMCwgMjAwKVwiO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGlmIGEgQ01ZSyBjb2xvciBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIGEgYmFja2dyb3VuZFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gQ3lhbiAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFllbGxvdyAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgLSBCbGFjay9LZXkgKDAtMTAwKVxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IEFuYWx5c2lzIHJlc3VsdCB3aXRoIGlzTGlnaHRCYWNrZ3JvdW5kIGJvb2xlYW4gYW5kIHJlYXNvbmluZ1xyXG4gICAqL1xyXG4gIHN0YXRpYyBhbmFseXplQ215a0ZvckJhY2tncm91bmQoYywgbSwgeSwgaykge1xyXG4gICAgY29uc3QgbWF4Q01ZID0gTWF0aC5tYXgoYywgbSwgeSk7XHJcbiAgICBjb25zdCBhdmdDTVkgPSAoYyArIG0gKyB5KSAvIDM7XHJcblxyXG4gICAgY29uc3QgYW5hbHlzaXMgPSB7XHJcbiAgICAgIGMsXHJcbiAgICAgIG0sXHJcbiAgICAgIHksXHJcbiAgICAgIGssXHJcbiAgICAgIG1heENNWSxcclxuICAgICAgYXZnQ01ZLFxyXG4gICAgICBpc0xpZ2h0QmFja2dyb3VuZDogZmFsc2UsXHJcbiAgICAgIGNhdGVnb3J5OiBcInVua25vd25cIixcclxuICAgICAgcmVhc29uaW5nOiBcIlwiLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBWZXJ5IGxpZ2h0IGNvbG9yczogbG93IEsgYW5kIGxvdyBDTVkgdmFsdWVzXHJcbiAgICBpZiAoayA8PSAyMCAmJiBtYXhDTVkgPD0gMzAgJiYgYXZnQ01ZIDw9IDIwKSB7XHJcbiAgICAgIGFuYWx5c2lzLmlzTGlnaHRCYWNrZ3JvdW5kID0gdHJ1ZTtcclxuICAgICAgYW5hbHlzaXMuY2F0ZWdvcnkgPSBcInZlcnlfbGlnaHRcIjtcclxuICAgICAgYW5hbHlzaXMucmVhc29uaW5nID0gXCJWZXJ5IGxpZ2h0IGNvbG9yIHN1aXRhYmxlIGZvciBiYWNrZ3JvdW5kXCI7XHJcbiAgICAgIHJldHVybiBhbmFseXNpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBMaWdodCB0aW50ZWQgY29sb3JzOiB2ZXJ5IGxvdyBLLCBzbGlnaHRseSBoaWdoZXIgQ01ZIChsaWtlIGxpZ2h0IHBpbmssIGxpZ2h0IGJsdWUsIGV0Yy4pXHJcbiAgICBpZiAoayA8PSAxMCAmJiBtYXhDTVkgPD0gNTAgJiYgYXZnQ01ZIDw9IDI1KSB7XHJcbiAgICAgIGFuYWx5c2lzLmlzTGlnaHRCYWNrZ3JvdW5kID0gdHJ1ZTtcclxuICAgICAgYW5hbHlzaXMuY2F0ZWdvcnkgPSBcImxpZ2h0X3RpbnRlZFwiO1xyXG4gICAgICBhbmFseXNpcy5yZWFzb25pbmcgPSBcIkxpZ2h0IHRpbnRlZCBjb2xvciBzdWl0YWJsZSBmb3IgYmFja2dyb3VuZFwiO1xyXG4gICAgICByZXR1cm4gYW5hbHlzaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlnaHQgZ3JheTogYmFsYW5jZWQgQ01ZLCBtb2RlcmF0ZSBLXHJcbiAgICBpZiAoXHJcbiAgICAgIGsgPj0gNSAmJlxyXG4gICAgICBrIDw9IDYwICYmXHJcbiAgICAgIG1heENNWSA8PSAxNSAmJlxyXG4gICAgICBNYXRoLmFicyhjIC0gbSkgPD0gNSAmJlxyXG4gICAgICBNYXRoLmFicyhtIC0geSkgPD0gNVxyXG4gICAgKSB7XHJcbiAgICAgIGFuYWx5c2lzLmlzTGlnaHRCYWNrZ3JvdW5kID0gdHJ1ZTtcclxuICAgICAgYW5hbHlzaXMuY2F0ZWdvcnkgPSBcImxpZ2h0X2dyYXlcIjtcclxuICAgICAgYW5hbHlzaXMucmVhc29uaW5nID0gXCJMaWdodCBncmF5IGNvbG9yIHN1aXRhYmxlIGZvciBiYWNrZ3JvdW5kXCI7XHJcbiAgICAgIHJldHVybiBhbmFseXNpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3Qgc3VpdGFibGUgZm9yIGJhY2tncm91bmRcclxuICAgIGFuYWx5c2lzLnJlYXNvbmluZyA9IFwiVG9vIGRhcmsgb3Igc2F0dXJhdGVkIGZvciBiYWNrZ3JvdW5kIHVzZVwiO1xyXG4gICAgcmV0dXJuIGFuYWx5c2lzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5hbHl6ZSBJRE1MIGNvbG9yIHJlZmVyZW5jZSBmb3IgYmFja2dyb3VuZCBzdWl0YWJpbGl0eVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclJlZiAtIElETUwgY29sb3IgcmVmZXJlbmNlXHJcbiAgICogQHJldHVybnMge29iamVjdHxudWxsfSBBbmFseXNpcyByZXN1bHQgb3IgbnVsbCBpZiBub3QgQ01ZS1xyXG4gICAqL1xyXG4gIHN0YXRpYyBhbmFseXplSWRtbENvbG9yRm9yQmFja2dyb3VuZChjb2xvclJlZikge1xyXG4gICAgLy8gSGFuZGxlIFBhcGVyIGNvbG9yIHNwZWNpYWxseVxyXG4gICAgaWYgKGNvbG9yUmVmID09PSBcIkNvbG9yL1BhcGVyXCIgfHwgY29sb3JSZWYuaW5jbHVkZXMoXCJQYXBlclwiKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzTGlnaHRCYWNrZ3JvdW5kOiB0cnVlLFxyXG4gICAgICAgIGNhdGVnb3J5OiBcInBhcGVyXCIsXHJcbiAgICAgICAgcmVhc29uaW5nOiBcIkluRGVzaWduIFBhcGVyIGNvbG9yIC0gaWRlYWwgZm9yIGJhY2tncm91bmRcIixcclxuICAgICAgICBjb2xvclJlZixcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjbXlrID0gdGhpcy5wYXJzZUNteWtGcm9tQ29sb3JSZWYoY29sb3JSZWYpO1xyXG4gICAgaWYgKCFjbXlrKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFuYWx5c2lzID0gdGhpcy5hbmFseXplQ215a0ZvckJhY2tncm91bmQoXHJcbiAgICAgIGNteWsuYyxcclxuICAgICAgY215ay5tLFxyXG4gICAgICBjbXlrLnksXHJcbiAgICAgIGNteWsua1xyXG4gICAgKTtcclxuICAgIGFuYWx5c2lzLmNvbG9yUmVmID0gY29sb3JSZWY7XHJcbiAgICByZXR1cm4gYW5hbHlzaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgUkdCIGJyaWdodG5lc3MgdmFsdWUgKDAtMjU1LCBoaWdoZXIgPSBicmlnaHRlcilcclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFJlZCAoMC0yNTUpXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGcgLSBHcmVlbiAoMC0yNTUpXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBCbHVlICgwLTI1NSlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCcmlnaHRuZXNzIHZhbHVlXHJcbiAgICovXHJcbiAgc3RhdGljIGdldFJnYkJyaWdodG5lc3MociwgZywgYikge1xyXG4gICAgLy8gVXNlIHJlbGF0aXZlIGx1bWluYW5jZSBmb3JtdWxhXHJcbiAgICByZXR1cm4gMC4yOTkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGJyaWdodG5lc3MgZnJvbSBDTVlLIHZhbHVlc1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gQ3lhbiAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFllbGxvdyAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgLSBCbGFjay9LZXkgKDAtMTAwKVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEJyaWdodG5lc3MgdmFsdWUgKDAtMjU1KVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRDbXlrQnJpZ2h0bmVzcyhjLCBtLCB5LCBrKSB7XHJcbiAgICBjb25zdCB7IHIsIGcsIGIgfSA9IHRoaXMuY215a1RvUmdiKGMsIG0sIHksIGspO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0UmdiQnJpZ2h0bmVzcyhyLCBnLCBiKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNvcnQgY29sb3JzIGJ5IGxpZ2h0bmVzcyAobGlnaHRlc3QgZmlyc3QpXHJcbiAgICogQHBhcmFtIHtBcnJheX0gY29sb3JSZWZzIC0gQXJyYXkgb2YgSURNTCBjb2xvciByZWZlcmVuY2VzXHJcbiAgICogQHJldHVybnMge0FycmF5fSBTb3J0ZWQgYXJyYXkgd2l0aCBsaWdodGVzdCBjb2xvcnMgZmlyc3RcclxuICAgKi9cclxuICBzdGF0aWMgc29ydENvbG9yc0J5TGlnaHRuZXNzKGNvbG9yUmVmcykge1xyXG4gICAgcmV0dXJuIGNvbG9yUmVmcy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgIC8vIEFuYWx5emUgYm90aCBjb2xvcnMgZm9yIGJhY2tncm91bmQgc3VpdGFiaWxpdHlcclxuICAgICAgY29uc3QgYW5hbHlzaXNBID0gdGhpcy5hbmFseXplSWRtbENvbG9yRm9yQmFja2dyb3VuZChhKTtcclxuICAgICAgY29uc3QgYW5hbHlzaXNCID0gdGhpcy5hbmFseXplSWRtbENvbG9yRm9yQmFja2dyb3VuZChiKTtcclxuXHJcbiAgICAgIC8vIFByaW9yaXRpemUgYWN0dWFsIENNWUsgY29sb3JzIG92ZXIgUGFwZXIgY29sb3IgZm9yIHZpc3VhbCBpbnRlcmVzdFxyXG4gICAgICBjb25zdCBhSXNQYXBlciA9IGEuaW5jbHVkZXMoXCJQYXBlclwiKTtcclxuICAgICAgY29uc3QgYklzUGFwZXIgPSBiLmluY2x1ZGVzKFwiUGFwZXJcIik7XHJcbiAgICAgIGNvbnN0IGFJc0NteWsgPSAhYUlzUGFwZXIgJiYgYW5hbHlzaXNBICYmIGFuYWx5c2lzQS5jICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgIGNvbnN0IGJJc0NteWsgPSAhYklzUGFwZXIgJiYgYW5hbHlzaXNCICYmIGFuYWx5c2lzQi5jICE9PSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAvLyBJZiBvbmUgaXMgQ01ZSyBhbmQgb3RoZXIgaXMgUGFwZXIsIHByZWZlciBDTVlLIGZvciB2aXN1YWwgaW50ZXJlc3RcclxuICAgICAgaWYgKGFJc0NteWsgJiYgYklzUGFwZXIpIHJldHVybiAtMTtcclxuICAgICAgaWYgKGJJc0NteWsgJiYgYUlzUGFwZXIpIHJldHVybiAxO1xyXG5cclxuICAgICAgLy8gSWYgYm90aCBhcmUgQ01ZSywgc29ydCBieSBsaWdodG5lc3MgKGxvd2VyIEsgdmFsdWUgPSBsaWdodGVyKVxyXG4gICAgICBpZiAoYUlzQ215ayAmJiBiSXNDbXlrKSB7XHJcbiAgICAgICAgY29uc3QgY215a0EgPSB0aGlzLnBhcnNlQ215a0Zyb21Db2xvclJlZihhKTtcclxuICAgICAgICBjb25zdCBjbXlrQiA9IHRoaXMucGFyc2VDbXlrRnJvbUNvbG9yUmVmKGIpO1xyXG5cclxuICAgICAgICBpZiAoY215a0EgJiYgY215a0IpIHtcclxuICAgICAgICAgIC8vIEZpcnN0IGNvbXBhcmUgYnkgY2F0ZWdvcnkgcHJpb3JpdHkgKHZlcnlfbGlnaHQgPiBsaWdodF9ncmF5LCBldGMuKVxyXG4gICAgICAgICAgY29uc3QgY2F0ZWdvcnlQcmlvcml0eSA9IHtcclxuICAgICAgICAgICAgdmVyeV9saWdodDogMSxcclxuICAgICAgICAgICAgbGlnaHRfZ3JheTogMixcclxuICAgICAgICAgICAgcGFwZXI6IDMsXHJcbiAgICAgICAgICAgIHVua25vd246IDQsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IHByaW9yaXR5QSA9IGNhdGVnb3J5UHJpb3JpdHlbYW5hbHlzaXNBLmNhdGVnb3J5XSB8fCA0O1xyXG4gICAgICAgICAgY29uc3QgcHJpb3JpdHlCID0gY2F0ZWdvcnlQcmlvcml0eVthbmFseXNpc0IuY2F0ZWdvcnldIHx8IDQ7XHJcblxyXG4gICAgICAgICAgaWYgKHByaW9yaXR5QSAhPT0gcHJpb3JpdHlCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmlvcml0eUEgLSBwcmlvcml0eUI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gSWYgc2FtZSBjYXRlZ29yeSwgc29ydCBieSBLIHZhbHVlIChsb3dlciBLID0gbGlnaHRlcilcclxuICAgICAgICAgIHJldHVybiBjbXlrQS5rIC0gY215a0IuaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIGJvdGggYXJlIFBhcGVyIG9yIGJvdGggYXJlIHVua25vd24sIG1haW50YWluIG9yaWdpbmFsIG9yZGVyXHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBSZXN0b3JlIENvbW1vbkpTIGV4cG9ydHNcclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvclV0aWxzO1xyXG5tb2R1bGUuZXhwb3J0cy5jbXlrVG9SZ2IgPSBDb2xvclV0aWxzLmNteWtUb1JnYjtcclxubW9kdWxlLmV4cG9ydHMuY215a1RvUmdiU3RyaW5nID0gQ29sb3JVdGlscy5jbXlrVG9SZ2JTdHJpbmc7XHJcbm1vZHVsZS5leHBvcnRzLmNteWtUb0hleCA9IENvbG9yVXRpbHMuY215a1RvSGV4O1xyXG5tb2R1bGUuZXhwb3J0cy5yZ2JUb0hleCA9IENvbG9yVXRpbHMucmdiVG9IZXg7XHJcbm1vZHVsZS5leHBvcnRzLnBhcnNlQ215a0Zyb21Db2xvclJlZiA9IENvbG9yVXRpbHMucGFyc2VDbXlrRnJvbUNvbG9yUmVmO1xyXG5tb2R1bGUuZXhwb3J0cy5jb252ZXJ0SWRtbENvbG9yVG9SZ2IgPSBDb2xvclV0aWxzLmNvbnZlcnRJZG1sQ29sb3JUb1JnYjtcclxubW9kdWxlLmV4cG9ydHMuYW5hbHl6ZUNteWtGb3JCYWNrZ3JvdW5kID0gQ29sb3JVdGlscy5hbmFseXplQ215a0ZvckJhY2tncm91bmQ7XHJcbm1vZHVsZS5leHBvcnRzLmFuYWx5emVJZG1sQ29sb3JGb3JCYWNrZ3JvdW5kID1cclxuICBDb2xvclV0aWxzLmFuYWx5emVJZG1sQ29sb3JGb3JCYWNrZ3JvdW5kO1xyXG5tb2R1bGUuZXhwb3J0cy5nZXRSZ2JCcmlnaHRuZXNzID0gQ29sb3JVdGlscy5nZXRSZ2JCcmlnaHRuZXNzO1xyXG5tb2R1bGUuZXhwb3J0cy5nZXRDbXlrQnJpZ2h0bmVzcyA9IENvbG9yVXRpbHMuZ2V0Q215a0JyaWdodG5lc3M7XHJcbm1vZHVsZS5leHBvcnRzLnNvcnRDb2xvcnNCeUxpZ2h0bmVzcyA9IENvbG9yVXRpbHMuc29ydENvbG9yc0J5TGlnaHRuZXNzO1xyXG4iXSwibmFtZXMiOlsiQ29sb3JVdGlscyIsImNteWtUb1JnYiIsImMiLCJtIiwieSIsImsiLCJjTm9ybSIsIm1Ob3JtIiwieU5vcm0iLCJrTm9ybSIsInIiLCJNYXRoIiwicm91bmQiLCJnIiwiYiIsImNteWtUb1JnYlN0cmluZyIsInJnYlRvSGV4IiwidG9IZXgiLCJjb21wb25lbnQiLCJoZXgiLCJ0b1N0cmluZyIsImxlbmd0aCIsImNteWtUb0hleCIsInBhcnNlQ215a0Zyb21Db2xvclJlZiIsImNvbG9yUmVmIiwiY215a01hdGNoIiwibWF0Y2giLCJtYXAiLCJ2YWwiLCJwYXJzZUZsb2F0IiwiY29udmVydElkbWxDb2xvclRvUmdiIiwiY29sb3JSZWZPck9iaiIsInJlZCIsInVuZGVmaW5lZCIsImdyZWVuIiwiYmx1ZSIsImNteWsiLCJjb25zb2xlIiwibG9nIiwicmdiU3RyaW5nIiwibmFtZWRDb2xvcnMiLCJhbmFseXplQ215a0ZvckJhY2tncm91bmQiLCJtYXhDTVkiLCJtYXgiLCJhdmdDTVkiLCJhbmFseXNpcyIsImlzTGlnaHRCYWNrZ3JvdW5kIiwiY2F0ZWdvcnkiLCJyZWFzb25pbmciLCJhYnMiLCJhbmFseXplSWRtbENvbG9yRm9yQmFja2dyb3VuZCIsImluY2x1ZGVzIiwiZ2V0UmdiQnJpZ2h0bmVzcyIsImdldENteWtCcmlnaHRuZXNzIiwic29ydENvbG9yc0J5TGlnaHRuZXNzIiwiY29sb3JSZWZzIiwic29ydCIsImEiLCJhbmFseXNpc0EiLCJhbmFseXNpc0IiLCJhSXNQYXBlciIsImJJc1BhcGVyIiwiYUlzQ215ayIsImJJc0NteWsiLCJjbXlrQSIsImNteWtCIiwiY2F0ZWdvcnlQcmlvcml0eSIsInZlcnlfbGlnaHQiLCJsaWdodF9ncmF5IiwicGFwZXIiLCJ1bmtub3duIiwicHJpb3JpdHlBIiwicHJpb3JpdHlCIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/utils/ColorUtils.js\n"));

/***/ })

});