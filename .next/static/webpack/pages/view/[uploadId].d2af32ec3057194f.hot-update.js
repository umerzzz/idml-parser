"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StoryParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StoryParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StoryParser {\n    async parseStoryFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCDD Parsing story: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const storyId = path.basename(fileName, \".xml\");\n            const storyData = parsed.Story || parsed;\n            // ADD THESE SIMPLE LOGS FIRST:\n            console.log(\"=== SIMPLE DEBUG TEST ===\");\n            console.log(\"Story file name:\", fileName);\n            console.log(\"Parsed story keys:\", Object.keys(storyData));\n            console.log(\"Raw story data sample:\", JSON.stringify(storyData, null, 2).substring(0, 500));\n            // Extract detailed story information\n            const detailedStory = {\n                self: storyData[\"@_Self\"],\n                appliedTOCStyle: storyData[\"@_AppliedTOCStyle\"] || \"n\",\n                userText: storyData[\"@_UserText\"] !== false,\n                // Extract story content with formatting\n                content: this.extractDetailedStoryContent(storyData),\n                // Extract text formatting\n                textFormatting: this.extractTextFormatting(storyData)\n            };\n            const cleanStoryId = storyId.replace(\"Story_\", \"\");\n            this.stories[cleanStoryId] = detailedStory;\n            // Enhanced logging to show line breaks\n            const { plainText, lineBreakInfo } = detailedStory.content;\n            console.log(\"✅ Story \".concat(storyId, \" parsed:\"));\n            console.log(\"   - Characters: \".concat(plainText.length));\n            console.log(\"   - Words: \".concat(detailedStory.content.wordCount));\n            console.log(\"   - Line breaks: \".concat((lineBreakInfo === null || lineBreakInfo === void 0 ? void 0 : lineBreakInfo.lineBreakCount) || 0));\n            console.log('   - Text preview: \"'.concat(plainText.substring(0, 50).replace(/\\n/g, \"\\\\n\"), '...\"'));\n        } catch (error) {\n            console.error(\"❌ Error parsing story \".concat(fileName, \":\"), error.message);\n        }\n    }\n    // Replace the existing extractDetailedStoryContent method with this corrected version\n    extractDetailedStoryContent(storyData) {\n        var _this = this;\n        let content = \"\";\n        let formattedContent = [];\n        let textColor = null;\n        let debugInfo = [];\n        const extractTextRecursively = function(element) {\n            let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (typeof element === \"string\") {\n                content += element;\n                return;\n            }\n            if (element && typeof element === \"object\") {\n                // ENHANCED: Special handling for CharacterStyleRange with sophisticated Br detection\n                if (element.CharacterStyleRange) {\n                    const ranges = Array.isArray(element.CharacterStyleRange) ? element.CharacterStyleRange : [\n                        element.CharacterStyleRange\n                    ];\n                    // SIMPLIFIED DEBUG: Just log problematic text ranges\n                    const allRangeContent = ranges.map((r)=>r.Content ? Array.isArray(r.Content) ? r.Content.join(\"\") : String(r.Content) : \"\").join(\"\");\n                    if (allRangeContent.includes(\"pavoluptusda\") || allRangeContent.includes(\"pa\") || allRangeContent.includes(\"voluptusda\")) {\n                        console.log(\"\\uD83D\\uDEA8 FOUND RANGES WITH PROBLEMATIC TEXT:\");\n                        ranges.forEach((range, index)=>{\n                            const content = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                            console.log(\"   Range \".concat(index, ': \"').concat(content, '\"'));\n                        });\n                    }\n                    ranges.forEach((range, rangeIndex)=>{\n                        // Extract direct font references from the XML range\n                        const directFontRef = range[\"@_AppliedFont\"] || range[\"@_FontFamily\"] || range[\"@_Font\"] || \"\";\n                        const formatting = {\n                            paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                            characterStyle: range[\"@_AppliedCharacterStyle\"] || null,\n                            fontSize: range[\"@_PointSize\"] ? parseFloat(range[\"@_PointSize\"]) : null,\n                            fontReference: directFontRef,\n                            fillColor: range[\"@_FillColor\"] || null,\n                            fontStyle: range[\"@_FontStyle\"] || null,\n                            // CRITICAL FIX: Inherit paragraph alignment from context if not explicitly set\n                            alignment: range[\"@_Justification\"] || range[\"@_Alignment\"] || context.paragraphAlignment || null\n                        };\n                        // DEBUG: Log formatting extraction for any styled text (generic check)\n                        const rangeContent = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                        const hasStyleInfo = range[\"@_FontStyle\"] || range[\"@_AppliedCharacterStyle\"] || element[\"@_AppliedParagraphStyle\"] || range[\"@_AppliedFont\"];\n                        if (hasStyleInfo && rangeContent.trim()) {\n                            console.log(\"\\uD83D\\uDD27 StoryParser - Extracting formatting for range:\", JSON.stringify(rangeContent.substring(0, 30) + \"...\"), {\n                                rawRangeAttributes: Object.keys(range).filter((k)=>k.startsWith(\"@_\")),\n                                extractedFormatting: formatting,\n                                fontStyleFromXML: range[\"@_FontStyle\"],\n                                characterStyleFromXML: range[\"@_AppliedCharacterStyle\"],\n                                paragraphStyleFromXML: element[\"@_AppliedParagraphStyle\"]\n                            });\n                        }\n                        const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                        // FIXED: Process content with proper space preservation\n                        if (range.Content) {\n                            const contents = Array.isArray(range.Content) ? range.Content : [\n                                range.Content\n                            ];\n                            contents.forEach((contentItem, contentIndex)=>{\n                                const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n                                content += text;\n                                formattedContent.push({\n                                    text: text,\n                                    formatting: resolvedFormatting\n                                });\n                                // CRITICAL FIX: Check for Br elements AFTER each content item within the same range\n                                if (range.Br !== undefined && contentIndex < contents.length - 1) {\n                                    const lineBreakText = \"\\n\";\n                                    content += lineBreakText;\n                                    formattedContent.push({\n                                        text: lineBreakText,\n                                        formatting: {\n                                            isBreak: true,\n                                            breakType: \"line\",\n                                            position: \"between_content\",\n                                            source: \"Br element within range\"\n                                        }\n                                    });\n                                    debugInfo.push({\n                                        type: \"Line break detected within content\",\n                                        location: \"CharacterStyleRange[\".concat(rangeIndex, \"], between content[\").concat(contentIndex, \"] and content[\").concat(contentIndex + 1, \"]\"),\n                                        breakType: \"line\",\n                                        context: context\n                                    });\n                                }\n                            });\n                        }\n                        // Handle Br elements at the end of the range\n                        if (range.Br !== undefined && (!range.Content || Array.isArray(range.Content) === false)) {\n                            const brElements = _this.extractBrElements(range);\n                            brElements.forEach((brInfo, brIndex)=>{\n                                const lineBreakText = _this.determineLineBreakType(brInfo, context);\n                                content += lineBreakText;\n                                formattedContent.push({\n                                    text: lineBreakText,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: brInfo.type || \"line\",\n                                        position: brInfo.position || \"end\",\n                                        source: \"Br element at end of range\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Line break detected at end of range\",\n                                    location: \"CharacterStyleRange[\".concat(rangeIndex, \"], Br[\").concat(brIndex, \"]\"),\n                                    breakType: brInfo.type || \"line\",\n                                    context: context\n                                });\n                            });\n                        }\n                        // CRITICAL FIX: Add space between character style ranges if needed\n                        if (rangeIndex < ranges.length - 1) {\n                            const nextRange = ranges[rangeIndex + 1];\n                            // More robust space detection\n                            const currentText = content.slice(-10); // Check last 10 characters\n                            const currentRangeEndsWithSpace = /\\s$/.test(currentText); // Any whitespace at end\n                            const nextContent = nextRange.Content ? String(Array.isArray(nextRange.Content) ? nextRange.Content[0] : nextRange.Content) : \"\";\n                            const nextRangeStartsWithSpace = /^\\s/.test(nextContent); // Any whitespace at start\n                            // AGGRESSIVE FIX: Add space between ALL ranges unless explicitly not needed\n                            const shouldSkipSpace = currentRangeEndsWithSpace || nextRangeStartsWithSpace || _this.shouldInsertImplicitLineBreak(range, nextRange, context) || !nextRange.Content || // Skip if next range has no content\n                            nextContent.trim() === \"\"; // Skip if next content is only whitespace\n                            if (!shouldSkipSpace) {\n                                const currentStyle = range[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const nextStyle = nextRange[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const spaceText = \" \";\n                                content += spaceText;\n                                formattedContent.push({\n                                    text: spaceText,\n                                    formatting: {\n                                        isSpace: true,\n                                        source: \"between character style ranges (aggressive)\",\n                                        currentStyle,\n                                        nextStyle\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Space inserted between character styles (aggressive)\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    currentStyle,\n                                    nextStyle,\n                                    reason: \"Default space insertion - words likely split across ranges\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            } else {\n                                debugInfo.push({\n                                    type: \"Space insertion skipped\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    reason: currentRangeEndsWithSpace ? \"Current range ends with space\" : nextRangeStartsWithSpace ? \"Next range starts with space\" : !nextRange.Content ? \"Next range has no content\" : nextContent.trim() === \"\" ? \"Next content is only whitespace\" : \"Line break would be inserted\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            }\n                            // Handle explicit line breaks between ranges (for cases where shouldInsertImplicitLineBreak is true)\n                            if (_this.shouldInsertImplicitLineBreak(range, nextRange, context)) {\n                                const implicitBreak = \"\\n\";\n                                content += implicitBreak;\n                                formattedContent.push({\n                                    text: implicitBreak,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: \"implicit\",\n                                        source: \"between ranges\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Implicit line break\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1)\n                                });\n                            }\n                        }\n                    });\n                    return; // Don't continue processing to avoid duplication\n                }\n                // ENHANCED: Handle ParagraphStyleRange with context\n                if (element.ParagraphStyleRange) {\n                    const ranges = Array.isArray(element.ParagraphStyleRange) ? element.ParagraphStyleRange : [\n                        element.ParagraphStyleRange\n                    ];\n                    ranges.forEach((range, index)=>{\n                        const paragraphContext = {\n                            ...context,\n                            paragraphIndex: index,\n                            totalParagraphs: ranges.length,\n                            appliedStyle: range[\"@_AppliedParagraphStyle\"],\n                            // CRITICAL FIX: Pass down direct paragraph-level alignment\n                            paragraphAlignment: range[\"@_Justification\"] || range[\"@_Alignment\"]\n                        };\n                        extractTextRecursively(range, depth + 1, paragraphContext);\n                        // Add paragraph break between paragraphs (but not after the last one)\n                        if (index < ranges.length - 1) {\n                            const paragraphBreak = \"\\n\";\n                            content += paragraphBreak;\n                            formattedContent.push({\n                                text: paragraphBreak,\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"paragraph\",\n                                    source: \"between paragraphs\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Paragraph break\",\n                                location: \"between paragraphs \".concat(index, \" and \").concat(index + 1)\n                            });\n                        }\n                    });\n                    return;\n                }\n                // Handle direct Content elements (when not inside CharacterStyleRange)\n                if (element.Content && !element.CharacterStyleRange) {\n                    let text = Array.isArray(element.Content) ? element.Content.join(\"\") : String(element.Content);\n                    text = IDMLUtils.decodeXMLEntities(text);\n                    content += text;\n                    const formatting = {\n                        paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                        characterStyle: element[\"@_AppliedCharacterStyle\"] || null,\n                        fontSize: element[\"@_PointSize\"] || null,\n                        fontFamily: element[\"@_AppliedFont\"] || null,\n                        fillColor: element[\"@_FillColor\"] || null\n                    };\n                    const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                    formattedContent.push({\n                        text: text,\n                        formatting: resolvedFormatting\n                    });\n                }\n                // ENHANCED: Direct Br element handling (outside of ranges)\n                if (element.Br !== undefined) {\n                    const brElements = Array.isArray(element.Br) ? element.Br : [\n                        element.Br\n                    ];\n                    brElements.forEach((br, index)=>{\n                        const lineBreakText = \"\\n\";\n                        content += lineBreakText;\n                        formattedContent.push({\n                            text: lineBreakText,\n                            formatting: {\n                                isBreak: true,\n                                breakType: \"explicit\",\n                                source: \"direct Br element\"\n                            }\n                        });\n                        debugInfo.push({\n                            type: \"Direct Br element\",\n                            location: \"Direct element, index \".concat(index)\n                        });\n                    });\n                }\n                // Continue with other nested elements\n                Object.entries(element).forEach((param)=>{\n                    let [key, value] = param;\n                    if (!key.startsWith(\"@_\") && key !== \"Content\" && key !== \"Br\" && key !== \"CharacterStyleRange\" && key !== \"ParagraphStyleRange\") {\n                        if (Array.isArray(value)) {\n                            value.forEach((item)=>extractTextRecursively(item, depth + 1, context));\n                        } else if (typeof value === \"object\" && depth < 10) {\n                            extractTextRecursively(value, depth + 1, context);\n                        }\n                    }\n                });\n            }\n        };\n        extractTextRecursively(storyData);\n        // ENHANCED: Process and clean up the content with sophisticated line break preservation\n        const processedContent = IDMLUtils.sophisticatedLineBreakProcessing(content);\n        // DEBUG: Log space preservation results\n        console.log(\"\\uD83D\\uDCDD Text extraction results:\");\n        console.log(\"   - Original content length:\", content.length);\n        console.log(\"   - Processed content length:\", processedContent.length);\n        console.log(\"   - Space preservation events:\", debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length);\n        // SPECIFIC DEBUG: Check for the problematic \"pavoluptusda\" text (simplified)\n        if (processedContent.includes(\"pavoluptusda\") || processedContent.includes(\"pa\") && processedContent.includes(\"voluptusda\")) {\n            console.log(\"\\uD83D\\uDEA8 FOUND PROBLEMATIC TEXT:\");\n            console.log('   - Contains \"pavoluptusda\":', processedContent.includes(\"pavoluptusda\"));\n            console.log('   - Contains \"pa voluptusda\":', processedContent.includes(\"pa voluptusda\"));\n            console.log(\"   - FormattedContent breakdown:\", formattedContent.map((item)=>item.text).join(\"|\"));\n        }\n        const lineBreakInfo = {\n            hasLineBreaks: processedContent.includes(\"\\n\"),\n            lineBreakCount: (processedContent.match(/\\n/g) || []).length,\n            lineBreakTypes: this.analyzeLineBreakTypes(formattedContent),\n            debugInfo: debugInfo,\n            spacePreservationCount: debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length\n        };\n        return {\n            plainText: processedContent,\n            formattedContent: formattedContent.filter((item)=>item.text && item.text.length > 0),\n            wordCount: IDMLUtils.countWords(processedContent.replace(/\\n/g, \" \")),\n            characterCount: processedContent.length,\n            textColor: textColor,\n            lineBreakInfo: lineBreakInfo\n        };\n    }\n    // Add this helper method to better handle mixed content and Br elements\n    analyzeContentStructure(range) {\n        const structure = {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentItems: range.Content ? Array.isArray(range.Content) ? range.Content : [\n                range.Content\n            ] : [],\n            brElements: range.Br ? Array.isArray(range.Br) ? range.Br : [\n                range.Br\n            ] : []\n        };\n        console.log(\"Content structure analysis:\", structure);\n        return structure;\n    }\n    // Enhanced helper for processing interleaved content and breaks\n    processInterleavedContent(range, resolvedFormatting) {\n        const results = [];\n        let content = \"\";\n        // This method would need access to the actual XML structure to determine\n        // the exact order of Content and Br elements. For now, we'll use the \n        // approach above which handles the most common case.\n        return results;\n    }\n    // SOPHISTICATED: Helper method to extract Br elements with context\n    extractBrElements(range) {\n        const brElements = [];\n        if (range.Br !== undefined) {\n            if (Array.isArray(range.Br)) {\n                range.Br.forEach((br, index)=>{\n                    brElements.push({\n                        type: \"line\",\n                        position: index === 0 ? \"start\" : \"middle\",\n                        element: br\n                    });\n                });\n            } else {\n                brElements.push({\n                    type: \"line\",\n                    position: \"end\",\n                    element: range.Br\n                });\n            }\n        }\n        return brElements;\n    }\n    // SOPHISTICATED: Determine the appropriate line break type\n    determineLineBreakType(brInfo, context) {\n        // Different line break characters based on context\n        switch(brInfo.type){\n            case \"paragraph\":\n                return \"\\n\\n\"; // Double line break for paragraph separation\n            case \"forced\":\n                return \"\\n\"; // Forced line break (Shift+Enter equivalent)\n            case \"line\":\n            default:\n                return \"\\n\"; // Standard line break\n        }\n    }\n    // SOPHISTICATED: Determine if an implicit line break should be inserted\n    shouldInsertImplicitLineBreak(currentRange, nextRange, context) {\n        // Don't insert implicit breaks if explicit Br elements are present\n        if (currentRange.Br !== undefined || nextRange.Br !== undefined) {\n            return false;\n        }\n        // Insert breaks between different character styles in different paragraphs\n        const currentCharStyle = currentRange[\"@_AppliedCharacterStyle\"];\n        const nextCharStyle = nextRange[\"@_AppliedCharacterStyle\"];\n        // If we're in a context where styles change significantly, add a break\n        if (currentCharStyle && nextCharStyle && currentCharStyle !== nextCharStyle) {\n            // Check if this might be a title/heading followed by body text\n            const styleIndicatesBreak = this.styleIndicatesLineBreak(currentCharStyle, nextCharStyle);\n            return styleIndicatesBreak;\n        }\n        return false;\n    }\n    // SOPHISTICATED: Analyze if style change indicates a line break\n    styleIndicatesLineBreak(currentStyle, nextStyle) {\n        const titleIndicators = [\n            \"title\",\n            \"heading\",\n            \"header\"\n        ];\n        const bodyIndicators = [\n            \"body\",\n            \"text\",\n            \"normal\"\n        ];\n        const currentIsTitle = titleIndicators.some((indicator)=>currentStyle.toLowerCase().includes(indicator));\n        const nextIsBody = bodyIndicators.some((indicator)=>nextStyle.toLowerCase().includes(indicator));\n        return currentIsTitle && nextIsBody;\n    }\n    // SOPHISTICATED: Analyze line break types in formatted content\n    analyzeLineBreakTypes(formattedContent) {\n        const types = {\n            explicit: 0,\n            implicit: 0,\n            paragraph: 0,\n            direct: 0 // Direct Br elements\n        };\n        formattedContent.forEach((item)=>{\n            var _item_formatting;\n            if ((_item_formatting = item.formatting) === null || _item_formatting === void 0 ? void 0 : _item_formatting.isBreak) {\n                const breakType = item.formatting.breakType || \"unknown\";\n                if (types.hasOwnProperty(breakType)) {\n                    types[breakType]++;\n                }\n            }\n        });\n        return types;\n    }\n    extractDetailedFormattingFromRange(range) {\n        const formatting = {};\n        // Extract all possible font attributes\n        const fontAttributes = [\n            \"@_AppliedFont\",\n            \"@_FontFamily\",\n            \"@_Font\",\n            \"@_PostScriptName\",\n            \"@_FontName\"\n        ];\n        fontAttributes.forEach((attr)=>{\n            if (range[attr]) {\n                formatting.fontReference = range[attr];\n            }\n        });\n        // Extract font and size attributes\n        formatting.fontSize = IDMLUtils.parseNumeric(range[\"@_PointSize\"]);\n        // ENHANCED: Extract leading with proper processing\n        const rawLeading = range[\"@_Leading\"];\n        formatting.leading = this.processLeadingValue(rawLeading, formatting.fontSize);\n        formatting.leadingType = this.determineLeadingType(rawLeading);\n        // Extract color and style attributes\n        formatting.fillColor = range[\"@_FillColor\"];\n        formatting.strokeColor = range[\"@_StrokeColor\"];\n        formatting.fontStyle = range[\"@_FontStyle\"];\n        // Extract advanced typography attributes\n        formatting.tracking = IDMLUtils.parseNumeric(range[\"@_Tracking\"]);\n        formatting.baselineShift = IDMLUtils.parseNumeric(range[\"@_BaselineShift\"]);\n        formatting.kerning = IDMLUtils.parseNumeric(range[\"@_Kerning\"]);\n        formatting.horizontalScale = IDMLUtils.parseNumeric(range[\"@_HorizontalScale\"]) || 100;\n        formatting.verticalScale = IDMLUtils.parseNumeric(range[\"@_VerticalScale\"]) || 100;\n        // Extract paragraph-level attributes if present\n        // CRITICAL FIX: Only set alignment if explicitly specified, allowing paragraph inheritance\n        const explicitAlignment = range[\"@_Justification\"] || range[\"@_Alignment\"];\n        if (explicitAlignment) {\n            formatting.alignment = explicitAlignment;\n        }\n        formatting.leftIndent = IDMLUtils.parseNumeric(range[\"@_LeftIndent\"]);\n        formatting.rightIndent = IDMLUtils.parseNumeric(range[\"@_RightIndent\"]);\n        formatting.firstLineIndent = IDMLUtils.parseNumeric(range[\"@_FirstLineIndent\"]);\n        formatting.spaceBefore = IDMLUtils.parseNumeric(range[\"@_SpaceBefore\"]);\n        formatting.spaceAfter = IDMLUtils.parseNumeric(range[\"@_SpaceAfter\"]);\n        // Calculate effective line height for CSS\n        formatting.effectiveLineHeight = this.calculateEffectiveLineHeight(formatting);\n        return formatting;\n    }\n    // NEW: Process leading values with InDesign-specific logic\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = IDMLUtils.parseNumeric(rawLeading);\n        if (numericLeading) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (IDMLUtils.parseNumeric(rawLeading)) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(formatting) {\n        const fontSize = formatting.fontSize || 12;\n        const leading = formatting.leading;\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\") {\n            // Convert points to CSS line-height ratio\n            return leading / fontSize;\n        }\n        return 1.2; // Fallback\n    }\n    extractTextFormatting(storyData) {\n        const formatting = {\n            paragraphStyles: [],\n            characterStyles: [],\n            appliedStyles: []\n        };\n        // Extract applied paragraph styles\n        if (storyData.ParagraphStyleRange) {\n            const ranges = Array.isArray(storyData.ParagraphStyleRange) ? storyData.ParagraphStyleRange : [\n                storyData.ParagraphStyleRange\n            ];\n            ranges.forEach((range)=>{\n                const appliedStyle = range[\"@_AppliedParagraphStyle\"];\n                if (appliedStyle && !formatting.paragraphStyles.includes(appliedStyle)) {\n                    formatting.paragraphStyles.push(appliedStyle);\n                }\n                // Extract character styles within paragraph ranges\n                if (range.CharacterStyleRange) {\n                    const charRanges = Array.isArray(range.CharacterStyleRange) ? range.CharacterStyleRange : [\n                        range.CharacterStyleRange\n                    ];\n                    charRanges.forEach((charRange)=>{\n                        const charStyle = charRange[\"@_AppliedCharacterStyle\"];\n                        if (charStyle && !formatting.characterStyles.includes(charStyle)) {\n                            formatting.characterStyles.push(charStyle);\n                        }\n                    });\n                }\n            });\n        }\n        return formatting;\n    }\n    // Add this method to debug raw story content\n    debugRawStoryContent(storyData) {\n        console.log(\"\\n\\uD83D\\uDD0D RAW STORY CONTENT DEBUG:\");\n        console.log(\"Story keys:\", Object.keys(storyData));\n        const findCharacterRanges = function(obj) {\n            let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key === \"CharacterStyleRange\") {\n                        console.log(\"\\n\\uD83D\\uDCDD Found CharacterStyleRange at \".concat(path, \":\"), obj[key]);\n                        const ranges = Array.isArray(obj[key]) ? obj[key] : [\n                            obj[key]\n                        ];\n                        ranges.forEach((range, index)=>{\n                            console.log(\"  Range \".concat(index + 1, \" attributes:\"), Object.keys(range).filter((k)=>k.startsWith(\"@_\")));\n                            console.log(\"  Range \".concat(index + 1, \" font info:\"), {\n                                AppliedFont: range[\"@_AppliedFont\"],\n                                FontStyle: range[\"@_FontStyle\"],\n                                PointSize: range[\"@_PointSize\"]\n                            });\n                        });\n                    } else if (typeof obj[key] === \"object\") {\n                        findCharacterRanges(obj[key], \"\".concat(path, \".\").concat(key));\n                    }\n                });\n            }\n        };\n        findCharacterRanges(storyData);\n    }\n    getStories() {\n        return this.stories;\n    }\n    getStory(storyId) {\n        return this.stories[storyId];\n    }\n    clearStories() {\n        this.stories = {};\n    }\n    constructor(styleParser){\n        this.styleParser = styleParser;\n        this.stories = {};\n    }\n}\nmodule.exports = StoryParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3VFLEdBQUcsQ0FBQ3ZFLElBQUk7eUJBQUM7d0JBQzlEckYsT0FBT1UsT0FBTyxDQUFDLENBQUNDLE9BQU9DOzRCQUNyQmxELFFBQVFDLEdBQUcsQ0FBQyxXQUFxQixPQUFWaUQsUUFBUSxHQUFFLGlCQUMvQjFDLE9BQU9DLElBQUksQ0FBQ3dDLE9BQU9tQixNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLFVBQVUsQ0FBQzs0QkFFOUN0RSxRQUFRQyxHQUFHLENBQUMsV0FBcUIsT0FBVmlELFFBQVEsR0FBRSxnQkFBYztnQ0FDN0NpSixhQUFhbEosS0FBSyxDQUFDLGdCQUFnQjtnQ0FDbkNtSixXQUFXbkosS0FBSyxDQUFDLGNBQWM7Z0NBQy9Cb0osV0FBV3BKLEtBQUssQ0FBQyxjQUFjOzRCQUNqQzt3QkFDRjtvQkFDRixPQUFPLElBQUksT0FBT2lKLEdBQUcsQ0FBQ3ZFLElBQUksS0FBSyxVQUFVO3dCQUN2Q3NFLG9CQUFvQkMsR0FBRyxDQUFDdkUsSUFBSSxFQUFFLEdBQVdBLE9BQVJuSSxNQUFLLEtBQU8sT0FBSm1JO29CQUMzQztnQkFDRjtZQUNGO1FBQ0Y7UUFFQXNFLG9CQUFvQjNMO0lBQ3RCO0lBRUFnTSxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNoTCxPQUFPO0lBQ3JCO0lBRUFpTCxTQUFTbk0sT0FBTyxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxDQUFDa0IsT0FBTyxDQUFDbEIsUUFBUTtJQUM5QjtJQUVBb00sZUFBZTtRQUNiLElBQUksQ0FBQ2xMLE9BQU8sR0FBRyxDQUFDO0lBQ2xCO0lBMXJCQW1MLFlBQVk3SCxXQUFXLENBQUU7UUFDdkIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ3RELE9BQU8sR0FBRyxDQUFDO0lBQ2xCO0FBd3JCRjtBQUVBb0wsT0FBT0MsT0FBTyxHQUFHaE4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3BhcnNlcnMvU3RvcnlQYXJzZXIuanM/NjhjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBJRE1MVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9JRE1MVXRpbHMnKTtcclxuXHJcbmNsYXNzIFN0b3J5UGFyc2VyIHtcclxuICBjb25zdHJ1Y3RvcihzdHlsZVBhcnNlcikge1xyXG4gICAgdGhpcy5zdHlsZVBhcnNlciA9IHN0eWxlUGFyc2VyO1xyXG4gICAgdGhpcy5zdG9yaWVzID0ge307XHJcbiAgfVxyXG5cclxuICBhc3luYyBwYXJzZVN0b3J5RmlsZShmaWxlTmFtZSwgY29udGVudCwgeG1sUGFyc2VyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TnSBQYXJzaW5nIHN0b3J5OiAke2ZpbGVOYW1lfWApO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSB4bWxQYXJzZXIucGFyc2UoY29udGVudCk7XHJcbiAgICAgIGNvbnN0IHN0b3J5SWQgPSBwYXRoLmJhc2VuYW1lKGZpbGVOYW1lLCAnLnhtbCcpO1xyXG4gICAgICBcclxuICAgICAgY29uc3Qgc3RvcnlEYXRhID0gcGFyc2VkLlN0b3J5IHx8IHBhcnNlZDtcclxuICAgICAgXHJcbiAgICAgIC8vIEFERCBUSEVTRSBTSU1QTEUgTE9HUyBGSVJTVDpcclxuICAgICAgY29uc29sZS5sb2coJz09PSBTSU1QTEUgREVCVUcgVEVTVCA9PT0nKTtcclxuICAgICAgY29uc29sZS5sb2coJ1N0b3J5IGZpbGUgbmFtZTonLCBmaWxlTmFtZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgc3Rvcnkga2V5czonLCBPYmplY3Qua2V5cyhzdG9yeURhdGEpKTtcclxuICAgICAgY29uc29sZS5sb2coJ1JhdyBzdG9yeSBkYXRhIHNhbXBsZTonLCBKU09OLnN0cmluZ2lmeShzdG9yeURhdGEsIG51bGwsIDIpLnN1YnN0cmluZygwLCA1MDApKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgZGV0YWlsZWQgc3RvcnkgaW5mb3JtYXRpb25cclxuICAgICAgY29uc3QgZGV0YWlsZWRTdG9yeSA9IHtcclxuICAgICAgICBzZWxmOiBzdG9yeURhdGFbJ0BfU2VsZiddLFxyXG4gICAgICAgIGFwcGxpZWRUT0NTdHlsZTogc3RvcnlEYXRhWydAX0FwcGxpZWRUT0NTdHlsZSddIHx8ICduJyxcclxuICAgICAgICB1c2VyVGV4dDogc3RvcnlEYXRhWydAX1VzZXJUZXh0J10gIT09IGZhbHNlLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEV4dHJhY3Qgc3RvcnkgY29udGVudCB3aXRoIGZvcm1hdHRpbmdcclxuICAgICAgICBjb250ZW50OiB0aGlzLmV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudChzdG9yeURhdGEpLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEV4dHJhY3QgdGV4dCBmb3JtYXR0aW5nXHJcbiAgICAgICAgdGV4dEZvcm1hdHRpbmc6IHRoaXMuZXh0cmFjdFRleHRGb3JtYXR0aW5nKHN0b3J5RGF0YSlcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNsZWFuU3RvcnlJZCA9IHN0b3J5SWQucmVwbGFjZSgnU3RvcnlfJywgJycpO1xyXG4gICAgICB0aGlzLnN0b3JpZXNbY2xlYW5TdG9yeUlkXSA9IGRldGFpbGVkU3Rvcnk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFbmhhbmNlZCBsb2dnaW5nIHRvIHNob3cgbGluZSBicmVha3NcclxuICAgICAgY29uc3QgeyBwbGFpblRleHQsIGxpbmVCcmVha0luZm8gfSA9IGRldGFpbGVkU3RvcnkuY29udGVudDtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBTdG9yeSAke3N0b3J5SWR9IHBhcnNlZDpgKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIC0gQ2hhcmFjdGVyczogJHtwbGFpblRleHQubGVuZ3RofWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBXb3JkczogJHtkZXRhaWxlZFN0b3J5LmNvbnRlbnQud29yZENvdW50fWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBMaW5lIGJyZWFrczogJHtsaW5lQnJlYWtJbmZvPy5saW5lQnJlYWtDb3VudCB8fCAwfWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBUZXh0IHByZXZpZXc6IFwiJHtwbGFpblRleHQuc3Vic3RyaW5nKDAsIDUwKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJyl9Li4uXCJgKTtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcGFyc2luZyBzdG9yeSAke2ZpbGVOYW1lfTpgLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlcGxhY2UgdGhlIGV4aXN0aW5nIGV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudCBtZXRob2Qgd2l0aCB0aGlzIGNvcnJlY3RlZCB2ZXJzaW9uXHJcbiAgZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50KHN0b3J5RGF0YSkge1xyXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcclxuICAgIGxldCBmb3JtYXR0ZWRDb250ZW50ID0gW107XHJcbiAgICBsZXQgdGV4dENvbG9yID0gbnVsbDtcclxuICAgIGxldCBkZWJ1Z0luZm8gPSBbXTtcclxuICAgIFxyXG4gICAgY29uc3QgZXh0cmFjdFRleHRSZWN1cnNpdmVseSA9IChlbGVtZW50LCBkZXB0aCA9IDAsIGNvbnRleHQgPSB7fSkgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29udGVudCArPSBlbGVtZW50O1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IFNwZWNpYWwgaGFuZGxpbmcgZm9yIENoYXJhY3RlclN0eWxlUmFuZ2Ugd2l0aCBzb3BoaXN0aWNhdGVkIEJyIGRldGVjdGlvblxyXG4gICAgICAgIGlmIChlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlKSA/IFxyXG4gICAgICAgICAgICBlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UgOiBbZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlXTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gU0lNUExJRklFRCBERUJVRzogSnVzdCBsb2cgcHJvYmxlbWF0aWMgdGV4dCByYW5nZXNcclxuICAgICAgICAgIGNvbnN0IGFsbFJhbmdlQ29udGVudCA9IHJhbmdlcy5tYXAociA9PiByLkNvbnRlbnQgPyBcclxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoci5Db250ZW50KSA/IHIuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhyLkNvbnRlbnQpKSA6ICcnKS5qb2luKCcnKTtcclxuICAgICAgICAgIGlmIChhbGxSYW5nZUNvbnRlbnQuaW5jbHVkZXMoJ3Bhdm9sdXB0dXNkYScpIHx8IGFsbFJhbmdlQ29udGVudC5pbmNsdWRlcygncGEnKSB8fCBhbGxSYW5nZUNvbnRlbnQuaW5jbHVkZXMoJ3ZvbHVwdHVzZGEnKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+aqCBGT1VORCBSQU5HRVMgV0lUSCBQUk9CTEVNQVRJQyBURVhUOicpO1xyXG4gICAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHJhbmdlLkNvbnRlbnQgPyBcclxuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhyYW5nZS5Db250ZW50KSkgOiAnJztcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgUmFuZ2UgJHtpbmRleH06IFwiJHtjb250ZW50fVwiYCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIHJhbmdlSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgLy8gRXh0cmFjdCBkaXJlY3QgZm9udCByZWZlcmVuY2VzIGZyb20gdGhlIFhNTCByYW5nZVxyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3RGb250UmVmID0gcmFuZ2VbJ0BfQXBwbGllZEZvbnQnXSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbJ0BfRm9udEZhbWlseSddIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVsnQF9Gb250J10gfHwgJyc7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0aW5nID0ge1xyXG4gICAgICAgICAgICAgIHBhcmFncmFwaFN0eWxlOiBlbGVtZW50WydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddIHx8IGNvbnRleHQuYXBwbGllZFN0eWxlIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgY2hhcmFjdGVyU3R5bGU6IHJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgZm9udFNpemU6IHJhbmdlWydAX1BvaW50U2l6ZSddID8gcGFyc2VGbG9hdChyYW5nZVsnQF9Qb2ludFNpemUnXSkgOiBudWxsLFxyXG4gICAgICAgICAgICAgIGZvbnRSZWZlcmVuY2U6IGRpcmVjdEZvbnRSZWYsXHJcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiByYW5nZVsnQF9GaWxsQ29sb3InXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgIGZvbnRTdHlsZTogcmFuZ2VbJ0BfRm9udFN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IEluaGVyaXQgcGFyYWdyYXBoIGFsaWdubWVudCBmcm9tIGNvbnRleHQgaWYgbm90IGV4cGxpY2l0bHkgc2V0XHJcbiAgICAgICAgICAgICAgYWxpZ25tZW50OiByYW5nZVsnQF9KdXN0aWZpY2F0aW9uJ10gfHwgcmFuZ2VbJ0BfQWxpZ25tZW50J10gfHwgY29udGV4dC5wYXJhZ3JhcGhBbGlnbm1lbnQgfHwgbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gREVCVUc6IExvZyBmb3JtYXR0aW5nIGV4dHJhY3Rpb24gZm9yIGFueSBzdHlsZWQgdGV4dCAoZ2VuZXJpYyBjaGVjaylcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VDb250ZW50ID0gcmFuZ2UuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhyYW5nZS5Db250ZW50KSkgOiAnJztcclxuICAgICAgICAgICAgY29uc3QgaGFzU3R5bGVJbmZvID0gcmFuZ2VbJ0BfRm9udFN0eWxlJ10gfHwgcmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFsnQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGUnXSB8fCByYW5nZVsnQF9BcHBsaWVkRm9udCddO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGhhc1N0eWxlSW5mbyAmJiByYW5nZUNvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflKcgU3RvcnlQYXJzZXIgLSBFeHRyYWN0aW5nIGZvcm1hdHRpbmcgZm9yIHJhbmdlOicsIEpTT04uc3RyaW5naWZ5KHJhbmdlQ29udGVudC5zdWJzdHJpbmcoMCwgMzApICsgJy4uLicpLCB7XHJcbiAgICAgICAgICAgICAgICByYXdSYW5nZUF0dHJpYnV0ZXM6IE9iamVjdC5rZXlzKHJhbmdlKS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoJ0BfJykpLFxyXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkRm9ybWF0dGluZzogZm9ybWF0dGluZyxcclxuICAgICAgICAgICAgICAgIGZvbnRTdHlsZUZyb21YTUw6IHJhbmdlWydAX0ZvbnRTdHlsZSddLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyU3R5bGVGcm9tWE1MOiByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSxcclxuICAgICAgICAgICAgICAgIHBhcmFncmFwaFN0eWxlRnJvbVhNTDogZWxlbWVudFsnQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGUnXVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEZvcm1hdHRpbmcgPSB0aGlzLnN0eWxlUGFyc2VyLnJlc29sdmVTdHlsZUZvcm1hdHRpbmcoZm9ybWF0dGluZyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBGSVhFRDogUHJvY2VzcyBjb250ZW50IHdpdGggcHJvcGVyIHNwYWNlIHByZXNlcnZhdGlvblxyXG4gICAgICAgICAgICBpZiAocmFuZ2UuQ29udGVudCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA/IHJhbmdlLkNvbnRlbnQgOiBbcmFuZ2UuQ29udGVudF07XHJcbiAgICAgICAgICAgICAgY29udGVudHMuZm9yRWFjaCgoY29udGVudEl0ZW0sIGNvbnRlbnRJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyhTdHJpbmcoY29udGVudEl0ZW0pKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gdGV4dDtcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHJlc29sdmVkRm9ybWF0dGluZ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogQ2hlY2sgZm9yIEJyIGVsZW1lbnRzIEFGVEVSIGVhY2ggY29udGVudCBpdGVtIHdpdGhpbiB0aGUgc2FtZSByYW5nZVxyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLkJyICE9PSB1bmRlZmluZWQgJiYgY29udGVudEluZGV4IDwgY29udGVudHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gJ1xcbic7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiAnbGluZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JldHdlZW5fY29udGVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdCciBlbGVtZW50IHdpdGhpbiByYW5nZSdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaW5lIGJyZWFrIGRldGVjdGVkIHdpdGhpbiBjb250ZW50JyxcclxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYENoYXJhY3RlclN0eWxlUmFuZ2VbJHtyYW5nZUluZGV4fV0sIGJldHdlZW4gY29udGVudFske2NvbnRlbnRJbmRleH1dIGFuZCBjb250ZW50WyR7Y29udGVudEluZGV4ICsgMX1dYCxcclxuICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgQnIgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgcmFuZ2VcclxuICAgICAgICAgICAgaWYgKHJhbmdlLkJyICE9PSB1bmRlZmluZWQgJiYgKCFyYW5nZS5Db250ZW50IHx8IEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudCkgPT09IGZhbHNlKSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGJyRWxlbWVudHMgPSB0aGlzLmV4dHJhY3RCckVsZW1lbnRzKHJhbmdlKTtcclxuICAgICAgICAgICAgICBickVsZW1lbnRzLmZvckVhY2goKGJySW5mbywgYnJJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUJyZWFrVGV4dCA9IHRoaXMuZGV0ZXJtaW5lTGluZUJyZWFrVHlwZShickluZm8sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0LFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7IFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiBickluZm8udHlwZSB8fCAnbGluZScsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGJySW5mby5wb3NpdGlvbiB8fCAnZW5kJyxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdCciBlbGVtZW50IGF0IGVuZCBvZiByYW5nZSdcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ0xpbmUgYnJlYWsgZGV0ZWN0ZWQgYXQgZW5kIG9mIHJhbmdlJyxcclxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBDaGFyYWN0ZXJTdHlsZVJhbmdlWyR7cmFuZ2VJbmRleH1dLCBCclske2JySW5kZXh9XWAsXHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogYnJJbmZvLnR5cGUgfHwgJ2xpbmUnLFxyXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBBZGQgc3BhY2UgYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGUgcmFuZ2VzIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBpZiAocmFuZ2VJbmRleCA8IHJhbmdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbmV4dFJhbmdlID0gcmFuZ2VzW3JhbmdlSW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBNb3JlIHJvYnVzdCBzcGFjZSBkZXRlY3Rpb25cclxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGNvbnRlbnQuc2xpY2UoLTEwKTsgLy8gQ2hlY2sgbGFzdCAxMCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSA9IC9cXHMkLy50ZXN0KGN1cnJlbnRUZXh0KTsgLy8gQW55IHdoaXRlc3BhY2UgYXQgZW5kXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgY29uc3QgbmV4dENvbnRlbnQgPSBuZXh0UmFuZ2UuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAgICAgU3RyaW5nKEFycmF5LmlzQXJyYXkobmV4dFJhbmdlLkNvbnRlbnQpID8gbmV4dFJhbmdlLkNvbnRlbnRbMF0gOiBuZXh0UmFuZ2UuQ29udGVudCkgOiAnJztcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2UgPSAvXlxccy8udGVzdChuZXh0Q29udGVudCk7IC8vIEFueSB3aGl0ZXNwYWNlIGF0IHN0YXJ0XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gQUdHUkVTU0lWRSBGSVg6IEFkZCBzcGFjZSBiZXR3ZWVuIEFMTCByYW5nZXMgdW5sZXNzIGV4cGxpY2l0bHkgbm90IG5lZWRlZFxyXG4gICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBTcGFjZSA9IGN1cnJlbnRSYW5nZUVuZHNXaXRoU3BhY2UgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2UgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrKHJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbmV4dFJhbmdlLkNvbnRlbnQgfHwgLy8gU2tpcCBpZiBuZXh0IHJhbmdlIGhhcyBubyBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29udGVudC50cmltKCkgPT09ICcnOyAvLyBTa2lwIGlmIG5leHQgY29udGVudCBpcyBvbmx5IHdoaXRlc3BhY2VcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBpZiAoIXNob3VsZFNraXBTcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0eWxlID0gcmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFN0eWxlID0gbmV4dFJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddIHx8ICdub25lJztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhY2VUZXh0ID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBzcGFjZVRleHQ7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBzcGFjZVRleHQsXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpc1NwYWNlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ2JldHdlZW4gY2hhcmFjdGVyIHN0eWxlIHJhbmdlcyAoYWdncmVzc2l2ZSknLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3R5bGVcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ1NwYWNlIGluc2VydGVkIGJldHdlZW4gY2hhcmFjdGVyIHN0eWxlcyAoYWdncmVzc2l2ZSknLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7cmFuZ2VJbmRleCArIDF9YCxcclxuICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICBuZXh0U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogJ0RlZmF1bHQgc3BhY2UgaW5zZXJ0aW9uIC0gd29yZHMgbGlrZWx5IHNwbGl0IGFjcm9zcyByYW5nZXMnLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dEVuZDogY3VycmVudFRleHQuc2xpY2UoLTUpLFxyXG4gICAgICAgICAgICAgICAgICBuZXh0VGV4dFN0YXJ0OiBuZXh0Q29udGVudC5zbGljZSgwLCA1KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ1NwYWNlIGluc2VydGlvbiBza2lwcGVkJyxcclxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBCZXR3ZWVuIHJhbmdlcyAke3JhbmdlSW5kZXh9IGFuZCAke3JhbmdlSW5kZXggKyAxfWAsXHJcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSA/ICdDdXJyZW50IHJhbmdlIGVuZHMgd2l0aCBzcGFjZScgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSA/ICdOZXh0IHJhbmdlIHN0YXJ0cyB3aXRoIHNwYWNlJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIW5leHRSYW5nZS5Db250ZW50ID8gJ05leHQgcmFuZ2UgaGFzIG5vIGNvbnRlbnQnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENvbnRlbnQudHJpbSgpID09PSAnJyA/ICdOZXh0IGNvbnRlbnQgaXMgb25seSB3aGl0ZXNwYWNlJyA6ICdMaW5lIGJyZWFrIHdvdWxkIGJlIGluc2VydGVkJyxcclxuICAgICAgICAgICAgICAgICAgY3VycmVudFRleHRFbmQ6IGN1cnJlbnRUZXh0LnNsaWNlKC01KSxcclxuICAgICAgICAgICAgICAgICAgbmV4dFRleHRTdGFydDogbmV4dENvbnRlbnQuc2xpY2UoMCwgNSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBIYW5kbGUgZXhwbGljaXQgbGluZSBicmVha3MgYmV0d2VlbiByYW5nZXMgKGZvciBjYXNlcyB3aGVyZSBzaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayBpcyB0cnVlKVxyXG4gICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrKHJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbXBsaWNpdEJyZWFrID0gJ1xcbic7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGltcGxpY2l0QnJlYWs7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBpbXBsaWNpdEJyZWFrLFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdpbXBsaWNpdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnYmV0d2VlbiByYW5nZXMnXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdJbXBsaWNpdCBsaW5lIGJyZWFrJyxcclxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBCZXR3ZWVuIHJhbmdlcyAke3JhbmdlSW5kZXh9IGFuZCAke3JhbmdlSW5kZXggKyAxfWBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm47IC8vIERvbid0IGNvbnRpbnVlIHByb2Nlc3NpbmcgdG8gYXZvaWQgZHVwbGljYXRpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IEhhbmRsZSBQYXJhZ3JhcGhTdHlsZVJhbmdlIHdpdGggY29udGV4dFxyXG4gICAgICAgIGlmIChlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5QYXJhZ3JhcGhTdHlsZVJhbmdlKSA/IFxyXG4gICAgICAgICAgICBlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2UgOiBbZWxlbWVudC5QYXJhZ3JhcGhTdHlsZVJhbmdlXTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhDb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgIC4uLmNvbnRleHQsXHJcbiAgICAgICAgICAgICAgcGFyYWdyYXBoSW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgIHRvdGFsUGFyYWdyYXBoczogcmFuZ2VzLmxlbmd0aCxcclxuICAgICAgICAgICAgICBhcHBsaWVkU3R5bGU6IHJhbmdlWydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddLFxyXG4gICAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogUGFzcyBkb3duIGRpcmVjdCBwYXJhZ3JhcGgtbGV2ZWwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgcGFyYWdyYXBoQWxpZ25tZW50OiByYW5nZVsnQF9KdXN0aWZpY2F0aW9uJ10gfHwgcmFuZ2VbJ0BfQWxpZ25tZW50J11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkocmFuZ2UsIGRlcHRoICsgMSwgcGFyYWdyYXBoQ29udGV4dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBZGQgcGFyYWdyYXBoIGJyZWFrIGJldHdlZW4gcGFyYWdyYXBocyAoYnV0IG5vdCBhZnRlciB0aGUgbGFzdCBvbmUpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHJhbmdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoQnJlYWsgPSAnXFxuJztcclxuICAgICAgICAgICAgICBjb250ZW50ICs9IHBhcmFncmFwaEJyZWFrO1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhZ3JhcGhCcmVhayxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiAncGFyYWdyYXBoJyxcclxuICAgICAgICAgICAgICAgICAgc291cmNlOiAnYmV0d2VlbiBwYXJhZ3JhcGhzJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHsgXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUGFyYWdyYXBoIGJyZWFrJywgXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogYGJldHdlZW4gcGFyYWdyYXBocyAke2luZGV4fSBhbmQgJHtpbmRleCArIDF9YCBcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEhhbmRsZSBkaXJlY3QgQ29udGVudCBlbGVtZW50cyAod2hlbiBub3QgaW5zaWRlIENoYXJhY3RlclN0eWxlUmFuZ2UpXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuQ29udGVudCAmJiAhZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlKSB7XHJcbiAgICAgICAgICBsZXQgdGV4dCA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5Db250ZW50KSA/IGVsZW1lbnQuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhlbGVtZW50LkNvbnRlbnQpO1xyXG4gICAgICAgICAgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyh0ZXh0KTtcclxuICAgICAgICAgIGNvbnRlbnQgKz0gdGV4dDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ10gfHwgY29udGV4dC5hcHBsaWVkU3R5bGUgfHwgbnVsbCxcclxuICAgICAgICAgICAgY2hhcmFjdGVyU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udFNpemU6IGVsZW1lbnRbJ0BfUG9pbnRTaXplJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udEZhbWlseTogZWxlbWVudFsnQF9BcHBsaWVkRm9udCddIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogZWxlbWVudFsnQF9GaWxsQ29sb3InXSB8fCBudWxsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IHJlc29sdmVkRm9ybWF0dGluZyA9IHRoaXMuc3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IERpcmVjdCBCciBlbGVtZW50IGhhbmRsaW5nIChvdXRzaWRlIG9mIHJhbmdlcylcclxuICAgICAgICBpZiAoZWxlbWVudC5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zdCBickVsZW1lbnRzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkJyKSA/IGVsZW1lbnQuQnIgOiBbZWxlbWVudC5Ccl07XHJcbiAgICAgICAgICBickVsZW1lbnRzLmZvckVhY2goKGJyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gJ1xcbic7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0LFxyXG4gICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdleHBsaWNpdCcsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICdkaXJlY3QgQnIgZWxlbWVudCdcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0RpcmVjdCBCciBlbGVtZW50JyxcclxuICAgICAgICAgICAgICBsb2NhdGlvbjogYERpcmVjdCBlbGVtZW50LCBpbmRleCAke2luZGV4fWBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciBuZXN0ZWQgZWxlbWVudHNcclxuICAgICAgICBPYmplY3QuZW50cmllcyhlbGVtZW50KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJ0BfJykgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQ29udGVudCcgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQnInICYmIFxyXG4gICAgICAgICAgICAgIGtleSAhPT0gJ0NoYXJhY3RlclN0eWxlUmFuZ2UnICYmXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnUGFyYWdyYXBoU3R5bGVSYW5nZScpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChpdGVtID0+IGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkoaXRlbSwgZGVwdGggKyAxLCBjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBkZXB0aCA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgZXh0cmFjdFRleHRSZWN1cnNpdmVseSh2YWx1ZSwgZGVwdGggKyAxLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5KHN0b3J5RGF0YSk7XHJcbiAgICBcclxuICAgIC8vIEVOSEFOQ0VEOiBQcm9jZXNzIGFuZCBjbGVhbiB1cCB0aGUgY29udGVudCB3aXRoIHNvcGhpc3RpY2F0ZWQgbGluZSBicmVhayBwcmVzZXJ2YXRpb25cclxuICAgIGNvbnN0IHByb2Nlc3NlZENvbnRlbnQgPSBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmcoY29udGVudCk7XHJcbiAgICBcclxuICAgIC8vIERFQlVHOiBMb2cgc3BhY2UgcHJlc2VydmF0aW9uIHJlc3VsdHNcclxuICAgIGNvbnNvbGUubG9nKCfwn5OdIFRleHQgZXh0cmFjdGlvbiByZXN1bHRzOicpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gT3JpZ2luYWwgY29udGVudCBsZW5ndGg6JywgY29udGVudC5sZW5ndGgpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gUHJvY2Vzc2VkIGNvbnRlbnQgbGVuZ3RoOicsIHByb2Nlc3NlZENvbnRlbnQubGVuZ3RoKTtcclxuICAgIGNvbnNvbGUubG9nKCcgICAtIFNwYWNlIHByZXNlcnZhdGlvbiBldmVudHM6JywgZGVidWdJbmZvLmZpbHRlcihpbmZvID0+IGluZm8udHlwZS5pbmNsdWRlcygnU3BhY2UgaW5zZXJ0ZWQnKSkubGVuZ3RoKTtcclxuICAgIFxyXG4gICAgLy8gU1BFQ0lGSUMgREVCVUc6IENoZWNrIGZvciB0aGUgcHJvYmxlbWF0aWMgXCJwYXZvbHVwdHVzZGFcIiB0ZXh0IChzaW1wbGlmaWVkKVxyXG4gICAgaWYgKHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3Bhdm9sdXB0dXNkYScpIHx8IHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3BhJykgJiYgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygndm9sdXB0dXNkYScpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qoIEZPVU5EIFBST0JMRU1BVElDIFRFWFQ6Jyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIENvbnRhaW5zIFwicGF2b2x1cHR1c2RhXCI6JywgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBDb250YWlucyBcInBhIHZvbHVwdHVzZGFcIjonLCBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCdwYSB2b2x1cHR1c2RhJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBGb3JtYXR0ZWRDb250ZW50IGJyZWFrZG93bjonLCBmb3JtYXR0ZWRDb250ZW50Lm1hcChpdGVtID0+IGl0ZW0udGV4dCkuam9pbignfCcpKTtcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIFxyXG4gICAgY29uc3QgbGluZUJyZWFrSW5mbyA9IHtcclxuICAgICAgaGFzTGluZUJyZWFrczogcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygnXFxuJyksXHJcbiAgICAgIGxpbmVCcmVha0NvdW50OiAocHJvY2Vzc2VkQ29udGVudC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGgsXHJcbiAgICAgIGxpbmVCcmVha1R5cGVzOiB0aGlzLmFuYWx5emVMaW5lQnJlYWtUeXBlcyhmb3JtYXR0ZWRDb250ZW50KSxcclxuICAgICAgZGVidWdJbmZvOiBkZWJ1Z0luZm8sXHJcbiAgICAgIHNwYWNlUHJlc2VydmF0aW9uQ291bnQ6IGRlYnVnSW5mby5maWx0ZXIoaW5mbyA9PiBpbmZvLnR5cGUuaW5jbHVkZXMoJ1NwYWNlIGluc2VydGVkJykpLmxlbmd0aFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGxhaW5UZXh0OiBwcm9jZXNzZWRDb250ZW50LFxyXG4gICAgICBmb3JtYXR0ZWRDb250ZW50OiBmb3JtYXR0ZWRDb250ZW50LmZpbHRlcihpdGVtID0+IGl0ZW0udGV4dCAmJiBpdGVtLnRleHQubGVuZ3RoID4gMCksXHJcbiAgICAgIHdvcmRDb3VudDogSURNTFV0aWxzLmNvdW50V29yZHMocHJvY2Vzc2VkQ29udGVudC5yZXBsYWNlKC9cXG4vZywgJyAnKSksXHJcbiAgICAgIGNoYXJhY3RlckNvdW50OiBwcm9jZXNzZWRDb250ZW50Lmxlbmd0aCxcclxuICAgICAgdGV4dENvbG9yOiB0ZXh0Q29sb3IsXHJcbiAgICAgIGxpbmVCcmVha0luZm86IGxpbmVCcmVha0luZm9cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgdGhpcyBoZWxwZXIgbWV0aG9kIHRvIGJldHRlciBoYW5kbGUgbWl4ZWQgY29udGVudCBhbmQgQnIgZWxlbWVudHNcclxuICBhbmFseXplQ29udGVudFN0cnVjdHVyZShyYW5nZSkge1xyXG4gICAgY29uc3Qgc3RydWN0dXJlID0ge1xyXG4gICAgICBoYXNDb250ZW50OiAhIXJhbmdlLkNvbnRlbnQsXHJcbiAgICAgIGhhc0JyOiByYW5nZS5CciAhPT0gdW5kZWZpbmVkLFxyXG4gICAgICBjb250ZW50SXRlbXM6IHJhbmdlLkNvbnRlbnQgPyAoQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA/IHJhbmdlLkNvbnRlbnQgOiBbcmFuZ2UuQ29udGVudF0pIDogW10sXHJcbiAgICAgIGJyRWxlbWVudHM6IHJhbmdlLkJyID8gKEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpID8gcmFuZ2UuQnIgOiBbcmFuZ2UuQnJdKSA6IFtdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQ29udGVudCBzdHJ1Y3R1cmUgYW5hbHlzaXM6Jywgc3RydWN0dXJlKTtcclxuICAgIHJldHVybiBzdHJ1Y3R1cmU7XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBoZWxwZXIgZm9yIHByb2Nlc3NpbmcgaW50ZXJsZWF2ZWQgY29udGVudCBhbmQgYnJlYWtzXHJcbiAgcHJvY2Vzc0ludGVybGVhdmVkQ29udGVudChyYW5nZSwgcmVzb2x2ZWRGb3JtYXR0aW5nKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgXHJcbiAgICAvLyBUaGlzIG1ldGhvZCB3b3VsZCBuZWVkIGFjY2VzcyB0byB0aGUgYWN0dWFsIFhNTCBzdHJ1Y3R1cmUgdG8gZGV0ZXJtaW5lXHJcbiAgICAvLyB0aGUgZXhhY3Qgb3JkZXIgb2YgQ29udGVudCBhbmQgQnIgZWxlbWVudHMuIEZvciBub3csIHdlJ2xsIHVzZSB0aGUgXHJcbiAgICAvLyBhcHByb2FjaCBhYm92ZSB3aGljaCBoYW5kbGVzIHRoZSBtb3N0IGNvbW1vbiBjYXNlLlxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEhlbHBlciBtZXRob2QgdG8gZXh0cmFjdCBCciBlbGVtZW50cyB3aXRoIGNvbnRleHRcclxuICBleHRyYWN0QnJFbGVtZW50cyhyYW5nZSkge1xyXG4gICAgY29uc3QgYnJFbGVtZW50cyA9IFtdO1xyXG4gICAgXHJcbiAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyYW5nZS5CcikpIHtcclxuICAgICAgICByYW5nZS5Cci5mb3JFYWNoKChiciwgaW5kZXgpID0+IHtcclxuICAgICAgICAgIGJyRWxlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgcG9zaXRpb246IGluZGV4ID09PSAwID8gJ3N0YXJ0JyA6ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICBlbGVtZW50OiBiclxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJFbGVtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJyxcclxuICAgICAgICAgIGVsZW1lbnQ6IHJhbmdlLkJyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGJyRWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGxpbmUgYnJlYWsgdHlwZVxyXG4gIGRldGVybWluZUxpbmVCcmVha1R5cGUoYnJJbmZvLCBjb250ZXh0KSB7XHJcbiAgICAvLyBEaWZmZXJlbnQgbGluZSBicmVhayBjaGFyYWN0ZXJzIGJhc2VkIG9uIGNvbnRleHRcclxuICAgIHN3aXRjaCAoYnJJbmZvLnR5cGUpIHtcclxuICAgICAgY2FzZSAncGFyYWdyYXBoJzpcclxuICAgICAgICByZXR1cm4gJ1xcblxcbic7IC8vIERvdWJsZSBsaW5lIGJyZWFrIGZvciBwYXJhZ3JhcGggc2VwYXJhdGlvblxyXG4gICAgICBjYXNlICdmb3JjZWQnOlxyXG4gICAgICAgIHJldHVybiAnXFxuJzsgLy8gRm9yY2VkIGxpbmUgYnJlYWsgKFNoaWZ0K0VudGVyIGVxdWl2YWxlbnQpXHJcbiAgICAgIGNhc2UgJ2xpbmUnOlxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAnXFxuJzsgLy8gU3RhbmRhcmQgbGluZSBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogRGV0ZXJtaW5lIGlmIGFuIGltcGxpY2l0IGxpbmUgYnJlYWsgc2hvdWxkIGJlIGluc2VydGVkXHJcbiAgc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsoY3VycmVudFJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpIHtcclxuICAgIC8vIERvbid0IGluc2VydCBpbXBsaWNpdCBicmVha3MgaWYgZXhwbGljaXQgQnIgZWxlbWVudHMgYXJlIHByZXNlbnRcclxuICAgIGlmIChjdXJyZW50UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCB8fCBuZXh0UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEluc2VydCBicmVha3MgYmV0d2VlbiBkaWZmZXJlbnQgY2hhcmFjdGVyIHN0eWxlcyBpbiBkaWZmZXJlbnQgcGFyYWdyYXBoc1xyXG4gICAgY29uc3QgY3VycmVudENoYXJTdHlsZSA9IGN1cnJlbnRSYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXTtcclxuICAgIGNvbnN0IG5leHRDaGFyU3R5bGUgPSBuZXh0UmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ107XHJcbiAgICBcclxuICAgIC8vIElmIHdlJ3JlIGluIGEgY29udGV4dCB3aGVyZSBzdHlsZXMgY2hhbmdlIHNpZ25pZmljYW50bHksIGFkZCBhIGJyZWFrXHJcbiAgICBpZiAoY3VycmVudENoYXJTdHlsZSAmJiBuZXh0Q2hhclN0eWxlICYmIGN1cnJlbnRDaGFyU3R5bGUgIT09IG5leHRDaGFyU3R5bGUpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBtaWdodCBiZSBhIHRpdGxlL2hlYWRpbmcgZm9sbG93ZWQgYnkgYm9keSB0ZXh0XHJcbiAgICAgIGNvbnN0IHN0eWxlSW5kaWNhdGVzQnJlYWsgPSB0aGlzLnN0eWxlSW5kaWNhdGVzTGluZUJyZWFrKGN1cnJlbnRDaGFyU3R5bGUsIG5leHRDaGFyU3R5bGUpO1xyXG4gICAgICByZXR1cm4gc3R5bGVJbmRpY2F0ZXNCcmVhaztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogQW5hbHl6ZSBpZiBzdHlsZSBjaGFuZ2UgaW5kaWNhdGVzIGEgbGluZSBicmVha1xyXG4gIHN0eWxlSW5kaWNhdGVzTGluZUJyZWFrKGN1cnJlbnRTdHlsZSwgbmV4dFN0eWxlKSB7XHJcbiAgICBjb25zdCB0aXRsZUluZGljYXRvcnMgPSBbJ3RpdGxlJywgJ2hlYWRpbmcnLCAnaGVhZGVyJ107XHJcbiAgICBjb25zdCBib2R5SW5kaWNhdG9ycyA9IFsnYm9keScsICd0ZXh0JywgJ25vcm1hbCddO1xyXG4gICAgXHJcbiAgICBjb25zdCBjdXJyZW50SXNUaXRsZSA9IHRpdGxlSW5kaWNhdG9ycy5zb21lKGluZGljYXRvciA9PiBcclxuICAgICAgY3VycmVudFN0eWxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5kaWNhdG9yKSk7XHJcbiAgICBjb25zdCBuZXh0SXNCb2R5ID0gYm9keUluZGljYXRvcnMuc29tZShpbmRpY2F0b3IgPT4gXHJcbiAgICAgIG5leHRTdHlsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGluZGljYXRvcikpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gY3VycmVudElzVGl0bGUgJiYgbmV4dElzQm9keTtcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEFuYWx5emUgbGluZSBicmVhayB0eXBlcyBpbiBmb3JtYXR0ZWQgY29udGVudFxyXG4gIGFuYWx5emVMaW5lQnJlYWtUeXBlcyhmb3JtYXR0ZWRDb250ZW50KSB7XHJcbiAgICBjb25zdCB0eXBlcyA9IHtcclxuICAgICAgZXhwbGljaXQ6IDAsICAgICAgLy8gRnJvbSA8QnIvPiBlbGVtZW50c1xyXG4gICAgICBpbXBsaWNpdDogMCwgICAgICAvLyBJbmZlcnJlZCBmcm9tIHN0eWxlIGNoYW5nZXNcclxuICAgICAgcGFyYWdyYXBoOiAwLCAgICAgLy8gQmV0d2VlbiBwYXJhZ3JhcGhzXHJcbiAgICAgIGRpcmVjdDogMCAgICAgICAgLy8gRGlyZWN0IEJyIGVsZW1lbnRzXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmb3JtYXR0ZWRDb250ZW50LmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGlmIChpdGVtLmZvcm1hdHRpbmc/LmlzQnJlYWspIHtcclxuICAgICAgICBjb25zdCBicmVha1R5cGUgPSBpdGVtLmZvcm1hdHRpbmcuYnJlYWtUeXBlIHx8ICd1bmtub3duJztcclxuICAgICAgICBpZiAodHlwZXMuaGFzT3duUHJvcGVydHkoYnJlYWtUeXBlKSkge1xyXG4gICAgICAgICAgdHlwZXNbYnJlYWtUeXBlXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB0eXBlcztcclxuICB9XHJcblxyXG4gIGV4dHJhY3REZXRhaWxlZEZvcm1hdHRpbmdGcm9tUmFuZ2UocmFuZ2UpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7fTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBhbGwgcG9zc2libGUgZm9udCBhdHRyaWJ1dGVzXHJcbiAgICBjb25zdCBmb250QXR0cmlidXRlcyA9IFtcclxuICAgICAgJ0BfQXBwbGllZEZvbnQnLCAnQF9Gb250RmFtaWx5JywgJ0BfRm9udCcsIFxyXG4gICAgICAnQF9Qb3N0U2NyaXB0TmFtZScsICdAX0ZvbnROYW1lJ1xyXG4gICAgXTtcclxuICAgIFxyXG4gICAgZm9udEF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHtcclxuICAgICAgaWYgKHJhbmdlW2F0dHJdKSB7XHJcbiAgICAgICAgZm9ybWF0dGluZy5mb250UmVmZXJlbmNlID0gcmFuZ2VbYXR0cl07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGZvbnQgYW5kIHNpemUgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy5mb250U2l6ZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfUG9pbnRTaXplJ10pO1xyXG4gICAgXHJcbiAgICAvLyBFTkhBTkNFRDogRXh0cmFjdCBsZWFkaW5nIHdpdGggcHJvcGVyIHByb2Nlc3NpbmdcclxuICAgIGNvbnN0IHJhd0xlYWRpbmcgPSByYW5nZVsnQF9MZWFkaW5nJ107XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmcgPSB0aGlzLnByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9ybWF0dGluZy5mb250U2l6ZSk7XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmdUeXBlID0gdGhpcy5kZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBjb2xvciBhbmQgc3R5bGUgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy5maWxsQ29sb3IgPSByYW5nZVsnQF9GaWxsQ29sb3InXTtcclxuICAgIGZvcm1hdHRpbmcuc3Ryb2tlQ29sb3IgPSByYW5nZVsnQF9TdHJva2VDb2xvciddO1xyXG4gICAgZm9ybWF0dGluZy5mb250U3R5bGUgPSByYW5nZVsnQF9Gb250U3R5bGUnXTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBhZHZhbmNlZCB0eXBvZ3JhcGh5IGF0dHJpYnV0ZXNcclxuICAgIGZvcm1hdHRpbmcudHJhY2tpbmcgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1RyYWNraW5nJ10pO1xyXG4gICAgZm9ybWF0dGluZy5iYXNlbGluZVNoaWZ0ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9CYXNlbGluZVNoaWZ0J10pO1xyXG4gICAgZm9ybWF0dGluZy5rZXJuaW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9LZXJuaW5nJ10pO1xyXG4gICAgZm9ybWF0dGluZy5ob3Jpem9udGFsU2NhbGUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0hvcml6b250YWxTY2FsZSddKSB8fCAxMDA7XHJcbiAgICBmb3JtYXR0aW5nLnZlcnRpY2FsU2NhbGUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1ZlcnRpY2FsU2NhbGUnXSkgfHwgMTAwO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IHBhcmFncmFwaC1sZXZlbCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcclxuICAgIC8vIENSSVRJQ0FMIEZJWDogT25seSBzZXQgYWxpZ25tZW50IGlmIGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBhbGxvd2luZyBwYXJhZ3JhcGggaW5oZXJpdGFuY2VcclxuICAgIGNvbnN0IGV4cGxpY2l0QWxpZ25tZW50ID0gcmFuZ2VbJ0BfSnVzdGlmaWNhdGlvbiddIHx8IHJhbmdlWydAX0FsaWdubWVudCddO1xyXG4gICAgaWYgKGV4cGxpY2l0QWxpZ25tZW50KSB7XHJcbiAgICAgIGZvcm1hdHRpbmcuYWxpZ25tZW50ID0gZXhwbGljaXRBbGlnbm1lbnQ7XHJcbiAgICB9XHJcbiAgICBmb3JtYXR0aW5nLmxlZnRJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0xlZnRJbmRlbnQnXSk7XHJcbiAgICBmb3JtYXR0aW5nLnJpZ2h0SW5kZW50ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9SaWdodEluZGVudCddKTtcclxuICAgIGZvcm1hdHRpbmcuZmlyc3RMaW5lSW5kZW50ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9GaXJzdExpbmVJbmRlbnQnXSk7XHJcbiAgICBmb3JtYXR0aW5nLnNwYWNlQmVmb3JlID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9TcGFjZUJlZm9yZSddKTtcclxuICAgIGZvcm1hdHRpbmcuc3BhY2VBZnRlciA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfU3BhY2VBZnRlciddKTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBmb3IgQ1NTXHJcbiAgICBmb3JtYXR0aW5nLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoZm9ybWF0dGluZyk7XHJcbiAgICBcclxuICAgIHJldHVybiBmb3JtYXR0aW5nO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBQcm9jZXNzIGxlYWRpbmcgdmFsdWVzIHdpdGggSW5EZXNpZ24tc3BlY2lmaWMgbG9naWNcclxuICBwcm9jZXNzTGVhZGluZ1ZhbHVlKHJhd0xlYWRpbmcsIGZvbnRTaXplKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcpIHJldHVybiAnYXV0byc7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBcImF1dG9cIiBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZyA9PT0gJ2F1dG8nIHx8IHJhd0xlYWRpbmcgPT09ICdBdXRvJykge1xyXG4gICAgICByZXR1cm4gZm9udFNpemUgPyBmb250U2l6ZSAqIDEuMiA6ICdhdXRvJzsgLy8gSW5EZXNpZ24gZGVmYXVsdCBhdXRvIGxlYWRpbmcgaXMgMTIwJVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgbnVtZXJpYyBsZWFkaW5nIChpbiBwb2ludHMpXHJcbiAgICBjb25zdCBudW1lcmljTGVhZGluZyA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmF3TGVhZGluZyk7XHJcbiAgICBpZiAobnVtZXJpY0xlYWRpbmcpIHtcclxuICAgICAgcmV0dXJuIG51bWVyaWNMZWFkaW5nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgcGVyY2VudGFnZS1iYXNlZCBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcygnJScpKSB7XHJcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KHJhd0xlYWRpbmcucmVwbGFjZSgnJScsICcnKSk7XHJcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IChmb250U2l6ZSAqIHBlcmNlbnRhZ2UgLyAxMDApIDogJ2F1dG8nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gJ2F1dG8nO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgbGVhZGluZyBiZWluZyB1c2VkXHJcbiAgZGV0ZXJtaW5lTGVhZGluZ1R5cGUocmF3TGVhZGluZykge1xyXG4gICAgaWYgKCFyYXdMZWFkaW5nIHx8IHJhd0xlYWRpbmcgPT09ICdhdXRvJyB8fCByYXdMZWFkaW5nID09PSAnQXV0bycpIHtcclxuICAgICAgcmV0dXJuICdhdXRvJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoJyUnKSkge1xyXG4gICAgICByZXR1cm4gJ3BlcmNlbnRhZ2UnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYXdMZWFkaW5nKSkge1xyXG4gICAgICByZXR1cm4gJ2Fic29sdXRlJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcblxyXG4gIC8vIE5FVzogQ2FsY3VsYXRlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBmb3IgQ1NTIHJlbmRlcmluZ1xyXG4gIGNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoZm9ybWF0dGluZykge1xyXG4gICAgY29uc3QgZm9udFNpemUgPSBmb3JtYXR0aW5nLmZvbnRTaXplIHx8IDEyO1xyXG4gICAgY29uc3QgbGVhZGluZyA9IGZvcm1hdHRpbmcubGVhZGluZztcclxuICAgIFxyXG4gICAgaWYgKGxlYWRpbmcgPT09ICdhdXRvJykge1xyXG4gICAgICByZXR1cm4gMS4yOyAvLyBDU1MgbGluZS1oZWlnaHQgcmF0aW8gZm9yIGF1dG9cclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHR5cGVvZiBsZWFkaW5nID09PSAnbnVtYmVyJykge1xyXG4gICAgICAvLyBDb252ZXJ0IHBvaW50cyB0byBDU1MgbGluZS1oZWlnaHQgcmF0aW9cclxuICAgICAgcmV0dXJuIGxlYWRpbmcgLyBmb250U2l6ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIDEuMjsgLy8gRmFsbGJhY2tcclxuICB9XHJcblxyXG4gIGV4dHJhY3RUZXh0Rm9ybWF0dGluZyhzdG9yeURhdGEpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7XHJcbiAgICAgIHBhcmFncmFwaFN0eWxlczogW10sXHJcbiAgICAgIGNoYXJhY3RlclN0eWxlczogW10sXHJcbiAgICAgIGFwcGxpZWRTdHlsZXM6IFtdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGFwcGxpZWQgcGFyYWdyYXBoIHN0eWxlc1xyXG4gICAgaWYgKHN0b3J5RGF0YS5QYXJhZ3JhcGhTdHlsZVJhbmdlKSB7XHJcbiAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkoc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2UpID8gc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2UgOiBbc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2VdO1xyXG4gICAgICBcclxuICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFwcGxpZWRTdHlsZSA9IHJhbmdlWydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddO1xyXG4gICAgICAgIGlmIChhcHBsaWVkU3R5bGUgJiYgIWZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVzLmluY2x1ZGVzKGFwcGxpZWRTdHlsZSkpIHtcclxuICAgICAgICAgIGZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVzLnB1c2goYXBwbGllZFN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXh0cmFjdCBjaGFyYWN0ZXIgc3R5bGVzIHdpdGhpbiBwYXJhZ3JhcGggcmFuZ2VzXHJcbiAgICAgICAgaWYgKHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNvbnN0IGNoYXJSYW5nZXMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2UpID8gcmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZSA6IFtyYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlXTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY2hhclJhbmdlcy5mb3JFYWNoKGNoYXJSYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJTdHlsZSA9IGNoYXJSYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXTtcclxuICAgICAgICAgICAgaWYgKGNoYXJTdHlsZSAmJiAhZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZXMuaW5jbHVkZXMoY2hhclN0eWxlKSkge1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVzLnB1c2goY2hhclN0eWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmc7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgdGhpcyBtZXRob2QgdG8gZGVidWcgcmF3IHN0b3J5IGNvbnRlbnRcclxuICBkZWJ1Z1Jhd1N0b3J5Q29udGVudChzdG9yeURhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKCdcXG7wn5SNIFJBVyBTVE9SWSBDT05URU5UIERFQlVHOicpO1xyXG4gICAgY29uc29sZS5sb2coJ1N0b3J5IGtleXM6JywgT2JqZWN0LmtleXMoc3RvcnlEYXRhKSk7XHJcbiAgICBcclxuICAgIGNvbnN0IGZpbmRDaGFyYWN0ZXJSYW5nZXMgPSAob2JqLCBwYXRoID0gJycpID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgaWYgKGtleSA9PT0gJ0NoYXJhY3RlclN0eWxlUmFuZ2UnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBcXG7wn5OdIEZvdW5kIENoYXJhY3RlclN0eWxlUmFuZ2UgYXQgJHtwYXRofTpgLCBvYmpba2V5XSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkob2JqW2tleV0pID8gb2JqW2tleV0gOiBbb2JqW2tleV1dO1xyXG4gICAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgUmFuZ2UgJHtpbmRleCArIDF9IGF0dHJpYnV0ZXM6YCwgXHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyYW5nZSkuZmlsdGVyKGsgPT4gay5zdGFydHNXaXRoKCdAXycpKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgUmFuZ2UgJHtpbmRleCArIDF9IGZvbnQgaW5mbzpgLCB7XHJcbiAgICAgICAgICAgICAgICBBcHBsaWVkRm9udDogcmFuZ2VbJ0BfQXBwbGllZEZvbnQnXSxcclxuICAgICAgICAgICAgICAgIEZvbnRTdHlsZTogcmFuZ2VbJ0BfRm9udFN0eWxlJ10sXHJcbiAgICAgICAgICAgICAgICBQb2ludFNpemU6IHJhbmdlWydAX1BvaW50U2l6ZSddXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGZpbmRDaGFyYWN0ZXJSYW5nZXMob2JqW2tleV0sIGAke3BhdGh9LiR7a2V5fWApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmaW5kQ2hhcmFjdGVyUmFuZ2VzKHN0b3J5RGF0YSk7XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yaWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmllcztcclxuICB9XHJcblxyXG4gIGdldFN0b3J5KHN0b3J5SWQpIHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JpZXNbc3RvcnlJZF07XHJcbiAgfVxyXG5cclxuICBjbGVhclN0b3JpZXMoKSB7XHJcbiAgICB0aGlzLnN0b3JpZXMgPSB7fTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RvcnlQYXJzZXI7ICJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIklETUxVdGlscyIsIlN0b3J5UGFyc2VyIiwicGFyc2VTdG9yeUZpbGUiLCJmaWxlTmFtZSIsImNvbnRlbnQiLCJ4bWxQYXJzZXIiLCJjb25zb2xlIiwibG9nIiwicGFyc2VkIiwicGFyc2UiLCJzdG9yeUlkIiwiYmFzZW5hbWUiLCJzdG9yeURhdGEiLCJTdG9yeSIsIk9iamVjdCIsImtleXMiLCJKU09OIiwic3RyaW5naWZ5Iiwic3Vic3RyaW5nIiwiZGV0YWlsZWRTdG9yeSIsInNlbGYiLCJhcHBsaWVkVE9DU3R5bGUiLCJ1c2VyVGV4dCIsImV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudCIsInRleHRGb3JtYXR0aW5nIiwiZXh0cmFjdFRleHRGb3JtYXR0aW5nIiwiY2xlYW5TdG9yeUlkIiwicmVwbGFjZSIsInN0b3JpZXMiLCJwbGFpblRleHQiLCJsaW5lQnJlYWtJbmZvIiwibGVuZ3RoIiwid29yZENvdW50IiwibGluZUJyZWFrQ291bnQiLCJlcnJvciIsIm1lc3NhZ2UiLCJmb3JtYXR0ZWRDb250ZW50IiwidGV4dENvbG9yIiwiZGVidWdJbmZvIiwiZXh0cmFjdFRleHRSZWN1cnNpdmVseSIsImVsZW1lbnQiLCJkZXB0aCIsImNvbnRleHQiLCJDaGFyYWN0ZXJTdHlsZVJhbmdlIiwicmFuZ2VzIiwiQXJyYXkiLCJpc0FycmF5IiwiYWxsUmFuZ2VDb250ZW50IiwibWFwIiwiciIsIkNvbnRlbnQiLCJqb2luIiwiU3RyaW5nIiwiaW5jbHVkZXMiLCJmb3JFYWNoIiwicmFuZ2UiLCJpbmRleCIsInJhbmdlSW5kZXgiLCJkaXJlY3RGb250UmVmIiwiZm9ybWF0dGluZyIsInBhcmFncmFwaFN0eWxlIiwiYXBwbGllZFN0eWxlIiwiY2hhcmFjdGVyU3R5bGUiLCJmb250U2l6ZSIsInBhcnNlRmxvYXQiLCJmb250UmVmZXJlbmNlIiwiZmlsbENvbG9yIiwiZm9udFN0eWxlIiwiYWxpZ25tZW50IiwicGFyYWdyYXBoQWxpZ25tZW50IiwicmFuZ2VDb250ZW50IiwiaGFzU3R5bGVJbmZvIiwidHJpbSIsInJhd1JhbmdlQXR0cmlidXRlcyIsImZpbHRlciIsImsiLCJzdGFydHNXaXRoIiwiZXh0cmFjdGVkRm9ybWF0dGluZyIsImZvbnRTdHlsZUZyb21YTUwiLCJjaGFyYWN0ZXJTdHlsZUZyb21YTUwiLCJwYXJhZ3JhcGhTdHlsZUZyb21YTUwiLCJyZXNvbHZlZEZvcm1hdHRpbmciLCJzdHlsZVBhcnNlciIsInJlc29sdmVTdHlsZUZvcm1hdHRpbmciLCJjb250ZW50cyIsImNvbnRlbnRJdGVtIiwiY29udGVudEluZGV4IiwidGV4dCIsImRlY29kZVhNTEVudGl0aWVzIiwicHVzaCIsIkJyIiwidW5kZWZpbmVkIiwibGluZUJyZWFrVGV4dCIsImlzQnJlYWsiLCJicmVha1R5cGUiLCJwb3NpdGlvbiIsInNvdXJjZSIsInR5cGUiLCJsb2NhdGlvbiIsImJyRWxlbWVudHMiLCJleHRyYWN0QnJFbGVtZW50cyIsImJySW5mbyIsImJySW5kZXgiLCJkZXRlcm1pbmVMaW5lQnJlYWtUeXBlIiwibmV4dFJhbmdlIiwiY3VycmVudFRleHQiLCJzbGljZSIsImN1cnJlbnRSYW5nZUVuZHNXaXRoU3BhY2UiLCJ0ZXN0IiwibmV4dENvbnRlbnQiLCJuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2UiLCJzaG91bGRTa2lwU3BhY2UiLCJzaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayIsImN1cnJlbnRTdHlsZSIsIm5leHRTdHlsZSIsInNwYWNlVGV4dCIsImlzU3BhY2UiLCJyZWFzb24iLCJjdXJyZW50VGV4dEVuZCIsIm5leHRUZXh0U3RhcnQiLCJpbXBsaWNpdEJyZWFrIiwiUGFyYWdyYXBoU3R5bGVSYW5nZSIsInBhcmFncmFwaENvbnRleHQiLCJwYXJhZ3JhcGhJbmRleCIsInRvdGFsUGFyYWdyYXBocyIsInBhcmFncmFwaEJyZWFrIiwiZm9udEZhbWlseSIsImJyIiwiZW50cmllcyIsImtleSIsInZhbHVlIiwiaXRlbSIsInByb2Nlc3NlZENvbnRlbnQiLCJzb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyIsImluZm8iLCJoYXNMaW5lQnJlYWtzIiwibWF0Y2giLCJsaW5lQnJlYWtUeXBlcyIsImFuYWx5emVMaW5lQnJlYWtUeXBlcyIsInNwYWNlUHJlc2VydmF0aW9uQ291bnQiLCJjb3VudFdvcmRzIiwiY2hhcmFjdGVyQ291bnQiLCJhbmFseXplQ29udGVudFN0cnVjdHVyZSIsInN0cnVjdHVyZSIsImhhc0NvbnRlbnQiLCJoYXNCciIsImNvbnRlbnRJdGVtcyIsInByb2Nlc3NJbnRlcmxlYXZlZENvbnRlbnQiLCJyZXN1bHRzIiwiY3VycmVudFJhbmdlIiwiY3VycmVudENoYXJTdHlsZSIsIm5leHRDaGFyU3R5bGUiLCJzdHlsZUluZGljYXRlc0JyZWFrIiwic3R5bGVJbmRpY2F0ZXNMaW5lQnJlYWsiLCJ0aXRsZUluZGljYXRvcnMiLCJib2R5SW5kaWNhdG9ycyIsImN1cnJlbnRJc1RpdGxlIiwic29tZSIsImluZGljYXRvciIsInRvTG93ZXJDYXNlIiwibmV4dElzQm9keSIsInR5cGVzIiwiZXhwbGljaXQiLCJpbXBsaWNpdCIsInBhcmFncmFwaCIsImRpcmVjdCIsImhhc093blByb3BlcnR5IiwiZXh0cmFjdERldGFpbGVkRm9ybWF0dGluZ0Zyb21SYW5nZSIsImZvbnRBdHRyaWJ1dGVzIiwiYXR0ciIsInBhcnNlTnVtZXJpYyIsInJhd0xlYWRpbmciLCJsZWFkaW5nIiwicHJvY2Vzc0xlYWRpbmdWYWx1ZSIsImxlYWRpbmdUeXBlIiwiZGV0ZXJtaW5lTGVhZGluZ1R5cGUiLCJzdHJva2VDb2xvciIsInRyYWNraW5nIiwiYmFzZWxpbmVTaGlmdCIsImtlcm5pbmciLCJob3Jpem9udGFsU2NhbGUiLCJ2ZXJ0aWNhbFNjYWxlIiwiZXhwbGljaXRBbGlnbm1lbnQiLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJmaXJzdExpbmVJbmRlbnQiLCJzcGFjZUJlZm9yZSIsInNwYWNlQWZ0ZXIiLCJlZmZlY3RpdmVMaW5lSGVpZ2h0IiwiY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodCIsIm51bWVyaWNMZWFkaW5nIiwicGVyY2VudGFnZSIsInBhcmFncmFwaFN0eWxlcyIsImNoYXJhY3RlclN0eWxlcyIsImFwcGxpZWRTdHlsZXMiLCJjaGFyUmFuZ2VzIiwiY2hhclJhbmdlIiwiY2hhclN0eWxlIiwiZGVidWdSYXdTdG9yeUNvbnRlbnQiLCJmaW5kQ2hhcmFjdGVyUmFuZ2VzIiwib2JqIiwiQXBwbGllZEZvbnQiLCJGb250U3R5bGUiLCJQb2ludFNpemUiLCJnZXRTdG9yaWVzIiwiZ2V0U3RvcnkiLCJjbGVhclN0b3JpZXMiLCJjb25zdHJ1Y3RvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/parsers/StoryParser.js\n"));

/***/ })

});