"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StyleParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StyleParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StyleParser {\n    async parseResourceFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCCB Parsing resource: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const resourceName = path.basename(fileName, \".xml\");\n            // Handle different resource types\n            if (fileName.includes(\"Styles.xml\")) {\n                await this.extractStyles(parsed);\n            } else if (fileName.includes(\"Fonts.xml\")) {\n                await this.extractFonts(parsed);\n            } else if (fileName.includes(\"Graphic.xml\")) {\n                await this.extractGraphics(parsed);\n            } else if (fileName.includes(\"Preferences.xml\")) {\n                await this.extractPreferences(parsed);\n            }\n            console.log(\"✅ Resource \".concat(resourceName, \" parsed\"));\n        } catch (error) {\n            console.error(\"❌ Error parsing \".concat(fileName, \":\"), error.message);\n        }\n    }\n    async extractStyles(stylesData) {\n        console.log(\"Extracting styles...\");\n        const styles = stylesData.Styles || stylesData;\n        // Extract Paragraph Styles\n        if (styles.RootParagraphStyleGroup) {\n            this.extractParagraphStyles(styles.RootParagraphStyleGroup);\n        }\n        // Extract Character Styles  \n        if (styles.RootCharacterStyleGroup) {\n            this.extractCharacterStyles(styles.RootCharacterStyleGroup);\n        }\n    }\n    extractParagraphStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.ParagraphStyle) {\n                const styles = Array.isArray(group.ParagraphStyle) ? group.ParagraphStyle : [\n                    group.ParagraphStyle\n                ];\n                styles.forEach((style)=>{\n                    // CRITICAL: Extract font reference from multiple possible locations\n                    const fontRef = this.extractFontFromStyle(style);\n                    // ENHANCED: Process leading with proper InDesign logic\n                    const fontSize = parseFloat(style[\"@_PointSize\"]) || 12;\n                    const rawLeading = style[\"@_Leading\"];\n                    const processedLeading = this.processLeadingValue(rawLeading, fontSize);\n                    this.styles.paragraph[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: fontSize,\n                        leading: processedLeading,\n                        leadingType: this.determineLeadingType(rawLeading),\n                        effectiveLineHeight: this.calculateEffectiveLineHeight(processedLeading, fontSize),\n                        alignment: style[\"@_Justification\"] || \"LeftAlign\",\n                        leftIndent: parseFloat(style[\"@_LeftIndent\"]) || 0,\n                        rightIndent: parseFloat(style[\"@_RightIndent\"]) || 0,\n                        firstLineIndent: parseFloat(style[\"@_FirstLineIndent\"]) || 0,\n                        spaceBefore: parseFloat(style[\"@_SpaceBefore\"]) || 0,\n                        spaceAfter: parseFloat(style[\"@_SpaceAfter\"]) || 0,\n                        // Typography enhancements\n                        tracking: parseFloat(style[\"@_Tracking\"]) || 0,\n                        kerning: parseFloat(style[\"@_Kerning\"]) || 0,\n                        horizontalScale: parseFloat(style[\"@_HorizontalScale\"]) || 100,\n                        verticalScale: parseFloat(style[\"@_VerticalScale\"]) || 100,\n                        // ENHANCED: Use the new extraction method\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || \"Color/Black\",\n                        rawStyle: style\n                    };\n                    console.log(\"✅ Paragraph Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.ParagraphStyleGroup) {\n                const subGroups = Array.isArray(group.ParagraphStyleGroup) ? group.ParagraphStyleGroup : [\n                    group.ParagraphStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    extractFontFromStyle(style) {\n        // Try direct attributes first\n        let fontRef = style[\"@_AppliedFont\"] || style[\"@_FontFamily\"] || style[\"@_Font\"] || \"\";\n        // If not found, try Properties nested structure\n        if (!fontRef && style.Properties) {\n            if (style.Properties.AppliedFont) {\n                fontRef = style.Properties.AppliedFont[\"#text\"] || style.Properties.AppliedFont || \"\";\n            }\n            // Also try other property variations\n            if (!fontRef && style.Properties.FontFamily) {\n                fontRef = style.Properties.FontFamily[\"#text\"] || style.Properties.FontFamily || \"\";\n            }\n        }\n        return fontRef || \"\";\n    }\n    extractCharacterStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.CharacterStyle) {\n                const styles = Array.isArray(group.CharacterStyle) ? group.CharacterStyle : [\n                    group.CharacterStyle\n                ];\n                styles.forEach((style)=>{\n                    const fontRef = this.extractFontFromStyle(style);\n                    this.styles.character[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: parseFloat(style[\"@_PointSize\"]) || null,\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || null,\n                        strokeColor: style[\"@_StrokeColor\"] || null,\n                        rawStyle: style\n                    };\n                    console.log(\"✅ Character Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.CharacterStyleGroup) {\n                const subGroups = Array.isArray(group.CharacterStyleGroup) ? group.CharacterStyleGroup : [\n                    group.CharacterStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    async extractFonts(fontsData) {\n        console.log(\"Extracting fonts with enhanced mapping...\");\n        const fonts = fontsData.Fonts || fontsData;\n        this.resources.fonts = {};\n        this.fontMap = new Map(); // Global font lookup map\n        if (fonts.FontFamily) {\n            const fontFamilies = Array.isArray(fonts.FontFamily) ? fonts.FontFamily : [\n                fonts.FontFamily\n            ];\n            fontFamilies.forEach((family)=>{\n                const familyInfo = {\n                    self: family[\"@_Self\"],\n                    name: family[\"@_Name\"] || \"\",\n                    fonts: []\n                };\n                if (family.Font) {\n                    const fontList = Array.isArray(family.Font) ? family.Font : [\n                        family.Font\n                    ];\n                    fontList.forEach((font)=>{\n                        const fontInfo = {\n                            self: font[\"@_Self\"],\n                            fontFamily: font[\"@_FontFamily\"] || familyInfo.name,\n                            name: font[\"@_Name\"] || \"\",\n                            postScriptName: font[\"@_PostScriptName\"] || \"\",\n                            status: font[\"@_Status\"] || \"Unknown\",\n                            fontStyleName: font[\"@_FontStyleName\"] || \"Regular\"\n                        };\n                        familyInfo.fonts.push(fontInfo);\n                        // Create multiple lookup entries for this font\n                        this.fontMap.set(font[\"@_Self\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_PostScriptName\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_Name\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_FontFamily\"], familyInfo.name);\n                        console.log(\"Font mapping: \".concat(font[\"@_Self\"], \" -> \").concat(familyInfo.name));\n                    });\n                }\n                this.resources.fonts[family[\"@_Self\"]] = familyInfo;\n            });\n        }\n        console.log(\"✅ Fonts extracted: \".concat(Object.keys(this.resources.fonts).length, \" families\"));\n        console.log(\"Font map entries: \".concat(this.fontMap.size));\n    }\n    async extractGraphics(graphicsData) {\n        console.log(\"Extracting graphics and colors...\");\n        const graphics = graphicsData.Graphic || graphicsData;\n        this.resources.colors = {};\n        this.resources.gradients = {};\n        // Extract Colors\n        if (graphics.Color) {\n            const colors = Array.isArray(graphics.Color) ? graphics.Color : [\n                graphics.Color\n            ];\n            colors.forEach((color)=>{\n                this.resources.colors[color[\"@_Self\"]] = {\n                    self: color[\"@_Self\"],\n                    name: color[\"@_Name\"] || \"\",\n                    model: color[\"@_Model\"] || \"Process\",\n                    space: color[\"@_Space\"] || \"CMYK\",\n                    cyan: parseFloat(color[\"@_Cyan\"]) || 0,\n                    magenta: parseFloat(color[\"@_Magenta\"]) || 0,\n                    yellow: parseFloat(color[\"@_Yellow\"]) || 0,\n                    black: parseFloat(color[\"@_Black\"]) || 0,\n                    red: parseFloat(color[\"@_Red\"]) || 0,\n                    green: parseFloat(color[\"@_Green\"]) || 0,\n                    blue: parseFloat(color[\"@_Blue\"]) || 0\n                };\n            });\n        }\n        // Extract Gradients\n        if (graphics.Gradient) {\n            const gradients = Array.isArray(graphics.Gradient) ? graphics.Gradient : [\n                graphics.Gradient\n            ];\n            gradients.forEach((gradient)=>{\n                this.resources.gradients[gradient[\"@_Self\"]] = {\n                    self: gradient[\"@_Self\"],\n                    name: gradient[\"@_Name\"] || \"\",\n                    type: gradient[\"@_Type\"] || \"Linear\",\n                    gradientStops: this.extractGradientStops(gradient)\n                };\n            });\n        }\n    }\n    extractGradientStops(gradient) {\n        const stops = [];\n        if (gradient.GradientStop) {\n            const stopList = Array.isArray(gradient.GradientStop) ? gradient.GradientStop : [\n                gradient.GradientStop\n            ];\n            stopList.forEach((stop)=>{\n                stops.push({\n                    self: stop[\"@_Self\"],\n                    stopColor: stop[\"@_StopColor\"] || \"\",\n                    location: parseFloat(stop[\"@_Location\"]) || 0,\n                    midpoint: parseFloat(stop[\"@_Midpoint\"]) || 50\n                });\n            });\n        }\n        return stops;\n    }\n    async extractPreferences(preferencesData) {\n        console.log(\"Extracting document preferences...\");\n        const prefs = preferencesData.Preferences || preferencesData;\n        // Extract various document preferences\n        this.documentInfo = {\n            preferences: {\n                documentPreferences: this.extractDocumentPrefs(prefs.DocumentPreference),\n                viewPreferences: this.extractViewPrefs(prefs.ViewPreference),\n                guidePreferences: this.extractGuidePrefs(prefs.GuidePreference),\n                gridPreferences: this.extractGridPrefs(prefs.GridPreference),\n                marginPreferences: this.extractMarginPrefs(prefs.MarginPreference),\n                columnPreferences: this.extractColumnPrefs(prefs.ColumnPreference)\n            }\n        };\n    }\n    extractDocumentPrefs(docPref) {\n        if (!docPref) return {};\n        return {\n            pageWidth: parseFloat(docPref[\"@_PageWidth\"]) || 0,\n            pageHeight: parseFloat(docPref[\"@_PageHeight\"]) || 0,\n            left: parseFloat(docPref[\"@_Left\"]) || 0,\n            top: parseFloat(docPref[\"@_Top\"]) || 0,\n            right: parseFloat(docPref[\"@_Right\"]) || 0,\n            bottom: parseFloat(docPref[\"@_Bottom\"]) || 0,\n            columnCount: parseInt(docPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(docPref[\"@_ColumnGutter\"]) || 0,\n            facingPages: docPref[\"@_FacingPages\"] === true,\n            allowPageShuffle: docPref[\"@_AllowPageShuffle\"] !== false,\n            slugBleedType: docPref[\"@_SlugBleedType\"] || \"None\",\n            documentBleedTopOffset: parseFloat(docPref[\"@_DocumentBleedTopOffset\"]) || 0,\n            documentBleedBottomOffset: parseFloat(docPref[\"@_DocumentBleedBottomOffset\"]) || 0,\n            documentBleedInsideOrLeftOffset: parseFloat(docPref[\"@_DocumentBleedInsideOrLeftOffset\"]) || 0,\n            documentBleedOutsideOrRightOffset: parseFloat(docPref[\"@_DocumentBleedOutsideOrRightOffset\"]) || 0\n        };\n    }\n    extractViewPrefs(viewPref) {\n        if (!viewPref) return {};\n        return {\n            horizontalMeasurementUnits: viewPref[\"@_HorizontalMeasurementUnits\"] || \"Points\",\n            verticalMeasurementUnits: viewPref[\"@_VerticalMeasurementUnits\"] || \"Points\",\n            rulerOrigin: viewPref[\"@_RulerOrigin\"] || \"SpreadOrigin\",\n            showRulers: viewPref[\"@_ShowRulers\"] !== false\n        };\n    }\n    extractGuidePrefs(guidePref) {\n        if (!guidePref) return {};\n        return {\n            rulerGuideColor: guidePref[\"@_RulerGuideColor\"] || \"Green\",\n            guidesInBack: guidePref[\"@_GuidesInBack\"] === true,\n            guidesLocked: guidePref[\"@_GuidesLocked\"] === true,\n            guidesShown: guidePref[\"@_GuidesShown\"] !== false,\n            guidesSnapto: guidePref[\"@_GuidesSnapto\"] !== false\n        };\n    }\n    extractGridPrefs(gridPref) {\n        if (!gridPref) return {};\n        return {\n            baselineStart: parseFloat(gridPref[\"@_BaselineStart\"]) || 0,\n            baselineDivision: parseFloat(gridPref[\"@_BaselineDivision\"]) || 12,\n            baselineShown: gridPref[\"@_BaselineShown\"] === true,\n            baselineSnapto: gridPref[\"@_BaselineSnapto\"] === true,\n            documentGridShown: gridPref[\"@_DocumentGridShown\"] === true,\n            documentGridSnapto: gridPref[\"@_DocumentGridSnapto\"] === true\n        };\n    }\n    extractMarginPrefs(marginPref) {\n        if (!marginPref) return {};\n        return {\n            top: parseFloat(marginPref[\"@_Top\"]) || 0,\n            bottom: parseFloat(marginPref[\"@_Bottom\"]) || 0,\n            left: parseFloat(marginPref[\"@_Left\"]) || 0,\n            right: parseFloat(marginPref[\"@_Right\"]) || 0,\n            columnCount: parseInt(marginPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(marginPref[\"@_ColumnGutter\"]) || 0\n        };\n    }\n    extractColumnPrefs(columnPref) {\n        if (!columnPref) return {};\n        return {\n            textColumnCount: parseInt(columnPref[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(columnPref[\"@_TextColumnGutter\"]) || 0\n        };\n    }\n    resolveStyleFormatting(formatting) {\n        const resolved = {\n            ...formatting\n        };\n        // DEBUG: Check if formatting is being applied (generic check)\n        const hasAnyFormatting = formatting.paragraphStyle || formatting.characterStyle || formatting.fontStyle || formatting.fontReference || formatting.fontSize;\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Input:\", {\n                paragraphStyle: formatting.paragraphStyle,\n                characterStyle: formatting.characterStyle,\n                directFontStyle: formatting.fontStyle,\n                directFontRef: formatting.fontReference,\n                directFontSize: formatting.fontSize\n            });\n        }\n        // Resolve paragraph style (base layer)\n        if (formatting.paragraphStyle && this.styles.paragraph[formatting.paragraphStyle]) {\n            const pStyle = this.styles.paragraph[formatting.paragraphStyle];\n            if (!resolved.fontSize && pStyle.pointSize) resolved.fontSize = pStyle.pointSize;\n            if (!resolved.fillColor && pStyle.fillColor) resolved.fillColor = pStyle.fillColor;\n            // CRITICAL FIX: Always inherit paragraph alignment unless explicitly overridden\n            if (pStyle.alignment) resolved.alignment = pStyle.alignment;\n            if (!resolved.fontStyle && pStyle.fontStyle) {\n                resolved.fontStyle = pStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from paragraph style: \"'.concat(pStyle.fontStyle, '\"'));\n                }\n            }\n            // CRITICAL: Resolve font from paragraph style\n            if (!resolved.fontFamily && pStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(pStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from paragraph style: \".concat(pStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n            // Add other paragraph properties with enhanced leading support\n            resolved.leading = pStyle.leading;\n            resolved.leadingType = pStyle.leadingType;\n            resolved.effectiveLineHeight = pStyle.effectiveLineHeight;\n            resolved.leftIndent = pStyle.leftIndent;\n            resolved.rightIndent = pStyle.rightIndent;\n            resolved.firstLineIndent = pStyle.firstLineIndent;\n            resolved.spaceBefore = pStyle.spaceBefore;\n            resolved.spaceAfter = pStyle.spaceAfter;\n            resolved.tracking = pStyle.tracking;\n            resolved.kerning = pStyle.kerning;\n        }\n        // Resolve character style (override layer)\n        if (formatting.characterStyle && this.styles.character[formatting.characterStyle]) {\n            const cStyle = this.styles.character[formatting.characterStyle];\n            if (cStyle.pointSize) resolved.fontSize = cStyle.pointSize;\n            if (cStyle.fillColor) resolved.fillColor = cStyle.fillColor;\n            if (cStyle.fontStyle) {\n                resolved.fontStyle = cStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from character style: \"'.concat(cStyle.fontStyle, '\"'));\n                }\n            }\n            if (cStyle.strokeColor) resolved.strokeColor = cStyle.strokeColor;\n            // Include leading information from character style\n            if (cStyle.leading) resolved.leading = cStyle.leading;\n            if (cStyle.leadingType) resolved.leadingType = cStyle.leadingType;\n            if (cStyle.effectiveLineHeight) resolved.effectiveLineHeight = cStyle.effectiveLineHeight;\n            // CRITICAL: Character style font overrides paragraph style\n            if (cStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(cStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from character style: \".concat(cStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n        }\n        // Apply direct formatting (highest priority)\n        if (formatting.fontReference) {\n            resolved.fontFamily = this.resolveFontReference(formatting.fontReference);\n            if (hasAnyFormatting) {\n                console.log(\"   Font from direct formatting: \".concat(formatting.fontReference, \" -> \").concat(resolved.fontFamily));\n            }\n        }\n        // CRITICAL: Apply direct fontStyle if provided (this might be the issue)\n        if (formatting.fontStyle) {\n            resolved.fontStyle = formatting.fontStyle;\n            if (hasAnyFormatting) {\n                console.log('   FontStyle from direct formatting: \"'.concat(formatting.fontStyle, '\"'));\n            }\n        }\n        // Apply direct leading information (highest priority)\n        if (formatting.leading !== undefined) resolved.leading = formatting.leading;\n        if (formatting.leadingType) resolved.leadingType = formatting.leadingType;\n        if (formatting.effectiveLineHeight) resolved.effectiveLineHeight = formatting.effectiveLineHeight;\n        // Apply other direct formatting attributes\n        if (formatting.fontSize) resolved.fontSize = formatting.fontSize;\n        if (formatting.tracking) resolved.tracking = formatting.tracking;\n        if (formatting.kerning) resolved.kerning = formatting.kerning;\n        // CRITICAL FIX: Apply direct alignment if explicitly specified (overrides paragraph alignment)\n        if (formatting.alignment && formatting.alignment !== \"LeftAlign\") {\n            resolved.alignment = formatting.alignment;\n            if (hasAnyFormatting) {\n                console.log('   Alignment from direct formatting: \"'.concat(formatting.alignment, '\"'));\n            }\n        }\n        // FIXED: Ensure fontStyle defaults to Regular/normal if not set\n        if (!resolved.fontStyle || resolved.fontStyle === \"\") {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log('   FontStyle defaulted to: \"Regular\"');\n            }\n        }\n        // ADDITIONAL FIX: If no styles were applied from any source, ensure clean defaults\n        if (!formatting.paragraphStyle && !formatting.characterStyle && !formatting.fontStyle && !formatting.fontReference) {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log(\"   No source styles found - ensuring clean defaults\");\n            }\n        }\n        // Final fallback\n        if (!resolved.fontFamily || resolved.fontFamily === \"\") {\n            resolved.fontFamily = this.getDefaultFont();\n            if (hasAnyFormatting) {\n                console.log(\"   Using fallback font: \".concat(resolved.fontFamily));\n            }\n        }\n        // Ensure line height is calculated if not explicitly set\n        if (!resolved.effectiveLineHeight && resolved.fontSize && resolved.leading) {\n            resolved.effectiveLineHeight = this.calculateEffectiveLineHeight(resolved.leading, resolved.fontSize);\n        }\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Final Output:\", {\n                fontSize: resolved.fontSize,\n                fontFamily: resolved.fontFamily,\n                fontStyle: resolved.fontStyle,\n                fillColor: resolved.fillColor,\n                leading: resolved.leading,\n                effectiveLineHeight: resolved.effectiveLineHeight\n            });\n        }\n        return resolved;\n    }\n    resolveFontReference(fontRef) {\n        if (!fontRef || fontRef === \"\") {\n            console.log(\"Empty font reference, using fallback\");\n            return this.getDefaultFont();\n        }\n        // Try direct lookup in font map\n        if (this.fontMap && this.fontMap.has(fontRef)) {\n            const resolvedFont = this.fontMap.get(fontRef);\n            console.log('Font resolved: \"'.concat(fontRef, '\" -> \"').concat(resolvedFont, '\"'));\n            return resolvedFont;\n        }\n        // Try partial matching for font families\n        if (this.resources.fonts) {\n            for (const [familyId, familyInfo] of Object.entries(this.resources.fonts)){\n                // Check family name match\n                if (familyInfo.name && (familyInfo.name.toLowerCase().includes(fontRef.toLowerCase()) || fontRef.toLowerCase().includes(familyInfo.name.toLowerCase()))) {\n                    console.log('Font partially matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                    return familyInfo.name;\n                }\n                // Check individual font matches\n                if (familyInfo.fonts) {\n                    for (const font of familyInfo.fonts){\n                        if (font.self === fontRef || font.postScriptName === fontRef || font.name === fontRef) {\n                            console.log('Font exactly matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                            return familyInfo.name;\n                        }\n                    }\n                }\n            }\n        }\n        console.log('Font not found: \"'.concat(fontRef, '\", using fallback'));\n        return this.getDefaultFont() || fontRef;\n    }\n    getDefaultFont() {\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFamily = Object.values(this.resources.fonts)[0];\n            return firstFamily.name || \"Arial\";\n        }\n        return \"Arial\";\n    }\n    inferFontFromContext() {\n        // If we have font definitions but no explicit references, \n        // return the first available font as a fallback\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFontFamily = Object.values(this.resources.fonts)[0];\n            return firstFontFamily.name;\n        }\n        return null;\n    }\n    getStoryStyleSummary(story) {\n        var _story_content_formattedContent, _story_content;\n        const summary = {\n            fontSize: null,\n            fontFamily: null,\n            alignment: null,\n            fillColor: null,\n            fontStyle: null,\n            leading: null,\n            leadingType: null,\n            effectiveLineHeight: null,\n            tracking: null,\n            kerning: null\n        };\n        // Get the most common or first formatting values\n        if (((_story_content = story.content) === null || _story_content === void 0 ? void 0 : (_story_content_formattedContent = _story_content.formattedContent) === null || _story_content_formattedContent === void 0 ? void 0 : _story_content_formattedContent.length) > 0) {\n            const firstFormatted = story.content.formattedContent.find((item)=>item.formatting && !item.formatting.isBreak);\n            if (firstFormatted === null || firstFormatted === void 0 ? void 0 : firstFormatted.formatting) {\n                const fmt = firstFormatted.formatting;\n                summary.fontSize = fmt.fontSize;\n                summary.fontFamily = fmt.fontFamily;\n                summary.alignment = fmt.alignment;\n                summary.fillColor = fmt.fillColor;\n                summary.fontStyle = fmt.fontStyle;\n                summary.leading = fmt.leading;\n                summary.leadingType = fmt.leadingType;\n                summary.effectiveLineHeight = fmt.effectiveLineHeight;\n                summary.tracking = fmt.tracking;\n                summary.kerning = fmt.kerning;\n            }\n        }\n        return summary;\n    }\n    // NEW: Process leading values with InDesign-specific logic (shared with StoryParser)\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = parseFloat(rawLeading);\n        if (!isNaN(numericLeading)) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (!isNaN(parseFloat(rawLeading))) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(leading, fontSize) {\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\" && fontSize) {\n            // Convert points to CSS line-height ratio\n            return Math.max(0.8, leading / fontSize); // Ensure minimum line height\n        }\n        return 1.2; // Fallback\n    }\n    getStyles() {\n        return this.styles;\n    }\n    getResources() {\n        return this.resources;\n    }\n    getFontMap() {\n        return this.fontMap;\n    }\n    constructor(){\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n        this.resources = {\n            fonts: {},\n            colors: {},\n            gradients: {}\n        };\n        this.fontMap = new Map(); // Global font lookup map\n    }\n}\nmodule.exports = StyleParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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L1N0eWxlUGFyc2VyLmpzPzY5YWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3QgSURNTFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvSURNTFV0aWxzJyk7XHJcblxyXG5jbGFzcyBTdHlsZVBhcnNlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnN0eWxlcyA9IHtcclxuICAgICAgcGFyYWdyYXBoOiB7fSxcclxuICAgICAgY2hhcmFjdGVyOiB7fSxcclxuICAgICAgb2JqZWN0OiB7fSxcclxuICAgICAgdGFibGU6IHt9LFxyXG4gICAgICBjZWxsOiB7fVxyXG4gICAgfTtcclxuICAgIHRoaXMucmVzb3VyY2VzID0ge1xyXG4gICAgICBmb250czoge30sXHJcbiAgICAgIGNvbG9yczoge30sXHJcbiAgICAgIGdyYWRpZW50czoge31cclxuICAgIH07XHJcbiAgICB0aGlzLmZvbnRNYXAgPSBuZXcgTWFwKCk7IC8vIEdsb2JhbCBmb250IGxvb2t1cCBtYXBcclxuICB9XHJcblxyXG4gIGFzeW5jIHBhcnNlUmVzb3VyY2VGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OLIFBhcnNpbmcgcmVzb3VyY2U6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcclxuICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlTmFtZSwgJy54bWwnKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgcmVzb3VyY2UgdHlwZXNcclxuICAgICAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKCdTdHlsZXMueG1sJykpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RTdHlsZXMocGFyc2VkKTtcclxuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcygnRm9udHMueG1sJykpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RGb250cyhwYXJzZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKCdHcmFwaGljLnhtbCcpKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0R3JhcGhpY3MocGFyc2VkKTtcclxuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcygnUHJlZmVyZW5jZXMueG1sJykpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RQcmVmZXJlbmNlcyhwYXJzZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFJlc291cmNlICR7cmVzb3VyY2VOYW1lfSBwYXJzZWRgKTtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcGFyc2luZyAke2ZpbGVOYW1lfTpgLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3RTdHlsZXMoc3R5bGVzRGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coJ0V4dHJhY3Rpbmcgc3R5bGVzLi4uJyk7XHJcbiAgICBcclxuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlc0RhdGEuU3R5bGVzIHx8IHN0eWxlc0RhdGE7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgUGFyYWdyYXBoIFN0eWxlc1xyXG4gICAgaWYgKHN0eWxlcy5Sb290UGFyYWdyYXBoU3R5bGVHcm91cCkge1xyXG4gICAgICB0aGlzLmV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMoc3R5bGVzLlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBDaGFyYWN0ZXIgU3R5bGVzICBcclxuICAgIGlmIChzdHlsZXMuUm9vdENoYXJhY3RlclN0eWxlR3JvdXApIHtcclxuICAgICAgdGhpcy5leHRyYWN0Q2hhcmFjdGVyU3R5bGVzKHN0eWxlcy5Sb290Q2hhcmFjdGVyU3R5bGVHcm91cCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRyYWN0UGFyYWdyYXBoU3R5bGVzKHN0eWxlR3JvdXApIHtcclxuICAgIGNvbnN0IGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSA9IChncm91cCkgPT4ge1xyXG4gICAgICBpZiAoZ3JvdXAuUGFyYWdyYXBoU3R5bGUpIHtcclxuICAgICAgICBjb25zdCBzdHlsZXMgPSBBcnJheS5pc0FycmF5KGdyb3VwLlBhcmFncmFwaFN0eWxlKSA/IGdyb3VwLlBhcmFncmFwaFN0eWxlIDogW2dyb3VwLlBhcmFncmFwaFN0eWxlXTtcclxuICAgICAgICBcclxuICAgICAgICBzdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XHJcbiAgICAgICAgICAvLyBDUklUSUNBTDogRXh0cmFjdCBmb250IHJlZmVyZW5jZSBmcm9tIG11bHRpcGxlIHBvc3NpYmxlIGxvY2F0aW9uc1xyXG4gICAgICAgICAgY29uc3QgZm9udFJlZiA9IHRoaXMuZXh0cmFjdEZvbnRGcm9tU3R5bGUoc3R5bGUpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBFTkhBTkNFRDogUHJvY2VzcyBsZWFkaW5nIHdpdGggcHJvcGVyIEluRGVzaWduIGxvZ2ljXHJcbiAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IHBhcnNlRmxvYXQoc3R5bGVbJ0BfUG9pbnRTaXplJ10pIHx8IDEyO1xyXG4gICAgICAgICAgY29uc3QgcmF3TGVhZGluZyA9IHN0eWxlWydAX0xlYWRpbmcnXTtcclxuICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZExlYWRpbmcgPSB0aGlzLnByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9udFNpemUpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICB0aGlzLnN0eWxlcy5wYXJhZ3JhcGhbc3R5bGVbJ0BfU2VsZiddXSA9IHtcclxuICAgICAgICAgICAgc2VsZjogc3R5bGVbJ0BfU2VsZiddLFxyXG4gICAgICAgICAgICBuYW1lOiBzdHlsZVsnQF9OYW1lJ10gfHwgJycsXHJcbiAgICAgICAgICAgIGZvbnRTdHlsZTogc3R5bGVbJ0BfRm9udFN0eWxlJ10gfHwgJ1JlZ3VsYXInLFxyXG4gICAgICAgICAgICBwb2ludFNpemU6IGZvbnRTaXplLFxyXG4gICAgICAgICAgICBsZWFkaW5nOiBwcm9jZXNzZWRMZWFkaW5nLFxyXG4gICAgICAgICAgICBsZWFkaW5nVHlwZTogdGhpcy5kZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSxcclxuICAgICAgICAgICAgZWZmZWN0aXZlTGluZUhlaWdodDogdGhpcy5jYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KHByb2Nlc3NlZExlYWRpbmcsIGZvbnRTaXplKSxcclxuICAgICAgICAgICAgYWxpZ25tZW50OiBzdHlsZVsnQF9KdXN0aWZpY2F0aW9uJ10gfHwgJ0xlZnRBbGlnbicsXHJcbiAgICAgICAgICAgIGxlZnRJbmRlbnQ6IHBhcnNlRmxvYXQoc3R5bGVbJ0BfTGVmdEluZGVudCddKSB8fCAwLFxyXG4gICAgICAgICAgICByaWdodEluZGVudDogcGFyc2VGbG9hdChzdHlsZVsnQF9SaWdodEluZGVudCddKSB8fCAwLFxyXG4gICAgICAgICAgICBmaXJzdExpbmVJbmRlbnQ6IHBhcnNlRmxvYXQoc3R5bGVbJ0BfRmlyc3RMaW5lSW5kZW50J10pIHx8IDAsXHJcbiAgICAgICAgICAgIHNwYWNlQmVmb3JlOiBwYXJzZUZsb2F0KHN0eWxlWydAX1NwYWNlQmVmb3JlJ10pIHx8IDAsXHJcbiAgICAgICAgICAgIHNwYWNlQWZ0ZXI6IHBhcnNlRmxvYXQoc3R5bGVbJ0BfU3BhY2VBZnRlciddKSB8fCAwLFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVHlwb2dyYXBoeSBlbmhhbmNlbWVudHNcclxuICAgICAgICAgICAgdHJhY2tpbmc6IHBhcnNlRmxvYXQoc3R5bGVbJ0BfVHJhY2tpbmcnXSkgfHwgMCxcclxuICAgICAgICAgICAga2VybmluZzogcGFyc2VGbG9hdChzdHlsZVsnQF9LZXJuaW5nJ10pIHx8IDAsXHJcbiAgICAgICAgICAgIGhvcml6b250YWxTY2FsZTogcGFyc2VGbG9hdChzdHlsZVsnQF9Ib3Jpem9udGFsU2NhbGUnXSkgfHwgMTAwLFxyXG4gICAgICAgICAgICB2ZXJ0aWNhbFNjYWxlOiBwYXJzZUZsb2F0KHN0eWxlWydAX1ZlcnRpY2FsU2NhbGUnXSkgfHwgMTAwLFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gRU5IQU5DRUQ6IFVzZSB0aGUgbmV3IGV4dHJhY3Rpb24gbWV0aG9kXHJcbiAgICAgICAgICAgIGFwcGxpZWRGb250OiBmb250UmVmLFxyXG4gICAgICAgICAgICBvcmlnaW5hbEZvbnRSZWY6IGZvbnRSZWYsXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHN0eWxlWydAX0ZpbGxDb2xvciddIHx8ICdDb2xvci9CbGFjaycsXHJcbiAgICAgICAgICAgIHJhd1N0eWxlOiBzdHlsZVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBQYXJhZ3JhcGggU3R5bGU6ICR7c3R5bGVbJ0BfTmFtZSddfSAtPiBGb250OiBcIiR7Zm9udFJlZn1cImApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cCkge1xyXG4gICAgICAgIGNvbnN0IHN1Ykdyb3VwcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cCkgPyBncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwIDogW2dyb3VwLlBhcmFncmFwaFN0eWxlR3JvdXBdO1xyXG4gICAgICAgIHN1Ykdyb3Vwcy5mb3JFYWNoKGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseShzdHlsZUdyb3VwKTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RGb250RnJvbVN0eWxlKHN0eWxlKSB7XHJcbiAgICAvLyBUcnkgZGlyZWN0IGF0dHJpYnV0ZXMgZmlyc3RcclxuICAgIGxldCBmb250UmVmID0gc3R5bGVbJ0BfQXBwbGllZEZvbnQnXSB8fCBcclxuICAgICAgICAgICAgICAgICBzdHlsZVsnQF9Gb250RmFtaWx5J10gfHwgXHJcbiAgICAgICAgICAgICAgICAgc3R5bGVbJ0BfRm9udCddIHx8ICcnO1xyXG4gICAgXHJcbiAgICAvLyBJZiBub3QgZm91bmQsIHRyeSBQcm9wZXJ0aWVzIG5lc3RlZCBzdHJ1Y3R1cmVcclxuICAgIGlmICghZm9udFJlZiAmJiBzdHlsZS5Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgIGlmIChzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250KSB7XHJcbiAgICAgICAgZm9udFJlZiA9IHN0eWxlLlByb3BlcnRpZXMuQXBwbGllZEZvbnRbJyN0ZXh0J10gfHwgXHJcbiAgICAgICAgICAgICAgICAgc3R5bGUuUHJvcGVydGllcy5BcHBsaWVkRm9udCB8fCAnJztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQWxzbyB0cnkgb3RoZXIgcHJvcGVydHkgdmFyaWF0aW9uc1xyXG4gICAgICBpZiAoIWZvbnRSZWYgJiYgc3R5bGUuUHJvcGVydGllcy5Gb250RmFtaWx5KSB7XHJcbiAgICAgICAgZm9udFJlZiA9IHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseVsnI3RleHQnXSB8fCBcclxuICAgICAgICAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkZvbnRGYW1pbHkgfHwgJyc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZvbnRSZWYgfHwgJyc7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0Q2hhcmFjdGVyU3R5bGVzKHN0eWxlR3JvdXApIHtcclxuICAgIGNvbnN0IGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSA9IChncm91cCkgPT4ge1xyXG4gICAgICBpZiAoZ3JvdXAuQ2hhcmFjdGVyU3R5bGUpIHtcclxuICAgICAgICBjb25zdCBzdHlsZXMgPSBBcnJheS5pc0FycmF5KGdyb3VwLkNoYXJhY3RlclN0eWxlKSA/IGdyb3VwLkNoYXJhY3RlclN0eWxlIDogW2dyb3VwLkNoYXJhY3RlclN0eWxlXTtcclxuICAgICAgICBcclxuICAgICAgICBzdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBmb250UmVmID0gdGhpcy5leHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHRoaXMuc3R5bGVzLmNoYXJhY3RlcltzdHlsZVsnQF9TZWxmJ11dID0ge1xyXG4gICAgICAgICAgICBzZWxmOiBzdHlsZVsnQF9TZWxmJ10sXHJcbiAgICAgICAgICAgIG5hbWU6IHN0eWxlWydAX05hbWUnXSB8fCAnJyxcclxuICAgICAgICAgICAgZm9udFN0eWxlOiBzdHlsZVsnQF9Gb250U3R5bGUnXSB8fCAnUmVndWxhcicsXHJcbiAgICAgICAgICAgIHBvaW50U2l6ZTogcGFyc2VGbG9hdChzdHlsZVsnQF9Qb2ludFNpemUnXSkgfHwgbnVsbCxcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGFwcGxpZWRGb250OiBmb250UmVmLFxyXG4gICAgICAgICAgICBvcmlnaW5hbEZvbnRSZWY6IGZvbnRSZWYsXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHN0eWxlWydAX0ZpbGxDb2xvciddIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzdHlsZVsnQF9TdHJva2VDb2xvciddIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHJhd1N0eWxlOiBzdHlsZVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBDaGFyYWN0ZXIgU3R5bGU6ICR7c3R5bGVbJ0BfTmFtZSddfSAtPiBGb250OiBcIiR7Zm9udFJlZn1cImApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZ3JvdXAuQ2hhcmFjdGVyU3R5bGVHcm91cCkge1xyXG4gICAgICAgIGNvbnN0IHN1Ykdyb3VwcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuQ2hhcmFjdGVyU3R5bGVHcm91cCkgPyBncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwIDogW2dyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXBdO1xyXG4gICAgICAgIHN1Ykdyb3Vwcy5mb3JFYWNoKGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseShzdHlsZUdyb3VwKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3RGb250cyhmb250c0RhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0aW5nIGZvbnRzIHdpdGggZW5oYW5jZWQgbWFwcGluZy4uLicpO1xyXG4gICAgXHJcbiAgICBjb25zdCBmb250cyA9IGZvbnRzRGF0YS5Gb250cyB8fCBmb250c0RhdGE7XHJcbiAgICB0aGlzLnJlc291cmNlcy5mb250cyA9IHt9O1xyXG4gICAgdGhpcy5mb250TWFwID0gbmV3IE1hcCgpOyAvLyBHbG9iYWwgZm9udCBsb29rdXAgbWFwXHJcbiAgICBcclxuICAgIGlmIChmb250cy5Gb250RmFtaWx5KSB7XHJcbiAgICAgIGNvbnN0IGZvbnRGYW1pbGllcyA9IEFycmF5LmlzQXJyYXkoZm9udHMuRm9udEZhbWlseSkgPyBmb250cy5Gb250RmFtaWx5IDogW2ZvbnRzLkZvbnRGYW1pbHldO1xyXG4gICAgICBcclxuICAgICAgZm9udEZhbWlsaWVzLmZvckVhY2goZmFtaWx5ID0+IHtcclxuICAgICAgICBjb25zdCBmYW1pbHlJbmZvID0ge1xyXG4gICAgICAgICAgc2VsZjogZmFtaWx5WydAX1NlbGYnXSxcclxuICAgICAgICAgIG5hbWU6IGZhbWlseVsnQF9OYW1lJ10gfHwgJycsXHJcbiAgICAgICAgICBmb250czogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChmYW1pbHkuRm9udCkge1xyXG4gICAgICAgICAgY29uc3QgZm9udExpc3QgPSBBcnJheS5pc0FycmF5KGZhbWlseS5Gb250KSA/IGZhbWlseS5Gb250IDogW2ZhbWlseS5Gb250XTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZm9udExpc3QuZm9yRWFjaChmb250ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZm9udEluZm8gPSB7XHJcbiAgICAgICAgICAgICAgc2VsZjogZm9udFsnQF9TZWxmJ10sXHJcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogZm9udFsnQF9Gb250RmFtaWx5J10gfHwgZmFtaWx5SW5mby5uYW1lLFxyXG4gICAgICAgICAgICAgIG5hbWU6IGZvbnRbJ0BfTmFtZSddIHx8ICcnLFxyXG4gICAgICAgICAgICAgIHBvc3RTY3JpcHROYW1lOiBmb250WydAX1Bvc3RTY3JpcHROYW1lJ10gfHwgJycsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiBmb250WydAX1N0YXR1cyddIHx8ICdVbmtub3duJyxcclxuICAgICAgICAgICAgICBmb250U3R5bGVOYW1lOiBmb250WydAX0ZvbnRTdHlsZU5hbWUnXSB8fCAnUmVndWxhcidcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZhbWlseUluZm8uZm9udHMucHVzaChmb250SW5mbyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgbXVsdGlwbGUgbG9va3VwIGVudHJpZXMgZm9yIHRoaXMgZm9udFxyXG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbJ0BfU2VsZiddLCBmYW1pbHlJbmZvLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbJ0BfUG9zdFNjcmlwdE5hbWUnXSwgZmFtaWx5SW5mby5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250WydAX05hbWUnXSwgZmFtaWx5SW5mby5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250WydAX0ZvbnRGYW1pbHknXSwgZmFtaWx5SW5mby5uYW1lKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb250IG1hcHBpbmc6ICR7Zm9udFsnQF9TZWxmJ119IC0+ICR7ZmFtaWx5SW5mby5uYW1lfWApO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzLmZvbnRzW2ZhbWlseVsnQF9TZWxmJ11dID0gZmFtaWx5SW5mbztcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDinIUgRm9udHMgZXh0cmFjdGVkOiAke09iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGh9IGZhbWlsaWVzYCk7XHJcbiAgICBjb25zb2xlLmxvZyhgRm9udCBtYXAgZW50cmllczogJHt0aGlzLmZvbnRNYXAuc2l6ZX1gKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3RHcmFwaGljcyhncmFwaGljc0RhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0aW5nIGdyYXBoaWNzIGFuZCBjb2xvcnMuLi4nKTtcclxuICAgIFxyXG4gICAgY29uc3QgZ3JhcGhpY3MgPSBncmFwaGljc0RhdGEuR3JhcGhpYyB8fCBncmFwaGljc0RhdGE7XHJcbiAgICB0aGlzLnJlc291cmNlcy5jb2xvcnMgPSB7fTtcclxuICAgIHRoaXMucmVzb3VyY2VzLmdyYWRpZW50cyA9IHt9O1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IENvbG9yc1xyXG4gICAgaWYgKGdyYXBoaWNzLkNvbG9yKSB7XHJcbiAgICAgIGNvbnN0IGNvbG9ycyA9IEFycmF5LmlzQXJyYXkoZ3JhcGhpY3MuQ29sb3IpID8gZ3JhcGhpY3MuQ29sb3IgOiBbZ3JhcGhpY3MuQ29sb3JdO1xyXG4gICAgICBcclxuICAgICAgY29sb3JzLmZvckVhY2goY29sb3IgPT4ge1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzLmNvbG9yc1tjb2xvclsnQF9TZWxmJ11dID0ge1xyXG4gICAgICAgICAgc2VsZjogY29sb3JbJ0BfU2VsZiddLFxyXG4gICAgICAgICAgbmFtZTogY29sb3JbJ0BfTmFtZSddIHx8ICcnLFxyXG4gICAgICAgICAgbW9kZWw6IGNvbG9yWydAX01vZGVsJ10gfHwgJ1Byb2Nlc3MnLFxyXG4gICAgICAgICAgc3BhY2U6IGNvbG9yWydAX1NwYWNlJ10gfHwgJ0NNWUsnLFxyXG4gICAgICAgICAgY3lhbjogcGFyc2VGbG9hdChjb2xvclsnQF9DeWFuJ10pIHx8IDAsXHJcbiAgICAgICAgICBtYWdlbnRhOiBwYXJzZUZsb2F0KGNvbG9yWydAX01hZ2VudGEnXSkgfHwgMCxcclxuICAgICAgICAgIHllbGxvdzogcGFyc2VGbG9hdChjb2xvclsnQF9ZZWxsb3cnXSkgfHwgMCxcclxuICAgICAgICAgIGJsYWNrOiBwYXJzZUZsb2F0KGNvbG9yWydAX0JsYWNrJ10pIHx8IDAsXHJcbiAgICAgICAgICByZWQ6IHBhcnNlRmxvYXQoY29sb3JbJ0BfUmVkJ10pIHx8IDAsXHJcbiAgICAgICAgICBncmVlbjogcGFyc2VGbG9hdChjb2xvclsnQF9HcmVlbiddKSB8fCAwLFxyXG4gICAgICAgICAgYmx1ZTogcGFyc2VGbG9hdChjb2xvclsnQF9CbHVlJ10pIHx8IDBcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBHcmFkaWVudHNcclxuICAgIGlmIChncmFwaGljcy5HcmFkaWVudCkge1xyXG4gICAgICBjb25zdCBncmFkaWVudHMgPSBBcnJheS5pc0FycmF5KGdyYXBoaWNzLkdyYWRpZW50KSA/IGdyYXBoaWNzLkdyYWRpZW50IDogW2dyYXBoaWNzLkdyYWRpZW50XTtcclxuICAgICAgXHJcbiAgICAgIGdyYWRpZW50cy5mb3JFYWNoKGdyYWRpZW50ID0+IHtcclxuICAgICAgICB0aGlzLnJlc291cmNlcy5ncmFkaWVudHNbZ3JhZGllbnRbJ0BfU2VsZiddXSA9IHtcclxuICAgICAgICAgIHNlbGY6IGdyYWRpZW50WydAX1NlbGYnXSxcclxuICAgICAgICAgIG5hbWU6IGdyYWRpZW50WydAX05hbWUnXSB8fCAnJyxcclxuICAgICAgICAgIHR5cGU6IGdyYWRpZW50WydAX1R5cGUnXSB8fCAnTGluZWFyJyxcclxuICAgICAgICAgIGdyYWRpZW50U3RvcHM6IHRoaXMuZXh0cmFjdEdyYWRpZW50U3RvcHMoZ3JhZGllbnQpXHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3JhZGllbnRTdG9wcyhncmFkaWVudCkge1xyXG4gICAgY29uc3Qgc3RvcHMgPSBbXTtcclxuICAgIFxyXG4gICAgaWYgKGdyYWRpZW50LkdyYWRpZW50U3RvcCkge1xyXG4gICAgICBjb25zdCBzdG9wTGlzdCA9IEFycmF5LmlzQXJyYXkoZ3JhZGllbnQuR3JhZGllbnRTdG9wKSA/IGdyYWRpZW50LkdyYWRpZW50U3RvcCA6IFtncmFkaWVudC5HcmFkaWVudFN0b3BdO1xyXG4gICAgICBcclxuICAgICAgc3RvcExpc3QuZm9yRWFjaChzdG9wID0+IHtcclxuICAgICAgICBzdG9wcy5wdXNoKHtcclxuICAgICAgICAgIHNlbGY6IHN0b3BbJ0BfU2VsZiddLFxyXG4gICAgICAgICAgc3RvcENvbG9yOiBzdG9wWydAX1N0b3BDb2xvciddIHx8ICcnLFxyXG4gICAgICAgICAgbG9jYXRpb246IHBhcnNlRmxvYXQoc3RvcFsnQF9Mb2NhdGlvbiddKSB8fCAwLFxyXG4gICAgICAgICAgbWlkcG9pbnQ6IHBhcnNlRmxvYXQoc3RvcFsnQF9NaWRwb2ludCddKSB8fCA1MFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHN0b3BzO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdFByZWZlcmVuY2VzKHByZWZlcmVuY2VzRGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coJ0V4dHJhY3RpbmcgZG9jdW1lbnQgcHJlZmVyZW5jZXMuLi4nKTtcclxuICAgIFxyXG4gICAgY29uc3QgcHJlZnMgPSBwcmVmZXJlbmNlc0RhdGEuUHJlZmVyZW5jZXMgfHwgcHJlZmVyZW5jZXNEYXRhO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IHZhcmlvdXMgZG9jdW1lbnQgcHJlZmVyZW5jZXNcclxuICAgIHRoaXMuZG9jdW1lbnRJbmZvID0ge1xyXG4gICAgICBwcmVmZXJlbmNlczoge1xyXG4gICAgICAgIGRvY3VtZW50UHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdERvY3VtZW50UHJlZnMocHJlZnMuRG9jdW1lbnRQcmVmZXJlbmNlKSxcclxuICAgICAgICB2aWV3UHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdFZpZXdQcmVmcyhwcmVmcy5WaWV3UHJlZmVyZW5jZSksXHJcbiAgICAgICAgZ3VpZGVQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0R3VpZGVQcmVmcyhwcmVmcy5HdWlkZVByZWZlcmVuY2UpLFxyXG4gICAgICAgIGdyaWRQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0R3JpZFByZWZzKHByZWZzLkdyaWRQcmVmZXJlbmNlKSxcclxuICAgICAgICBtYXJnaW5QcmVmZXJlbmNlczogdGhpcy5leHRyYWN0TWFyZ2luUHJlZnMocHJlZnMuTWFyZ2luUHJlZmVyZW5jZSksXHJcbiAgICAgICAgY29sdW1uUHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdENvbHVtblByZWZzKHByZWZzLkNvbHVtblByZWZlcmVuY2UpXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0RG9jdW1lbnRQcmVmcyhkb2NQcmVmKSB7XHJcbiAgICBpZiAoIWRvY1ByZWYpIHJldHVybiB7fTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGFnZVdpZHRoOiBwYXJzZUZsb2F0KGRvY1ByZWZbJ0BfUGFnZVdpZHRoJ10pIHx8IDAsXHJcbiAgICAgIHBhZ2VIZWlnaHQ6IHBhcnNlRmxvYXQoZG9jUHJlZlsnQF9QYWdlSGVpZ2h0J10pIHx8IDAsXHJcbiAgICAgIGxlZnQ6IHBhcnNlRmxvYXQoZG9jUHJlZlsnQF9MZWZ0J10pIHx8IDAsXHJcbiAgICAgIHRvcDogcGFyc2VGbG9hdChkb2NQcmVmWydAX1RvcCddKSB8fCAwLFxyXG4gICAgICByaWdodDogcGFyc2VGbG9hdChkb2NQcmVmWydAX1JpZ2h0J10pIHx8IDAsXHJcbiAgICAgIGJvdHRvbTogcGFyc2VGbG9hdChkb2NQcmVmWydAX0JvdHRvbSddKSB8fCAwLFxyXG4gICAgICBjb2x1bW5Db3VudDogcGFyc2VJbnQoZG9jUHJlZlsnQF9Db2x1bW5Db3VudCddKSB8fCAxLFxyXG4gICAgICBjb2x1bW5HdXR0ZXI6IHBhcnNlRmxvYXQoZG9jUHJlZlsnQF9Db2x1bW5HdXR0ZXInXSkgfHwgMCxcclxuICAgICAgZmFjaW5nUGFnZXM6IGRvY1ByZWZbJ0BfRmFjaW5nUGFnZXMnXSA9PT0gdHJ1ZSxcclxuICAgICAgYWxsb3dQYWdlU2h1ZmZsZTogZG9jUHJlZlsnQF9BbGxvd1BhZ2VTaHVmZmxlJ10gIT09IGZhbHNlLFxyXG4gICAgICBzbHVnQmxlZWRUeXBlOiBkb2NQcmVmWydAX1NsdWdCbGVlZFR5cGUnXSB8fCAnTm9uZScsXHJcbiAgICAgIGRvY3VtZW50QmxlZWRUb3BPZmZzZXQ6IHBhcnNlRmxvYXQoZG9jUHJlZlsnQF9Eb2N1bWVudEJsZWVkVG9wT2Zmc2V0J10pIHx8IDAsXHJcbiAgICAgIGRvY3VtZW50QmxlZWRCb3R0b21PZmZzZXQ6IHBhcnNlRmxvYXQoZG9jUHJlZlsnQF9Eb2N1bWVudEJsZWVkQm90dG9tT2Zmc2V0J10pIHx8IDAsXHJcbiAgICAgIGRvY3VtZW50QmxlZWRJbnNpZGVPckxlZnRPZmZzZXQ6IHBhcnNlRmxvYXQoZG9jUHJlZlsnQF9Eb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0J10pIHx8IDAsXHJcbiAgICAgIGRvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldDogcGFyc2VGbG9hdChkb2NQcmVmWydAX0RvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldCddKSB8fCAwXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFZpZXdQcmVmcyh2aWV3UHJlZikge1xyXG4gICAgaWYgKCF2aWV3UHJlZikgcmV0dXJuIHt9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0czogdmlld1ByZWZbJ0BfSG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHMnXSB8fCAnUG9pbnRzJyxcclxuICAgICAgdmVydGljYWxNZWFzdXJlbWVudFVuaXRzOiB2aWV3UHJlZlsnQF9WZXJ0aWNhbE1lYXN1cmVtZW50VW5pdHMnXSB8fCAnUG9pbnRzJyxcclxuICAgICAgcnVsZXJPcmlnaW46IHZpZXdQcmVmWydAX1J1bGVyT3JpZ2luJ10gfHwgJ1NwcmVhZE9yaWdpbicsXHJcbiAgICAgIHNob3dSdWxlcnM6IHZpZXdQcmVmWydAX1Nob3dSdWxlcnMnXSAhPT0gZmFsc2VcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3VpZGVQcmVmcyhndWlkZVByZWYpIHtcclxuICAgIGlmICghZ3VpZGVQcmVmKSByZXR1cm4ge307XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJ1bGVyR3VpZGVDb2xvcjogZ3VpZGVQcmVmWydAX1J1bGVyR3VpZGVDb2xvciddIHx8ICdHcmVlbicsXHJcbiAgICAgIGd1aWRlc0luQmFjazogZ3VpZGVQcmVmWydAX0d1aWRlc0luQmFjayddID09PSB0cnVlLFxyXG4gICAgICBndWlkZXNMb2NrZWQ6IGd1aWRlUHJlZlsnQF9HdWlkZXNMb2NrZWQnXSA9PT0gdHJ1ZSxcclxuICAgICAgZ3VpZGVzU2hvd246IGd1aWRlUHJlZlsnQF9HdWlkZXNTaG93biddICE9PSBmYWxzZSxcclxuICAgICAgZ3VpZGVzU25hcHRvOiBndWlkZVByZWZbJ0BfR3VpZGVzU25hcHRvJ10gIT09IGZhbHNlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdEdyaWRQcmVmcyhncmlkUHJlZikge1xyXG4gICAgaWYgKCFncmlkUHJlZikgcmV0dXJuIHt9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBiYXNlbGluZVN0YXJ0OiBwYXJzZUZsb2F0KGdyaWRQcmVmWydAX0Jhc2VsaW5lU3RhcnQnXSkgfHwgMCxcclxuICAgICAgYmFzZWxpbmVEaXZpc2lvbjogcGFyc2VGbG9hdChncmlkUHJlZlsnQF9CYXNlbGluZURpdmlzaW9uJ10pIHx8IDEyLFxyXG4gICAgICBiYXNlbGluZVNob3duOiBncmlkUHJlZlsnQF9CYXNlbGluZVNob3duJ10gPT09IHRydWUsXHJcbiAgICAgIGJhc2VsaW5lU25hcHRvOiBncmlkUHJlZlsnQF9CYXNlbGluZVNuYXB0byddID09PSB0cnVlLFxyXG4gICAgICBkb2N1bWVudEdyaWRTaG93bjogZ3JpZFByZWZbJ0BfRG9jdW1lbnRHcmlkU2hvd24nXSA9PT0gdHJ1ZSxcclxuICAgICAgZG9jdW1lbnRHcmlkU25hcHRvOiBncmlkUHJlZlsnQF9Eb2N1bWVudEdyaWRTbmFwdG8nXSA9PT0gdHJ1ZVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RNYXJnaW5QcmVmcyhtYXJnaW5QcmVmKSB7XHJcbiAgICBpZiAoIW1hcmdpblByZWYpIHJldHVybiB7fTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiBwYXJzZUZsb2F0KG1hcmdpblByZWZbJ0BfVG9wJ10pIHx8IDAsXHJcbiAgICAgIGJvdHRvbTogcGFyc2VGbG9hdChtYXJnaW5QcmVmWydAX0JvdHRvbSddKSB8fCAwLFxyXG4gICAgICBsZWZ0OiBwYXJzZUZsb2F0KG1hcmdpblByZWZbJ0BfTGVmdCddKSB8fCAwLFxyXG4gICAgICByaWdodDogcGFyc2VGbG9hdChtYXJnaW5QcmVmWydAX1JpZ2h0J10pIHx8IDAsXHJcbiAgICAgIGNvbHVtbkNvdW50OiBwYXJzZUludChtYXJnaW5QcmVmWydAX0NvbHVtbkNvdW50J10pIHx8IDEsXHJcbiAgICAgIGNvbHVtbkd1dHRlcjogcGFyc2VGbG9hdChtYXJnaW5QcmVmWydAX0NvbHVtbkd1dHRlciddKSB8fCAwXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdENvbHVtblByZWZzKGNvbHVtblByZWYpIHtcclxuICAgIGlmICghY29sdW1uUHJlZikgcmV0dXJuIHt9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0Q29sdW1uQ291bnQ6IHBhcnNlSW50KGNvbHVtblByZWZbJ0BfVGV4dENvbHVtbkNvdW50J10pIHx8IDEsXHJcbiAgICAgIHRleHRDb2x1bW5HdXR0ZXI6IHBhcnNlRmxvYXQoY29sdW1uUHJlZlsnQF9UZXh0Q29sdW1uR3V0dGVyJ10pIHx8IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXNvbHZlU3R5bGVGb3JtYXR0aW5nKGZvcm1hdHRpbmcpIHtcclxuICAgIGNvbnN0IHJlc29sdmVkID0geyAuLi5mb3JtYXR0aW5nIH07XHJcbiAgICBcclxuICAgIC8vIERFQlVHOiBDaGVjayBpZiBmb3JtYXR0aW5nIGlzIGJlaW5nIGFwcGxpZWQgKGdlbmVyaWMgY2hlY2spXHJcbiAgICBjb25zdCBoYXNBbnlGb3JtYXR0aW5nID0gZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSB8fCBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nLmZvbnRTdHlsZSB8fCBmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UgfHwgZm9ybWF0dGluZy5mb250U2l6ZTtcclxuICAgIFxyXG4gICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflKcgU3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyAtIElucHV0OicsIHtcclxuICAgICAgICBwYXJhZ3JhcGhTdHlsZTogZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSxcclxuICAgICAgICBjaGFyYWN0ZXJTdHlsZTogZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZSxcclxuICAgICAgICBkaXJlY3RGb250U3R5bGU6IGZvcm1hdHRpbmcuZm9udFN0eWxlLFxyXG4gICAgICAgIGRpcmVjdEZvbnRSZWY6IGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSxcclxuICAgICAgICBkaXJlY3RGb250U2l6ZTogZm9ybWF0dGluZy5mb250U2l6ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUmVzb2x2ZSBwYXJhZ3JhcGggc3R5bGUgKGJhc2UgbGF5ZXIpXHJcbiAgICBpZiAoZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSAmJiB0aGlzLnN0eWxlcy5wYXJhZ3JhcGhbZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZV0pIHtcclxuICAgICAgY29uc3QgcFN0eWxlID0gdGhpcy5zdHlsZXMucGFyYWdyYXBoW2Zvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVdO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFyZXNvbHZlZC5mb250U2l6ZSAmJiBwU3R5bGUucG9pbnRTaXplKSByZXNvbHZlZC5mb250U2l6ZSA9IHBTdHlsZS5wb2ludFNpemU7XHJcbiAgICAgIGlmICghcmVzb2x2ZWQuZmlsbENvbG9yICYmIHBTdHlsZS5maWxsQ29sb3IpIHJlc29sdmVkLmZpbGxDb2xvciA9IHBTdHlsZS5maWxsQ29sb3I7XHJcbiAgICAgIC8vIENSSVRJQ0FMIEZJWDogQWx3YXlzIGluaGVyaXQgcGFyYWdyYXBoIGFsaWdubWVudCB1bmxlc3MgZXhwbGljaXRseSBvdmVycmlkZGVuXHJcbiAgICAgIGlmIChwU3R5bGUuYWxpZ25tZW50KSByZXNvbHZlZC5hbGlnbm1lbnQgPSBwU3R5bGUuYWxpZ25tZW50O1xyXG4gICAgICBpZiAoIXJlc29sdmVkLmZvbnRTdHlsZSAmJiBwU3R5bGUuZm9udFN0eWxlKSB7XHJcbiAgICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gcFN0eWxlLmZvbnRTdHlsZTtcclxuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIEZvbnRTdHlsZSBmcm9tIHBhcmFncmFwaCBzdHlsZTogXCIke3BTdHlsZS5mb250U3R5bGV9XCJgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIENSSVRJQ0FMOiBSZXNvbHZlIGZvbnQgZnJvbSBwYXJhZ3JhcGggc3R5bGVcclxuICAgICAgaWYgKCFyZXNvbHZlZC5mb250RmFtaWx5ICYmIHBTdHlsZS5hcHBsaWVkRm9udCkge1xyXG4gICAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLnJlc29sdmVGb250UmVmZXJlbmNlKHBTdHlsZS5hcHBsaWVkRm9udCk7XHJcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBGb250IGZyb20gcGFyYWdyYXBoIHN0eWxlOiAke3BTdHlsZS5hcHBsaWVkRm9udH0gLT4gJHtyZXNvbHZlZC5mb250RmFtaWx5fWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQWRkIG90aGVyIHBhcmFncmFwaCBwcm9wZXJ0aWVzIHdpdGggZW5oYW5jZWQgbGVhZGluZyBzdXBwb3J0XHJcbiAgICAgIHJlc29sdmVkLmxlYWRpbmcgPSBwU3R5bGUubGVhZGluZztcclxuICAgICAgcmVzb2x2ZWQubGVhZGluZ1R5cGUgPSBwU3R5bGUubGVhZGluZ1R5cGU7XHJcbiAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSBwU3R5bGUuZWZmZWN0aXZlTGluZUhlaWdodDtcclxuICAgICAgcmVzb2x2ZWQubGVmdEluZGVudCA9IHBTdHlsZS5sZWZ0SW5kZW50O1xyXG4gICAgICByZXNvbHZlZC5yaWdodEluZGVudCA9IHBTdHlsZS5yaWdodEluZGVudDtcclxuICAgICAgcmVzb2x2ZWQuZmlyc3RMaW5lSW5kZW50ID0gcFN0eWxlLmZpcnN0TGluZUluZGVudDtcclxuICAgICAgcmVzb2x2ZWQuc3BhY2VCZWZvcmUgPSBwU3R5bGUuc3BhY2VCZWZvcmU7XHJcbiAgICAgIHJlc29sdmVkLnNwYWNlQWZ0ZXIgPSBwU3R5bGUuc3BhY2VBZnRlcjtcclxuICAgICAgcmVzb2x2ZWQudHJhY2tpbmcgPSBwU3R5bGUudHJhY2tpbmc7XHJcbiAgICAgIHJlc29sdmVkLmtlcm5pbmcgPSBwU3R5bGUua2VybmluZztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUmVzb2x2ZSBjaGFyYWN0ZXIgc3R5bGUgKG92ZXJyaWRlIGxheWVyKVxyXG4gICAgaWYgKGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgJiYgdGhpcy5zdHlsZXMuY2hhcmFjdGVyW2Zvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVdKSB7XHJcbiAgICAgIGNvbnN0IGNTdHlsZSA9IHRoaXMuc3R5bGVzLmNoYXJhY3Rlcltmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlXTtcclxuICAgICAgXHJcbiAgICAgIGlmIChjU3R5bGUucG9pbnRTaXplKSByZXNvbHZlZC5mb250U2l6ZSA9IGNTdHlsZS5wb2ludFNpemU7XHJcbiAgICAgIGlmIChjU3R5bGUuZmlsbENvbG9yKSByZXNvbHZlZC5maWxsQ29sb3IgPSBjU3R5bGUuZmlsbENvbG9yO1xyXG4gICAgICBpZiAoY1N0eWxlLmZvbnRTdHlsZSkge1xyXG4gICAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IGNTdHlsZS5mb250U3R5bGU7XHJcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBGb250U3R5bGUgZnJvbSBjaGFyYWN0ZXIgc3R5bGU6IFwiJHtjU3R5bGUuZm9udFN0eWxlfVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjU3R5bGUuc3Ryb2tlQ29sb3IpIHJlc29sdmVkLnN0cm9rZUNvbG9yID0gY1N0eWxlLnN0cm9rZUNvbG9yO1xyXG4gICAgICBcclxuICAgICAgLy8gSW5jbHVkZSBsZWFkaW5nIGluZm9ybWF0aW9uIGZyb20gY2hhcmFjdGVyIHN0eWxlXHJcbiAgICAgIGlmIChjU3R5bGUubGVhZGluZykgcmVzb2x2ZWQubGVhZGluZyA9IGNTdHlsZS5sZWFkaW5nO1xyXG4gICAgICBpZiAoY1N0eWxlLmxlYWRpbmdUeXBlKSByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IGNTdHlsZS5sZWFkaW5nVHlwZTtcclxuICAgICAgaWYgKGNTdHlsZS5lZmZlY3RpdmVMaW5lSGVpZ2h0KSByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gY1N0eWxlLmVmZmVjdGl2ZUxpbmVIZWlnaHQ7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDUklUSUNBTDogQ2hhcmFjdGVyIHN0eWxlIGZvbnQgb3ZlcnJpZGVzIHBhcmFncmFwaCBzdHlsZVxyXG4gICAgICBpZiAoY1N0eWxlLmFwcGxpZWRGb250KSB7XHJcbiAgICAgICAgcmVzb2x2ZWQuZm9udEZhbWlseSA9IHRoaXMucmVzb2x2ZUZvbnRSZWZlcmVuY2UoY1N0eWxlLmFwcGxpZWRGb250KTtcclxuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIEZvbnQgZnJvbSBjaGFyYWN0ZXIgc3R5bGU6ICR7Y1N0eWxlLmFwcGxpZWRGb250fSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEFwcGx5IGRpcmVjdCBmb3JtYXR0aW5nIChoaWdoZXN0IHByaW9yaXR5KVxyXG4gICAgaWYgKGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSkge1xyXG4gICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UpO1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBGb250IGZyb20gZGlyZWN0IGZvcm1hdHRpbmc6ICR7Zm9ybWF0dGluZy5mb250UmVmZXJlbmNlfSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ1JJVElDQUw6IEFwcGx5IGRpcmVjdCBmb250U3R5bGUgaWYgcHJvdmlkZWQgKHRoaXMgbWlnaHQgYmUgdGhlIGlzc3VlKVxyXG4gICAgaWYgKGZvcm1hdHRpbmcuZm9udFN0eWxlKSB7XHJcbiAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IGZvcm1hdHRpbmcuZm9udFN0eWxlO1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBGb250U3R5bGUgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogXCIke2Zvcm1hdHRpbmcuZm9udFN0eWxlfVwiYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQXBwbHkgZGlyZWN0IGxlYWRpbmcgaW5mb3JtYXRpb24gKGhpZ2hlc3QgcHJpb3JpdHkpXHJcbiAgICBpZiAoZm9ybWF0dGluZy5sZWFkaW5nICE9PSB1bmRlZmluZWQpIHJlc29sdmVkLmxlYWRpbmcgPSBmb3JtYXR0aW5nLmxlYWRpbmc7XHJcbiAgICBpZiAoZm9ybWF0dGluZy5sZWFkaW5nVHlwZSkgcmVzb2x2ZWQubGVhZGluZ1R5cGUgPSBmb3JtYXR0aW5nLmxlYWRpbmdUeXBlO1xyXG4gICAgaWYgKGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodCkgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodDtcclxuICAgIFxyXG4gICAgLy8gQXBwbHkgb3RoZXIgZGlyZWN0IGZvcm1hdHRpbmcgYXR0cmlidXRlc1xyXG4gICAgaWYgKGZvcm1hdHRpbmcuZm9udFNpemUpIHJlc29sdmVkLmZvbnRTaXplID0gZm9ybWF0dGluZy5mb250U2l6ZTtcclxuICAgIGlmIChmb3JtYXR0aW5nLnRyYWNraW5nKSByZXNvbHZlZC50cmFja2luZyA9IGZvcm1hdHRpbmcudHJhY2tpbmc7XHJcbiAgICBpZiAoZm9ybWF0dGluZy5rZXJuaW5nKSByZXNvbHZlZC5rZXJuaW5nID0gZm9ybWF0dGluZy5rZXJuaW5nO1xyXG4gICAgXHJcbiAgICAvLyBDUklUSUNBTCBGSVg6IEFwcGx5IGRpcmVjdCBhbGlnbm1lbnQgaWYgZXhwbGljaXRseSBzcGVjaWZpZWQgKG92ZXJyaWRlcyBwYXJhZ3JhcGggYWxpZ25tZW50KVxyXG4gICAgaWYgKGZvcm1hdHRpbmcuYWxpZ25tZW50ICYmIGZvcm1hdHRpbmcuYWxpZ25tZW50ICE9PSAnTGVmdEFsaWduJykge1xyXG4gICAgICByZXNvbHZlZC5hbGlnbm1lbnQgPSBmb3JtYXR0aW5nLmFsaWdubWVudDtcclxuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgICAgQWxpZ25tZW50IGZyb20gZGlyZWN0IGZvcm1hdHRpbmc6IFwiJHtmb3JtYXR0aW5nLmFsaWdubWVudH1cImApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEZJWEVEOiBFbnN1cmUgZm9udFN0eWxlIGRlZmF1bHRzIHRvIFJlZ3VsYXIvbm9ybWFsIGlmIG5vdCBzZXRcclxuICAgIGlmICghcmVzb2x2ZWQuZm9udFN0eWxlIHx8IHJlc29sdmVkLmZvbnRTdHlsZSA9PT0gJycpIHtcclxuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gJ1JlZ3VsYXInO1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBGb250U3R5bGUgZGVmYXVsdGVkIHRvOiBcIlJlZ3VsYXJcImApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEFERElUSU9OQUwgRklYOiBJZiBubyBzdHlsZXMgd2VyZSBhcHBsaWVkIGZyb20gYW55IHNvdXJjZSwgZW5zdXJlIGNsZWFuIGRlZmF1bHRzXHJcbiAgICBpZiAoIWZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGUgJiYgIWZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgJiYgIWZvcm1hdHRpbmcuZm9udFN0eWxlICYmICFmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UpIHtcclxuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gJ1JlZ3VsYXInO1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBObyBzb3VyY2Ugc3R5bGVzIGZvdW5kIC0gZW5zdXJpbmcgY2xlYW4gZGVmYXVsdHNgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBGaW5hbCBmYWxsYmFja1xyXG4gICAgaWYgKCFyZXNvbHZlZC5mb250RmFtaWx5IHx8IHJlc29sdmVkLmZvbnRGYW1pbHkgPT09ICcnKSB7XHJcbiAgICAgIHJlc29sdmVkLmZvbnRGYW1pbHkgPSB0aGlzLmdldERlZmF1bHRGb250KCk7XHJcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAgIFVzaW5nIGZhbGxiYWNrIGZvbnQ6ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBFbnN1cmUgbGluZSBoZWlnaHQgaXMgY2FsY3VsYXRlZCBpZiBub3QgZXhwbGljaXRseSBzZXRcclxuICAgIGlmICghcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCAmJiByZXNvbHZlZC5mb250U2l6ZSAmJiByZXNvbHZlZC5sZWFkaW5nKSB7XHJcbiAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQocmVzb2x2ZWQubGVhZGluZywgcmVzb2x2ZWQuZm9udFNpemUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UpyBTdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nIC0gRmluYWwgT3V0cHV0OicsIHtcclxuICAgICAgICBmb250U2l6ZTogcmVzb2x2ZWQuZm9udFNpemUsXHJcbiAgICAgICAgZm9udEZhbWlseTogcmVzb2x2ZWQuZm9udEZhbWlseSxcclxuICAgICAgICBmb250U3R5bGU6IHJlc29sdmVkLmZvbnRTdHlsZSxcclxuICAgICAgICBmaWxsQ29sb3I6IHJlc29sdmVkLmZpbGxDb2xvcixcclxuICAgICAgICBsZWFkaW5nOiByZXNvbHZlZC5sZWFkaW5nLFxyXG4gICAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXNvbHZlZDtcclxuICB9XHJcblxyXG4gIHJlc29sdmVGb250UmVmZXJlbmNlKGZvbnRSZWYpIHtcclxuICAgIGlmICghZm9udFJlZiB8fCBmb250UmVmID09PSAnJykge1xyXG4gICAgICBjb25zb2xlLmxvZygnRW1wdHkgZm9udCByZWZlcmVuY2UsIHVzaW5nIGZhbGxiYWNrJyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRGb250KCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFRyeSBkaXJlY3QgbG9va3VwIGluIGZvbnQgbWFwXHJcbiAgICBpZiAodGhpcy5mb250TWFwICYmIHRoaXMuZm9udE1hcC5oYXMoZm9udFJlZikpIHtcclxuICAgICAgY29uc3QgcmVzb2x2ZWRGb250ID0gdGhpcy5mb250TWFwLmdldChmb250UmVmKTtcclxuICAgICAgY29uc29sZS5sb2coYEZvbnQgcmVzb2x2ZWQ6IFwiJHtmb250UmVmfVwiIC0+IFwiJHtyZXNvbHZlZEZvbnR9XCJgKTtcclxuICAgICAgcmV0dXJuIHJlc29sdmVkRm9udDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVHJ5IHBhcnRpYWwgbWF0Y2hpbmcgZm9yIGZvbnQgZmFtaWxpZXNcclxuICAgIGlmICh0aGlzLnJlc291cmNlcy5mb250cykge1xyXG4gICAgICBmb3IgKGNvbnN0IFtmYW1pbHlJZCwgZmFtaWx5SW5mb10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5yZXNvdXJjZXMuZm9udHMpKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgZmFtaWx5IG5hbWUgbWF0Y2hcclxuICAgICAgICBpZiAoZmFtaWx5SW5mby5uYW1lICYmIFxyXG4gICAgICAgICAgICAoZmFtaWx5SW5mby5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZm9udFJlZi50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgZm9udFJlZi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZhbWlseUluZm8ubmFtZS50b0xvd2VyQ2FzZSgpKSkpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb250IHBhcnRpYWxseSBtYXRjaGVkOiBcIiR7Zm9udFJlZn1cIiAtPiBcIiR7ZmFtaWx5SW5mby5uYW1lfVwiYCk7XHJcbiAgICAgICAgICByZXR1cm4gZmFtaWx5SW5mby5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpbmRpdmlkdWFsIGZvbnQgbWF0Y2hlc1xyXG4gICAgICAgIGlmIChmYW1pbHlJbmZvLmZvbnRzKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IGZvbnQgb2YgZmFtaWx5SW5mby5mb250cykge1xyXG4gICAgICAgICAgICBpZiAoZm9udC5zZWxmID09PSBmb250UmVmIHx8IFxyXG4gICAgICAgICAgICAgICAgZm9udC5wb3N0U2NyaXB0TmFtZSA9PT0gZm9udFJlZiB8fCBcclxuICAgICAgICAgICAgICAgIGZvbnQubmFtZSA9PT0gZm9udFJlZikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb250IGV4YWN0bHkgbWF0Y2hlZDogXCIke2ZvbnRSZWZ9XCIgLT4gXCIke2ZhbWlseUluZm8ubmFtZX1cImApO1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYW1pbHlJbmZvLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYEZvbnQgbm90IGZvdW5kOiBcIiR7Zm9udFJlZn1cIiwgdXNpbmcgZmFsbGJhY2tgKTtcclxuICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRGb250KCkgfHwgZm9udFJlZjtcclxuICB9XHJcblxyXG4gIGdldERlZmF1bHRGb250KCkge1xyXG4gICAgaWYgKHRoaXMucmVzb3VyY2VzLmZvbnRzICYmIE9iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGZpcnN0RmFtaWx5ID0gT2JqZWN0LnZhbHVlcyh0aGlzLnJlc291cmNlcy5mb250cylbMF07XHJcbiAgICAgIHJldHVybiBmaXJzdEZhbWlseS5uYW1lIHx8ICdBcmlhbCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ0FyaWFsJztcclxuICB9XHJcblxyXG4gIGluZmVyRm9udEZyb21Db250ZXh0KCkge1xyXG4gICAgLy8gSWYgd2UgaGF2ZSBmb250IGRlZmluaXRpb25zIGJ1dCBubyBleHBsaWNpdCByZWZlcmVuY2VzLCBcclxuICAgIC8vIHJldHVybiB0aGUgZmlyc3QgYXZhaWxhYmxlIGZvbnQgYXMgYSBmYWxsYmFja1xyXG4gICAgaWYgKHRoaXMucmVzb3VyY2VzLmZvbnRzICYmIE9iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGZpcnN0Rm9udEZhbWlseSA9IE9iamVjdC52YWx1ZXModGhpcy5yZXNvdXJjZXMuZm9udHMpWzBdO1xyXG4gICAgICByZXR1cm4gZmlyc3RGb250RmFtaWx5Lm5hbWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGdldFN0b3J5U3R5bGVTdW1tYXJ5KHN0b3J5KSB7XHJcbiAgICBjb25zdCBzdW1tYXJ5ID0ge1xyXG4gICAgICBmb250U2l6ZTogbnVsbCxcclxuICAgICAgZm9udEZhbWlseTogbnVsbCxcclxuICAgICAgYWxpZ25tZW50OiBudWxsLFxyXG4gICAgICBmaWxsQ29sb3I6IG51bGwsXHJcbiAgICAgIGZvbnRTdHlsZTogbnVsbCxcclxuICAgICAgbGVhZGluZzogbnVsbCxcclxuICAgICAgbGVhZGluZ1R5cGU6IG51bGwsXHJcbiAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IG51bGwsXHJcbiAgICAgIHRyYWNraW5nOiBudWxsLFxyXG4gICAgICBrZXJuaW5nOiBudWxsXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBHZXQgdGhlIG1vc3QgY29tbW9uIG9yIGZpcnN0IGZvcm1hdHRpbmcgdmFsdWVzXHJcbiAgICBpZiAoc3RvcnkuY29udGVudD8uZm9ybWF0dGVkQ29udGVudD8ubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaXJzdEZvcm1hdHRlZCA9IHN0b3J5LmNvbnRlbnQuZm9ybWF0dGVkQ29udGVudC5maW5kKGl0ZW0gPT4gXHJcbiAgICAgICAgaXRlbS5mb3JtYXR0aW5nICYmICFpdGVtLmZvcm1hdHRpbmcuaXNCcmVha1xyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgaWYgKGZpcnN0Rm9ybWF0dGVkPy5mb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc3QgZm10ID0gZmlyc3RGb3JtYXR0ZWQuZm9ybWF0dGluZztcclxuICAgICAgICBzdW1tYXJ5LmZvbnRTaXplID0gZm10LmZvbnRTaXplO1xyXG4gICAgICAgIHN1bW1hcnkuZm9udEZhbWlseSA9IGZtdC5mb250RmFtaWx5O1xyXG4gICAgICAgIHN1bW1hcnkuYWxpZ25tZW50ID0gZm10LmFsaWdubWVudDtcclxuICAgICAgICBzdW1tYXJ5LmZpbGxDb2xvciA9IGZtdC5maWxsQ29sb3I7XHJcbiAgICAgICAgc3VtbWFyeS5mb250U3R5bGUgPSBmbXQuZm9udFN0eWxlO1xyXG4gICAgICAgIHN1bW1hcnkubGVhZGluZyA9IGZtdC5sZWFkaW5nO1xyXG4gICAgICAgIHN1bW1hcnkubGVhZGluZ1R5cGUgPSBmbXQubGVhZGluZ1R5cGU7XHJcbiAgICAgICAgc3VtbWFyeS5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gZm10LmVmZmVjdGl2ZUxpbmVIZWlnaHQ7XHJcbiAgICAgICAgc3VtbWFyeS50cmFja2luZyA9IGZtdC50cmFja2luZztcclxuICAgICAgICBzdW1tYXJ5Lmtlcm5pbmcgPSBmbXQua2VybmluZztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gc3VtbWFyeTtcclxuICB9XHJcblxyXG4gIC8vIE5FVzogUHJvY2VzcyBsZWFkaW5nIHZhbHVlcyB3aXRoIEluRGVzaWduLXNwZWNpZmljIGxvZ2ljIChzaGFyZWQgd2l0aCBTdG9yeVBhcnNlcilcclxuICBwcm9jZXNzTGVhZGluZ1ZhbHVlKHJhd0xlYWRpbmcsIGZvbnRTaXplKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcpIHJldHVybiAnYXV0byc7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBcImF1dG9cIiBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZyA9PT0gJ2F1dG8nIHx8IHJhd0xlYWRpbmcgPT09ICdBdXRvJykge1xyXG4gICAgICByZXR1cm4gZm9udFNpemUgPyBmb250U2l6ZSAqIDEuMiA6ICdhdXRvJzsgLy8gSW5EZXNpZ24gZGVmYXVsdCBhdXRvIGxlYWRpbmcgaXMgMTIwJVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgbnVtZXJpYyBsZWFkaW5nIChpbiBwb2ludHMpXHJcbiAgICBjb25zdCBudW1lcmljTGVhZGluZyA9IHBhcnNlRmxvYXQocmF3TGVhZGluZyk7XHJcbiAgICBpZiAoIWlzTmFOKG51bWVyaWNMZWFkaW5nKSkge1xyXG4gICAgICByZXR1cm4gbnVtZXJpY0xlYWRpbmc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBwZXJjZW50YWdlLWJhc2VkIGxlYWRpbmdcclxuICAgIGlmIChyYXdMZWFkaW5nLmluY2x1ZGVzKCclJykpIHtcclxuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQocmF3TGVhZGluZy5yZXBsYWNlKCclJywgJycpKTtcclxuICAgICAgcmV0dXJuIGZvbnRTaXplID8gKGZvbnRTaXplICogcGVyY2VudGFnZSAvIDEwMCkgOiAnYXV0byc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAnYXV0byc7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IERldGVybWluZSB0aGUgdHlwZSBvZiBsZWFkaW5nIGJlaW5nIHVzZWRcclxuICBkZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcgfHwgcmF3TGVhZGluZyA9PT0gJ2F1dG8nIHx8IHJhd0xlYWRpbmcgPT09ICdBdXRvJykge1xyXG4gICAgICByZXR1cm4gJ2F1dG8nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcygnJScpKSB7XHJcbiAgICAgIHJldHVybiAncGVyY2VudGFnZSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdChyYXdMZWFkaW5nKSkpIHtcclxuICAgICAgcmV0dXJuICdhYnNvbHV0ZSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAndW5rbm93bic7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IENhbGN1bGF0ZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgZm9yIENTUyByZW5kZXJpbmdcclxuICBjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KGxlYWRpbmcsIGZvbnRTaXplKSB7XHJcbiAgICBpZiAobGVhZGluZyA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgIHJldHVybiAxLjI7IC8vIENTUyBsaW5lLWhlaWdodCByYXRpbyBmb3IgYXV0b1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodHlwZW9mIGxlYWRpbmcgPT09ICdudW1iZXInICYmIGZvbnRTaXplKSB7XHJcbiAgICAgIC8vIENvbnZlcnQgcG9pbnRzIHRvIENTUyBsaW5lLWhlaWdodCByYXRpb1xyXG4gICAgICByZXR1cm4gTWF0aC5tYXgoMC44LCBsZWFkaW5nIC8gZm9udFNpemUpOyAvLyBFbnN1cmUgbWluaW11bSBsaW5lIGhlaWdodFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gMS4yOyAvLyBGYWxsYmFja1xyXG4gIH1cclxuXHJcbiAgZ2V0U3R5bGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmVzb3VyY2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzO1xyXG4gIH1cclxuXHJcbiAgZ2V0Rm9udE1hcCgpIHtcclxuICAgIHJldHVybiB0aGlzLmZvbnRNYXA7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlUGFyc2VyOyAiXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJJRE1MVXRpbHMiLCJTdHlsZVBhcnNlciIsInBhcnNlUmVzb3VyY2VGaWxlIiwiZmlsZU5hbWUiLCJjb250ZW50IiwieG1sUGFyc2VyIiwiY29uc29sZSIsImxvZyIsInBhcnNlZCIsInBhcnNlIiwicmVzb3VyY2VOYW1lIiwiYmFzZW5hbWUiLCJpbmNsdWRlcyIsImV4dHJhY3RTdHlsZXMiLCJleHRyYWN0Rm9udHMiLCJleHRyYWN0R3JhcGhpY3MiLCJleHRyYWN0UHJlZmVyZW5jZXMiLCJlcnJvciIsIm1lc3NhZ2UiLCJzdHlsZXNEYXRhIiwic3R5bGVzIiwiU3R5bGVzIiwiUm9vdFBhcmFncmFwaFN0eWxlR3JvdXAiLCJleHRyYWN0UGFyYWdyYXBoU3R5bGVzIiwiUm9vdENoYXJhY3RlclN0eWxlR3JvdXAiLCJleHRyYWN0Q2hhcmFjdGVyU3R5bGVzIiwic3R5bGVHcm91cCIsImV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSIsImdyb3VwIiwiUGFyYWdyYXBoU3R5bGUiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwic3R5bGUiLCJmb250UmVmIiwiZXh0cmFjdEZvbnRGcm9tU3R5bGUiLCJmb250U2l6ZSIsInBhcnNlRmxvYXQiLCJyYXdMZWFkaW5nIiwicHJvY2Vzc2VkTGVhZGluZyIsInByb2Nlc3NMZWFkaW5nVmFsdWUiLCJwYXJhZ3JhcGgiLCJzZWxmIiwibmFtZSIsImZvbnRTdHlsZSIsInBvaW50U2l6ZSIsImxlYWRpbmciLCJsZWFkaW5nVHlwZSIsImRldGVybWluZUxlYWRpbmdUeXBlIiwiZWZmZWN0aXZlTGluZUhlaWdodCIsImNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJhbGlnbm1lbnQiLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJmaXJzdExpbmVJbmRlbnQiLCJzcGFjZUJlZm9yZSIsInNwYWNlQWZ0ZXIiLCJ0cmFja2luZyIsImtlcm5pbmciLCJob3Jpem9udGFsU2NhbGUiLCJ2ZXJ0aWNhbFNjYWxlIiwiYXBwbGllZEZvbnQiLCJvcmlnaW5hbEZvbnRSZWYiLCJmaWxsQ29sb3IiLCJyYXdTdHlsZSIsIlBhcmFncmFwaFN0eWxlR3JvdXAiLCJzdWJHcm91cHMiLCJQcm9wZXJ0aWVzIiwiQXBwbGllZEZvbnQiLCJGb250RmFtaWx5IiwiQ2hhcmFjdGVyU3R5bGUiLCJjaGFyYWN0ZXIiLCJzdHJva2VDb2xvciIsIkNoYXJhY3RlclN0eWxlR3JvdXAiLCJmb250c0RhdGEiLCJmb250cyIsIkZvbnRzIiwicmVzb3VyY2VzIiwiZm9udE1hcCIsIk1hcCIsImZvbnRGYW1pbGllcyIsImZhbWlseSIsImZhbWlseUluZm8iLCJGb250IiwiZm9udExpc3QiLCJmb250IiwiZm9udEluZm8iLCJmb250RmFtaWx5IiwicG9zdFNjcmlwdE5hbWUiLCJzdGF0dXMiLCJmb250U3R5bGVOYW1lIiwicHVzaCIsInNldCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzaXplIiwiZ3JhcGhpY3NEYXRhIiwiZ3JhcGhpY3MiLCJHcmFwaGljIiwiY29sb3JzIiwiZ3JhZGllbnRzIiwiQ29sb3IiLCJjb2xvciIsIm1vZGVsIiwic3BhY2UiLCJjeWFuIiwibWFnZW50YSIsInllbGxvdyIsImJsYWNrIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwiR3JhZGllbnQiLCJncmFkaWVudCIsInR5cGUiLCJncmFkaWVudFN0b3BzIiwiZXh0cmFjdEdyYWRpZW50U3RvcHMiLCJzdG9wcyIsIkdyYWRpZW50U3RvcCIsInN0b3BMaXN0Iiwic3RvcCIsInN0b3BDb2xvciIsImxvY2F0aW9uIiwibWlkcG9pbnQiLCJwcmVmZXJlbmNlc0RhdGEiLCJwcmVmcyIsIlByZWZlcmVuY2VzIiwiZG9jdW1lbnRJbmZvIiwicHJlZmVyZW5jZXMiLCJkb2N1bWVudFByZWZlcmVuY2VzIiwiZXh0cmFjdERvY3VtZW50UHJlZnMiLCJEb2N1bWVudFByZWZlcmVuY2UiLCJ2aWV3UHJlZmVyZW5jZXMiLCJleHRyYWN0Vmlld1ByZWZzIiwiVmlld1ByZWZlcmVuY2UiLCJndWlkZVByZWZlcmVuY2VzIiwiZXh0cmFjdEd1aWRlUHJlZnMiLCJHdWlkZVByZWZlcmVuY2UiLCJncmlkUHJlZmVyZW5jZXMiLCJleHRyYWN0R3JpZFByZWZzIiwiR3JpZFByZWZlcmVuY2UiLCJtYXJnaW5QcmVmZXJlbmNlcyIsImV4dHJhY3RNYXJnaW5QcmVmcyIsIk1hcmdpblByZWZlcmVuY2UiLCJjb2x1bW5QcmVmZXJlbmNlcyIsImV4dHJhY3RDb2x1bW5QcmVmcyIsIkNvbHVtblByZWZlcmVuY2UiLCJkb2NQcmVmIiwicGFnZVdpZHRoIiwicGFnZUhlaWdodCIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbHVtbkNvdW50IiwicGFyc2VJbnQiLCJjb2x1bW5HdXR0ZXIiLCJmYWNpbmdQYWdlcyIsImFsbG93UGFnZVNodWZmbGUiLCJzbHVnQmxlZWRUeXBlIiwiZG9jdW1lbnRCbGVlZFRvcE9mZnNldCIsImRvY3VtZW50QmxlZWRCb3R0b21PZmZzZXQiLCJkb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0IiwiZG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0Iiwidmlld1ByZWYiLCJob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cyIsInZlcnRpY2FsTWVhc3VyZW1lbnRVbml0cyIsInJ1bGVyT3JpZ2luIiwic2hvd1J1bGVycyIsImd1aWRlUHJlZiIsInJ1bGVyR3VpZGVDb2xvciIsImd1aWRlc0luQmFjayIsImd1aWRlc0xvY2tlZCIsImd1aWRlc1Nob3duIiwiZ3VpZGVzU25hcHRvIiwiZ3JpZFByZWYiLCJiYXNlbGluZVN0YXJ0IiwiYmFzZWxpbmVEaXZpc2lvbiIsImJhc2VsaW5lU2hvd24iLCJiYXNlbGluZVNuYXB0byIsImRvY3VtZW50R3JpZFNob3duIiwiZG9jdW1lbnRHcmlkU25hcHRvIiwibWFyZ2luUHJlZiIsImNvbHVtblByZWYiLCJ0ZXh0Q29sdW1uQ291bnQiLCJ0ZXh0Q29sdW1uR3V0dGVyIiwicmVzb2x2ZVN0eWxlRm9ybWF0dGluZyIsImZvcm1hdHRpbmciLCJyZXNvbHZlZCIsImhhc0FueUZvcm1hdHRpbmciLCJwYXJhZ3JhcGhTdHlsZSIsImNoYXJhY3RlclN0eWxlIiwiZm9udFJlZmVyZW5jZSIsImRpcmVjdEZvbnRTdHlsZSIsImRpcmVjdEZvbnRSZWYiLCJkaXJlY3RGb250U2l6ZSIsInBTdHlsZSIsInJlc29sdmVGb250UmVmZXJlbmNlIiwiY1N0eWxlIiwidW5kZWZpbmVkIiwiZ2V0RGVmYXVsdEZvbnQiLCJoYXMiLCJyZXNvbHZlZEZvbnQiLCJnZXQiLCJmYW1pbHlJZCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsImZpcnN0RmFtaWx5IiwidmFsdWVzIiwiaW5mZXJGb250RnJvbUNvbnRleHQiLCJmaXJzdEZvbnRGYW1pbHkiLCJnZXRTdG9yeVN0eWxlU3VtbWFyeSIsInN0b3J5Iiwic3VtbWFyeSIsImZvcm1hdHRlZENvbnRlbnQiLCJmaXJzdEZvcm1hdHRlZCIsImZpbmQiLCJpdGVtIiwiaXNCcmVhayIsImZtdCIsIm51bWVyaWNMZWFkaW5nIiwiaXNOYU4iLCJwZXJjZW50YWdlIiwicmVwbGFjZSIsIk1hdGgiLCJtYXgiLCJnZXRTdHlsZXMiLCJnZXRSZXNvdXJjZXMiLCJnZXRGb250TWFwIiwiY29uc3RydWN0b3IiLCJvYmplY3QiLCJ0YWJsZSIsImNlbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/parsers/StyleParser.js\n"));

/***/ })

});