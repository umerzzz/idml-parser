"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/IDMLUtils.js":
/*!********************************!*\
  !*** ./lib/utils/IDMLUtils.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"?82df\");\nclass IDMLUtils {\n    static parseGeometricBounds(boundsString) {\n        console.log(\"DEBUG: boundsString =\", boundsString);\n        if (!boundsString || boundsString === \"undefined\") {\n            console.log(\"Warning: Missing geometric bounds, using defaults\");\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n        const bounds = boundsString.split(\" \").map(parseFloat);\n        const result = {\n            top: bounds[0] || 0,\n            left: bounds[1] || 0,\n            bottom: bounds[2] || 0,\n            right: bounds[3] || 0,\n            width: (bounds[3] || 0) - (bounds[1] || 0),\n            height: (bounds[2] || 0) - (bounds[0] || 0)\n        };\n        console.log(\"Parsed bounds:\", result);\n        return result;\n    }\n    static parseTransform(transformString) {\n        if (!transformString) return {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            tx: 0,\n            ty: 0\n        };\n        const values = transformString.split(\" \").map(parseFloat);\n        return {\n            a: values[0] || 1,\n            b: values[1] || 0,\n            c: values[2] || 0,\n            d: values[3] || 1,\n            tx: values[4] || 0,\n            ty: values[5] || 0\n        };\n    }\n    static calculateRotation(transform) {\n        // Calculate rotation angle from transform matrix\n        return Math.atan2(transform.b, transform.a) * (180 / Math.PI);\n    }\n    static calculateCorners(bounds, transform) {\n        const corners = {\n            topLeft: {\n                x: bounds.left,\n                y: bounds.top\n            },\n            topRight: {\n                x: bounds.right,\n                y: bounds.top\n            },\n            bottomLeft: {\n                x: bounds.left,\n                y: bounds.bottom\n            },\n            bottomRight: {\n                x: bounds.right,\n                y: bounds.bottom\n            }\n        };\n        // Apply transformation to corners\n        Object.keys(corners).forEach((corner)=>{\n            const point = corners[corner];\n            corners[corner] = {\n                x: transform.a * point.x + transform.c * point.y + transform.tx,\n                y: transform.b * point.x + transform.d * point.y + transform.ty\n            };\n        });\n        return corners;\n    }\n    static cmykToRgb(c, m, y, k) {\n        // Convert CMYK percentages (0-100) to RGB (0-255)\n        c = c / 100;\n        m = m / 100;\n        y = y / 100;\n        k = k / 100;\n        const r = Math.round(255 * (1 - c) * (1 - k));\n        const g = Math.round(255 * (1 - m) * (1 - k));\n        const b = Math.round(255 * (1 - y) * (1 - k));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    static parseInDesignColor(colorRef) {\n        if (!colorRef || colorRef === \"Color/None\") return null;\n        // Handle CMYK colors\n        const cmykMatch = colorRef.match(/Color\\/C=(\\d+)\\s*M=(\\d+)\\s*Y=(\\d+)\\s*K=(\\d+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map(Number);\n            const rgb = this.cmykToRgb(c, m, y, k);\n            return \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n        }\n        // Handle RGB colors\n        const rgbMatch = colorRef.match(/Color\\/R=(\\d+)\\s*G=(\\d+)\\s*B=(\\d+)/);\n        if (rgbMatch) {\n            const [, r, g, b] = rgbMatch.map(Number);\n            return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n        }\n        // Standard colors\n        const standardColors = {\n            \"Color/Black\": \"rgb(0, 0, 0)\",\n            \"Color/White\": \"rgb(255, 255, 255)\",\n            \"Color/Red\": \"rgb(255, 0, 0)\",\n            \"Color/Green\": \"rgb(0, 255, 0)\",\n            \"Color/Blue\": \"rgb(0, 0, 255)\",\n            \"Color/Cyan\": \"rgb(0, 255, 255)\",\n            \"Color/Magenta\": \"rgb(255, 0, 255)\",\n            \"Color/Yellow\": \"rgb(255, 255, 0)\",\n            \"Color/Paper\": \"rgb(255, 255, 255)\",\n            \"Color/Registration\": \"rgb(0, 0, 0)\"\n        };\n        return standardColors[colorRef] || null;\n    }\n    static decodeXMLEntities(text) {\n        if (!text) return \"\";\n        return text.replace(/&#x000A;/g, \"\\n\") // Line feed\n        .replace(/&#x000D;/g, \"\\r\") // Carriage return\n        .replace(/&#x0009;/g, \"\t\") // Tab\n        .replace(/&#x00A0;/g, \"\\xa0\") // Non-breaking space\n        .replace(/&#x2028;/g, \"\\n\") // Line separator\n        .replace(/&#x2029;/g, \"\\u2029\") // Paragraph separator\n        .replace(/&#10;/g, \"\\n\") // Decimal line feed\n        .replace(/&#13;/g, \"\\r\") // Decimal carriage return\n        .replace(/&#9;/g, \"\t\") // Decimal tab\n        .replace(/&#160;/g, \"\\xa0\") // Decimal non-breaking space\n        .replace(/&lt;/g, \"<\") // Less than\n        .replace(/&gt;/g, \">\") // Greater than\n        .replace(/&amp;/g, \"&\") // Ampersand (must be last)\n        .replace(/&quot;/g, '\"') // Quote\n        .replace(/&apos;/g, \"'\"); // Apostrophe\n    }\n    static cleanTextContent(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\t/g, \"    \") // Convert tabs to spaces\n        .replace(/\\u00A0/g, \" \") // Convert non-breaking spaces\n        .replace(/ +/g, \" \") // Collapse multiple spaces\n        // REMOVED: .replace(/\\n{3,}/g, '\\n\\n')  // Allow unlimited consecutive line breaks\n        .trim();\n    }\n    static preserveLineBreaks(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\"); // Convert paragraph separators\n    // REMOVED: .replace(/\\n{3,}/g, '\\n\\n'); // Allow unlimited consecutive line breaks\n    }\n    // NEW: Clean up excessive line breaks to prevent text overflow\n    static cleanTextForRendering(text) {\n        if (!text) return \"\";\n        return text// Normalize line endings\n        .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\")// Remove trailing whitespace on each line only\n        .replace(/[ \\t]+\\n/g, \"\\n\");\n    // DO NOT collapse multiple spaces, tabs, or newlines\n    // DO NOT trim the whole string\n    }\n    // ENHANCED: Better line break processing that preserves word spaces\n    static sophisticatedLineBreakProcessing(content) {\n        if (!content) return \"\";\n        // DEBUG: Track if problematic text is being processed\n        const hasProblematicText = content.includes(\"pavoluptusda\") || content.includes(\"pa\") && content.includes(\"voluptusda\");\n        if (hasProblematicText) {\n            console.log(\"\\uD83D\\uDD27 IDMLUtils.sophisticatedLineBreakProcessing:\");\n            console.log(\"   - Input:\", JSON.stringify(content));\n        }\n        // First clean up the content but preserve word spaces\n        let processed = this.cleanTextForRendering(content);\n        if (hasProblematicText) {\n            console.log(\"   - After cleanTextForRendering:\", JSON.stringify(processed));\n        }\n        // Normalize line breaks but don't touch word spaces\n        // processed = processed\n        //   .replace(/\\r\\n/g, '\\n')      // Normalize Windows line breaks\n        //   .replace(/\\r/g, '\\n')        // Normalize old Mac line breaks\n        //   .replace(/\\u2029/g, '\\n')    // Convert line separators\n        //   .replace(/\\u2028/g, '\\n\\n')  // Convert paragraph separators to double breaks\n        //   .replace(/\\u000A/g, '\\n');   // Convert explicit line feed characters\n        // Ensure paragraph breaks are properly spaced\n        // processed = processed.replace(/\\n\\n+/g, '\\n\\n'); // REMOVE THIS LINE to preserve all consecutive newlines\n        return processed;\n    }\n    static countWords(text) {\n        return text.split(/\\s+/).filter((word)=>word.length > 0).length;\n    }\n    static parseNumeric(value) {\n        if (value === null || value === undefined || value === \"\") return null;\n        const num = parseFloat(value);\n        return isNaN(num) ? null : num;\n    }\n    static isImageFile(fileName) {\n        const imageExtensions = [\n            \".jpg\",\n            \".jpeg\",\n            \".png\",\n            \".gif\",\n            \".tiff\",\n            \".tif\",\n            \".bmp\",\n            \".svg\",\n            \".eps\",\n            \".ai\",\n            \".psd\",\n            \".webp\",\n            \".ico\",\n            \".jfif\",\n            \".jp2\",\n            \".jpx\"\n        ];\n        return imageExtensions.some((ext)=>fileName.toLowerCase().endsWith(ext));\n    }\n    static getImageExtension(imageTypeName) {\n        const typeMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return typeMap[imageTypeName] || \"jpg\";\n    }\n    static getImageExtensionFromFormat(format) {\n        const formatMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return formatMap[format] || \"jpg\";\n    }\n    static extractImageNameFromLink(linkUri) {\n        if (!linkUri) return null;\n        // Extract filename from path like \"file:C:/Users/lalo/Downloads/Tesla-Model-3.jpg 13325 \"\n        const match = linkUri.match(/([^\\/\\\\]+)\\.[^.]+$/);\n        return match ? match[1] : null;\n    }\n    static calculateCoordinateOffset(elements) {\n        if (!elements || elements.length === 0) {\n            console.log(\"\\uD83D\\uDEAB No elements provided for coordinate offset calculation\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        let minX = Infinity, minY = Infinity;\n        let maxStrokeWidth = 0;\n        let validElements = 0;\n        console.log(\"\\uD83D\\uDD0D ANALYZING \".concat(elements.length, \" elements for coordinate offset...\"));\n        // First pass: find TRUE minimum coordinates across all elements\n        elements.forEach((element, index)=>{\n            const bounds = element.geometricBounds || element.originalBounds;\n            const transform = element.itemTransform || {\n                tx: 0,\n                ty: 0\n            };\n            if (bounds && (bounds.left !== undefined || bounds.top !== undefined)) {\n                // Calculate final position after transform\n                const finalX = (bounds.left || 0) + (transform.tx || 0);\n                const finalY = (bounds.top || 0) + (transform.ty || 0);\n                console.log(\"   Element \".concat(index, \": bounds(\").concat(bounds.left, \", \").concat(bounds.top, \") + transform(\").concat(transform.tx, \", \").concat(transform.ty, \") = final(\").concat(finalX, \", \").concat(finalY, \")\"));\n                minX = Math.min(minX, finalX);\n                minY = Math.min(minY, finalY);\n                validElements++;\n                // Track maximum stroke width for intelligent padding\n                const strokeWidth = element.strokeWeight || 0;\n                maxStrokeWidth = Math.max(maxStrokeWidth, strokeWidth);\n            } else {\n                console.log(\"   Element \".concat(index, \": No valid bounds - skipping\"));\n            }\n        });\n        // Handle case where no valid elements found\n        if (validElements === 0) {\n            console.log(\"⚠️  No valid elements with bounds found - using zero offset\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        // Reset infinite values to 0 if no valid coordinates found\n        if (minX === Infinity) minX = 0;\n        if (minY === Infinity) minY = 0;\n        console.log(\"\\uD83D\\uDCCA ANALYSIS COMPLETE: minX=\".concat(minX, \", minY=\").concat(minY, \", maxStroke=\").concat(maxStrokeWidth, \"px, validElements=\").concat(validElements));\n        // ZERO-BASED OFFSET CALCULATION:\n        // The goal is to have NO OFFSET unless absolutely necessary for negative coordinates\n        let offsetX = 0;\n        let offsetY = 0;\n        // Only add offset if coordinates are actually negative\n        if (minX < 0) {\n            offsetX = Math.abs(minX);\n            console.log(\"❌ Negative X detected: \".concat(minX, \" → adding offset: \").concat(offsetX));\n        }\n        if (minY < 0) {\n            offsetY = Math.abs(minY);\n            console.log(\"❌ Negative Y detected: \".concat(minY, \" → adding offset: \").concat(offsetY));\n        }\n        // Add minimal stroke padding only if we already have an offset\n        if ((offsetX > 0 || offsetY > 0) && maxStrokeWidth > 0) {\n            const strokePadding = Math.ceil(maxStrokeWidth / 2);\n            if (offsetX > 0) offsetX += strokePadding;\n            if (offsetY > 0) offsetY += strokePadding;\n            console.log(\"\\uD83D\\uDD8C️ Added stroke padding: \".concat(strokePadding, \"px\"));\n        }\n        console.log(\"\\uD83C\\uDFAF FINAL OFFSET: X=\".concat(offsetX, \", Y=\").concat(offsetY));\n        console.log(\"   \".concat(offsetX === 0 ? \"✅ Perfect! No X offset needed\" : \"⚠️ X offset: \".concat(offsetX, \"px (\").concat(minX, \" was negative)\")));\n        console.log(\"   \".concat(offsetY === 0 ? \"✅ Perfect! No Y offset needed\" : \"⚠️ Y offset: \".concat(offsetY, \"px (\").concat(minY, \" was negative)\")));\n        return {\n            x: offsetX,\n            y: offsetY\n        };\n    }\n    /**\r\n   * Calculate precise coordinate offset for pixel-perfect InDesign coordinate system transformation\r\n   * This ensures accurate positioning similar to professional tools like IMG.LY InDesign\r\n   * @param {Array} elements - Array of elements with bounds and transforms\r\n   * @returns {Object} - {x, y} offset for coordinate transformation\r\n   */ static calculateCoordinateOffsetPrecise(elements) {\n        if (!elements || elements.length === 0) {\n            console.warn(\"\\uD83C\\uDFAF No elements provided for coordinate offset calculation\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        console.log(\"\\uD83D\\uDD0D ANALYZING\", elements.length, \"elements for PRECISE coordinate offset...\");\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxStroke = 0;\n        let validElements = 0;\n        elements.forEach((element, index)=>{\n            if (!element.geometricBounds || !element.itemTransform) {\n                console.warn(\"   ⚠️ Element \".concat(index, \" missing bounds/transform - skipping\"));\n                return;\n            }\n            // Calculate final position (bounds + transform)\n            const finalX = element.geometricBounds.left + element.itemTransform.tx;\n            const finalY = element.geometricBounds.top + element.itemTransform.ty;\n            // Track stroke width for precise positioning\n            const strokeWidth = element.strokeWeight || 0;\n            maxStroke = Math.max(maxStroke, strokeWidth);\n            console.log(\"   Element \".concat(index, \": bounds(\").concat(element.geometricBounds.left, \", \").concat(element.geometricBounds.top, \") + transform(\").concat(element.itemTransform.tx, \", \").concat(element.itemTransform.ty, \") = final(\").concat(finalX, \", \").concat(finalY, \")\"));\n            minX = Math.min(minX, finalX);\n            minY = Math.min(minY, finalY);\n            validElements++;\n        });\n        console.log(\"\\uD83D\\uDCCA ANALYSIS COMPLETE:\", \"minX=\".concat(minX, \", minY=\").concat(minY, \", maxStroke=\").concat(maxStroke, \"px, validElements=\").concat(validElements));\n        // FIXED: Only add offset if coordinates are actually negative\n        // Don't force elements to start at origin - preserve InDesign positioning\n        let offsetX = 0;\n        let offsetY = 0;\n        // Only handle negative coordinates that would be clipped by the browser\n        if (minX < 0) {\n            offsetX = Math.abs(minX) + maxStroke;\n            console.log(\"❌ Negative X detected: \".concat(minX, \" → adding offset: \").concat(offsetX));\n        } else {\n            console.log(\"✅ Positive X coordinates: \".concat(minX, \" → no offset needed\"));\n        }\n        if (minY < 0) {\n            offsetY = Math.abs(minY) + maxStroke;\n            console.log(\"❌ Negative Y detected: \".concat(minY, \" → adding offset: \").concat(offsetY));\n        } else {\n            console.log(\"✅ Positive Y coordinates: \".concat(minY, \" → no offset needed\"));\n        }\n        const finalOffset = {\n            x: offsetX,\n            y: offsetY\n        };\n        console.log(\"\\uD83C\\uDFAF FINAL PRECISE OFFSET:\", \"X=\".concat(offsetX, \", Y=\").concat(offsetY));\n        console.log(\"   \".concat(offsetX === 0 ? \"✅ Perfect! No X offset needed\" : \"⚠️ X offset: \".concat(offsetX, \"px (compensating for negative coordinates)\")));\n        console.log(\"   \".concat(offsetY === 0 ? \"✅ Perfect! No Y offset needed\" : \"⚠️ Y offset: \".concat(offsetY, \"px (compensating for negative coordinates)\")));\n        return finalOffset;\n    }\n    static calculateBoundsFromPath(item) {\n        try {\n            var _item_Properties_PathGeometry_GeometryPathType_PathPointArray, _item_Properties_PathGeometry_GeometryPathType, _item_Properties_PathGeometry, _item_Properties;\n            // First try to get bounds from GeometricBounds attribute\n            if (item[\"@_GeometricBounds\"]) {\n                return this.parseGeometricBounds(item[\"@_GeometricBounds\"]);\n            }\n            // Then try path geometry\n            const pathGeometry = item === null || item === void 0 ? void 0 : (_item_Properties = item.Properties) === null || _item_Properties === void 0 ? void 0 : (_item_Properties_PathGeometry = _item_Properties.PathGeometry) === null || _item_Properties_PathGeometry === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType = _item_Properties_PathGeometry.GeometryPathType) === null || _item_Properties_PathGeometry_GeometryPathType === void 0 ? void 0 : (_item_Properties_PathGeometry_GeometryPathType_PathPointArray = _item_Properties_PathGeometry_GeometryPathType.PathPointArray) === null || _item_Properties_PathGeometry_GeometryPathType_PathPointArray === void 0 ? void 0 : _item_Properties_PathGeometry_GeometryPathType_PathPointArray.PathPointType;\n            if (!pathGeometry || !Array.isArray(pathGeometry)) {\n                console.log(\"Warning: No geometry found for \".concat(item[\"@_Self\"], \", using item transform\"));\n                // Fallback to item transform if available\n                const transform = this.parseTransform(item[\"@_ItemTransform\"]);\n                return {\n                    top: transform.ty || 0,\n                    left: transform.tx || 0,\n                    bottom: (transform.ty || 0) + 100,\n                    right: (transform.tx || 0) + 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n            pathGeometry.forEach((point)=>{\n                const anchor = point[\"@_Anchor\"];\n                if (anchor) {\n                    const [x, y] = anchor.split(\" \").map(parseFloat);\n                    if (!isNaN(x) && !isNaN(y)) {\n                        minX = Math.min(minX, x);\n                        maxX = Math.max(maxX, x);\n                        minY = Math.min(minY, y);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            });\n            if (minX === Infinity || minY === Infinity) {\n                console.log(\"Warning: Could not calculate bounds for \".concat(item[\"@_Self\"]));\n                return {\n                    top: 0,\n                    left: 0,\n                    bottom: 100,\n                    right: 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            return {\n                top: minY,\n                left: minX,\n                bottom: maxY,\n                right: maxX,\n                width: maxX - minX,\n                height: maxY - minY\n            };\n        } catch (error) {\n            console.error(\"Error calculating bounds for \".concat(item[\"@_Self\"], \":\"), error);\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n    }\n    static calculateRelativePosition(frameBounds, contentBounds, frameTransform, contentTransform) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            offsetX: (contentBounds.left || 0) - (frameBounds.left || 0),\n            offsetY: (contentBounds.top || 0) - (frameBounds.top || 0),\n            scaleX: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.a) || 1,\n            scaleY: (contentTransform === null || contentTransform === void 0 ? void 0 : contentTransform.d) || 1,\n            transformDifference: {\n                frame: frameTransform,\n                content: contentTransform\n            }\n        };\n    }\n    static calculateGap(frameBounds, contentBounds) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            top: (contentBounds.top || 0) - (frameBounds.top || 0),\n            left: (contentBounds.left || 0) - (frameBounds.left || 0),\n            bottom: (frameBounds.bottom || 0) - (contentBounds.bottom || 0),\n            right: (frameBounds.right || 0) - (contentBounds.right || 0)\n        };\n    }\n    static calculateImagePositionInFrame(frameBounds, frameTransform, placedContent) {\n        if (!frameBounds || !(placedContent === null || placedContent === void 0 ? void 0 : placedContent.transform)) {\n            return null;\n        }\n        const imageTransform = placedContent.transform;\n        // Calculate image position relative to frame\n        const imageX = (frameBounds.left || 0) + (imageTransform.tx || 0);\n        const imageY = (frameBounds.top || 0) + (imageTransform.ty || 0);\n        // Calculate image size with scaling\n        const imageWidth = (frameBounds.width || 0) * (imageTransform.a || 1);\n        const imageHeight = (frameBounds.height || 0) * (imageTransform.d || 1);\n        return {\n            x: imageX,\n            y: imageY,\n            width: imageWidth,\n            height: imageHeight,\n            scaleX: imageTransform.a || 1,\n            scaleY: imageTransform.d || 1\n        };\n    }\n    static getXMLStructure(obj) {\n        let maxDepth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        if (currentDepth >= maxDepth || typeof obj !== \"object\" || obj === null) {\n            return typeof obj;\n        }\n        const structure = {};\n        Object.keys(obj).forEach((key)=>{\n            if (Array.isArray(obj[key])) {\n                structure[key] = \"Array[\".concat(obj[key].length, \"]\");\n            } else if (typeof obj[key] === \"object\" && obj[key] !== null) {\n                structure[key] = this.getXMLStructure(obj[key], maxDepth, currentDepth + 1);\n            } else {\n                structure[key] = typeof obj[key];\n            }\n        });\n        return structure;\n    }\n    static isFormattingAttribute(attributeName) {\n        const formattingAttributes = [\n            \"@_PointSize\",\n            \"@_Leading\",\n            \"@_Tracking\",\n            \"@_FontStyle\",\n            \"@_AppliedFont\",\n            \"@_FillColor\",\n            \"@_StrokeColor\",\n            \"@_Justification\",\n            \"@_LeftIndent\",\n            \"@_RightIndent\",\n            \"@_FirstLineIndent\",\n            \"@_SpaceBefore\",\n            \"@_SpaceAfter\",\n            \"@_Alignment\"\n        ];\n        return formattingAttributes.includes(attributeName);\n    }\n    static saveDebugInfo(debugInfo, fileName) {\n        try {\n            fs.writeFileSync(fileName, JSON.stringify(debugInfo, null, 2));\n            console.log(\"✅ Debug info saved to \".concat(fileName));\n        } catch (error) {\n            console.error(\"❌ Error saving debug info:\", error);\n            console.log(\"Debug info (first 2000 chars):\", JSON.stringify(debugInfo, null, 2).substring(0, 2000));\n        }\n    }\n}\nmodule.exports = IDMLUtils;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cUJBQXFCOUYsUUFBUSxDQUFDNkY7SUFDdkM7SUFFQSxPQUFPRSxjQUFjQyxTQUFTLEVBQUVsRixRQUFRLEVBQUU7UUFDeEMsSUFBSTtZQUNGbEYsR0FBR3FLLGFBQWEsQ0FBQ25GLFVBQVViLEtBQUtDLFNBQVMsQ0FBQzhGLFdBQVcsTUFBTTtZQUMzRGhLLFFBQVFDLEdBQUcsQ0FBQyx5QkFBa0MsT0FBVDZFO1FBQ3ZDLEVBQUUsT0FBT3NELE9BQU87WUFDZHBJLFFBQVFvSSxLQUFLLENBQUMsOEJBQThCQTtZQUM1Q3BJLFFBQVFDLEdBQUcsQ0FDVCxrQ0FDQWdFLEtBQUtDLFNBQVMsQ0FBQzhGLFdBQVcsTUFBTSxHQUFHRSxTQUFTLENBQUMsR0FBRztRQUVwRDtJQUNGO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHdksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3V0aWxzL0lETUxVdGlscy5qcz84ZDJmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcblxyXG5jbGFzcyBJRE1MVXRpbHMge1xyXG4gIHN0YXRpYyBwYXJzZUdlb21ldHJpY0JvdW5kcyhib3VuZHNTdHJpbmcpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IGJvdW5kc1N0cmluZyA9XCIsIGJvdW5kc1N0cmluZyk7XHJcbiAgICBpZiAoIWJvdW5kc1N0cmluZyB8fCBib3VuZHNTdHJpbmcgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiBNaXNzaW5nIGdlb21ldHJpYyBib3VuZHMsIHVzaW5nIGRlZmF1bHRzXCIpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMTAwLFxyXG4gICAgICAgIHJpZ2h0OiAxMDAsXHJcbiAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBib3VuZHMgPSBib3VuZHNTdHJpbmcuc3BsaXQoXCIgXCIpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgdG9wOiBib3VuZHNbMF0gfHwgMCxcclxuICAgICAgbGVmdDogYm91bmRzWzFdIHx8IDAsXHJcbiAgICAgIGJvdHRvbTogYm91bmRzWzJdIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBib3VuZHNbM10gfHwgMCxcclxuICAgICAgd2lkdGg6IChib3VuZHNbM10gfHwgMCkgLSAoYm91bmRzWzFdIHx8IDApLFxyXG4gICAgICBoZWlnaHQ6IChib3VuZHNbMl0gfHwgMCkgLSAoYm91bmRzWzBdIHx8IDApLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlBhcnNlZCBib3VuZHM6XCIsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybVN0cmluZykge1xyXG4gICAgaWYgKCF0cmFuc2Zvcm1TdHJpbmcpIHJldHVybiB7IGE6IDEsIGI6IDAsIGM6IDAsIGQ6IDEsIHR4OiAwLCB0eTogMCB9O1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IHRyYW5zZm9ybVN0cmluZy5zcGxpdChcIiBcIikubWFwKHBhcnNlRmxvYXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYTogdmFsdWVzWzBdIHx8IDEsIC8vIHggc2NhbGVcclxuICAgICAgYjogdmFsdWVzWzFdIHx8IDAsIC8vIHkgc2tld1xyXG4gICAgICBjOiB2YWx1ZXNbMl0gfHwgMCwgLy8geCBza2V3XHJcbiAgICAgIGQ6IHZhbHVlc1szXSB8fCAxLCAvLyB5IHNjYWxlXHJcbiAgICAgIHR4OiB2YWx1ZXNbNF0gfHwgMCwgLy8geCB0cmFuc2xhdGlvblxyXG4gICAgICB0eTogdmFsdWVzWzVdIHx8IDAsIC8vIHkgdHJhbnNsYXRpb25cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlUm90YXRpb24odHJhbnNmb3JtKSB7XHJcbiAgICAvLyBDYWxjdWxhdGUgcm90YXRpb24gYW5nbGUgZnJvbSB0cmFuc2Zvcm0gbWF0cml4XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmEpICogKDE4MCAvIE1hdGguUEkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUNvcm5lcnMoYm91bmRzLCB0cmFuc2Zvcm0pIHtcclxuICAgIGNvbnN0IGNvcm5lcnMgPSB7XHJcbiAgICAgIHRvcExlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy50b3AgfSxcclxuICAgICAgdG9wUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMudG9wIH0sXHJcbiAgICAgIGJvdHRvbUxlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy5ib3R0b20gfSxcclxuICAgICAgYm90dG9tUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMuYm90dG9tIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIGNvcm5lcnNcclxuICAgIE9iamVjdC5rZXlzKGNvcm5lcnMpLmZvckVhY2goKGNvcm5lcikgPT4ge1xyXG4gICAgICBjb25zdCBwb2ludCA9IGNvcm5lcnNbY29ybmVyXTtcclxuICAgICAgY29ybmVyc1tjb3JuZXJdID0ge1xyXG4gICAgICAgIHg6IHRyYW5zZm9ybS5hICogcG9pbnQueCArIHRyYW5zZm9ybS5jICogcG9pbnQueSArIHRyYW5zZm9ybS50eCxcclxuICAgICAgICB5OiB0cmFuc2Zvcm0uYiAqIHBvaW50LnggKyB0cmFuc2Zvcm0uZCAqIHBvaW50LnkgKyB0cmFuc2Zvcm0udHksXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29ybmVycztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjbXlrVG9SZ2IoYywgbSwgeSwgaykge1xyXG4gICAgLy8gQ29udmVydCBDTVlLIHBlcmNlbnRhZ2VzICgwLTEwMCkgdG8gUkdCICgwLTI1NSlcclxuICAgIGMgPSBjIC8gMTAwO1xyXG4gICAgbSA9IG0gLyAxMDA7XHJcbiAgICB5ID0geSAvIDEwMDtcclxuICAgIGsgPSBrIC8gMTAwO1xyXG5cclxuICAgIGNvbnN0IHIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gYykgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGcgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gbSkgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0geSkgKiAoMSAtIGspKTtcclxuXHJcbiAgICByZXR1cm4geyByLCBnLCBiIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VJbkRlc2lnbkNvbG9yKGNvbG9yUmVmKSB7XHJcbiAgICBpZiAoIWNvbG9yUmVmIHx8IGNvbG9yUmVmID09PSBcIkNvbG9yL05vbmVcIikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gSGFuZGxlIENNWUsgY29sb3JzXHJcbiAgICBjb25zdCBjbXlrTWF0Y2ggPSBjb2xvclJlZi5tYXRjaChcclxuICAgICAgL0NvbG9yXFwvQz0oXFxkKylcXHMqTT0oXFxkKylcXHMqWT0oXFxkKylcXHMqSz0oXFxkKykvXHJcbiAgICApO1xyXG4gICAgaWYgKGNteWtNYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCBjLCBtLCB5LCBrXSA9IGNteWtNYXRjaC5tYXAoTnVtYmVyKTtcclxuICAgICAgY29uc3QgcmdiID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cmdiLnJ9LCAke3JnYi5nfSwgJHtyZ2IuYn0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgUkdCIGNvbG9yc1xyXG4gICAgY29uc3QgcmdiTWF0Y2ggPSBjb2xvclJlZi5tYXRjaCgvQ29sb3JcXC9SPShcXGQrKVxccypHPShcXGQrKVxccypCPShcXGQrKS8pO1xyXG4gICAgaWYgKHJnYk1hdGNoKSB7XHJcbiAgICAgIGNvbnN0IFssIHIsIGcsIGJdID0gcmdiTWF0Y2gubWFwKE51bWJlcik7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGFuZGFyZCBjb2xvcnNcclxuICAgIGNvbnN0IHN0YW5kYXJkQ29sb3JzID0ge1xyXG4gICAgICBcIkNvbG9yL0JsYWNrXCI6IFwicmdiKDAsIDAsIDApXCIsXHJcbiAgICAgIFwiQ29sb3IvV2hpdGVcIjogXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIixcclxuICAgICAgXCJDb2xvci9SZWRcIjogXCJyZ2IoMjU1LCAwLCAwKVwiLFxyXG4gICAgICBcIkNvbG9yL0dyZWVuXCI6IFwicmdiKDAsIDI1NSwgMClcIixcclxuICAgICAgXCJDb2xvci9CbHVlXCI6IFwicmdiKDAsIDAsIDI1NSlcIixcclxuICAgICAgXCJDb2xvci9DeWFuXCI6IFwicmdiKDAsIDI1NSwgMjU1KVwiLFxyXG4gICAgICBcIkNvbG9yL01hZ2VudGFcIjogXCJyZ2IoMjU1LCAwLCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvWWVsbG93XCI6IFwicmdiKDI1NSwgMjU1LCAwKVwiLFxyXG4gICAgICBcIkNvbG9yL1BhcGVyXCI6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvUmVnaXN0cmF0aW9uXCI6IFwicmdiKDAsIDAsIDApXCIsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBzdGFuZGFyZENvbG9yc1tjb2xvclJlZl0gfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBkZWNvZGVYTUxFbnRpdGllcyh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMDBBOy9nLCBcIlxcblwiKSAvLyBMaW5lIGZlZWRcclxuICAgICAgLnJlcGxhY2UoLyYjeDAwMEQ7L2csIFwiXFxyXCIpIC8vIENhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiN4MDAwOTsvZywgXCJcXHRcIikgLy8gVGFiXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMEEwOy9nLCBcIlxcdTAwQTBcIikgLy8gTm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gyMDI4Oy9nLCBcIlxcblwiKSAvLyBMaW5lIHNlcGFyYXRvclxyXG4gICAgICAucmVwbGFjZSgvJiN4MjAyOTsvZywgXCJcXHUyMDI5XCIpIC8vIFBhcmFncmFwaCBzZXBhcmF0b3JcclxuICAgICAgLnJlcGxhY2UoLyYjMTA7L2csIFwiXFxuXCIpIC8vIERlY2ltYWwgbGluZSBmZWVkXHJcbiAgICAgIC5yZXBsYWNlKC8mIzEzOy9nLCBcIlxcclwiKSAvLyBEZWNpbWFsIGNhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiM5Oy9nLCBcIlxcdFwiKSAvLyBEZWNpbWFsIHRhYlxyXG4gICAgICAucmVwbGFjZSgvJiMxNjA7L2csIFwiXFx1MDBBMFwiKSAvLyBEZWNpbWFsIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAucmVwbGFjZSgvJmx0Oy9nLCBcIjxcIikgLy8gTGVzcyB0aGFuXHJcbiAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKSAvLyBHcmVhdGVyIHRoYW5cclxuICAgICAgLnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKSAvLyBBbXBlcnNhbmQgKG11c3QgYmUgbGFzdClcclxuICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKSAvLyBRdW90ZVxyXG4gICAgICAucmVwbGFjZSgvJmFwb3M7L2csIFwiJ1wiKTsgLy8gQXBvc3Ryb3BoZVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNsZWFuVGV4dENvbnRlbnQoY29udGVudCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgY29udGVudFxyXG4gICAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIikgLy8gTm9ybWFsaXplIFdpbmRvd3MgbGluZSBicmVha3NcclxuICAgICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCBcIiAgICBcIikgLy8gQ29udmVydCB0YWJzIHRvIHNwYWNlc1xyXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMEEwL2csIFwiIFwiKSAvLyBDb252ZXJ0IG5vbi1icmVha2luZyBzcGFjZXNcclxuICAgICAgICAucmVwbGFjZSgvICsvZywgXCIgXCIpIC8vIENvbGxhcHNlIG11bHRpcGxlIHNwYWNlc1xyXG4gICAgICAgIC8vIFJFTU9WRUQ6IC5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKSAgLy8gQWxsb3cgdW5saW1pdGVkIGNvbnNlY3V0aXZlIGxpbmUgYnJlYWtzXHJcbiAgICAgICAgLnRyaW0oKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwcmVzZXJ2ZUxpbmVCcmVha3MoY29udGVudCkge1xyXG4gICAgcmV0dXJuIGNvbnRlbnRcclxuICAgICAgLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKSAvLyBOb3JtYWxpemUgV2luZG93cyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpIC8vIENvbnZlcnQgbGluZSBzZXBhcmF0b3JzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpOyAvLyBDb252ZXJ0IHBhcmFncmFwaCBzZXBhcmF0b3JzXHJcbiAgICAvLyBSRU1PVkVEOiAucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJyk7IC8vIEFsbG93IHVubGltaXRlZCBjb25zZWN1dGl2ZSBsaW5lIGJyZWFrc1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBDbGVhbiB1cCBleGNlc3NpdmUgbGluZSBicmVha3MgdG8gcHJldmVudCB0ZXh0IG92ZXJmbG93XHJcbiAgc3RhdGljIGNsZWFuVGV4dEZvclJlbmRlcmluZyh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiBcIlwiO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGV4dFxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBsaW5lIGVuZGluZ3NcclxuICAgICAgICAucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKVxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG9uIGVhY2ggbGluZSBvbmx5XHJcbiAgICAgICAgLnJlcGxhY2UoL1sgXFx0XStcXG4vZywgXCJcXG5cIilcclxuICAgICk7XHJcbiAgICAvLyBETyBOT1QgY29sbGFwc2UgbXVsdGlwbGUgc3BhY2VzLCB0YWJzLCBvciBuZXdsaW5lc1xyXG4gICAgLy8gRE8gTk9UIHRyaW0gdGhlIHdob2xlIHN0cmluZ1xyXG4gIH1cclxuXHJcbiAgLy8gRU5IQU5DRUQ6IEJldHRlciBsaW5lIGJyZWFrIHByb2Nlc3NpbmcgdGhhdCBwcmVzZXJ2ZXMgd29yZCBzcGFjZXNcclxuICBzdGF0aWMgc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmcoY29udGVudCkge1xyXG4gICAgaWYgKCFjb250ZW50KSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAvLyBERUJVRzogVHJhY2sgaWYgcHJvYmxlbWF0aWMgdGV4dCBpcyBiZWluZyBwcm9jZXNzZWRcclxuICAgIGNvbnN0IGhhc1Byb2JsZW1hdGljVGV4dCA9XHJcbiAgICAgIGNvbnRlbnQuaW5jbHVkZXMoXCJwYXZvbHVwdHVzZGFcIikgfHxcclxuICAgICAgKGNvbnRlbnQuaW5jbHVkZXMoXCJwYVwiKSAmJiBjb250ZW50LmluY2x1ZGVzKFwidm9sdXB0dXNkYVwiKSk7XHJcbiAgICBpZiAoaGFzUHJvYmxlbWF0aWNUZXh0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3Npbmc6XCIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIiAgIC0gSW5wdXQ6XCIsIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaXJzdCBjbGVhbiB1cCB0aGUgY29udGVudCBidXQgcHJlc2VydmUgd29yZCBzcGFjZXNcclxuICAgIGxldCBwcm9jZXNzZWQgPSB0aGlzLmNsZWFuVGV4dEZvclJlbmRlcmluZyhjb250ZW50KTtcclxuXHJcbiAgICBpZiAoaGFzUHJvYmxlbWF0aWNUZXh0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwiICAgLSBBZnRlciBjbGVhblRleHRGb3JSZW5kZXJpbmc6XCIsXHJcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkocHJvY2Vzc2VkKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vcm1hbGl6ZSBsaW5lIGJyZWFrcyBidXQgZG9uJ3QgdG91Y2ggd29yZCBzcGFjZXNcclxuICAgIC8vIHByb2Nlc3NlZCA9IHByb2Nlc3NlZFxyXG4gICAgLy8gICAucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKSAgICAgIC8vIE5vcm1hbGl6ZSBXaW5kb3dzIGxpbmUgYnJlYWtzXHJcbiAgICAvLyAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcbicpICAgICAgICAvLyBOb3JtYWxpemUgb2xkIE1hYyBsaW5lIGJyZWFrc1xyXG4gICAgLy8gICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxuJykgICAgLy8gQ29udmVydCBsaW5lIHNlcGFyYXRvcnNcclxuICAgIC8vICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcblxcbicpICAvLyBDb252ZXJ0IHBhcmFncmFwaCBzZXBhcmF0b3JzIHRvIGRvdWJsZSBicmVha3NcclxuICAgIC8vICAgLnJlcGxhY2UoL1xcdTAwMEEvZywgJ1xcbicpOyAgIC8vIENvbnZlcnQgZXhwbGljaXQgbGluZSBmZWVkIGNoYXJhY3RlcnNcclxuXHJcbiAgICAvLyBFbnN1cmUgcGFyYWdyYXBoIGJyZWFrcyBhcmUgcHJvcGVybHkgc3BhY2VkXHJcbiAgICAvLyBwcm9jZXNzZWQgPSBwcm9jZXNzZWQucmVwbGFjZSgvXFxuXFxuKy9nLCAnXFxuXFxuJyk7IC8vIFJFTU9WRSBUSElTIExJTkUgdG8gcHJlc2VydmUgYWxsIGNvbnNlY3V0aXZlIG5ld2xpbmVzXHJcblxyXG4gICAgcmV0dXJuIHByb2Nlc3NlZDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjb3VudFdvcmRzKHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0LnNwbGl0KC9cXHMrLykuZmlsdGVyKCh3b3JkKSA9PiB3b3JkLmxlbmd0aCA+IDApLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwYXJzZU51bWVyaWModmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBcIlwiKSByZXR1cm4gbnVsbDtcclxuICAgIGNvbnN0IG51bSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG51bSkgPyBudWxsIDogbnVtO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGlzSW1hZ2VGaWxlKGZpbGVOYW1lKSB7XHJcbiAgICBjb25zdCBpbWFnZUV4dGVuc2lvbnMgPSBbXHJcbiAgICAgIFwiLmpwZ1wiLFxyXG4gICAgICBcIi5qcGVnXCIsXHJcbiAgICAgIFwiLnBuZ1wiLFxyXG4gICAgICBcIi5naWZcIixcclxuICAgICAgXCIudGlmZlwiLFxyXG4gICAgICBcIi50aWZcIixcclxuICAgICAgXCIuYm1wXCIsXHJcbiAgICAgIFwiLnN2Z1wiLFxyXG4gICAgICBcIi5lcHNcIixcclxuICAgICAgXCIuYWlcIixcclxuICAgICAgXCIucHNkXCIsXHJcbiAgICAgIFwiLndlYnBcIixcclxuICAgICAgXCIuaWNvXCIsXHJcbiAgICAgIFwiLmpmaWZcIixcclxuICAgICAgXCIuanAyXCIsXHJcbiAgICAgIFwiLmpweFwiLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBpbWFnZUV4dGVuc2lvbnMuc29tZSgoZXh0KSA9PiBmaWxlTmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldEltYWdlRXh0ZW5zaW9uKGltYWdlVHlwZU5hbWUpIHtcclxuICAgIGNvbnN0IHR5cGVNYXAgPSB7XHJcbiAgICAgIFwiJElEL0pQRUdcIjogXCJqcGdcIixcclxuICAgICAgXCIkSUQvUE5HXCI6IFwicG5nXCIsXHJcbiAgICAgIFwiJElEL1RJRkZcIjogXCJ0aWZcIixcclxuICAgICAgXCIkSUQvR0lGXCI6IFwiZ2lmXCIsXHJcbiAgICAgIFwiJElEL0JNUFwiOiBcImJtcFwiLFxyXG4gICAgfTtcclxuICAgIHJldHVybiB0eXBlTWFwW2ltYWdlVHlwZU5hbWVdIHx8IFwianBnXCI7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0SW1hZ2VFeHRlbnNpb25Gcm9tRm9ybWF0KGZvcm1hdCkge1xyXG4gICAgY29uc3QgZm9ybWF0TWFwID0ge1xyXG4gICAgICBcIiRJRC9KUEVHXCI6IFwianBnXCIsXHJcbiAgICAgIFwiJElEL1BOR1wiOiBcInBuZ1wiLFxyXG4gICAgICBcIiRJRC9USUZGXCI6IFwidGlmXCIsXHJcbiAgICAgIFwiJElEL0dJRlwiOiBcImdpZlwiLFxyXG4gICAgICBcIiRJRC9CTVBcIjogXCJibXBcIixcclxuICAgIH07XHJcbiAgICByZXR1cm4gZm9ybWF0TWFwW2Zvcm1hdF0gfHwgXCJqcGdcIjtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBleHRyYWN0SW1hZ2VOYW1lRnJvbUxpbmsobGlua1VyaSkge1xyXG4gICAgaWYgKCFsaW5rVXJpKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAvLyBFeHRyYWN0IGZpbGVuYW1lIGZyb20gcGF0aCBsaWtlIFwiZmlsZTpDOi9Vc2Vycy9sYWxvL0Rvd25sb2Fkcy9UZXNsYS1Nb2RlbC0zLmpwZyAxMzMyNSBcIlxyXG4gICAgY29uc3QgbWF0Y2ggPSBsaW5rVXJpLm1hdGNoKC8oW15cXC9cXFxcXSspXFwuW14uXSskLyk7XHJcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldChlbGVtZW50cykge1xyXG4gICAgaWYgKCFlbGVtZW50cyB8fCBlbGVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coXCLwn5qrIE5vIGVsZW1lbnRzIHByb3ZpZGVkIGZvciBjb29yZGluYXRlIG9mZnNldCBjYWxjdWxhdGlvblwiKTtcclxuICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBtaW5YID0gSW5maW5pdHksXHJcbiAgICAgIG1pblkgPSBJbmZpbml0eTtcclxuICAgIGxldCBtYXhTdHJva2VXaWR0aCA9IDA7XHJcbiAgICBsZXQgdmFsaWRFbGVtZW50cyA9IDA7XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5SNIEFOQUxZWklORyAke2VsZW1lbnRzLmxlbmd0aH0gZWxlbWVudHMgZm9yIGNvb3JkaW5hdGUgb2Zmc2V0Li4uYFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBGaXJzdCBwYXNzOiBmaW5kIFRSVUUgbWluaW11bSBjb29yZGluYXRlcyBhY3Jvc3MgYWxsIGVsZW1lbnRzXHJcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBib3VuZHMgPSBlbGVtZW50Lmdlb21ldHJpY0JvdW5kcyB8fCBlbGVtZW50Lm9yaWdpbmFsQm91bmRzO1xyXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbGVtZW50Lml0ZW1UcmFuc2Zvcm0gfHwgeyB0eDogMCwgdHk6IDAgfTtcclxuXHJcbiAgICAgIGlmIChib3VuZHMgJiYgKGJvdW5kcy5sZWZ0ICE9PSB1bmRlZmluZWQgfHwgYm91bmRzLnRvcCAhPT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBmaW5hbCBwb3NpdGlvbiBhZnRlciB0cmFuc2Zvcm1cclxuICAgICAgICBjb25zdCBmaW5hbFggPSAoYm91bmRzLmxlZnQgfHwgMCkgKyAodHJhbnNmb3JtLnR4IHx8IDApO1xyXG4gICAgICAgIGNvbnN0IGZpbmFsWSA9IChib3VuZHMudG9wIHx8IDApICsgKHRyYW5zZm9ybS50eSB8fCAwKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgICAgRWxlbWVudCAke2luZGV4fTogYm91bmRzKCR7Ym91bmRzLmxlZnR9LCAke2JvdW5kcy50b3B9KSArIHRyYW5zZm9ybSgke3RyYW5zZm9ybS50eH0sICR7dHJhbnNmb3JtLnR5fSkgPSBmaW5hbCgke2ZpbmFsWH0sICR7ZmluYWxZfSlgXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIGZpbmFsWCk7XHJcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGZpbmFsWSk7XHJcbiAgICAgICAgdmFsaWRFbGVtZW50cysrO1xyXG5cclxuICAgICAgICAvLyBUcmFjayBtYXhpbXVtIHN0cm9rZSB3aWR0aCBmb3IgaW50ZWxsaWdlbnQgcGFkZGluZ1xyXG4gICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gZWxlbWVudC5zdHJva2VXZWlnaHQgfHwgMDtcclxuICAgICAgICBtYXhTdHJva2VXaWR0aCA9IE1hdGgubWF4KG1heFN0cm9rZVdpZHRoLCBzdHJva2VXaWR0aCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAgIEVsZW1lbnQgJHtpbmRleH06IE5vIHZhbGlkIGJvdW5kcyAtIHNraXBwaW5nYCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIG5vIHZhbGlkIGVsZW1lbnRzIGZvdW5kXHJcbiAgICBpZiAodmFsaWRFbGVtZW50cyA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIuKaoO+4jyAgTm8gdmFsaWQgZWxlbWVudHMgd2l0aCBib3VuZHMgZm91bmQgLSB1c2luZyB6ZXJvIG9mZnNldFwiXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBpbmZpbml0ZSB2YWx1ZXMgdG8gMCBpZiBubyB2YWxpZCBjb29yZGluYXRlcyBmb3VuZFxyXG4gICAgaWYgKG1pblggPT09IEluZmluaXR5KSBtaW5YID0gMDtcclxuICAgIGlmIChtaW5ZID09PSBJbmZpbml0eSkgbWluWSA9IDA7XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5OKIEFOQUxZU0lTIENPTVBMRVRFOiBtaW5YPSR7bWluWH0sIG1pblk9JHttaW5ZfSwgbWF4U3Ryb2tlPSR7bWF4U3Ryb2tlV2lkdGh9cHgsIHZhbGlkRWxlbWVudHM9JHt2YWxpZEVsZW1lbnRzfWBcclxuICAgICk7XHJcblxyXG4gICAgLy8gWkVSTy1CQVNFRCBPRkZTRVQgQ0FMQ1VMQVRJT046XHJcbiAgICAvLyBUaGUgZ29hbCBpcyB0byBoYXZlIE5PIE9GRlNFVCB1bmxlc3MgYWJzb2x1dGVseSBuZWNlc3NhcnkgZm9yIG5lZ2F0aXZlIGNvb3JkaW5hdGVzXHJcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XHJcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XHJcblxyXG4gICAgLy8gT25seSBhZGQgb2Zmc2V0IGlmIGNvb3JkaW5hdGVzIGFyZSBhY3R1YWxseSBuZWdhdGl2ZVxyXG4gICAgaWYgKG1pblggPCAwKSB7XHJcbiAgICAgIG9mZnNldFggPSBNYXRoLmFicyhtaW5YKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKdjCBOZWdhdGl2ZSBYIGRldGVjdGVkOiAke21pblh9IOKGkiBhZGRpbmcgb2Zmc2V0OiAke29mZnNldFh9YFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtaW5ZIDwgMCkge1xyXG4gICAgICBvZmZzZXRZID0gTWF0aC5hYnMobWluWSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDinYwgTmVnYXRpdmUgWSBkZXRlY3RlZDogJHttaW5ZfSDihpIgYWRkaW5nIG9mZnNldDogJHtvZmZzZXRZfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgbWluaW1hbCBzdHJva2UgcGFkZGluZyBvbmx5IGlmIHdlIGFscmVhZHkgaGF2ZSBhbiBvZmZzZXRcclxuICAgIGlmICgob2Zmc2V0WCA+IDAgfHwgb2Zmc2V0WSA+IDApICYmIG1heFN0cm9rZVdpZHRoID4gMCkge1xyXG4gICAgICBjb25zdCBzdHJva2VQYWRkaW5nID0gTWF0aC5jZWlsKG1heFN0cm9rZVdpZHRoIC8gMik7XHJcbiAgICAgIGlmIChvZmZzZXRYID4gMCkgb2Zmc2V0WCArPSBzdHJva2VQYWRkaW5nO1xyXG4gICAgICBpZiAob2Zmc2V0WSA+IDApIG9mZnNldFkgKz0gc3Ryb2tlUGFkZGluZztcclxuICAgICAgY29uc29sZS5sb2coYPCflozvuI8gQWRkZWQgc3Ryb2tlIHBhZGRpbmc6ICR7c3Ryb2tlUGFkZGluZ31weGApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGDwn46vIEZJTkFMIE9GRlNFVDogWD0ke29mZnNldFh9LCBZPSR7b2Zmc2V0WX1gKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBgICAgJHtcclxuICAgICAgICBvZmZzZXRYID09PSAwXHJcbiAgICAgICAgICA/IFwi4pyFIFBlcmZlY3QhIE5vIFggb2Zmc2V0IG5lZWRlZFwiXHJcbiAgICAgICAgICA6IGDimqDvuI8gWCBvZmZzZXQ6ICR7b2Zmc2V0WH1weCAoJHttaW5YfSB3YXMgbmVnYXRpdmUpYFxyXG4gICAgICB9YFxyXG4gICAgKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBgICAgJHtcclxuICAgICAgICBvZmZzZXRZID09PSAwXHJcbiAgICAgICAgICA/IFwi4pyFIFBlcmZlY3QhIE5vIFkgb2Zmc2V0IG5lZWRlZFwiXHJcbiAgICAgICAgICA6IGDimqDvuI8gWSBvZmZzZXQ6ICR7b2Zmc2V0WX1weCAoJHttaW5ZfSB3YXMgbmVnYXRpdmUpYFxyXG4gICAgICB9YFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4geyB4OiBvZmZzZXRYLCB5OiBvZmZzZXRZIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgcHJlY2lzZSBjb29yZGluYXRlIG9mZnNldCBmb3IgcGl4ZWwtcGVyZmVjdCBJbkRlc2lnbiBjb29yZGluYXRlIHN5c3RlbSB0cmFuc2Zvcm1hdGlvblxyXG4gICAqIFRoaXMgZW5zdXJlcyBhY2N1cmF0ZSBwb3NpdGlvbmluZyBzaW1pbGFyIHRvIHByb2Zlc3Npb25hbCB0b29scyBsaWtlIElNRy5MWSBJbkRlc2lnblxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIC0gQXJyYXkgb2YgZWxlbWVudHMgd2l0aCBib3VuZHMgYW5kIHRyYW5zZm9ybXNcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIHt4LCB5fSBvZmZzZXQgZm9yIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb25cclxuICAgKi9cclxuICBzdGF0aWMgY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldFByZWNpc2UoZWxlbWVudHMpIHtcclxuICAgIGlmICghZWxlbWVudHMgfHwgZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIvCfjq8gTm8gZWxlbWVudHMgcHJvdmlkZWQgZm9yIGNvb3JkaW5hdGUgb2Zmc2V0IGNhbGN1bGF0aW9uXCIpO1xyXG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwi8J+UjSBBTkFMWVpJTkdcIixcclxuICAgICAgZWxlbWVudHMubGVuZ3RoLFxyXG4gICAgICBcImVsZW1lbnRzIGZvciBQUkVDSVNFIGNvb3JkaW5hdGUgb2Zmc2V0Li4uXCJcclxuICAgICk7XHJcblxyXG4gICAgbGV0IG1pblggPSBJbmZpbml0eTtcclxuICAgIGxldCBtaW5ZID0gSW5maW5pdHk7XHJcbiAgICBsZXQgbWF4U3Ryb2tlID0gMDtcclxuICAgIGxldCB2YWxpZEVsZW1lbnRzID0gMDtcclxuXHJcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoIWVsZW1lbnQuZ2VvbWV0cmljQm91bmRzIHx8ICFlbGVtZW50Lml0ZW1UcmFuc2Zvcm0pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICBgICAg4pqg77iPIEVsZW1lbnQgJHtpbmRleH0gbWlzc2luZyBib3VuZHMvdHJhbnNmb3JtIC0gc2tpcHBpbmdgXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBmaW5hbCBwb3NpdGlvbiAoYm91bmRzICsgdHJhbnNmb3JtKVxyXG4gICAgICBjb25zdCBmaW5hbFggPSBlbGVtZW50Lmdlb21ldHJpY0JvdW5kcy5sZWZ0ICsgZWxlbWVudC5pdGVtVHJhbnNmb3JtLnR4O1xyXG4gICAgICBjb25zdCBmaW5hbFkgPSBlbGVtZW50Lmdlb21ldHJpY0JvdW5kcy50b3AgKyBlbGVtZW50Lml0ZW1UcmFuc2Zvcm0udHk7XHJcblxyXG4gICAgICAvLyBUcmFjayBzdHJva2Ugd2lkdGggZm9yIHByZWNpc2UgcG9zaXRpb25pbmdcclxuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBlbGVtZW50LnN0cm9rZVdlaWdodCB8fCAwO1xyXG4gICAgICBtYXhTdHJva2UgPSBNYXRoLm1heChtYXhTdHJva2UsIHN0cm9rZVdpZHRoKTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGAgICBFbGVtZW50ICR7aW5kZXh9OiBib3VuZHMoJHtlbGVtZW50Lmdlb21ldHJpY0JvdW5kcy5sZWZ0fSwgJHtlbGVtZW50Lmdlb21ldHJpY0JvdW5kcy50b3B9KSArIHRyYW5zZm9ybSgke2VsZW1lbnQuaXRlbVRyYW5zZm9ybS50eH0sICR7ZWxlbWVudC5pdGVtVHJhbnNmb3JtLnR5fSkgPSBmaW5hbCgke2ZpbmFsWH0sICR7ZmluYWxZfSlgXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgZmluYWxYKTtcclxuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGZpbmFsWSk7XHJcbiAgICAgIHZhbGlkRWxlbWVudHMrKztcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIvCfk4ogQU5BTFlTSVMgQ09NUExFVEU6XCIsXHJcbiAgICAgIGBtaW5YPSR7bWluWH0sIG1pblk9JHttaW5ZfSwgbWF4U3Ryb2tlPSR7bWF4U3Ryb2tlfXB4LCB2YWxpZEVsZW1lbnRzPSR7dmFsaWRFbGVtZW50c31gXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEZJWEVEOiBPbmx5IGFkZCBvZmZzZXQgaWYgY29vcmRpbmF0ZXMgYXJlIGFjdHVhbGx5IG5lZ2F0aXZlXHJcbiAgICAvLyBEb24ndCBmb3JjZSBlbGVtZW50cyB0byBzdGFydCBhdCBvcmlnaW4gLSBwcmVzZXJ2ZSBJbkRlc2lnbiBwb3NpdGlvbmluZ1xyXG4gICAgbGV0IG9mZnNldFggPSAwO1xyXG4gICAgbGV0IG9mZnNldFkgPSAwO1xyXG5cclxuICAgIC8vIE9ubHkgaGFuZGxlIG5lZ2F0aXZlIGNvb3JkaW5hdGVzIHRoYXQgd291bGQgYmUgY2xpcHBlZCBieSB0aGUgYnJvd3NlclxyXG4gICAgaWYgKG1pblggPCAwKSB7XHJcbiAgICAgIG9mZnNldFggPSBNYXRoLmFicyhtaW5YKSArIG1heFN0cm9rZTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKdjCBOZWdhdGl2ZSBYIGRldGVjdGVkOiAke21pblh9IOKGkiBhZGRpbmcgb2Zmc2V0OiAke29mZnNldFh9YFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBQb3NpdGl2ZSBYIGNvb3JkaW5hdGVzOiAke21pblh9IOKGkiBubyBvZmZzZXQgbmVlZGVkYCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1pblkgPCAwKSB7XHJcbiAgICAgIG9mZnNldFkgPSBNYXRoLmFicyhtaW5ZKSArIG1heFN0cm9rZTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKdjCBOZWdhdGl2ZSBZIGRldGVjdGVkOiAke21pbll9IOKGkiBhZGRpbmcgb2Zmc2V0OiAke29mZnNldFl9YFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBQb3NpdGl2ZSBZIGNvb3JkaW5hdGVzOiAke21pbll9IOKGkiBubyBvZmZzZXQgbmVlZGVkYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmluYWxPZmZzZXQgPSB7IHg6IG9mZnNldFgsIHk6IG9mZnNldFkgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIvCfjq8gRklOQUwgUFJFQ0lTRSBPRkZTRVQ6XCIsIGBYPSR7b2Zmc2V0WH0sIFk9JHtvZmZzZXRZfWApO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGAgICAke1xyXG4gICAgICAgIG9mZnNldFggPT09IDBcclxuICAgICAgICAgID8gXCLinIUgUGVyZmVjdCEgTm8gWCBvZmZzZXQgbmVlZGVkXCJcclxuICAgICAgICAgIDogYOKaoO+4jyBYIG9mZnNldDogJHtvZmZzZXRYfXB4IChjb21wZW5zYXRpbmcgZm9yIG5lZ2F0aXZlIGNvb3JkaW5hdGVzKWBcclxuICAgICAgfWBcclxuICAgICk7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYCAgICR7XHJcbiAgICAgICAgb2Zmc2V0WSA9PT0gMFxyXG4gICAgICAgICAgPyBcIuKchSBQZXJmZWN0ISBObyBZIG9mZnNldCBuZWVkZWRcIlxyXG4gICAgICAgICAgOiBg4pqg77iPIFkgb2Zmc2V0OiAke29mZnNldFl9cHggKGNvbXBlbnNhdGluZyBmb3IgbmVnYXRpdmUgY29vcmRpbmF0ZXMpYFxyXG4gICAgICB9YFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxPZmZzZXQ7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgoaXRlbSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gRmlyc3QgdHJ5IHRvIGdldCBib3VuZHMgZnJvbSBHZW9tZXRyaWNCb3VuZHMgYXR0cmlidXRlXHJcbiAgICAgIGlmIChpdGVtW1wiQF9HZW9tZXRyaWNCb3VuZHNcIl0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUdlb21ldHJpY0JvdW5kcyhpdGVtW1wiQF9HZW9tZXRyaWNCb3VuZHNcIl0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGVuIHRyeSBwYXRoIGdlb21ldHJ5XHJcbiAgICAgIGNvbnN0IHBhdGhHZW9tZXRyeSA9XHJcbiAgICAgICAgaXRlbT8uUHJvcGVydGllcz8uUGF0aEdlb21ldHJ5Py5HZW9tZXRyeVBhdGhUeXBlPy5QYXRoUG9pbnRBcnJheVxyXG4gICAgICAgICAgPy5QYXRoUG9pbnRUeXBlO1xyXG5cclxuICAgICAgaWYgKCFwYXRoR2VvbWV0cnkgfHwgIUFycmF5LmlzQXJyYXkocGF0aEdlb21ldHJ5KSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYFdhcm5pbmc6IE5vIGdlb21ldHJ5IGZvdW5kIGZvciAke2l0ZW1bXCJAX1NlbGZcIl19LCB1c2luZyBpdGVtIHRyYW5zZm9ybWBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBGYWxsYmFjayB0byBpdGVtIHRyYW5zZm9ybSBpZiBhdmFpbGFibGVcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLnBhcnNlVHJhbnNmb3JtKGl0ZW1bXCJAX0l0ZW1UcmFuc2Zvcm1cIl0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0b3A6IHRyYW5zZm9ybS50eSB8fCAwLFxyXG4gICAgICAgICAgbGVmdDogdHJhbnNmb3JtLnR4IHx8IDAsXHJcbiAgICAgICAgICBib3R0b206ICh0cmFuc2Zvcm0udHkgfHwgMCkgKyAxMDAsIC8vIERlZmF1bHQgaGVpZ2h0XHJcbiAgICAgICAgICByaWdodDogKHRyYW5zZm9ybS50eCB8fCAwKSArIDEwMCwgLy8gRGVmYXVsdCB3aWR0aFxyXG4gICAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBtaW5YID0gSW5maW5pdHksXHJcbiAgICAgICAgbWluWSA9IEluZmluaXR5LFxyXG4gICAgICAgIG1heFggPSAtSW5maW5pdHksXHJcbiAgICAgICAgbWF4WSA9IC1JbmZpbml0eTtcclxuXHJcbiAgICAgIHBhdGhHZW9tZXRyeS5mb3JFYWNoKChwb2ludCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHBvaW50W1wiQF9BbmNob3JcIl07XHJcbiAgICAgICAgaWYgKGFuY2hvcikge1xyXG4gICAgICAgICAgY29uc3QgW3gsIHldID0gYW5jaG9yLnNwbGl0KFwiIFwiKS5tYXAocGFyc2VGbG9hdCk7XHJcbiAgICAgICAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xyXG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XHJcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcclxuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xyXG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChtaW5YID09PSBJbmZpbml0eSB8fCBtaW5ZID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYFdhcm5pbmc6IENvdWxkIG5vdCBjYWxjdWxhdGUgYm91bmRzIGZvciAke2l0ZW1bXCJAX1NlbGZcIl19YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICBib3R0b206IDEwMCxcclxuICAgICAgICAgIHJpZ2h0OiAxMDAsXHJcbiAgICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgICAgaGVpZ2h0OiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3A6IG1pblksXHJcbiAgICAgICAgbGVmdDogbWluWCxcclxuICAgICAgICBib3R0b206IG1heFksXHJcbiAgICAgICAgcmlnaHQ6IG1heFgsXHJcbiAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YLFxyXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblksXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjYWxjdWxhdGluZyBib3VuZHMgZm9yICR7aXRlbVtcIkBfU2VsZlwiXX06YCwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMTAwLFxyXG4gICAgICAgIHJpZ2h0OiAxMDAsXHJcbiAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVSZWxhdGl2ZVBvc2l0aW9uKFxyXG4gICAgZnJhbWVCb3VuZHMsXHJcbiAgICBjb250ZW50Qm91bmRzLFxyXG4gICAgZnJhbWVUcmFuc2Zvcm0sXHJcbiAgICBjb250ZW50VHJhbnNmb3JtXHJcbiAgKSB7XHJcbiAgICBpZiAoIWZyYW1lQm91bmRzIHx8ICFjb250ZW50Qm91bmRzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvZmZzZXRYOiAoY29udGVudEJvdW5kcy5sZWZ0IHx8IDApIC0gKGZyYW1lQm91bmRzLmxlZnQgfHwgMCksXHJcbiAgICAgIG9mZnNldFk6IChjb250ZW50Qm91bmRzLnRvcCB8fCAwKSAtIChmcmFtZUJvdW5kcy50b3AgfHwgMCksXHJcbiAgICAgIHNjYWxlWDogY29udGVudFRyYW5zZm9ybT8uYSB8fCAxLFxyXG4gICAgICBzY2FsZVk6IGNvbnRlbnRUcmFuc2Zvcm0/LmQgfHwgMSxcclxuICAgICAgdHJhbnNmb3JtRGlmZmVyZW5jZToge1xyXG4gICAgICAgIGZyYW1lOiBmcmFtZVRyYW5zZm9ybSxcclxuICAgICAgICBjb250ZW50OiBjb250ZW50VHJhbnNmb3JtLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVHYXAoZnJhbWVCb3VuZHMsIGNvbnRlbnRCb3VuZHMpIHtcclxuICAgIGlmICghZnJhbWVCb3VuZHMgfHwgIWNvbnRlbnRCb3VuZHMpIHJldHVybiBudWxsO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcDogKGNvbnRlbnRCb3VuZHMudG9wIHx8IDApIC0gKGZyYW1lQm91bmRzLnRvcCB8fCAwKSxcclxuICAgICAgbGVmdDogKGNvbnRlbnRCb3VuZHMubGVmdCB8fCAwKSAtIChmcmFtZUJvdW5kcy5sZWZ0IHx8IDApLFxyXG4gICAgICBib3R0b206IChmcmFtZUJvdW5kcy5ib3R0b20gfHwgMCkgLSAoY29udGVudEJvdW5kcy5ib3R0b20gfHwgMCksXHJcbiAgICAgIHJpZ2h0OiAoZnJhbWVCb3VuZHMucmlnaHQgfHwgMCkgLSAoY29udGVudEJvdW5kcy5yaWdodCB8fCAwKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlSW1hZ2VQb3NpdGlvbkluRnJhbWUoXHJcbiAgICBmcmFtZUJvdW5kcyxcclxuICAgIGZyYW1lVHJhbnNmb3JtLFxyXG4gICAgcGxhY2VkQ29udGVudFxyXG4gICkge1xyXG4gICAgaWYgKCFmcmFtZUJvdW5kcyB8fCAhcGxhY2VkQ29udGVudD8udHJhbnNmb3JtKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGltYWdlVHJhbnNmb3JtID0gcGxhY2VkQ29udGVudC50cmFuc2Zvcm07XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGltYWdlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGZyYW1lXHJcbiAgICBjb25zdCBpbWFnZVggPSAoZnJhbWVCb3VuZHMubGVmdCB8fCAwKSArIChpbWFnZVRyYW5zZm9ybS50eCB8fCAwKTtcclxuICAgIGNvbnN0IGltYWdlWSA9IChmcmFtZUJvdW5kcy50b3AgfHwgMCkgKyAoaW1hZ2VUcmFuc2Zvcm0udHkgfHwgMCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGltYWdlIHNpemUgd2l0aCBzY2FsaW5nXHJcbiAgICBjb25zdCBpbWFnZVdpZHRoID0gKGZyYW1lQm91bmRzLndpZHRoIHx8IDApICogKGltYWdlVHJhbnNmb3JtLmEgfHwgMSk7XHJcbiAgICBjb25zdCBpbWFnZUhlaWdodCA9IChmcmFtZUJvdW5kcy5oZWlnaHQgfHwgMCkgKiAoaW1hZ2VUcmFuc2Zvcm0uZCB8fCAxKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiBpbWFnZVgsXHJcbiAgICAgIHk6IGltYWdlWSxcclxuICAgICAgd2lkdGg6IGltYWdlV2lkdGgsXHJcbiAgICAgIGhlaWdodDogaW1hZ2VIZWlnaHQsXHJcbiAgICAgIHNjYWxlWDogaW1hZ2VUcmFuc2Zvcm0uYSB8fCAxLFxyXG4gICAgICBzY2FsZVk6IGltYWdlVHJhbnNmb3JtLmQgfHwgMSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0WE1MU3RydWN0dXJlKG9iaiwgbWF4RGVwdGggPSAzLCBjdXJyZW50RGVwdGggPSAwKSB7XHJcbiAgICBpZiAoY3VycmVudERlcHRoID49IG1heERlcHRoIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0cnVjdHVyZSA9IHt9O1xyXG5cclxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xyXG4gICAgICAgIHN0cnVjdHVyZVtrZXldID0gYEFycmF5WyR7b2JqW2tleV0ubGVuZ3RofV1gO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gXCJvYmplY3RcIiAmJiBvYmpba2V5XSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHN0cnVjdHVyZVtrZXldID0gdGhpcy5nZXRYTUxTdHJ1Y3R1cmUoXHJcbiAgICAgICAgICBvYmpba2V5XSxcclxuICAgICAgICAgIG1heERlcHRoLFxyXG4gICAgICAgICAgY3VycmVudERlcHRoICsgMVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RydWN0dXJlW2tleV0gPSB0eXBlb2Ygb2JqW2tleV07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBzdHJ1Y3R1cmU7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaXNGb3JtYXR0aW5nQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmdBdHRyaWJ1dGVzID0gW1xyXG4gICAgICBcIkBfUG9pbnRTaXplXCIsXHJcbiAgICAgIFwiQF9MZWFkaW5nXCIsXHJcbiAgICAgIFwiQF9UcmFja2luZ1wiLFxyXG4gICAgICBcIkBfRm9udFN0eWxlXCIsXHJcbiAgICAgIFwiQF9BcHBsaWVkRm9udFwiLFxyXG4gICAgICBcIkBfRmlsbENvbG9yXCIsXHJcbiAgICAgIFwiQF9TdHJva2VDb2xvclwiLFxyXG4gICAgICBcIkBfSnVzdGlmaWNhdGlvblwiLFxyXG4gICAgICBcIkBfTGVmdEluZGVudFwiLFxyXG4gICAgICBcIkBfUmlnaHRJbmRlbnRcIixcclxuICAgICAgXCJAX0ZpcnN0TGluZUluZGVudFwiLFxyXG4gICAgICBcIkBfU3BhY2VCZWZvcmVcIixcclxuICAgICAgXCJAX1NwYWNlQWZ0ZXJcIixcclxuICAgICAgXCJAX0FsaWdubWVudFwiLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBmb3JtYXR0aW5nQXR0cmlidXRlcy5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBzYXZlRGVidWdJbmZvKGRlYnVnSW5mbywgZmlsZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZU5hbWUsIEpTT04uc3RyaW5naWZ5KGRlYnVnSW5mbywgbnVsbCwgMikpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIERlYnVnIGluZm8gc2F2ZWQgdG8gJHtmaWxlTmFtZX1gKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3Igc2F2aW5nIGRlYnVnIGluZm86XCIsIGVycm9yKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCJEZWJ1ZyBpbmZvIChmaXJzdCAyMDAwIGNoYXJzKTpcIixcclxuICAgICAgICBKU09OLnN0cmluZ2lmeShkZWJ1Z0luZm8sIG51bGwsIDIpLnN1YnN0cmluZygwLCAyMDAwKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJRE1MVXRpbHM7XHJcbiJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImZzIiwiSURNTFV0aWxzIiwicGFyc2VHZW9tZXRyaWNCb3VuZHMiLCJib3VuZHNTdHJpbmciLCJjb25zb2xlIiwibG9nIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0Iiwid2lkdGgiLCJoZWlnaHQiLCJib3VuZHMiLCJzcGxpdCIsIm1hcCIsInBhcnNlRmxvYXQiLCJyZXN1bHQiLCJwYXJzZVRyYW5zZm9ybSIsInRyYW5zZm9ybVN0cmluZyIsImEiLCJiIiwiYyIsImQiLCJ0eCIsInR5IiwidmFsdWVzIiwiY2FsY3VsYXRlUm90YXRpb24iLCJ0cmFuc2Zvcm0iLCJNYXRoIiwiYXRhbjIiLCJQSSIsImNhbGN1bGF0ZUNvcm5lcnMiLCJjb3JuZXJzIiwidG9wTGVmdCIsIngiLCJ5IiwidG9wUmlnaHQiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImNvcm5lciIsInBvaW50IiwiY215a1RvUmdiIiwibSIsImsiLCJyIiwicm91bmQiLCJnIiwicGFyc2VJbkRlc2lnbkNvbG9yIiwiY29sb3JSZWYiLCJjbXlrTWF0Y2giLCJtYXRjaCIsIk51bWJlciIsInJnYiIsInJnYk1hdGNoIiwic3RhbmRhcmRDb2xvcnMiLCJkZWNvZGVYTUxFbnRpdGllcyIsInRleHQiLCJyZXBsYWNlIiwiY2xlYW5UZXh0Q29udGVudCIsImNvbnRlbnQiLCJ0cmltIiwicHJlc2VydmVMaW5lQnJlYWtzIiwiY2xlYW5UZXh0Rm9yUmVuZGVyaW5nIiwic29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmciLCJoYXNQcm9ibGVtYXRpY1RleHQiLCJpbmNsdWRlcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwcm9jZXNzZWQiLCJjb3VudFdvcmRzIiwiZmlsdGVyIiwid29yZCIsImxlbmd0aCIsInBhcnNlTnVtZXJpYyIsInZhbHVlIiwidW5kZWZpbmVkIiwibnVtIiwiaXNOYU4iLCJpc0ltYWdlRmlsZSIsImZpbGVOYW1lIiwiaW1hZ2VFeHRlbnNpb25zIiwic29tZSIsImV4dCIsInRvTG93ZXJDYXNlIiwiZW5kc1dpdGgiLCJnZXRJbWFnZUV4dGVuc2lvbiIsImltYWdlVHlwZU5hbWUiLCJ0eXBlTWFwIiwiZ2V0SW1hZ2VFeHRlbnNpb25Gcm9tRm9ybWF0IiwiZm9ybWF0IiwiZm9ybWF0TWFwIiwiZXh0cmFjdEltYWdlTmFtZUZyb21MaW5rIiwibGlua1VyaSIsImNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXQiLCJlbGVtZW50cyIsIm1pblgiLCJJbmZpbml0eSIsIm1pblkiLCJtYXhTdHJva2VXaWR0aCIsInZhbGlkRWxlbWVudHMiLCJlbGVtZW50IiwiaW5kZXgiLCJnZW9tZXRyaWNCb3VuZHMiLCJvcmlnaW5hbEJvdW5kcyIsIml0ZW1UcmFuc2Zvcm0iLCJmaW5hbFgiLCJmaW5hbFkiLCJtaW4iLCJzdHJva2VXaWR0aCIsInN0cm9rZVdlaWdodCIsIm1heCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiYWJzIiwic3Ryb2tlUGFkZGluZyIsImNlaWwiLCJjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0UHJlY2lzZSIsIndhcm4iLCJtYXhTdHJva2UiLCJmaW5hbE9mZnNldCIsImNhbGN1bGF0ZUJvdW5kc0Zyb21QYXRoIiwiaXRlbSIsInBhdGhHZW9tZXRyeSIsIlByb3BlcnRpZXMiLCJQYXRoR2VvbWV0cnkiLCJHZW9tZXRyeVBhdGhUeXBlIiwiUGF0aFBvaW50QXJyYXkiLCJQYXRoUG9pbnRUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwibWF4WCIsIm1heFkiLCJhbmNob3IiLCJlcnJvciIsImNhbGN1bGF0ZVJlbGF0aXZlUG9zaXRpb24iLCJmcmFtZUJvdW5kcyIsImNvbnRlbnRCb3VuZHMiLCJmcmFtZVRyYW5zZm9ybSIsImNvbnRlbnRUcmFuc2Zvcm0iLCJzY2FsZVgiLCJzY2FsZVkiLCJ0cmFuc2Zvcm1EaWZmZXJlbmNlIiwiZnJhbWUiLCJjYWxjdWxhdGVHYXAiLCJjYWxjdWxhdGVJbWFnZVBvc2l0aW9uSW5GcmFtZSIsInBsYWNlZENvbnRlbnQiLCJpbWFnZVRyYW5zZm9ybSIsImltYWdlWCIsImltYWdlWSIsImltYWdlV2lkdGgiLCJpbWFnZUhlaWdodCIsImdldFhNTFN0cnVjdHVyZSIsIm9iaiIsIm1heERlcHRoIiwiY3VycmVudERlcHRoIiwic3RydWN0dXJlIiwia2V5IiwiaXNGb3JtYXR0aW5nQXR0cmlidXRlIiwiYXR0cmlidXRlTmFtZSIsImZvcm1hdHRpbmdBdHRyaWJ1dGVzIiwic2F2ZURlYnVnSW5mbyIsImRlYnVnSW5mbyIsIndyaXRlRmlsZVN5bmMiLCJzdWJzdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/utils/IDMLUtils.js\n"));

/***/ })

});