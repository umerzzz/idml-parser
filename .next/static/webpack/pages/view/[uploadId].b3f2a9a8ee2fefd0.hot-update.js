"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StyleParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StyleParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StyleParser {\n    // ADDED: Method to set document units for typography conversion\n    setDocumentUnits(units) {\n        this.documentUnits = units;\n        console.log(\"\\uD83D\\uDCD0 StyleParser: Set document units to\", units);\n    }\n    // ADDED: Method to convert typography measurements to pixels\n    convertTypographyToPixels(value) {\n        if (typeof value !== \"number\" || isNaN(value) || !this.unitConverter || !this.documentUnits) {\n            return value;\n        }\n        // Only convert if we have a supported unit and it's not already pixels\n        if (this.unitConverter.isSupportedUnit(this.documentUnits)) {\n            const convertedValue = this.unitConverter.toPixels(value, this.documentUnits);\n            console.log(\"\\uD83D\\uDCD0 Converted typography: \".concat(value, \" \").concat(this.documentUnits, \" → \").concat(convertedValue, \" px\"));\n            return convertedValue;\n        }\n        return value;\n    }\n    // ADDED: Method to convert an entire style object's measurements to pixels\n    convertStyleMeasurementsToPixels(style) {\n        if (!this.unitConverter || !this.documentUnits) {\n            return style;\n        }\n        const convertedStyle = {\n            ...style\n        };\n        // Convert measurements that need pixel conversion\n        const measurementFields = [\n            \"leftIndent\",\n            \"rightIndent\",\n            \"firstLineIndent\",\n            \"spaceBefore\",\n            \"spaceAfter\",\n            \"tracking\",\n            \"kerning\"\n        ];\n        measurementFields.forEach((field)=>{\n            if (typeof convertedStyle[field] === \"number\") {\n                convertedStyle[field] = this.convertTypographyToPixels(convertedStyle[field]);\n            }\n        });\n        // Convert leading if it's a numeric value\n        if (typeof convertedStyle.leading === \"number\") {\n            convertedStyle.leading = this.convertTypographyToPixels(convertedStyle.leading);\n        }\n        return convertedStyle;\n    }\n    async parseResourceFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCCB Parsing resource: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const resourceName = path.basename(fileName, \".xml\");\n            // Handle different resource types\n            if (fileName.includes(\"Styles.xml\")) {\n                await this.extractStyles(parsed);\n            } else if (fileName.includes(\"Fonts.xml\")) {\n                await this.extractFonts(parsed);\n            } else if (fileName.includes(\"Graphic.xml\")) {\n                await this.extractGraphics(parsed);\n            } else if (fileName.includes(\"Preferences.xml\")) {\n                await this.extractPreferences(parsed);\n            }\n            console.log(\"✅ Resource \".concat(resourceName, \" parsed\"));\n        } catch (error) {\n            console.error(\"❌ Error parsing \".concat(fileName, \":\"), error.message);\n        }\n    }\n    async extractStyles(stylesData) {\n        console.log(\"Extracting styles...\");\n        const styles = stylesData.Styles || stylesData;\n        // Extract Paragraph Styles\n        if (styles.RootParagraphStyleGroup) {\n            this.extractParagraphStyles(styles.RootParagraphStyleGroup);\n        }\n        // Extract Character Styles\n        if (styles.RootCharacterStyleGroup) {\n            this.extractCharacterStyles(styles.RootCharacterStyleGroup);\n        }\n    }\n    extractParagraphStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.ParagraphStyle) {\n                const styles = Array.isArray(group.ParagraphStyle) ? group.ParagraphStyle : [\n                    group.ParagraphStyle\n                ];\n                styles.forEach((style)=>{\n                    // CRITICAL: Extract font reference from multiple possible locations\n                    const fontRef = this.extractFontFromStyle(style);\n                    // ENHANCED: Process leading with proper InDesign logic\n                    const fontSize = parseFloat(style[\"@_PointSize\"]) || 12;\n                    const rawLeading = style[\"@_Leading\"];\n                    const processedLeading = this.processLeadingValue(rawLeading, fontSize);\n                    // FIXED: Extract raw typography measurements for conversion\n                    const rawLeftIndent = parseFloat(style[\"@_LeftIndent\"]) || 0;\n                    const rawRightIndent = parseFloat(style[\"@_RightIndent\"]) || 0;\n                    const rawFirstLineIndent = parseFloat(style[\"@_FirstLineIndent\"]) || 0;\n                    const rawSpaceBefore = parseFloat(style[\"@_SpaceBefore\"]) || 0;\n                    const rawSpaceAfter = parseFloat(style[\"@_SpaceAfter\"]) || 0;\n                    const rawTracking = parseFloat(style[\"@_Tracking\"]) || 0;\n                    const rawKerning = parseFloat(style[\"@_Kerning\"]) || 0;\n                    // FIXED: Create base style object with raw values\n                    const baseStyle = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: fontSize,\n                        leading: processedLeading,\n                        leadingType: this.determineLeadingType(rawLeading),\n                        effectiveLineHeight: this.calculateEffectiveLineHeight(processedLeading, fontSize),\n                        alignment: style[\"@_Justification\"] || \"LeftAlign\",\n                        // Raw measurements (will be converted to pixels)\n                        leftIndent: rawLeftIndent,\n                        rightIndent: rawRightIndent,\n                        firstLineIndent: rawFirstLineIndent,\n                        spaceBefore: rawSpaceBefore,\n                        spaceAfter: rawSpaceAfter,\n                        tracking: rawTracking,\n                        kerning: rawKerning,\n                        // Store original values for reference\n                        originalLeftIndent: rawLeftIndent,\n                        originalRightIndent: rawRightIndent,\n                        originalFirstLineIndent: rawFirstLineIndent,\n                        originalSpaceBefore: rawSpaceBefore,\n                        originalSpaceAfter: rawSpaceAfter,\n                        originalTracking: rawTracking,\n                        originalKerning: rawKerning,\n                        horizontalScale: parseFloat(style[\"@_HorizontalScale\"]) || 100,\n                        verticalScale: parseFloat(style[\"@_VerticalScale\"]) || 100,\n                        // ENHANCED: Use the new extraction method\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || \"Color/Black\",\n                        rawStyle: style\n                    };\n                    // FIXED: Apply unit conversion to create pixel-converted style\n                    this.styles.paragraph[style[\"@_Self\"]] = this.convertStyleMeasurementsToPixels(baseStyle);\n                    console.log(\"✅ Paragraph Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.ParagraphStyleGroup) {\n                const subGroups = Array.isArray(group.ParagraphStyleGroup) ? group.ParagraphStyleGroup : [\n                    group.ParagraphStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    extractFontFromStyle(style) {\n        // Try direct attributes first\n        let fontRef = style[\"@_AppliedFont\"] || style[\"@_FontFamily\"] || style[\"@_Font\"] || \"\";\n        // If not found, try Properties nested structure\n        if (!fontRef && style.Properties) {\n            if (style.Properties.AppliedFont) {\n                fontRef = style.Properties.AppliedFont[\"#text\"] || style.Properties.AppliedFont || \"\";\n            }\n            // Also try other property variations\n            if (!fontRef && style.Properties.FontFamily) {\n                fontRef = style.Properties.FontFamily[\"#text\"] || style.Properties.FontFamily || \"\";\n            }\n        }\n        return fontRef || \"\";\n    }\n    extractCharacterStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.CharacterStyle) {\n                const styles = Array.isArray(group.CharacterStyle) ? group.CharacterStyle : [\n                    group.CharacterStyle\n                ];\n                styles.forEach((style)=>{\n                    const fontRef = this.extractFontFromStyle(style);\n                    this.styles.character[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: parseFloat(style[\"@_PointSize\"]) || null,\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || null,\n                        strokeColor: style[\"@_StrokeColor\"] || null,\n                        rawStyle: style\n                    };\n                    console.log(\"✅ Character Style: \".concat(style[\"@_Name\"], ' -> Font: \"').concat(fontRef, '\"'));\n                });\n            }\n            if (group.CharacterStyleGroup) {\n                const subGroups = Array.isArray(group.CharacterStyleGroup) ? group.CharacterStyleGroup : [\n                    group.CharacterStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    async extractFonts(fontsData) {\n        console.log(\"Extracting fonts with enhanced mapping...\");\n        const fonts = fontsData.Fonts || fontsData;\n        this.resources.fonts = {};\n        this.fontMap = new Map(); // Global font lookup map\n        if (fonts.FontFamily) {\n            const fontFamilies = Array.isArray(fonts.FontFamily) ? fonts.FontFamily : [\n                fonts.FontFamily\n            ];\n            fontFamilies.forEach((family)=>{\n                const familyInfo = {\n                    self: family[\"@_Self\"],\n                    name: family[\"@_Name\"] || \"\",\n                    fonts: []\n                };\n                if (family.Font) {\n                    const fontList = Array.isArray(family.Font) ? family.Font : [\n                        family.Font\n                    ];\n                    fontList.forEach((font)=>{\n                        const fontInfo = {\n                            self: font[\"@_Self\"],\n                            fontFamily: font[\"@_FontFamily\"] || familyInfo.name,\n                            name: font[\"@_Name\"] || \"\",\n                            postScriptName: font[\"@_PostScriptName\"] || \"\",\n                            status: font[\"@_Status\"] || \"Unknown\",\n                            fontStyleName: font[\"@_FontStyleName\"] || \"Regular\"\n                        };\n                        familyInfo.fonts.push(fontInfo);\n                        // Create multiple lookup entries for this font\n                        this.fontMap.set(font[\"@_Self\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_PostScriptName\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_Name\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_FontFamily\"], familyInfo.name);\n                        console.log(\"Font mapping: \".concat(font[\"@_Self\"], \" -> \").concat(familyInfo.name));\n                    });\n                }\n                this.resources.fonts[family[\"@_Self\"]] = familyInfo;\n            });\n        }\n        console.log(\"✅ Fonts extracted: \".concat(Object.keys(this.resources.fonts).length, \" families\"));\n        console.log(\"Font map entries: \".concat(this.fontMap.size));\n    }\n    async extractGraphics(graphicsData) {\n        console.log(\"Extracting graphics and colors...\");\n        const graphics = graphicsData.Graphic || graphicsData;\n        this.resources.colors = {};\n        this.resources.gradients = {};\n        // Extract Colors\n        if (graphics.Color) {\n            const colors = Array.isArray(graphics.Color) ? graphics.Color : [\n                graphics.Color\n            ];\n            colors.forEach((color)=>{\n                // Extract individual channel values from attributes (if present)\n                const cyan = parseFloat(color[\"@_Cyan\"]) || 0;\n                const magenta = parseFloat(color[\"@_Magenta\"]) || 0;\n                const yellow = parseFloat(color[\"@_Yellow\"]) || 0;\n                const black = parseFloat(color[\"@_Black\"]) || 0;\n                const red = parseFloat(color[\"@_Red\"]) || 0;\n                const green = parseFloat(color[\"@_Green\"]) || 0;\n                const blue = parseFloat(color[\"@_Blue\"]) || 0;\n                // Get color space and model information\n                const colorSpace = color[\"@_Space\"] || \"CMYK\";\n                const colorModel = color[\"@_Model\"] || \"Process\";\n                const colorValue = color[\"@_ColorValue\"];\n                const colorName = color[\"@_Name\"] || \"\";\n                const colorSelf = color[\"@_Self\"] || \"\";\n                console.log(\"\\uD83C\\uDFA8 Processing color: \".concat(colorSelf));\n                console.log('   Name: \"'.concat(colorName, '\", Space: ').concat(colorSpace, \", Model: \").concat(colorModel));\n                console.log('   ColorValue: \"'.concat(colorValue, '\"'));\n                console.log(\"   Individual channels - C:\".concat(cyan, \" M:\").concat(magenta, \" Y:\").concat(yellow, \" K:\").concat(black, \" R:\").concat(red, \" G:\").concat(green, \" B:\").concat(blue));\n                // CRITICAL: Determine if this is a custom color that should use RGB ColorValue\n                const isCustomColor = this.isCustomColorName(colorSelf, colorName);\n                console.log(\"   \\uD83D\\uDD0D Is custom color: \".concat(isCustomColor));\n                // Initialize color data structure\n                let finalColorData = {\n                    self: colorSelf,\n                    name: colorName,\n                    model: colorModel,\n                    space: colorSpace,\n                    cyan: 0,\n                    magenta: 0,\n                    yellow: 0,\n                    black: 0,\n                    red: 0,\n                    green: 0,\n                    blue: 0,\n                    // Additional fields to track color source\n                    colorSource: \"unknown\",\n                    hasDirectRGB: false,\n                    hasDirectCMYK: false,\n                    hasColorValue: !!colorValue,\n                    isCustomColor: isCustomColor\n                };\n                // STRATEGY 1: Check for direct RGB values in individual attributes\n                if (red > 0 || green > 0 || blue > 0) {\n                    console.log(\"   ✅ Using direct RGB from individual channels: R:\".concat(red, \" G:\").concat(green, \" B:\").concat(blue));\n                    finalColorData.red = red;\n                    finalColorData.green = green;\n                    finalColorData.blue = blue;\n                    finalColorData.colorSource = \"direct_rgb_channels\";\n                    finalColorData.hasDirectRGB = true;\n                } else if (cyan > 0 || magenta > 0 || yellow > 0 || black > 0) {\n                    console.log(\"   ✅ Using direct CMYK from individual channels: C:\".concat(cyan, \" M:\").concat(magenta, \" Y:\").concat(yellow, \" K:\").concat(black));\n                    finalColorData.cyan = cyan;\n                    finalColorData.magenta = magenta;\n                    finalColorData.yellow = yellow;\n                    finalColorData.black = black;\n                    finalColorData.colorSource = \"direct_cmyk_channels\";\n                    finalColorData.hasDirectCMYK = true;\n                } else if (colorValue && isCustomColor) {\n                    console.log('   \\uD83D\\uDD0D Parsing ColorValue for CUSTOM color: \"'.concat(colorValue, '\"'));\n                    // Split ColorValue into numeric parts\n                    const valueParts = colorValue.split(/\\s+/).map(Number).filter((v)=>!isNaN(v));\n                    if (valueParts.length === 3 && colorSpace === \"RGB\") {\n                        // RGB ColorValue: \"255 137 0\" -> R:255 G:137 B:0\n                        console.log(\"   ✅ Using RGB ColorValue for custom color: R:\".concat(valueParts[0], \" G:\").concat(valueParts[1], \" B:\").concat(valueParts[2]));\n                        finalColorData.red = valueParts[0];\n                        finalColorData.green = valueParts[1];\n                        finalColorData.blue = valueParts[2];\n                        finalColorData.colorSource = \"colorvalue_rgb_custom\";\n                        finalColorData.hasDirectRGB = true;\n                    } else if (valueParts.length === 4 && colorSpace === \"CMYK\") {\n                        // CMYK ColorValue: \"0 0 0 100\" -> C:0 M:0 Y:0 K:100\n                        console.log(\"   ✅ Using CMYK ColorValue for custom color: C:\".concat(valueParts[0], \" M:\").concat(valueParts[1], \" Y:\").concat(valueParts[2], \" K:\").concat(valueParts[3]));\n                        finalColorData.cyan = valueParts[0];\n                        finalColorData.magenta = valueParts[1];\n                        finalColorData.yellow = valueParts[2];\n                        finalColorData.black = valueParts[3];\n                        finalColorData.colorSource = \"colorvalue_cmyk_custom\";\n                        finalColorData.hasDirectCMYK = true;\n                    } else if (valueParts.length === 3) {\n                        // Assume RGB if space is unknown but we have 3 values (for custom colors)\n                        console.log(\"   ⚠️  Assuming RGB for 3-value ColorValue on custom color: R:\".concat(valueParts[0], \" G:\").concat(valueParts[1], \" B:\").concat(valueParts[2]));\n                        finalColorData.red = valueParts[0];\n                        finalColorData.green = valueParts[1];\n                        finalColorData.blue = valueParts[2];\n                        finalColorData.space = \"RGB\";\n                        finalColorData.colorSource = \"colorvalue_assumed_rgb_custom\";\n                        finalColorData.hasDirectRGB = true;\n                    } else {\n                        console.log('   ⚠️  Could not parse ColorValue for custom color: \"'.concat(colorValue, '\" (').concat(valueParts.length, \" parts)\"));\n                        finalColorData.colorSource = \"colorvalue_unparseable_custom\";\n                    }\n                } else if (colorValue && !isCustomColor) {\n                    console.log('   \\uD83D\\uDD0D Parsing ColorValue for STANDARD color: \"'.concat(colorValue, '\"'));\n                    // Split ColorValue into numeric parts\n                    const valueParts = colorValue.split(/\\s+/).map(Number).filter((v)=>!isNaN(v));\n                    if (valueParts.length === 4 && colorSpace === \"CMYK\") {\n                        // Only use CMYK ColorValue for standard colors, ignore RGB ColorValue\n                        console.log(\"   ✅ Using CMYK ColorValue for standard color: C:\".concat(valueParts[0], \" M:\").concat(valueParts[1], \" Y:\").concat(valueParts[2], \" K:\").concat(valueParts[3]));\n                        finalColorData.cyan = valueParts[0];\n                        finalColorData.magenta = valueParts[1];\n                        finalColorData.yellow = valueParts[2];\n                        finalColorData.black = valueParts[3];\n                        finalColorData.colorSource = \"colorvalue_cmyk_standard\";\n                        finalColorData.hasDirectCMYK = true;\n                    } else if (valueParts.length === 3 && colorSpace === \"RGB\") {\n                        // Skip RGB ColorValue for standard colors to avoid \"0 0 0\" issues\n                        console.log('   ⚠️  Skipping RGB ColorValue for standard color (avoiding black fallback): \"'.concat(colorValue, '\"'));\n                        finalColorData.colorSource = \"colorvalue_rgb_skipped_standard\";\n                    } else {\n                        console.log('   ⚠️  Could not parse ColorValue for standard color: \"'.concat(colorValue, '\" (').concat(valueParts.length, \" parts)\"));\n                        finalColorData.colorSource = \"colorvalue_unparseable_standard\";\n                    }\n                }\n                // STRATEGY 5: Handle special color types (fallback)\n                if (finalColorData.colorSource === \"unknown\") {\n                    console.log(\"   \\uD83D\\uDD04 Using fallback handling for color: \".concat(colorSelf));\n                    finalColorData.colorSource = \"fallback\";\n                    // For standard colors with no data, don't store them at all\n                    // This will cause them to fall through to the gray fallback in ColorUtils\n                    if (!isCustomColor && finalColorData.cyan === 0 && finalColorData.magenta === 0 && finalColorData.yellow === 0 && finalColorData.black === 0 && finalColorData.red === 0 && finalColorData.green === 0 && finalColorData.blue === 0) {\n                        console.log(\"   ⚠️  Standard color with no valid data - skipping storage to allow gray fallback\");\n                        return; // Skip storing this color completely\n                    }\n                }\n                // Store the color data\n                this.resources.colors[colorSelf] = finalColorData;\n                console.log(\"   \\uD83D\\uDCBE Stored color data:\", {\n                    self: finalColorData.self,\n                    source: finalColorData.colorSource,\n                    hasRGB: finalColorData.hasDirectRGB,\n                    hasCMYK: finalColorData.hasDirectCMYK,\n                    isCustom: finalColorData.isCustomColor,\n                    rgb: \"\".concat(finalColorData.red, \",\").concat(finalColorData.green, \",\").concat(finalColorData.blue),\n                    cmyk: \"\".concat(finalColorData.cyan, \",\").concat(finalColorData.magenta, \",\").concat(finalColorData.yellow, \",\").concat(finalColorData.black)\n                });\n            });\n        }\n        // Extract Gradients\n        if (graphics.Gradient) {\n            const gradients = Array.isArray(graphics.Gradient) ? graphics.Gradient : [\n                graphics.Gradient\n            ];\n            gradients.forEach((gradient)=>{\n                this.resources.gradients[gradient[\"@_Self\"]] = {\n                    self: gradient[\"@_Self\"],\n                    name: gradient[\"@_Name\"] || \"\",\n                    type: gradient[\"@_Type\"] || \"Linear\",\n                    gradientStops: this.extractGradientStops(gradient)\n                };\n            });\n        }\n        console.log(\"✅ Graphics extraction complete. Colors: \".concat(Object.keys(this.resources.colors).length, \", Gradients: \").concat(Object.keys(this.resources.gradients).length));\n    }\n    // NEW METHOD: Determine if a color is custom and should use RGB ColorValue\n    isCustomColorName(colorSelf, colorName) {\n        // Standard/predefined InDesign colors that should NOT use RGB ColorValue\n        const standardColors = [\n            \"Color/Black\",\n            \"Color/White\",\n            \"Color/Red\",\n            \"Color/Green\",\n            \"Color/Blue\",\n            \"Color/Cyan\",\n            \"Color/Magenta\",\n            \"Color/Yellow\",\n            \"Color/Paper\",\n            \"Color/Registration\",\n            \"Color/None\"\n        ];\n        // Standard color patterns (CMYK values in the name)\n        const cmykPattern = /Color\\/C=[\\d.]+\\s*M=[\\d.]+\\s*Y=[\\d.]+\\s*K=[\\d.]+/;\n        const rgbPattern = /Color\\/R=[\\d.]+\\s*G=[\\d.]+\\s*B=[\\d.]+/;\n        // Check if it's a standard color\n        if (standardColors.includes(colorSelf)) {\n            return false;\n        }\n        // Check if it follows CMYK or RGB pattern (these are auto-generated, not custom)\n        if (cmykPattern.test(colorSelf) || rgbPattern.test(colorSelf)) {\n            return false;\n        }\n        // Check for hidden/system colors\n        if (colorSelf.includes(\"/u\") && /\\/u\\d+$/.test(colorSelf)) {\n            return false;\n        }\n        // If color name is generic or empty, it's likely not custom\n        if (!colorName || colorName === \"\" || colorName === \"$ID/\") {\n            return false;\n        }\n        // Custom colors typically have meaningful names like \"Main\", \"Brand\", \"Accent\", etc.\n        const customColorPatterns = [\n            /main/i,\n            /brand/i,\n            /accent/i,\n            /primary/i,\n            /secondary/i,\n            /theme/i,\n            /custom/i\n        ];\n        // Check if the name matches custom patterns\n        const hasCustomPattern = customColorPatterns.some((pattern)=>pattern.test(colorName) || pattern.test(colorSelf));\n        if (hasCustomPattern) {\n            return true;\n        }\n        // If it's not a standard color and has a meaningful name, consider it custom\n        return colorName.length > 2 && !colorName.includes(\"$ID/\");\n    }\n    extractGradientStops(gradient) {\n        const stops = [];\n        if (gradient.GradientStop) {\n            const stopList = Array.isArray(gradient.GradientStop) ? gradient.GradientStop : [\n                gradient.GradientStop\n            ];\n            stopList.forEach((stop)=>{\n                stops.push({\n                    self: stop[\"@_Self\"],\n                    stopColor: stop[\"@_StopColor\"] || \"\",\n                    location: parseFloat(stop[\"@_Location\"]) || 0,\n                    midpoint: parseFloat(stop[\"@_Midpoint\"]) || 50\n                });\n            });\n        }\n        return stops;\n    }\n    async extractPreferences(preferencesData) {\n        console.log(\"Extracting document preferences...\");\n        const prefs = preferencesData.Preferences || preferencesData;\n        // Extract various document preferences\n        this.documentInfo = {\n            preferences: {\n                documentPreferences: this.extractDocumentPrefs(prefs.DocumentPreference),\n                viewPreferences: this.extractViewPrefs(prefs.ViewPreference),\n                guidePreferences: this.extractGuidePrefs(prefs.GuidePreference),\n                gridPreferences: this.extractGridPrefs(prefs.GridPreference),\n                marginPreferences: this.extractMarginPrefs(prefs.MarginPreference),\n                columnPreferences: this.extractColumnPrefs(prefs.ColumnPreference)\n            }\n        };\n    }\n    extractDocumentPrefs(docPref) {\n        if (!docPref) return {};\n        return {\n            pageWidth: parseFloat(docPref[\"@_PageWidth\"]) || 0,\n            pageHeight: parseFloat(docPref[\"@_PageHeight\"]) || 0,\n            left: parseFloat(docPref[\"@_Left\"]) || 0,\n            top: parseFloat(docPref[\"@_Top\"]) || 0,\n            right: parseFloat(docPref[\"@_Right\"]) || 0,\n            bottom: parseFloat(docPref[\"@_Bottom\"]) || 0,\n            columnCount: parseInt(docPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(docPref[\"@_ColumnGutter\"]) || 0,\n            facingPages: docPref[\"@_FacingPages\"] === true,\n            allowPageShuffle: docPref[\"@_AllowPageShuffle\"] !== false,\n            slugBleedType: docPref[\"@_SlugBleedType\"] || \"None\",\n            documentBleedTopOffset: parseFloat(docPref[\"@_DocumentBleedTopOffset\"]) || 0,\n            documentBleedBottomOffset: parseFloat(docPref[\"@_DocumentBleedBottomOffset\"]) || 0,\n            documentBleedInsideOrLeftOffset: parseFloat(docPref[\"@_DocumentBleedInsideOrLeftOffset\"]) || 0,\n            documentBleedOutsideOrRightOffset: parseFloat(docPref[\"@_DocumentBleedOutsideOrRightOffset\"]) || 0\n        };\n    }\n    extractViewPrefs(viewPref) {\n        if (!viewPref) return {};\n        return {\n            horizontalMeasurementUnits: viewPref[\"@_HorizontalMeasurementUnits\"] || \"Points\",\n            verticalMeasurementUnits: viewPref[\"@_VerticalMeasurementUnits\"] || \"Points\",\n            rulerOrigin: viewPref[\"@_RulerOrigin\"] || \"SpreadOrigin\",\n            showRulers: viewPref[\"@_ShowRulers\"] !== false\n        };\n    }\n    extractGuidePrefs(guidePref) {\n        if (!guidePref) return {};\n        return {\n            rulerGuideColor: guidePref[\"@_RulerGuideColor\"] || \"Green\",\n            guidesInBack: guidePref[\"@_GuidesInBack\"] === true,\n            guidesLocked: guidePref[\"@_GuidesLocked\"] === true,\n            guidesShown: guidePref[\"@_GuidesShown\"] !== false,\n            guidesSnapto: guidePref[\"@_GuidesSnapto\"] !== false\n        };\n    }\n    extractGridPrefs(gridPref) {\n        if (!gridPref) return {};\n        return {\n            baselineStart: parseFloat(gridPref[\"@_BaselineStart\"]) || 0,\n            baselineDivision: parseFloat(gridPref[\"@_BaselineDivision\"]) || 12,\n            baselineShown: gridPref[\"@_BaselineShown\"] === true,\n            baselineSnapto: gridPref[\"@_BaselineSnapto\"] === true,\n            documentGridShown: gridPref[\"@_DocumentGridShown\"] === true,\n            documentGridSnapto: gridPref[\"@_DocumentGridSnapto\"] === true\n        };\n    }\n    extractMarginPrefs(marginPref) {\n        if (!marginPref) return {};\n        return {\n            top: parseFloat(marginPref[\"@_Top\"]) || 0,\n            bottom: parseFloat(marginPref[\"@_Bottom\"]) || 0,\n            left: parseFloat(marginPref[\"@_Left\"]) || 0,\n            right: parseFloat(marginPref[\"@_Right\"]) || 0,\n            columnCount: parseInt(marginPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(marginPref[\"@_ColumnGutter\"]) || 0\n        };\n    }\n    extractColumnPrefs(columnPref) {\n        if (!columnPref) return {};\n        return {\n            textColumnCount: parseInt(columnPref[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(columnPref[\"@_TextColumnGutter\"]) || 0\n        };\n    }\n    resolveStyleFormatting(formatting) {\n        const resolved = {\n            ...formatting\n        };\n        // DEBUG: Check if formatting is being applied (generic check)\n        const hasAnyFormatting = formatting.paragraphStyle || formatting.characterStyle || formatting.fontStyle || formatting.fontReference || formatting.fontSize;\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Input:\", {\n                paragraphStyle: formatting.paragraphStyle,\n                characterStyle: formatting.characterStyle,\n                directFontStyle: formatting.fontStyle,\n                directFontRef: formatting.fontReference,\n                directFontSize: formatting.fontSize\n            });\n        }\n        // Resolve paragraph style (base layer)\n        if (formatting.paragraphStyle && this.styles.paragraph[formatting.paragraphStyle]) {\n            const pStyle = this.styles.paragraph[formatting.paragraphStyle];\n            if (!resolved.fontSize && pStyle.pointSize) resolved.fontSize = pStyle.pointSize;\n            if (!resolved.fillColor && pStyle.fillColor) resolved.fillColor = pStyle.fillColor;\n            // CRITICAL FIX: Always inherit paragraph alignment unless explicitly overridden\n            if (pStyle.alignment) resolved.alignment = pStyle.alignment;\n            if (!resolved.fontStyle && pStyle.fontStyle) {\n                resolved.fontStyle = pStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from paragraph style: \"'.concat(pStyle.fontStyle, '\"'));\n                }\n            }\n            // CRITICAL: Resolve font from paragraph style\n            if (!resolved.fontFamily && pStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(pStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from paragraph style: \".concat(pStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n            // Add other paragraph properties with enhanced leading support\n            resolved.leading = pStyle.leading;\n            resolved.leadingType = pStyle.leadingType;\n            resolved.effectiveLineHeight = pStyle.effectiveLineHeight;\n            resolved.leftIndent = pStyle.leftIndent;\n            resolved.rightIndent = pStyle.rightIndent;\n            resolved.firstLineIndent = pStyle.firstLineIndent;\n            resolved.spaceBefore = pStyle.spaceBefore;\n            resolved.spaceAfter = pStyle.spaceAfter;\n            resolved.tracking = pStyle.tracking;\n            resolved.kerning = pStyle.kerning;\n        }\n        // Resolve character style (override layer)\n        if (formatting.characterStyle && this.styles.character[formatting.characterStyle]) {\n            const cStyle = this.styles.character[formatting.characterStyle];\n            if (cStyle.pointSize) resolved.fontSize = cStyle.pointSize;\n            if (cStyle.fillColor) resolved.fillColor = cStyle.fillColor;\n            if (cStyle.fontStyle) {\n                resolved.fontStyle = cStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log('   FontStyle from character style: \"'.concat(cStyle.fontStyle, '\"'));\n                }\n            }\n            if (cStyle.strokeColor) resolved.strokeColor = cStyle.strokeColor;\n            // Include leading information from character style\n            if (cStyle.leading) resolved.leading = cStyle.leading;\n            if (cStyle.leadingType) resolved.leadingType = cStyle.leadingType;\n            if (cStyle.effectiveLineHeight) resolved.effectiveLineHeight = cStyle.effectiveLineHeight;\n            // CRITICAL: Character style font overrides paragraph style\n            if (cStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(cStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(\"   Font from character style: \".concat(cStyle.appliedFont, \" -> \").concat(resolved.fontFamily));\n                }\n            }\n        }\n        // Apply direct formatting (highest priority)\n        if (formatting.fontReference) {\n            resolved.fontFamily = this.resolveFontReference(formatting.fontReference);\n            if (hasAnyFormatting) {\n                console.log(\"   Font from direct formatting: \".concat(formatting.fontReference, \" -> \").concat(resolved.fontFamily));\n            }\n        }\n        // CRITICAL: Apply direct fontStyle if provided (this might be the issue)\n        if (formatting.fontStyle) {\n            resolved.fontStyle = formatting.fontStyle;\n            if (hasAnyFormatting) {\n                console.log('   FontStyle from direct formatting: \"'.concat(formatting.fontStyle, '\"'));\n            }\n        }\n        // Apply direct leading information (highest priority)\n        if (formatting.leading !== undefined) resolved.leading = formatting.leading;\n        if (formatting.leadingType) resolved.leadingType = formatting.leadingType;\n        if (formatting.effectiveLineHeight) resolved.effectiveLineHeight = formatting.effectiveLineHeight;\n        // Apply other direct formatting attributes\n        if (formatting.fontSize) resolved.fontSize = formatting.fontSize;\n        if (formatting.tracking) resolved.tracking = formatting.tracking;\n        if (formatting.kerning) resolved.kerning = formatting.kerning;\n        // CRITICAL FIX: Apply direct alignment if explicitly specified (overrides paragraph alignment)\n        if (formatting.alignment) {\n            resolved.alignment = formatting.alignment;\n            if (hasAnyFormatting) {\n                console.log('   Alignment from direct formatting: \"'.concat(formatting.alignment, '\"'));\n            }\n        }\n        // FIXED: Ensure fontStyle defaults to Regular/normal if not set\n        if (!resolved.fontStyle || resolved.fontStyle === \"\") {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log('   FontStyle defaulted to: \"Regular\"');\n            }\n        }\n        // ADDITIONAL FIX: If no styles were applied from any source, ensure clean defaults\n        if (!formatting.paragraphStyle && !formatting.characterStyle && !formatting.fontStyle && !formatting.fontReference) {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log(\"   No source styles found - ensuring clean defaults\");\n            }\n        }\n        // Final fallback\n        if (!resolved.fontFamily || resolved.fontFamily === \"\") {\n            resolved.fontFamily = this.getDefaultFont();\n            if (hasAnyFormatting) {\n                console.log(\"   Using fallback font: \".concat(resolved.fontFamily));\n            }\n        }\n        // Ensure line height is calculated if not explicitly set\n        if (!resolved.effectiveLineHeight && resolved.fontSize && resolved.leading) {\n            resolved.effectiveLineHeight = this.calculateEffectiveLineHeight(resolved.leading, resolved.fontSize);\n        }\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Final Output:\", {\n                fontSize: resolved.fontSize,\n                fontFamily: resolved.fontFamily,\n                fontStyle: resolved.fontStyle,\n                fillColor: resolved.fillColor,\n                leading: resolved.leading,\n                effectiveLineHeight: resolved.effectiveLineHeight\n            });\n        }\n        return resolved;\n    }\n    resolveFontReference(fontRef) {\n        if (!fontRef || fontRef === \"\") {\n            console.log(\"Empty font reference, using fallback\");\n            return this.getDefaultFont();\n        }\n        // Try direct lookup in font map\n        if (this.fontMap && this.fontMap.has(fontRef)) {\n            const resolvedFont = this.fontMap.get(fontRef);\n            console.log('Font resolved: \"'.concat(fontRef, '\" -> \"').concat(resolvedFont, '\"'));\n            return resolvedFont;\n        }\n        // Try partial matching for font families\n        if (this.resources.fonts) {\n            for (const [familyId, familyInfo] of Object.entries(this.resources.fonts)){\n                // Check family name match\n                if (familyInfo.name && (familyInfo.name.toLowerCase().includes(fontRef.toLowerCase()) || fontRef.toLowerCase().includes(familyInfo.name.toLowerCase()))) {\n                    console.log('Font partially matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                    return familyInfo.name;\n                }\n                // Check individual font matches\n                if (familyInfo.fonts) {\n                    for (const font of familyInfo.fonts){\n                        if (font.self === fontRef || font.postScriptName === fontRef || font.name === fontRef) {\n                            console.log('Font exactly matched: \"'.concat(fontRef, '\" -> \"').concat(familyInfo.name, '\"'));\n                            return familyInfo.name;\n                        }\n                    }\n                }\n            }\n        }\n        console.log('Font not found: \"'.concat(fontRef, '\", using fallback'));\n        return this.getDefaultFont() || fontRef;\n    }\n    getDefaultFont() {\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFamily = Object.values(this.resources.fonts)[0];\n            return firstFamily.name || \"Arial\";\n        }\n        return \"Arial\";\n    }\n    inferFontFromContext() {\n        // If we have font definitions but no explicit references,\n        // return the first available font as a fallback\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFontFamily = Object.values(this.resources.fonts)[0];\n            return firstFontFamily.name;\n        }\n        return null;\n    }\n    getStoryStyleSummary(story) {\n        var _story_content_formattedContent, _story_content;\n        const summary = {\n            fontSize: null,\n            fontFamily: null,\n            alignment: null,\n            fillColor: null,\n            fontStyle: null,\n            leading: null,\n            leadingType: null,\n            effectiveLineHeight: null,\n            tracking: null,\n            kerning: null\n        };\n        // Get the most common or first formatting values\n        if (((_story_content = story.content) === null || _story_content === void 0 ? void 0 : (_story_content_formattedContent = _story_content.formattedContent) === null || _story_content_formattedContent === void 0 ? void 0 : _story_content_formattedContent.length) > 0) {\n            const firstFormatted = story.content.formattedContent.find((item)=>item.formatting && !item.formatting.isBreak);\n            if (firstFormatted === null || firstFormatted === void 0 ? void 0 : firstFormatted.formatting) {\n                const fmt = firstFormatted.formatting;\n                summary.fontSize = fmt.fontSize;\n                summary.fontFamily = fmt.fontFamily;\n                summary.alignment = fmt.alignment;\n                summary.fillColor = fmt.fillColor;\n                summary.fontStyle = fmt.fontStyle;\n                summary.leading = fmt.leading;\n                summary.leadingType = fmt.leadingType;\n                summary.effectiveLineHeight = fmt.effectiveLineHeight;\n                summary.tracking = fmt.tracking;\n                summary.kerning = fmt.kerning;\n            }\n        }\n        return summary;\n    }\n    // NEW: Process leading values with InDesign-specific logic (shared with StoryParser)\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = parseFloat(rawLeading);\n        if (!isNaN(numericLeading)) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (!isNaN(parseFloat(rawLeading))) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(leading, fontSize) {\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\" && fontSize) {\n            // Convert points to CSS line-height ratio\n            return Math.max(0.8, leading / fontSize); // Ensure minimum line height\n        }\n        return 1.2; // Fallback\n    }\n    getStyles() {\n        return this.styles;\n    }\n    getResources() {\n        return this.resources;\n    }\n    getFontMap() {\n        return this.fontMap;\n    }\n    // Add methods to return style and font definitions for debug\n    getParagraphStyles() {\n        return this.styles.paragraph;\n    }\n    getCharacterStyles() {\n        return this.styles.character;\n    }\n    getFontDefinitions() {\n        // Prefer plain object for debug output\n        if (this.resources && this.resources.fonts) {\n            return this.resources.fonts;\n        }\n        // Fallback: convert fontMap to object\n        if (this.fontMap && typeof this.fontMap.entries === \"function\") {\n            return Object.fromEntries(this.fontMap.entries());\n        }\n        return {};\n    }\n    // FIXED: Add method to access document preferences including ViewPreferences\n    getDocumentInfo() {\n        return this.documentInfo;\n    }\n    constructor(unitConverter = null){\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n        this.resources = {\n            fonts: {},\n            colors: {},\n            gradients: {}\n        };\n        this.fontMap = new Map(); // Global font lookup map\n        this.unitConverter = unitConverter; // ADDED: Unit converter for typography measurements\n        this.documentUnits = null; // Will be set from document units\n    }\n}\nmodule.exports = StyleParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTyxDQUFDO1lBQ1JDLE1BQU0sQ0FBQztRQUNUO1FBQ0EsSUFBSSxDQUFDaE0sU0FBUyxHQUFHO1lBQ2ZGLE9BQU8sQ0FBQztZQUNSeUIsUUFBUSxDQUFDO1lBQ1RDLFdBQVcsQ0FBQztRQUNkO1FBQ0EsSUFBSSxDQUFDdkIsT0FBTyxHQUFHLElBQUlDLE9BQU8seUJBQXlCO1FBQ25ELElBQUksQ0FBQ2xHLGFBQWEsR0FBR0EsZUFBZSxvREFBb0Q7UUFDeEYsSUFBSSxDQUFDTixhQUFhLEdBQUcsTUFBTSxrQ0FBa0M7SUFDL0Q7QUFrb0NGO0FBRUF1UyxPQUFPQyxPQUFPLEdBQUczUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGFyc2Vycy9TdHlsZVBhcnNlci5qcz82OWFjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9JRE1MVXRpbHNcIik7XG5cbmNsYXNzIFN0eWxlUGFyc2VyIHtcbiAgY29uc3RydWN0b3IodW5pdENvbnZlcnRlciA9IG51bGwpIHtcbiAgICB0aGlzLnN0eWxlcyA9IHtcbiAgICAgIHBhcmFncmFwaDoge30sXG4gICAgICBjaGFyYWN0ZXI6IHt9LFxuICAgICAgb2JqZWN0OiB7fSxcbiAgICAgIHRhYmxlOiB7fSxcbiAgICAgIGNlbGw6IHt9LFxuICAgIH07XG4gICAgdGhpcy5yZXNvdXJjZXMgPSB7XG4gICAgICBmb250czoge30sXG4gICAgICBjb2xvcnM6IHt9LFxuICAgICAgZ3JhZGllbnRzOiB7fSxcbiAgICB9O1xuICAgIHRoaXMuZm9udE1hcCA9IG5ldyBNYXAoKTsgLy8gR2xvYmFsIGZvbnQgbG9va3VwIG1hcFxuICAgIHRoaXMudW5pdENvbnZlcnRlciA9IHVuaXRDb252ZXJ0ZXI7IC8vIEFEREVEOiBVbml0IGNvbnZlcnRlciBmb3IgdHlwb2dyYXBoeSBtZWFzdXJlbWVudHNcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSBudWxsOyAvLyBXaWxsIGJlIHNldCBmcm9tIGRvY3VtZW50IHVuaXRzXG4gIH1cblxuICAvLyBBRERFRDogTWV0aG9kIHRvIHNldCBkb2N1bWVudCB1bml0cyBmb3IgdHlwb2dyYXBoeSBjb252ZXJzaW9uXG4gIHNldERvY3VtZW50VW5pdHModW5pdHMpIHtcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSB1bml0cztcbiAgICBjb25zb2xlLmxvZyhcIvCfk5AgU3R5bGVQYXJzZXI6IFNldCBkb2N1bWVudCB1bml0cyB0b1wiLCB1bml0cyk7XG4gIH1cblxuICAvLyBBRERFRDogTWV0aG9kIHRvIGNvbnZlcnQgdHlwb2dyYXBoeSBtZWFzdXJlbWVudHMgdG8gcGl4ZWxzXG4gIGNvbnZlcnRUeXBvZ3JhcGh5VG9QaXhlbHModmFsdWUpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgIGlzTmFOKHZhbHVlKSB8fFxuICAgICAgIXRoaXMudW5pdENvbnZlcnRlciB8fFxuICAgICAgIXRoaXMuZG9jdW1lbnRVbml0c1xuICAgICkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIE9ubHkgY29udmVydCBpZiB3ZSBoYXZlIGEgc3VwcG9ydGVkIHVuaXQgYW5kIGl0J3Mgbm90IGFscmVhZHkgcGl4ZWxzXG4gICAgaWYgKHRoaXMudW5pdENvbnZlcnRlci5pc1N1cHBvcnRlZFVuaXQodGhpcy5kb2N1bWVudFVuaXRzKSkge1xuICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSB0aGlzLnVuaXRDb252ZXJ0ZXIudG9QaXhlbHMoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0aGlzLmRvY3VtZW50VW5pdHNcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCfk5AgQ29udmVydGVkIHR5cG9ncmFwaHk6ICR7dmFsdWV9ICR7dGhpcy5kb2N1bWVudFVuaXRzfSDihpIgJHtjb252ZXJ0ZWRWYWx1ZX0gcHhgXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbnZlcnRlZFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gY29udmVydCBhbiBlbnRpcmUgc3R5bGUgb2JqZWN0J3MgbWVhc3VyZW1lbnRzIHRvIHBpeGVsc1xuICBjb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyhzdHlsZSkge1xuICAgIGlmICghdGhpcy51bml0Q29udmVydGVyIHx8ICF0aGlzLmRvY3VtZW50VW5pdHMpIHtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICBjb25zdCBjb252ZXJ0ZWRTdHlsZSA9IHsgLi4uc3R5bGUgfTtcblxuICAgIC8vIENvbnZlcnQgbWVhc3VyZW1lbnRzIHRoYXQgbmVlZCBwaXhlbCBjb252ZXJzaW9uXG4gICAgY29uc3QgbWVhc3VyZW1lbnRGaWVsZHMgPSBbXG4gICAgICBcImxlZnRJbmRlbnRcIixcbiAgICAgIFwicmlnaHRJbmRlbnRcIixcbiAgICAgIFwiZmlyc3RMaW5lSW5kZW50XCIsXG4gICAgICBcInNwYWNlQmVmb3JlXCIsXG4gICAgICBcInNwYWNlQWZ0ZXJcIixcbiAgICAgIFwidHJhY2tpbmdcIixcbiAgICAgIFwia2VybmluZ1wiLFxuICAgIF07XG5cbiAgICBtZWFzdXJlbWVudEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjb252ZXJ0ZWRTdHlsZVtmaWVsZF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29udmVydGVkU3R5bGVbZmllbGRdID0gdGhpcy5jb252ZXJ0VHlwb2dyYXBoeVRvUGl4ZWxzKFxuICAgICAgICAgIGNvbnZlcnRlZFN0eWxlW2ZpZWxkXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ29udmVydCBsZWFkaW5nIGlmIGl0J3MgYSBudW1lcmljIHZhbHVlXG4gICAgaWYgKHR5cGVvZiBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nID0gdGhpcy5jb252ZXJ0VHlwb2dyYXBoeVRvUGl4ZWxzKFxuICAgICAgICBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0ZWRTdHlsZTtcbiAgfVxuXG4gIGFzeW5jIHBhcnNlUmVzb3VyY2VGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpIHtcbiAgICBjb25zb2xlLmxvZyhg8J+TiyBQYXJzaW5nIHJlc291cmNlOiAke2ZpbGVOYW1lfWApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcbiAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUsIFwiLnhtbFwiKTtcblxuICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCByZXNvdXJjZSB0eXBlc1xuICAgICAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKFwiU3R5bGVzLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RTdHlsZXMocGFyc2VkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoXCJGb250cy54bWxcIikpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0Rm9udHMocGFyc2VkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoXCJHcmFwaGljLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RHcmFwaGljcyhwYXJzZWQpO1xuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhcIlByZWZlcmVuY2VzLnhtbFwiKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RQcmVmZXJlbmNlcyhwYXJzZWQpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFJlc291cmNlICR7cmVzb3VyY2VOYW1lfSBwYXJzZWRgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHBhcnNpbmcgJHtmaWxlTmFtZX06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZXh0cmFjdFN0eWxlcyhzdHlsZXNEYXRhKSB7XG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIHN0eWxlcy4uLlwiKTtcblxuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlc0RhdGEuU3R5bGVzIHx8IHN0eWxlc0RhdGE7XG5cbiAgICAvLyBFeHRyYWN0IFBhcmFncmFwaCBTdHlsZXNcbiAgICBpZiAoc3R5bGVzLlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XG4gICAgICB0aGlzLmV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMoc3R5bGVzLlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwKTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IENoYXJhY3RlciBTdHlsZXNcbiAgICBpZiAoc3R5bGVzLlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwKSB7XG4gICAgICB0aGlzLmV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVzLlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwKTtcbiAgICB9XG4gIH1cblxuICBleHRyYWN0UGFyYWdyYXBoU3R5bGVzKHN0eWxlR3JvdXApIHtcbiAgICBjb25zdCBleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkgPSAoZ3JvdXApID0+IHtcbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZSkge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBBcnJheS5pc0FycmF5KGdyb3VwLlBhcmFncmFwaFN0eWxlKVxuICAgICAgICAgID8gZ3JvdXAuUGFyYWdyYXBoU3R5bGVcbiAgICAgICAgICA6IFtncm91cC5QYXJhZ3JhcGhTdHlsZV07XG5cbiAgICAgICAgc3R5bGVzLmZvckVhY2goKHN0eWxlKSA9PiB7XG4gICAgICAgICAgLy8gQ1JJVElDQUw6IEV4dHJhY3QgZm9udCByZWZlcmVuY2UgZnJvbSBtdWx0aXBsZSBwb3NzaWJsZSBsb2NhdGlvbnNcbiAgICAgICAgICBjb25zdCBmb250UmVmID0gdGhpcy5leHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSk7XG5cbiAgICAgICAgICAvLyBFTkhBTkNFRDogUHJvY2VzcyBsZWFkaW5nIHdpdGggcHJvcGVyIEluRGVzaWduIGxvZ2ljXG4gICAgICAgICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9Qb2ludFNpemVcIl0pIHx8IDEyO1xuICAgICAgICAgIGNvbnN0IHJhd0xlYWRpbmcgPSBzdHlsZVtcIkBfTGVhZGluZ1wiXTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzZWRMZWFkaW5nID0gdGhpcy5wcm9jZXNzTGVhZGluZ1ZhbHVlKFxuICAgICAgICAgICAgcmF3TGVhZGluZyxcbiAgICAgICAgICAgIGZvbnRTaXplXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIEZJWEVEOiBFeHRyYWN0IHJhdyB0eXBvZ3JhcGh5IG1lYXN1cmVtZW50cyBmb3IgY29udmVyc2lvblxuICAgICAgICAgIGNvbnN0IHJhd0xlZnRJbmRlbnQgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9MZWZ0SW5kZW50XCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1JpZ2h0SW5kZW50ID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfUmlnaHRJbmRlbnRcIl0pIHx8IDA7XG4gICAgICAgICAgY29uc3QgcmF3Rmlyc3RMaW5lSW5kZW50ID1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoc3R5bGVbXCJAX0ZpcnN0TGluZUluZGVudFwiXSkgfHwgMDtcbiAgICAgICAgICBjb25zdCByYXdTcGFjZUJlZm9yZSA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1NwYWNlQmVmb3JlXCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1NwYWNlQWZ0ZXIgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9TcGFjZUFmdGVyXCJdKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHJhd1RyYWNraW5nID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfVHJhY2tpbmdcIl0pIHx8IDA7XG4gICAgICAgICAgY29uc3QgcmF3S2VybmluZyA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX0tlcm5pbmdcIl0pIHx8IDA7XG5cbiAgICAgICAgICAvLyBGSVhFRDogQ3JlYXRlIGJhc2Ugc3R5bGUgb2JqZWN0IHdpdGggcmF3IHZhbHVlc1xuICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHtcbiAgICAgICAgICAgIHNlbGY6IHN0eWxlW1wiQF9TZWxmXCJdLFxuICAgICAgICAgICAgbmFtZTogc3R5bGVbXCJAX05hbWVcIl0gfHwgXCJcIixcbiAgICAgICAgICAgIGZvbnRTdHlsZTogc3R5bGVbXCJAX0ZvbnRTdHlsZVwiXSB8fCBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgIHBvaW50U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgICBsZWFkaW5nOiBwcm9jZXNzZWRMZWFkaW5nLFxuICAgICAgICAgICAgbGVhZGluZ1R5cGU6IHRoaXMuZGV0ZXJtaW5lTGVhZGluZ1R5cGUocmF3TGVhZGluZyksXG4gICAgICAgICAgICBlZmZlY3RpdmVMaW5lSGVpZ2h0OiB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoXG4gICAgICAgICAgICAgIHByb2Nlc3NlZExlYWRpbmcsXG4gICAgICAgICAgICAgIGZvbnRTaXplXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYWxpZ25tZW50OiBzdHlsZVtcIkBfSnVzdGlmaWNhdGlvblwiXSB8fCBcIkxlZnRBbGlnblwiLFxuXG4gICAgICAgICAgICAvLyBSYXcgbWVhc3VyZW1lbnRzICh3aWxsIGJlIGNvbnZlcnRlZCB0byBwaXhlbHMpXG4gICAgICAgICAgICBsZWZ0SW5kZW50OiByYXdMZWZ0SW5kZW50LFxuICAgICAgICAgICAgcmlnaHRJbmRlbnQ6IHJhd1JpZ2h0SW5kZW50LFxuICAgICAgICAgICAgZmlyc3RMaW5lSW5kZW50OiByYXdGaXJzdExpbmVJbmRlbnQsXG4gICAgICAgICAgICBzcGFjZUJlZm9yZTogcmF3U3BhY2VCZWZvcmUsXG4gICAgICAgICAgICBzcGFjZUFmdGVyOiByYXdTcGFjZUFmdGVyLFxuICAgICAgICAgICAgdHJhY2tpbmc6IHJhd1RyYWNraW5nLFxuICAgICAgICAgICAga2VybmluZzogcmF3S2VybmluZyxcblxuICAgICAgICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgdmFsdWVzIGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgIG9yaWdpbmFsTGVmdEluZGVudDogcmF3TGVmdEluZGVudCxcbiAgICAgICAgICAgIG9yaWdpbmFsUmlnaHRJbmRlbnQ6IHJhd1JpZ2h0SW5kZW50LFxuICAgICAgICAgICAgb3JpZ2luYWxGaXJzdExpbmVJbmRlbnQ6IHJhd0ZpcnN0TGluZUluZGVudCxcbiAgICAgICAgICAgIG9yaWdpbmFsU3BhY2VCZWZvcmU6IHJhd1NwYWNlQmVmb3JlLFxuICAgICAgICAgICAgb3JpZ2luYWxTcGFjZUFmdGVyOiByYXdTcGFjZUFmdGVyLFxuICAgICAgICAgICAgb3JpZ2luYWxUcmFja2luZzogcmF3VHJhY2tpbmcsXG4gICAgICAgICAgICBvcmlnaW5hbEtlcm5pbmc6IHJhd0tlcm5pbmcsXG5cbiAgICAgICAgICAgIGhvcml6b250YWxTY2FsZTogcGFyc2VGbG9hdChzdHlsZVtcIkBfSG9yaXpvbnRhbFNjYWxlXCJdKSB8fCAxMDAsXG4gICAgICAgICAgICB2ZXJ0aWNhbFNjYWxlOiBwYXJzZUZsb2F0KHN0eWxlW1wiQF9WZXJ0aWNhbFNjYWxlXCJdKSB8fCAxMDAsXG5cbiAgICAgICAgICAgIC8vIEVOSEFOQ0VEOiBVc2UgdGhlIG5ldyBleHRyYWN0aW9uIG1ldGhvZFxuICAgICAgICAgICAgYXBwbGllZEZvbnQ6IGZvbnRSZWYsXG4gICAgICAgICAgICBvcmlnaW5hbEZvbnRSZWY6IGZvbnRSZWYsXG5cbiAgICAgICAgICAgIGZpbGxDb2xvcjogc3R5bGVbXCJAX0ZpbGxDb2xvclwiXSB8fCBcIkNvbG9yL0JsYWNrXCIsXG4gICAgICAgICAgICByYXdTdHlsZTogc3R5bGUsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEZJWEVEOiBBcHBseSB1bml0IGNvbnZlcnNpb24gdG8gY3JlYXRlIHBpeGVsLWNvbnZlcnRlZCBzdHlsZVxuICAgICAgICAgIHRoaXMuc3R5bGVzLnBhcmFncmFwaFtzdHlsZVtcIkBfU2VsZlwiXV0gPVxuICAgICAgICAgICAgdGhpcy5jb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyhiYXNlU3R5bGUpO1xuXG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBg4pyFIFBhcmFncmFwaCBTdHlsZTogJHtzdHlsZVtcIkBfTmFtZVwiXX0gLT4gRm9udDogXCIke2ZvbnRSZWZ9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN1Ykdyb3VwcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cClcbiAgICAgICAgICA/IGdyb3VwLlBhcmFncmFwaFN0eWxlR3JvdXBcbiAgICAgICAgICA6IFtncm91cC5QYXJhZ3JhcGhTdHlsZUdyb3VwXTtcbiAgICAgICAgc3ViR3JvdXBzLmZvckVhY2goZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KHN0eWxlR3JvdXApO1xuICB9XG5cbiAgZXh0cmFjdEZvbnRGcm9tU3R5bGUoc3R5bGUpIHtcbiAgICAvLyBUcnkgZGlyZWN0IGF0dHJpYnV0ZXMgZmlyc3RcbiAgICBsZXQgZm9udFJlZiA9XG4gICAgICBzdHlsZVtcIkBfQXBwbGllZEZvbnRcIl0gfHwgc3R5bGVbXCJAX0ZvbnRGYW1pbHlcIl0gfHwgc3R5bGVbXCJAX0ZvbnRcIl0gfHwgXCJcIjtcblxuICAgIC8vIElmIG5vdCBmb3VuZCwgdHJ5IFByb3BlcnRpZXMgbmVzdGVkIHN0cnVjdHVyZVxuICAgIGlmICghZm9udFJlZiAmJiBzdHlsZS5Qcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoc3R5bGUuUHJvcGVydGllcy5BcHBsaWVkRm9udCkge1xuICAgICAgICBmb250UmVmID1cbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250W1wiI3RleHRcIl0gfHxcbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkFwcGxpZWRGb250IHx8XG4gICAgICAgICAgXCJcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWxzbyB0cnkgb3RoZXIgcHJvcGVydHkgdmFyaWF0aW9uc1xuICAgICAgaWYgKCFmb250UmVmICYmIHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseSkge1xuICAgICAgICBmb250UmVmID1cbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkZvbnRGYW1pbHlbXCIjdGV4dFwiXSB8fFxuICAgICAgICAgIHN0eWxlLlByb3BlcnRpZXMuRm9udEZhbWlseSB8fFxuICAgICAgICAgIFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnRSZWYgfHwgXCJcIjtcbiAgfVxuXG4gIGV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVHcm91cCkge1xuICAgIGNvbnN0IGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSA9IChncm91cCkgPT4ge1xuICAgICAgaWYgKGdyb3VwLkNoYXJhY3RlclN0eWxlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuQ2hhcmFjdGVyU3R5bGUpXG4gICAgICAgICAgPyBncm91cC5DaGFyYWN0ZXJTdHlsZVxuICAgICAgICAgIDogW2dyb3VwLkNoYXJhY3RlclN0eWxlXTtcblxuICAgICAgICBzdHlsZXMuZm9yRWFjaCgoc3R5bGUpID0+IHtcbiAgICAgICAgICBjb25zdCBmb250UmVmID0gdGhpcy5leHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSk7XG5cbiAgICAgICAgICB0aGlzLnN0eWxlcy5jaGFyYWN0ZXJbc3R5bGVbXCJAX1NlbGZcIl1dID0ge1xuICAgICAgICAgICAgc2VsZjogc3R5bGVbXCJAX1NlbGZcIl0sXG4gICAgICAgICAgICBuYW1lOiBzdHlsZVtcIkBfTmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgICAgZm9udFN0eWxlOiBzdHlsZVtcIkBfRm9udFN0eWxlXCJdIHx8IFwiUmVndWxhclwiLFxuICAgICAgICAgICAgcG9pbnRTaXplOiBwYXJzZUZsb2F0KHN0eWxlW1wiQF9Qb2ludFNpemVcIl0pIHx8IG51bGwsXG5cbiAgICAgICAgICAgIGFwcGxpZWRGb250OiBmb250UmVmLFxuICAgICAgICAgICAgb3JpZ2luYWxGb250UmVmOiBmb250UmVmLFxuXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHN0eWxlW1wiQF9GaWxsQ29sb3JcIl0gfHwgbnVsbCxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzdHlsZVtcIkBfU3Ryb2tlQ29sb3JcIl0gfHwgbnVsbCxcbiAgICAgICAgICAgIHJhd1N0eWxlOiBzdHlsZSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBg4pyFIENoYXJhY3RlciBTdHlsZTogJHtzdHlsZVtcIkBfTmFtZVwiXX0gLT4gRm9udDogXCIke2ZvbnRSZWZ9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN1Ykdyb3VwcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuQ2hhcmFjdGVyU3R5bGVHcm91cClcbiAgICAgICAgICA/IGdyb3VwLkNoYXJhY3RlclN0eWxlR3JvdXBcbiAgICAgICAgICA6IFtncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwXTtcbiAgICAgICAgc3ViR3JvdXBzLmZvckVhY2goZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KHN0eWxlR3JvdXApO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdEZvbnRzKGZvbnRzRGF0YSkge1xuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBmb250cyB3aXRoIGVuaGFuY2VkIG1hcHBpbmcuLi5cIik7XG5cbiAgICBjb25zdCBmb250cyA9IGZvbnRzRGF0YS5Gb250cyB8fCBmb250c0RhdGE7XG4gICAgdGhpcy5yZXNvdXJjZXMuZm9udHMgPSB7fTtcbiAgICB0aGlzLmZvbnRNYXAgPSBuZXcgTWFwKCk7IC8vIEdsb2JhbCBmb250IGxvb2t1cCBtYXBcblxuICAgIGlmIChmb250cy5Gb250RmFtaWx5KSB7XG4gICAgICBjb25zdCBmb250RmFtaWxpZXMgPSBBcnJheS5pc0FycmF5KGZvbnRzLkZvbnRGYW1pbHkpXG4gICAgICAgID8gZm9udHMuRm9udEZhbWlseVxuICAgICAgICA6IFtmb250cy5Gb250RmFtaWx5XTtcblxuICAgICAgZm9udEZhbWlsaWVzLmZvckVhY2goKGZhbWlseSkgPT4ge1xuICAgICAgICBjb25zdCBmYW1pbHlJbmZvID0ge1xuICAgICAgICAgIHNlbGY6IGZhbWlseVtcIkBfU2VsZlwiXSxcbiAgICAgICAgICBuYW1lOiBmYW1pbHlbXCJAX05hbWVcIl0gfHwgXCJcIixcbiAgICAgICAgICBmb250czogW10sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZhbWlseS5Gb250KSB7XG4gICAgICAgICAgY29uc3QgZm9udExpc3QgPSBBcnJheS5pc0FycmF5KGZhbWlseS5Gb250KVxuICAgICAgICAgICAgPyBmYW1pbHkuRm9udFxuICAgICAgICAgICAgOiBbZmFtaWx5LkZvbnRdO1xuXG4gICAgICAgICAgZm9udExpc3QuZm9yRWFjaCgoZm9udCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm9udEluZm8gPSB7XG4gICAgICAgICAgICAgIHNlbGY6IGZvbnRbXCJAX1NlbGZcIl0sXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGZvbnRbXCJAX0ZvbnRGYW1pbHlcIl0gfHwgZmFtaWx5SW5mby5uYW1lLFxuICAgICAgICAgICAgICBuYW1lOiBmb250W1wiQF9OYW1lXCJdIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHBvc3RTY3JpcHROYW1lOiBmb250W1wiQF9Qb3N0U2NyaXB0TmFtZVwiXSB8fCBcIlwiLFxuICAgICAgICAgICAgICBzdGF0dXM6IGZvbnRbXCJAX1N0YXR1c1wiXSB8fCBcIlVua25vd25cIixcbiAgICAgICAgICAgICAgZm9udFN0eWxlTmFtZTogZm9udFtcIkBfRm9udFN0eWxlTmFtZVwiXSB8fCBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZhbWlseUluZm8uZm9udHMucHVzaChmb250SW5mbyk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBsb29rdXAgZW50cmllcyBmb3IgdGhpcyBmb250XG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX1NlbGZcIl0sIGZhbWlseUluZm8ubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX1Bvc3RTY3JpcHROYW1lXCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250W1wiQF9OYW1lXCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250W1wiQF9Gb250RmFtaWx5XCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYEZvbnQgbWFwcGluZzogJHtmb250W1wiQF9TZWxmXCJdfSAtPiAke2ZhbWlseUluZm8ubmFtZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZm9udHNbZmFtaWx5W1wiQF9TZWxmXCJdXSA9IGZhbWlseUluZm87XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGDinIUgRm9udHMgZXh0cmFjdGVkOiAke09iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmZvbnRzKS5sZW5ndGh9IGZhbWlsaWVzYFxuICAgICk7XG4gICAgY29uc29sZS5sb2coYEZvbnQgbWFwIGVudHJpZXM6ICR7dGhpcy5mb250TWFwLnNpemV9YCk7XG4gIH1cblxuICBhc3luYyBleHRyYWN0R3JhcGhpY3MoZ3JhcGhpY3NEYXRhKSB7XG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIGdyYXBoaWNzIGFuZCBjb2xvcnMuLi5cIik7XG5cbiAgICBjb25zdCBncmFwaGljcyA9IGdyYXBoaWNzRGF0YS5HcmFwaGljIHx8IGdyYXBoaWNzRGF0YTtcbiAgICB0aGlzLnJlc291cmNlcy5jb2xvcnMgPSB7fTtcbiAgICB0aGlzLnJlc291cmNlcy5ncmFkaWVudHMgPSB7fTtcblxuICAgIC8vIEV4dHJhY3QgQ29sb3JzXG4gICAgaWYgKGdyYXBoaWNzLkNvbG9yKSB7XG4gICAgICBjb25zdCBjb2xvcnMgPSBBcnJheS5pc0FycmF5KGdyYXBoaWNzLkNvbG9yKVxuICAgICAgICA/IGdyYXBoaWNzLkNvbG9yXG4gICAgICAgIDogW2dyYXBoaWNzLkNvbG9yXTtcblxuICAgICAgY29sb3JzLmZvckVhY2goKGNvbG9yKSA9PiB7XG4gICAgICAgIC8vIEV4dHJhY3QgaW5kaXZpZHVhbCBjaGFubmVsIHZhbHVlcyBmcm9tIGF0dHJpYnV0ZXMgKGlmIHByZXNlbnQpXG4gICAgICAgIGNvbnN0IGN5YW4gPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9DeWFuXCJdKSB8fCAwO1xuICAgICAgICBjb25zdCBtYWdlbnRhID0gcGFyc2VGbG9hdChjb2xvcltcIkBfTWFnZW50YVwiXSkgfHwgMDtcbiAgICAgICAgY29uc3QgeWVsbG93ID0gcGFyc2VGbG9hdChjb2xvcltcIkBfWWVsbG93XCJdKSB8fCAwO1xuICAgICAgICBjb25zdCBibGFjayA9IHBhcnNlRmxvYXQoY29sb3JbXCJAX0JsYWNrXCJdKSB8fCAwO1xuICAgICAgICBjb25zdCByZWQgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9SZWRcIl0pIHx8IDA7XG4gICAgICAgIGNvbnN0IGdyZWVuID0gcGFyc2VGbG9hdChjb2xvcltcIkBfR3JlZW5cIl0pIHx8IDA7XG4gICAgICAgIGNvbnN0IGJsdWUgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9CbHVlXCJdKSB8fCAwO1xuXG4gICAgICAgIC8vIEdldCBjb2xvciBzcGFjZSBhbmQgbW9kZWwgaW5mb3JtYXRpb25cbiAgICAgICAgY29uc3QgY29sb3JTcGFjZSA9IGNvbG9yW1wiQF9TcGFjZVwiXSB8fCBcIkNNWUtcIjtcbiAgICAgICAgY29uc3QgY29sb3JNb2RlbCA9IGNvbG9yW1wiQF9Nb2RlbFwiXSB8fCBcIlByb2Nlc3NcIjtcbiAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IGNvbG9yW1wiQF9Db2xvclZhbHVlXCJdO1xuICAgICAgICBjb25zdCBjb2xvck5hbWUgPSBjb2xvcltcIkBfTmFtZVwiXSB8fCBcIlwiO1xuICAgICAgICBjb25zdCBjb2xvclNlbGYgPSBjb2xvcltcIkBfU2VsZlwiXSB8fCBcIlwiO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46oIFByb2Nlc3NpbmcgY29sb3I6ICR7Y29sb3JTZWxmfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgICAgTmFtZTogXCIke2NvbG9yTmFtZX1cIiwgU3BhY2U6ICR7Y29sb3JTcGFjZX0sIE1vZGVsOiAke2NvbG9yTW9kZWx9YFxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICAgQ29sb3JWYWx1ZTogXCIke2NvbG9yVmFsdWV9XCJgKTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYCAgIEluZGl2aWR1YWwgY2hhbm5lbHMgLSBDOiR7Y3lhbn0gTToke21hZ2VudGF9IFk6JHt5ZWxsb3d9IEs6JHtibGFja30gUjoke3JlZH0gRzoke2dyZWVufSBCOiR7Ymx1ZX1gXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ1JJVElDQUw6IERldGVybWluZSBpZiB0aGlzIGlzIGEgY3VzdG9tIGNvbG9yIHRoYXQgc2hvdWxkIHVzZSBSR0IgQ29sb3JWYWx1ZVxuICAgICAgICBjb25zdCBpc0N1c3RvbUNvbG9yID0gdGhpcy5pc0N1c3RvbUNvbG9yTmFtZShjb2xvclNlbGYsIGNvbG9yTmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICDwn5SNIElzIGN1c3RvbSBjb2xvcjogJHtpc0N1c3RvbUNvbG9yfWApO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgY29sb3IgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgbGV0IGZpbmFsQ29sb3JEYXRhID0ge1xuICAgICAgICAgIHNlbGY6IGNvbG9yU2VsZixcbiAgICAgICAgICBuYW1lOiBjb2xvck5hbWUsXG4gICAgICAgICAgbW9kZWw6IGNvbG9yTW9kZWwsXG4gICAgICAgICAgc3BhY2U6IGNvbG9yU3BhY2UsXG4gICAgICAgICAgY3lhbjogMCxcbiAgICAgICAgICBtYWdlbnRhOiAwLFxuICAgICAgICAgIHllbGxvdzogMCxcbiAgICAgICAgICBibGFjazogMCxcbiAgICAgICAgICByZWQ6IDAsXG4gICAgICAgICAgZ3JlZW46IDAsXG4gICAgICAgICAgYmx1ZTogMCxcbiAgICAgICAgICAvLyBBZGRpdGlvbmFsIGZpZWxkcyB0byB0cmFjayBjb2xvciBzb3VyY2VcbiAgICAgICAgICBjb2xvclNvdXJjZTogXCJ1bmtub3duXCIsXG4gICAgICAgICAgaGFzRGlyZWN0UkdCOiBmYWxzZSxcbiAgICAgICAgICBoYXNEaXJlY3RDTVlLOiBmYWxzZSxcbiAgICAgICAgICBoYXNDb2xvclZhbHVlOiAhIWNvbG9yVmFsdWUsXG4gICAgICAgICAgaXNDdXN0b21Db2xvcjogaXNDdXN0b21Db2xvcixcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTVFJBVEVHWSAxOiBDaGVjayBmb3IgZGlyZWN0IFJHQiB2YWx1ZXMgaW4gaW5kaXZpZHVhbCBhdHRyaWJ1dGVzXG4gICAgICAgIGlmIChyZWQgPiAwIHx8IGdyZWVuID4gMCB8fCBibHVlID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCAgIOKchSBVc2luZyBkaXJlY3QgUkdCIGZyb20gaW5kaXZpZHVhbCBjaGFubmVsczogUjoke3JlZH0gRzoke2dyZWVufSBCOiR7Ymx1ZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5yZWQgPSByZWQ7XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuZ3JlZW4gPSBncmVlbjtcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5ibHVlID0gYmx1ZTtcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiZGlyZWN0X3JnYl9jaGFubmVsc1wiO1xuICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmhhc0RpcmVjdFJHQiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU1RSQVRFR1kgMjogQ2hlY2sgZm9yIGRpcmVjdCBDTVlLIHZhbHVlcyBpbiBpbmRpdmlkdWFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZWxzZSBpZiAoY3lhbiA+IDAgfHwgbWFnZW50YSA+IDAgfHwgeWVsbG93ID4gMCB8fCBibGFjayA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGAgICDinIUgVXNpbmcgZGlyZWN0IENNWUsgZnJvbSBpbmRpdmlkdWFsIGNoYW5uZWxzOiBDOiR7Y3lhbn0gTToke21hZ2VudGF9IFk6JHt5ZWxsb3d9IEs6JHtibGFja31gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jeWFuID0gY3lhbjtcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5tYWdlbnRhID0gbWFnZW50YTtcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS55ZWxsb3cgPSB5ZWxsb3c7XG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuYmxhY2sgPSBibGFjaztcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiZGlyZWN0X2NteWtfY2hhbm5lbHNcIjtcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RDTVlLID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTVFJBVEVHWSAzOiBQYXJzZSBDb2xvclZhbHVlIGF0dHJpYnV0ZSAoT05MWSBmb3IgY3VzdG9tIGNvbG9ycylcbiAgICAgICAgZWxzZSBpZiAoY29sb3JWYWx1ZSAmJiBpc0N1c3RvbUNvbG9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgICAg8J+UjSBQYXJzaW5nIENvbG9yVmFsdWUgZm9yIENVU1RPTSBjb2xvcjogXCIke2NvbG9yVmFsdWV9XCJgXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFNwbGl0IENvbG9yVmFsdWUgaW50byBudW1lcmljIHBhcnRzXG4gICAgICAgICAgY29uc3QgdmFsdWVQYXJ0cyA9IGNvbG9yVmFsdWVcbiAgICAgICAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAgICAgICAubWFwKE51bWJlcilcbiAgICAgICAgICAgIC5maWx0ZXIoKHYpID0+ICFpc05hTih2KSk7XG5cbiAgICAgICAgICBpZiAodmFsdWVQYXJ0cy5sZW5ndGggPT09IDMgJiYgY29sb3JTcGFjZSA9PT0gXCJSR0JcIikge1xuICAgICAgICAgICAgLy8gUkdCIENvbG9yVmFsdWU6IFwiMjU1IDEzNyAwXCIgLT4gUjoyNTUgRzoxMzcgQjowXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYCAgIOKchSBVc2luZyBSR0IgQ29sb3JWYWx1ZSBmb3IgY3VzdG9tIGNvbG9yOiBSOiR7dmFsdWVQYXJ0c1swXX0gRzoke3ZhbHVlUGFydHNbMV19IEI6JHt2YWx1ZVBhcnRzWzJdfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5yZWQgPSB2YWx1ZVBhcnRzWzBdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuZ3JlZW4gPSB2YWx1ZVBhcnRzWzFdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuYmx1ZSA9IHZhbHVlUGFydHNbMl07XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiY29sb3J2YWx1ZV9yZ2JfY3VzdG9tXCI7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RSR0IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVQYXJ0cy5sZW5ndGggPT09IDQgJiYgY29sb3JTcGFjZSA9PT0gXCJDTVlLXCIpIHtcbiAgICAgICAgICAgIC8vIENNWUsgQ29sb3JWYWx1ZTogXCIwIDAgMCAxMDBcIiAtPiBDOjAgTTowIFk6MCBLOjEwMFxuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIGAgICDinIUgVXNpbmcgQ01ZSyBDb2xvclZhbHVlIGZvciBjdXN0b20gY29sb3I6IEM6JHt2YWx1ZVBhcnRzWzBdfSBNOiR7dmFsdWVQYXJ0c1sxXX0gWToke3ZhbHVlUGFydHNbMl19IEs6JHt2YWx1ZVBhcnRzWzNdfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jeWFuID0gdmFsdWVQYXJ0c1swXTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLm1hZ2VudGEgPSB2YWx1ZVBhcnRzWzFdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEueWVsbG93ID0gdmFsdWVQYXJ0c1syXTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmJsYWNrID0gdmFsdWVQYXJ0c1szXTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlID0gXCJjb2xvcnZhbHVlX2NteWtfY3VzdG9tXCI7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RDTVlLID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlUGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgUkdCIGlmIHNwYWNlIGlzIHVua25vd24gYnV0IHdlIGhhdmUgMyB2YWx1ZXMgKGZvciBjdXN0b20gY29sb3JzKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIGAgICDimqDvuI8gIEFzc3VtaW5nIFJHQiBmb3IgMy12YWx1ZSBDb2xvclZhbHVlIG9uIGN1c3RvbSBjb2xvcjogUjoke3ZhbHVlUGFydHNbMF19IEc6JHt2YWx1ZVBhcnRzWzFdfSBCOiR7dmFsdWVQYXJ0c1syXX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEucmVkID0gdmFsdWVQYXJ0c1swXTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmdyZWVuID0gdmFsdWVQYXJ0c1sxXTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmJsdWUgPSB2YWx1ZVBhcnRzWzJdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuc3BhY2UgPSBcIlJHQlwiO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImNvbG9ydmFsdWVfYXNzdW1lZF9yZ2JfY3VzdG9tXCI7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RSR0IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYCAgIOKaoO+4jyAgQ291bGQgbm90IHBhcnNlIENvbG9yVmFsdWUgZm9yIGN1c3RvbSBjb2xvcjogXCIke2NvbG9yVmFsdWV9XCIgKCR7dmFsdWVQYXJ0cy5sZW5ndGh9IHBhcnRzKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiY29sb3J2YWx1ZV91bnBhcnNlYWJsZV9jdXN0b21cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU1RSQVRFR1kgNDogSGFuZGxlIENvbG9yVmFsdWUgZm9yIHN0YW5kYXJkIGNvbG9ycyAodXNlIGZvciBDTVlLIG9ubHksIHNraXAgUkdCKVxuICAgICAgICBlbHNlIGlmIChjb2xvclZhbHVlICYmICFpc0N1c3RvbUNvbG9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgICAg8J+UjSBQYXJzaW5nIENvbG9yVmFsdWUgZm9yIFNUQU5EQVJEIGNvbG9yOiBcIiR7Y29sb3JWYWx1ZX1cImBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gU3BsaXQgQ29sb3JWYWx1ZSBpbnRvIG51bWVyaWMgcGFydHNcbiAgICAgICAgICBjb25zdCB2YWx1ZVBhcnRzID0gY29sb3JWYWx1ZVxuICAgICAgICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgLmZpbHRlcigodikgPT4gIWlzTmFOKHYpKTtcblxuICAgICAgICAgIGlmICh2YWx1ZVBhcnRzLmxlbmd0aCA9PT0gNCAmJiBjb2xvclNwYWNlID09PSBcIkNNWUtcIikge1xuICAgICAgICAgICAgLy8gT25seSB1c2UgQ01ZSyBDb2xvclZhbHVlIGZvciBzdGFuZGFyZCBjb2xvcnMsIGlnbm9yZSBSR0IgQ29sb3JWYWx1ZVxuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIGAgICDinIUgVXNpbmcgQ01ZSyBDb2xvclZhbHVlIGZvciBzdGFuZGFyZCBjb2xvcjogQzoke3ZhbHVlUGFydHNbMF19IE06JHt2YWx1ZVBhcnRzWzFdfSBZOiR7dmFsdWVQYXJ0c1syXX0gSzoke3ZhbHVlUGFydHNbM119YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmN5YW4gPSB2YWx1ZVBhcnRzWzBdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEubWFnZW50YSA9IHZhbHVlUGFydHNbMV07XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS55ZWxsb3cgPSB2YWx1ZVBhcnRzWzJdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuYmxhY2sgPSB2YWx1ZVBhcnRzWzNdO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImNvbG9ydmFsdWVfY215a19zdGFuZGFyZFwiO1xuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuaGFzRGlyZWN0Q01ZSyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVBhcnRzLmxlbmd0aCA9PT0gMyAmJiBjb2xvclNwYWNlID09PSBcIlJHQlwiKSB7XG4gICAgICAgICAgICAvLyBTa2lwIFJHQiBDb2xvclZhbHVlIGZvciBzdGFuZGFyZCBjb2xvcnMgdG8gYXZvaWQgXCIwIDAgMFwiIGlzc3Vlc1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIGAgICDimqDvuI8gIFNraXBwaW5nIFJHQiBDb2xvclZhbHVlIGZvciBzdGFuZGFyZCBjb2xvciAoYXZvaWRpbmcgYmxhY2sgZmFsbGJhY2spOiBcIiR7Y29sb3JWYWx1ZX1cImBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiY29sb3J2YWx1ZV9yZ2Jfc2tpcHBlZF9zdGFuZGFyZFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYCAgIOKaoO+4jyAgQ291bGQgbm90IHBhcnNlIENvbG9yVmFsdWUgZm9yIHN0YW5kYXJkIGNvbG9yOiBcIiR7Y29sb3JWYWx1ZX1cIiAoJHt2YWx1ZVBhcnRzLmxlbmd0aH0gcGFydHMpYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlID0gXCJjb2xvcnZhbHVlX3VucGFyc2VhYmxlX3N0YW5kYXJkXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU1RSQVRFR1kgNTogSGFuZGxlIHNwZWNpYWwgY29sb3IgdHlwZXMgKGZhbGxiYWNrKVxuICAgICAgICBpZiAoZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPT09IFwidW5rbm93blwiKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIPCflIQgVXNpbmcgZmFsbGJhY2sgaGFuZGxpbmcgZm9yIGNvbG9yOiAke2NvbG9yU2VsZn1gKTtcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiZmFsbGJhY2tcIjtcblxuICAgICAgICAgIC8vIEZvciBzdGFuZGFyZCBjb2xvcnMgd2l0aCBubyBkYXRhLCBkb24ndCBzdG9yZSB0aGVtIGF0IGFsbFxuICAgICAgICAgIC8vIFRoaXMgd2lsbCBjYXVzZSB0aGVtIHRvIGZhbGwgdGhyb3VnaCB0byB0aGUgZ3JheSBmYWxsYmFjayBpbiBDb2xvclV0aWxzXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWlzQ3VzdG9tQ29sb3IgJiZcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmN5YW4gPT09IDAgJiZcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLm1hZ2VudGEgPT09IDAgJiZcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLnllbGxvdyA9PT0gMCAmJlxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuYmxhY2sgPT09IDAgJiZcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLnJlZCA9PT0gMCAmJlxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuZ3JlZW4gPT09IDAgJiZcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmJsdWUgPT09IDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBgICAg4pqg77iPICBTdGFuZGFyZCBjb2xvciB3aXRoIG5vIHZhbGlkIGRhdGEgLSBza2lwcGluZyBzdG9yYWdlIHRvIGFsbG93IGdyYXkgZmFsbGJhY2tgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBTa2lwIHN0b3JpbmcgdGhpcyBjb2xvciBjb21wbGV0ZWx5XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGNvbG9yIGRhdGFcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuY29sb3JzW2NvbG9yU2VsZl0gPSBmaW5hbENvbG9yRGF0YTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgICAg8J+SviBTdG9yZWQgY29sb3IgZGF0YTpgLCB7XG4gICAgICAgICAgc2VsZjogZmluYWxDb2xvckRhdGEuc2VsZixcbiAgICAgICAgICBzb3VyY2U6IGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlLFxuICAgICAgICAgIGhhc1JHQjogZmluYWxDb2xvckRhdGEuaGFzRGlyZWN0UkdCLFxuICAgICAgICAgIGhhc0NNWUs6IGZpbmFsQ29sb3JEYXRhLmhhc0RpcmVjdENNWUssXG4gICAgICAgICAgaXNDdXN0b206IGZpbmFsQ29sb3JEYXRhLmlzQ3VzdG9tQ29sb3IsXG4gICAgICAgICAgcmdiOiBgJHtmaW5hbENvbG9yRGF0YS5yZWR9LCR7ZmluYWxDb2xvckRhdGEuZ3JlZW59LCR7ZmluYWxDb2xvckRhdGEuYmx1ZX1gLFxuICAgICAgICAgIGNteWs6IGAke2ZpbmFsQ29sb3JEYXRhLmN5YW59LCR7ZmluYWxDb2xvckRhdGEubWFnZW50YX0sJHtmaW5hbENvbG9yRGF0YS55ZWxsb3d9LCR7ZmluYWxDb2xvckRhdGEuYmxhY2t9YCxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IEdyYWRpZW50c1xuICAgIGlmIChncmFwaGljcy5HcmFkaWVudCkge1xuICAgICAgY29uc3QgZ3JhZGllbnRzID0gQXJyYXkuaXNBcnJheShncmFwaGljcy5HcmFkaWVudClcbiAgICAgICAgPyBncmFwaGljcy5HcmFkaWVudFxuICAgICAgICA6IFtncmFwaGljcy5HcmFkaWVudF07XG5cbiAgICAgIGdyYWRpZW50cy5mb3JFYWNoKChncmFkaWVudCkgPT4ge1xuICAgICAgICB0aGlzLnJlc291cmNlcy5ncmFkaWVudHNbZ3JhZGllbnRbXCJAX1NlbGZcIl1dID0ge1xuICAgICAgICAgIHNlbGY6IGdyYWRpZW50W1wiQF9TZWxmXCJdLFxuICAgICAgICAgIG5hbWU6IGdyYWRpZW50W1wiQF9OYW1lXCJdIHx8IFwiXCIsXG4gICAgICAgICAgdHlwZTogZ3JhZGllbnRbXCJAX1R5cGVcIl0gfHwgXCJMaW5lYXJcIixcbiAgICAgICAgICBncmFkaWVudFN0b3BzOiB0aGlzLmV4dHJhY3RHcmFkaWVudFN0b3BzKGdyYWRpZW50KSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYOKchSBHcmFwaGljcyBleHRyYWN0aW9uIGNvbXBsZXRlLiBDb2xvcnM6ICR7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmNvbG9ycykubGVuZ3RoXG4gICAgICB9LCBHcmFkaWVudHM6ICR7T2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuZ3JhZGllbnRzKS5sZW5ndGh9YFxuICAgICk7XG4gIH1cblxuICAvLyBORVcgTUVUSE9EOiBEZXRlcm1pbmUgaWYgYSBjb2xvciBpcyBjdXN0b20gYW5kIHNob3VsZCB1c2UgUkdCIENvbG9yVmFsdWVcbiAgaXNDdXN0b21Db2xvck5hbWUoY29sb3JTZWxmLCBjb2xvck5hbWUpIHtcbiAgICAvLyBTdGFuZGFyZC9wcmVkZWZpbmVkIEluRGVzaWduIGNvbG9ycyB0aGF0IHNob3VsZCBOT1QgdXNlIFJHQiBDb2xvclZhbHVlXG4gICAgY29uc3Qgc3RhbmRhcmRDb2xvcnMgPSBbXG4gICAgICBcIkNvbG9yL0JsYWNrXCIsXG4gICAgICBcIkNvbG9yL1doaXRlXCIsXG4gICAgICBcIkNvbG9yL1JlZFwiLFxuICAgICAgXCJDb2xvci9HcmVlblwiLFxuICAgICAgXCJDb2xvci9CbHVlXCIsXG4gICAgICBcIkNvbG9yL0N5YW5cIixcbiAgICAgIFwiQ29sb3IvTWFnZW50YVwiLFxuICAgICAgXCJDb2xvci9ZZWxsb3dcIixcbiAgICAgIFwiQ29sb3IvUGFwZXJcIixcbiAgICAgIFwiQ29sb3IvUmVnaXN0cmF0aW9uXCIsXG4gICAgICBcIkNvbG9yL05vbmVcIixcbiAgICBdO1xuXG4gICAgLy8gU3RhbmRhcmQgY29sb3IgcGF0dGVybnMgKENNWUsgdmFsdWVzIGluIHRoZSBuYW1lKVxuICAgIGNvbnN0IGNteWtQYXR0ZXJuID0gL0NvbG9yXFwvQz1bXFxkLl0rXFxzKk09W1xcZC5dK1xccypZPVtcXGQuXStcXHMqSz1bXFxkLl0rLztcbiAgICBjb25zdCByZ2JQYXR0ZXJuID0gL0NvbG9yXFwvUj1bXFxkLl0rXFxzKkc9W1xcZC5dK1xccypCPVtcXGQuXSsvO1xuXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIHN0YW5kYXJkIGNvbG9yXG4gICAgaWYgKHN0YW5kYXJkQ29sb3JzLmluY2x1ZGVzKGNvbG9yU2VsZikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBpdCBmb2xsb3dzIENNWUsgb3IgUkdCIHBhdHRlcm4gKHRoZXNlIGFyZSBhdXRvLWdlbmVyYXRlZCwgbm90IGN1c3RvbSlcbiAgICBpZiAoY215a1BhdHRlcm4udGVzdChjb2xvclNlbGYpIHx8IHJnYlBhdHRlcm4udGVzdChjb2xvclNlbGYpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGhpZGRlbi9zeXN0ZW0gY29sb3JzXG4gICAgaWYgKGNvbG9yU2VsZi5pbmNsdWRlcyhcIi91XCIpICYmIC9cXC91XFxkKyQvLnRlc3QoY29sb3JTZWxmKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIGNvbG9yIG5hbWUgaXMgZ2VuZXJpYyBvciBlbXB0eSwgaXQncyBsaWtlbHkgbm90IGN1c3RvbVxuICAgIGlmICghY29sb3JOYW1lIHx8IGNvbG9yTmFtZSA9PT0gXCJcIiB8fCBjb2xvck5hbWUgPT09IFwiJElEL1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIGNvbG9ycyB0eXBpY2FsbHkgaGF2ZSBtZWFuaW5nZnVsIG5hbWVzIGxpa2UgXCJNYWluXCIsIFwiQnJhbmRcIiwgXCJBY2NlbnRcIiwgZXRjLlxuICAgIGNvbnN0IGN1c3RvbUNvbG9yUGF0dGVybnMgPSBbXG4gICAgICAvbWFpbi9pLFxuICAgICAgL2JyYW5kL2ksXG4gICAgICAvYWNjZW50L2ksXG4gICAgICAvcHJpbWFyeS9pLFxuICAgICAgL3NlY29uZGFyeS9pLFxuICAgICAgL3RoZW1lL2ksXG4gICAgICAvY3VzdG9tL2ksXG4gICAgXTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBuYW1lIG1hdGNoZXMgY3VzdG9tIHBhdHRlcm5zXG4gICAgY29uc3QgaGFzQ3VzdG9tUGF0dGVybiA9IGN1c3RvbUNvbG9yUGF0dGVybnMuc29tZShcbiAgICAgIChwYXR0ZXJuKSA9PiBwYXR0ZXJuLnRlc3QoY29sb3JOYW1lKSB8fCBwYXR0ZXJuLnRlc3QoY29sb3JTZWxmKVxuICAgICk7XG5cbiAgICBpZiAoaGFzQ3VzdG9tUGF0dGVybikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gSWYgaXQncyBub3QgYSBzdGFuZGFyZCBjb2xvciBhbmQgaGFzIGEgbWVhbmluZ2Z1bCBuYW1lLCBjb25zaWRlciBpdCBjdXN0b21cbiAgICByZXR1cm4gY29sb3JOYW1lLmxlbmd0aCA+IDIgJiYgIWNvbG9yTmFtZS5pbmNsdWRlcyhcIiRJRC9cIik7XG4gIH1cblxuICBleHRyYWN0R3JhZGllbnRTdG9wcyhncmFkaWVudCkge1xuICAgIGNvbnN0IHN0b3BzID0gW107XG5cbiAgICBpZiAoZ3JhZGllbnQuR3JhZGllbnRTdG9wKSB7XG4gICAgICBjb25zdCBzdG9wTGlzdCA9IEFycmF5LmlzQXJyYXkoZ3JhZGllbnQuR3JhZGllbnRTdG9wKVxuICAgICAgICA/IGdyYWRpZW50LkdyYWRpZW50U3RvcFxuICAgICAgICA6IFtncmFkaWVudC5HcmFkaWVudFN0b3BdO1xuXG4gICAgICBzdG9wTGlzdC5mb3JFYWNoKChzdG9wKSA9PiB7XG4gICAgICAgIHN0b3BzLnB1c2goe1xuICAgICAgICAgIHNlbGY6IHN0b3BbXCJAX1NlbGZcIl0sXG4gICAgICAgICAgc3RvcENvbG9yOiBzdG9wW1wiQF9TdG9wQ29sb3JcIl0gfHwgXCJcIixcbiAgICAgICAgICBsb2NhdGlvbjogcGFyc2VGbG9hdChzdG9wW1wiQF9Mb2NhdGlvblwiXSkgfHwgMCxcbiAgICAgICAgICBtaWRwb2ludDogcGFyc2VGbG9hdChzdG9wW1wiQF9NaWRwb2ludFwiXSkgfHwgNTAsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3BzO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdFByZWZlcmVuY2VzKHByZWZlcmVuY2VzRGF0YSkge1xuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBkb2N1bWVudCBwcmVmZXJlbmNlcy4uLlwiKTtcblxuICAgIGNvbnN0IHByZWZzID0gcHJlZmVyZW5jZXNEYXRhLlByZWZlcmVuY2VzIHx8IHByZWZlcmVuY2VzRGF0YTtcblxuICAgIC8vIEV4dHJhY3QgdmFyaW91cyBkb2N1bWVudCBwcmVmZXJlbmNlc1xuICAgIHRoaXMuZG9jdW1lbnRJbmZvID0ge1xuICAgICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgZG9jdW1lbnRQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0RG9jdW1lbnRQcmVmcyhcbiAgICAgICAgICBwcmVmcy5Eb2N1bWVudFByZWZlcmVuY2VcbiAgICAgICAgKSxcbiAgICAgICAgdmlld1ByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RWaWV3UHJlZnMocHJlZnMuVmlld1ByZWZlcmVuY2UpLFxuICAgICAgICBndWlkZVByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RHdWlkZVByZWZzKHByZWZzLkd1aWRlUHJlZmVyZW5jZSksXG4gICAgICAgIGdyaWRQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0R3JpZFByZWZzKHByZWZzLkdyaWRQcmVmZXJlbmNlKSxcbiAgICAgICAgbWFyZ2luUHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdE1hcmdpblByZWZzKHByZWZzLk1hcmdpblByZWZlcmVuY2UpLFxuICAgICAgICBjb2x1bW5QcmVmZXJlbmNlczogdGhpcy5leHRyYWN0Q29sdW1uUHJlZnMocHJlZnMuQ29sdW1uUHJlZmVyZW5jZSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBleHRyYWN0RG9jdW1lbnRQcmVmcyhkb2NQcmVmKSB7XG4gICAgaWYgKCFkb2NQcmVmKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVdpZHRoOiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX1BhZ2VXaWR0aFwiXSkgfHwgMCxcbiAgICAgIHBhZ2VIZWlnaHQ6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfUGFnZUhlaWdodFwiXSkgfHwgMCxcbiAgICAgIGxlZnQ6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfTGVmdFwiXSkgfHwgMCxcbiAgICAgIHRvcDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Ub3BcIl0pIHx8IDAsXG4gICAgICByaWdodDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9SaWdodFwiXSkgfHwgMCxcbiAgICAgIGJvdHRvbTogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Cb3R0b21cIl0pIHx8IDAsXG4gICAgICBjb2x1bW5Db3VudDogcGFyc2VJbnQoZG9jUHJlZltcIkBfQ29sdW1uQ291bnRcIl0pIHx8IDEsXG4gICAgICBjb2x1bW5HdXR0ZXI6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfQ29sdW1uR3V0dGVyXCJdKSB8fCAwLFxuICAgICAgZmFjaW5nUGFnZXM6IGRvY1ByZWZbXCJAX0ZhY2luZ1BhZ2VzXCJdID09PSB0cnVlLFxuICAgICAgYWxsb3dQYWdlU2h1ZmZsZTogZG9jUHJlZltcIkBfQWxsb3dQYWdlU2h1ZmZsZVwiXSAhPT0gZmFsc2UsXG4gICAgICBzbHVnQmxlZWRUeXBlOiBkb2NQcmVmW1wiQF9TbHVnQmxlZWRUeXBlXCJdIHx8IFwiTm9uZVwiLFxuICAgICAgZG9jdW1lbnRCbGVlZFRvcE9mZnNldDpcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkVG9wT2Zmc2V0XCJdKSB8fCAwLFxuICAgICAgZG9jdW1lbnRCbGVlZEJvdHRvbU9mZnNldDpcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkQm90dG9tT2Zmc2V0XCJdKSB8fCAwLFxuICAgICAgZG9jdW1lbnRCbGVlZEluc2lkZU9yTGVmdE9mZnNldDpcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0XCJdKSB8fCAwLFxuICAgICAgZG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0OlxuICAgICAgICBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0RvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldFwiXSkgfHwgMCxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdFZpZXdQcmVmcyh2aWV3UHJlZikge1xuICAgIGlmICghdmlld1ByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICBob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0czpcbiAgICAgICAgdmlld1ByZWZbXCJAX0hvcml6b250YWxNZWFzdXJlbWVudFVuaXRzXCJdIHx8IFwiUG9pbnRzXCIsXG4gICAgICB2ZXJ0aWNhbE1lYXN1cmVtZW50VW5pdHM6XG4gICAgICAgIHZpZXdQcmVmW1wiQF9WZXJ0aWNhbE1lYXN1cmVtZW50VW5pdHNcIl0gfHwgXCJQb2ludHNcIixcbiAgICAgIHJ1bGVyT3JpZ2luOiB2aWV3UHJlZltcIkBfUnVsZXJPcmlnaW5cIl0gfHwgXCJTcHJlYWRPcmlnaW5cIixcbiAgICAgIHNob3dSdWxlcnM6IHZpZXdQcmVmW1wiQF9TaG93UnVsZXJzXCJdICE9PSBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdEd1aWRlUHJlZnMoZ3VpZGVQcmVmKSB7XG4gICAgaWYgKCFndWlkZVByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICBydWxlckd1aWRlQ29sb3I6IGd1aWRlUHJlZltcIkBfUnVsZXJHdWlkZUNvbG9yXCJdIHx8IFwiR3JlZW5cIixcbiAgICAgIGd1aWRlc0luQmFjazogZ3VpZGVQcmVmW1wiQF9HdWlkZXNJbkJhY2tcIl0gPT09IHRydWUsXG4gICAgICBndWlkZXNMb2NrZWQ6IGd1aWRlUHJlZltcIkBfR3VpZGVzTG9ja2VkXCJdID09PSB0cnVlLFxuICAgICAgZ3VpZGVzU2hvd246IGd1aWRlUHJlZltcIkBfR3VpZGVzU2hvd25cIl0gIT09IGZhbHNlLFxuICAgICAgZ3VpZGVzU25hcHRvOiBndWlkZVByZWZbXCJAX0d1aWRlc1NuYXB0b1wiXSAhPT0gZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGV4dHJhY3RHcmlkUHJlZnMoZ3JpZFByZWYpIHtcbiAgICBpZiAoIWdyaWRQcmVmKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZWxpbmVTdGFydDogcGFyc2VGbG9hdChncmlkUHJlZltcIkBfQmFzZWxpbmVTdGFydFwiXSkgfHwgMCxcbiAgICAgIGJhc2VsaW5lRGl2aXNpb246IHBhcnNlRmxvYXQoZ3JpZFByZWZbXCJAX0Jhc2VsaW5lRGl2aXNpb25cIl0pIHx8IDEyLFxuICAgICAgYmFzZWxpbmVTaG93bjogZ3JpZFByZWZbXCJAX0Jhc2VsaW5lU2hvd25cIl0gPT09IHRydWUsXG4gICAgICBiYXNlbGluZVNuYXB0bzogZ3JpZFByZWZbXCJAX0Jhc2VsaW5lU25hcHRvXCJdID09PSB0cnVlLFxuICAgICAgZG9jdW1lbnRHcmlkU2hvd246IGdyaWRQcmVmW1wiQF9Eb2N1bWVudEdyaWRTaG93blwiXSA9PT0gdHJ1ZSxcbiAgICAgIGRvY3VtZW50R3JpZFNuYXB0bzogZ3JpZFByZWZbXCJAX0RvY3VtZW50R3JpZFNuYXB0b1wiXSA9PT0gdHJ1ZSxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdE1hcmdpblByZWZzKG1hcmdpblByZWYpIHtcbiAgICBpZiAoIW1hcmdpblByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfVG9wXCJdKSB8fCAwLFxuICAgICAgYm90dG9tOiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX0JvdHRvbVwiXSkgfHwgMCxcbiAgICAgIGxlZnQ6IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfTGVmdFwiXSkgfHwgMCxcbiAgICAgIHJpZ2h0OiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX1JpZ2h0XCJdKSB8fCAwLFxuICAgICAgY29sdW1uQ291bnQ6IHBhcnNlSW50KG1hcmdpblByZWZbXCJAX0NvbHVtbkNvdW50XCJdKSB8fCAxLFxuICAgICAgY29sdW1uR3V0dGVyOiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX0NvbHVtbkd1dHRlclwiXSkgfHwgMCxcbiAgICB9O1xuICB9XG5cbiAgZXh0cmFjdENvbHVtblByZWZzKGNvbHVtblByZWYpIHtcbiAgICBpZiAoIWNvbHVtblByZWYpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0Q29sdW1uQ291bnQ6IHBhcnNlSW50KGNvbHVtblByZWZbXCJAX1RleHRDb2x1bW5Db3VudFwiXSkgfHwgMSxcbiAgICAgIHRleHRDb2x1bW5HdXR0ZXI6IHBhcnNlRmxvYXQoY29sdW1uUHJlZltcIkBfVGV4dENvbHVtbkd1dHRlclwiXSkgfHwgMCxcbiAgICB9O1xuICB9XG5cbiAgcmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB7IC4uLmZvcm1hdHRpbmcgfTtcblxuICAgIC8vIERFQlVHOiBDaGVjayBpZiBmb3JtYXR0aW5nIGlzIGJlaW5nIGFwcGxpZWQgKGdlbmVyaWMgY2hlY2spXG4gICAgY29uc3QgaGFzQW55Rm9ybWF0dGluZyA9XG4gICAgICBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlIHx8XG4gICAgICBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlIHx8XG4gICAgICBmb3JtYXR0aW5nLmZvbnRTdHlsZSB8fFxuICAgICAgZm9ybWF0dGluZy5mb250UmVmZXJlbmNlIHx8XG4gICAgICBmb3JtYXR0aW5nLmZvbnRTaXplO1xuXG4gICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBTdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nIC0gSW5wdXQ6XCIsIHtcbiAgICAgICAgcGFyYWdyYXBoU3R5bGU6IGZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGUsXG4gICAgICAgIGNoYXJhY3RlclN0eWxlOiBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlLFxuICAgICAgICBkaXJlY3RGb250U3R5bGU6IGZvcm1hdHRpbmcuZm9udFN0eWxlLFxuICAgICAgICBkaXJlY3RGb250UmVmOiBmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UsXG4gICAgICAgIGRpcmVjdEZvbnRTaXplOiBmb3JtYXR0aW5nLmZvbnRTaXplLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVzb2x2ZSBwYXJhZ3JhcGggc3R5bGUgKGJhc2UgbGF5ZXIpXG4gICAgaWYgKFxuICAgICAgZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSAmJlxuICAgICAgdGhpcy5zdHlsZXMucGFyYWdyYXBoW2Zvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVdXG4gICAgKSB7XG4gICAgICBjb25zdCBwU3R5bGUgPSB0aGlzLnN0eWxlcy5wYXJhZ3JhcGhbZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZV07XG5cbiAgICAgIGlmICghcmVzb2x2ZWQuZm9udFNpemUgJiYgcFN0eWxlLnBvaW50U2l6ZSlcbiAgICAgICAgcmVzb2x2ZWQuZm9udFNpemUgPSBwU3R5bGUucG9pbnRTaXplO1xuICAgICAgaWYgKCFyZXNvbHZlZC5maWxsQ29sb3IgJiYgcFN0eWxlLmZpbGxDb2xvcilcbiAgICAgICAgcmVzb2x2ZWQuZmlsbENvbG9yID0gcFN0eWxlLmZpbGxDb2xvcjtcbiAgICAgIC8vIENSSVRJQ0FMIEZJWDogQWx3YXlzIGluaGVyaXQgcGFyYWdyYXBoIGFsaWdubWVudCB1bmxlc3MgZXhwbGljaXRseSBvdmVycmlkZGVuXG4gICAgICBpZiAocFN0eWxlLmFsaWdubWVudCkgcmVzb2x2ZWQuYWxpZ25tZW50ID0gcFN0eWxlLmFsaWdubWVudDtcbiAgICAgIGlmICghcmVzb2x2ZWQuZm9udFN0eWxlICYmIHBTdHlsZS5mb250U3R5bGUpIHtcbiAgICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gcFN0eWxlLmZvbnRTdHlsZTtcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGAgICBGb250U3R5bGUgZnJvbSBwYXJhZ3JhcGggc3R5bGU6IFwiJHtwU3R5bGUuZm9udFN0eWxlfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ1JJVElDQUw6IFJlc29sdmUgZm9udCBmcm9tIHBhcmFncmFwaCBzdHlsZVxuICAgICAgaWYgKCFyZXNvbHZlZC5mb250RmFtaWx5ICYmIHBTdHlsZS5hcHBsaWVkRm9udCkge1xuICAgICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShwU3R5bGUuYXBwbGllZEZvbnQpO1xuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCAgIEZvbnQgZnJvbSBwYXJhZ3JhcGggc3R5bGU6ICR7cFN0eWxlLmFwcGxpZWRGb250fSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIG90aGVyIHBhcmFncmFwaCBwcm9wZXJ0aWVzIHdpdGggZW5oYW5jZWQgbGVhZGluZyBzdXBwb3J0XG4gICAgICByZXNvbHZlZC5sZWFkaW5nID0gcFN0eWxlLmxlYWRpbmc7XG4gICAgICByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IHBTdHlsZS5sZWFkaW5nVHlwZTtcbiAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSBwU3R5bGUuZWZmZWN0aXZlTGluZUhlaWdodDtcbiAgICAgIHJlc29sdmVkLmxlZnRJbmRlbnQgPSBwU3R5bGUubGVmdEluZGVudDtcbiAgICAgIHJlc29sdmVkLnJpZ2h0SW5kZW50ID0gcFN0eWxlLnJpZ2h0SW5kZW50O1xuICAgICAgcmVzb2x2ZWQuZmlyc3RMaW5lSW5kZW50ID0gcFN0eWxlLmZpcnN0TGluZUluZGVudDtcbiAgICAgIHJlc29sdmVkLnNwYWNlQmVmb3JlID0gcFN0eWxlLnNwYWNlQmVmb3JlO1xuICAgICAgcmVzb2x2ZWQuc3BhY2VBZnRlciA9IHBTdHlsZS5zcGFjZUFmdGVyO1xuICAgICAgcmVzb2x2ZWQudHJhY2tpbmcgPSBwU3R5bGUudHJhY2tpbmc7XG4gICAgICByZXNvbHZlZC5rZXJuaW5nID0gcFN0eWxlLmtlcm5pbmc7XG4gICAgfVxuXG4gICAgLy8gUmVzb2x2ZSBjaGFyYWN0ZXIgc3R5bGUgKG92ZXJyaWRlIGxheWVyKVxuICAgIGlmIChcbiAgICAgIGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgJiZcbiAgICAgIHRoaXMuc3R5bGVzLmNoYXJhY3Rlcltmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlXVxuICAgICkge1xuICAgICAgY29uc3QgY1N0eWxlID0gdGhpcy5zdHlsZXMuY2hhcmFjdGVyW2Zvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVdO1xuXG4gICAgICBpZiAoY1N0eWxlLnBvaW50U2l6ZSkgcmVzb2x2ZWQuZm9udFNpemUgPSBjU3R5bGUucG9pbnRTaXplO1xuICAgICAgaWYgKGNTdHlsZS5maWxsQ29sb3IpIHJlc29sdmVkLmZpbGxDb2xvciA9IGNTdHlsZS5maWxsQ29sb3I7XG4gICAgICBpZiAoY1N0eWxlLmZvbnRTdHlsZSkge1xuICAgICAgICByZXNvbHZlZC5mb250U3R5bGUgPSBjU3R5bGUuZm9udFN0eWxlO1xuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCAgIEZvbnRTdHlsZSBmcm9tIGNoYXJhY3RlciBzdHlsZTogXCIke2NTdHlsZS5mb250U3R5bGV9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNTdHlsZS5zdHJva2VDb2xvcikgcmVzb2x2ZWQuc3Ryb2tlQ29sb3IgPSBjU3R5bGUuc3Ryb2tlQ29sb3I7XG5cbiAgICAgIC8vIEluY2x1ZGUgbGVhZGluZyBpbmZvcm1hdGlvbiBmcm9tIGNoYXJhY3RlciBzdHlsZVxuICAgICAgaWYgKGNTdHlsZS5sZWFkaW5nKSByZXNvbHZlZC5sZWFkaW5nID0gY1N0eWxlLmxlYWRpbmc7XG4gICAgICBpZiAoY1N0eWxlLmxlYWRpbmdUeXBlKSByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IGNTdHlsZS5sZWFkaW5nVHlwZTtcbiAgICAgIGlmIChjU3R5bGUuZWZmZWN0aXZlTGluZUhlaWdodClcbiAgICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IGNTdHlsZS5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xuXG4gICAgICAvLyBDUklUSUNBTDogQ2hhcmFjdGVyIHN0eWxlIGZvbnQgb3ZlcnJpZGVzIHBhcmFncmFwaCBzdHlsZVxuICAgICAgaWYgKGNTdHlsZS5hcHBsaWVkRm9udCkge1xuICAgICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShjU3R5bGUuYXBwbGllZEZvbnQpO1xuICAgICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCAgIEZvbnQgZnJvbSBjaGFyYWN0ZXIgc3R5bGU6ICR7Y1N0eWxlLmFwcGxpZWRGb250fSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBkaXJlY3QgZm9ybWF0dGluZyAoaGlnaGVzdCBwcmlvcml0eSlcbiAgICBpZiAoZm9ybWF0dGluZy5mb250UmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UpO1xuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYCAgIEZvbnQgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogJHtmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2V9IC0+ICR7cmVzb2x2ZWQuZm9udEZhbWlseX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ1JJVElDQUw6IEFwcGx5IGRpcmVjdCBmb250U3R5bGUgaWYgcHJvdmlkZWQgKHRoaXMgbWlnaHQgYmUgdGhlIGlzc3VlKVxuICAgIGlmIChmb3JtYXR0aW5nLmZvbnRTdHlsZSkge1xuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gZm9ybWF0dGluZy5mb250U3R5bGU7XG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgICAgRm9udFN0eWxlIGZyb20gZGlyZWN0IGZvcm1hdHRpbmc6IFwiJHtmb3JtYXR0aW5nLmZvbnRTdHlsZX1cImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBkaXJlY3QgbGVhZGluZyBpbmZvcm1hdGlvbiAoaGlnaGVzdCBwcmlvcml0eSlcbiAgICBpZiAoZm9ybWF0dGluZy5sZWFkaW5nICE9PSB1bmRlZmluZWQpIHJlc29sdmVkLmxlYWRpbmcgPSBmb3JtYXR0aW5nLmxlYWRpbmc7XG4gICAgaWYgKGZvcm1hdHRpbmcubGVhZGluZ1R5cGUpIHJlc29sdmVkLmxlYWRpbmdUeXBlID0gZm9ybWF0dGluZy5sZWFkaW5nVHlwZTtcbiAgICBpZiAoZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0KVxuICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodDtcblxuICAgIC8vIEFwcGx5IG90aGVyIGRpcmVjdCBmb3JtYXR0aW5nIGF0dHJpYnV0ZXNcbiAgICBpZiAoZm9ybWF0dGluZy5mb250U2l6ZSkgcmVzb2x2ZWQuZm9udFNpemUgPSBmb3JtYXR0aW5nLmZvbnRTaXplO1xuICAgIGlmIChmb3JtYXR0aW5nLnRyYWNraW5nKSByZXNvbHZlZC50cmFja2luZyA9IGZvcm1hdHRpbmcudHJhY2tpbmc7XG4gICAgaWYgKGZvcm1hdHRpbmcua2VybmluZykgcmVzb2x2ZWQua2VybmluZyA9IGZvcm1hdHRpbmcua2VybmluZztcblxuICAgIC8vIENSSVRJQ0FMIEZJWDogQXBwbHkgZGlyZWN0IGFsaWdubWVudCBpZiBleHBsaWNpdGx5IHNwZWNpZmllZCAob3ZlcnJpZGVzIHBhcmFncmFwaCBhbGlnbm1lbnQpXG4gICAgaWYgKGZvcm1hdHRpbmcuYWxpZ25tZW50KSB7XG4gICAgICByZXNvbHZlZC5hbGlnbm1lbnQgPSBmb3JtYXR0aW5nLmFsaWdubWVudDtcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgICBBbGlnbm1lbnQgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogXCIke2Zvcm1hdHRpbmcuYWxpZ25tZW50fVwiYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZJWEVEOiBFbnN1cmUgZm9udFN0eWxlIGRlZmF1bHRzIHRvIFJlZ3VsYXIvbm9ybWFsIGlmIG5vdCBzZXRcbiAgICBpZiAoIXJlc29sdmVkLmZvbnRTdHlsZSB8fCByZXNvbHZlZC5mb250U3R5bGUgPT09IFwiXCIpIHtcbiAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IFwiUmVndWxhclwiO1xuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIEZvbnRTdHlsZSBkZWZhdWx0ZWQgdG86IFwiUmVndWxhclwiYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQURESVRJT05BTCBGSVg6IElmIG5vIHN0eWxlcyB3ZXJlIGFwcGxpZWQgZnJvbSBhbnkgc291cmNlLCBlbnN1cmUgY2xlYW4gZGVmYXVsdHNcbiAgICBpZiAoXG4gICAgICAhZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSAmJlxuICAgICAgIWZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgJiZcbiAgICAgICFmb3JtYXR0aW5nLmZvbnRTdHlsZSAmJlxuICAgICAgIWZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZVxuICAgICkge1xuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gXCJSZWd1bGFyXCI7XG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhgICAgTm8gc291cmNlIHN0eWxlcyBmb3VuZCAtIGVuc3VyaW5nIGNsZWFuIGRlZmF1bHRzYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmluYWwgZmFsbGJhY2tcbiAgICBpZiAoIXJlc29sdmVkLmZvbnRGYW1pbHkgfHwgcmVzb2x2ZWQuZm9udEZhbWlseSA9PT0gXCJcIikge1xuICAgICAgcmVzb2x2ZWQuZm9udEZhbWlseSA9IHRoaXMuZ2V0RGVmYXVsdEZvbnQoKTtcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBVc2luZyBmYWxsYmFjayBmb250OiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGxpbmUgaGVpZ2h0IGlzIGNhbGN1bGF0ZWQgaWYgbm90IGV4cGxpY2l0bHkgc2V0XG4gICAgaWYgKFxuICAgICAgIXJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgJiZcbiAgICAgIHJlc29sdmVkLmZvbnRTaXplICYmXG4gICAgICByZXNvbHZlZC5sZWFkaW5nXG4gICAgKSB7XG4gICAgICByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KFxuICAgICAgICByZXNvbHZlZC5sZWFkaW5nLFxuICAgICAgICByZXNvbHZlZC5mb250U2l6ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xuICAgICAgY29uc29sZS5sb2coXCLwn5SnIFN0eWxlUGFyc2VyLnJlc29sdmVTdHlsZUZvcm1hdHRpbmcgLSBGaW5hbCBPdXRwdXQ6XCIsIHtcbiAgICAgICAgZm9udFNpemU6IHJlc29sdmVkLmZvbnRTaXplLFxuICAgICAgICBmb250RmFtaWx5OiByZXNvbHZlZC5mb250RmFtaWx5LFxuICAgICAgICBmb250U3R5bGU6IHJlc29sdmVkLmZvbnRTdHlsZSxcbiAgICAgICAgZmlsbENvbG9yOiByZXNvbHZlZC5maWxsQ29sb3IsXG4gICAgICAgIGxlYWRpbmc6IHJlc29sdmVkLmxlYWRpbmcsXG4gICAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cblxuICByZXNvbHZlRm9udFJlZmVyZW5jZShmb250UmVmKSB7XG4gICAgaWYgKCFmb250UmVmIHx8IGZvbnRSZWYgPT09IFwiXCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRW1wdHkgZm9udCByZWZlcmVuY2UsIHVzaW5nIGZhbGxiYWNrXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdEZvbnQoKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgZGlyZWN0IGxvb2t1cCBpbiBmb250IG1hcFxuICAgIGlmICh0aGlzLmZvbnRNYXAgJiYgdGhpcy5mb250TWFwLmhhcyhmb250UmVmKSkge1xuICAgICAgY29uc3QgcmVzb2x2ZWRGb250ID0gdGhpcy5mb250TWFwLmdldChmb250UmVmKTtcbiAgICAgIGNvbnNvbGUubG9nKGBGb250IHJlc29sdmVkOiBcIiR7Zm9udFJlZn1cIiAtPiBcIiR7cmVzb2x2ZWRGb250fVwiYCk7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRGb250O1xuICAgIH1cblxuICAgIC8vIFRyeSBwYXJ0aWFsIG1hdGNoaW5nIGZvciBmb250IGZhbWlsaWVzXG4gICAgaWYgKHRoaXMucmVzb3VyY2VzLmZvbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtmYW1pbHlJZCwgZmFtaWx5SW5mb10gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgIHRoaXMucmVzb3VyY2VzLmZvbnRzXG4gICAgICApKSB7XG4gICAgICAgIC8vIENoZWNrIGZhbWlseSBuYW1lIG1hdGNoXG4gICAgICAgIGlmIChcbiAgICAgICAgICBmYW1pbHlJbmZvLm5hbWUgJiZcbiAgICAgICAgICAoZmFtaWx5SW5mby5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZm9udFJlZi50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICAgICAgZm9udFJlZi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZhbWlseUluZm8ubmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgRm9udCBwYXJ0aWFsbHkgbWF0Y2hlZDogXCIke2ZvbnRSZWZ9XCIgLT4gXCIke2ZhbWlseUluZm8ubmFtZX1cImBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBmYW1pbHlJbmZvLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpbmRpdmlkdWFsIGZvbnQgbWF0Y2hlc1xuICAgICAgICBpZiAoZmFtaWx5SW5mby5mb250cykge1xuICAgICAgICAgIGZvciAoY29uc3QgZm9udCBvZiBmYW1pbHlJbmZvLmZvbnRzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGZvbnQuc2VsZiA9PT0gZm9udFJlZiB8fFxuICAgICAgICAgICAgICBmb250LnBvc3RTY3JpcHROYW1lID09PSBmb250UmVmIHx8XG4gICAgICAgICAgICAgIGZvbnQubmFtZSA9PT0gZm9udFJlZlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIGBGb250IGV4YWN0bHkgbWF0Y2hlZDogXCIke2ZvbnRSZWZ9XCIgLT4gXCIke2ZhbWlseUluZm8ubmFtZX1cImBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbWlseUluZm8ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgRm9udCBub3QgZm91bmQ6IFwiJHtmb250UmVmfVwiLCB1c2luZyBmYWxsYmFja2ApO1xuICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRGb250KCkgfHwgZm9udFJlZjtcbiAgfVxuXG4gIGdldERlZmF1bHRGb250KCkge1xuICAgIGlmICh0aGlzLnJlc291cmNlcy5mb250cyAmJiBPYmplY3Qua2V5cyh0aGlzLnJlc291cmNlcy5mb250cykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RGYW1pbHkgPSBPYmplY3QudmFsdWVzKHRoaXMucmVzb3VyY2VzLmZvbnRzKVswXTtcbiAgICAgIHJldHVybiBmaXJzdEZhbWlseS5uYW1lIHx8IFwiQXJpYWxcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiQXJpYWxcIjtcbiAgfVxuXG4gIGluZmVyRm9udEZyb21Db250ZXh0KCkge1xuICAgIC8vIElmIHdlIGhhdmUgZm9udCBkZWZpbml0aW9ucyBidXQgbm8gZXhwbGljaXQgcmVmZXJlbmNlcyxcbiAgICAvLyByZXR1cm4gdGhlIGZpcnN0IGF2YWlsYWJsZSBmb250IGFzIGEgZmFsbGJhY2tcbiAgICBpZiAodGhpcy5yZXNvdXJjZXMuZm9udHMgJiYgT2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuZm9udHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0Rm9udEZhbWlseSA9IE9iamVjdC52YWx1ZXModGhpcy5yZXNvdXJjZXMuZm9udHMpWzBdO1xuICAgICAgcmV0dXJuIGZpcnN0Rm9udEZhbWlseS5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFN0b3J5U3R5bGVTdW1tYXJ5KHN0b3J5KSB7XG4gICAgY29uc3Qgc3VtbWFyeSA9IHtcbiAgICAgIGZvbnRTaXplOiBudWxsLFxuICAgICAgZm9udEZhbWlseTogbnVsbCxcbiAgICAgIGFsaWdubWVudDogbnVsbCxcbiAgICAgIGZpbGxDb2xvcjogbnVsbCxcbiAgICAgIGZvbnRTdHlsZTogbnVsbCxcbiAgICAgIGxlYWRpbmc6IG51bGwsXG4gICAgICBsZWFkaW5nVHlwZTogbnVsbCxcbiAgICAgIGVmZmVjdGl2ZUxpbmVIZWlnaHQ6IG51bGwsXG4gICAgICB0cmFja2luZzogbnVsbCxcbiAgICAgIGtlcm5pbmc6IG51bGwsXG4gICAgfTtcblxuICAgIC8vIEdldCB0aGUgbW9zdCBjb21tb24gb3IgZmlyc3QgZm9ybWF0dGluZyB2YWx1ZXNcbiAgICBpZiAoc3RvcnkuY29udGVudD8uZm9ybWF0dGVkQ29udGVudD8ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RGb3JtYXR0ZWQgPSBzdG9yeS5jb250ZW50LmZvcm1hdHRlZENvbnRlbnQuZmluZChcbiAgICAgICAgKGl0ZW0pID0+IGl0ZW0uZm9ybWF0dGluZyAmJiAhaXRlbS5mb3JtYXR0aW5nLmlzQnJlYWtcbiAgICAgICk7XG5cbiAgICAgIGlmIChmaXJzdEZvcm1hdHRlZD8uZm9ybWF0dGluZykge1xuICAgICAgICBjb25zdCBmbXQgPSBmaXJzdEZvcm1hdHRlZC5mb3JtYXR0aW5nO1xuICAgICAgICBzdW1tYXJ5LmZvbnRTaXplID0gZm10LmZvbnRTaXplO1xuICAgICAgICBzdW1tYXJ5LmZvbnRGYW1pbHkgPSBmbXQuZm9udEZhbWlseTtcbiAgICAgICAgc3VtbWFyeS5hbGlnbm1lbnQgPSBmbXQuYWxpZ25tZW50O1xuICAgICAgICBzdW1tYXJ5LmZpbGxDb2xvciA9IGZtdC5maWxsQ29sb3I7XG4gICAgICAgIHN1bW1hcnkuZm9udFN0eWxlID0gZm10LmZvbnRTdHlsZTtcbiAgICAgICAgc3VtbWFyeS5sZWFkaW5nID0gZm10LmxlYWRpbmc7XG4gICAgICAgIHN1bW1hcnkubGVhZGluZ1R5cGUgPSBmbXQubGVhZGluZ1R5cGU7XG4gICAgICAgIHN1bW1hcnkuZWZmZWN0aXZlTGluZUhlaWdodCA9IGZtdC5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xuICAgICAgICBzdW1tYXJ5LnRyYWNraW5nID0gZm10LnRyYWNraW5nO1xuICAgICAgICBzdW1tYXJ5Lmtlcm5pbmcgPSBmbXQua2VybmluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VtbWFyeTtcbiAgfVxuXG4gIC8vIE5FVzogUHJvY2VzcyBsZWFkaW5nIHZhbHVlcyB3aXRoIEluRGVzaWduLXNwZWNpZmljIGxvZ2ljIChzaGFyZWQgd2l0aCBTdG9yeVBhcnNlcilcbiAgcHJvY2Vzc0xlYWRpbmdWYWx1ZShyYXdMZWFkaW5nLCBmb250U2l6ZSkge1xuICAgIGlmICghcmF3TGVhZGluZykgcmV0dXJuIFwiYXV0b1wiO1xuXG4gICAgLy8gSGFuZGxlIFwiYXV0b1wiIGxlYWRpbmdcbiAgICBpZiAocmF3TGVhZGluZyA9PT0gXCJhdXRvXCIgfHwgcmF3TGVhZGluZyA9PT0gXCJBdXRvXCIpIHtcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IGZvbnRTaXplICogMS4yIDogXCJhdXRvXCI7IC8vIEluRGVzaWduIGRlZmF1bHQgYXV0byBsZWFkaW5nIGlzIDEyMCVcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbnVtZXJpYyBsZWFkaW5nIChpbiBwb2ludHMpXG4gICAgY29uc3QgbnVtZXJpY0xlYWRpbmcgPSBwYXJzZUZsb2F0KHJhd0xlYWRpbmcpO1xuICAgIGlmICghaXNOYU4obnVtZXJpY0xlYWRpbmcpKSB7XG4gICAgICByZXR1cm4gbnVtZXJpY0xlYWRpbmc7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHBlcmNlbnRhZ2UtYmFzZWQgbGVhZGluZ1xuICAgIGlmIChyYXdMZWFkaW5nLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQocmF3TGVhZGluZy5yZXBsYWNlKFwiJVwiLCBcIlwiKSk7XG4gICAgICByZXR1cm4gZm9udFNpemUgPyAoZm9udFNpemUgKiBwZXJjZW50YWdlKSAvIDEwMCA6IFwiYXV0b1wiO1xuICAgIH1cblxuICAgIHJldHVybiBcImF1dG9cIjtcbiAgfVxuXG4gIC8vIE5FVzogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGxlYWRpbmcgYmVpbmcgdXNlZFxuICBkZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSB7XG4gICAgaWYgKCFyYXdMZWFkaW5nIHx8IHJhd0xlYWRpbmcgPT09IFwiYXV0b1wiIHx8IHJhd0xlYWRpbmcgPT09IFwiQXV0b1wiKSB7XG4gICAgICByZXR1cm4gXCJhdXRvXCI7XG4gICAgfVxuXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICByZXR1cm4gXCJwZXJjZW50YWdlXCI7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KHJhd0xlYWRpbmcpKSkge1xuICAgICAgcmV0dXJuIFwiYWJzb2x1dGVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIH1cblxuICAvLyBORVc6IENhbGN1bGF0ZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgZm9yIENTUyByZW5kZXJpbmdcbiAgY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChsZWFkaW5nLCBmb250U2l6ZSkge1xuICAgIGlmIChsZWFkaW5nID09PSBcImF1dG9cIikge1xuICAgICAgcmV0dXJuIDEuMjsgLy8gQ1NTIGxpbmUtaGVpZ2h0IHJhdGlvIGZvciBhdXRvXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsZWFkaW5nID09PSBcIm51bWJlclwiICYmIGZvbnRTaXplKSB7XG4gICAgICAvLyBDb252ZXJ0IHBvaW50cyB0byBDU1MgbGluZS1oZWlnaHQgcmF0aW9cbiAgICAgIHJldHVybiBNYXRoLm1heCgwLjgsIGxlYWRpbmcgLyBmb250U2l6ZSk7IC8vIEVuc3VyZSBtaW5pbXVtIGxpbmUgaGVpZ2h0XG4gICAgfVxuXG4gICAgcmV0dXJuIDEuMjsgLy8gRmFsbGJhY2tcbiAgfVxuXG4gIGdldFN0eWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZXM7XG4gIH1cblxuICBnZXRSZXNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzO1xuICB9XG5cbiAgZ2V0Rm9udE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb250TWFwO1xuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHMgdG8gcmV0dXJuIHN0eWxlIGFuZCBmb250IGRlZmluaXRpb25zIGZvciBkZWJ1Z1xuICBnZXRQYXJhZ3JhcGhTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzLnBhcmFncmFwaDtcbiAgfVxuICBnZXRDaGFyYWN0ZXJTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzLmNoYXJhY3RlcjtcbiAgfVxuICBnZXRGb250RGVmaW5pdGlvbnMoKSB7XG4gICAgLy8gUHJlZmVyIHBsYWluIG9iamVjdCBmb3IgZGVidWcgb3V0cHV0XG4gICAgaWYgKHRoaXMucmVzb3VyY2VzICYmIHRoaXMucmVzb3VyY2VzLmZvbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXMuZm9udHM7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrOiBjb252ZXJ0IGZvbnRNYXAgdG8gb2JqZWN0XG4gICAgaWYgKHRoaXMuZm9udE1hcCAmJiB0eXBlb2YgdGhpcy5mb250TWFwLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLmZvbnRNYXAuZW50cmllcygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gRklYRUQ6IEFkZCBtZXRob2QgdG8gYWNjZXNzIGRvY3VtZW50IHByZWZlcmVuY2VzIGluY2x1ZGluZyBWaWV3UHJlZmVyZW5jZXNcbiAgZ2V0RG9jdW1lbnRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50SW5mbztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlUGFyc2VyO1xuIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiSURNTFV0aWxzIiwiU3R5bGVQYXJzZXIiLCJzZXREb2N1bWVudFVuaXRzIiwidW5pdHMiLCJkb2N1bWVudFVuaXRzIiwiY29uc29sZSIsImxvZyIsImNvbnZlcnRUeXBvZ3JhcGh5VG9QaXhlbHMiLCJ2YWx1ZSIsImlzTmFOIiwidW5pdENvbnZlcnRlciIsImlzU3VwcG9ydGVkVW5pdCIsImNvbnZlcnRlZFZhbHVlIiwidG9QaXhlbHMiLCJjb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyIsInN0eWxlIiwiY29udmVydGVkU3R5bGUiLCJtZWFzdXJlbWVudEZpZWxkcyIsImZvckVhY2giLCJmaWVsZCIsImxlYWRpbmciLCJwYXJzZVJlc291cmNlRmlsZSIsImZpbGVOYW1lIiwiY29udGVudCIsInhtbFBhcnNlciIsInBhcnNlZCIsInBhcnNlIiwicmVzb3VyY2VOYW1lIiwiYmFzZW5hbWUiLCJpbmNsdWRlcyIsImV4dHJhY3RTdHlsZXMiLCJleHRyYWN0Rm9udHMiLCJleHRyYWN0R3JhcGhpY3MiLCJleHRyYWN0UHJlZmVyZW5jZXMiLCJlcnJvciIsIm1lc3NhZ2UiLCJzdHlsZXNEYXRhIiwic3R5bGVzIiwiU3R5bGVzIiwiUm9vdFBhcmFncmFwaFN0eWxlR3JvdXAiLCJleHRyYWN0UGFyYWdyYXBoU3R5bGVzIiwiUm9vdENoYXJhY3RlclN0eWxlR3JvdXAiLCJleHRyYWN0Q2hhcmFjdGVyU3R5bGVzIiwic3R5bGVHcm91cCIsImV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseSIsImdyb3VwIiwiUGFyYWdyYXBoU3R5bGUiLCJBcnJheSIsImlzQXJyYXkiLCJmb250UmVmIiwiZXh0cmFjdEZvbnRGcm9tU3R5bGUiLCJmb250U2l6ZSIsInBhcnNlRmxvYXQiLCJyYXdMZWFkaW5nIiwicHJvY2Vzc2VkTGVhZGluZyIsInByb2Nlc3NMZWFkaW5nVmFsdWUiLCJyYXdMZWZ0SW5kZW50IiwicmF3UmlnaHRJbmRlbnQiLCJyYXdGaXJzdExpbmVJbmRlbnQiLCJyYXdTcGFjZUJlZm9yZSIsInJhd1NwYWNlQWZ0ZXIiLCJyYXdUcmFja2luZyIsInJhd0tlcm5pbmciLCJiYXNlU3R5bGUiLCJzZWxmIiwibmFtZSIsImZvbnRTdHlsZSIsInBvaW50U2l6ZSIsImxlYWRpbmdUeXBlIiwiZGV0ZXJtaW5lTGVhZGluZ1R5cGUiLCJlZmZlY3RpdmVMaW5lSGVpZ2h0IiwiY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodCIsImFsaWdubWVudCIsImxlZnRJbmRlbnQiLCJyaWdodEluZGVudCIsImZpcnN0TGluZUluZGVudCIsInNwYWNlQmVmb3JlIiwic3BhY2VBZnRlciIsInRyYWNraW5nIiwia2VybmluZyIsIm9yaWdpbmFsTGVmdEluZGVudCIsIm9yaWdpbmFsUmlnaHRJbmRlbnQiLCJvcmlnaW5hbEZpcnN0TGluZUluZGVudCIsIm9yaWdpbmFsU3BhY2VCZWZvcmUiLCJvcmlnaW5hbFNwYWNlQWZ0ZXIiLCJvcmlnaW5hbFRyYWNraW5nIiwib3JpZ2luYWxLZXJuaW5nIiwiaG9yaXpvbnRhbFNjYWxlIiwidmVydGljYWxTY2FsZSIsImFwcGxpZWRGb250Iiwib3JpZ2luYWxGb250UmVmIiwiZmlsbENvbG9yIiwicmF3U3R5bGUiLCJwYXJhZ3JhcGgiLCJQYXJhZ3JhcGhTdHlsZUdyb3VwIiwic3ViR3JvdXBzIiwiUHJvcGVydGllcyIsIkFwcGxpZWRGb250IiwiRm9udEZhbWlseSIsIkNoYXJhY3RlclN0eWxlIiwiY2hhcmFjdGVyIiwic3Ryb2tlQ29sb3IiLCJDaGFyYWN0ZXJTdHlsZUdyb3VwIiwiZm9udHNEYXRhIiwiZm9udHMiLCJGb250cyIsInJlc291cmNlcyIsImZvbnRNYXAiLCJNYXAiLCJmb250RmFtaWxpZXMiLCJmYW1pbHkiLCJmYW1pbHlJbmZvIiwiRm9udCIsImZvbnRMaXN0IiwiZm9udCIsImZvbnRJbmZvIiwiZm9udEZhbWlseSIsInBvc3RTY3JpcHROYW1lIiwic3RhdHVzIiwiZm9udFN0eWxlTmFtZSIsInB1c2giLCJzZXQiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwic2l6ZSIsImdyYXBoaWNzRGF0YSIsImdyYXBoaWNzIiwiR3JhcGhpYyIsImNvbG9ycyIsImdyYWRpZW50cyIsIkNvbG9yIiwiY29sb3IiLCJjeWFuIiwibWFnZW50YSIsInllbGxvdyIsImJsYWNrIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwiY29sb3JTcGFjZSIsImNvbG9yTW9kZWwiLCJjb2xvclZhbHVlIiwiY29sb3JOYW1lIiwiY29sb3JTZWxmIiwiaXNDdXN0b21Db2xvciIsImlzQ3VzdG9tQ29sb3JOYW1lIiwiZmluYWxDb2xvckRhdGEiLCJtb2RlbCIsInNwYWNlIiwiY29sb3JTb3VyY2UiLCJoYXNEaXJlY3RSR0IiLCJoYXNEaXJlY3RDTVlLIiwiaGFzQ29sb3JWYWx1ZSIsInZhbHVlUGFydHMiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImZpbHRlciIsInYiLCJzb3VyY2UiLCJoYXNSR0IiLCJoYXNDTVlLIiwiaXNDdXN0b20iLCJyZ2IiLCJjbXlrIiwiR3JhZGllbnQiLCJncmFkaWVudCIsInR5cGUiLCJncmFkaWVudFN0b3BzIiwiZXh0cmFjdEdyYWRpZW50U3RvcHMiLCJzdGFuZGFyZENvbG9ycyIsImNteWtQYXR0ZXJuIiwicmdiUGF0dGVybiIsInRlc3QiLCJjdXN0b21Db2xvclBhdHRlcm5zIiwiaGFzQ3VzdG9tUGF0dGVybiIsInNvbWUiLCJwYXR0ZXJuIiwic3RvcHMiLCJHcmFkaWVudFN0b3AiLCJzdG9wTGlzdCIsInN0b3AiLCJzdG9wQ29sb3IiLCJsb2NhdGlvbiIsIm1pZHBvaW50IiwicHJlZmVyZW5jZXNEYXRhIiwicHJlZnMiLCJQcmVmZXJlbmNlcyIsImRvY3VtZW50SW5mbyIsInByZWZlcmVuY2VzIiwiZG9jdW1lbnRQcmVmZXJlbmNlcyIsImV4dHJhY3REb2N1bWVudFByZWZzIiwiRG9jdW1lbnRQcmVmZXJlbmNlIiwidmlld1ByZWZlcmVuY2VzIiwiZXh0cmFjdFZpZXdQcmVmcyIsIlZpZXdQcmVmZXJlbmNlIiwiZ3VpZGVQcmVmZXJlbmNlcyIsImV4dHJhY3RHdWlkZVByZWZzIiwiR3VpZGVQcmVmZXJlbmNlIiwiZ3JpZFByZWZlcmVuY2VzIiwiZXh0cmFjdEdyaWRQcmVmcyIsIkdyaWRQcmVmZXJlbmNlIiwibWFyZ2luUHJlZmVyZW5jZXMiLCJleHRyYWN0TWFyZ2luUHJlZnMiLCJNYXJnaW5QcmVmZXJlbmNlIiwiY29sdW1uUHJlZmVyZW5jZXMiLCJleHRyYWN0Q29sdW1uUHJlZnMiLCJDb2x1bW5QcmVmZXJlbmNlIiwiZG9jUHJlZiIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJjb2x1bW5Db3VudCIsInBhcnNlSW50IiwiY29sdW1uR3V0dGVyIiwiZmFjaW5nUGFnZXMiLCJhbGxvd1BhZ2VTaHVmZmxlIiwic2x1Z0JsZWVkVHlwZSIsImRvY3VtZW50QmxlZWRUb3BPZmZzZXQiLCJkb2N1bWVudEJsZWVkQm90dG9tT2Zmc2V0IiwiZG9jdW1lbnRCbGVlZEluc2lkZU9yTGVmdE9mZnNldCIsImRvY3VtZW50QmxlZWRPdXRzaWRlT3JSaWdodE9mZnNldCIsInZpZXdQcmVmIiwiaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHMiLCJ2ZXJ0aWNhbE1lYXN1cmVtZW50VW5pdHMiLCJydWxlck9yaWdpbiIsInNob3dSdWxlcnMiLCJndWlkZVByZWYiLCJydWxlckd1aWRlQ29sb3IiLCJndWlkZXNJbkJhY2siLCJndWlkZXNMb2NrZWQiLCJndWlkZXNTaG93biIsImd1aWRlc1NuYXB0byIsImdyaWRQcmVmIiwiYmFzZWxpbmVTdGFydCIsImJhc2VsaW5lRGl2aXNpb24iLCJiYXNlbGluZVNob3duIiwiYmFzZWxpbmVTbmFwdG8iLCJkb2N1bWVudEdyaWRTaG93biIsImRvY3VtZW50R3JpZFNuYXB0byIsIm1hcmdpblByZWYiLCJjb2x1bW5QcmVmIiwidGV4dENvbHVtbkNvdW50IiwidGV4dENvbHVtbkd1dHRlciIsInJlc29sdmVTdHlsZUZvcm1hdHRpbmciLCJmb3JtYXR0aW5nIiwicmVzb2x2ZWQiLCJoYXNBbnlGb3JtYXR0aW5nIiwicGFyYWdyYXBoU3R5bGUiLCJjaGFyYWN0ZXJTdHlsZSIsImZvbnRSZWZlcmVuY2UiLCJkaXJlY3RGb250U3R5bGUiLCJkaXJlY3RGb250UmVmIiwiZGlyZWN0Rm9udFNpemUiLCJwU3R5bGUiLCJyZXNvbHZlRm9udFJlZmVyZW5jZSIsImNTdHlsZSIsInVuZGVmaW5lZCIsImdldERlZmF1bHRGb250IiwiaGFzIiwicmVzb2x2ZWRGb250IiwiZ2V0IiwiZmFtaWx5SWQiLCJlbnRyaWVzIiwidG9Mb3dlckNhc2UiLCJmaXJzdEZhbWlseSIsInZhbHVlcyIsImluZmVyRm9udEZyb21Db250ZXh0IiwiZmlyc3RGb250RmFtaWx5IiwiZ2V0U3RvcnlTdHlsZVN1bW1hcnkiLCJzdG9yeSIsInN1bW1hcnkiLCJmb3JtYXR0ZWRDb250ZW50IiwiZmlyc3RGb3JtYXR0ZWQiLCJmaW5kIiwiaXRlbSIsImlzQnJlYWsiLCJmbXQiLCJudW1lcmljTGVhZGluZyIsInBlcmNlbnRhZ2UiLCJyZXBsYWNlIiwiTWF0aCIsIm1heCIsImdldFN0eWxlcyIsImdldFJlc291cmNlcyIsImdldEZvbnRNYXAiLCJnZXRQYXJhZ3JhcGhTdHlsZXMiLCJnZXRDaGFyYWN0ZXJTdHlsZXMiLCJnZXRGb250RGVmaW5pdGlvbnMiLCJmcm9tRW50cmllcyIsImdldERvY3VtZW50SW5mbyIsImNvbnN0cnVjdG9yIiwib2JqZWN0IiwidGFibGUiLCJjZWxsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/parsers/StyleParser.js\n"));

/***/ })

});