"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StoryParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StoryParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StoryParser {\n    async parseStoryFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCDD Parsing story: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const storyId = path.basename(fileName, \".xml\");\n            const storyData = parsed.Story || parsed;\n            // ADD THESE SIMPLE LOGS FIRST:\n            console.log(\"=== SIMPLE DEBUG TEST ===\");\n            console.log(\"Story file name:\", fileName);\n            console.log(\"Parsed story keys:\", Object.keys(storyData));\n            console.log(\"Raw story data sample:\", JSON.stringify(storyData, null, 2).substring(0, 500));\n            // Extract detailed story information\n            const detailedStory = {\n                self: storyData[\"@_Self\"],\n                appliedTOCStyle: storyData[\"@_AppliedTOCStyle\"] || \"n\",\n                userText: storyData[\"@_UserText\"] !== false,\n                // Extract story content with formatting\n                content: this.extractDetailedStoryContent(storyData),\n                // Extract text formatting\n                textFormatting: this.extractTextFormatting(storyData)\n            };\n            const cleanStoryId = storyId.replace(\"Story_\", \"\");\n            this.stories[cleanStoryId] = detailedStory;\n            // Enhanced logging to show line breaks\n            const { plainText, lineBreakInfo } = detailedStory.content;\n            console.log(\"✅ Story \".concat(storyId, \" parsed:\"));\n            console.log(\"   - Characters: \".concat(plainText.length));\n            console.log(\"   - Words: \".concat(detailedStory.content.wordCount));\n            console.log(\"   - Line breaks: \".concat((lineBreakInfo === null || lineBreakInfo === void 0 ? void 0 : lineBreakInfo.lineBreakCount) || 0));\n            console.log('   - Text preview: \"'.concat(plainText.substring(0, 50).replace(/\\n/g, \"\\\\n\"), '...\"'));\n        } catch (error) {\n            console.error(\"❌ Error parsing story \".concat(fileName, \":\"), error.message);\n        }\n    }\n    // Replace the existing extractDetailedStoryContent method with this corrected version\n    extractDetailedStoryContent(storyData) {\n        var _this = this;\n        let content = \"\";\n        let formattedContent = [];\n        let textColor = null;\n        let debugInfo = [];\n        const extractTextRecursively = function(element) {\n            let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (typeof element === \"string\") {\n                content += element;\n                return;\n            }\n            if (element && typeof element === \"object\") {\n                // ENHANCED: Special handling for CharacterStyleRange with sophisticated Br detection\n                if (element.CharacterStyleRange) {\n                    const ranges = Array.isArray(element.CharacterStyleRange) ? element.CharacterStyleRange : [\n                        element.CharacterStyleRange\n                    ];\n                    // SIMPLIFIED DEBUG: Just log problematic text ranges\n                    const allRangeContent = ranges.map((r)=>r.Content ? Array.isArray(r.Content) ? r.Content.join(\"\") : String(r.Content) : \"\").join(\"\");\n                    if (allRangeContent.includes(\"pavoluptusda\") || allRangeContent.includes(\"pa\") || allRangeContent.includes(\"voluptusda\")) {\n                        console.log(\"\\uD83D\\uDEA8 FOUND RANGES WITH PROBLEMATIC TEXT:\");\n                        ranges.forEach((range, index)=>{\n                            const content = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                            console.log(\"   Range \".concat(index, ': \"').concat(content, '\"'));\n                        });\n                    }\n                    ranges.forEach((range, rangeIndex)=>{\n                        // Extract direct font references from the XML range\n                        const directFontRef = range[\"@_AppliedFont\"] || range[\"@_FontFamily\"] || range[\"@_Font\"] || \"\";\n                        const formatting = {\n                            paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                            characterStyle: range[\"@_AppliedCharacterStyle\"] || null,\n                            fontSize: range[\"@_PointSize\"] ? parseFloat(range[\"@_PointSize\"]) : null,\n                            fontReference: directFontRef,\n                            fillColor: range[\"@_FillColor\"] || null,\n                            fontStyle: range[\"@_FontStyle\"] || null\n                        };\n                        // DEBUG: Log formatting extraction for any styled text (generic check)\n                        const rangeContent = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                        const hasStyleInfo = range[\"@_FontStyle\"] || range[\"@_AppliedCharacterStyle\"] || element[\"@_AppliedParagraphStyle\"] || range[\"@_AppliedFont\"];\n                        if (hasStyleInfo && rangeContent.trim()) {\n                            console.log(\"\\uD83D\\uDD27 StoryParser - Extracting formatting for range:\", JSON.stringify(rangeContent.substring(0, 30) + \"...\"), {\n                                rawRangeAttributes: Object.keys(range).filter((k)=>k.startsWith(\"@_\")),\n                                extractedFormatting: formatting,\n                                fontStyleFromXML: range[\"@_FontStyle\"],\n                                characterStyleFromXML: range[\"@_AppliedCharacterStyle\"],\n                                paragraphStyleFromXML: element[\"@_AppliedParagraphStyle\"]\n                            });\n                        }\n                        const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                        // FIXED: Process content with proper space preservation\n                        if (range.Content) {\n                            const contents = Array.isArray(range.Content) ? range.Content : [\n                                range.Content\n                            ];\n                            contents.forEach((contentItem, contentIndex)=>{\n                                const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n                                content += text;\n                                formattedContent.push({\n                                    text: text,\n                                    formatting: resolvedFormatting\n                                });\n                                // CRITICAL FIX: Check for Br elements AFTER each content item within the same range\n                                if (range.Br !== undefined && contentIndex < contents.length - 1) {\n                                    const lineBreakText = \"\\n\";\n                                    content += lineBreakText;\n                                    formattedContent.push({\n                                        text: lineBreakText,\n                                        formatting: {\n                                            isBreak: true,\n                                            breakType: \"line\",\n                                            position: \"between_content\",\n                                            source: \"Br element within range\"\n                                        }\n                                    });\n                                    debugInfo.push({\n                                        type: \"Line break detected within content\",\n                                        location: \"CharacterStyleRange[\".concat(rangeIndex, \"], between content[\").concat(contentIndex, \"] and content[\").concat(contentIndex + 1, \"]\"),\n                                        breakType: \"line\",\n                                        context: context\n                                    });\n                                }\n                            });\n                        }\n                        // Handle Br elements at the end of the range\n                        if (range.Br !== undefined && (!range.Content || Array.isArray(range.Content) === false)) {\n                            const brElements = _this.extractBrElements(range);\n                            brElements.forEach((brInfo, brIndex)=>{\n                                const lineBreakText = _this.determineLineBreakType(brInfo, context);\n                                content += lineBreakText;\n                                formattedContent.push({\n                                    text: lineBreakText,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: brInfo.type || \"line\",\n                                        position: brInfo.position || \"end\",\n                                        source: \"Br element at end of range\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Line break detected at end of range\",\n                                    location: \"CharacterStyleRange[\".concat(rangeIndex, \"], Br[\").concat(brIndex, \"]\"),\n                                    breakType: brInfo.type || \"line\",\n                                    context: context\n                                });\n                            });\n                        }\n                        // CRITICAL FIX: Add space between character style ranges if needed\n                        if (rangeIndex < ranges.length - 1) {\n                            const nextRange = ranges[rangeIndex + 1];\n                            // More robust space detection\n                            const currentText = content.slice(-10); // Check last 10 characters\n                            const currentRangeEndsWithSpace = /\\s$/.test(currentText); // Any whitespace at end\n                            const nextContent = nextRange.Content ? String(Array.isArray(nextRange.Content) ? nextRange.Content[0] : nextRange.Content) : \"\";\n                            const nextRangeStartsWithSpace = /^\\s/.test(nextContent); // Any whitespace at start\n                            // AGGRESSIVE FIX: Add space between ALL ranges unless explicitly not needed\n                            const shouldSkipSpace = currentRangeEndsWithSpace || nextRangeStartsWithSpace || _this.shouldInsertImplicitLineBreak(range, nextRange, context) || !nextRange.Content || // Skip if next range has no content\n                            nextContent.trim() === \"\"; // Skip if next content is only whitespace\n                            if (!shouldSkipSpace) {\n                                const currentStyle = range[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const nextStyle = nextRange[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const spaceText = \" \";\n                                content += spaceText;\n                                formattedContent.push({\n                                    text: spaceText,\n                                    formatting: {\n                                        isSpace: true,\n                                        source: \"between character style ranges (aggressive)\",\n                                        currentStyle,\n                                        nextStyle\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Space inserted between character styles (aggressive)\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    currentStyle,\n                                    nextStyle,\n                                    reason: \"Default space insertion - words likely split across ranges\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            } else {\n                                debugInfo.push({\n                                    type: \"Space insertion skipped\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    reason: currentRangeEndsWithSpace ? \"Current range ends with space\" : nextRangeStartsWithSpace ? \"Next range starts with space\" : !nextRange.Content ? \"Next range has no content\" : nextContent.trim() === \"\" ? \"Next content is only whitespace\" : \"Line break would be inserted\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            }\n                            // Handle explicit line breaks between ranges (for cases where shouldInsertImplicitLineBreak is true)\n                            if (_this.shouldInsertImplicitLineBreak(range, nextRange, context)) {\n                                const implicitBreak = \"\\n\";\n                                content += implicitBreak;\n                                formattedContent.push({\n                                    text: implicitBreak,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: \"implicit\",\n                                        source: \"between ranges\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Implicit line break\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1)\n                                });\n                            }\n                        }\n                    });\n                    return; // Don't continue processing to avoid duplication\n                }\n                // ENHANCED: Handle ParagraphStyleRange with context\n                if (element.ParagraphStyleRange) {\n                    const ranges = Array.isArray(element.ParagraphStyleRange) ? element.ParagraphStyleRange : [\n                        element.ParagraphStyleRange\n                    ];\n                    ranges.forEach((range, index)=>{\n                        const paragraphContext = {\n                            ...context,\n                            paragraphIndex: index,\n                            totalParagraphs: ranges.length,\n                            appliedStyle: range[\"@_AppliedParagraphStyle\"]\n                        };\n                        extractTextRecursively(range, depth + 1, paragraphContext);\n                        // Add paragraph break between paragraphs (but not after the last one)\n                        if (index < ranges.length - 1) {\n                            const paragraphBreak = \"\\n\";\n                            content += paragraphBreak;\n                            formattedContent.push({\n                                text: paragraphBreak,\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"paragraph\",\n                                    source: \"between paragraphs\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Paragraph break\",\n                                location: \"between paragraphs \".concat(index, \" and \").concat(index + 1)\n                            });\n                        }\n                    });\n                    return;\n                }\n                // Handle direct Content elements (when not inside CharacterStyleRange)\n                if (element.Content && !element.CharacterStyleRange) {\n                    let text = Array.isArray(element.Content) ? element.Content.join(\"\") : String(element.Content);\n                    text = IDMLUtils.decodeXMLEntities(text);\n                    content += text;\n                    const formatting = {\n                        paragraphStyle: element[\"@_AppliedParagraphStyle\"] || null,\n                        characterStyle: element[\"@_AppliedCharacterStyle\"] || null,\n                        fontSize: element[\"@_PointSize\"] || null,\n                        fontFamily: element[\"@_AppliedFont\"] || null,\n                        fillColor: element[\"@_FillColor\"] || null\n                    };\n                    const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                    formattedContent.push({\n                        text: text,\n                        formatting: resolvedFormatting\n                    });\n                }\n                // ENHANCED: Direct Br element handling (outside of ranges)\n                if (element.Br !== undefined) {\n                    const brElements = Array.isArray(element.Br) ? element.Br : [\n                        element.Br\n                    ];\n                    brElements.forEach((br, index)=>{\n                        const lineBreakText = \"\\n\";\n                        content += lineBreakText;\n                        formattedContent.push({\n                            text: lineBreakText,\n                            formatting: {\n                                isBreak: true,\n                                breakType: \"explicit\",\n                                source: \"direct Br element\"\n                            }\n                        });\n                        debugInfo.push({\n                            type: \"Direct Br element\",\n                            location: \"Direct element, index \".concat(index)\n                        });\n                    });\n                }\n                // Continue with other nested elements\n                Object.entries(element).forEach((param)=>{\n                    let [key, value] = param;\n                    if (!key.startsWith(\"@_\") && key !== \"Content\" && key !== \"Br\" && key !== \"CharacterStyleRange\" && key !== \"ParagraphStyleRange\") {\n                        if (Array.isArray(value)) {\n                            value.forEach((item)=>extractTextRecursively(item, depth + 1, context));\n                        } else if (typeof value === \"object\" && depth < 10) {\n                            extractTextRecursively(value, depth + 1, context);\n                        }\n                    }\n                });\n            }\n        };\n        extractTextRecursively(storyData);\n        // ENHANCED: Process and clean up the content with sophisticated line break preservation\n        const processedContent = IDMLUtils.sophisticatedLineBreakProcessing(content);\n        // DEBUG: Log space preservation results\n        console.log(\"\\uD83D\\uDCDD Text extraction results:\");\n        console.log(\"   - Original content length:\", content.length);\n        console.log(\"   - Processed content length:\", processedContent.length);\n        console.log(\"   - Space preservation events:\", debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length);\n        // SPECIFIC DEBUG: Check for the problematic \"pavoluptusda\" text (simplified)\n        if (processedContent.includes(\"pavoluptusda\") || processedContent.includes(\"pa\") && processedContent.includes(\"voluptusda\")) {\n            console.log(\"\\uD83D\\uDEA8 FOUND PROBLEMATIC TEXT:\");\n            console.log('   - Contains \"pavoluptusda\":', processedContent.includes(\"pavoluptusda\"));\n            console.log('   - Contains \"pa voluptusda\":', processedContent.includes(\"pa voluptusda\"));\n            console.log(\"   - FormattedContent breakdown:\", formattedContent.map((item)=>item.text).join(\"|\"));\n        }\n        const lineBreakInfo = {\n            hasLineBreaks: processedContent.includes(\"\\n\"),\n            lineBreakCount: (processedContent.match(/\\n/g) || []).length,\n            lineBreakTypes: this.analyzeLineBreakTypes(formattedContent),\n            debugInfo: debugInfo,\n            spacePreservationCount: debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length\n        };\n        return {\n            plainText: processedContent,\n            formattedContent: formattedContent.filter((item)=>item.text && item.text.length > 0),\n            wordCount: IDMLUtils.countWords(processedContent.replace(/\\n/g, \" \")),\n            characterCount: processedContent.length,\n            textColor: textColor,\n            lineBreakInfo: lineBreakInfo\n        };\n    }\n    // Add this helper method to better handle mixed content and Br elements\n    analyzeContentStructure(range) {\n        const structure = {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentItems: range.Content ? Array.isArray(range.Content) ? range.Content : [\n                range.Content\n            ] : [],\n            brElements: range.Br ? Array.isArray(range.Br) ? range.Br : [\n                range.Br\n            ] : []\n        };\n        console.log(\"Content structure analysis:\", structure);\n        return structure;\n    }\n    // Enhanced helper for processing interleaved content and breaks\n    processInterleavedContent(range, resolvedFormatting) {\n        const results = [];\n        let content = \"\";\n        // This method would need access to the actual XML structure to determine\n        // the exact order of Content and Br elements. For now, we'll use the \n        // approach above which handles the most common case.\n        return results;\n    }\n    // SOPHISTICATED: Helper method to extract Br elements with context\n    extractBrElements(range) {\n        const brElements = [];\n        if (range.Br !== undefined) {\n            if (Array.isArray(range.Br)) {\n                range.Br.forEach((br, index)=>{\n                    brElements.push({\n                        type: \"line\",\n                        position: index === 0 ? \"start\" : \"middle\",\n                        element: br\n                    });\n                });\n            } else {\n                brElements.push({\n                    type: \"line\",\n                    position: \"end\",\n                    element: range.Br\n                });\n            }\n        }\n        return brElements;\n    }\n    // SOPHISTICATED: Determine the appropriate line break type\n    determineLineBreakType(brInfo, context) {\n        // Different line break characters based on context\n        switch(brInfo.type){\n            case \"paragraph\":\n                return \"\\n\\n\"; // Double line break for paragraph separation\n            case \"forced\":\n                return \"\\n\"; // Forced line break (Shift+Enter equivalent)\n            case \"line\":\n            default:\n                return \"\\n\"; // Standard line break\n        }\n    }\n    // SOPHISTICATED: Determine if an implicit line break should be inserted\n    shouldInsertImplicitLineBreak(currentRange, nextRange, context) {\n        // Don't insert implicit breaks if explicit Br elements are present\n        if (currentRange.Br !== undefined || nextRange.Br !== undefined) {\n            return false;\n        }\n        // Insert breaks between different character styles in different paragraphs\n        const currentCharStyle = currentRange[\"@_AppliedCharacterStyle\"];\n        const nextCharStyle = nextRange[\"@_AppliedCharacterStyle\"];\n        // If we're in a context where styles change significantly, add a break\n        if (currentCharStyle && nextCharStyle && currentCharStyle !== nextCharStyle) {\n            // Check if this might be a title/heading followed by body text\n            const styleIndicatesBreak = this.styleIndicatesLineBreak(currentCharStyle, nextCharStyle);\n            return styleIndicatesBreak;\n        }\n        return false;\n    }\n    // SOPHISTICATED: Analyze if style change indicates a line break\n    styleIndicatesLineBreak(currentStyle, nextStyle) {\n        const titleIndicators = [\n            \"title\",\n            \"heading\",\n            \"header\"\n        ];\n        const bodyIndicators = [\n            \"body\",\n            \"text\",\n            \"normal\"\n        ];\n        const currentIsTitle = titleIndicators.some((indicator)=>currentStyle.toLowerCase().includes(indicator));\n        const nextIsBody = bodyIndicators.some((indicator)=>nextStyle.toLowerCase().includes(indicator));\n        return currentIsTitle && nextIsBody;\n    }\n    // SOPHISTICATED: Analyze line break types in formatted content\n    analyzeLineBreakTypes(formattedContent) {\n        const types = {\n            explicit: 0,\n            implicit: 0,\n            paragraph: 0,\n            direct: 0 // Direct Br elements\n        };\n        formattedContent.forEach((item)=>{\n            var _item_formatting;\n            if ((_item_formatting = item.formatting) === null || _item_formatting === void 0 ? void 0 : _item_formatting.isBreak) {\n                const breakType = item.formatting.breakType || \"unknown\";\n                if (types.hasOwnProperty(breakType)) {\n                    types[breakType]++;\n                }\n            }\n        });\n        return types;\n    }\n    extractDetailedFormattingFromRange(range) {\n        const formatting = {};\n        // Extract all possible font attributes\n        const fontAttributes = [\n            \"@_AppliedFont\",\n            \"@_FontFamily\",\n            \"@_Font\",\n            \"@_PostScriptName\",\n            \"@_FontName\"\n        ];\n        fontAttributes.forEach((attr)=>{\n            if (range[attr]) {\n                formatting.fontReference = range[attr];\n            }\n        });\n        // Extract font and size attributes\n        formatting.fontSize = IDMLUtils.parseNumeric(range[\"@_PointSize\"]);\n        // ENHANCED: Extract leading with proper processing\n        const rawLeading = range[\"@_Leading\"];\n        formatting.leading = this.processLeadingValue(rawLeading, formatting.fontSize);\n        formatting.leadingType = this.determineLeadingType(rawLeading);\n        // Extract color and style attributes\n        formatting.fillColor = range[\"@_FillColor\"];\n        formatting.strokeColor = range[\"@_StrokeColor\"];\n        formatting.fontStyle = range[\"@_FontStyle\"];\n        // Extract advanced typography attributes\n        formatting.tracking = IDMLUtils.parseNumeric(range[\"@_Tracking\"]);\n        formatting.baselineShift = IDMLUtils.parseNumeric(range[\"@_BaselineShift\"]);\n        formatting.kerning = IDMLUtils.parseNumeric(range[\"@_Kerning\"]);\n        formatting.horizontalScale = IDMLUtils.parseNumeric(range[\"@_HorizontalScale\"]) || 100;\n        formatting.verticalScale = IDMLUtils.parseNumeric(range[\"@_VerticalScale\"]) || 100;\n        // Extract paragraph-level attributes if present\n        // CRITICAL FIX: Only set alignment if explicitly specified, allowing paragraph inheritance\n        const explicitAlignment = range[\"@_Justification\"] || range[\"@_Alignment\"];\n        if (explicitAlignment) {\n            formatting.alignment = explicitAlignment;\n        }\n        formatting.leftIndent = IDMLUtils.parseNumeric(range[\"@_LeftIndent\"]);\n        formatting.rightIndent = IDMLUtils.parseNumeric(range[\"@_RightIndent\"]);\n        formatting.firstLineIndent = IDMLUtils.parseNumeric(range[\"@_FirstLineIndent\"]);\n        formatting.spaceBefore = IDMLUtils.parseNumeric(range[\"@_SpaceBefore\"]);\n        formatting.spaceAfter = IDMLUtils.parseNumeric(range[\"@_SpaceAfter\"]);\n        // Calculate effective line height for CSS\n        formatting.effectiveLineHeight = this.calculateEffectiveLineHeight(formatting);\n        return formatting;\n    }\n    // NEW: Process leading values with InDesign-specific logic\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = IDMLUtils.parseNumeric(rawLeading);\n        if (numericLeading) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (IDMLUtils.parseNumeric(rawLeading)) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(formatting) {\n        const fontSize = formatting.fontSize || 12;\n        const leading = formatting.leading;\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\") {\n            // Convert points to CSS line-height ratio\n            return leading / fontSize;\n        }\n        return 1.2; // Fallback\n    }\n    extractTextFormatting(storyData) {\n        const formatting = {\n            paragraphStyles: [],\n            characterStyles: [],\n            appliedStyles: []\n        };\n        // Extract applied paragraph styles\n        if (storyData.ParagraphStyleRange) {\n            const ranges = Array.isArray(storyData.ParagraphStyleRange) ? storyData.ParagraphStyleRange : [\n                storyData.ParagraphStyleRange\n            ];\n            ranges.forEach((range)=>{\n                const appliedStyle = range[\"@_AppliedParagraphStyle\"];\n                if (appliedStyle && !formatting.paragraphStyles.includes(appliedStyle)) {\n                    formatting.paragraphStyles.push(appliedStyle);\n                }\n                // Extract character styles within paragraph ranges\n                if (range.CharacterStyleRange) {\n                    const charRanges = Array.isArray(range.CharacterStyleRange) ? range.CharacterStyleRange : [\n                        range.CharacterStyleRange\n                    ];\n                    charRanges.forEach((charRange)=>{\n                        const charStyle = charRange[\"@_AppliedCharacterStyle\"];\n                        if (charStyle && !formatting.characterStyles.includes(charStyle)) {\n                            formatting.characterStyles.push(charStyle);\n                        }\n                    });\n                }\n            });\n        }\n        return formatting;\n    }\n    // Add this method to debug raw story content\n    debugRawStoryContent(storyData) {\n        console.log(\"\\n\\uD83D\\uDD0D RAW STORY CONTENT DEBUG:\");\n        console.log(\"Story keys:\", Object.keys(storyData));\n        const findCharacterRanges = function(obj) {\n            let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key === \"CharacterStyleRange\") {\n                        console.log(\"\\n\\uD83D\\uDCDD Found CharacterStyleRange at \".concat(path, \":\"), obj[key]);\n                        const ranges = Array.isArray(obj[key]) ? obj[key] : [\n                            obj[key]\n                        ];\n                        ranges.forEach((range, index)=>{\n                            console.log(\"  Range \".concat(index + 1, \" attributes:\"), Object.keys(range).filter((k)=>k.startsWith(\"@_\")));\n                            console.log(\"  Range \".concat(index + 1, \" font info:\"), {\n                                AppliedFont: range[\"@_AppliedFont\"],\n                                FontStyle: range[\"@_FontStyle\"],\n                                PointSize: range[\"@_PointSize\"]\n                            });\n                        });\n                    } else if (typeof obj[key] === \"object\") {\n                        findCharacterRanges(obj[key], \"\".concat(path, \".\").concat(key));\n                    }\n                });\n            }\n        };\n        findCharacterRanges(storyData);\n    }\n    getStories() {\n        return this.stories;\n    }\n    getStory(storyId) {\n        return this.stories[storyId];\n    }\n    clearStories() {\n        this.stories = {};\n    }\n    constructor(styleParser){\n        this.styleParser = styleParser;\n        this.stories = {};\n    }\n}\nmodule.exports = StoryParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VSxDQUFDOzRCQUU5Q3BFLFFBQVFDLEdBQUcsQ0FBQyxXQUFxQixPQUFWaUQsUUFBUSxHQUFFLGdCQUFjO2dDQUM3Q2dKLGFBQWFqSixLQUFLLENBQUMsZ0JBQWdCO2dDQUNuQ2tKLFdBQVdsSixLQUFLLENBQUMsY0FBYztnQ0FDL0JtSixXQUFXbkosS0FBSyxDQUFDLGNBQWM7NEJBQ2pDO3dCQUNGO29CQUNGLE9BQU8sSUFBSSxPQUFPZ0osR0FBRyxDQUFDeEUsSUFBSSxLQUFLLFVBQVU7d0JBQ3ZDdUUsb0JBQW9CQyxHQUFHLENBQUN4RSxJQUFJLEVBQUUsR0FBV0EsT0FBUmpJLE1BQUssS0FBTyxPQUFKaUk7b0JBQzNDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBdUUsb0JBQW9CMUw7SUFDdEI7SUFFQStMLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQy9LLE9BQU87SUFDckI7SUFFQWdMLFNBQVNsTSxPQUFPLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNrQixPQUFPLENBQUNsQixRQUFRO0lBQzlCO0lBRUFtTSxlQUFlO1FBQ2IsSUFBSSxDQUFDakwsT0FBTyxHQUFHLENBQUM7SUFDbEI7SUF0ckJBa0wsWUFBWTlILFdBQVcsQ0FBRTtRQUN2QixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDcEQsT0FBTyxHQUFHLENBQUM7SUFDbEI7QUFvckJGO0FBRUFtTCxPQUFPQyxPQUFPLEdBQUcvTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGFyc2Vycy9TdG9yeVBhcnNlci5qcz82OGNmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL0lETUxVdGlscycpO1xyXG5cclxuY2xhc3MgU3RvcnlQYXJzZXIge1xyXG4gIGNvbnN0cnVjdG9yKHN0eWxlUGFyc2VyKSB7XHJcbiAgICB0aGlzLnN0eWxlUGFyc2VyID0gc3R5bGVQYXJzZXI7XHJcbiAgICB0aGlzLnN0b3JpZXMgPSB7fTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHBhcnNlU3RvcnlGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OdIFBhcnNpbmcgc3Rvcnk6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcclxuICAgICAgY29uc3Qgc3RvcnlJZCA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUsICcueG1sJyk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzdG9yeURhdGEgPSBwYXJzZWQuU3RvcnkgfHwgcGFyc2VkO1xyXG4gICAgICBcclxuICAgICAgLy8gQUREIFRIRVNFIFNJTVBMRSBMT0dTIEZJUlNUOlxyXG4gICAgICBjb25zb2xlLmxvZygnPT09IFNJTVBMRSBERUJVRyBURVNUID09PScpO1xyXG4gICAgICBjb25zb2xlLmxvZygnU3RvcnkgZmlsZSBuYW1lOicsIGZpbGVOYW1lKTtcclxuICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCBzdG9yeSBrZXlzOicsIE9iamVjdC5rZXlzKHN0b3J5RGF0YSkpO1xyXG4gICAgICBjb25zb2xlLmxvZygnUmF3IHN0b3J5IGRhdGEgc2FtcGxlOicsIEpTT04uc3RyaW5naWZ5KHN0b3J5RGF0YSwgbnVsbCwgMikuc3Vic3RyaW5nKDAsIDUwMCkpO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBkZXRhaWxlZCBzdG9yeSBpbmZvcm1hdGlvblxyXG4gICAgICBjb25zdCBkZXRhaWxlZFN0b3J5ID0ge1xyXG4gICAgICAgIHNlbGY6IHN0b3J5RGF0YVsnQF9TZWxmJ10sXHJcbiAgICAgICAgYXBwbGllZFRPQ1N0eWxlOiBzdG9yeURhdGFbJ0BfQXBwbGllZFRPQ1N0eWxlJ10gfHwgJ24nLFxyXG4gICAgICAgIHVzZXJUZXh0OiBzdG9yeURhdGFbJ0BfVXNlclRleHQnXSAhPT0gZmFsc2UsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXh0cmFjdCBzdG9yeSBjb250ZW50IHdpdGggZm9ybWF0dGluZ1xyXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50KHN0b3J5RGF0YSksXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXh0cmFjdCB0ZXh0IGZvcm1hdHRpbmdcclxuICAgICAgICB0ZXh0Rm9ybWF0dGluZzogdGhpcy5leHRyYWN0VGV4dEZvcm1hdHRpbmcoc3RvcnlEYXRhKVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2xlYW5TdG9yeUlkID0gc3RvcnlJZC5yZXBsYWNlKCdTdG9yeV8nLCAnJyk7XHJcbiAgICAgIHRoaXMuc3Rvcmllc1tjbGVhblN0b3J5SWRdID0gZGV0YWlsZWRTdG9yeTtcclxuICAgICAgXHJcbiAgICAgIC8vIEVuaGFuY2VkIGxvZ2dpbmcgdG8gc2hvdyBsaW5lIGJyZWFrc1xyXG4gICAgICBjb25zdCB7IHBsYWluVGV4dCwgbGluZUJyZWFrSW5mbyB9ID0gZGV0YWlsZWRTdG9yeS5jb250ZW50O1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFN0b3J5ICR7c3RvcnlJZH0gcGFyc2VkOmApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBDaGFyYWN0ZXJzOiAke3BsYWluVGV4dC5sZW5ndGh9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIFdvcmRzOiAke2RldGFpbGVkU3RvcnkuY29udGVudC53b3JkQ291bnR9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIExpbmUgYnJlYWtzOiAke2xpbmVCcmVha0luZm8/LmxpbmVCcmVha0NvdW50IHx8IDB9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAtIFRleHQgcHJldmlldzogXCIke3BsYWluVGV4dC5zdWJzdHJpbmcoMCwgNTApLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKX0uLi5cImApO1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBwYXJzaW5nIHN0b3J5ICR7ZmlsZU5hbWV9OmAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVwbGFjZSB0aGUgZXhpc3RpbmcgZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50IG1ldGhvZCB3aXRoIHRoaXMgY29ycmVjdGVkIHZlcnNpb25cclxuICBleHRyYWN0RGV0YWlsZWRTdG9yeUNvbnRlbnQoc3RvcnlEYXRhKSB7XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgbGV0IGZvcm1hdHRlZENvbnRlbnQgPSBbXTtcclxuICAgIGxldCB0ZXh0Q29sb3IgPSBudWxsO1xyXG4gICAgbGV0IGRlYnVnSW5mbyA9IFtdO1xyXG4gICAgXHJcbiAgICBjb25zdCBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5ID0gKGVsZW1lbnQsIGRlcHRoID0gMCwgY29udGV4dCA9IHt9KSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb250ZW50ICs9IGVsZW1lbnQ7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyBFTkhBTkNFRDogU3BlY2lhbCBoYW5kbGluZyBmb3IgQ2hhcmFjdGVyU3R5bGVSYW5nZSB3aXRoIHNvcGhpc3RpY2F0ZWQgQnIgZGV0ZWN0aW9uXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpID8gXHJcbiAgICAgICAgICAgIGVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZSA6IFtlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTSU1QTElGSUVEIERFQlVHOiBKdXN0IGxvZyBwcm9ibGVtYXRpYyB0ZXh0IHJhbmdlc1xyXG4gICAgICAgICAgY29uc3QgYWxsUmFuZ2VDb250ZW50ID0gcmFuZ2VzLm1hcChyID0+IHIuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShyLkNvbnRlbnQpID8gci5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKHIuQ29udGVudCkpIDogJycpLmpvaW4oJycpO1xyXG4gICAgICAgICAgaWYgKGFsbFJhbmdlQ29udGVudC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykgfHwgYWxsUmFuZ2VDb250ZW50LmluY2x1ZGVzKCdwYScpIHx8IGFsbFJhbmdlQ29udGVudC5pbmNsdWRlcygndm9sdXB0dXNkYScpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5qoIEZPVU5EIFJBTkdFUyBXSVRIIFBST0JMRU1BVElDIFRFWFQ6Jyk7XHJcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmFuZ2UuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudCkgPyByYW5nZS5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKHJhbmdlLkNvbnRlbnQpKSA6ICcnO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBSYW5nZSAke2luZGV4fTogXCIke2NvbnRlbnR9XCJgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgcmFuZ2VJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBFeHRyYWN0IGRpcmVjdCBmb250IHJlZmVyZW5jZXMgZnJvbSB0aGUgWE1MIHJhbmdlXHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdEZvbnRSZWYgPSByYW5nZVsnQF9BcHBsaWVkRm9udCddIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVsnQF9Gb250RmFtaWx5J10gfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWydAX0ZvbnQnXSB8fCAnJztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7XHJcbiAgICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ10gfHwgY29udGV4dC5hcHBsaWVkU3R5bGUgfHwgbnVsbCxcclxuICAgICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZTogcmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgICBmb250U2l6ZTogcmFuZ2VbJ0BfUG9pbnRTaXplJ10gPyBwYXJzZUZsb2F0KHJhbmdlWydAX1BvaW50U2l6ZSddKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgZm9udFJlZmVyZW5jZTogZGlyZWN0Rm9udFJlZixcclxuICAgICAgICAgICAgICBmaWxsQ29sb3I6IHJhbmdlWydAX0ZpbGxDb2xvciddIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgZm9udFN0eWxlOiByYW5nZVsnQF9Gb250U3R5bGUnXSB8fCBudWxsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBERUJVRzogTG9nIGZvcm1hdHRpbmcgZXh0cmFjdGlvbiBmb3IgYW55IHN0eWxlZCB0ZXh0IChnZW5lcmljIGNoZWNrKVxyXG4gICAgICAgICAgICBjb25zdCByYW5nZUNvbnRlbnQgPSByYW5nZS5Db250ZW50ID8gXHJcbiAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudCkgPyByYW5nZS5Db250ZW50LmpvaW4oJycpIDogU3RyaW5nKHJhbmdlLkNvbnRlbnQpKSA6ICcnO1xyXG4gICAgICAgICAgICBjb25zdCBoYXNTdHlsZUluZm8gPSByYW5nZVsnQF9Gb250U3R5bGUnXSB8fCByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50WydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddIHx8IHJhbmdlWydAX0FwcGxpZWRGb250J107XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaGFzU3R5bGVJbmZvICYmIHJhbmdlQ29udGVudC50cmltKCkpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UpyBTdG9yeVBhcnNlciAtIEV4dHJhY3RpbmcgZm9ybWF0dGluZyBmb3IgcmFuZ2U6JywgSlNPTi5zdHJpbmdpZnkocmFuZ2VDb250ZW50LnN1YnN0cmluZygwLCAzMCkgKyAnLi4uJyksIHtcclxuICAgICAgICAgICAgICAgIHJhd1JhbmdlQXR0cmlidXRlczogT2JqZWN0LmtleXMocmFuZ2UpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnQF8nKSksXHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRGb3JtYXR0aW5nOiBmb3JtYXR0aW5nLFxyXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlRnJvbVhNTDogcmFuZ2VbJ0BfRm9udFN0eWxlJ10sXHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZUZyb21YTUw6IHJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddLFxyXG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGVGcm9tWE1MOiBlbGVtZW50WydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkRm9ybWF0dGluZyA9IHRoaXMuc3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZJWEVEOiBQcm9jZXNzIGNvbnRlbnQgd2l0aCBwcm9wZXIgc3BhY2UgcHJlc2VydmF0aW9uXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5Db250ZW50KSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudCA6IFtyYW5nZS5Db250ZW50XTtcclxuICAgICAgICAgICAgICBjb250ZW50cy5mb3JFYWNoKChjb250ZW50SXRlbSwgY29udGVudEluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gSURNTFV0aWxzLmRlY29kZVhNTEVudGl0aWVzKFN0cmluZyhjb250ZW50SXRlbSkpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBDaGVjayBmb3IgQnIgZWxlbWVudHMgQUZURVIgZWFjaCBjb250ZW50IGl0ZW0gd2l0aGluIHRoZSBzYW1lIHJhbmdlXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCAmJiBjb250ZW50SW5kZXggPCBjb250ZW50cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSAnXFxuJztcclxuICAgICAgICAgICAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzogeyBcclxuICAgICAgICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYmV0d2Vlbl9jb250ZW50JyxcclxuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ0JyIGVsZW1lbnQgd2l0aGluIHJhbmdlJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0xpbmUgYnJlYWsgZGV0ZWN0ZWQgd2l0aGluIGNvbnRlbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQ2hhcmFjdGVyU3R5bGVSYW5nZVske3JhbmdlSW5kZXh9XSwgYmV0d2VlbiBjb250ZW50WyR7Y29udGVudEluZGV4fV0gYW5kIGNvbnRlbnRbJHtjb250ZW50SW5kZXggKyAxfV1gLFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBCciBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSByYW5nZVxyXG4gICAgICAgICAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCAmJiAoIXJhbmdlLkNvbnRlbnQgfHwgQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA9PT0gZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgYnJFbGVtZW50cyA9IHRoaXMuZXh0cmFjdEJyRWxlbWVudHMocmFuZ2UpO1xyXG4gICAgICAgICAgICAgIGJyRWxlbWVudHMuZm9yRWFjaCgoYnJJbmZvLCBickluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gdGhpcy5kZXRlcm1pbmVMaW5lQnJlYWtUeXBlKGJySW5mbywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGxpbmVCcmVha1RleHQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHQsXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHsgXHJcbiAgICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6IGJySW5mby50eXBlIHx8ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYnJJbmZvLnBvc2l0aW9uIHx8ICdlbmQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ0JyIGVsZW1lbnQgYXQgZW5kIG9mIHJhbmdlJ1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnTGluZSBicmVhayBkZXRlY3RlZCBhdCBlbmQgb2YgcmFuZ2UnLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYENoYXJhY3RlclN0eWxlUmFuZ2VbJHtyYW5nZUluZGV4fV0sIEJyWyR7YnJJbmRleH1dYCxcclxuICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiBickluZm8udHlwZSB8fCAnbGluZScsXHJcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IEFkZCBzcGFjZSBiZXR3ZWVuIGNoYXJhY3RlciBzdHlsZSByYW5nZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChyYW5nZUluZGV4IDwgcmFuZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0UmFuZ2UgPSByYW5nZXNbcmFuZ2VJbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIE1vcmUgcm9idXN0IHNwYWNlIGRldGVjdGlvblxyXG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gY29udGVudC5zbGljZSgtMTApOyAvLyBDaGVjayBsYXN0IDEwIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlID0gL1xccyQvLnRlc3QoY3VycmVudFRleHQpOyAvLyBBbnkgd2hpdGVzcGFjZSBhdCBlbmRcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0Q29udGVudCA9IG5leHRSYW5nZS5Db250ZW50ID8gXHJcbiAgICAgICAgICAgICAgICBTdHJpbmcoQXJyYXkuaXNBcnJheShuZXh0UmFuZ2UuQ29udGVudCkgPyBuZXh0UmFuZ2UuQ29udGVudFswXSA6IG5leHRSYW5nZS5Db250ZW50KSA6ICcnO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSA9IC9eXFxzLy50ZXN0KG5leHRDb250ZW50KTsgLy8gQW55IHdoaXRlc3BhY2UgYXQgc3RhcnRcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBBR0dSRVNTSVZFIEZJWDogQWRkIHNwYWNlIGJldHdlZW4gQUxMIHJhbmdlcyB1bmxlc3MgZXhwbGljaXRseSBub3QgbmVlZGVkXHJcbiAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2tpcFNwYWNlID0gY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsocmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFuZXh0UmFuZ2UuQ29udGVudCB8fCAvLyBTa2lwIGlmIG5leHQgcmFuZ2UgaGFzIG5vIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb250ZW50LnRyaW0oKSA9PT0gJyc7IC8vIFNraXAgaWYgbmV4dCBjb250ZW50IGlzIG9ubHkgd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGlmICghc2hvdWxkU2tpcFNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGUgPSByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSB8fCAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U3R5bGUgPSBuZXh0UmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFjZVRleHQgPSAnICc7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IHNwYWNlVGV4dDtcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHNwYWNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzU3BhY2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGUgcmFuZ2VzIChhZ2dyZXNzaXZlKScsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdHlsZVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnU3BhY2UgaW5zZXJ0ZWQgYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGVzIChhZ2dyZXNzaXZlKScsXHJcbiAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQmV0d2VlbiByYW5nZXMgJHtyYW5nZUluZGV4fSBhbmQgJHtyYW5nZUluZGV4ICsgMX1gLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgIG5leHRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgcmVhc29uOiAnRGVmYXVsdCBzcGFjZSBpbnNlcnRpb24gLSB3b3JkcyBsaWtlbHkgc3BsaXQgYWNyb3NzIHJhbmdlcycsXHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0RW5kOiBjdXJyZW50VGV4dC5zbGljZSgtNSksXHJcbiAgICAgICAgICAgICAgICAgIG5leHRUZXh0U3RhcnQ6IG5leHRDb250ZW50LnNsaWNlKDAsIDUpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnU3BhY2UgaW5zZXJ0aW9uIHNraXBwZWQnLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7cmFuZ2VJbmRleCArIDF9YCxcclxuICAgICAgICAgICAgICAgICAgcmVhc29uOiBjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlID8gJ0N1cnJlbnQgcmFuZ2UgZW5kcyB3aXRoIHNwYWNlJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJhbmdlU3RhcnRzV2l0aFNwYWNlID8gJ05leHQgcmFuZ2Ugc3RhcnRzIHdpdGggc3BhY2UnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAhbmV4dFJhbmdlLkNvbnRlbnQgPyAnTmV4dCByYW5nZSBoYXMgbm8gY29udGVudCcgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29udGVudC50cmltKCkgPT09ICcnID8gJ05leHQgY29udGVudCBpcyBvbmx5IHdoaXRlc3BhY2UnIDogJ0xpbmUgYnJlYWsgd291bGQgYmUgaW5zZXJ0ZWQnLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dEVuZDogY3VycmVudFRleHQuc2xpY2UoLTUpLFxyXG4gICAgICAgICAgICAgICAgICBuZXh0VGV4dFN0YXJ0OiBuZXh0Q29udGVudC5zbGljZSgwLCA1KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBleHBsaWNpdCBsaW5lIGJyZWFrcyBiZXR3ZWVuIHJhbmdlcyAoZm9yIGNhc2VzIHdoZXJlIHNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrIGlzIHRydWUpXHJcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsocmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltcGxpY2l0QnJlYWsgPSAnXFxuJztcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gaW1wbGljaXRCcmVhaztcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGltcGxpY2l0QnJlYWssXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogJ2ltcGxpY2l0JyxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdiZXR3ZWVuIHJhbmdlcydcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ0ltcGxpY2l0IGxpbmUgYnJlYWsnLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7cmFuZ2VJbmRleCArIDF9YFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgY29udGludWUgcHJvY2Vzc2luZyB0byBhdm9pZCBkdXBsaWNhdGlvblxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBFTkhBTkNFRDogSGFuZGxlIFBhcmFncmFwaFN0eWxlUmFuZ2Ugd2l0aCBjb250ZXh0XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2UpID8gXHJcbiAgICAgICAgICAgIGVsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZSA6IFtlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaENvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgLi4uY29udGV4dCxcclxuICAgICAgICAgICAgICBwYXJhZ3JhcGhJbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgdG90YWxQYXJhZ3JhcGhzOiByYW5nZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgIGFwcGxpZWRTdHlsZTogcmFuZ2VbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkocmFuZ2UsIGRlcHRoICsgMSwgcGFyYWdyYXBoQ29udGV4dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBZGQgcGFyYWdyYXBoIGJyZWFrIGJldHdlZW4gcGFyYWdyYXBocyAoYnV0IG5vdCBhZnRlciB0aGUgbGFzdCBvbmUpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHJhbmdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoQnJlYWsgPSAnXFxuJztcclxuICAgICAgICAgICAgICBjb250ZW50ICs9IHBhcmFncmFwaEJyZWFrO1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhZ3JhcGhCcmVhayxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiAncGFyYWdyYXBoJyxcclxuICAgICAgICAgICAgICAgICAgc291cmNlOiAnYmV0d2VlbiBwYXJhZ3JhcGhzJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHsgXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUGFyYWdyYXBoIGJyZWFrJywgXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogYGJldHdlZW4gcGFyYWdyYXBocyAke2luZGV4fSBhbmQgJHtpbmRleCArIDF9YCBcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEhhbmRsZSBkaXJlY3QgQ29udGVudCBlbGVtZW50cyAod2hlbiBub3QgaW5zaWRlIENoYXJhY3RlclN0eWxlUmFuZ2UpXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuQ29udGVudCAmJiAhZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlKSB7XHJcbiAgICAgICAgICBsZXQgdGV4dCA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5Db250ZW50KSA/IGVsZW1lbnQuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhlbGVtZW50LkNvbnRlbnQpO1xyXG4gICAgICAgICAgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyh0ZXh0KTtcclxuICAgICAgICAgIGNvbnRlbnQgKz0gdGV4dDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgY2hhcmFjdGVyU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udFNpemU6IGVsZW1lbnRbJ0BfUG9pbnRTaXplJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udEZhbWlseTogZWxlbWVudFsnQF9BcHBsaWVkRm9udCddIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogZWxlbWVudFsnQF9GaWxsQ29sb3InXSB8fCBudWxsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IHJlc29sdmVkRm9ybWF0dGluZyA9IHRoaXMuc3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IERpcmVjdCBCciBlbGVtZW50IGhhbmRsaW5nIChvdXRzaWRlIG9mIHJhbmdlcylcclxuICAgICAgICBpZiAoZWxlbWVudC5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zdCBickVsZW1lbnRzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkJyKSA/IGVsZW1lbnQuQnIgOiBbZWxlbWVudC5Ccl07XHJcbiAgICAgICAgICBickVsZW1lbnRzLmZvckVhY2goKGJyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gJ1xcbic7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0LFxyXG4gICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdleHBsaWNpdCcsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICdkaXJlY3QgQnIgZWxlbWVudCdcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0RpcmVjdCBCciBlbGVtZW50JyxcclxuICAgICAgICAgICAgICBsb2NhdGlvbjogYERpcmVjdCBlbGVtZW50LCBpbmRleCAke2luZGV4fWBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciBuZXN0ZWQgZWxlbWVudHNcclxuICAgICAgICBPYmplY3QuZW50cmllcyhlbGVtZW50KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJ0BfJykgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQ29udGVudCcgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQnInICYmIFxyXG4gICAgICAgICAgICAgIGtleSAhPT0gJ0NoYXJhY3RlclN0eWxlUmFuZ2UnICYmXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnUGFyYWdyYXBoU3R5bGVSYW5nZScpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChpdGVtID0+IGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkoaXRlbSwgZGVwdGggKyAxLCBjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBkZXB0aCA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgZXh0cmFjdFRleHRSZWN1cnNpdmVseSh2YWx1ZSwgZGVwdGggKyAxLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5KHN0b3J5RGF0YSk7XHJcbiAgICBcclxuICAgIC8vIEVOSEFOQ0VEOiBQcm9jZXNzIGFuZCBjbGVhbiB1cCB0aGUgY29udGVudCB3aXRoIHNvcGhpc3RpY2F0ZWQgbGluZSBicmVhayBwcmVzZXJ2YXRpb25cclxuICAgIGNvbnN0IHByb2Nlc3NlZENvbnRlbnQgPSBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmcoY29udGVudCk7XHJcbiAgICBcclxuICAgIC8vIERFQlVHOiBMb2cgc3BhY2UgcHJlc2VydmF0aW9uIHJlc3VsdHNcclxuICAgIGNvbnNvbGUubG9nKCfwn5OdIFRleHQgZXh0cmFjdGlvbiByZXN1bHRzOicpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gT3JpZ2luYWwgY29udGVudCBsZW5ndGg6JywgY29udGVudC5sZW5ndGgpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gUHJvY2Vzc2VkIGNvbnRlbnQgbGVuZ3RoOicsIHByb2Nlc3NlZENvbnRlbnQubGVuZ3RoKTtcclxuICAgIGNvbnNvbGUubG9nKCcgICAtIFNwYWNlIHByZXNlcnZhdGlvbiBldmVudHM6JywgZGVidWdJbmZvLmZpbHRlcihpbmZvID0+IGluZm8udHlwZS5pbmNsdWRlcygnU3BhY2UgaW5zZXJ0ZWQnKSkubGVuZ3RoKTtcclxuICAgIFxyXG4gICAgLy8gU1BFQ0lGSUMgREVCVUc6IENoZWNrIGZvciB0aGUgcHJvYmxlbWF0aWMgXCJwYXZvbHVwdHVzZGFcIiB0ZXh0IChzaW1wbGlmaWVkKVxyXG4gICAgaWYgKHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3Bhdm9sdXB0dXNkYScpIHx8IHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3BhJykgJiYgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygndm9sdXB0dXNkYScpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qoIEZPVU5EIFBST0JMRU1BVElDIFRFWFQ6Jyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIENvbnRhaW5zIFwicGF2b2x1cHR1c2RhXCI6JywgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBDb250YWlucyBcInBhIHZvbHVwdHVzZGFcIjonLCBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCdwYSB2b2x1cHR1c2RhJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBGb3JtYXR0ZWRDb250ZW50IGJyZWFrZG93bjonLCBmb3JtYXR0ZWRDb250ZW50Lm1hcChpdGVtID0+IGl0ZW0udGV4dCkuam9pbignfCcpKTtcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIFxyXG4gICAgY29uc3QgbGluZUJyZWFrSW5mbyA9IHtcclxuICAgICAgaGFzTGluZUJyZWFrczogcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygnXFxuJyksXHJcbiAgICAgIGxpbmVCcmVha0NvdW50OiAocHJvY2Vzc2VkQ29udGVudC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGgsXHJcbiAgICAgIGxpbmVCcmVha1R5cGVzOiB0aGlzLmFuYWx5emVMaW5lQnJlYWtUeXBlcyhmb3JtYXR0ZWRDb250ZW50KSxcclxuICAgICAgZGVidWdJbmZvOiBkZWJ1Z0luZm8sXHJcbiAgICAgIHNwYWNlUHJlc2VydmF0aW9uQ291bnQ6IGRlYnVnSW5mby5maWx0ZXIoaW5mbyA9PiBpbmZvLnR5cGUuaW5jbHVkZXMoJ1NwYWNlIGluc2VydGVkJykpLmxlbmd0aFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGxhaW5UZXh0OiBwcm9jZXNzZWRDb250ZW50LFxyXG4gICAgICBmb3JtYXR0ZWRDb250ZW50OiBmb3JtYXR0ZWRDb250ZW50LmZpbHRlcihpdGVtID0+IGl0ZW0udGV4dCAmJiBpdGVtLnRleHQubGVuZ3RoID4gMCksXHJcbiAgICAgIHdvcmRDb3VudDogSURNTFV0aWxzLmNvdW50V29yZHMocHJvY2Vzc2VkQ29udGVudC5yZXBsYWNlKC9cXG4vZywgJyAnKSksXHJcbiAgICAgIGNoYXJhY3RlckNvdW50OiBwcm9jZXNzZWRDb250ZW50Lmxlbmd0aCxcclxuICAgICAgdGV4dENvbG9yOiB0ZXh0Q29sb3IsXHJcbiAgICAgIGxpbmVCcmVha0luZm86IGxpbmVCcmVha0luZm9cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgdGhpcyBoZWxwZXIgbWV0aG9kIHRvIGJldHRlciBoYW5kbGUgbWl4ZWQgY29udGVudCBhbmQgQnIgZWxlbWVudHNcclxuICBhbmFseXplQ29udGVudFN0cnVjdHVyZShyYW5nZSkge1xyXG4gICAgY29uc3Qgc3RydWN0dXJlID0ge1xyXG4gICAgICBoYXNDb250ZW50OiAhIXJhbmdlLkNvbnRlbnQsXHJcbiAgICAgIGhhc0JyOiByYW5nZS5CciAhPT0gdW5kZWZpbmVkLFxyXG4gICAgICBjb250ZW50SXRlbXM6IHJhbmdlLkNvbnRlbnQgPyAoQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA/IHJhbmdlLkNvbnRlbnQgOiBbcmFuZ2UuQ29udGVudF0pIDogW10sXHJcbiAgICAgIGJyRWxlbWVudHM6IHJhbmdlLkJyID8gKEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpID8gcmFuZ2UuQnIgOiBbcmFuZ2UuQnJdKSA6IFtdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQ29udGVudCBzdHJ1Y3R1cmUgYW5hbHlzaXM6Jywgc3RydWN0dXJlKTtcclxuICAgIHJldHVybiBzdHJ1Y3R1cmU7XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBoZWxwZXIgZm9yIHByb2Nlc3NpbmcgaW50ZXJsZWF2ZWQgY29udGVudCBhbmQgYnJlYWtzXHJcbiAgcHJvY2Vzc0ludGVybGVhdmVkQ29udGVudChyYW5nZSwgcmVzb2x2ZWRGb3JtYXR0aW5nKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgXHJcbiAgICAvLyBUaGlzIG1ldGhvZCB3b3VsZCBuZWVkIGFjY2VzcyB0byB0aGUgYWN0dWFsIFhNTCBzdHJ1Y3R1cmUgdG8gZGV0ZXJtaW5lXHJcbiAgICAvLyB0aGUgZXhhY3Qgb3JkZXIgb2YgQ29udGVudCBhbmQgQnIgZWxlbWVudHMuIEZvciBub3csIHdlJ2xsIHVzZSB0aGUgXHJcbiAgICAvLyBhcHByb2FjaCBhYm92ZSB3aGljaCBoYW5kbGVzIHRoZSBtb3N0IGNvbW1vbiBjYXNlLlxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEhlbHBlciBtZXRob2QgdG8gZXh0cmFjdCBCciBlbGVtZW50cyB3aXRoIGNvbnRleHRcclxuICBleHRyYWN0QnJFbGVtZW50cyhyYW5nZSkge1xyXG4gICAgY29uc3QgYnJFbGVtZW50cyA9IFtdO1xyXG4gICAgXHJcbiAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyYW5nZS5CcikpIHtcclxuICAgICAgICByYW5nZS5Cci5mb3JFYWNoKChiciwgaW5kZXgpID0+IHtcclxuICAgICAgICAgIGJyRWxlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgcG9zaXRpb246IGluZGV4ID09PSAwID8gJ3N0YXJ0JyA6ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICBlbGVtZW50OiBiclxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJFbGVtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJyxcclxuICAgICAgICAgIGVsZW1lbnQ6IHJhbmdlLkJyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGJyRWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGxpbmUgYnJlYWsgdHlwZVxyXG4gIGRldGVybWluZUxpbmVCcmVha1R5cGUoYnJJbmZvLCBjb250ZXh0KSB7XHJcbiAgICAvLyBEaWZmZXJlbnQgbGluZSBicmVhayBjaGFyYWN0ZXJzIGJhc2VkIG9uIGNvbnRleHRcclxuICAgIHN3aXRjaCAoYnJJbmZvLnR5cGUpIHtcclxuICAgICAgY2FzZSAncGFyYWdyYXBoJzpcclxuICAgICAgICByZXR1cm4gJ1xcblxcbic7IC8vIERvdWJsZSBsaW5lIGJyZWFrIGZvciBwYXJhZ3JhcGggc2VwYXJhdGlvblxyXG4gICAgICBjYXNlICdmb3JjZWQnOlxyXG4gICAgICAgIHJldHVybiAnXFxuJzsgLy8gRm9yY2VkIGxpbmUgYnJlYWsgKFNoaWZ0K0VudGVyIGVxdWl2YWxlbnQpXHJcbiAgICAgIGNhc2UgJ2xpbmUnOlxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAnXFxuJzsgLy8gU3RhbmRhcmQgbGluZSBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogRGV0ZXJtaW5lIGlmIGFuIGltcGxpY2l0IGxpbmUgYnJlYWsgc2hvdWxkIGJlIGluc2VydGVkXHJcbiAgc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsoY3VycmVudFJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpIHtcclxuICAgIC8vIERvbid0IGluc2VydCBpbXBsaWNpdCBicmVha3MgaWYgZXhwbGljaXQgQnIgZWxlbWVudHMgYXJlIHByZXNlbnRcclxuICAgIGlmIChjdXJyZW50UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCB8fCBuZXh0UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEluc2VydCBicmVha3MgYmV0d2VlbiBkaWZmZXJlbnQgY2hhcmFjdGVyIHN0eWxlcyBpbiBkaWZmZXJlbnQgcGFyYWdyYXBoc1xyXG4gICAgY29uc3QgY3VycmVudENoYXJTdHlsZSA9IGN1cnJlbnRSYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXTtcclxuICAgIGNvbnN0IG5leHRDaGFyU3R5bGUgPSBuZXh0UmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ107XHJcbiAgICBcclxuICAgIC8vIElmIHdlJ3JlIGluIGEgY29udGV4dCB3aGVyZSBzdHlsZXMgY2hhbmdlIHNpZ25pZmljYW50bHksIGFkZCBhIGJyZWFrXHJcbiAgICBpZiAoY3VycmVudENoYXJTdHlsZSAmJiBuZXh0Q2hhclN0eWxlICYmIGN1cnJlbnRDaGFyU3R5bGUgIT09IG5leHRDaGFyU3R5bGUpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBtaWdodCBiZSBhIHRpdGxlL2hlYWRpbmcgZm9sbG93ZWQgYnkgYm9keSB0ZXh0XHJcbiAgICAgIGNvbnN0IHN0eWxlSW5kaWNhdGVzQnJlYWsgPSB0aGlzLnN0eWxlSW5kaWNhdGVzTGluZUJyZWFrKGN1cnJlbnRDaGFyU3R5bGUsIG5leHRDaGFyU3R5bGUpO1xyXG4gICAgICByZXR1cm4gc3R5bGVJbmRpY2F0ZXNCcmVhaztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogQW5hbHl6ZSBpZiBzdHlsZSBjaGFuZ2UgaW5kaWNhdGVzIGEgbGluZSBicmVha1xyXG4gIHN0eWxlSW5kaWNhdGVzTGluZUJyZWFrKGN1cnJlbnRTdHlsZSwgbmV4dFN0eWxlKSB7XHJcbiAgICBjb25zdCB0aXRsZUluZGljYXRvcnMgPSBbJ3RpdGxlJywgJ2hlYWRpbmcnLCAnaGVhZGVyJ107XHJcbiAgICBjb25zdCBib2R5SW5kaWNhdG9ycyA9IFsnYm9keScsICd0ZXh0JywgJ25vcm1hbCddO1xyXG4gICAgXHJcbiAgICBjb25zdCBjdXJyZW50SXNUaXRsZSA9IHRpdGxlSW5kaWNhdG9ycy5zb21lKGluZGljYXRvciA9PiBcclxuICAgICAgY3VycmVudFN0eWxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5kaWNhdG9yKSk7XHJcbiAgICBjb25zdCBuZXh0SXNCb2R5ID0gYm9keUluZGljYXRvcnMuc29tZShpbmRpY2F0b3IgPT4gXHJcbiAgICAgIG5leHRTdHlsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGluZGljYXRvcikpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gY3VycmVudElzVGl0bGUgJiYgbmV4dElzQm9keTtcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEFuYWx5emUgbGluZSBicmVhayB0eXBlcyBpbiBmb3JtYXR0ZWQgY29udGVudFxyXG4gIGFuYWx5emVMaW5lQnJlYWtUeXBlcyhmb3JtYXR0ZWRDb250ZW50KSB7XHJcbiAgICBjb25zdCB0eXBlcyA9IHtcclxuICAgICAgZXhwbGljaXQ6IDAsICAgICAgLy8gRnJvbSA8QnIvPiBlbGVtZW50c1xyXG4gICAgICBpbXBsaWNpdDogMCwgICAgICAvLyBJbmZlcnJlZCBmcm9tIHN0eWxlIGNoYW5nZXNcclxuICAgICAgcGFyYWdyYXBoOiAwLCAgICAgLy8gQmV0d2VlbiBwYXJhZ3JhcGhzXHJcbiAgICAgIGRpcmVjdDogMCAgICAgICAgLy8gRGlyZWN0IEJyIGVsZW1lbnRzXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmb3JtYXR0ZWRDb250ZW50LmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGlmIChpdGVtLmZvcm1hdHRpbmc/LmlzQnJlYWspIHtcclxuICAgICAgICBjb25zdCBicmVha1R5cGUgPSBpdGVtLmZvcm1hdHRpbmcuYnJlYWtUeXBlIHx8ICd1bmtub3duJztcclxuICAgICAgICBpZiAodHlwZXMuaGFzT3duUHJvcGVydHkoYnJlYWtUeXBlKSkge1xyXG4gICAgICAgICAgdHlwZXNbYnJlYWtUeXBlXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB0eXBlcztcclxuICB9XHJcblxyXG4gIGV4dHJhY3REZXRhaWxlZEZvcm1hdHRpbmdGcm9tUmFuZ2UocmFuZ2UpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7fTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBhbGwgcG9zc2libGUgZm9udCBhdHRyaWJ1dGVzXHJcbiAgICBjb25zdCBmb250QXR0cmlidXRlcyA9IFtcclxuICAgICAgJ0BfQXBwbGllZEZvbnQnLCAnQF9Gb250RmFtaWx5JywgJ0BfRm9udCcsIFxyXG4gICAgICAnQF9Qb3N0U2NyaXB0TmFtZScsICdAX0ZvbnROYW1lJ1xyXG4gICAgXTtcclxuICAgIFxyXG4gICAgZm9udEF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHtcclxuICAgICAgaWYgKHJhbmdlW2F0dHJdKSB7XHJcbiAgICAgICAgZm9ybWF0dGluZy5mb250UmVmZXJlbmNlID0gcmFuZ2VbYXR0cl07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGZvbnQgYW5kIHNpemUgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy5mb250U2l6ZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfUG9pbnRTaXplJ10pO1xyXG4gICAgXHJcbiAgICAvLyBFTkhBTkNFRDogRXh0cmFjdCBsZWFkaW5nIHdpdGggcHJvcGVyIHByb2Nlc3NpbmdcclxuICAgIGNvbnN0IHJhd0xlYWRpbmcgPSByYW5nZVsnQF9MZWFkaW5nJ107XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmcgPSB0aGlzLnByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9ybWF0dGluZy5mb250U2l6ZSk7XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmdUeXBlID0gdGhpcy5kZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBjb2xvciBhbmQgc3R5bGUgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy5maWxsQ29sb3IgPSByYW5nZVsnQF9GaWxsQ29sb3InXTtcclxuICAgIGZvcm1hdHRpbmcuc3Ryb2tlQ29sb3IgPSByYW5nZVsnQF9TdHJva2VDb2xvciddO1xyXG4gICAgZm9ybWF0dGluZy5mb250U3R5bGUgPSByYW5nZVsnQF9Gb250U3R5bGUnXTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBhZHZhbmNlZCB0eXBvZ3JhcGh5IGF0dHJpYnV0ZXNcclxuICAgIGZvcm1hdHRpbmcudHJhY2tpbmcgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1RyYWNraW5nJ10pO1xyXG4gICAgZm9ybWF0dGluZy5iYXNlbGluZVNoaWZ0ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9CYXNlbGluZVNoaWZ0J10pO1xyXG4gICAgZm9ybWF0dGluZy5rZXJuaW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9LZXJuaW5nJ10pO1xyXG4gICAgZm9ybWF0dGluZy5ob3Jpem9udGFsU2NhbGUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0hvcml6b250YWxTY2FsZSddKSB8fCAxMDA7XHJcbiAgICBmb3JtYXR0aW5nLnZlcnRpY2FsU2NhbGUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1ZlcnRpY2FsU2NhbGUnXSkgfHwgMTAwO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IHBhcmFncmFwaC1sZXZlbCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcclxuICAgIC8vIENSSVRJQ0FMIEZJWDogT25seSBzZXQgYWxpZ25tZW50IGlmIGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBhbGxvd2luZyBwYXJhZ3JhcGggaW5oZXJpdGFuY2VcclxuICAgIGNvbnN0IGV4cGxpY2l0QWxpZ25tZW50ID0gcmFuZ2VbJ0BfSnVzdGlmaWNhdGlvbiddIHx8IHJhbmdlWydAX0FsaWdubWVudCddO1xyXG4gICAgaWYgKGV4cGxpY2l0QWxpZ25tZW50KSB7XHJcbiAgICAgIGZvcm1hdHRpbmcuYWxpZ25tZW50ID0gZXhwbGljaXRBbGlnbm1lbnQ7XHJcbiAgICB9XHJcbiAgICBmb3JtYXR0aW5nLmxlZnRJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0xlZnRJbmRlbnQnXSk7XHJcbiAgICBmb3JtYXR0aW5nLnJpZ2h0SW5kZW50ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9SaWdodEluZGVudCddKTtcclxuICAgIGZvcm1hdHRpbmcuZmlyc3RMaW5lSW5kZW50ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9GaXJzdExpbmVJbmRlbnQnXSk7XHJcbiAgICBmb3JtYXR0aW5nLnNwYWNlQmVmb3JlID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9TcGFjZUJlZm9yZSddKTtcclxuICAgIGZvcm1hdHRpbmcuc3BhY2VBZnRlciA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfU3BhY2VBZnRlciddKTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBmb3IgQ1NTXHJcbiAgICBmb3JtYXR0aW5nLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoZm9ybWF0dGluZyk7XHJcbiAgICBcclxuICAgIHJldHVybiBmb3JtYXR0aW5nO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBQcm9jZXNzIGxlYWRpbmcgdmFsdWVzIHdpdGggSW5EZXNpZ24tc3BlY2lmaWMgbG9naWNcclxuICBwcm9jZXNzTGVhZGluZ1ZhbHVlKHJhd0xlYWRpbmcsIGZvbnRTaXplKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcpIHJldHVybiAnYXV0byc7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBcImF1dG9cIiBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZyA9PT0gJ2F1dG8nIHx8IHJhd0xlYWRpbmcgPT09ICdBdXRvJykge1xyXG4gICAgICByZXR1cm4gZm9udFNpemUgPyBmb250U2l6ZSAqIDEuMiA6ICdhdXRvJzsgLy8gSW5EZXNpZ24gZGVmYXVsdCBhdXRvIGxlYWRpbmcgaXMgMTIwJVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgbnVtZXJpYyBsZWFkaW5nIChpbiBwb2ludHMpXHJcbiAgICBjb25zdCBudW1lcmljTGVhZGluZyA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmF3TGVhZGluZyk7XHJcbiAgICBpZiAobnVtZXJpY0xlYWRpbmcpIHtcclxuICAgICAgcmV0dXJuIG51bWVyaWNMZWFkaW5nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgcGVyY2VudGFnZS1iYXNlZCBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcygnJScpKSB7XHJcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KHJhd0xlYWRpbmcucmVwbGFjZSgnJScsICcnKSk7XHJcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IChmb250U2l6ZSAqIHBlcmNlbnRhZ2UgLyAxMDApIDogJ2F1dG8nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gJ2F1dG8nO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgbGVhZGluZyBiZWluZyB1c2VkXHJcbiAgZGV0ZXJtaW5lTGVhZGluZ1R5cGUocmF3TGVhZGluZykge1xyXG4gICAgaWYgKCFyYXdMZWFkaW5nIHx8IHJhd0xlYWRpbmcgPT09ICdhdXRvJyB8fCByYXdMZWFkaW5nID09PSAnQXV0bycpIHtcclxuICAgICAgcmV0dXJuICdhdXRvJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoJyUnKSkge1xyXG4gICAgICByZXR1cm4gJ3BlcmNlbnRhZ2UnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYXdMZWFkaW5nKSkge1xyXG4gICAgICByZXR1cm4gJ2Fic29sdXRlJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcblxyXG4gIC8vIE5FVzogQ2FsY3VsYXRlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBmb3IgQ1NTIHJlbmRlcmluZ1xyXG4gIGNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoZm9ybWF0dGluZykge1xyXG4gICAgY29uc3QgZm9udFNpemUgPSBmb3JtYXR0aW5nLmZvbnRTaXplIHx8IDEyO1xyXG4gICAgY29uc3QgbGVhZGluZyA9IGZvcm1hdHRpbmcubGVhZGluZztcclxuICAgIFxyXG4gICAgaWYgKGxlYWRpbmcgPT09ICdhdXRvJykge1xyXG4gICAgICByZXR1cm4gMS4yOyAvLyBDU1MgbGluZS1oZWlnaHQgcmF0aW8gZm9yIGF1dG9cclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHR5cGVvZiBsZWFkaW5nID09PSAnbnVtYmVyJykge1xyXG4gICAgICAvLyBDb252ZXJ0IHBvaW50cyB0byBDU1MgbGluZS1oZWlnaHQgcmF0aW9cclxuICAgICAgcmV0dXJuIGxlYWRpbmcgLyBmb250U2l6ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIDEuMjsgLy8gRmFsbGJhY2tcclxuICB9XHJcblxyXG4gIGV4dHJhY3RUZXh0Rm9ybWF0dGluZyhzdG9yeURhdGEpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7XHJcbiAgICAgIHBhcmFncmFwaFN0eWxlczogW10sXHJcbiAgICAgIGNoYXJhY3RlclN0eWxlczogW10sXHJcbiAgICAgIGFwcGxpZWRTdHlsZXM6IFtdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGFwcGxpZWQgcGFyYWdyYXBoIHN0eWxlc1xyXG4gICAgaWYgKHN0b3J5RGF0YS5QYXJhZ3JhcGhTdHlsZVJhbmdlKSB7XHJcbiAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkoc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2UpID8gc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2UgOiBbc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2VdO1xyXG4gICAgICBcclxuICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFwcGxpZWRTdHlsZSA9IHJhbmdlWydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddO1xyXG4gICAgICAgIGlmIChhcHBsaWVkU3R5bGUgJiYgIWZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVzLmluY2x1ZGVzKGFwcGxpZWRTdHlsZSkpIHtcclxuICAgICAgICAgIGZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVzLnB1c2goYXBwbGllZFN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXh0cmFjdCBjaGFyYWN0ZXIgc3R5bGVzIHdpdGhpbiBwYXJhZ3JhcGggcmFuZ2VzXHJcbiAgICAgICAgaWYgKHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNvbnN0IGNoYXJSYW5nZXMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2UpID8gcmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZSA6IFtyYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlXTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY2hhclJhbmdlcy5mb3JFYWNoKGNoYXJSYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJTdHlsZSA9IGNoYXJSYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXTtcclxuICAgICAgICAgICAgaWYgKGNoYXJTdHlsZSAmJiAhZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZXMuaW5jbHVkZXMoY2hhclN0eWxlKSkge1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVzLnB1c2goY2hhclN0eWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmc7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgdGhpcyBtZXRob2QgdG8gZGVidWcgcmF3IHN0b3J5IGNvbnRlbnRcclxuICBkZWJ1Z1Jhd1N0b3J5Q29udGVudChzdG9yeURhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKCdcXG7wn5SNIFJBVyBTVE9SWSBDT05URU5UIERFQlVHOicpO1xyXG4gICAgY29uc29sZS5sb2coJ1N0b3J5IGtleXM6JywgT2JqZWN0LmtleXMoc3RvcnlEYXRhKSk7XHJcbiAgICBcclxuICAgIGNvbnN0IGZpbmRDaGFyYWN0ZXJSYW5nZXMgPSAob2JqLCBwYXRoID0gJycpID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgaWYgKGtleSA9PT0gJ0NoYXJhY3RlclN0eWxlUmFuZ2UnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBcXG7wn5OdIEZvdW5kIENoYXJhY3RlclN0eWxlUmFuZ2UgYXQgJHtwYXRofTpgLCBvYmpba2V5XSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkob2JqW2tleV0pID8gb2JqW2tleV0gOiBbb2JqW2tleV1dO1xyXG4gICAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgUmFuZ2UgJHtpbmRleCArIDF9IGF0dHJpYnV0ZXM6YCwgXHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyYW5nZSkuZmlsdGVyKGsgPT4gay5zdGFydHNXaXRoKCdAXycpKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgUmFuZ2UgJHtpbmRleCArIDF9IGZvbnQgaW5mbzpgLCB7XHJcbiAgICAgICAgICAgICAgICBBcHBsaWVkRm9udDogcmFuZ2VbJ0BfQXBwbGllZEZvbnQnXSxcclxuICAgICAgICAgICAgICAgIEZvbnRTdHlsZTogcmFuZ2VbJ0BfRm9udFN0eWxlJ10sXHJcbiAgICAgICAgICAgICAgICBQb2ludFNpemU6IHJhbmdlWydAX1BvaW50U2l6ZSddXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGZpbmRDaGFyYWN0ZXJSYW5nZXMob2JqW2tleV0sIGAke3BhdGh9LiR7a2V5fWApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmaW5kQ2hhcmFjdGVyUmFuZ2VzKHN0b3J5RGF0YSk7XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yaWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmllcztcclxuICB9XHJcblxyXG4gIGdldFN0b3J5KHN0b3J5SWQpIHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JpZXNbc3RvcnlJZF07XHJcbiAgfVxyXG5cclxuICBjbGVhclN0b3JpZXMoKSB7XHJcbiAgICB0aGlzLnN0b3JpZXMgPSB7fTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RvcnlQYXJzZXI7ICJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIklETUxVdGlscyIsIlN0b3J5UGFyc2VyIiwicGFyc2VTdG9yeUZpbGUiLCJmaWxlTmFtZSIsImNvbnRlbnQiLCJ4bWxQYXJzZXIiLCJjb25zb2xlIiwibG9nIiwicGFyc2VkIiwicGFyc2UiLCJzdG9yeUlkIiwiYmFzZW5hbWUiLCJzdG9yeURhdGEiLCJTdG9yeSIsIk9iamVjdCIsImtleXMiLCJKU09OIiwic3RyaW5naWZ5Iiwic3Vic3RyaW5nIiwiZGV0YWlsZWRTdG9yeSIsInNlbGYiLCJhcHBsaWVkVE9DU3R5bGUiLCJ1c2VyVGV4dCIsImV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudCIsInRleHRGb3JtYXR0aW5nIiwiZXh0cmFjdFRleHRGb3JtYXR0aW5nIiwiY2xlYW5TdG9yeUlkIiwicmVwbGFjZSIsInN0b3JpZXMiLCJwbGFpblRleHQiLCJsaW5lQnJlYWtJbmZvIiwibGVuZ3RoIiwid29yZENvdW50IiwibGluZUJyZWFrQ291bnQiLCJlcnJvciIsIm1lc3NhZ2UiLCJmb3JtYXR0ZWRDb250ZW50IiwidGV4dENvbG9yIiwiZGVidWdJbmZvIiwiZXh0cmFjdFRleHRSZWN1cnNpdmVseSIsImVsZW1lbnQiLCJkZXB0aCIsImNvbnRleHQiLCJDaGFyYWN0ZXJTdHlsZVJhbmdlIiwicmFuZ2VzIiwiQXJyYXkiLCJpc0FycmF5IiwiYWxsUmFuZ2VDb250ZW50IiwibWFwIiwiciIsIkNvbnRlbnQiLCJqb2luIiwiU3RyaW5nIiwiaW5jbHVkZXMiLCJmb3JFYWNoIiwicmFuZ2UiLCJpbmRleCIsInJhbmdlSW5kZXgiLCJkaXJlY3RGb250UmVmIiwiZm9ybWF0dGluZyIsInBhcmFncmFwaFN0eWxlIiwiYXBwbGllZFN0eWxlIiwiY2hhcmFjdGVyU3R5bGUiLCJmb250U2l6ZSIsInBhcnNlRmxvYXQiLCJmb250UmVmZXJlbmNlIiwiZmlsbENvbG9yIiwiZm9udFN0eWxlIiwicmFuZ2VDb250ZW50IiwiaGFzU3R5bGVJbmZvIiwidHJpbSIsInJhd1JhbmdlQXR0cmlidXRlcyIsImZpbHRlciIsImsiLCJzdGFydHNXaXRoIiwiZXh0cmFjdGVkRm9ybWF0dGluZyIsImZvbnRTdHlsZUZyb21YTUwiLCJjaGFyYWN0ZXJTdHlsZUZyb21YTUwiLCJwYXJhZ3JhcGhTdHlsZUZyb21YTUwiLCJyZXNvbHZlZEZvcm1hdHRpbmciLCJzdHlsZVBhcnNlciIsInJlc29sdmVTdHlsZUZvcm1hdHRpbmciLCJjb250ZW50cyIsImNvbnRlbnRJdGVtIiwiY29udGVudEluZGV4IiwidGV4dCIsImRlY29kZVhNTEVudGl0aWVzIiwicHVzaCIsIkJyIiwidW5kZWZpbmVkIiwibGluZUJyZWFrVGV4dCIsImlzQnJlYWsiLCJicmVha1R5cGUiLCJwb3NpdGlvbiIsInNvdXJjZSIsInR5cGUiLCJsb2NhdGlvbiIsImJyRWxlbWVudHMiLCJleHRyYWN0QnJFbGVtZW50cyIsImJySW5mbyIsImJySW5kZXgiLCJkZXRlcm1pbmVMaW5lQnJlYWtUeXBlIiwibmV4dFJhbmdlIiwiY3VycmVudFRleHQiLCJzbGljZSIsImN1cnJlbnRSYW5nZUVuZHNXaXRoU3BhY2UiLCJ0ZXN0IiwibmV4dENvbnRlbnQiLCJuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2UiLCJzaG91bGRTa2lwU3BhY2UiLCJzaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayIsImN1cnJlbnRTdHlsZSIsIm5leHRTdHlsZSIsInNwYWNlVGV4dCIsImlzU3BhY2UiLCJyZWFzb24iLCJjdXJyZW50VGV4dEVuZCIsIm5leHRUZXh0U3RhcnQiLCJpbXBsaWNpdEJyZWFrIiwiUGFyYWdyYXBoU3R5bGVSYW5nZSIsInBhcmFncmFwaENvbnRleHQiLCJwYXJhZ3JhcGhJbmRleCIsInRvdGFsUGFyYWdyYXBocyIsInBhcmFncmFwaEJyZWFrIiwiZm9udEZhbWlseSIsImJyIiwiZW50cmllcyIsImtleSIsInZhbHVlIiwiaXRlbSIsInByb2Nlc3NlZENvbnRlbnQiLCJzb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyIsImluZm8iLCJoYXNMaW5lQnJlYWtzIiwibWF0Y2giLCJsaW5lQnJlYWtUeXBlcyIsImFuYWx5emVMaW5lQnJlYWtUeXBlcyIsInNwYWNlUHJlc2VydmF0aW9uQ291bnQiLCJjb3VudFdvcmRzIiwiY2hhcmFjdGVyQ291bnQiLCJhbmFseXplQ29udGVudFN0cnVjdHVyZSIsInN0cnVjdHVyZSIsImhhc0NvbnRlbnQiLCJoYXNCciIsImNvbnRlbnRJdGVtcyIsInByb2Nlc3NJbnRlcmxlYXZlZENvbnRlbnQiLCJyZXN1bHRzIiwiY3VycmVudFJhbmdlIiwiY3VycmVudENoYXJTdHlsZSIsIm5leHRDaGFyU3R5bGUiLCJzdHlsZUluZGljYXRlc0JyZWFrIiwic3R5bGVJbmRpY2F0ZXNMaW5lQnJlYWsiLCJ0aXRsZUluZGljYXRvcnMiLCJib2R5SW5kaWNhdG9ycyIsImN1cnJlbnRJc1RpdGxlIiwic29tZSIsImluZGljYXRvciIsInRvTG93ZXJDYXNlIiwibmV4dElzQm9keSIsInR5cGVzIiwiZXhwbGljaXQiLCJpbXBsaWNpdCIsInBhcmFncmFwaCIsImRpcmVjdCIsImhhc093blByb3BlcnR5IiwiZXh0cmFjdERldGFpbGVkRm9ybWF0dGluZ0Zyb21SYW5nZSIsImZvbnRBdHRyaWJ1dGVzIiwiYXR0ciIsInBhcnNlTnVtZXJpYyIsInJhd0xlYWRpbmciLCJsZWFkaW5nIiwicHJvY2Vzc0xlYWRpbmdWYWx1ZSIsImxlYWRpbmdUeXBlIiwiZGV0ZXJtaW5lTGVhZGluZ1R5cGUiLCJzdHJva2VDb2xvciIsInRyYWNraW5nIiwiYmFzZWxpbmVTaGlmdCIsImtlcm5pbmciLCJob3Jpem9udGFsU2NhbGUiLCJ2ZXJ0aWNhbFNjYWxlIiwiZXhwbGljaXRBbGlnbm1lbnQiLCJhbGlnbm1lbnQiLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJmaXJzdExpbmVJbmRlbnQiLCJzcGFjZUJlZm9yZSIsInNwYWNlQWZ0ZXIiLCJlZmZlY3RpdmVMaW5lSGVpZ2h0IiwiY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodCIsIm51bWVyaWNMZWFkaW5nIiwicGVyY2VudGFnZSIsInBhcmFncmFwaFN0eWxlcyIsImNoYXJhY3RlclN0eWxlcyIsImFwcGxpZWRTdHlsZXMiLCJjaGFyUmFuZ2VzIiwiY2hhclJhbmdlIiwiY2hhclN0eWxlIiwiZGVidWdSYXdTdG9yeUNvbnRlbnQiLCJmaW5kQ2hhcmFjdGVyUmFuZ2VzIiwib2JqIiwiQXBwbGllZEZvbnQiLCJGb250U3R5bGUiLCJQb2ludFNpemUiLCJnZXRTdG9yaWVzIiwiZ2V0U3RvcnkiLCJjbGVhclN0b3JpZXMiLCJjb25zdHJ1Y3RvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/parsers/StoryParser.js\n"));

/***/ })

});