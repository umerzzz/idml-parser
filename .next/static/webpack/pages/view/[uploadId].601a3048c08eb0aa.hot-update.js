"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/parsers/StoryParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StoryParser.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst path = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StoryParser {\n    async parseStoryFile(fileName, content, xmlParser) {\n        console.log(\"\\uD83D\\uDCDD Parsing story: \".concat(fileName));\n        try {\n            const parsed = xmlParser.parse(content);\n            const storyId = path.basename(fileName, \".xml\");\n            const storyData = parsed.Story || parsed;\n            // ADD THESE SIMPLE LOGS FIRST:\n            console.log(\"=== SIMPLE DEBUG TEST ===\");\n            console.log(\"Story file name:\", fileName);\n            console.log(\"Parsed story keys:\", Object.keys(storyData));\n            console.log(\"Raw story data sample:\", JSON.stringify(storyData, null, 2).substring(0, 500));\n            // Extract detailed story information\n            const detailedStory = {\n                self: storyData[\"@_Self\"],\n                appliedTOCStyle: storyData[\"@_AppliedTOCStyle\"] || \"n\",\n                userText: storyData[\"@_UserText\"] !== false,\n                // Extract story content with formatting\n                content: this.extractDetailedStoryContent(storyData),\n                // Extract text formatting\n                textFormatting: this.extractTextFormatting(storyData)\n            };\n            const cleanStoryId = storyId.replace(\"Story_\", \"\");\n            this.stories[cleanStoryId] = detailedStory;\n            // Enhanced logging to show line breaks\n            const { plainText, lineBreakInfo } = detailedStory.content;\n            console.log(\"✅ Story \".concat(storyId, \" parsed:\"));\n            console.log(\"   - Characters: \".concat(plainText.length));\n            console.log(\"   - Words: \".concat(detailedStory.content.wordCount));\n            console.log(\"   - Line breaks: \".concat((lineBreakInfo === null || lineBreakInfo === void 0 ? void 0 : lineBreakInfo.lineBreakCount) || 0));\n            console.log('   - Text preview: \"'.concat(plainText.substring(0, 50).replace(/\\n/g, \"\\\\n\"), '...\"'));\n        } catch (error) {\n            console.error(\"❌ Error parsing story \".concat(fileName, \":\"), error.message);\n        }\n    }\n    // Replace the existing extractDetailedStoryContent method with this corrected version\n    extractDetailedStoryContent(storyData) {\n        var _this = this;\n        let content = \"\";\n        let formattedContent = [];\n        let textColor = null;\n        let debugInfo = [];\n        const extractTextRecursively = function(element) {\n            let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (typeof element === \"string\") {\n                content += element;\n                return;\n            }\n            if (element && typeof element === \"object\") {\n                // ENHANCED: Special handling for CharacterStyleRange with sophisticated Br detection\n                if (element.CharacterStyleRange) {\n                    const ranges = Array.isArray(element.CharacterStyleRange) ? element.CharacterStyleRange : [\n                        element.CharacterStyleRange\n                    ];\n                    // SIMPLIFIED DEBUG: Just log problematic text ranges\n                    const allRangeContent = ranges.map((r)=>r.Content ? Array.isArray(r.Content) ? r.Content.join(\"\") : String(r.Content) : \"\").join(\"\");\n                    if (allRangeContent.includes(\"pavoluptusda\") || allRangeContent.includes(\"pa\") || allRangeContent.includes(\"voluptusda\")) {\n                        console.log(\"\\uD83D\\uDEA8 FOUND RANGES WITH PROBLEMATIC TEXT:\");\n                        ranges.forEach((range, index)=>{\n                            const content = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                            console.log(\"   Range \".concat(index, ': \"').concat(content, '\"'));\n                        });\n                    }\n                    ranges.forEach((range, rangeIndex)=>{\n                        // Extract direct font references from the XML range\n                        const directFontRef = range[\"@_AppliedFont\"] || range[\"@_FontFamily\"] || range[\"@_Font\"] || \"\";\n                        const formatting = {\n                            paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                            characterStyle: range[\"@_AppliedCharacterStyle\"] || null,\n                            fontSize: range[\"@_PointSize\"] ? parseFloat(range[\"@_PointSize\"]) : null,\n                            fontReference: directFontRef,\n                            fillColor: range[\"@_FillColor\"] || null,\n                            fontStyle: range[\"@_FontStyle\"] || null,\n                            // CRITICAL FIX: Inherit paragraph alignment from context if not explicitly set\n                            alignment: range[\"@_Justification\"] || range[\"@_Alignment\"] || context.paragraphAlignment || null\n                        };\n                        // DEBUG: Log formatting extraction for any styled text (generic check)\n                        const rangeContent = range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\") : String(range.Content) : \"\";\n                        const hasStyleInfo = range[\"@_FontStyle\"] || range[\"@_AppliedCharacterStyle\"] || element[\"@_AppliedParagraphStyle\"] || range[\"@_AppliedFont\"];\n                        if (hasStyleInfo && rangeContent.trim()) {\n                            console.log(\"\\uD83D\\uDD27 StoryParser - Extracting formatting for range:\", JSON.stringify(rangeContent.substring(0, 30) + \"...\"), {\n                                rawRangeAttributes: Object.keys(range).filter((k)=>k.startsWith(\"@_\")),\n                                extractedFormatting: formatting,\n                                fontStyleFromXML: range[\"@_FontStyle\"],\n                                characterStyleFromXML: range[\"@_AppliedCharacterStyle\"],\n                                paragraphStyleFromXML: element[\"@_AppliedParagraphStyle\"]\n                            });\n                        }\n                        const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                        // FIXED: Process content with proper space preservation\n                        if (range.Content) {\n                            const contents = Array.isArray(range.Content) ? range.Content : [\n                                range.Content\n                            ];\n                            contents.forEach((contentItem, contentIndex)=>{\n                                const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n                                content += text;\n                                formattedContent.push({\n                                    text: text,\n                                    formatting: resolvedFormatting\n                                });\n                                // CRITICAL FIX: Check for Br elements AFTER each content item within the same range\n                                if (range.Br !== undefined && contentIndex < contents.length - 1) {\n                                    const lineBreakText = \"\\n\";\n                                    content += lineBreakText;\n                                    formattedContent.push({\n                                        text: lineBreakText,\n                                        formatting: {\n                                            isBreak: true,\n                                            breakType: \"line\",\n                                            position: \"between_content\",\n                                            source: \"Br element within range\"\n                                        }\n                                    });\n                                    debugInfo.push({\n                                        type: \"Line break detected within content\",\n                                        location: \"CharacterStyleRange[\".concat(rangeIndex, \"], between content[\").concat(contentIndex, \"] and content[\").concat(contentIndex + 1, \"]\"),\n                                        breakType: \"line\",\n                                        context: context\n                                    });\n                                }\n                            });\n                        }\n                        // Handle Br elements at the end of the range\n                        if (range.Br !== undefined && (!range.Content || Array.isArray(range.Content) === false)) {\n                            const brElements = _this.extractBrElements(range);\n                            brElements.forEach((brInfo, brIndex)=>{\n                                const lineBreakText = _this.determineLineBreakType(brInfo, context);\n                                content += lineBreakText;\n                                formattedContent.push({\n                                    text: lineBreakText,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: brInfo.type || \"line\",\n                                        position: brInfo.position || \"end\",\n                                        source: \"Br element at end of range\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Line break detected at end of range\",\n                                    location: \"CharacterStyleRange[\".concat(rangeIndex, \"], Br[\").concat(brIndex, \"]\"),\n                                    breakType: brInfo.type || \"line\",\n                                    context: context\n                                });\n                            });\n                        }\n                        // CRITICAL FIX: Add space between character style ranges if needed\n                        if (rangeIndex < ranges.length - 1) {\n                            const nextRange = ranges[rangeIndex + 1];\n                            // More robust space detection\n                            const currentText = content.slice(-10); // Check last 10 characters\n                            const currentRangeEndsWithSpace = /\\s$/.test(currentText); // Any whitespace at end\n                            const nextContent = nextRange.Content ? String(Array.isArray(nextRange.Content) ? nextRange.Content[0] : nextRange.Content) : \"\";\n                            const nextRangeStartsWithSpace = /^\\s/.test(nextContent); // Any whitespace at start\n                            // AGGRESSIVE FIX: Add space between ALL ranges unless explicitly not needed\n                            const shouldSkipSpace = currentRangeEndsWithSpace || nextRangeStartsWithSpace || _this.shouldInsertImplicitLineBreak(range, nextRange, context) || !nextRange.Content || // Skip if next range has no content\n                            nextContent.trim() === \"\"; // Skip if next content is only whitespace\n                            if (!shouldSkipSpace) {\n                                const currentStyle = range[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const nextStyle = nextRange[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const spaceText = \" \";\n                                content += spaceText;\n                                formattedContent.push({\n                                    text: spaceText,\n                                    formatting: {\n                                        isSpace: true,\n                                        source: \"between character style ranges (aggressive)\",\n                                        currentStyle,\n                                        nextStyle\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Space inserted between character styles (aggressive)\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    currentStyle,\n                                    nextStyle,\n                                    reason: \"Default space insertion - words likely split across ranges\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            } else {\n                                debugInfo.push({\n                                    type: \"Space insertion skipped\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1),\n                                    reason: currentRangeEndsWithSpace ? \"Current range ends with space\" : nextRangeStartsWithSpace ? \"Next range starts with space\" : !nextRange.Content ? \"Next range has no content\" : nextContent.trim() === \"\" ? \"Next content is only whitespace\" : \"Line break would be inserted\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            }\n                            // Handle explicit line breaks between ranges (for cases where shouldInsertImplicitLineBreak is true)\n                            if (_this.shouldInsertImplicitLineBreak(range, nextRange, context)) {\n                                const implicitBreak = \"\\n\";\n                                content += implicitBreak;\n                                formattedContent.push({\n                                    text: implicitBreak,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: \"implicit\",\n                                        source: \"between ranges\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Implicit line break\",\n                                    location: \"Between ranges \".concat(rangeIndex, \" and \").concat(rangeIndex + 1)\n                                });\n                            }\n                        }\n                    });\n                    return; // Don't continue processing to avoid duplication\n                }\n                // ENHANCED: Handle ParagraphStyleRange with context\n                if (element.ParagraphStyleRange) {\n                    const ranges = Array.isArray(element.ParagraphStyleRange) ? element.ParagraphStyleRange : [\n                        element.ParagraphStyleRange\n                    ];\n                    ranges.forEach((range, index)=>{\n                        const paragraphContext = {\n                            ...context,\n                            paragraphIndex: index,\n                            totalParagraphs: ranges.length,\n                            appliedStyle: range[\"@_AppliedParagraphStyle\"],\n                            // CRITICAL FIX: Pass down direct paragraph-level alignment\n                            paragraphAlignment: range[\"@_Justification\"] || range[\"@_Alignment\"]\n                        };\n                        extractTextRecursively(range, depth + 1, paragraphContext);\n                        // Add paragraph break between paragraphs (but not after the last one)\n                        if (index < ranges.length - 1) {\n                            const paragraphBreak = \"\\n\";\n                            content += paragraphBreak;\n                            formattedContent.push({\n                                text: paragraphBreak,\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"paragraph\",\n                                    source: \"between paragraphs\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Paragraph break\",\n                                location: \"between paragraphs \".concat(index, \" and \").concat(index + 1)\n                            });\n                        }\n                    });\n                    return;\n                }\n                // Handle direct Content elements (when not inside CharacterStyleRange)\n                if (element.Content && !element.CharacterStyleRange) {\n                    let text = Array.isArray(element.Content) ? element.Content.join(\"\") : String(element.Content);\n                    text = IDMLUtils.decodeXMLEntities(text);\n                    content += text;\n                    const formatting = {\n                        paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                        characterStyle: element[\"@_AppliedCharacterStyle\"] || null,\n                        fontSize: element[\"@_PointSize\"] || null,\n                        fontFamily: element[\"@_AppliedFont\"] || null,\n                        fillColor: element[\"@_FillColor\"] || null,\n                        // CRITICAL FIX: Inherit paragraph alignment from context if not explicitly set\n                        alignment: element[\"@_Justification\"] || element[\"@_Alignment\"] || context.paragraphAlignment || null\n                    };\n                    const resolvedFormatting = _this.styleParser.resolveStyleFormatting(formatting);\n                    formattedContent.push({\n                        text: text,\n                        formatting: resolvedFormatting\n                    });\n                }\n                // ENHANCED: Direct Br element handling (outside of ranges)\n                if (element.Br !== undefined) {\n                    const brElements = Array.isArray(element.Br) ? element.Br : [\n                        element.Br\n                    ];\n                    brElements.forEach((br, index)=>{\n                        const lineBreakText = \"\\n\";\n                        content += lineBreakText;\n                        formattedContent.push({\n                            text: lineBreakText,\n                            formatting: {\n                                isBreak: true,\n                                breakType: \"explicit\",\n                                source: \"direct Br element\"\n                            }\n                        });\n                        debugInfo.push({\n                            type: \"Direct Br element\",\n                            location: \"Direct element, index \".concat(index)\n                        });\n                    });\n                }\n                // Continue with other nested elements\n                Object.entries(element).forEach((param)=>{\n                    let [key, value] = param;\n                    if (!key.startsWith(\"@_\") && key !== \"Content\" && key !== \"Br\" && key !== \"CharacterStyleRange\" && key !== \"ParagraphStyleRange\") {\n                        if (Array.isArray(value)) {\n                            value.forEach((item)=>extractTextRecursively(item, depth + 1, context));\n                        } else if (typeof value === \"object\" && depth < 10) {\n                            extractTextRecursively(value, depth + 1, context);\n                        }\n                    }\n                });\n            }\n        };\n        extractTextRecursively(storyData);\n        // ENHANCED: Process and clean up the content with sophisticated line break preservation\n        const processedContent = IDMLUtils.sophisticatedLineBreakProcessing(content);\n        // DEBUG: Log space preservation results\n        console.log(\"\\uD83D\\uDCDD Text extraction results:\");\n        console.log(\"   - Original content length:\", content.length);\n        console.log(\"   - Processed content length:\", processedContent.length);\n        console.log(\"   - Space preservation events:\", debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length);\n        // SPECIFIC DEBUG: Check for the problematic \"pavoluptusda\" text (simplified)\n        if (processedContent.includes(\"pavoluptusda\") || processedContent.includes(\"pa\") && processedContent.includes(\"voluptusda\")) {\n            console.log(\"\\uD83D\\uDEA8 FOUND PROBLEMATIC TEXT:\");\n            console.log('   - Contains \"pavoluptusda\":', processedContent.includes(\"pavoluptusda\"));\n            console.log('   - Contains \"pa voluptusda\":', processedContent.includes(\"pa voluptusda\"));\n            console.log(\"   - FormattedContent breakdown:\", formattedContent.map((item)=>item.text).join(\"|\"));\n        }\n        const lineBreakInfo = {\n            hasLineBreaks: processedContent.includes(\"\\n\"),\n            lineBreakCount: (processedContent.match(/\\n/g) || []).length,\n            lineBreakTypes: this.analyzeLineBreakTypes(formattedContent),\n            debugInfo: debugInfo,\n            spacePreservationCount: debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length\n        };\n        return {\n            plainText: processedContent,\n            formattedContent: formattedContent.filter((item)=>item.text && item.text.length > 0),\n            wordCount: IDMLUtils.countWords(processedContent.replace(/\\n/g, \" \")),\n            characterCount: processedContent.length,\n            textColor: textColor,\n            lineBreakInfo: lineBreakInfo\n        };\n    }\n    // Add this helper method to better handle mixed content and Br elements\n    analyzeContentStructure(range) {\n        const structure = {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentItems: range.Content ? Array.isArray(range.Content) ? range.Content : [\n                range.Content\n            ] : [],\n            brElements: range.Br ? Array.isArray(range.Br) ? range.Br : [\n                range.Br\n            ] : []\n        };\n        console.log(\"Content structure analysis:\", structure);\n        return structure;\n    }\n    // Enhanced helper for processing interleaved content and breaks\n    processInterleavedContent(range, resolvedFormatting) {\n        const results = [];\n        let content = \"\";\n        // This method would need access to the actual XML structure to determine\n        // the exact order of Content and Br elements. For now, we'll use the \n        // approach above which handles the most common case.\n        return results;\n    }\n    // SOPHISTICATED: Helper method to extract Br elements with context\n    extractBrElements(range) {\n        const brElements = [];\n        if (range.Br !== undefined) {\n            if (Array.isArray(range.Br)) {\n                range.Br.forEach((br, index)=>{\n                    brElements.push({\n                        type: \"line\",\n                        position: index === 0 ? \"start\" : \"middle\",\n                        element: br\n                    });\n                });\n            } else {\n                brElements.push({\n                    type: \"line\",\n                    position: \"end\",\n                    element: range.Br\n                });\n            }\n        }\n        return brElements;\n    }\n    // SOPHISTICATED: Determine the appropriate line break type\n    determineLineBreakType(brInfo, context) {\n        // Different line break characters based on context\n        switch(brInfo.type){\n            case \"paragraph\":\n                return \"\\n\\n\"; // Double line break for paragraph separation\n            case \"forced\":\n                return \"\\n\"; // Forced line break (Shift+Enter equivalent)\n            case \"line\":\n            default:\n                return \"\\n\"; // Standard line break\n        }\n    }\n    // SOPHISTICATED: Determine if an implicit line break should be inserted\n    shouldInsertImplicitLineBreak(currentRange, nextRange, context) {\n        // Don't insert implicit breaks if explicit Br elements are present\n        if (currentRange.Br !== undefined || nextRange.Br !== undefined) {\n            return false;\n        }\n        // Insert breaks between different character styles in different paragraphs\n        const currentCharStyle = currentRange[\"@_AppliedCharacterStyle\"];\n        const nextCharStyle = nextRange[\"@_AppliedCharacterStyle\"];\n        // If we're in a context where styles change significantly, add a break\n        if (currentCharStyle && nextCharStyle && currentCharStyle !== nextCharStyle) {\n            // Check if this might be a title/heading followed by body text\n            const styleIndicatesBreak = this.styleIndicatesLineBreak(currentCharStyle, nextCharStyle);\n            return styleIndicatesBreak;\n        }\n        return false;\n    }\n    // SOPHISTICATED: Analyze if style change indicates a line break\n    styleIndicatesLineBreak(currentStyle, nextStyle) {\n        const titleIndicators = [\n            \"title\",\n            \"heading\",\n            \"header\"\n        ];\n        const bodyIndicators = [\n            \"body\",\n            \"text\",\n            \"normal\"\n        ];\n        const currentIsTitle = titleIndicators.some((indicator)=>currentStyle.toLowerCase().includes(indicator));\n        const nextIsBody = bodyIndicators.some((indicator)=>nextStyle.toLowerCase().includes(indicator));\n        return currentIsTitle && nextIsBody;\n    }\n    // SOPHISTICATED: Analyze line break types in formatted content\n    analyzeLineBreakTypes(formattedContent) {\n        const types = {\n            explicit: 0,\n            implicit: 0,\n            paragraph: 0,\n            direct: 0 // Direct Br elements\n        };\n        formattedContent.forEach((item)=>{\n            var _item_formatting;\n            if ((_item_formatting = item.formatting) === null || _item_formatting === void 0 ? void 0 : _item_formatting.isBreak) {\n                const breakType = item.formatting.breakType || \"unknown\";\n                if (types.hasOwnProperty(breakType)) {\n                    types[breakType]++;\n                }\n            }\n        });\n        return types;\n    }\n    extractDetailedFormattingFromRange(range) {\n        const formatting = {};\n        // Extract all possible font attributes\n        const fontAttributes = [\n            \"@_AppliedFont\",\n            \"@_FontFamily\",\n            \"@_Font\",\n            \"@_PostScriptName\",\n            \"@_FontName\"\n        ];\n        fontAttributes.forEach((attr)=>{\n            if (range[attr]) {\n                formatting.fontReference = range[attr];\n            }\n        });\n        // Extract font and size attributes\n        formatting.fontSize = IDMLUtils.parseNumeric(range[\"@_PointSize\"]);\n        // ENHANCED: Extract leading with proper processing\n        const rawLeading = range[\"@_Leading\"];\n        formatting.leading = this.processLeadingValue(rawLeading, formatting.fontSize);\n        formatting.leadingType = this.determineLeadingType(rawLeading);\n        // Extract color and style attributes\n        formatting.fillColor = range[\"@_FillColor\"];\n        formatting.strokeColor = range[\"@_StrokeColor\"];\n        formatting.fontStyle = range[\"@_FontStyle\"];\n        // Extract advanced typography attributes\n        formatting.tracking = IDMLUtils.parseNumeric(range[\"@_Tracking\"]);\n        formatting.baselineShift = IDMLUtils.parseNumeric(range[\"@_BaselineShift\"]);\n        formatting.kerning = IDMLUtils.parseNumeric(range[\"@_Kerning\"]);\n        formatting.horizontalScale = IDMLUtils.parseNumeric(range[\"@_HorizontalScale\"]) || 100;\n        formatting.verticalScale = IDMLUtils.parseNumeric(range[\"@_VerticalScale\"]) || 100;\n        // ENHANCED: Extract InDesign-specific text layout properties for precise rendering\n        formatting.baselineGridAlign = range[\"@_AlignToBaseline\"] || \"None\";\n        formatting.dropCapLines = IDMLUtils.parseNumeric(range[\"@_DropCapLines\"]) || 0;\n        formatting.dropCapCharacters = IDMLUtils.parseNumeric(range[\"@_DropCapCharacters\"]) || 0;\n        // Extract paragraph-level attributes if present\n        // CRITICAL FIX: Only set alignment if explicitly specified, allowing paragraph inheritance\n        const explicitAlignment = range[\"@_Justification\"] || range[\"@_Alignment\"];\n        if (explicitAlignment) {\n            formatting.alignment = explicitAlignment;\n        }\n        formatting.leftIndent = IDMLUtils.parseNumeric(range[\"@_LeftIndent\"]);\n        formatting.rightIndent = IDMLUtils.parseNumeric(range[\"@_RightIndent\"]);\n        formatting.firstLineIndent = IDMLUtils.parseNumeric(range[\"@_FirstLineIndent\"]);\n        formatting.spaceBefore = IDMLUtils.parseNumeric(range[\"@_SpaceBefore\"]);\n        formatting.spaceAfter = IDMLUtils.parseNumeric(range[\"@_SpaceAfter\"]);\n        // Calculate effective line height for CSS\n        formatting.effectiveLineHeight = this.calculateEffectiveLineHeight(formatting);\n        return formatting;\n    }\n    // NEW: Process leading values with InDesign-specific logic\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = IDMLUtils.parseNumeric(rawLeading);\n        if (numericLeading) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (IDMLUtils.parseNumeric(rawLeading)) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(formatting) {\n        const fontSize = formatting.fontSize || 12;\n        const leading = formatting.leading;\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\") {\n            // Convert points to CSS line-height ratio\n            return leading / fontSize;\n        }\n        return 1.2; // Fallback\n    }\n    extractTextFormatting(storyData) {\n        const formatting = {\n            paragraphStyles: [],\n            characterStyles: [],\n            appliedStyles: []\n        };\n        // Extract applied paragraph styles\n        if (storyData.ParagraphStyleRange) {\n            const ranges = Array.isArray(storyData.ParagraphStyleRange) ? storyData.ParagraphStyleRange : [\n                storyData.ParagraphStyleRange\n            ];\n            ranges.forEach((range)=>{\n                const appliedStyle = range[\"@_AppliedParagraphStyle\"];\n                if (appliedStyle && !formatting.paragraphStyles.includes(appliedStyle)) {\n                    formatting.paragraphStyles.push(appliedStyle);\n                }\n                // Extract character styles within paragraph ranges\n                if (range.CharacterStyleRange) {\n                    const charRanges = Array.isArray(range.CharacterStyleRange) ? range.CharacterStyleRange : [\n                        range.CharacterStyleRange\n                    ];\n                    charRanges.forEach((charRange)=>{\n                        const charStyle = charRange[\"@_AppliedCharacterStyle\"];\n                        if (charStyle && !formatting.characterStyles.includes(charStyle)) {\n                            formatting.characterStyles.push(charStyle);\n                        }\n                    });\n                }\n            });\n        }\n        return formatting;\n    }\n    // Add this method to debug raw story content\n    debugRawStoryContent(storyData) {\n        console.log(\"\\n\\uD83D\\uDD0D RAW STORY CONTENT DEBUG:\");\n        console.log(\"Story keys:\", Object.keys(storyData));\n        const findCharacterRanges = function(obj) {\n            let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key === \"CharacterStyleRange\") {\n                        console.log(\"\\n\\uD83D\\uDCDD Found CharacterStyleRange at \".concat(path, \":\"), obj[key]);\n                        const ranges = Array.isArray(obj[key]) ? obj[key] : [\n                            obj[key]\n                        ];\n                        ranges.forEach((range, index)=>{\n                            console.log(\"  Range \".concat(index + 1, \" attributes:\"), Object.keys(range).filter((k)=>k.startsWith(\"@_\")));\n                            console.log(\"  Range \".concat(index + 1, \" font info:\"), {\n                                AppliedFont: range[\"@_AppliedFont\"],\n                                FontStyle: range[\"@_FontStyle\"],\n                                PointSize: range[\"@_PointSize\"]\n                            });\n                        });\n                    } else if (typeof obj[key] === \"object\") {\n                        findCharacterRanges(obj[key], \"\".concat(path, \".\").concat(key));\n                    }\n                });\n            }\n        };\n        findCharacterRanges(storyData);\n    }\n    getStories() {\n        return this.stories;\n    }\n    getStory(storyId) {\n        return this.stories[storyId];\n    }\n    clearStories() {\n        this.stories = {};\n    }\n    constructor(styleParser){\n        this.styleParser = styleParser;\n        this.stories = {};\n    }\n}\nmodule.exports = StoryParser;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcGFyc2Vycy9TdG9yeVBhcnNlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDckIsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUM7QUFFMUIsTUFBTUU7SUFNSixNQUFNQyxlQUFlQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsU0FBUyxFQUFFO1FBQ2pEQyxRQUFRQyxHQUFHLENBQUMsK0JBQThCLE9BQVRKO1FBRWpDLElBQUk7WUFDRixNQUFNSyxTQUFTSCxVQUFVSSxLQUFLLENBQUNMO1lBQy9CLE1BQU1NLFVBQVVaLEtBQUthLFFBQVEsQ0FBQ1IsVUFBVTtZQUV4QyxNQUFNUyxZQUFZSixPQUFPSyxLQUFLLElBQUlMO1lBRWxDLCtCQUErQjtZQUMvQkYsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0JKO1lBQ2hDRyxRQUFRQyxHQUFHLENBQUMsc0JBQXNCTyxPQUFPQyxJQUFJLENBQUNIO1lBQzlDTixRQUFRQyxHQUFHLENBQUMsMEJBQTBCUyxLQUFLQyxTQUFTLENBQUNMLFdBQVcsTUFBTSxHQUFHTSxTQUFTLENBQUMsR0FBRztZQUV0RixxQ0FBcUM7WUFDckMsTUFBTUMsZ0JBQWdCO2dCQUNwQkMsTUFBTVIsU0FBUyxDQUFDLFNBQVM7Z0JBQ3pCUyxpQkFBaUJULFNBQVMsQ0FBQyxvQkFBb0IsSUFBSTtnQkFDbkRVLFVBQVVWLFNBQVMsQ0FBQyxhQUFhLEtBQUs7Z0JBRXRDLHdDQUF3QztnQkFDeENSLFNBQVMsSUFBSSxDQUFDbUIsMkJBQTJCLENBQUNYO2dCQUUxQywwQkFBMEI7Z0JBQzFCWSxnQkFBZ0IsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ2I7WUFDN0M7WUFFQSxNQUFNYyxlQUFlaEIsUUFBUWlCLE9BQU8sQ0FBQyxVQUFVO1lBQy9DLElBQUksQ0FBQ0MsT0FBTyxDQUFDRixhQUFhLEdBQUdQO1lBRTdCLHVDQUF1QztZQUN2QyxNQUFNLEVBQUVVLFNBQVMsRUFBRUMsYUFBYSxFQUFFLEdBQUdYLGNBQWNmLE9BQU87WUFDMURFLFFBQVFDLEdBQUcsQ0FBQyxXQUFtQixPQUFSRyxTQUFRO1lBQy9CSixRQUFRQyxHQUFHLENBQUMsb0JBQXFDLE9BQWpCc0IsVUFBVUUsTUFBTTtZQUNoRHpCLFFBQVFDLEdBQUcsQ0FBQyxlQUErQyxPQUFoQ1ksY0FBY2YsT0FBTyxDQUFDNEIsU0FBUztZQUMxRDFCLFFBQVFDLEdBQUcsQ0FBQyxxQkFBd0QsT0FBbkN1QixDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVHLGNBQWMsS0FBSTtZQUNsRTNCLFFBQVFDLEdBQUcsQ0FBQyx1QkFBd0UsT0FBakRzQixVQUFVWCxTQUFTLENBQUMsR0FBRyxJQUFJUyxPQUFPLENBQUMsT0FBTyxRQUFPO1FBRXRGLEVBQUUsT0FBT08sT0FBTztZQUNkNUIsUUFBUTRCLEtBQUssQ0FBQyx5QkFBa0MsT0FBVC9CLFVBQVMsTUFBSStCLE1BQU1DLE9BQU87UUFDbkU7SUFDRjtJQUVBLHNGQUFzRjtJQUN0RlosNEJBQTRCWCxTQUFTLEVBQUU7O1FBQ3JDLElBQUlSLFVBQVU7UUFDZCxJQUFJZ0MsbUJBQW1CLEVBQUU7UUFDekIsSUFBSUMsWUFBWTtRQUNoQixJQUFJQyxZQUFZLEVBQUU7UUFFbEIsTUFBTUMseUJBQXlCLFNBQUNDO2dCQUFTQyx5RUFBUSxHQUFHQywyRUFBVSxDQUFDO1lBQzdELElBQUksT0FBT0YsWUFBWSxVQUFVO2dCQUMvQnBDLFdBQVdvQztnQkFDWDtZQUNGO1lBRUEsSUFBSUEsV0FBVyxPQUFPQSxZQUFZLFVBQVU7Z0JBQzFDLHFGQUFxRjtnQkFDckYsSUFBSUEsUUFBUUcsbUJBQW1CLEVBQUU7b0JBQy9CLE1BQU1DLFNBQVNDLE1BQU1DLE9BQU8sQ0FBQ04sUUFBUUcsbUJBQW1CLElBQ3RESCxRQUFRRyxtQkFBbUIsR0FBRzt3QkFBQ0gsUUFBUUcsbUJBQW1CO3FCQUFDO29CQUU3RCxxREFBcUQ7b0JBQ3JELE1BQU1JLGtCQUFrQkgsT0FBT0ksR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxPQUFPLEdBQzlDTCxNQUFNQyxPQUFPLENBQUNHLEVBQUVDLE9BQU8sSUFBSUQsRUFBRUMsT0FBTyxDQUFDQyxJQUFJLENBQUMsTUFBTUMsT0FBT0gsRUFBRUMsT0FBTyxJQUFLLElBQUlDLElBQUksQ0FBQztvQkFDakYsSUFBSUosZ0JBQWdCTSxRQUFRLENBQUMsbUJBQW1CTixnQkFBZ0JNLFFBQVEsQ0FBQyxTQUFTTixnQkFBZ0JNLFFBQVEsQ0FBQyxlQUFlO3dCQUN4SC9DLFFBQVFDLEdBQUcsQ0FBQzt3QkFDWnFDLE9BQU9VLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQzs0QkFDckIsTUFBTXBELFVBQVVtRCxNQUFNTCxPQUFPLEdBQzFCTCxNQUFNQyxPQUFPLENBQUNTLE1BQU1MLE9BQU8sSUFBSUssTUFBTUwsT0FBTyxDQUFDQyxJQUFJLENBQUMsTUFBTUMsT0FBT0csTUFBTUwsT0FBTyxJQUFLOzRCQUNwRjVDLFFBQVFDLEdBQUcsQ0FBQyxZQUF1QkgsT0FBWG9ELE9BQU0sT0FBYSxPQUFScEQsU0FBUTt3QkFDN0M7b0JBQ0Y7b0JBRUF3QyxPQUFPVSxPQUFPLENBQUMsQ0FBQ0MsT0FBT0U7d0JBQ3JCLG9EQUFvRDt3QkFDcEQsTUFBTUMsZ0JBQWdCSCxLQUFLLENBQUMsZ0JBQWdCLElBQ3ZCQSxLQUFLLENBQUMsZUFBZSxJQUNyQkEsS0FBSyxDQUFDLFNBQVMsSUFBSTt3QkFFeEMsTUFBTUksYUFBYTs0QkFDakJDLGdCQUFnQnBCLE9BQU8sQ0FBQywwQkFBMEIsSUFBSUUsUUFBUW1CLFlBQVksSUFBSTs0QkFDOUVDLGdCQUFnQlAsS0FBSyxDQUFDLDBCQUEwQixJQUFJOzRCQUNwRFEsVUFBVVIsS0FBSyxDQUFDLGNBQWMsR0FBR1MsV0FBV1QsS0FBSyxDQUFDLGNBQWMsSUFBSTs0QkFDcEVVLGVBQWVQOzRCQUNmUSxXQUFXWCxLQUFLLENBQUMsY0FBYyxJQUFJOzRCQUNuQ1ksV0FBV1osS0FBSyxDQUFDLGNBQWMsSUFBSTs0QkFDbkMsK0VBQStFOzRCQUMvRWEsV0FBV2IsS0FBSyxDQUFDLGtCQUFrQixJQUFJQSxLQUFLLENBQUMsY0FBYyxJQUFJYixRQUFRMkIsa0JBQWtCLElBQUk7d0JBQy9GO3dCQUVBLHVFQUF1RTt3QkFDdkUsTUFBTUMsZUFBZWYsTUFBTUwsT0FBTyxHQUMvQkwsTUFBTUMsT0FBTyxDQUFDUyxNQUFNTCxPQUFPLElBQUlLLE1BQU1MLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLE1BQU1DLE9BQU9HLE1BQU1MLE9BQU8sSUFBSzt3QkFDcEYsTUFBTXFCLGVBQWVoQixLQUFLLENBQUMsY0FBYyxJQUFJQSxLQUFLLENBQUMsMEJBQTBCLElBQ3pEZixPQUFPLENBQUMsMEJBQTBCLElBQUllLEtBQUssQ0FBQyxnQkFBZ0I7d0JBRWhGLElBQUlnQixnQkFBZ0JELGFBQWFFLElBQUksSUFBSTs0QkFDdkNsRSxRQUFRQyxHQUFHLENBQUMsK0RBQXFEUyxLQUFLQyxTQUFTLENBQUNxRCxhQUFhcEQsU0FBUyxDQUFDLEdBQUcsTUFBTSxRQUFRO2dDQUN0SHVELG9CQUFvQjNELE9BQU9DLElBQUksQ0FBQ3dDLE9BQU9tQixNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLFVBQVUsQ0FBQztnQ0FDaEVDLHFCQUFxQmxCO2dDQUNyQm1CLGtCQUFrQnZCLEtBQUssQ0FBQyxjQUFjO2dDQUN0Q3dCLHVCQUF1QnhCLEtBQUssQ0FBQywwQkFBMEI7Z0NBQ3ZEeUIsdUJBQXVCeEMsT0FBTyxDQUFDLDBCQUEwQjs0QkFDM0Q7d0JBQ0Y7d0JBRUEsTUFBTXlDLHFCQUFxQixNQUFLQyxXQUFXLENBQUNDLHNCQUFzQixDQUFDeEI7d0JBRW5FLHdEQUF3RDt3QkFDeEQsSUFBSUosTUFBTUwsT0FBTyxFQUFFOzRCQUNqQixNQUFNa0MsV0FBV3ZDLE1BQU1DLE9BQU8sQ0FBQ1MsTUFBTUwsT0FBTyxJQUFJSyxNQUFNTCxPQUFPLEdBQUc7Z0NBQUNLLE1BQU1MLE9BQU87NkJBQUM7NEJBQy9Fa0MsU0FBUzlCLE9BQU8sQ0FBQyxDQUFDK0IsYUFBYUM7Z0NBQzdCLE1BQU1DLE9BQU92RixVQUFVd0YsaUJBQWlCLENBQUNwQyxPQUFPaUM7Z0NBQ2hEakYsV0FBV21GO2dDQUNYbkQsaUJBQWlCcUQsSUFBSSxDQUFDO29DQUNwQkYsTUFBTUE7b0NBQ041QixZQUFZc0I7Z0NBQ2Q7Z0NBRUEsb0ZBQW9GO2dDQUNwRixJQUFJMUIsTUFBTW1DLEVBQUUsS0FBS0MsYUFBYUwsZUFBZUYsU0FBU3JELE1BQU0sR0FBRyxHQUFHO29DQUNoRSxNQUFNNkQsZ0JBQWdCO29DQUN0QnhGLFdBQVd3RjtvQ0FDWHhELGlCQUFpQnFELElBQUksQ0FBQzt3Q0FDcEJGLE1BQU1LO3dDQUNOakMsWUFBWTs0Q0FDVmtDLFNBQVM7NENBQ1RDLFdBQVc7NENBQ1hDLFVBQVU7NENBQ1ZDLFFBQVE7d0NBQ1Y7b0NBQ0Y7b0NBRUExRCxVQUFVbUQsSUFBSSxDQUFDO3dDQUNiUSxNQUFNO3dDQUNOQyxVQUFVLHVCQUF1RFosT0FBaEM3QixZQUFXLHVCQUFrRDZCLE9BQTdCQSxjQUFhLGtCQUFpQyxPQUFqQkEsZUFBZSxHQUFFO3dDQUMvR1EsV0FBVzt3Q0FDWHBELFNBQVNBO29DQUNYO2dDQUNGOzRCQUNGO3dCQUNGO3dCQUVBLDZDQUE2Qzt3QkFDN0MsSUFBSWEsTUFBTW1DLEVBQUUsS0FBS0MsYUFBYyxFQUFDcEMsTUFBTUwsT0FBTyxJQUFJTCxNQUFNQyxPQUFPLENBQUNTLE1BQU1MLE9BQU8sTUFBTSxLQUFJLEdBQUk7NEJBQ3hGLE1BQU1pRCxhQUFhLE1BQUtDLGlCQUFpQixDQUFDN0M7NEJBQzFDNEMsV0FBVzdDLE9BQU8sQ0FBQyxDQUFDK0MsUUFBUUM7Z0NBQzFCLE1BQU1WLGdCQUFnQixNQUFLVyxzQkFBc0IsQ0FBQ0YsUUFBUTNEO2dDQUMxRHRDLFdBQVd3RjtnQ0FFWHhELGlCQUFpQnFELElBQUksQ0FBQztvQ0FDcEJGLE1BQU1LO29DQUNOakMsWUFBWTt3Q0FDVmtDLFNBQVM7d0NBQ1RDLFdBQVdPLE9BQU9KLElBQUksSUFBSTt3Q0FDMUJGLFVBQVVNLE9BQU9OLFFBQVEsSUFBSTt3Q0FDN0JDLFFBQVE7b0NBQ1Y7Z0NBQ0Y7Z0NBRUExRCxVQUFVbUQsSUFBSSxDQUFDO29DQUNiUSxNQUFNO29DQUNOQyxVQUFVLHVCQUEwQ0ksT0FBbkI3QyxZQUFXLFVBQWdCLE9BQVI2QyxTQUFRO29DQUM1RFIsV0FBV08sT0FBT0osSUFBSSxJQUFJO29DQUMxQnZELFNBQVNBO2dDQUNYOzRCQUNGO3dCQUNGO3dCQUVBLG1FQUFtRTt3QkFDbkUsSUFBSWUsYUFBYWIsT0FBT2IsTUFBTSxHQUFHLEdBQUc7NEJBQ2xDLE1BQU15RSxZQUFZNUQsTUFBTSxDQUFDYSxhQUFhLEVBQUU7NEJBRXhDLDhCQUE4Qjs0QkFDOUIsTUFBTWdELGNBQWNyRyxRQUFRc0csS0FBSyxDQUFDLENBQUMsS0FBSywyQkFBMkI7NEJBQ25FLE1BQU1DLDRCQUE0QixNQUFNQyxJQUFJLENBQUNILGNBQWMsd0JBQXdCOzRCQUVuRixNQUFNSSxjQUFjTCxVQUFVdEQsT0FBTyxHQUNuQ0UsT0FBT1AsTUFBTUMsT0FBTyxDQUFDMEQsVUFBVXRELE9BQU8sSUFBSXNELFVBQVV0RCxPQUFPLENBQUMsRUFBRSxHQUFHc0QsVUFBVXRELE9BQU8sSUFBSTs0QkFDeEYsTUFBTTRELDJCQUEyQixNQUFNRixJQUFJLENBQUNDLGNBQWMsMEJBQTBCOzRCQUVwRiw0RUFBNEU7NEJBQzVFLE1BQU1FLGtCQUFrQkosNkJBQ0RHLDRCQUNBLE1BQUtFLDZCQUE2QixDQUFDekQsT0FBT2lELFdBQVc5RCxZQUNyRCxDQUFDOEQsVUFBVXRELE9BQU8sSUFBSSxvQ0FBb0M7NEJBQzFEMkQsWUFBWXJDLElBQUksT0FBTyxJQUFJLDBDQUEwQzs0QkFFNUYsSUFBSSxDQUFDdUMsaUJBQWlCO2dDQUNwQixNQUFNRSxlQUFlMUQsS0FBSyxDQUFDLDBCQUEwQixJQUFJO2dDQUN6RCxNQUFNMkQsWUFBWVYsU0FBUyxDQUFDLDBCQUEwQixJQUFJO2dDQUUxRCxNQUFNVyxZQUFZO2dDQUNsQi9HLFdBQVcrRztnQ0FDWC9FLGlCQUFpQnFELElBQUksQ0FBQztvQ0FDcEJGLE1BQU00QjtvQ0FDTnhELFlBQVk7d0NBQ1Z5RCxTQUFTO3dDQUNUcEIsUUFBUTt3Q0FDUmlCO3dDQUNBQztvQ0FDRjtnQ0FDRjtnQ0FFQTVFLFVBQVVtRCxJQUFJLENBQUM7b0NBQ2JRLE1BQU07b0NBQ05DLFVBQVUsa0JBQW9DekMsT0FBbEJBLFlBQVcsU0FBc0IsT0FBZkEsYUFBYTtvQ0FDM0R3RDtvQ0FDQUM7b0NBQ0FHLFFBQVE7b0NBQ1JDLGdCQUFnQmIsWUFBWUMsS0FBSyxDQUFDLENBQUM7b0NBQ25DYSxlQUFlVixZQUFZSCxLQUFLLENBQUMsR0FBRztnQ0FDdEM7NEJBQ0YsT0FBTztnQ0FDTHBFLFVBQVVtRCxJQUFJLENBQUM7b0NBQ2JRLE1BQU07b0NBQ05DLFVBQVUsa0JBQW9DekMsT0FBbEJBLFlBQVcsU0FBc0IsT0FBZkEsYUFBYTtvQ0FDM0Q0RCxRQUFRViw0QkFBNEIsa0NBQzVCRywyQkFBMkIsaUNBQzNCLENBQUNOLFVBQVV0RCxPQUFPLEdBQUcsOEJBQ3JCMkQsWUFBWXJDLElBQUksT0FBTyxLQUFLLG9DQUFvQztvQ0FDeEU4QyxnQkFBZ0JiLFlBQVlDLEtBQUssQ0FBQyxDQUFDO29DQUNuQ2EsZUFBZVYsWUFBWUgsS0FBSyxDQUFDLEdBQUc7Z0NBQ3RDOzRCQUNGOzRCQUVBLHFHQUFxRzs0QkFDckcsSUFBSSxNQUFLTSw2QkFBNkIsQ0FBQ3pELE9BQU9pRCxXQUFXOUQsVUFBVTtnQ0FDakUsTUFBTThFLGdCQUFnQjtnQ0FDdEJwSCxXQUFXb0g7Z0NBQ1hwRixpQkFBaUJxRCxJQUFJLENBQUM7b0NBQ3BCRixNQUFNaUM7b0NBQ043RCxZQUFZO3dDQUNWa0MsU0FBUzt3Q0FDVEMsV0FBVzt3Q0FDWEUsUUFBUTtvQ0FDVjtnQ0FDRjtnQ0FFQTFELFVBQVVtRCxJQUFJLENBQUM7b0NBQ2JRLE1BQU07b0NBQ05DLFVBQVUsa0JBQW9DekMsT0FBbEJBLFlBQVcsU0FBc0IsT0FBZkEsYUFBYTtnQ0FDN0Q7NEJBQ0Y7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsUUFBUSxpREFBaUQ7Z0JBQzNEO2dCQUVBLG9EQUFvRDtnQkFDcEQsSUFBSWpCLFFBQVFpRixtQkFBbUIsRUFBRTtvQkFDL0IsTUFBTTdFLFNBQVNDLE1BQU1DLE9BQU8sQ0FBQ04sUUFBUWlGLG1CQUFtQixJQUN0RGpGLFFBQVFpRixtQkFBbUIsR0FBRzt3QkFBQ2pGLFFBQVFpRixtQkFBbUI7cUJBQUM7b0JBRTdEN0UsT0FBT1UsT0FBTyxDQUFDLENBQUNDLE9BQU9DO3dCQUNyQixNQUFNa0UsbUJBQW1COzRCQUN2QixHQUFHaEYsT0FBTzs0QkFDVmlGLGdCQUFnQm5FOzRCQUNoQm9FLGlCQUFpQmhGLE9BQU9iLE1BQU07NEJBQzlCOEIsY0FBY04sS0FBSyxDQUFDLDBCQUEwQjs0QkFDOUMsMkRBQTJEOzRCQUMzRGMsb0JBQW9CZCxLQUFLLENBQUMsa0JBQWtCLElBQUlBLEtBQUssQ0FBQyxjQUFjO3dCQUN0RTt3QkFFQWhCLHVCQUF1QmdCLE9BQU9kLFFBQVEsR0FBR2lGO3dCQUV6QyxzRUFBc0U7d0JBQ3RFLElBQUlsRSxRQUFRWixPQUFPYixNQUFNLEdBQUcsR0FBRzs0QkFDN0IsTUFBTThGLGlCQUFpQjs0QkFDdkJ6SCxXQUFXeUg7NEJBQ1h6RixpQkFBaUJxRCxJQUFJLENBQUM7Z0NBQ3BCRixNQUFNc0M7Z0NBQ05sRSxZQUFZO29DQUNWa0MsU0FBUztvQ0FDVEMsV0FBVztvQ0FDWEUsUUFBUTtnQ0FDVjs0QkFDRjs0QkFDQTFELFVBQVVtRCxJQUFJLENBQUM7Z0NBQ2JRLE1BQU07Z0NBQ05DLFVBQVUsc0JBQW1DMUMsT0FBYkEsT0FBTSxTQUFpQixPQUFWQSxRQUFROzRCQUN2RDt3QkFDRjtvQkFDRjtvQkFDQTtnQkFDRjtnQkFFQSx1RUFBdUU7Z0JBQ3ZFLElBQUloQixRQUFRVSxPQUFPLElBQUksQ0FBQ1YsUUFBUUcsbUJBQW1CLEVBQUU7b0JBQ25ELElBQUk0QyxPQUFPMUMsTUFBTUMsT0FBTyxDQUFDTixRQUFRVSxPQUFPLElBQUlWLFFBQVFVLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLE1BQU1DLE9BQU9aLFFBQVFVLE9BQU87b0JBQzdGcUMsT0FBT3ZGLFVBQVV3RixpQkFBaUIsQ0FBQ0Q7b0JBQ25DbkYsV0FBV21GO29CQUVYLE1BQU01QixhQUFhO3dCQUNqQkMsZ0JBQWdCcEIsT0FBTyxDQUFDLDBCQUEwQixJQUFJRSxRQUFRbUIsWUFBWSxJQUFJO3dCQUM5RUMsZ0JBQWdCdEIsT0FBTyxDQUFDLDBCQUEwQixJQUFJO3dCQUN0RHVCLFVBQVV2QixPQUFPLENBQUMsY0FBYyxJQUFJO3dCQUNwQ3NGLFlBQVl0RixPQUFPLENBQUMsZ0JBQWdCLElBQUk7d0JBQ3hDMEIsV0FBVzFCLE9BQU8sQ0FBQyxjQUFjLElBQUk7d0JBQ3JDLCtFQUErRTt3QkFDL0U0QixXQUFXNUIsT0FBTyxDQUFDLGtCQUFrQixJQUFJQSxPQUFPLENBQUMsY0FBYyxJQUFJRSxRQUFRMkIsa0JBQWtCLElBQUk7b0JBQ25HO29CQUVBLE1BQU1ZLHFCQUFxQixNQUFLQyxXQUFXLENBQUNDLHNCQUFzQixDQUFDeEI7b0JBRW5FdkIsaUJBQWlCcUQsSUFBSSxDQUFDO3dCQUNwQkYsTUFBTUE7d0JBQ041QixZQUFZc0I7b0JBQ2Q7Z0JBQ0Y7Z0JBRUEsMkRBQTJEO2dCQUMzRCxJQUFJekMsUUFBUWtELEVBQUUsS0FBS0MsV0FBVztvQkFDNUIsTUFBTVEsYUFBYXRELE1BQU1DLE9BQU8sQ0FBQ04sUUFBUWtELEVBQUUsSUFBSWxELFFBQVFrRCxFQUFFLEdBQUc7d0JBQUNsRCxRQUFRa0QsRUFBRTtxQkFBQztvQkFDeEVTLFdBQVc3QyxPQUFPLENBQUMsQ0FBQ3lFLElBQUl2RTt3QkFDdEIsTUFBTW9DLGdCQUFnQjt3QkFDdEJ4RixXQUFXd0Y7d0JBQ1h4RCxpQkFBaUJxRCxJQUFJLENBQUM7NEJBQ3BCRixNQUFNSzs0QkFDTmpDLFlBQVk7Z0NBQ1ZrQyxTQUFTO2dDQUNUQyxXQUFXO2dDQUNYRSxRQUFROzRCQUNWO3dCQUNGO3dCQUNBMUQsVUFBVW1ELElBQUksQ0FBQzs0QkFDYlEsTUFBTTs0QkFDTkMsVUFBVSx5QkFBK0IsT0FBTjFDO3dCQUNyQztvQkFDRjtnQkFDRjtnQkFFQSxzQ0FBc0M7Z0JBQ3RDMUMsT0FBT2tILE9BQU8sQ0FBQ3hGLFNBQVNjLE9BQU8sQ0FBQzt3QkFBQyxDQUFDMkUsS0FBS0MsTUFBTTtvQkFDM0MsSUFBSSxDQUFDRCxJQUFJckQsVUFBVSxDQUFDLFNBQ2hCcUQsUUFBUSxhQUNSQSxRQUFRLFFBQ1JBLFFBQVEseUJBQ1JBLFFBQVEsdUJBQXVCO3dCQUNqQyxJQUFJcEYsTUFBTUMsT0FBTyxDQUFDb0YsUUFBUTs0QkFDeEJBLE1BQU01RSxPQUFPLENBQUM2RSxDQUFBQSxPQUFRNUYsdUJBQXVCNEYsTUFBTTFGLFFBQVEsR0FBR0M7d0JBQ2hFLE9BQU8sSUFBSSxPQUFPd0YsVUFBVSxZQUFZekYsUUFBUSxJQUFJOzRCQUNsREYsdUJBQXVCMkYsT0FBT3pGLFFBQVEsR0FBR0M7d0JBQzNDO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBSCx1QkFBdUIzQjtRQUV2Qix3RkFBd0Y7UUFDeEYsTUFBTXdILG1CQUFtQnBJLFVBQVVxSSxnQ0FBZ0MsQ0FBQ2pJO1FBRXBFLHdDQUF3QztRQUN4Q0UsUUFBUUMsR0FBRyxDQUFDO1FBQ1pELFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUNILFFBQVEyQixNQUFNO1FBQzNEekIsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQzZILGlCQUFpQnJHLE1BQU07UUFDckV6QixRQUFRQyxHQUFHLENBQUMsbUNBQW1DK0IsVUFBVW9DLE1BQU0sQ0FBQzRELENBQUFBLE9BQVFBLEtBQUtyQyxJQUFJLENBQUM1QyxRQUFRLENBQUMsbUJBQW1CdEIsTUFBTTtRQUVwSCw2RUFBNkU7UUFDN0UsSUFBSXFHLGlCQUFpQi9FLFFBQVEsQ0FBQyxtQkFBbUIrRSxpQkFBaUIvRSxRQUFRLENBQUMsU0FBUytFLGlCQUFpQi9FLFFBQVEsQ0FBQyxlQUFlO1lBQzNIL0MsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUM2SCxpQkFBaUIvRSxRQUFRLENBQUM7WUFDdkUvQyxRQUFRQyxHQUFHLENBQUMsa0NBQWtDNkgsaUJBQWlCL0UsUUFBUSxDQUFDO1lBQ3hFL0MsUUFBUUMsR0FBRyxDQUFDLG9DQUFvQzZCLGlCQUFpQlksR0FBRyxDQUFDbUYsQ0FBQUEsT0FBUUEsS0FBSzVDLElBQUksRUFBRXBDLElBQUksQ0FBQztRQUMvRjtRQUlBLE1BQU1yQixnQkFBZ0I7WUFDcEJ5RyxlQUFlSCxpQkFBaUIvRSxRQUFRLENBQUM7WUFDekNwQixnQkFBZ0IsQ0FBQ21HLGlCQUFpQkksS0FBSyxDQUFDLFVBQVUsRUFBRSxFQUFFekcsTUFBTTtZQUM1RDBHLGdCQUFnQixJQUFJLENBQUNDLHFCQUFxQixDQUFDdEc7WUFDM0NFLFdBQVdBO1lBQ1hxRyx3QkFBd0JyRyxVQUFVb0MsTUFBTSxDQUFDNEQsQ0FBQUEsT0FBUUEsS0FBS3JDLElBQUksQ0FBQzVDLFFBQVEsQ0FBQyxtQkFBbUJ0QixNQUFNO1FBQy9GO1FBRUEsT0FBTztZQUNMRixXQUFXdUc7WUFDWGhHLGtCQUFrQkEsaUJBQWlCc0MsTUFBTSxDQUFDeUQsQ0FBQUEsT0FBUUEsS0FBSzVDLElBQUksSUFBSTRDLEtBQUs1QyxJQUFJLENBQUN4RCxNQUFNLEdBQUc7WUFDbEZDLFdBQVdoQyxVQUFVNEksVUFBVSxDQUFDUixpQkFBaUJ6RyxPQUFPLENBQUMsT0FBTztZQUNoRWtILGdCQUFnQlQsaUJBQWlCckcsTUFBTTtZQUN2Q00sV0FBV0E7WUFDWFAsZUFBZUE7UUFDakI7SUFDRjtJQUVBLHdFQUF3RTtJQUN4RWdILHdCQUF3QnZGLEtBQUssRUFBRTtRQUM3QixNQUFNd0YsWUFBWTtZQUNoQkMsWUFBWSxDQUFDLENBQUN6RixNQUFNTCxPQUFPO1lBQzNCK0YsT0FBTzFGLE1BQU1tQyxFQUFFLEtBQUtDO1lBQ3BCdUQsY0FBYzNGLE1BQU1MLE9BQU8sR0FBSUwsTUFBTUMsT0FBTyxDQUFDUyxNQUFNTCxPQUFPLElBQUlLLE1BQU1MLE9BQU8sR0FBRztnQkFBQ0ssTUFBTUwsT0FBTzthQUFDLEdBQUksRUFBRTtZQUNuR2lELFlBQVk1QyxNQUFNbUMsRUFBRSxHQUFJN0MsTUFBTUMsT0FBTyxDQUFDUyxNQUFNbUMsRUFBRSxJQUFJbkMsTUFBTW1DLEVBQUUsR0FBRztnQkFBQ25DLE1BQU1tQyxFQUFFO2FBQUMsR0FBSSxFQUFFO1FBQy9FO1FBRUFwRixRQUFRQyxHQUFHLENBQUMsK0JBQStCd0k7UUFDM0MsT0FBT0E7SUFDVDtJQUVBLGdFQUFnRTtJQUNoRUksMEJBQTBCNUYsS0FBSyxFQUFFMEIsa0JBQWtCLEVBQUU7UUFDbkQsTUFBTW1FLFVBQVUsRUFBRTtRQUNsQixJQUFJaEosVUFBVTtRQUVkLHlFQUF5RTtRQUN6RSxzRUFBc0U7UUFDdEUscURBQXFEO1FBRXJELE9BQU9nSjtJQUNUO0lBRUEsbUVBQW1FO0lBQ25FaEQsa0JBQWtCN0MsS0FBSyxFQUFFO1FBQ3ZCLE1BQU00QyxhQUFhLEVBQUU7UUFFckIsSUFBSTVDLE1BQU1tQyxFQUFFLEtBQUtDLFdBQVc7WUFDMUIsSUFBSTlDLE1BQU1DLE9BQU8sQ0FBQ1MsTUFBTW1DLEVBQUUsR0FBRztnQkFDM0JuQyxNQUFNbUMsRUFBRSxDQUFDcEMsT0FBTyxDQUFDLENBQUN5RSxJQUFJdkU7b0JBQ3BCMkMsV0FBV1YsSUFBSSxDQUFDO3dCQUNkUSxNQUFNO3dCQUNORixVQUFVdkMsVUFBVSxJQUFJLFVBQVU7d0JBQ2xDaEIsU0FBU3VGO29CQUNYO2dCQUNGO1lBQ0YsT0FBTztnQkFDTDVCLFdBQVdWLElBQUksQ0FBQztvQkFDZFEsTUFBTTtvQkFDTkYsVUFBVTtvQkFDVnZELFNBQVNlLE1BQU1tQyxFQUFFO2dCQUNuQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPUztJQUNUO0lBRUEsMkRBQTJEO0lBQzNESSx1QkFBdUJGLE1BQU0sRUFBRTNELE9BQU8sRUFBRTtRQUN0QyxtREFBbUQ7UUFDbkQsT0FBUTJELE9BQU9KLElBQUk7WUFDakIsS0FBSztnQkFDSCxPQUFPLFFBQVEsNkNBQTZDO1lBQzlELEtBQUs7Z0JBQ0gsT0FBTyxNQUFNLDZDQUE2QztZQUM1RCxLQUFLO1lBQ0w7Z0JBQ0UsT0FBTyxNQUFNLHNCQUFzQjtRQUN2QztJQUNGO0lBRUEsd0VBQXdFO0lBQ3hFZSw4QkFBOEJxQyxZQUFZLEVBQUU3QyxTQUFTLEVBQUU5RCxPQUFPLEVBQUU7UUFDOUQsbUVBQW1FO1FBQ25FLElBQUkyRyxhQUFhM0QsRUFBRSxLQUFLQyxhQUFhYSxVQUFVZCxFQUFFLEtBQUtDLFdBQVc7WUFDL0QsT0FBTztRQUNUO1FBRUEsMkVBQTJFO1FBQzNFLE1BQU0yRCxtQkFBbUJELFlBQVksQ0FBQywwQkFBMEI7UUFDaEUsTUFBTUUsZ0JBQWdCL0MsU0FBUyxDQUFDLDBCQUEwQjtRQUUxRCx1RUFBdUU7UUFDdkUsSUFBSThDLG9CQUFvQkMsaUJBQWlCRCxxQkFBcUJDLGVBQWU7WUFDM0UsK0RBQStEO1lBQy9ELE1BQU1DLHNCQUFzQixJQUFJLENBQUNDLHVCQUF1QixDQUFDSCxrQkFBa0JDO1lBQzNFLE9BQU9DO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQSxnRUFBZ0U7SUFDaEVDLHdCQUF3QnhDLFlBQVksRUFBRUMsU0FBUyxFQUFFO1FBQy9DLE1BQU13QyxrQkFBa0I7WUFBQztZQUFTO1lBQVc7U0FBUztRQUN0RCxNQUFNQyxpQkFBaUI7WUFBQztZQUFRO1lBQVE7U0FBUztRQUVqRCxNQUFNQyxpQkFBaUJGLGdCQUFnQkcsSUFBSSxDQUFDQyxDQUFBQSxZQUMxQzdDLGFBQWE4QyxXQUFXLEdBQUcxRyxRQUFRLENBQUN5RztRQUN0QyxNQUFNRSxhQUFhTCxlQUFlRSxJQUFJLENBQUNDLENBQUFBLFlBQ3JDNUMsVUFBVTZDLFdBQVcsR0FBRzFHLFFBQVEsQ0FBQ3lHO1FBRW5DLE9BQU9GLGtCQUFrQkk7SUFDM0I7SUFFQSwrREFBK0Q7SUFDL0R0QixzQkFBc0J0RyxnQkFBZ0IsRUFBRTtRQUN0QyxNQUFNNkgsUUFBUTtZQUNaQyxVQUFVO1lBQ1ZDLFVBQVU7WUFDVkMsV0FBVztZQUNYQyxRQUFRLEVBQVMscUJBQXFCO1FBQ3hDO1FBRUFqSSxpQkFBaUJrQixPQUFPLENBQUM2RSxDQUFBQTtnQkFDbkJBO1lBQUosS0FBSUEsbUJBQUFBLEtBQUt4RSxVQUFVLGNBQWZ3RSx1Q0FBQUEsaUJBQWlCdEMsT0FBTyxFQUFFO2dCQUM1QixNQUFNQyxZQUFZcUMsS0FBS3hFLFVBQVUsQ0FBQ21DLFNBQVMsSUFBSTtnQkFDL0MsSUFBSW1FLE1BQU1LLGNBQWMsQ0FBQ3hFLFlBQVk7b0JBQ25DbUUsS0FBSyxDQUFDbkUsVUFBVTtnQkFDbEI7WUFDRjtRQUNGO1FBRUEsT0FBT21FO0lBQ1Q7SUFFQU0sbUNBQW1DaEgsS0FBSyxFQUFFO1FBQ3hDLE1BQU1JLGFBQWEsQ0FBQztRQUVwQix1Q0FBdUM7UUFDdkMsTUFBTTZHLGlCQUFpQjtZQUNyQjtZQUFpQjtZQUFnQjtZQUNqQztZQUFvQjtTQUNyQjtRQUVEQSxlQUFlbEgsT0FBTyxDQUFDbUgsQ0FBQUE7WUFDckIsSUFBSWxILEtBQUssQ0FBQ2tILEtBQUssRUFBRTtnQkFDZjlHLFdBQVdNLGFBQWEsR0FBR1YsS0FBSyxDQUFDa0gsS0FBSztZQUN4QztRQUNGO1FBRUEsbUNBQW1DO1FBQ25DOUcsV0FBV0ksUUFBUSxHQUFHL0QsVUFBVTBLLFlBQVksQ0FBQ25ILEtBQUssQ0FBQyxjQUFjO1FBRWpFLG1EQUFtRDtRQUNuRCxNQUFNb0gsYUFBYXBILEtBQUssQ0FBQyxZQUFZO1FBQ3JDSSxXQUFXaUgsT0FBTyxHQUFHLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNGLFlBQVloSCxXQUFXSSxRQUFRO1FBQzdFSixXQUFXbUgsV0FBVyxHQUFHLElBQUksQ0FBQ0Msb0JBQW9CLENBQUNKO1FBRW5ELHFDQUFxQztRQUNyQ2hILFdBQVdPLFNBQVMsR0FBR1gsS0FBSyxDQUFDLGNBQWM7UUFDM0NJLFdBQVdxSCxXQUFXLEdBQUd6SCxLQUFLLENBQUMsZ0JBQWdCO1FBQy9DSSxXQUFXUSxTQUFTLEdBQUdaLEtBQUssQ0FBQyxjQUFjO1FBRTNDLHlDQUF5QztRQUN6Q0ksV0FBV3NILFFBQVEsR0FBR2pMLFVBQVUwSyxZQUFZLENBQUNuSCxLQUFLLENBQUMsYUFBYTtRQUNoRUksV0FBV3VILGFBQWEsR0FBR2xMLFVBQVUwSyxZQUFZLENBQUNuSCxLQUFLLENBQUMsa0JBQWtCO1FBQzFFSSxXQUFXd0gsT0FBTyxHQUFHbkwsVUFBVTBLLFlBQVksQ0FBQ25ILEtBQUssQ0FBQyxZQUFZO1FBQzlESSxXQUFXeUgsZUFBZSxHQUFHcEwsVUFBVTBLLFlBQVksQ0FBQ25ILEtBQUssQ0FBQyxvQkFBb0IsS0FBSztRQUNuRkksV0FBVzBILGFBQWEsR0FBR3JMLFVBQVUwSyxZQUFZLENBQUNuSCxLQUFLLENBQUMsa0JBQWtCLEtBQUs7UUFFL0UsbUZBQW1GO1FBQ25GSSxXQUFXMkgsaUJBQWlCLEdBQUcvSCxLQUFLLENBQUMsb0JBQW9CLElBQUk7UUFDN0RJLFdBQVc0SCxZQUFZLEdBQUd2TCxVQUFVMEssWUFBWSxDQUFDbkgsS0FBSyxDQUFDLGlCQUFpQixLQUFLO1FBQzdFSSxXQUFXNkgsaUJBQWlCLEdBQUd4TCxVQUFVMEssWUFBWSxDQUFDbkgsS0FBSyxDQUFDLHNCQUFzQixLQUFLO1FBRXZGLGdEQUFnRDtRQUNoRCwyRkFBMkY7UUFDM0YsTUFBTWtJLG9CQUFvQmxJLEtBQUssQ0FBQyxrQkFBa0IsSUFBSUEsS0FBSyxDQUFDLGNBQWM7UUFDMUUsSUFBSWtJLG1CQUFtQjtZQUNyQjlILFdBQVdTLFNBQVMsR0FBR3FIO1FBQ3pCO1FBQ0E5SCxXQUFXK0gsVUFBVSxHQUFHMUwsVUFBVTBLLFlBQVksQ0FBQ25ILEtBQUssQ0FBQyxlQUFlO1FBQ3BFSSxXQUFXZ0ksV0FBVyxHQUFHM0wsVUFBVTBLLFlBQVksQ0FBQ25ILEtBQUssQ0FBQyxnQkFBZ0I7UUFDdEVJLFdBQVdpSSxlQUFlLEdBQUc1TCxVQUFVMEssWUFBWSxDQUFDbkgsS0FBSyxDQUFDLG9CQUFvQjtRQUM5RUksV0FBV2tJLFdBQVcsR0FBRzdMLFVBQVUwSyxZQUFZLENBQUNuSCxLQUFLLENBQUMsZ0JBQWdCO1FBQ3RFSSxXQUFXbUksVUFBVSxHQUFHOUwsVUFBVTBLLFlBQVksQ0FBQ25ILEtBQUssQ0FBQyxlQUFlO1FBRXBFLDBDQUEwQztRQUMxQ0ksV0FBV29JLG1CQUFtQixHQUFHLElBQUksQ0FBQ0MsNEJBQTRCLENBQUNySTtRQUVuRSxPQUFPQTtJQUNUO0lBRUEsMkRBQTJEO0lBQzNEa0gsb0JBQW9CRixVQUFVLEVBQUU1RyxRQUFRLEVBQUU7UUFDeEMsSUFBSSxDQUFDNEcsWUFBWSxPQUFPO1FBRXhCLHdCQUF3QjtRQUN4QixJQUFJQSxlQUFlLFVBQVVBLGVBQWUsUUFBUTtZQUNsRCxPQUFPNUcsV0FBV0EsV0FBVyxNQUFNLFFBQVEsd0NBQXdDO1FBQ3JGO1FBRUEscUNBQXFDO1FBQ3JDLE1BQU1rSSxpQkFBaUJqTSxVQUFVMEssWUFBWSxDQUFDQztRQUM5QyxJQUFJc0IsZ0JBQWdCO1lBQ2xCLE9BQU9BO1FBQ1Q7UUFFQSxrQ0FBa0M7UUFDbEMsSUFBSXRCLFdBQVd0SCxRQUFRLENBQUMsTUFBTTtZQUM1QixNQUFNNkksYUFBYWxJLFdBQVcyRyxXQUFXaEosT0FBTyxDQUFDLEtBQUs7WUFDdEQsT0FBT29DLFdBQVlBLFdBQVdtSSxhQUFhLE1BQU87UUFDcEQ7UUFFQSxPQUFPO0lBQ1Q7SUFFQSxnREFBZ0Q7SUFDaERuQixxQkFBcUJKLFVBQVUsRUFBRTtRQUMvQixJQUFJLENBQUNBLGNBQWNBLGVBQWUsVUFBVUEsZUFBZSxRQUFRO1lBQ2pFLE9BQU87UUFDVDtRQUVBLElBQUlBLFdBQVd0SCxRQUFRLENBQUMsTUFBTTtZQUM1QixPQUFPO1FBQ1Q7UUFFQSxJQUFJckQsVUFBVTBLLFlBQVksQ0FBQ0MsYUFBYTtZQUN0QyxPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQSx5REFBeUQ7SUFDekRxQiw2QkFBNkJySSxVQUFVLEVBQUU7UUFDdkMsTUFBTUksV0FBV0osV0FBV0ksUUFBUSxJQUFJO1FBQ3hDLE1BQU02RyxVQUFVakgsV0FBV2lILE9BQU87UUFFbEMsSUFBSUEsWUFBWSxRQUFRO1lBQ3RCLE9BQU8sS0FBSyxpQ0FBaUM7UUFDL0M7UUFFQSxJQUFJLE9BQU9BLFlBQVksVUFBVTtZQUMvQiwwQ0FBMEM7WUFDMUMsT0FBT0EsVUFBVTdHO1FBQ25CO1FBRUEsT0FBTyxLQUFLLFdBQVc7SUFDekI7SUFFQXRDLHNCQUFzQmIsU0FBUyxFQUFFO1FBQy9CLE1BQU0rQyxhQUFhO1lBQ2pCd0ksaUJBQWlCLEVBQUU7WUFDbkJDLGlCQUFpQixFQUFFO1lBQ25CQyxlQUFlLEVBQUU7UUFDbkI7UUFFQSxtQ0FBbUM7UUFDbkMsSUFBSXpMLFVBQVU2RyxtQkFBbUIsRUFBRTtZQUNqQyxNQUFNN0UsU0FBU0MsTUFBTUMsT0FBTyxDQUFDbEMsVUFBVTZHLG1CQUFtQixJQUFJN0csVUFBVTZHLG1CQUFtQixHQUFHO2dCQUFDN0csVUFBVTZHLG1CQUFtQjthQUFDO1lBRTdIN0UsT0FBT1UsT0FBTyxDQUFDQyxDQUFBQTtnQkFDYixNQUFNTSxlQUFlTixLQUFLLENBQUMsMEJBQTBCO2dCQUNyRCxJQUFJTSxnQkFBZ0IsQ0FBQ0YsV0FBV3dJLGVBQWUsQ0FBQzlJLFFBQVEsQ0FBQ1EsZUFBZTtvQkFDdEVGLFdBQVd3SSxlQUFlLENBQUMxRyxJQUFJLENBQUM1QjtnQkFDbEM7Z0JBRUEsbURBQW1EO2dCQUNuRCxJQUFJTixNQUFNWixtQkFBbUIsRUFBRTtvQkFDN0IsTUFBTTJKLGFBQWF6SixNQUFNQyxPQUFPLENBQUNTLE1BQU1aLG1CQUFtQixJQUFJWSxNQUFNWixtQkFBbUIsR0FBRzt3QkFBQ1ksTUFBTVosbUJBQW1CO3FCQUFDO29CQUVySDJKLFdBQVdoSixPQUFPLENBQUNpSixDQUFBQTt3QkFDakIsTUFBTUMsWUFBWUQsU0FBUyxDQUFDLDBCQUEwQjt3QkFDdEQsSUFBSUMsYUFBYSxDQUFDN0ksV0FBV3lJLGVBQWUsQ0FBQy9JLFFBQVEsQ0FBQ21KLFlBQVk7NEJBQ2hFN0ksV0FBV3lJLGVBQWUsQ0FBQzNHLElBQUksQ0FBQytHO3dCQUNsQztvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPN0k7SUFDVDtJQUVBLDZDQUE2QztJQUM3QzhJLHFCQUFxQjdMLFNBQVMsRUFBRTtRQUM5Qk4sUUFBUUMsR0FBRyxDQUFDO1FBQ1pELFFBQVFDLEdBQUcsQ0FBQyxlQUFlTyxPQUFPQyxJQUFJLENBQUNIO1FBRXZDLE1BQU04TCxzQkFBc0IsU0FBQ0M7Z0JBQUs3TSx3RUFBTztZQUN2QyxJQUFJLE9BQU82TSxRQUFRLFlBQVlBLFFBQVEsTUFBTTtnQkFDM0M3TCxPQUFPQyxJQUFJLENBQUM0TCxLQUFLckosT0FBTyxDQUFDMkUsQ0FBQUE7b0JBQ3ZCLElBQUlBLFFBQVEsdUJBQXVCO3dCQUNqQzNILFFBQVFDLEdBQUcsQ0FBQywrQ0FBMEMsT0FBTFQsTUFBSyxNQUFJNk0sR0FBRyxDQUFDMUUsSUFBSTt3QkFDbEUsTUFBTXJGLFNBQVNDLE1BQU1DLE9BQU8sQ0FBQzZKLEdBQUcsQ0FBQzFFLElBQUksSUFBSTBFLEdBQUcsQ0FBQzFFLElBQUksR0FBRzs0QkFBQzBFLEdBQUcsQ0FBQzFFLElBQUk7eUJBQUM7d0JBQzlEckYsT0FBT1UsT0FBTyxDQUFDLENBQUNDLE9BQU9DOzRCQUNyQmxELFFBQVFDLEdBQUcsQ0FBQyxXQUFxQixPQUFWaUQsUUFBUSxHQUFFLGlCQUMvQjFDLE9BQU9DLElBQUksQ0FBQ3dDLE9BQU9tQixNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLFVBQVUsQ0FBQzs0QkFFOUN0RSxRQUFRQyxHQUFHLENBQUMsV0FBcUIsT0FBVmlELFFBQVEsR0FBRSxnQkFBYztnQ0FDN0NvSixhQUFhckosS0FBSyxDQUFDLGdCQUFnQjtnQ0FDbkNzSixXQUFXdEosS0FBSyxDQUFDLGNBQWM7Z0NBQy9CdUosV0FBV3ZKLEtBQUssQ0FBQyxjQUFjOzRCQUNqQzt3QkFDRjtvQkFDRixPQUFPLElBQUksT0FBT29KLEdBQUcsQ0FBQzFFLElBQUksS0FBSyxVQUFVO3dCQUN2Q3lFLG9CQUFvQkMsR0FBRyxDQUFDMUUsSUFBSSxFQUFFLEdBQVdBLE9BQVJuSSxNQUFLLEtBQU8sT0FBSm1JO29CQUMzQztnQkFDRjtZQUNGO1FBQ0Y7UUFFQXlFLG9CQUFvQjlMO0lBQ3RCO0lBRUFtTSxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNuTCxPQUFPO0lBQ3JCO0lBRUFvTCxTQUFTdE0sT0FBTyxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxDQUFDa0IsT0FBTyxDQUFDbEIsUUFBUTtJQUM5QjtJQUVBdU0sZUFBZTtRQUNiLElBQUksQ0FBQ3JMLE9BQU8sR0FBRyxDQUFDO0lBQ2xCO0lBanNCQXNMLFlBQVloSSxXQUFXLENBQUU7UUFDdkIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ3RELE9BQU8sR0FBRyxDQUFDO0lBQ2xCO0FBK3JCRjtBQUVBdUwsT0FBT0MsT0FBTyxHQUFHbk4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3BhcnNlcnMvU3RvcnlQYXJzZXIuanM/NjhjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBJRE1MVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9JRE1MVXRpbHMnKTtcclxuXHJcbmNsYXNzIFN0b3J5UGFyc2VyIHtcclxuICBjb25zdHJ1Y3RvcihzdHlsZVBhcnNlcikge1xyXG4gICAgdGhpcy5zdHlsZVBhcnNlciA9IHN0eWxlUGFyc2VyO1xyXG4gICAgdGhpcy5zdG9yaWVzID0ge307XHJcbiAgfVxyXG5cclxuICBhc3luYyBwYXJzZVN0b3J5RmlsZShmaWxlTmFtZSwgY29udGVudCwgeG1sUGFyc2VyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TnSBQYXJzaW5nIHN0b3J5OiAke2ZpbGVOYW1lfWApO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSB4bWxQYXJzZXIucGFyc2UoY29udGVudCk7XHJcbiAgICAgIGNvbnN0IHN0b3J5SWQgPSBwYXRoLmJhc2VuYW1lKGZpbGVOYW1lLCAnLnhtbCcpO1xyXG4gICAgICBcclxuICAgICAgY29uc3Qgc3RvcnlEYXRhID0gcGFyc2VkLlN0b3J5IHx8IHBhcnNlZDtcclxuICAgICAgXHJcbiAgICAgIC8vIEFERCBUSEVTRSBTSU1QTEUgTE9HUyBGSVJTVDpcclxuICAgICAgY29uc29sZS5sb2coJz09PSBTSU1QTEUgREVCVUcgVEVTVCA9PT0nKTtcclxuICAgICAgY29uc29sZS5sb2coJ1N0b3J5IGZpbGUgbmFtZTonLCBmaWxlTmFtZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgc3Rvcnkga2V5czonLCBPYmplY3Qua2V5cyhzdG9yeURhdGEpKTtcclxuICAgICAgY29uc29sZS5sb2coJ1JhdyBzdG9yeSBkYXRhIHNhbXBsZTonLCBKU09OLnN0cmluZ2lmeShzdG9yeURhdGEsIG51bGwsIDIpLnN1YnN0cmluZygwLCA1MDApKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgZGV0YWlsZWQgc3RvcnkgaW5mb3JtYXRpb25cclxuICAgICAgY29uc3QgZGV0YWlsZWRTdG9yeSA9IHtcclxuICAgICAgICBzZWxmOiBzdG9yeURhdGFbJ0BfU2VsZiddLFxyXG4gICAgICAgIGFwcGxpZWRUT0NTdHlsZTogc3RvcnlEYXRhWydAX0FwcGxpZWRUT0NTdHlsZSddIHx8ICduJyxcclxuICAgICAgICB1c2VyVGV4dDogc3RvcnlEYXRhWydAX1VzZXJUZXh0J10gIT09IGZhbHNlLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEV4dHJhY3Qgc3RvcnkgY29udGVudCB3aXRoIGZvcm1hdHRpbmdcclxuICAgICAgICBjb250ZW50OiB0aGlzLmV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudChzdG9yeURhdGEpLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEV4dHJhY3QgdGV4dCBmb3JtYXR0aW5nXHJcbiAgICAgICAgdGV4dEZvcm1hdHRpbmc6IHRoaXMuZXh0cmFjdFRleHRGb3JtYXR0aW5nKHN0b3J5RGF0YSlcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNsZWFuU3RvcnlJZCA9IHN0b3J5SWQucmVwbGFjZSgnU3RvcnlfJywgJycpO1xyXG4gICAgICB0aGlzLnN0b3JpZXNbY2xlYW5TdG9yeUlkXSA9IGRldGFpbGVkU3Rvcnk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFbmhhbmNlZCBsb2dnaW5nIHRvIHNob3cgbGluZSBicmVha3NcclxuICAgICAgY29uc3QgeyBwbGFpblRleHQsIGxpbmVCcmVha0luZm8gfSA9IGRldGFpbGVkU3RvcnkuY29udGVudDtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBTdG9yeSAke3N0b3J5SWR9IHBhcnNlZDpgKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIC0gQ2hhcmFjdGVyczogJHtwbGFpblRleHQubGVuZ3RofWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBXb3JkczogJHtkZXRhaWxlZFN0b3J5LmNvbnRlbnQud29yZENvdW50fWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBMaW5lIGJyZWFrczogJHtsaW5lQnJlYWtJbmZvPy5saW5lQnJlYWtDb3VudCB8fCAwfWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBUZXh0IHByZXZpZXc6IFwiJHtwbGFpblRleHQuc3Vic3RyaW5nKDAsIDUwKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJyl9Li4uXCJgKTtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcGFyc2luZyBzdG9yeSAke2ZpbGVOYW1lfTpgLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlcGxhY2UgdGhlIGV4aXN0aW5nIGV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudCBtZXRob2Qgd2l0aCB0aGlzIGNvcnJlY3RlZCB2ZXJzaW9uXHJcbiAgZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50KHN0b3J5RGF0YSkge1xyXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcclxuICAgIGxldCBmb3JtYXR0ZWRDb250ZW50ID0gW107XHJcbiAgICBsZXQgdGV4dENvbG9yID0gbnVsbDtcclxuICAgIGxldCBkZWJ1Z0luZm8gPSBbXTtcclxuICAgIFxyXG4gICAgY29uc3QgZXh0cmFjdFRleHRSZWN1cnNpdmVseSA9IChlbGVtZW50LCBkZXB0aCA9IDAsIGNvbnRleHQgPSB7fSkgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29udGVudCArPSBlbGVtZW50O1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IFNwZWNpYWwgaGFuZGxpbmcgZm9yIENoYXJhY3RlclN0eWxlUmFuZ2Ugd2l0aCBzb3BoaXN0aWNhdGVkIEJyIGRldGVjdGlvblxyXG4gICAgICAgIGlmIChlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlKSA/IFxyXG4gICAgICAgICAgICBlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UgOiBbZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlXTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gU0lNUExJRklFRCBERUJVRzogSnVzdCBsb2cgcHJvYmxlbWF0aWMgdGV4dCByYW5nZXNcclxuICAgICAgICAgIGNvbnN0IGFsbFJhbmdlQ29udGVudCA9IHJhbmdlcy5tYXAociA9PiByLkNvbnRlbnQgPyBcclxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoci5Db250ZW50KSA/IHIuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhyLkNvbnRlbnQpKSA6ICcnKS5qb2luKCcnKTtcclxuICAgICAgICAgIGlmIChhbGxSYW5nZUNvbnRlbnQuaW5jbHVkZXMoJ3Bhdm9sdXB0dXNkYScpIHx8IGFsbFJhbmdlQ29udGVudC5pbmNsdWRlcygncGEnKSB8fCBhbGxSYW5nZUNvbnRlbnQuaW5jbHVkZXMoJ3ZvbHVwdHVzZGEnKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+aqCBGT1VORCBSQU5HRVMgV0lUSCBQUk9CTEVNQVRJQyBURVhUOicpO1xyXG4gICAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHJhbmdlLkNvbnRlbnQgPyBcclxuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhyYW5nZS5Db250ZW50KSkgOiAnJztcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgUmFuZ2UgJHtpbmRleH06IFwiJHtjb250ZW50fVwiYCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIHJhbmdlSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgLy8gRXh0cmFjdCBkaXJlY3QgZm9udCByZWZlcmVuY2VzIGZyb20gdGhlIFhNTCByYW5nZVxyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3RGb250UmVmID0gcmFuZ2VbJ0BfQXBwbGllZEZvbnQnXSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbJ0BfRm9udEZhbWlseSddIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVsnQF9Gb250J10gfHwgJyc7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0aW5nID0ge1xyXG4gICAgICAgICAgICAgIHBhcmFncmFwaFN0eWxlOiBlbGVtZW50WydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddIHx8IGNvbnRleHQuYXBwbGllZFN0eWxlIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgY2hhcmFjdGVyU3R5bGU6IHJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgZm9udFNpemU6IHJhbmdlWydAX1BvaW50U2l6ZSddID8gcGFyc2VGbG9hdChyYW5nZVsnQF9Qb2ludFNpemUnXSkgOiBudWxsLFxyXG4gICAgICAgICAgICAgIGZvbnRSZWZlcmVuY2U6IGRpcmVjdEZvbnRSZWYsXHJcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiByYW5nZVsnQF9GaWxsQ29sb3InXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgIGZvbnRTdHlsZTogcmFuZ2VbJ0BfRm9udFN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IEluaGVyaXQgcGFyYWdyYXBoIGFsaWdubWVudCBmcm9tIGNvbnRleHQgaWYgbm90IGV4cGxpY2l0bHkgc2V0XHJcbiAgICAgICAgICAgICAgYWxpZ25tZW50OiByYW5nZVsnQF9KdXN0aWZpY2F0aW9uJ10gfHwgcmFuZ2VbJ0BfQWxpZ25tZW50J10gfHwgY29udGV4dC5wYXJhZ3JhcGhBbGlnbm1lbnQgfHwgbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gREVCVUc6IExvZyBmb3JtYXR0aW5nIGV4dHJhY3Rpb24gZm9yIGFueSBzdHlsZWQgdGV4dCAoZ2VuZXJpYyBjaGVjaylcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VDb250ZW50ID0gcmFuZ2UuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhyYW5nZS5Db250ZW50KSkgOiAnJztcclxuICAgICAgICAgICAgY29uc3QgaGFzU3R5bGVJbmZvID0gcmFuZ2VbJ0BfRm9udFN0eWxlJ10gfHwgcmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFsnQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGUnXSB8fCByYW5nZVsnQF9BcHBsaWVkRm9udCddO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGhhc1N0eWxlSW5mbyAmJiByYW5nZUNvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflKcgU3RvcnlQYXJzZXIgLSBFeHRyYWN0aW5nIGZvcm1hdHRpbmcgZm9yIHJhbmdlOicsIEpTT04uc3RyaW5naWZ5KHJhbmdlQ29udGVudC5zdWJzdHJpbmcoMCwgMzApICsgJy4uLicpLCB7XHJcbiAgICAgICAgICAgICAgICByYXdSYW5nZUF0dHJpYnV0ZXM6IE9iamVjdC5rZXlzKHJhbmdlKS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoJ0BfJykpLFxyXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkRm9ybWF0dGluZzogZm9ybWF0dGluZyxcclxuICAgICAgICAgICAgICAgIGZvbnRTdHlsZUZyb21YTUw6IHJhbmdlWydAX0ZvbnRTdHlsZSddLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyU3R5bGVGcm9tWE1MOiByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSxcclxuICAgICAgICAgICAgICAgIHBhcmFncmFwaFN0eWxlRnJvbVhNTDogZWxlbWVudFsnQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGUnXVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEZvcm1hdHRpbmcgPSB0aGlzLnN0eWxlUGFyc2VyLnJlc29sdmVTdHlsZUZvcm1hdHRpbmcoZm9ybWF0dGluZyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBGSVhFRDogUHJvY2VzcyBjb250ZW50IHdpdGggcHJvcGVyIHNwYWNlIHByZXNlcnZhdGlvblxyXG4gICAgICAgICAgICBpZiAocmFuZ2UuQ29udGVudCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA/IHJhbmdlLkNvbnRlbnQgOiBbcmFuZ2UuQ29udGVudF07XHJcbiAgICAgICAgICAgICAgY29udGVudHMuZm9yRWFjaCgoY29udGVudEl0ZW0sIGNvbnRlbnRJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyhTdHJpbmcoY29udGVudEl0ZW0pKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gdGV4dDtcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHJlc29sdmVkRm9ybWF0dGluZ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogQ2hlY2sgZm9yIEJyIGVsZW1lbnRzIEFGVEVSIGVhY2ggY29udGVudCBpdGVtIHdpdGhpbiB0aGUgc2FtZSByYW5nZVxyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLkJyICE9PSB1bmRlZmluZWQgJiYgY29udGVudEluZGV4IDwgY29udGVudHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gJ1xcbic7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiAnbGluZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JldHdlZW5fY29udGVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdCciBlbGVtZW50IHdpdGhpbiByYW5nZSdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaW5lIGJyZWFrIGRldGVjdGVkIHdpdGhpbiBjb250ZW50JyxcclxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYENoYXJhY3RlclN0eWxlUmFuZ2VbJHtyYW5nZUluZGV4fV0sIGJldHdlZW4gY29udGVudFske2NvbnRlbnRJbmRleH1dIGFuZCBjb250ZW50WyR7Y29udGVudEluZGV4ICsgMX1dYCxcclxuICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgQnIgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgcmFuZ2VcclxuICAgICAgICAgICAgaWYgKHJhbmdlLkJyICE9PSB1bmRlZmluZWQgJiYgKCFyYW5nZS5Db250ZW50IHx8IEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudCkgPT09IGZhbHNlKSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGJyRWxlbWVudHMgPSB0aGlzLmV4dHJhY3RCckVsZW1lbnRzKHJhbmdlKTtcclxuICAgICAgICAgICAgICBickVsZW1lbnRzLmZvckVhY2goKGJySW5mbywgYnJJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUJyZWFrVGV4dCA9IHRoaXMuZGV0ZXJtaW5lTGluZUJyZWFrVHlwZShickluZm8sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0LFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7IFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiBickluZm8udHlwZSB8fCAnbGluZScsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGJySW5mby5wb3NpdGlvbiB8fCAnZW5kJyxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdCciBlbGVtZW50IGF0IGVuZCBvZiByYW5nZSdcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ0xpbmUgYnJlYWsgZGV0ZWN0ZWQgYXQgZW5kIG9mIHJhbmdlJyxcclxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBDaGFyYWN0ZXJTdHlsZVJhbmdlWyR7cmFuZ2VJbmRleH1dLCBCclske2JySW5kZXh9XWAsXHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogYnJJbmZvLnR5cGUgfHwgJ2xpbmUnLFxyXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBBZGQgc3BhY2UgYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGUgcmFuZ2VzIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBpZiAocmFuZ2VJbmRleCA8IHJhbmdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbmV4dFJhbmdlID0gcmFuZ2VzW3JhbmdlSW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBNb3JlIHJvYnVzdCBzcGFjZSBkZXRlY3Rpb25cclxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGNvbnRlbnQuc2xpY2UoLTEwKTsgLy8gQ2hlY2sgbGFzdCAxMCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSA9IC9cXHMkLy50ZXN0KGN1cnJlbnRUZXh0KTsgLy8gQW55IHdoaXRlc3BhY2UgYXQgZW5kXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgY29uc3QgbmV4dENvbnRlbnQgPSBuZXh0UmFuZ2UuQ29udGVudCA/IFxyXG4gICAgICAgICAgICAgICAgU3RyaW5nKEFycmF5LmlzQXJyYXkobmV4dFJhbmdlLkNvbnRlbnQpID8gbmV4dFJhbmdlLkNvbnRlbnRbMF0gOiBuZXh0UmFuZ2UuQ29udGVudCkgOiAnJztcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2UgPSAvXlxccy8udGVzdChuZXh0Q29udGVudCk7IC8vIEFueSB3aGl0ZXNwYWNlIGF0IHN0YXJ0XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gQUdHUkVTU0lWRSBGSVg6IEFkZCBzcGFjZSBiZXR3ZWVuIEFMTCByYW5nZXMgdW5sZXNzIGV4cGxpY2l0bHkgbm90IG5lZWRlZFxyXG4gICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBTcGFjZSA9IGN1cnJlbnRSYW5nZUVuZHNXaXRoU3BhY2UgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2UgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrKHJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbmV4dFJhbmdlLkNvbnRlbnQgfHwgLy8gU2tpcCBpZiBuZXh0IHJhbmdlIGhhcyBubyBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29udGVudC50cmltKCkgPT09ICcnOyAvLyBTa2lwIGlmIG5leHQgY29udGVudCBpcyBvbmx5IHdoaXRlc3BhY2VcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBpZiAoIXNob3VsZFNraXBTcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0eWxlID0gcmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFN0eWxlID0gbmV4dFJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddIHx8ICdub25lJztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhY2VUZXh0ID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBzcGFjZVRleHQ7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBzcGFjZVRleHQsXHJcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICBpc1NwYWNlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ2JldHdlZW4gY2hhcmFjdGVyIHN0eWxlIHJhbmdlcyAoYWdncmVzc2l2ZSknLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3R5bGVcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ1NwYWNlIGluc2VydGVkIGJldHdlZW4gY2hhcmFjdGVyIHN0eWxlcyAoYWdncmVzc2l2ZSknLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7cmFuZ2VJbmRleCArIDF9YCxcclxuICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICBuZXh0U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogJ0RlZmF1bHQgc3BhY2UgaW5zZXJ0aW9uIC0gd29yZHMgbGlrZWx5IHNwbGl0IGFjcm9zcyByYW5nZXMnLFxyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dEVuZDogY3VycmVudFRleHQuc2xpY2UoLTUpLFxyXG4gICAgICAgICAgICAgICAgICBuZXh0VGV4dFN0YXJ0OiBuZXh0Q29udGVudC5zbGljZSgwLCA1KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ1NwYWNlIGluc2VydGlvbiBza2lwcGVkJyxcclxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBCZXR3ZWVuIHJhbmdlcyAke3JhbmdlSW5kZXh9IGFuZCAke3JhbmdlSW5kZXggKyAxfWAsXHJcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSA/ICdDdXJyZW50IHJhbmdlIGVuZHMgd2l0aCBzcGFjZScgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSA/ICdOZXh0IHJhbmdlIHN0YXJ0cyB3aXRoIHNwYWNlJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIW5leHRSYW5nZS5Db250ZW50ID8gJ05leHQgcmFuZ2UgaGFzIG5vIGNvbnRlbnQnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENvbnRlbnQudHJpbSgpID09PSAnJyA/ICdOZXh0IGNvbnRlbnQgaXMgb25seSB3aGl0ZXNwYWNlJyA6ICdMaW5lIGJyZWFrIHdvdWxkIGJlIGluc2VydGVkJyxcclxuICAgICAgICAgICAgICAgICAgY3VycmVudFRleHRFbmQ6IGN1cnJlbnRUZXh0LnNsaWNlKC01KSxcclxuICAgICAgICAgICAgICAgICAgbmV4dFRleHRTdGFydDogbmV4dENvbnRlbnQuc2xpY2UoMCwgNSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBIYW5kbGUgZXhwbGljaXQgbGluZSBicmVha3MgYmV0d2VlbiByYW5nZXMgKGZvciBjYXNlcyB3aGVyZSBzaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayBpcyB0cnVlKVxyXG4gICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrKHJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbXBsaWNpdEJyZWFrID0gJ1xcbic7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGltcGxpY2l0QnJlYWs7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBpbXBsaWNpdEJyZWFrLFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdpbXBsaWNpdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnYmV0d2VlbiByYW5nZXMnXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdJbXBsaWNpdCBsaW5lIGJyZWFrJyxcclxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGBCZXR3ZWVuIHJhbmdlcyAke3JhbmdlSW5kZXh9IGFuZCAke3JhbmdlSW5kZXggKyAxfWBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm47IC8vIERvbid0IGNvbnRpbnVlIHByb2Nlc3NpbmcgdG8gYXZvaWQgZHVwbGljYXRpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IEhhbmRsZSBQYXJhZ3JhcGhTdHlsZVJhbmdlIHdpdGggY29udGV4dFxyXG4gICAgICAgIGlmIChlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5QYXJhZ3JhcGhTdHlsZVJhbmdlKSA/IFxyXG4gICAgICAgICAgICBlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2UgOiBbZWxlbWVudC5QYXJhZ3JhcGhTdHlsZVJhbmdlXTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhDb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgIC4uLmNvbnRleHQsXHJcbiAgICAgICAgICAgICAgcGFyYWdyYXBoSW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgIHRvdGFsUGFyYWdyYXBoczogcmFuZ2VzLmxlbmd0aCxcclxuICAgICAgICAgICAgICBhcHBsaWVkU3R5bGU6IHJhbmdlWydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddLFxyXG4gICAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogUGFzcyBkb3duIGRpcmVjdCBwYXJhZ3JhcGgtbGV2ZWwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgcGFyYWdyYXBoQWxpZ25tZW50OiByYW5nZVsnQF9KdXN0aWZpY2F0aW9uJ10gfHwgcmFuZ2VbJ0BfQWxpZ25tZW50J11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkocmFuZ2UsIGRlcHRoICsgMSwgcGFyYWdyYXBoQ29udGV4dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBZGQgcGFyYWdyYXBoIGJyZWFrIGJldHdlZW4gcGFyYWdyYXBocyAoYnV0IG5vdCBhZnRlciB0aGUgbGFzdCBvbmUpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHJhbmdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoQnJlYWsgPSAnXFxuJztcclxuICAgICAgICAgICAgICBjb250ZW50ICs9IHBhcmFncmFwaEJyZWFrO1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhZ3JhcGhCcmVhayxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiAncGFyYWdyYXBoJyxcclxuICAgICAgICAgICAgICAgICAgc291cmNlOiAnYmV0d2VlbiBwYXJhZ3JhcGhzJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHsgXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUGFyYWdyYXBoIGJyZWFrJywgXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogYGJldHdlZW4gcGFyYWdyYXBocyAke2luZGV4fSBhbmQgJHtpbmRleCArIDF9YCBcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEhhbmRsZSBkaXJlY3QgQ29udGVudCBlbGVtZW50cyAod2hlbiBub3QgaW5zaWRlIENoYXJhY3RlclN0eWxlUmFuZ2UpXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuQ29udGVudCAmJiAhZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlKSB7XHJcbiAgICAgICAgICBsZXQgdGV4dCA9IEFycmF5LmlzQXJyYXkoZWxlbWVudC5Db250ZW50KSA/IGVsZW1lbnQuQ29udGVudC5qb2luKCcnKSA6IFN0cmluZyhlbGVtZW50LkNvbnRlbnQpO1xyXG4gICAgICAgICAgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyh0ZXh0KTtcclxuICAgICAgICAgIGNvbnRlbnQgKz0gdGV4dDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ10gfHwgY29udGV4dC5hcHBsaWVkU3R5bGUgfHwgbnVsbCxcclxuICAgICAgICAgICAgY2hhcmFjdGVyU3R5bGU6IGVsZW1lbnRbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udFNpemU6IGVsZW1lbnRbJ0BfUG9pbnRTaXplJ10gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udEZhbWlseTogZWxlbWVudFsnQF9BcHBsaWVkRm9udCddIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogZWxlbWVudFsnQF9GaWxsQ29sb3InXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IEluaGVyaXQgcGFyYWdyYXBoIGFsaWdubWVudCBmcm9tIGNvbnRleHQgaWYgbm90IGV4cGxpY2l0bHkgc2V0XHJcbiAgICAgICAgICAgIGFsaWdubWVudDogZWxlbWVudFsnQF9KdXN0aWZpY2F0aW9uJ10gfHwgZWxlbWVudFsnQF9BbGlnbm1lbnQnXSB8fCBjb250ZXh0LnBhcmFncmFwaEFsaWdubWVudCB8fCBudWxsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IHJlc29sdmVkRm9ybWF0dGluZyA9IHRoaXMuc3R5bGVQYXJzZXIucmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IERpcmVjdCBCciBlbGVtZW50IGhhbmRsaW5nIChvdXRzaWRlIG9mIHJhbmdlcylcclxuICAgICAgICBpZiAoZWxlbWVudC5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zdCBickVsZW1lbnRzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkJyKSA/IGVsZW1lbnQuQnIgOiBbZWxlbWVudC5Ccl07XHJcbiAgICAgICAgICBickVsZW1lbnRzLmZvckVhY2goKGJyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gJ1xcbic7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0LFxyXG4gICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBicmVha1R5cGU6ICdleHBsaWNpdCcsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICdkaXJlY3QgQnIgZWxlbWVudCdcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0RpcmVjdCBCciBlbGVtZW50JyxcclxuICAgICAgICAgICAgICBsb2NhdGlvbjogYERpcmVjdCBlbGVtZW50LCBpbmRleCAke2luZGV4fWBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciBuZXN0ZWQgZWxlbWVudHNcclxuICAgICAgICBPYmplY3QuZW50cmllcyhlbGVtZW50KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJ0BfJykgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQ29udGVudCcgJiYgXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnQnInICYmIFxyXG4gICAgICAgICAgICAgIGtleSAhPT0gJ0NoYXJhY3RlclN0eWxlUmFuZ2UnICYmXHJcbiAgICAgICAgICAgICAga2V5ICE9PSAnUGFyYWdyYXBoU3R5bGVSYW5nZScpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChpdGVtID0+IGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkoaXRlbSwgZGVwdGggKyAxLCBjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBkZXB0aCA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgZXh0cmFjdFRleHRSZWN1cnNpdmVseSh2YWx1ZSwgZGVwdGggKyAxLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5KHN0b3J5RGF0YSk7XHJcbiAgICBcclxuICAgIC8vIEVOSEFOQ0VEOiBQcm9jZXNzIGFuZCBjbGVhbiB1cCB0aGUgY29udGVudCB3aXRoIHNvcGhpc3RpY2F0ZWQgbGluZSBicmVhayBwcmVzZXJ2YXRpb25cclxuICAgIGNvbnN0IHByb2Nlc3NlZENvbnRlbnQgPSBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmcoY29udGVudCk7XHJcbiAgICBcclxuICAgIC8vIERFQlVHOiBMb2cgc3BhY2UgcHJlc2VydmF0aW9uIHJlc3VsdHNcclxuICAgIGNvbnNvbGUubG9nKCfwn5OdIFRleHQgZXh0cmFjdGlvbiByZXN1bHRzOicpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gT3JpZ2luYWwgY29udGVudCBsZW5ndGg6JywgY29udGVudC5sZW5ndGgpO1xyXG4gICAgY29uc29sZS5sb2coJyAgIC0gUHJvY2Vzc2VkIGNvbnRlbnQgbGVuZ3RoOicsIHByb2Nlc3NlZENvbnRlbnQubGVuZ3RoKTtcclxuICAgIGNvbnNvbGUubG9nKCcgICAtIFNwYWNlIHByZXNlcnZhdGlvbiBldmVudHM6JywgZGVidWdJbmZvLmZpbHRlcihpbmZvID0+IGluZm8udHlwZS5pbmNsdWRlcygnU3BhY2UgaW5zZXJ0ZWQnKSkubGVuZ3RoKTtcclxuICAgIFxyXG4gICAgLy8gU1BFQ0lGSUMgREVCVUc6IENoZWNrIGZvciB0aGUgcHJvYmxlbWF0aWMgXCJwYXZvbHVwdHVzZGFcIiB0ZXh0IChzaW1wbGlmaWVkKVxyXG4gICAgaWYgKHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3Bhdm9sdXB0dXNkYScpIHx8IHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoJ3BhJykgJiYgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygndm9sdXB0dXNkYScpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qoIEZPVU5EIFBST0JMRU1BVElDIFRFWFQ6Jyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIENvbnRhaW5zIFwicGF2b2x1cHR1c2RhXCI6JywgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygncGF2b2x1cHR1c2RhJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBDb250YWlucyBcInBhIHZvbHVwdHVzZGFcIjonLCBwcm9jZXNzZWRDb250ZW50LmluY2x1ZGVzKCdwYSB2b2x1cHR1c2RhJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBGb3JtYXR0ZWRDb250ZW50IGJyZWFrZG93bjonLCBmb3JtYXR0ZWRDb250ZW50Lm1hcChpdGVtID0+IGl0ZW0udGV4dCkuam9pbignfCcpKTtcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIFxyXG4gICAgY29uc3QgbGluZUJyZWFrSW5mbyA9IHtcclxuICAgICAgaGFzTGluZUJyZWFrczogcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcygnXFxuJyksXHJcbiAgICAgIGxpbmVCcmVha0NvdW50OiAocHJvY2Vzc2VkQ29udGVudC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGgsXHJcbiAgICAgIGxpbmVCcmVha1R5cGVzOiB0aGlzLmFuYWx5emVMaW5lQnJlYWtUeXBlcyhmb3JtYXR0ZWRDb250ZW50KSxcclxuICAgICAgZGVidWdJbmZvOiBkZWJ1Z0luZm8sXHJcbiAgICAgIHNwYWNlUHJlc2VydmF0aW9uQ291bnQ6IGRlYnVnSW5mby5maWx0ZXIoaW5mbyA9PiBpbmZvLnR5cGUuaW5jbHVkZXMoJ1NwYWNlIGluc2VydGVkJykpLmxlbmd0aFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGxhaW5UZXh0OiBwcm9jZXNzZWRDb250ZW50LFxyXG4gICAgICBmb3JtYXR0ZWRDb250ZW50OiBmb3JtYXR0ZWRDb250ZW50LmZpbHRlcihpdGVtID0+IGl0ZW0udGV4dCAmJiBpdGVtLnRleHQubGVuZ3RoID4gMCksXHJcbiAgICAgIHdvcmRDb3VudDogSURNTFV0aWxzLmNvdW50V29yZHMocHJvY2Vzc2VkQ29udGVudC5yZXBsYWNlKC9cXG4vZywgJyAnKSksXHJcbiAgICAgIGNoYXJhY3RlckNvdW50OiBwcm9jZXNzZWRDb250ZW50Lmxlbmd0aCxcclxuICAgICAgdGV4dENvbG9yOiB0ZXh0Q29sb3IsXHJcbiAgICAgIGxpbmVCcmVha0luZm86IGxpbmVCcmVha0luZm9cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgdGhpcyBoZWxwZXIgbWV0aG9kIHRvIGJldHRlciBoYW5kbGUgbWl4ZWQgY29udGVudCBhbmQgQnIgZWxlbWVudHNcclxuICBhbmFseXplQ29udGVudFN0cnVjdHVyZShyYW5nZSkge1xyXG4gICAgY29uc3Qgc3RydWN0dXJlID0ge1xyXG4gICAgICBoYXNDb250ZW50OiAhIXJhbmdlLkNvbnRlbnQsXHJcbiAgICAgIGhhc0JyOiByYW5nZS5CciAhPT0gdW5kZWZpbmVkLFxyXG4gICAgICBjb250ZW50SXRlbXM6IHJhbmdlLkNvbnRlbnQgPyAoQXJyYXkuaXNBcnJheShyYW5nZS5Db250ZW50KSA/IHJhbmdlLkNvbnRlbnQgOiBbcmFuZ2UuQ29udGVudF0pIDogW10sXHJcbiAgICAgIGJyRWxlbWVudHM6IHJhbmdlLkJyID8gKEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpID8gcmFuZ2UuQnIgOiBbcmFuZ2UuQnJdKSA6IFtdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQ29udGVudCBzdHJ1Y3R1cmUgYW5hbHlzaXM6Jywgc3RydWN0dXJlKTtcclxuICAgIHJldHVybiBzdHJ1Y3R1cmU7XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBoZWxwZXIgZm9yIHByb2Nlc3NpbmcgaW50ZXJsZWF2ZWQgY29udGVudCBhbmQgYnJlYWtzXHJcbiAgcHJvY2Vzc0ludGVybGVhdmVkQ29udGVudChyYW5nZSwgcmVzb2x2ZWRGb3JtYXR0aW5nKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgXHJcbiAgICAvLyBUaGlzIG1ldGhvZCB3b3VsZCBuZWVkIGFjY2VzcyB0byB0aGUgYWN0dWFsIFhNTCBzdHJ1Y3R1cmUgdG8gZGV0ZXJtaW5lXHJcbiAgICAvLyB0aGUgZXhhY3Qgb3JkZXIgb2YgQ29udGVudCBhbmQgQnIgZWxlbWVudHMuIEZvciBub3csIHdlJ2xsIHVzZSB0aGUgXHJcbiAgICAvLyBhcHByb2FjaCBhYm92ZSB3aGljaCBoYW5kbGVzIHRoZSBtb3N0IGNvbW1vbiBjYXNlLlxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEhlbHBlciBtZXRob2QgdG8gZXh0cmFjdCBCciBlbGVtZW50cyB3aXRoIGNvbnRleHRcclxuICBleHRyYWN0QnJFbGVtZW50cyhyYW5nZSkge1xyXG4gICAgY29uc3QgYnJFbGVtZW50cyA9IFtdO1xyXG4gICAgXHJcbiAgICBpZiAocmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyYW5nZS5CcikpIHtcclxuICAgICAgICByYW5nZS5Cci5mb3JFYWNoKChiciwgaW5kZXgpID0+IHtcclxuICAgICAgICAgIGJyRWxlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgcG9zaXRpb246IGluZGV4ID09PSAwID8gJ3N0YXJ0JyA6ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICBlbGVtZW50OiBiclxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJFbGVtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJyxcclxuICAgICAgICAgIGVsZW1lbnQ6IHJhbmdlLkJyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGJyRWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGxpbmUgYnJlYWsgdHlwZVxyXG4gIGRldGVybWluZUxpbmVCcmVha1R5cGUoYnJJbmZvLCBjb250ZXh0KSB7XHJcbiAgICAvLyBEaWZmZXJlbnQgbGluZSBicmVhayBjaGFyYWN0ZXJzIGJhc2VkIG9uIGNvbnRleHRcclxuICAgIHN3aXRjaCAoYnJJbmZvLnR5cGUpIHtcclxuICAgICAgY2FzZSAncGFyYWdyYXBoJzpcclxuICAgICAgICByZXR1cm4gJ1xcblxcbic7IC8vIERvdWJsZSBsaW5lIGJyZWFrIGZvciBwYXJhZ3JhcGggc2VwYXJhdGlvblxyXG4gICAgICBjYXNlICdmb3JjZWQnOlxyXG4gICAgICAgIHJldHVybiAnXFxuJzsgLy8gRm9yY2VkIGxpbmUgYnJlYWsgKFNoaWZ0K0VudGVyIGVxdWl2YWxlbnQpXHJcbiAgICAgIGNhc2UgJ2xpbmUnOlxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAnXFxuJzsgLy8gU3RhbmRhcmQgbGluZSBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogRGV0ZXJtaW5lIGlmIGFuIGltcGxpY2l0IGxpbmUgYnJlYWsgc2hvdWxkIGJlIGluc2VydGVkXHJcbiAgc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsoY3VycmVudFJhbmdlLCBuZXh0UmFuZ2UsIGNvbnRleHQpIHtcclxuICAgIC8vIERvbid0IGluc2VydCBpbXBsaWNpdCBicmVha3MgaWYgZXhwbGljaXQgQnIgZWxlbWVudHMgYXJlIHByZXNlbnRcclxuICAgIGlmIChjdXJyZW50UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCB8fCBuZXh0UmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEluc2VydCBicmVha3MgYmV0d2VlbiBkaWZmZXJlbnQgY2hhcmFjdGVyIHN0eWxlcyBpbiBkaWZmZXJlbnQgcGFyYWdyYXBoc1xyXG4gICAgY29uc3QgY3VycmVudENoYXJTdHlsZSA9IGN1cnJlbnRSYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXTtcclxuICAgIGNvbnN0IG5leHRDaGFyU3R5bGUgPSBuZXh0UmFuZ2VbJ0BfQXBwbGllZENoYXJhY3RlclN0eWxlJ107XHJcbiAgICBcclxuICAgIC8vIElmIHdlJ3JlIGluIGEgY29udGV4dCB3aGVyZSBzdHlsZXMgY2hhbmdlIHNpZ25pZmljYW50bHksIGFkZCBhIGJyZWFrXHJcbiAgICBpZiAoY3VycmVudENoYXJTdHlsZSAmJiBuZXh0Q2hhclN0eWxlICYmIGN1cnJlbnRDaGFyU3R5bGUgIT09IG5leHRDaGFyU3R5bGUpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBtaWdodCBiZSBhIHRpdGxlL2hlYWRpbmcgZm9sbG93ZWQgYnkgYm9keSB0ZXh0XHJcbiAgICAgIGNvbnN0IHN0eWxlSW5kaWNhdGVzQnJlYWsgPSB0aGlzLnN0eWxlSW5kaWNhdGVzTGluZUJyZWFrKGN1cnJlbnRDaGFyU3R5bGUsIG5leHRDaGFyU3R5bGUpO1xyXG4gICAgICByZXR1cm4gc3R5bGVJbmRpY2F0ZXNCcmVhaztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogQW5hbHl6ZSBpZiBzdHlsZSBjaGFuZ2UgaW5kaWNhdGVzIGEgbGluZSBicmVha1xyXG4gIHN0eWxlSW5kaWNhdGVzTGluZUJyZWFrKGN1cnJlbnRTdHlsZSwgbmV4dFN0eWxlKSB7XHJcbiAgICBjb25zdCB0aXRsZUluZGljYXRvcnMgPSBbJ3RpdGxlJywgJ2hlYWRpbmcnLCAnaGVhZGVyJ107XHJcbiAgICBjb25zdCBib2R5SW5kaWNhdG9ycyA9IFsnYm9keScsICd0ZXh0JywgJ25vcm1hbCddO1xyXG4gICAgXHJcbiAgICBjb25zdCBjdXJyZW50SXNUaXRsZSA9IHRpdGxlSW5kaWNhdG9ycy5zb21lKGluZGljYXRvciA9PiBcclxuICAgICAgY3VycmVudFN0eWxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5kaWNhdG9yKSk7XHJcbiAgICBjb25zdCBuZXh0SXNCb2R5ID0gYm9keUluZGljYXRvcnMuc29tZShpbmRpY2F0b3IgPT4gXHJcbiAgICAgIG5leHRTdHlsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGluZGljYXRvcikpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gY3VycmVudElzVGl0bGUgJiYgbmV4dElzQm9keTtcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEFuYWx5emUgbGluZSBicmVhayB0eXBlcyBpbiBmb3JtYXR0ZWQgY29udGVudFxyXG4gIGFuYWx5emVMaW5lQnJlYWtUeXBlcyhmb3JtYXR0ZWRDb250ZW50KSB7XHJcbiAgICBjb25zdCB0eXBlcyA9IHtcclxuICAgICAgZXhwbGljaXQ6IDAsICAgICAgLy8gRnJvbSA8QnIvPiBlbGVtZW50c1xyXG4gICAgICBpbXBsaWNpdDogMCwgICAgICAvLyBJbmZlcnJlZCBmcm9tIHN0eWxlIGNoYW5nZXNcclxuICAgICAgcGFyYWdyYXBoOiAwLCAgICAgLy8gQmV0d2VlbiBwYXJhZ3JhcGhzXHJcbiAgICAgIGRpcmVjdDogMCAgICAgICAgLy8gRGlyZWN0IEJyIGVsZW1lbnRzXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmb3JtYXR0ZWRDb250ZW50LmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGlmIChpdGVtLmZvcm1hdHRpbmc/LmlzQnJlYWspIHtcclxuICAgICAgICBjb25zdCBicmVha1R5cGUgPSBpdGVtLmZvcm1hdHRpbmcuYnJlYWtUeXBlIHx8ICd1bmtub3duJztcclxuICAgICAgICBpZiAodHlwZXMuaGFzT3duUHJvcGVydHkoYnJlYWtUeXBlKSkge1xyXG4gICAgICAgICAgdHlwZXNbYnJlYWtUeXBlXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB0eXBlcztcclxuICB9XHJcblxyXG4gIGV4dHJhY3REZXRhaWxlZEZvcm1hdHRpbmdGcm9tUmFuZ2UocmFuZ2UpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7fTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBhbGwgcG9zc2libGUgZm9udCBhdHRyaWJ1dGVzXHJcbiAgICBjb25zdCBmb250QXR0cmlidXRlcyA9IFtcclxuICAgICAgJ0BfQXBwbGllZEZvbnQnLCAnQF9Gb250RmFtaWx5JywgJ0BfRm9udCcsIFxyXG4gICAgICAnQF9Qb3N0U2NyaXB0TmFtZScsICdAX0ZvbnROYW1lJ1xyXG4gICAgXTtcclxuICAgIFxyXG4gICAgZm9udEF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHtcclxuICAgICAgaWYgKHJhbmdlW2F0dHJdKSB7XHJcbiAgICAgICAgZm9ybWF0dGluZy5mb250UmVmZXJlbmNlID0gcmFuZ2VbYXR0cl07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGZvbnQgYW5kIHNpemUgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy5mb250U2l6ZSA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfUG9pbnRTaXplJ10pO1xyXG4gICAgXHJcbiAgICAvLyBFTkhBTkNFRDogRXh0cmFjdCBsZWFkaW5nIHdpdGggcHJvcGVyIHByb2Nlc3NpbmdcclxuICAgIGNvbnN0IHJhd0xlYWRpbmcgPSByYW5nZVsnQF9MZWFkaW5nJ107XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmcgPSB0aGlzLnByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9ybWF0dGluZy5mb250U2l6ZSk7XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmdUeXBlID0gdGhpcy5kZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBjb2xvciBhbmQgc3R5bGUgYXR0cmlidXRlc1xyXG4gICAgZm9ybWF0dGluZy5maWxsQ29sb3IgPSByYW5nZVsnQF9GaWxsQ29sb3InXTtcclxuICAgIGZvcm1hdHRpbmcuc3Ryb2tlQ29sb3IgPSByYW5nZVsnQF9TdHJva2VDb2xvciddO1xyXG4gICAgZm9ybWF0dGluZy5mb250U3R5bGUgPSByYW5nZVsnQF9Gb250U3R5bGUnXTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBhZHZhbmNlZCB0eXBvZ3JhcGh5IGF0dHJpYnV0ZXNcclxuICAgIGZvcm1hdHRpbmcudHJhY2tpbmcgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1RyYWNraW5nJ10pO1xyXG4gICAgZm9ybWF0dGluZy5iYXNlbGluZVNoaWZ0ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9CYXNlbGluZVNoaWZ0J10pO1xyXG4gICAgZm9ybWF0dGluZy5rZXJuaW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9LZXJuaW5nJ10pO1xyXG4gICAgZm9ybWF0dGluZy5ob3Jpem9udGFsU2NhbGUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0hvcml6b250YWxTY2FsZSddKSB8fCAxMDA7XHJcbiAgICBmb3JtYXR0aW5nLnZlcnRpY2FsU2NhbGUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1ZlcnRpY2FsU2NhbGUnXSkgfHwgMTAwO1xyXG4gICAgXHJcbiAgICAvLyBFTkhBTkNFRDogRXh0cmFjdCBJbkRlc2lnbi1zcGVjaWZpYyB0ZXh0IGxheW91dCBwcm9wZXJ0aWVzIGZvciBwcmVjaXNlIHJlbmRlcmluZ1xyXG4gICAgZm9ybWF0dGluZy5iYXNlbGluZUdyaWRBbGlnbiA9IHJhbmdlWydAX0FsaWduVG9CYXNlbGluZSddIHx8ICdOb25lJztcclxuICAgIGZvcm1hdHRpbmcuZHJvcENhcExpbmVzID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9Ecm9wQ2FwTGluZXMnXSkgfHwgMDtcclxuICAgIGZvcm1hdHRpbmcuZHJvcENhcENoYXJhY3RlcnMgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0Ryb3BDYXBDaGFyYWN0ZXJzJ10pIHx8IDA7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgcGFyYWdyYXBoLWxldmVsIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxyXG4gICAgLy8gQ1JJVElDQUwgRklYOiBPbmx5IHNldCBhbGlnbm1lbnQgaWYgZXhwbGljaXRseSBzcGVjaWZpZWQsIGFsbG93aW5nIHBhcmFncmFwaCBpbmhlcml0YW5jZVxyXG4gICAgY29uc3QgZXhwbGljaXRBbGlnbm1lbnQgPSByYW5nZVsnQF9KdXN0aWZpY2F0aW9uJ10gfHwgcmFuZ2VbJ0BfQWxpZ25tZW50J107XHJcbiAgICBpZiAoZXhwbGljaXRBbGlnbm1lbnQpIHtcclxuICAgICAgZm9ybWF0dGluZy5hbGlnbm1lbnQgPSBleHBsaWNpdEFsaWdubWVudDtcclxuICAgIH1cclxuICAgIGZvcm1hdHRpbmcubGVmdEluZGVudCA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbJ0BfTGVmdEluZGVudCddKTtcclxuICAgIGZvcm1hdHRpbmcucmlnaHRJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1JpZ2h0SW5kZW50J10pO1xyXG4gICAgZm9ybWF0dGluZy5maXJzdExpbmVJbmRlbnQgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX0ZpcnN0TGluZUluZGVudCddKTtcclxuICAgIGZvcm1hdHRpbmcuc3BhY2VCZWZvcmUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlWydAX1NwYWNlQmVmb3JlJ10pO1xyXG4gICAgZm9ybWF0dGluZy5zcGFjZUFmdGVyID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVsnQF9TcGFjZUFmdGVyJ10pO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1NcclxuICAgIGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodCA9IHRoaXMuY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChmb3JtYXR0aW5nKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmc7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IFByb2Nlc3MgbGVhZGluZyB2YWx1ZXMgd2l0aCBJbkRlc2lnbi1zcGVjaWZpYyBsb2dpY1xyXG4gIHByb2Nlc3NMZWFkaW5nVmFsdWUocmF3TGVhZGluZywgZm9udFNpemUpIHtcclxuICAgIGlmICghcmF3TGVhZGluZykgcmV0dXJuICdhdXRvJztcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIFwiYXV0b1wiIGxlYWRpbmdcclxuICAgIGlmIChyYXdMZWFkaW5nID09PSAnYXV0bycgfHwgcmF3TGVhZGluZyA9PT0gJ0F1dG8nKSB7XHJcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IGZvbnRTaXplICogMS4yIDogJ2F1dG8nOyAvLyBJbkRlc2lnbiBkZWZhdWx0IGF1dG8gbGVhZGluZyBpcyAxMjAlXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBudW1lcmljIGxlYWRpbmcgKGluIHBvaW50cylcclxuICAgIGNvbnN0IG51bWVyaWNMZWFkaW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYXdMZWFkaW5nKTtcclxuICAgIGlmIChudW1lcmljTGVhZGluZykge1xyXG4gICAgICByZXR1cm4gbnVtZXJpY0xlYWRpbmc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBwZXJjZW50YWdlLWJhc2VkIGxlYWRpbmdcclxuICAgIGlmIChyYXdMZWFkaW5nLmluY2x1ZGVzKCclJykpIHtcclxuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQocmF3TGVhZGluZy5yZXBsYWNlKCclJywgJycpKTtcclxuICAgICAgcmV0dXJuIGZvbnRTaXplID8gKGZvbnRTaXplICogcGVyY2VudGFnZSAvIDEwMCkgOiAnYXV0byc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAnYXV0byc7XHJcbiAgfVxyXG5cclxuICAvLyBORVc6IERldGVybWluZSB0aGUgdHlwZSBvZiBsZWFkaW5nIGJlaW5nIHVzZWRcclxuICBkZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcgfHwgcmF3TGVhZGluZyA9PT0gJ2F1dG8nIHx8IHJhd0xlYWRpbmcgPT09ICdBdXRvJykge1xyXG4gICAgICByZXR1cm4gJ2F1dG8nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcygnJScpKSB7XHJcbiAgICAgIHJldHVybiAncGVyY2VudGFnZSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhd0xlYWRpbmcpKSB7XHJcbiAgICAgIHJldHVybiAnYWJzb2x1dGUnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1MgcmVuZGVyaW5nXHJcbiAgY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChmb3JtYXR0aW5nKSB7XHJcbiAgICBjb25zdCBmb250U2l6ZSA9IGZvcm1hdHRpbmcuZm9udFNpemUgfHwgMTI7XHJcbiAgICBjb25zdCBsZWFkaW5nID0gZm9ybWF0dGluZy5sZWFkaW5nO1xyXG4gICAgXHJcbiAgICBpZiAobGVhZGluZyA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgIHJldHVybiAxLjI7IC8vIENTUyBsaW5lLWhlaWdodCByYXRpbyBmb3IgYXV0b1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodHlwZW9mIGxlYWRpbmcgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIC8vIENvbnZlcnQgcG9pbnRzIHRvIENTUyBsaW5lLWhlaWdodCByYXRpb1xyXG4gICAgICByZXR1cm4gbGVhZGluZyAvIGZvbnRTaXplO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gMS4yOyAvLyBGYWxsYmFja1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFRleHRGb3JtYXR0aW5nKHN0b3J5RGF0YSkge1xyXG4gICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgcGFyYWdyYXBoU3R5bGVzOiBbXSxcclxuICAgICAgY2hhcmFjdGVyU3R5bGVzOiBbXSxcclxuICAgICAgYXBwbGllZFN0eWxlczogW11cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgYXBwbGllZCBwYXJhZ3JhcGggc3R5bGVzXHJcbiAgICBpZiAoc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2UpIHtcclxuICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZSkgPyBzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZSA6IFtzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZV07XHJcbiAgICAgIFxyXG4gICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwbGllZFN0eWxlID0gcmFuZ2VbJ0BfQXBwbGllZFBhcmFncmFwaFN0eWxlJ107XHJcbiAgICAgICAgaWYgKGFwcGxpZWRTdHlsZSAmJiAhZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZXMuaW5jbHVkZXMoYXBwbGllZFN0eWxlKSkge1xyXG4gICAgICAgICAgZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZXMucHVzaChhcHBsaWVkU3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBFeHRyYWN0IGNoYXJhY3RlciBzdHlsZXMgd2l0aGluIHBhcmFncmFwaCByYW5nZXNcclxuICAgICAgICBpZiAocmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgY2hhclJhbmdlcyA9IEFycmF5LmlzQXJyYXkocmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZSkgPyByYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlIDogW3JhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjaGFyUmFuZ2VzLmZvckVhY2goY2hhclJhbmdlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hhclN0eWxlID0gY2hhclJhbmdlWydAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZSddO1xyXG4gICAgICAgICAgICBpZiAoY2hhclN0eWxlICYmICFmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlcy5pbmNsdWRlcyhjaGFyU3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZXMucHVzaChjaGFyU3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZm9ybWF0dGluZztcclxuICB9XHJcblxyXG4gIC8vIEFkZCB0aGlzIG1ldGhvZCB0byBkZWJ1ZyByYXcgc3RvcnkgY29udGVudFxyXG4gIGRlYnVnUmF3U3RvcnlDb250ZW50KHN0b3J5RGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coJ1xcbvCflI0gUkFXIFNUT1JZIENPTlRFTlQgREVCVUc6Jyk7XHJcbiAgICBjb25zb2xlLmxvZygnU3Rvcnkga2V5czonLCBPYmplY3Qua2V5cyhzdG9yeURhdGEpKTtcclxuICAgIFxyXG4gICAgY29uc3QgZmluZENoYXJhY3RlclJhbmdlcyA9IChvYmosIHBhdGggPSAnJykgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICBpZiAoa2V5ID09PSAnQ2hhcmFjdGVyU3R5bGVSYW5nZScpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfk50gRm91bmQgQ2hhcmFjdGVyU3R5bGVSYW5nZSBhdCAke3BhdGh9OmAsIG9ialtrZXldKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShvYmpba2V5XSkgPyBvYmpba2V5XSA6IFtvYmpba2V5XV07XHJcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBSYW5nZSAke2luZGV4ICsgMX0gYXR0cmlidXRlczpgLCBcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhbmdlKS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoJ0BfJykpXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBSYW5nZSAke2luZGV4ICsgMX0gZm9udCBpbmZvOmAsIHtcclxuICAgICAgICAgICAgICAgIEFwcGxpZWRGb250OiByYW5nZVsnQF9BcHBsaWVkRm9udCddLFxyXG4gICAgICAgICAgICAgICAgRm9udFN0eWxlOiByYW5nZVsnQF9Gb250U3R5bGUnXSxcclxuICAgICAgICAgICAgICAgIFBvaW50U2l6ZTogcmFuZ2VbJ0BfUG9pbnRTaXplJ11cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZmluZENoYXJhY3RlclJhbmdlcyhvYmpba2V5XSwgYCR7cGF0aH0uJHtrZXl9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZpbmRDaGFyYWN0ZXJSYW5nZXMoc3RvcnlEYXRhKTtcclxuICB9XHJcblxyXG4gIGdldFN0b3JpZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdG9yaWVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3Rvcnkoc3RvcnlJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3Rvcmllc1tzdG9yeUlkXTtcclxuICB9XHJcblxyXG4gIGNsZWFyU3RvcmllcygpIHtcclxuICAgIHRoaXMuc3RvcmllcyA9IHt9O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9yeVBhcnNlcjsgIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiSURNTFV0aWxzIiwiU3RvcnlQYXJzZXIiLCJwYXJzZVN0b3J5RmlsZSIsImZpbGVOYW1lIiwiY29udGVudCIsInhtbFBhcnNlciIsImNvbnNvbGUiLCJsb2ciLCJwYXJzZWQiLCJwYXJzZSIsInN0b3J5SWQiLCJiYXNlbmFtZSIsInN0b3J5RGF0YSIsIlN0b3J5IiwiT2JqZWN0Iiwia2V5cyIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdWJzdHJpbmciLCJkZXRhaWxlZFN0b3J5Iiwic2VsZiIsImFwcGxpZWRUT0NTdHlsZSIsInVzZXJUZXh0IiwiZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50IiwidGV4dEZvcm1hdHRpbmciLCJleHRyYWN0VGV4dEZvcm1hdHRpbmciLCJjbGVhblN0b3J5SWQiLCJyZXBsYWNlIiwic3RvcmllcyIsInBsYWluVGV4dCIsImxpbmVCcmVha0luZm8iLCJsZW5ndGgiLCJ3b3JkQ291bnQiLCJsaW5lQnJlYWtDb3VudCIsImVycm9yIiwibWVzc2FnZSIsImZvcm1hdHRlZENvbnRlbnQiLCJ0ZXh0Q29sb3IiLCJkZWJ1Z0luZm8iLCJleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5IiwiZWxlbWVudCIsImRlcHRoIiwiY29udGV4dCIsIkNoYXJhY3RlclN0eWxlUmFuZ2UiLCJyYW5nZXMiLCJBcnJheSIsImlzQXJyYXkiLCJhbGxSYW5nZUNvbnRlbnQiLCJtYXAiLCJyIiwiQ29udGVudCIsImpvaW4iLCJTdHJpbmciLCJpbmNsdWRlcyIsImZvckVhY2giLCJyYW5nZSIsImluZGV4IiwicmFuZ2VJbmRleCIsImRpcmVjdEZvbnRSZWYiLCJmb3JtYXR0aW5nIiwicGFyYWdyYXBoU3R5bGUiLCJhcHBsaWVkU3R5bGUiLCJjaGFyYWN0ZXJTdHlsZSIsImZvbnRTaXplIiwicGFyc2VGbG9hdCIsImZvbnRSZWZlcmVuY2UiLCJmaWxsQ29sb3IiLCJmb250U3R5bGUiLCJhbGlnbm1lbnQiLCJwYXJhZ3JhcGhBbGlnbm1lbnQiLCJyYW5nZUNvbnRlbnQiLCJoYXNTdHlsZUluZm8iLCJ0cmltIiwicmF3UmFuZ2VBdHRyaWJ1dGVzIiwiZmlsdGVyIiwiayIsInN0YXJ0c1dpdGgiLCJleHRyYWN0ZWRGb3JtYXR0aW5nIiwiZm9udFN0eWxlRnJvbVhNTCIsImNoYXJhY3RlclN0eWxlRnJvbVhNTCIsInBhcmFncmFwaFN0eWxlRnJvbVhNTCIsInJlc29sdmVkRm9ybWF0dGluZyIsInN0eWxlUGFyc2VyIiwicmVzb2x2ZVN0eWxlRm9ybWF0dGluZyIsImNvbnRlbnRzIiwiY29udGVudEl0ZW0iLCJjb250ZW50SW5kZXgiLCJ0ZXh0IiwiZGVjb2RlWE1MRW50aXRpZXMiLCJwdXNoIiwiQnIiLCJ1bmRlZmluZWQiLCJsaW5lQnJlYWtUZXh0IiwiaXNCcmVhayIsImJyZWFrVHlwZSIsInBvc2l0aW9uIiwic291cmNlIiwidHlwZSIsImxvY2F0aW9uIiwiYnJFbGVtZW50cyIsImV4dHJhY3RCckVsZW1lbnRzIiwiYnJJbmZvIiwiYnJJbmRleCIsImRldGVybWluZUxpbmVCcmVha1R5cGUiLCJuZXh0UmFuZ2UiLCJjdXJyZW50VGV4dCIsInNsaWNlIiwiY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZSIsInRlc3QiLCJuZXh0Q29udGVudCIsIm5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSIsInNob3VsZFNraXBTcGFjZSIsInNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrIiwiY3VycmVudFN0eWxlIiwibmV4dFN0eWxlIiwic3BhY2VUZXh0IiwiaXNTcGFjZSIsInJlYXNvbiIsImN1cnJlbnRUZXh0RW5kIiwibmV4dFRleHRTdGFydCIsImltcGxpY2l0QnJlYWsiLCJQYXJhZ3JhcGhTdHlsZVJhbmdlIiwicGFyYWdyYXBoQ29udGV4dCIsInBhcmFncmFwaEluZGV4IiwidG90YWxQYXJhZ3JhcGhzIiwicGFyYWdyYXBoQnJlYWsiLCJmb250RmFtaWx5IiwiYnIiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJpdGVtIiwicHJvY2Vzc2VkQ29udGVudCIsInNvcGhpc3RpY2F0ZWRMaW5lQnJlYWtQcm9jZXNzaW5nIiwiaW5mbyIsImhhc0xpbmVCcmVha3MiLCJtYXRjaCIsImxpbmVCcmVha1R5cGVzIiwiYW5hbHl6ZUxpbmVCcmVha1R5cGVzIiwic3BhY2VQcmVzZXJ2YXRpb25Db3VudCIsImNvdW50V29yZHMiLCJjaGFyYWN0ZXJDb3VudCIsImFuYWx5emVDb250ZW50U3RydWN0dXJlIiwic3RydWN0dXJlIiwiaGFzQ29udGVudCIsImhhc0JyIiwiY29udGVudEl0ZW1zIiwicHJvY2Vzc0ludGVybGVhdmVkQ29udGVudCIsInJlc3VsdHMiLCJjdXJyZW50UmFuZ2UiLCJjdXJyZW50Q2hhclN0eWxlIiwibmV4dENoYXJTdHlsZSIsInN0eWxlSW5kaWNhdGVzQnJlYWsiLCJzdHlsZUluZGljYXRlc0xpbmVCcmVhayIsInRpdGxlSW5kaWNhdG9ycyIsImJvZHlJbmRpY2F0b3JzIiwiY3VycmVudElzVGl0bGUiLCJzb21lIiwiaW5kaWNhdG9yIiwidG9Mb3dlckNhc2UiLCJuZXh0SXNCb2R5IiwidHlwZXMiLCJleHBsaWNpdCIsImltcGxpY2l0IiwicGFyYWdyYXBoIiwiZGlyZWN0IiwiaGFzT3duUHJvcGVydHkiLCJleHRyYWN0RGV0YWlsZWRGb3JtYXR0aW5nRnJvbVJhbmdlIiwiZm9udEF0dHJpYnV0ZXMiLCJhdHRyIiwicGFyc2VOdW1lcmljIiwicmF3TGVhZGluZyIsImxlYWRpbmciLCJwcm9jZXNzTGVhZGluZ1ZhbHVlIiwibGVhZGluZ1R5cGUiLCJkZXRlcm1pbmVMZWFkaW5nVHlwZSIsInN0cm9rZUNvbG9yIiwidHJhY2tpbmciLCJiYXNlbGluZVNoaWZ0Iiwia2VybmluZyIsImhvcml6b250YWxTY2FsZSIsInZlcnRpY2FsU2NhbGUiLCJiYXNlbGluZUdyaWRBbGlnbiIsImRyb3BDYXBMaW5lcyIsImRyb3BDYXBDaGFyYWN0ZXJzIiwiZXhwbGljaXRBbGlnbm1lbnQiLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJmaXJzdExpbmVJbmRlbnQiLCJzcGFjZUJlZm9yZSIsInNwYWNlQWZ0ZXIiLCJlZmZlY3RpdmVMaW5lSGVpZ2h0IiwiY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodCIsIm51bWVyaWNMZWFkaW5nIiwicGVyY2VudGFnZSIsInBhcmFncmFwaFN0eWxlcyIsImNoYXJhY3RlclN0eWxlcyIsImFwcGxpZWRTdHlsZXMiLCJjaGFyUmFuZ2VzIiwiY2hhclJhbmdlIiwiY2hhclN0eWxlIiwiZGVidWdSYXdTdG9yeUNvbnRlbnQiLCJmaW5kQ2hhcmFjdGVyUmFuZ2VzIiwib2JqIiwiQXBwbGllZEZvbnQiLCJGb250U3R5bGUiLCJQb2ludFNpemUiLCJnZXRTdG9yaWVzIiwiZ2V0U3RvcnkiLCJjbGVhclN0b3JpZXMiLCJjb25zdHJ1Y3RvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/parsers/StoryParser.js\n"));

/***/ })

});