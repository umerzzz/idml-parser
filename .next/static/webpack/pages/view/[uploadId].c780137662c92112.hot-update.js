"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Main processor\n\nconst IDMLProcessor = __webpack_require__(/*! ./IDMLProcessor */ \"./lib/IDMLProcessor.js\");\n// Individual modules for advanced usage\nconst IDMLXMLParser = __webpack_require__(/*! ./parsers/XMLParser */ \"./lib/parsers/XMLParser.js\");\nconst FileExtractor = __webpack_require__(/*! ./extractors/FileExtractor */ \"./lib/extractors/FileExtractor.js\");\nconst StyleParser = __webpack_require__(/*! ./parsers/StyleParser */ \"./lib/parsers/StyleParser.js\");\nconst StoryParser = __webpack_require__(/*! ./parsers/StoryParser */ \"./lib/parsers/StoryParser.js\");\nconst ElementParser = __webpack_require__(/*! ./parsers/ElementParser */ \"./lib/parsers/ElementParser.js\");\nconst DocumentParser = __webpack_require__(/*! ./parsers/DocumentParser */ \"./lib/parsers/DocumentParser.js\");\nconst ImageProcessor = __webpack_require__(/*! ./processors/ImageProcessor */ \"./lib/processors/ImageProcessor.js\");\nconst DebugAnalyzer = __webpack_require__(/*! ./debug/DebugAnalyzer */ \"./lib/debug/DebugAnalyzer.js\");\nconst IDMLUtils = __webpack_require__(/*! ./utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nconst ColorUtils = __webpack_require__(/*! ./utils/ColorUtils */ \"./lib/utils/ColorUtils.js\");\nconst InDesignTextMetrics = __webpack_require__(/*! ./utils/InDesignTextMetrics */ \"./lib/utils/InDesignTextMetrics.js\");\nmodule.exports = {\n    // Main class (default export)\n    IDMLProcessor,\n    // Individual modules\n    IDMLXMLParser,\n    FileExtractor,\n    StyleParser,\n    StoryParser,\n    ElementParser,\n    DocumentParser,\n    ImageProcessor,\n    DebugAnalyzer,\n    IDMLUtils,\n    ColorUtils,\n    // Convenience exports\n    parsers: {\n        XMLParser: IDMLXMLParser,\n        StyleParser,\n        StoryParser,\n        ElementParser,\n        DocumentParser\n    },\n    extractors: {\n        FileExtractor\n    },\n    processors: {\n        ImageProcessor\n    },\n    debug: {\n        DebugAnalyzer\n    },\n    utils: {\n        IDMLUtils,\n        ColorUtils\n    }\n};\n// Default export for backward compatibility\nmodule.exports[\"default\"] = IDMLProcessor;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCOztBQUNqQixNQUFNQSxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBRTlCLHdDQUF3QztBQUN4QyxNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1FLGdCQUFnQkYsbUJBQU9BLENBQUM7QUFDOUIsTUFBTUcsY0FBY0gsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUksY0FBY0osbUJBQU9BLENBQUM7QUFDNUIsTUFBTUssZ0JBQWdCTCxtQkFBT0EsQ0FBQztBQUM5QixNQUFNTSxpQkFBaUJOLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU1PLGlCQUFpQlAsbUJBQU9BLENBQUM7QUFDL0IsTUFBTVEsZ0JBQWdCUixtQkFBT0EsQ0FBQztBQUM5QixNQUFNUyxZQUFZVCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNVSxhQUFhVixtQkFBT0EsQ0FBQztBQUMzQixNQUFNVyxzQkFBc0JYLG1CQUFPQSxDQUFDO0FBRXBDWSxPQUFPQyxPQUFPLEdBQUc7SUFDZiw4QkFBOEI7SUFDOUJkO0lBRUEscUJBQXFCO0lBQ3JCRTtJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUVBLHNCQUFzQjtJQUN0QkksU0FBUztRQUNQQyxXQUFXZDtRQUNYRTtRQUNBQztRQUNBQztRQUNBQztJQUNGO0lBRUFVLFlBQVk7UUFDVmQ7SUFDRjtJQUVBZSxZQUFZO1FBQ1ZWO0lBQ0Y7SUFFQVcsT0FBTztRQUNMVjtJQUNGO0lBRUFXLE9BQU87UUFDTFY7UUFDQUM7SUFDRjtBQUNGO0FBRUEsNENBQTRDO0FBQzVDRSx5QkFBc0IsR0FBR2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2luZGV4LmpzP2E4ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTWFpbiBwcm9jZXNzb3JcclxuY29uc3QgSURNTFByb2Nlc3NvciA9IHJlcXVpcmUoJy4vSURNTFByb2Nlc3NvcicpO1xyXG5cclxuLy8gSW5kaXZpZHVhbCBtb2R1bGVzIGZvciBhZHZhbmNlZCB1c2FnZVxyXG5jb25zdCBJRE1MWE1MUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXJzL1hNTFBhcnNlcicpO1xyXG5jb25zdCBGaWxlRXh0cmFjdG9yID0gcmVxdWlyZSgnLi9leHRyYWN0b3JzL0ZpbGVFeHRyYWN0b3InKTtcclxuY29uc3QgU3R5bGVQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcnMvU3R5bGVQYXJzZXInKTtcclxuY29uc3QgU3RvcnlQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcnMvU3RvcnlQYXJzZXInKTtcclxuY29uc3QgRWxlbWVudFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2Vycy9FbGVtZW50UGFyc2VyJyk7XHJcbmNvbnN0IERvY3VtZW50UGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXJzL0RvY3VtZW50UGFyc2VyJyk7XHJcbmNvbnN0IEltYWdlUHJvY2Vzc29yID0gcmVxdWlyZSgnLi9wcm9jZXNzb3JzL0ltYWdlUHJvY2Vzc29yJyk7XHJcbmNvbnN0IERlYnVnQW5hbHl6ZXIgPSByZXF1aXJlKCcuL2RlYnVnL0RlYnVnQW5hbHl6ZXInKTtcclxuY29uc3QgSURNTFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9JRE1MVXRpbHMnKTtcclxuY29uc3QgQ29sb3JVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvQ29sb3JVdGlscycpO1xyXG5jb25zdCBJbkRlc2lnblRleHRNZXRyaWNzID0gcmVxdWlyZSgnLi91dGlscy9JbkRlc2lnblRleHRNZXRyaWNzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAvLyBNYWluIGNsYXNzIChkZWZhdWx0IGV4cG9ydClcclxuICBJRE1MUHJvY2Vzc29yLFxyXG4gIFxyXG4gIC8vIEluZGl2aWR1YWwgbW9kdWxlc1xyXG4gIElETUxYTUxQYXJzZXIsXHJcbiAgRmlsZUV4dHJhY3RvcixcclxuICBTdHlsZVBhcnNlcixcclxuICBTdG9yeVBhcnNlcixcclxuICBFbGVtZW50UGFyc2VyLFxyXG4gIERvY3VtZW50UGFyc2VyLFxyXG4gIEltYWdlUHJvY2Vzc29yLFxyXG4gIERlYnVnQW5hbHl6ZXIsXHJcbiAgSURNTFV0aWxzLFxyXG4gIENvbG9yVXRpbHMsXHJcbiAgXHJcbiAgLy8gQ29udmVuaWVuY2UgZXhwb3J0c1xyXG4gIHBhcnNlcnM6IHtcclxuICAgIFhNTFBhcnNlcjogSURNTFhNTFBhcnNlcixcclxuICAgIFN0eWxlUGFyc2VyLFxyXG4gICAgU3RvcnlQYXJzZXIsXHJcbiAgICBFbGVtZW50UGFyc2VyLFxyXG4gICAgRG9jdW1lbnRQYXJzZXJcclxuICB9LFxyXG4gIFxyXG4gIGV4dHJhY3RvcnM6IHtcclxuICAgIEZpbGVFeHRyYWN0b3JcclxuICB9LFxyXG4gIFxyXG4gIHByb2Nlc3NvcnM6IHtcclxuICAgIEltYWdlUHJvY2Vzc29yXHJcbiAgfSxcclxuICBcclxuICBkZWJ1Zzoge1xyXG4gICAgRGVidWdBbmFseXplclxyXG4gIH0sXHJcbiAgXHJcbiAgdXRpbHM6IHtcclxuICAgIElETUxVdGlscyxcclxuICAgIENvbG9yVXRpbHNcclxuICB9XHJcbn07XHJcblxyXG4vLyBEZWZhdWx0IGV4cG9ydCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gSURNTFByb2Nlc3NvcjsgIl0sIm5hbWVzIjpbIklETUxQcm9jZXNzb3IiLCJyZXF1aXJlIiwiSURNTFhNTFBhcnNlciIsIkZpbGVFeHRyYWN0b3IiLCJTdHlsZVBhcnNlciIsIlN0b3J5UGFyc2VyIiwiRWxlbWVudFBhcnNlciIsIkRvY3VtZW50UGFyc2VyIiwiSW1hZ2VQcm9jZXNzb3IiLCJEZWJ1Z0FuYWx5emVyIiwiSURNTFV0aWxzIiwiQ29sb3JVdGlscyIsIkluRGVzaWduVGV4dE1ldHJpY3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2VycyIsIlhNTFBhcnNlciIsImV4dHJhY3RvcnMiLCJwcm9jZXNzb3JzIiwiZGVidWciLCJ1dGlscyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/index.js\n"));

/***/ }),

/***/ "./lib/utils/InDesignTextMetrics.js":
/*!******************************************!*\
  !*** ./lib/utils/InDesignTextMetrics.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * InDesignTextMetrics.js - Precise text measurement utility for 1:1 InDesign compatibility\r\n * Handles font metrics, leading calculations, and text frame insets exactly like InDesign\r\n */ \nclass InDesignTextMetrics {\n    /**\r\n   * Calculate precise text frame dimensions including InDesign-specific insets\r\n   * @param {object} textFrame - The text frame element\r\n   * @param {object} textFramePrefs - Text frame preferences from InDesign\r\n   * @returns {object} Adjusted frame dimensions\r\n   */ static calculateTextFrameInsets(textFrame, textFramePrefs) {\n        var _textFramePrefs_insetSpacing, _textFramePrefs_textInsets, _textFramePrefs_insetSpacing1, _textFramePrefs_textInsets1, _textFramePrefs_insetSpacing2, _textFramePrefs_textInsets2, _textFramePrefs_insetSpacing3, _textFramePrefs_textInsets3;\n        // InDesign default text frame insets (in points)\n        const DEFAULT_INSETS = {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        };\n        // Extract insets from preferences if available\n        const insets = {\n            top: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing === void 0 ? void 0 : _textFramePrefs_insetSpacing.top) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets === void 0 ? void 0 : _textFramePrefs_textInsets.top) || DEFAULT_INSETS.top,\n            bottom: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing1 = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing1 === void 0 ? void 0 : _textFramePrefs_insetSpacing1.bottom) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets1 = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets1 === void 0 ? void 0 : _textFramePrefs_textInsets1.bottom) || DEFAULT_INSETS.bottom,\n            left: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing2 = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing2 === void 0 ? void 0 : _textFramePrefs_insetSpacing2.left) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets2 = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets2 === void 0 ? void 0 : _textFramePrefs_textInsets2.left) || DEFAULT_INSETS.left,\n            right: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing3 = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing3 === void 0 ? void 0 : _textFramePrefs_insetSpacing3.right) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets3 = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets3 === void 0 ? void 0 : _textFramePrefs_textInsets3.right) || DEFAULT_INSETS.right\n        };\n        // Calculate content area (available for text)\n        const contentArea = {\n            width: Math.max(0, textFrame.position.width - insets.left - insets.right),\n            height: Math.max(0, textFrame.position.height - insets.top - insets.bottom),\n            offsetX: insets.left,\n            offsetY: insets.top\n        };\n        return {\n            originalFrame: textFrame.position,\n            insets,\n            contentArea,\n            hasInsets: insets.top > 0 || insets.bottom > 0 || insets.left > 0 || insets.right > 0\n        };\n    }\n    /**\r\n   * Convert InDesign leading to precise CSS line-height\r\n   * @param {number|string} leading - InDesign leading value\r\n   * @param {number} fontSize - Font size in points\r\n   * @param {string} leadingType - Type of leading (auto, absolute, percentage)\r\n   * @returns {object} CSS-compatible line height info\r\n   */ static convertLeadingToCSS(leading, fontSize) {\n        let leadingType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"auto\";\n        let cssLineHeight;\n        let lineHeightPx;\n        switch(leadingType){\n            case \"auto\":\n                // InDesign auto leading is typically 120% of font size\n                cssLineHeight = 1.2;\n                lineHeightPx = fontSize * 1.2;\n                break;\n            case \"absolute\":\n                // Leading is in points, convert to line-height ratio\n                if (typeof leading === \"number\" && leading > 0) {\n                    cssLineHeight = Math.max(0.8, leading / fontSize);\n                    lineHeightPx = leading;\n                } else {\n                    cssLineHeight = 1.2;\n                    lineHeightPx = fontSize * 1.2;\n                }\n                break;\n            case \"percentage\":\n                // Leading is percentage-based\n                const percentage = parseFloat(leading) / 100;\n                cssLineHeight = Math.max(0.8, percentage);\n                lineHeightPx = fontSize * percentage;\n                break;\n            default:\n                cssLineHeight = 1.2;\n                lineHeightPx = fontSize * 1.2;\n        }\n        return {\n            cssLineHeight: Math.round(cssLineHeight * 1000) / 1000,\n            lineHeightPx: Math.round(lineHeightPx * 100) / 100,\n            leadingType,\n            originalLeading: leading\n        };\n    }\n    /**\r\n   * Calculate first baseline offset according to InDesign rules\r\n   * @param {string} firstBaselineOffset - InDesign first baseline offset setting\r\n   * @param {number} fontSize - Font size in points\r\n   * @param {number} lineHeight - Line height in points\r\n   * @returns {number} First baseline offset in points\r\n   */ static calculateFirstBaselineOffset(firstBaselineOffset, fontSize, lineHeight) {\n        switch(firstBaselineOffset){\n            case \"AscentOffset\":\n                // Text sits at natural ascent line (default)\n                return fontSize * 0.8; // Approximate ascent for most fonts\n            case \"CapHeightOffset\":\n                // Text sits at cap height\n                return fontSize * 0.7; // Approximate cap height for most fonts\n            case \"FixedHeight\":\n                // Custom fixed height - use line height\n                return lineHeight;\n            case \"XHeightOffset\":\n                // Text sits at x-height\n                return fontSize * 0.5; // Approximate x-height for most fonts\n            default:\n                return fontSize * 0.8; // Default to ascent offset\n        }\n    }\n    /**\r\n   * Measure text accurately using canvas with InDesign-specific adjustments\r\n   * @param {string} text - Text to measure\r\n   * @param {object} textStyles - Complete text styling object\r\n   * @param {object} frameMetrics - Text frame metrics\r\n   * @returns {object} Precise text measurement data\r\n   */ static measureTextPrecisely(text, textStyles, frameMetrics) {\n        if (!text || text.trim() === \"\") {\n            return {\n                textWidth: 0,\n                textHeight: 0,\n                lineCount: 0,\n                lines: [],\n                willOverflow: false,\n                fits: true\n            };\n        }\n        // Create canvas for measurement\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        // Set font with proper fallbacks\n        const fontSize = parseFloat(textStyles.fontSize) || 12;\n        const fontFamily = textStyles.fontFamily || \"Arial, sans-serif\";\n        const fontWeight = textStyles.fontWeight || \"normal\";\n        const fontStyle = textStyles.fontStyle || \"normal\";\n        ctx.font = \"\".concat(fontStyle, \" \").concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n        // Calculate effective content width accounting for tracking\n        const tracking = textStyles.tracking || 0;\n        const trackingAdjustment = tracking * fontSize / 1000; // Convert em to px\n        const effectiveWidth = frameMetrics.contentArea.width - Math.abs(trackingAdjustment);\n        // Split text into words for accurate wrapping\n        const words = text.replace(/\\s+/g, \" \").trim().split(\" \");\n        const lines = [];\n        let currentLine = \"\";\n        let currentLineWidth = 0;\n        // Measure space width once\n        const spaceWidth = ctx.measureText(\" \").width + trackingAdjustment;\n        for(let i = 0; i < words.length; i++){\n            const word = words[i];\n            const wordWidth = ctx.measureText(word).width + (word.length - 1) * trackingAdjustment;\n            // Check if word fits on current line\n            const wordWithSpaceWidth = currentLine ? wordWidth + spaceWidth : wordWidth;\n            if (currentLine && currentLineWidth + wordWithSpaceWidth > effectiveWidth) {\n                // Word doesn't fit, start new line\n                lines.push({\n                    text: currentLine,\n                    width: currentLineWidth\n                });\n                currentLine = word;\n                currentLineWidth = wordWidth;\n            } else {\n                // Word fits, add to current line\n                if (currentLine) {\n                    currentLine += \" \" + word;\n                    currentLineWidth += wordWithSpaceWidth;\n                } else {\n                    currentLine = word;\n                    currentLineWidth = wordWidth;\n                }\n            }\n        }\n        // Add the last line\n        if (currentLine) {\n            lines.push({\n                text: currentLine,\n                width: currentLineWidth\n            });\n        }\n        // Calculate text height using InDesign-accurate leading\n        const lineHeightInfo = this.convertLeadingToCSS(textStyles.leading, fontSize, textStyles.leadingType);\n        const lineCount = Math.max(1, lines.length);\n        const firstBaselineOffset = this.calculateFirstBaselineOffset(textStyles.firstBaselineOffset || \"AscentOffset\", fontSize, lineHeightInfo.lineHeightPx);\n        // Calculate total text height including first baseline offset\n        const textHeight = firstBaselineOffset + (lineCount - 1) * lineHeightInfo.lineHeightPx;\n        // Check if text overflows the available height\n        const willOverflow = textHeight > frameMetrics.contentArea.height;\n        return {\n            textWidth: Math.max(...lines.map((line)=>line.width)),\n            textHeight: Math.round(textHeight * 100) / 100,\n            lineCount,\n            lines,\n            lineHeightPx: lineHeightInfo.lineHeightPx,\n            firstBaselineOffset,\n            willOverflow,\n            fits: !willOverflow,\n            availableHeight: frameMetrics.contentArea.height,\n            overflowAmount: willOverflow ? textHeight - frameMetrics.contentArea.height : 0,\n            // Detailed metrics for debugging\n            metrics: {\n                fontSize,\n                leading: textStyles.leading,\n                leadingType: textStyles.leadingType,\n                effectiveWidth,\n                tracking: trackingAdjustment,\n                spaceWidth\n            }\n        };\n    }\n    /**\r\n   * Calculate optimal font size to prevent overflow while maintaining design integrity\r\n   * @param {object} textMeasurement - Result from measureTextPrecisely\r\n   * @param {object} originalStyles - Original text styles\r\n   * @param {number} maxReduction - Maximum font size reduction allowed (0.0-1.0)\r\n   * @returns {object} Adjusted text styles or null if no adjustment needed\r\n   */ static calculateOptimalFontSize(textMeasurement, originalStyles) {\n        let maxReduction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.15;\n        if (!textMeasurement.willOverflow) {\n            return null; // No adjustment needed\n        }\n        const originalFontSize = parseFloat(originalStyles.fontSize) || 12;\n        const overflowRatio = textMeasurement.textHeight / textMeasurement.availableHeight;\n        // Calculate required scale factor\n        let scaleFactor = 1 / overflowRatio;\n        // Apply maximum reduction limit to preserve design integrity\n        const minAllowedScale = 1 - maxReduction;\n        scaleFactor = Math.max(minAllowedScale, scaleFactor);\n        const newFontSize = originalFontSize * scaleFactor;\n        // If we can't fix it with the allowed reduction, return proportional adjustment\n        if (scaleFactor === minAllowedScale && overflowRatio > 1.2) {\n            return {\n                adjustedStyles: {\n                    ...originalStyles,\n                    fontSize: \"\".concat(Math.round(newFontSize * 100) / 100, \"px\"),\n                    // Also adjust line-height proportionally for severe overflows\n                    lineHeight: Math.max(0.9, parseFloat(originalStyles.lineHeight || \"1.2\") * scaleFactor)\n                },\n                adjustmentType: \"font_size_reduced\",\n                scaleFactor,\n                originalFontSize,\n                newFontSize: Math.round(newFontSize * 100) / 100,\n                stillOverflows: true\n            };\n        }\n        return {\n            adjustedStyles: {\n                ...originalStyles,\n                fontSize: \"\".concat(Math.round(newFontSize * 100) / 100, \"px\")\n            },\n            adjustmentType: \"font_size_reduced\",\n            scaleFactor,\n            originalFontSize,\n            newFontSize: Math.round(newFontSize * 100) / 100,\n            stillOverflows: false\n        };\n    }\n    /**\r\n   * Generate CSS styles with InDesign-accurate typography\r\n   * @param {object} inDesignFormatting - Formatting object from InDesign\r\n   * @param {object} frameMetrics - Text frame metrics\r\n   * @returns {object} CSS styles optimized for InDesign compatibility\r\n   */ static generateInDesignCSS(inDesignFormatting, frameMetrics) {\n        const fontSize = inDesignFormatting.fontSize || 12;\n        // Convert leading to CSS\n        const lineHeightInfo = this.convertLeadingToCSS(inDesignFormatting.leading, fontSize, inDesignFormatting.leadingType);\n        // Calculate first baseline offset for positioning\n        const firstBaselineOffset = this.calculateFirstBaselineOffset(inDesignFormatting.firstBaselineOffset || \"AscentOffset\", fontSize, lineHeightInfo.lineHeightPx);\n        return {\n            // Typography\n            fontSize: \"\".concat(fontSize, \"px\"),\n            lineHeight: lineHeightInfo.cssLineHeight,\n            fontFamily: inDesignFormatting.fontFamily || \"Arial, sans-serif\",\n            fontWeight: inDesignFormatting.fontWeight || \"normal\",\n            fontStyle: inDesignFormatting.fontStyle || \"normal\",\n            // Advanced typography\n            letterSpacing: inDesignFormatting.tracking ? \"\".concat(inDesignFormatting.tracking / 1000, \"em\") : \"normal\",\n            textAlign: inDesignFormatting.textAlign || \"left\",\n            color: inDesignFormatting.color || \"black\",\n            // Layout and positioning\n            padding: \"\".concat(firstBaselineOffset, \"px \").concat(frameMetrics.insets.right, \"px \").concat(frameMetrics.insets.bottom, \"px \").concat(frameMetrics.insets.left, \"px\"),\n            margin: 0,\n            // Overflow control\n            width: \"\".concat(frameMetrics.contentArea.width, \"px\"),\n            height: \"\".concat(frameMetrics.contentArea.height, \"px\"),\n            overflow: \"hidden\",\n            boxSizing: \"border-box\",\n            // Text layout optimization\n            whiteSpace: \"normal\",\n            wordWrap: \"break-word\",\n            overflowWrap: \"break-word\",\n            wordBreak: \"normal\",\n            // InDesign-specific adjustments\n            position: \"relative\",\n            top: frameMetrics.hasInsets ? \"\".concat(frameMetrics.offsetY, \"px\") : \"0\",\n            left: frameMetrics.hasInsets ? \"\".concat(frameMetrics.offsetX, \"px\") : \"0\",\n            // Debug info (can be removed in production)\n            \"--indesign-leading\": inDesignFormatting.leading,\n            \"--indesign-leading-type\": inDesignFormatting.leadingType,\n            \"--css-line-height\": lineHeightInfo.cssLineHeight,\n            \"--first-baseline-offset\": \"\".concat(firstBaselineOffset, \"px\")\n        };\n    }\n}\n// Export for use in other modules\nif ( true && module.exports) {\n    module.exports = InDesignTextMetrics;\n} else if (true) {\n    window.InDesignTextMetrics = InDesignTextMetrics;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGFBQWE3QixNQUFNLENBQUNILE1BQU0sRUFBQyxPQUE4QixPQUF6QmdDLGFBQWE3QixNQUFNLENBQUNGLElBQUksRUFBQztZQUM3SHlGLFFBQVE7WUFFUixtQkFBbUI7WUFDbkJuRixPQUFPLEdBQWtDLE9BQS9CeUIsYUFBYTFCLFdBQVcsQ0FBQ0MsS0FBSyxFQUFDO1lBQ3pDSSxRQUFRLEdBQW1DLE9BQWhDcUIsYUFBYTFCLFdBQVcsQ0FBQ0ssTUFBTSxFQUFDO1lBQzNDZ0YsVUFBVTtZQUNWQyxXQUFXO1lBRVgsMkJBQTJCO1lBQzNCQyxZQUFZO1lBQ1pDLFVBQVU7WUFDVkMsY0FBYztZQUNkQyxXQUFXO1lBRVgsZ0NBQWdDO1lBQ2hDdEYsVUFBVTtZQUNWWCxLQUFLaUMsYUFBYWpCLFNBQVMsR0FBRyxHQUF3QixPQUFyQmlCLGFBQWFuQixPQUFPLEVBQUMsUUFBTTtZQUM1RFosTUFBTStCLGFBQWFqQixTQUFTLEdBQUcsR0FBd0IsT0FBckJpQixhQUFhcEIsT0FBTyxFQUFDLFFBQU07WUFFN0QsNENBQTRDO1lBQzVDLHNCQUFzQnlFLG1CQUFtQnBFLE9BQU87WUFDaEQsMkJBQTJCb0UsbUJBQW1CbEUsV0FBVztZQUN6RCxxQkFBcUIrQyxlQUFlOUMsYUFBYTtZQUNqRCwyQkFBMkIsR0FBdUIsT0FBcEJPLHFCQUFvQjtRQUNwRDtJQUNGO0FBQ0Y7QUFFQSxrQ0FBa0M7QUFDbEMsSUFBSSxLQUFrQixJQUFlc0UsT0FBT0MsT0FBTyxFQUFFO0lBQ25ERCxPQUFPQyxPQUFPLEdBQUd4RztBQUNuQixPQUFPLElBQUksSUFBa0IsRUFBYTtJQUN4Q3lHLE9BQU96RyxtQkFBbUIsR0FBR0E7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3V0aWxzL0luRGVzaWduVGV4dE1ldHJpY3MuanM/N2U1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogSW5EZXNpZ25UZXh0TWV0cmljcy5qcyAtIFByZWNpc2UgdGV4dCBtZWFzdXJlbWVudCB1dGlsaXR5IGZvciAxOjEgSW5EZXNpZ24gY29tcGF0aWJpbGl0eVxyXG4gKiBIYW5kbGVzIGZvbnQgbWV0cmljcywgbGVhZGluZyBjYWxjdWxhdGlvbnMsIGFuZCB0ZXh0IGZyYW1lIGluc2V0cyBleGFjdGx5IGxpa2UgSW5EZXNpZ25cclxuICovXHJcblxyXG5jbGFzcyBJbkRlc2lnblRleHRNZXRyaWNzIHtcclxuICBcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgcHJlY2lzZSB0ZXh0IGZyYW1lIGRpbWVuc2lvbnMgaW5jbHVkaW5nIEluRGVzaWduLXNwZWNpZmljIGluc2V0c1xyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0ZXh0RnJhbWUgLSBUaGUgdGV4dCBmcmFtZSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHRleHRGcmFtZVByZWZzIC0gVGV4dCBmcmFtZSBwcmVmZXJlbmNlcyBmcm9tIEluRGVzaWduXHJcbiAgICogQHJldHVybnMge29iamVjdH0gQWRqdXN0ZWQgZnJhbWUgZGltZW5zaW9uc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjYWxjdWxhdGVUZXh0RnJhbWVJbnNldHModGV4dEZyYW1lLCB0ZXh0RnJhbWVQcmVmcykge1xyXG4gICAgLy8gSW5EZXNpZ24gZGVmYXVsdCB0ZXh0IGZyYW1lIGluc2V0cyAoaW4gcG9pbnRzKVxyXG4gICAgY29uc3QgREVGQVVMVF9JTlNFVFMgPSB7XHJcbiAgICAgIHRvcDogMCxcclxuICAgICAgYm90dG9tOiAwLFxyXG4gICAgICBsZWZ0OiAwLFxyXG4gICAgICByaWdodDogMFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBpbnNldHMgZnJvbSBwcmVmZXJlbmNlcyBpZiBhdmFpbGFibGVcclxuICAgIGNvbnN0IGluc2V0cyA9IHtcclxuICAgICAgdG9wOiB0ZXh0RnJhbWVQcmVmcz8uaW5zZXRTcGFjaW5nPy50b3AgfHwgdGV4dEZyYW1lUHJlZnM/LnRleHRJbnNldHM/LnRvcCB8fCBERUZBVUxUX0lOU0VUUy50b3AsXHJcbiAgICAgIGJvdHRvbTogdGV4dEZyYW1lUHJlZnM/Lmluc2V0U3BhY2luZz8uYm90dG9tIHx8IHRleHRGcmFtZVByZWZzPy50ZXh0SW5zZXRzPy5ib3R0b20gfHwgREVGQVVMVF9JTlNFVFMuYm90dG9tLFxyXG4gICAgICBsZWZ0OiB0ZXh0RnJhbWVQcmVmcz8uaW5zZXRTcGFjaW5nPy5sZWZ0IHx8IHRleHRGcmFtZVByZWZzPy50ZXh0SW5zZXRzPy5sZWZ0IHx8IERFRkFVTFRfSU5TRVRTLmxlZnQsXHJcbiAgICAgIHJpZ2h0OiB0ZXh0RnJhbWVQcmVmcz8uaW5zZXRTcGFjaW5nPy5yaWdodCB8fCB0ZXh0RnJhbWVQcmVmcz8udGV4dEluc2V0cz8ucmlnaHQgfHwgREVGQVVMVF9JTlNFVFMucmlnaHRcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBjb250ZW50IGFyZWEgKGF2YWlsYWJsZSBmb3IgdGV4dClcclxuICAgIGNvbnN0IGNvbnRlbnRBcmVhID0ge1xyXG4gICAgICB3aWR0aDogTWF0aC5tYXgoMCwgdGV4dEZyYW1lLnBvc2l0aW9uLndpZHRoIC0gaW5zZXRzLmxlZnQgLSBpbnNldHMucmlnaHQpLFxyXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIHRleHRGcmFtZS5wb3NpdGlvbi5oZWlnaHQgLSBpbnNldHMudG9wIC0gaW5zZXRzLmJvdHRvbSksXHJcbiAgICAgIG9mZnNldFg6IGluc2V0cy5sZWZ0LFxyXG4gICAgICBvZmZzZXRZOiBpbnNldHMudG9wXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvcmlnaW5hbEZyYW1lOiB0ZXh0RnJhbWUucG9zaXRpb24sXHJcbiAgICAgIGluc2V0cyxcclxuICAgICAgY29udGVudEFyZWEsXHJcbiAgICAgIGhhc0luc2V0czogaW5zZXRzLnRvcCA+IDAgfHwgaW5zZXRzLmJvdHRvbSA+IDAgfHwgaW5zZXRzLmxlZnQgPiAwIHx8IGluc2V0cy5yaWdodCA+IDBcclxuICAgIH07XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgSW5EZXNpZ24gbGVhZGluZyB0byBwcmVjaXNlIENTUyBsaW5lLWhlaWdodFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbGVhZGluZyAtIEluRGVzaWduIGxlYWRpbmcgdmFsdWVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZm9udFNpemUgLSBGb250IHNpemUgaW4gcG9pbnRzXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYWRpbmdUeXBlIC0gVHlwZSBvZiBsZWFkaW5nIChhdXRvLCBhYnNvbHV0ZSwgcGVyY2VudGFnZSlcclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDU1MtY29tcGF0aWJsZSBsaW5lIGhlaWdodCBpbmZvXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbnZlcnRMZWFkaW5nVG9DU1MobGVhZGluZywgZm9udFNpemUsIGxlYWRpbmdUeXBlID0gJ2F1dG8nKSB7XHJcbiAgICBsZXQgY3NzTGluZUhlaWdodDtcclxuICAgIGxldCBsaW5lSGVpZ2h0UHg7XHJcbiAgICBcclxuICAgIHN3aXRjaCAobGVhZGluZ1R5cGUpIHtcclxuICAgICAgY2FzZSAnYXV0byc6XHJcbiAgICAgICAgLy8gSW5EZXNpZ24gYXV0byBsZWFkaW5nIGlzIHR5cGljYWxseSAxMjAlIG9mIGZvbnQgc2l6ZVxyXG4gICAgICAgIGNzc0xpbmVIZWlnaHQgPSAxLjI7XHJcbiAgICAgICAgbGluZUhlaWdodFB4ID0gZm9udFNpemUgKiAxLjI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ2Fic29sdXRlJzpcclxuICAgICAgICAvLyBMZWFkaW5nIGlzIGluIHBvaW50cywgY29udmVydCB0byBsaW5lLWhlaWdodCByYXRpb1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGVhZGluZyA9PT0gJ251bWJlcicgJiYgbGVhZGluZyA+IDApIHtcclxuICAgICAgICAgIGNzc0xpbmVIZWlnaHQgPSBNYXRoLm1heCgwLjgsIGxlYWRpbmcgLyBmb250U2l6ZSk7XHJcbiAgICAgICAgICBsaW5lSGVpZ2h0UHggPSBsZWFkaW5nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjc3NMaW5lSGVpZ2h0ID0gMS4yO1xyXG4gICAgICAgICAgbGluZUhlaWdodFB4ID0gZm9udFNpemUgKiAxLjI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIFxyXG4gICAgICBjYXNlICdwZXJjZW50YWdlJzpcclxuICAgICAgICAvLyBMZWFkaW5nIGlzIHBlcmNlbnRhZ2UtYmFzZWRcclxuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChsZWFkaW5nKSAvIDEwMDtcclxuICAgICAgICBjc3NMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoMC44LCBwZXJjZW50YWdlKTtcclxuICAgICAgICBsaW5lSGVpZ2h0UHggPSBmb250U2l6ZSAqIHBlcmNlbnRhZ2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgY3NzTGluZUhlaWdodCA9IDEuMjtcclxuICAgICAgICBsaW5lSGVpZ2h0UHggPSBmb250U2l6ZSAqIDEuMjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY3NzTGluZUhlaWdodDogTWF0aC5yb3VuZChjc3NMaW5lSGVpZ2h0ICogMTAwMCkgLyAxMDAwLCAvLyBSb3VuZCB0byAzIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgIGxpbmVIZWlnaHRQeDogTWF0aC5yb3VuZChsaW5lSGVpZ2h0UHggKiAxMDApIC8gMTAwLCAgICAgLy8gUm91bmQgdG8gMiBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICBsZWFkaW5nVHlwZSxcclxuICAgICAgb3JpZ2luYWxMZWFkaW5nOiBsZWFkaW5nXHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgZmlyc3QgYmFzZWxpbmUgb2Zmc2V0IGFjY29yZGluZyB0byBJbkRlc2lnbiBydWxlc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaXJzdEJhc2VsaW5lT2Zmc2V0IC0gSW5EZXNpZ24gZmlyc3QgYmFzZWxpbmUgb2Zmc2V0IHNldHRpbmdcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZm9udFNpemUgLSBGb250IHNpemUgaW4gcG9pbnRzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVIZWlnaHQgLSBMaW5lIGhlaWdodCBpbiBwb2ludHNcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBGaXJzdCBiYXNlbGluZSBvZmZzZXQgaW4gcG9pbnRzXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUZpcnN0QmFzZWxpbmVPZmZzZXQoZmlyc3RCYXNlbGluZU9mZnNldCwgZm9udFNpemUsIGxpbmVIZWlnaHQpIHtcclxuICAgIHN3aXRjaCAoZmlyc3RCYXNlbGluZU9mZnNldCkge1xyXG4gICAgICBjYXNlICdBc2NlbnRPZmZzZXQnOlxyXG4gICAgICAgIC8vIFRleHQgc2l0cyBhdCBuYXR1cmFsIGFzY2VudCBsaW5lIChkZWZhdWx0KVxyXG4gICAgICAgIHJldHVybiBmb250U2l6ZSAqIDAuODsgLy8gQXBwcm94aW1hdGUgYXNjZW50IGZvciBtb3N0IGZvbnRzXHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ0NhcEhlaWdodE9mZnNldCc6XHJcbiAgICAgICAgLy8gVGV4dCBzaXRzIGF0IGNhcCBoZWlnaHRcclxuICAgICAgICByZXR1cm4gZm9udFNpemUgKiAwLjc7IC8vIEFwcHJveGltYXRlIGNhcCBoZWlnaHQgZm9yIG1vc3QgZm9udHNcclxuICAgICAgICBcclxuICAgICAgY2FzZSAnRml4ZWRIZWlnaHQnOlxyXG4gICAgICAgIC8vIEN1c3RvbSBmaXhlZCBoZWlnaHQgLSB1c2UgbGluZSBoZWlnaHRcclxuICAgICAgICByZXR1cm4gbGluZUhlaWdodDtcclxuICAgICAgICBcclxuICAgICAgY2FzZSAnWEhlaWdodE9mZnNldCc6XHJcbiAgICAgICAgLy8gVGV4dCBzaXRzIGF0IHgtaGVpZ2h0XHJcbiAgICAgICAgcmV0dXJuIGZvbnRTaXplICogMC41OyAvLyBBcHByb3hpbWF0ZSB4LWhlaWdodCBmb3IgbW9zdCBmb250c1xyXG4gICAgICAgIFxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBmb250U2l6ZSAqIDAuODsgLy8gRGVmYXVsdCB0byBhc2NlbnQgb2Zmc2V0XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIE1lYXN1cmUgdGV4dCBhY2N1cmF0ZWx5IHVzaW5nIGNhbnZhcyB3aXRoIEluRGVzaWduLXNwZWNpZmljIGFkanVzdG1lbnRzXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IHRvIG1lYXN1cmVcclxuICAgKiBAcGFyYW0ge29iamVjdH0gdGV4dFN0eWxlcyAtIENvbXBsZXRlIHRleHQgc3R5bGluZyBvYmplY3RcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZnJhbWVNZXRyaWNzIC0gVGV4dCBmcmFtZSBtZXRyaWNzXHJcbiAgICogQHJldHVybnMge29iamVjdH0gUHJlY2lzZSB0ZXh0IG1lYXN1cmVtZW50IGRhdGFcclxuICAgKi9cclxuICBzdGF0aWMgbWVhc3VyZVRleHRQcmVjaXNlbHkodGV4dCwgdGV4dFN0eWxlcywgZnJhbWVNZXRyaWNzKSB7XHJcbiAgICBpZiAoIXRleHQgfHwgdGV4dC50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGV4dFdpZHRoOiAwLFxyXG4gICAgICAgIHRleHRIZWlnaHQ6IDAsXHJcbiAgICAgICAgbGluZUNvdW50OiAwLFxyXG4gICAgICAgIGxpbmVzOiBbXSxcclxuICAgICAgICB3aWxsT3ZlcmZsb3c6IGZhbHNlLFxyXG4gICAgICAgIGZpdHM6IHRydWVcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGNhbnZhcyBmb3IgbWVhc3VyZW1lbnRcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBcclxuICAgIC8vIFNldCBmb250IHdpdGggcHJvcGVyIGZhbGxiYWNrc1xyXG4gICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUZsb2F0KHRleHRTdHlsZXMuZm9udFNpemUpIHx8IDEyO1xyXG4gICAgY29uc3QgZm9udEZhbWlseSA9IHRleHRTdHlsZXMuZm9udEZhbWlseSB8fCAnQXJpYWwsIHNhbnMtc2VyaWYnO1xyXG4gICAgY29uc3QgZm9udFdlaWdodCA9IHRleHRTdHlsZXMuZm9udFdlaWdodCB8fCAnbm9ybWFsJztcclxuICAgIGNvbnN0IGZvbnRTdHlsZSA9IHRleHRTdHlsZXMuZm9udFN0eWxlIHx8ICdub3JtYWwnO1xyXG4gICAgXHJcbiAgICBjdHguZm9udCA9IGAke2ZvbnRTdHlsZX0gJHtmb250V2VpZ2h0fSAke2ZvbnRTaXplfXB4ICR7Zm9udEZhbWlseX1gO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgZWZmZWN0aXZlIGNvbnRlbnQgd2lkdGggYWNjb3VudGluZyBmb3IgdHJhY2tpbmdcclxuICAgIGNvbnN0IHRyYWNraW5nID0gdGV4dFN0eWxlcy50cmFja2luZyB8fCAwO1xyXG4gICAgY29uc3QgdHJhY2tpbmdBZGp1c3RtZW50ID0gdHJhY2tpbmcgKiBmb250U2l6ZSAvIDEwMDA7IC8vIENvbnZlcnQgZW0gdG8gcHhcclxuICAgIGNvbnN0IGVmZmVjdGl2ZVdpZHRoID0gZnJhbWVNZXRyaWNzLmNvbnRlbnRBcmVhLndpZHRoIC0gTWF0aC5hYnModHJhY2tpbmdBZGp1c3RtZW50KTtcclxuICAgIFxyXG4gICAgLy8gU3BsaXQgdGV4dCBpbnRvIHdvcmRzIGZvciBhY2N1cmF0ZSB3cmFwcGluZ1xyXG4gICAgY29uc3Qgd29yZHMgPSB0ZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCkuc3BsaXQoJyAnKTtcclxuICAgIGNvbnN0IGxpbmVzID0gW107XHJcbiAgICBsZXQgY3VycmVudExpbmUgPSAnJztcclxuICAgIGxldCBjdXJyZW50TGluZVdpZHRoID0gMDtcclxuICAgIFxyXG4gICAgLy8gTWVhc3VyZSBzcGFjZSB3aWR0aCBvbmNlXHJcbiAgICBjb25zdCBzcGFjZVdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KCcgJykud2lkdGggKyB0cmFja2luZ0FkanVzdG1lbnQ7XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgd29yZCA9IHdvcmRzW2ldO1xyXG4gICAgICBjb25zdCB3b3JkV2lkdGggPSBjdHgubWVhc3VyZVRleHQod29yZCkud2lkdGggKyAod29yZC5sZW5ndGggLSAxKSAqIHRyYWNraW5nQWRqdXN0bWVudDtcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcclxuICAgICAgY29uc3Qgd29yZFdpdGhTcGFjZVdpZHRoID0gY3VycmVudExpbmUgPyB3b3JkV2lkdGggKyBzcGFjZVdpZHRoIDogd29yZFdpZHRoO1xyXG4gICAgICBcclxuICAgICAgaWYgKGN1cnJlbnRMaW5lICYmIChjdXJyZW50TGluZVdpZHRoICsgd29yZFdpdGhTcGFjZVdpZHRoID4gZWZmZWN0aXZlV2lkdGgpKSB7XHJcbiAgICAgICAgLy8gV29yZCBkb2Vzbid0IGZpdCwgc3RhcnQgbmV3IGxpbmVcclxuICAgICAgICBsaW5lcy5wdXNoKHtcclxuICAgICAgICAgIHRleHQ6IGN1cnJlbnRMaW5lLFxyXG4gICAgICAgICAgd2lkdGg6IGN1cnJlbnRMaW5lV2lkdGhcclxuICAgICAgICB9KTtcclxuICAgICAgICBjdXJyZW50TGluZSA9IHdvcmQ7XHJcbiAgICAgICAgY3VycmVudExpbmVXaWR0aCA9IHdvcmRXaWR0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBXb3JkIGZpdHMsIGFkZCB0byBjdXJyZW50IGxpbmVcclxuICAgICAgICBpZiAoY3VycmVudExpbmUpIHtcclxuICAgICAgICAgIGN1cnJlbnRMaW5lICs9ICcgJyArIHdvcmQ7XHJcbiAgICAgICAgICBjdXJyZW50TGluZVdpZHRoICs9IHdvcmRXaXRoU3BhY2VXaWR0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY3VycmVudExpbmUgPSB3b3JkO1xyXG4gICAgICAgICAgY3VycmVudExpbmVXaWR0aCA9IHdvcmRXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQWRkIHRoZSBsYXN0IGxpbmVcclxuICAgIGlmIChjdXJyZW50TGluZSkge1xyXG4gICAgICBsaW5lcy5wdXNoKHtcclxuICAgICAgICB0ZXh0OiBjdXJyZW50TGluZSxcclxuICAgICAgICB3aWR0aDogY3VycmVudExpbmVXaWR0aFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRleHQgaGVpZ2h0IHVzaW5nIEluRGVzaWduLWFjY3VyYXRlIGxlYWRpbmdcclxuICAgIGNvbnN0IGxpbmVIZWlnaHRJbmZvID0gdGhpcy5jb252ZXJ0TGVhZGluZ1RvQ1NTKFxyXG4gICAgICB0ZXh0U3R5bGVzLmxlYWRpbmcsIFxyXG4gICAgICBmb250U2l6ZSwgXHJcbiAgICAgIHRleHRTdHlsZXMubGVhZGluZ1R5cGVcclxuICAgICk7XHJcbiAgICBcclxuICAgIGNvbnN0IGxpbmVDb3VudCA9IE1hdGgubWF4KDEsIGxpbmVzLmxlbmd0aCk7XHJcbiAgICBjb25zdCBmaXJzdEJhc2VsaW5lT2Zmc2V0ID0gdGhpcy5jYWxjdWxhdGVGaXJzdEJhc2VsaW5lT2Zmc2V0KFxyXG4gICAgICB0ZXh0U3R5bGVzLmZpcnN0QmFzZWxpbmVPZmZzZXQgfHwgJ0FzY2VudE9mZnNldCcsXHJcbiAgICAgIGZvbnRTaXplLFxyXG4gICAgICBsaW5lSGVpZ2h0SW5mby5saW5lSGVpZ2h0UHhcclxuICAgICk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB0ZXh0IGhlaWdodCBpbmNsdWRpbmcgZmlyc3QgYmFzZWxpbmUgb2Zmc2V0XHJcbiAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gZmlyc3RCYXNlbGluZU9mZnNldCArICgobGluZUNvdW50IC0gMSkgKiBsaW5lSGVpZ2h0SW5mby5saW5lSGVpZ2h0UHgpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiB0ZXh0IG92ZXJmbG93cyB0aGUgYXZhaWxhYmxlIGhlaWdodFxyXG4gICAgY29uc3Qgd2lsbE92ZXJmbG93ID0gdGV4dEhlaWdodCA+IGZyYW1lTWV0cmljcy5jb250ZW50QXJlYS5oZWlnaHQ7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHRXaWR0aDogTWF0aC5tYXgoLi4ubGluZXMubWFwKGxpbmUgPT4gbGluZS53aWR0aCkpLFxyXG4gICAgICB0ZXh0SGVpZ2h0OiBNYXRoLnJvdW5kKHRleHRIZWlnaHQgKiAxMDApIC8gMTAwLFxyXG4gICAgICBsaW5lQ291bnQsXHJcbiAgICAgIGxpbmVzLFxyXG4gICAgICBsaW5lSGVpZ2h0UHg6IGxpbmVIZWlnaHRJbmZvLmxpbmVIZWlnaHRQeCxcclxuICAgICAgZmlyc3RCYXNlbGluZU9mZnNldCxcclxuICAgICAgd2lsbE92ZXJmbG93LFxyXG4gICAgICBmaXRzOiAhd2lsbE92ZXJmbG93LFxyXG4gICAgICBhdmFpbGFibGVIZWlnaHQ6IGZyYW1lTWV0cmljcy5jb250ZW50QXJlYS5oZWlnaHQsXHJcbiAgICAgIG92ZXJmbG93QW1vdW50OiB3aWxsT3ZlcmZsb3cgPyB0ZXh0SGVpZ2h0IC0gZnJhbWVNZXRyaWNzLmNvbnRlbnRBcmVhLmhlaWdodCA6IDAsXHJcbiAgICAgIC8vIERldGFpbGVkIG1ldHJpY3MgZm9yIGRlYnVnZ2luZ1xyXG4gICAgICBtZXRyaWNzOiB7XHJcbiAgICAgICAgZm9udFNpemUsXHJcbiAgICAgICAgbGVhZGluZzogdGV4dFN0eWxlcy5sZWFkaW5nLFxyXG4gICAgICAgIGxlYWRpbmdUeXBlOiB0ZXh0U3R5bGVzLmxlYWRpbmdUeXBlLFxyXG4gICAgICAgIGVmZmVjdGl2ZVdpZHRoLFxyXG4gICAgICAgIHRyYWNraW5nOiB0cmFja2luZ0FkanVzdG1lbnQsXHJcbiAgICAgICAgc3BhY2VXaWR0aFxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgb3B0aW1hbCBmb250IHNpemUgdG8gcHJldmVudCBvdmVyZmxvdyB3aGlsZSBtYWludGFpbmluZyBkZXNpZ24gaW50ZWdyaXR5XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHRleHRNZWFzdXJlbWVudCAtIFJlc3VsdCBmcm9tIG1lYXN1cmVUZXh0UHJlY2lzZWx5XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9yaWdpbmFsU3R5bGVzIC0gT3JpZ2luYWwgdGV4dCBzdHlsZXNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmVkdWN0aW9uIC0gTWF4aW11bSBmb250IHNpemUgcmVkdWN0aW9uIGFsbG93ZWQgKDAuMC0xLjApXHJcbiAgICogQHJldHVybnMge29iamVjdH0gQWRqdXN0ZWQgdGV4dCBzdHlsZXMgb3IgbnVsbCBpZiBubyBhZGp1c3RtZW50IG5lZWRlZFxyXG4gICAqL1xyXG4gIHN0YXRpYyBjYWxjdWxhdGVPcHRpbWFsRm9udFNpemUodGV4dE1lYXN1cmVtZW50LCBvcmlnaW5hbFN0eWxlcywgbWF4UmVkdWN0aW9uID0gMC4xNSkge1xyXG4gICAgaWYgKCF0ZXh0TWVhc3VyZW1lbnQud2lsbE92ZXJmbG93KSB7XHJcbiAgICAgIHJldHVybiBudWxsOyAvLyBObyBhZGp1c3RtZW50IG5lZWRlZFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBvcmlnaW5hbEZvbnRTaXplID0gcGFyc2VGbG9hdChvcmlnaW5hbFN0eWxlcy5mb250U2l6ZSkgfHwgMTI7XHJcbiAgICBjb25zdCBvdmVyZmxvd1JhdGlvID0gdGV4dE1lYXN1cmVtZW50LnRleHRIZWlnaHQgLyB0ZXh0TWVhc3VyZW1lbnQuYXZhaWxhYmxlSGVpZ2h0O1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgcmVxdWlyZWQgc2NhbGUgZmFjdG9yXHJcbiAgICBsZXQgc2NhbGVGYWN0b3IgPSAxIC8gb3ZlcmZsb3dSYXRpbztcclxuICAgIFxyXG4gICAgLy8gQXBwbHkgbWF4aW11bSByZWR1Y3Rpb24gbGltaXQgdG8gcHJlc2VydmUgZGVzaWduIGludGVncml0eVxyXG4gICAgY29uc3QgbWluQWxsb3dlZFNjYWxlID0gMSAtIG1heFJlZHVjdGlvbjtcclxuICAgIHNjYWxlRmFjdG9yID0gTWF0aC5tYXgobWluQWxsb3dlZFNjYWxlLCBzY2FsZUZhY3Rvcik7XHJcbiAgICBcclxuICAgIGNvbnN0IG5ld0ZvbnRTaXplID0gb3JpZ2luYWxGb250U2l6ZSAqIHNjYWxlRmFjdG9yO1xyXG4gICAgXHJcbiAgICAvLyBJZiB3ZSBjYW4ndCBmaXggaXQgd2l0aCB0aGUgYWxsb3dlZCByZWR1Y3Rpb24sIHJldHVybiBwcm9wb3J0aW9uYWwgYWRqdXN0bWVudFxyXG4gICAgaWYgKHNjYWxlRmFjdG9yID09PSBtaW5BbGxvd2VkU2NhbGUgJiYgb3ZlcmZsb3dSYXRpbyA+IDEuMikge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkanVzdGVkU3R5bGVzOiB7XHJcbiAgICAgICAgICAuLi5vcmlnaW5hbFN0eWxlcyxcclxuICAgICAgICAgIGZvbnRTaXplOiBgJHtNYXRoLnJvdW5kKG5ld0ZvbnRTaXplICogMTAwKSAvIDEwMH1weGAsXHJcbiAgICAgICAgICAvLyBBbHNvIGFkanVzdCBsaW5lLWhlaWdodCBwcm9wb3J0aW9uYWxseSBmb3Igc2V2ZXJlIG92ZXJmbG93c1xyXG4gICAgICAgICAgbGluZUhlaWdodDogTWF0aC5tYXgoMC45LCBwYXJzZUZsb2F0KG9yaWdpbmFsU3R5bGVzLmxpbmVIZWlnaHQgfHwgJzEuMicpICogc2NhbGVGYWN0b3IpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGp1c3RtZW50VHlwZTogJ2ZvbnRfc2l6ZV9yZWR1Y2VkJyxcclxuICAgICAgICBzY2FsZUZhY3RvcixcclxuICAgICAgICBvcmlnaW5hbEZvbnRTaXplLFxyXG4gICAgICAgIG5ld0ZvbnRTaXplOiBNYXRoLnJvdW5kKG5ld0ZvbnRTaXplICogMTAwKSAvIDEwMCxcclxuICAgICAgICBzdGlsbE92ZXJmbG93czogdHJ1ZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhZGp1c3RlZFN0eWxlczoge1xyXG4gICAgICAgIC4uLm9yaWdpbmFsU3R5bGVzLFxyXG4gICAgICAgIGZvbnRTaXplOiBgJHtNYXRoLnJvdW5kKG5ld0ZvbnRTaXplICogMTAwKSAvIDEwMH1weGBcclxuICAgICAgfSxcclxuICAgICAgYWRqdXN0bWVudFR5cGU6ICdmb250X3NpemVfcmVkdWNlZCcsXHJcbiAgICAgIHNjYWxlRmFjdG9yLFxyXG4gICAgICBvcmlnaW5hbEZvbnRTaXplLFxyXG4gICAgICBuZXdGb250U2l6ZTogTWF0aC5yb3VuZChuZXdGb250U2l6ZSAqIDEwMCkgLyAxMDAsXHJcbiAgICAgIHN0aWxsT3ZlcmZsb3dzOiBmYWxzZVxyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgQ1NTIHN0eWxlcyB3aXRoIEluRGVzaWduLWFjY3VyYXRlIHR5cG9ncmFwaHlcclxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5EZXNpZ25Gb3JtYXR0aW5nIC0gRm9ybWF0dGluZyBvYmplY3QgZnJvbSBJbkRlc2lnblxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmcmFtZU1ldHJpY3MgLSBUZXh0IGZyYW1lIG1ldHJpY3NcclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDU1Mgc3R5bGVzIG9wdGltaXplZCBmb3IgSW5EZXNpZ24gY29tcGF0aWJpbGl0eVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZW5lcmF0ZUluRGVzaWduQ1NTKGluRGVzaWduRm9ybWF0dGluZywgZnJhbWVNZXRyaWNzKSB7XHJcbiAgICBjb25zdCBmb250U2l6ZSA9IGluRGVzaWduRm9ybWF0dGluZy5mb250U2l6ZSB8fCAxMjtcclxuICAgIFxyXG4gICAgLy8gQ29udmVydCBsZWFkaW5nIHRvIENTU1xyXG4gICAgY29uc3QgbGluZUhlaWdodEluZm8gPSB0aGlzLmNvbnZlcnRMZWFkaW5nVG9DU1MoXHJcbiAgICAgIGluRGVzaWduRm9ybWF0dGluZy5sZWFkaW5nLFxyXG4gICAgICBmb250U2l6ZSxcclxuICAgICAgaW5EZXNpZ25Gb3JtYXR0aW5nLmxlYWRpbmdUeXBlXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgZmlyc3QgYmFzZWxpbmUgb2Zmc2V0IGZvciBwb3NpdGlvbmluZ1xyXG4gICAgY29uc3QgZmlyc3RCYXNlbGluZU9mZnNldCA9IHRoaXMuY2FsY3VsYXRlRmlyc3RCYXNlbGluZU9mZnNldChcclxuICAgICAgaW5EZXNpZ25Gb3JtYXR0aW5nLmZpcnN0QmFzZWxpbmVPZmZzZXQgfHwgJ0FzY2VudE9mZnNldCcsXHJcbiAgICAgIGZvbnRTaXplLFxyXG4gICAgICBsaW5lSGVpZ2h0SW5mby5saW5lSGVpZ2h0UHhcclxuICAgICk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8vIFR5cG9ncmFwaHlcclxuICAgICAgZm9udFNpemU6IGAke2ZvbnRTaXplfXB4YCxcclxuICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodEluZm8uY3NzTGluZUhlaWdodCxcclxuICAgICAgZm9udEZhbWlseTogaW5EZXNpZ25Gb3JtYXR0aW5nLmZvbnRGYW1pbHkgfHwgJ0FyaWFsLCBzYW5zLXNlcmlmJyxcclxuICAgICAgZm9udFdlaWdodDogaW5EZXNpZ25Gb3JtYXR0aW5nLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCcsXHJcbiAgICAgIGZvbnRTdHlsZTogaW5EZXNpZ25Gb3JtYXR0aW5nLmZvbnRTdHlsZSB8fCAnbm9ybWFsJyxcclxuICAgICAgXHJcbiAgICAgIC8vIEFkdmFuY2VkIHR5cG9ncmFwaHlcclxuICAgICAgbGV0dGVyU3BhY2luZzogaW5EZXNpZ25Gb3JtYXR0aW5nLnRyYWNraW5nID8gYCR7aW5EZXNpZ25Gb3JtYXR0aW5nLnRyYWNraW5nIC8gMTAwMH1lbWAgOiAnbm9ybWFsJyxcclxuICAgICAgdGV4dEFsaWduOiBpbkRlc2lnbkZvcm1hdHRpbmcudGV4dEFsaWduIHx8ICdsZWZ0JyxcclxuICAgICAgY29sb3I6IGluRGVzaWduRm9ybWF0dGluZy5jb2xvciB8fCAnYmxhY2snLFxyXG4gICAgICBcclxuICAgICAgLy8gTGF5b3V0IGFuZCBwb3NpdGlvbmluZ1xyXG4gICAgICBwYWRkaW5nOiBgJHtmaXJzdEJhc2VsaW5lT2Zmc2V0fXB4ICR7ZnJhbWVNZXRyaWNzLmluc2V0cy5yaWdodH1weCAke2ZyYW1lTWV0cmljcy5pbnNldHMuYm90dG9tfXB4ICR7ZnJhbWVNZXRyaWNzLmluc2V0cy5sZWZ0fXB4YCxcclxuICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICBcclxuICAgICAgLy8gT3ZlcmZsb3cgY29udHJvbFxyXG4gICAgICB3aWR0aDogYCR7ZnJhbWVNZXRyaWNzLmNvbnRlbnRBcmVhLndpZHRofXB4YCxcclxuICAgICAgaGVpZ2h0OiBgJHtmcmFtZU1ldHJpY3MuY29udGVudEFyZWEuaGVpZ2h0fXB4YCxcclxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcclxuICAgICAgXHJcbiAgICAgIC8vIFRleHQgbGF5b3V0IG9wdGltaXphdGlvblxyXG4gICAgICB3aGl0ZVNwYWNlOiAnbm9ybWFsJyxcclxuICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJyxcclxuICAgICAgb3ZlcmZsb3dXcmFwOiAnYnJlYWstd29yZCcsXHJcbiAgICAgIHdvcmRCcmVhazogJ25vcm1hbCcsXHJcbiAgICAgIFxyXG4gICAgICAvLyBJbkRlc2lnbi1zcGVjaWZpYyBhZGp1c3RtZW50c1xyXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgdG9wOiBmcmFtZU1ldHJpY3MuaGFzSW5zZXRzID8gYCR7ZnJhbWVNZXRyaWNzLm9mZnNldFl9cHhgIDogJzAnLFxyXG4gICAgICBsZWZ0OiBmcmFtZU1ldHJpY3MuaGFzSW5zZXRzID8gYCR7ZnJhbWVNZXRyaWNzLm9mZnNldFh9cHhgIDogJzAnLFxyXG4gICAgICBcclxuICAgICAgLy8gRGVidWcgaW5mbyAoY2FuIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbilcclxuICAgICAgJy0taW5kZXNpZ24tbGVhZGluZyc6IGluRGVzaWduRm9ybWF0dGluZy5sZWFkaW5nLFxyXG4gICAgICAnLS1pbmRlc2lnbi1sZWFkaW5nLXR5cGUnOiBpbkRlc2lnbkZvcm1hdHRpbmcubGVhZGluZ1R5cGUsXHJcbiAgICAgICctLWNzcy1saW5lLWhlaWdodCc6IGxpbmVIZWlnaHRJbmZvLmNzc0xpbmVIZWlnaHQsXHJcbiAgICAgICctLWZpcnN0LWJhc2VsaW5lLW9mZnNldCc6IGAke2ZpcnN0QmFzZWxpbmVPZmZzZXR9cHhgXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IGZvciB1c2UgaW4gb3RoZXIgbW9kdWxlc1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEluRGVzaWduVGV4dE1ldHJpY3M7XHJcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICB3aW5kb3cuSW5EZXNpZ25UZXh0TWV0cmljcyA9IEluRGVzaWduVGV4dE1ldHJpY3M7XHJcbn0gIl0sIm5hbWVzIjpbIkluRGVzaWduVGV4dE1ldHJpY3MiLCJjYWxjdWxhdGVUZXh0RnJhbWVJbnNldHMiLCJ0ZXh0RnJhbWUiLCJ0ZXh0RnJhbWVQcmVmcyIsIkRFRkFVTFRfSU5TRVRTIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiaW5zZXRzIiwiaW5zZXRTcGFjaW5nIiwidGV4dEluc2V0cyIsImNvbnRlbnRBcmVhIiwid2lkdGgiLCJNYXRoIiwibWF4IiwicG9zaXRpb24iLCJoZWlnaHQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIm9yaWdpbmFsRnJhbWUiLCJoYXNJbnNldHMiLCJjb252ZXJ0TGVhZGluZ1RvQ1NTIiwibGVhZGluZyIsImZvbnRTaXplIiwibGVhZGluZ1R5cGUiLCJjc3NMaW5lSGVpZ2h0IiwibGluZUhlaWdodFB4IiwicGVyY2VudGFnZSIsInBhcnNlRmxvYXQiLCJyb3VuZCIsIm9yaWdpbmFsTGVhZGluZyIsImNhbGN1bGF0ZUZpcnN0QmFzZWxpbmVPZmZzZXQiLCJmaXJzdEJhc2VsaW5lT2Zmc2V0IiwibGluZUhlaWdodCIsIm1lYXN1cmVUZXh0UHJlY2lzZWx5IiwidGV4dCIsInRleHRTdHlsZXMiLCJmcmFtZU1ldHJpY3MiLCJ0cmltIiwidGV4dFdpZHRoIiwidGV4dEhlaWdodCIsImxpbmVDb3VudCIsImxpbmVzIiwid2lsbE92ZXJmbG93IiwiZml0cyIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJmb250RmFtaWx5IiwiZm9udFdlaWdodCIsImZvbnRTdHlsZSIsImZvbnQiLCJ0cmFja2luZyIsInRyYWNraW5nQWRqdXN0bWVudCIsImVmZmVjdGl2ZVdpZHRoIiwiYWJzIiwid29yZHMiLCJyZXBsYWNlIiwic3BsaXQiLCJjdXJyZW50TGluZSIsImN1cnJlbnRMaW5lV2lkdGgiLCJzcGFjZVdpZHRoIiwibWVhc3VyZVRleHQiLCJpIiwibGVuZ3RoIiwid29yZCIsIndvcmRXaWR0aCIsIndvcmRXaXRoU3BhY2VXaWR0aCIsInB1c2giLCJsaW5lSGVpZ2h0SW5mbyIsIm1hcCIsImxpbmUiLCJhdmFpbGFibGVIZWlnaHQiLCJvdmVyZmxvd0Ftb3VudCIsIm1ldHJpY3MiLCJjYWxjdWxhdGVPcHRpbWFsRm9udFNpemUiLCJ0ZXh0TWVhc3VyZW1lbnQiLCJvcmlnaW5hbFN0eWxlcyIsIm1heFJlZHVjdGlvbiIsIm9yaWdpbmFsRm9udFNpemUiLCJvdmVyZmxvd1JhdGlvIiwic2NhbGVGYWN0b3IiLCJtaW5BbGxvd2VkU2NhbGUiLCJuZXdGb250U2l6ZSIsImFkanVzdGVkU3R5bGVzIiwiYWRqdXN0bWVudFR5cGUiLCJzdGlsbE92ZXJmbG93cyIsImdlbmVyYXRlSW5EZXNpZ25DU1MiLCJpbkRlc2lnbkZvcm1hdHRpbmciLCJsZXR0ZXJTcGFjaW5nIiwidGV4dEFsaWduIiwiY29sb3IiLCJwYWRkaW5nIiwibWFyZ2luIiwib3ZlcmZsb3ciLCJib3hTaXppbmciLCJ3aGl0ZVNwYWNlIiwid29yZFdyYXAiLCJvdmVyZmxvd1dyYXAiLCJ3b3JkQnJlYWsiLCJtb2R1bGUiLCJleHBvcnRzIiwid2luZG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/utils/InDesignTextMetrics.js\n"));

/***/ })

});