"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/view/[uploadId]",{

/***/ "./lib/utils/InDesignTextMetrics.js":
/*!******************************************!*\
  !*** ./lib/utils/InDesignTextMetrics.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * InDesignTextMetrics.js - Precise text measurement utility for 1:1 InDesign compatibility\r\n * Handles font metrics, leading calculations, and text frame insets exactly like InDesign\r\n */ \nclass InDesignTextMetrics {\n    /**\r\n   * Calculate precise text frame dimensions including InDesign-specific insets\r\n   * @param {object} textFrame - The text frame element\r\n   * @param {object} textFramePrefs - Text frame preferences from InDesign\r\n   * @returns {object} Adjusted frame dimensions\r\n   */ static calculateTextFrameInsets(textFrame, textFramePrefs) {\n        var _textFramePrefs_insetSpacing, _textFramePrefs_textInsets, _textFramePrefs_insetSpacing1, _textFramePrefs_textInsets1, _textFramePrefs_insetSpacing2, _textFramePrefs_textInsets2, _textFramePrefs_insetSpacing3, _textFramePrefs_textInsets3;\n        // InDesign default text frame insets (in points)\n        const DEFAULT_INSETS = {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        };\n        // Extract insets from preferences if available\n        const insets = {\n            top: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing === void 0 ? void 0 : _textFramePrefs_insetSpacing.top) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets === void 0 ? void 0 : _textFramePrefs_textInsets.top) || DEFAULT_INSETS.top,\n            bottom: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing1 = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing1 === void 0 ? void 0 : _textFramePrefs_insetSpacing1.bottom) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets1 = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets1 === void 0 ? void 0 : _textFramePrefs_textInsets1.bottom) || DEFAULT_INSETS.bottom,\n            left: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing2 = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing2 === void 0 ? void 0 : _textFramePrefs_insetSpacing2.left) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets2 = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets2 === void 0 ? void 0 : _textFramePrefs_textInsets2.left) || DEFAULT_INSETS.left,\n            right: (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_insetSpacing3 = textFramePrefs.insetSpacing) === null || _textFramePrefs_insetSpacing3 === void 0 ? void 0 : _textFramePrefs_insetSpacing3.right) || (textFramePrefs === null || textFramePrefs === void 0 ? void 0 : (_textFramePrefs_textInsets3 = textFramePrefs.textInsets) === null || _textFramePrefs_textInsets3 === void 0 ? void 0 : _textFramePrefs_textInsets3.right) || DEFAULT_INSETS.right\n        };\n        // Calculate content area (available for text)\n        const contentArea = {\n            width: Math.max(0, textFrame.position.width - insets.left - insets.right),\n            height: Math.max(0, textFrame.position.height - insets.top - insets.bottom),\n            offsetX: insets.left,\n            offsetY: insets.top\n        };\n        return {\n            originalFrame: textFrame.position,\n            insets,\n            contentArea,\n            hasInsets: insets.top > 0 || insets.bottom > 0 || insets.left > 0 || insets.right > 0\n        };\n    }\n    /**\r\n   * Convert InDesign leading to precise CSS line-height\r\n   * @param {number|string} leading - InDesign leading value\r\n   * @param {number} fontSize - Font size in points\r\n   * @param {string} leadingType - Type of leading (auto, absolute, percentage)\r\n   * @returns {object} CSS-compatible line height info\r\n   */ static convertLeadingToCSS(leading, fontSize) {\n        let leadingType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"auto\";\n        let cssLineHeight;\n        let lineHeightPx;\n        switch(leadingType){\n            case \"auto\":\n                // InDesign auto leading is typically 120% of font size\n                cssLineHeight = 1.2;\n                lineHeightPx = fontSize * 1.2;\n                break;\n            case \"absolute\":\n                // Leading is in points, convert to line-height ratio\n                if (typeof leading === \"number\" && leading > 0) {\n                    cssLineHeight = Math.max(0.8, leading / fontSize);\n                    lineHeightPx = leading;\n                } else {\n                    cssLineHeight = 1.2;\n                    lineHeightPx = fontSize * 1.2;\n                }\n                break;\n            case \"percentage\":\n                // Leading is percentage-based\n                const percentage = parseFloat(leading) / 100;\n                cssLineHeight = Math.max(0.8, percentage);\n                lineHeightPx = fontSize * percentage;\n                break;\n            default:\n                cssLineHeight = 1.2;\n                lineHeightPx = fontSize * 1.2;\n        }\n        return {\n            cssLineHeight: Math.round(cssLineHeight * 1000) / 1000,\n            lineHeightPx: Math.round(lineHeightPx * 100) / 100,\n            leadingType,\n            originalLeading: leading\n        };\n    }\n    /**\r\n   * Calculate first baseline offset according to InDesign rules\r\n   * @param {string} firstBaselineOffset - InDesign first baseline offset setting\r\n   * @param {number} fontSize - Font size in points\r\n   * @param {number} lineHeight - Line height in points\r\n   * @returns {number} First baseline offset in points\r\n   */ static calculateFirstBaselineOffset(firstBaselineOffset, fontSize, lineHeight) {\n        switch(firstBaselineOffset){\n            case \"AscentOffset\":\n                // Text sits at natural ascent line (default)\n                return fontSize * 0.8; // Approximate ascent for most fonts\n            case \"CapHeightOffset\":\n                // Text sits at cap height\n                return fontSize * 0.7; // Approximate cap height for most fonts\n            case \"FixedHeight\":\n                // Custom fixed height - use line height\n                return lineHeight;\n            case \"XHeightOffset\":\n                // Text sits at x-height\n                return fontSize * 0.5; // Approximate x-height for most fonts\n            default:\n                return fontSize * 0.8; // Default to ascent offset\n        }\n    }\n    /**\r\n   * Measure text accurately using canvas with InDesign-specific adjustments\r\n   * @param {string} text - Text to measure\r\n   * @param {object} textStyles - Complete text styling object\r\n   * @param {object} frameMetrics - Text frame metrics\r\n   * @returns {object} Precise text measurement data\r\n   */ static measureTextPrecisely(text, textStyles, frameMetrics) {\n        if (!text || text.trim() === \"\") {\n            return {\n                textWidth: 0,\n                textHeight: 0,\n                lineCount: 0,\n                lines: [],\n                willOverflow: false,\n                fits: true\n            };\n        }\n        // Create canvas for measurement\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        // Set font with proper fallbacks\n        const fontSize = parseFloat(textStyles.fontSize) || 12;\n        const fontFamily = textStyles.fontFamily || \"Arial, sans-serif\";\n        const fontWeight = textStyles.fontWeight || \"normal\";\n        const fontStyle = textStyles.fontStyle || \"normal\";\n        ctx.font = \"\".concat(fontStyle, \" \").concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n        // Calculate effective content width accounting for tracking\n        const tracking = textStyles.tracking || 0;\n        const trackingAdjustment = tracking * fontSize / 1000; // Convert em to px\n        const effectiveWidth = Math.max(10, frameMetrics.contentArea.width - Math.abs(trackingAdjustment) - 2); // Leave 2px margin\n        // Split text into words for accurate wrapping, preserving line breaks\n        const words = text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\").split(/(\\s+|\\n)/).filter((word)=>word.length > 0);\n        const lines = [];\n        let currentLine = \"\";\n        let currentLineWidth = 0;\n        // Measure space width once\n        const spaceWidth = ctx.measureText(\" \").width + trackingAdjustment;\n        for(let i = 0; i < words.length; i++){\n            const word = words[i];\n            // Handle explicit line breaks\n            if (word === \"\\n\") {\n                if (currentLine) {\n                    lines.push({\n                        text: currentLine,\n                        width: currentLineWidth\n                    });\n                    currentLine = \"\";\n                    currentLineWidth = 0;\n                }\n                continue;\n            }\n            // Skip pure whitespace (except spaces)\n            if (/^\\s+$/.test(word) && word !== \" \") {\n                continue;\n            }\n            const wordWidth = ctx.measureText(word).width + Math.max(0, word.length - 1) * trackingAdjustment;\n            // Check if word fits on current line\n            const wordWithSpaceWidth = currentLine && word !== \" \" ? wordWidth + spaceWidth : wordWidth;\n            if (currentLine && word !== \" \" && currentLineWidth + wordWithSpaceWidth > effectiveWidth) {\n                // Word doesn't fit, start new line\n                lines.push({\n                    text: currentLine,\n                    width: currentLineWidth\n                });\n                currentLine = word;\n                currentLineWidth = wordWidth;\n            } else {\n                // Word fits, add to current line\n                if (currentLine && word !== \" \") {\n                    currentLine += \" \" + word;\n                    currentLineWidth += wordWithSpaceWidth;\n                } else if (word !== \" \") {\n                    currentLine = word;\n                    currentLineWidth = wordWidth;\n                }\n            }\n        }\n        // Add the last line\n        if (currentLine) {\n            lines.push({\n                text: currentLine,\n                width: currentLineWidth\n            });\n        }\n        // Calculate text height using InDesign-accurate leading\n        const lineHeightInfo = this.convertLeadingToCSS(textStyles.leading, fontSize, textStyles.leadingType);\n        const lineCount = Math.max(1, lines.length);\n        const firstBaselineOffset = this.calculateFirstBaselineOffset(textStyles.firstBaselineOffset || \"AscentOffset\", fontSize, lineHeightInfo.lineHeightPx);\n        // Calculate total text height including first baseline offset\n        const textHeight = firstBaselineOffset + (lineCount - 1) * lineHeightInfo.lineHeightPx;\n        // Check if text overflows the available height\n        const willOverflow = textHeight > frameMetrics.contentArea.height;\n        return {\n            textWidth: Math.max(...lines.map((line)=>line.width)),\n            textHeight: Math.round(textHeight * 100) / 100,\n            lineCount,\n            lines,\n            lineHeightPx: lineHeightInfo.lineHeightPx,\n            firstBaselineOffset,\n            willOverflow,\n            fits: !willOverflow,\n            availableHeight: frameMetrics.contentArea.height,\n            overflowAmount: willOverflow ? textHeight - frameMetrics.contentArea.height : 0,\n            // Detailed metrics for debugging\n            metrics: {\n                fontSize,\n                leading: textStyles.leading,\n                leadingType: textStyles.leadingType,\n                effectiveWidth,\n                tracking: trackingAdjustment,\n                spaceWidth\n            }\n        };\n    }\n    /**\r\n   * Calculate optimal font size to prevent overflow while maintaining design integrity\r\n   * @param {object} textMeasurement - Result from measureTextPrecisely\r\n   * @param {object} originalStyles - Original text styles\r\n   * @param {number} maxReduction - Maximum font size reduction allowed (0.0-1.0)\r\n   * @returns {object} Adjusted text styles or null if no adjustment needed\r\n   */ static calculateOptimalFontSize(textMeasurement, originalStyles) {\n        let maxReduction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.25;\n        if (!textMeasurement.willOverflow) {\n            return null; // No adjustment needed\n        }\n        const originalFontSize = parseFloat(originalStyles.fontSize) || 12;\n        const overflowRatio = textMeasurement.textHeight / textMeasurement.availableHeight;\n        console.log(\"\\uD83D\\uDD27 calculateOptimalFontSize:\", {\n            originalFontSize,\n            textHeight: textMeasurement.textHeight,\n            availableHeight: textMeasurement.availableHeight,\n            overflowRatio,\n            overflowAmount: textMeasurement.overflowAmount\n        });\n        // Calculate required scale factor to fit exactly\n        let scaleFactor = 1 / overflowRatio;\n        // Apply maximum reduction limit to preserve design integrity\n        const minAllowedScale = 1 - maxReduction;\n        const finalScaleFactor = Math.max(minAllowedScale, scaleFactor);\n        const newFontSize = originalFontSize * finalScaleFactor;\n        console.log(\"\\uD83D\\uDD27 Scale calculation:\", {\n            requiredScale: scaleFactor,\n            maxReduction,\n            minAllowedScale,\n            finalScaleFactor,\n            newFontSize\n        });\n        // Calculate if text will still overflow after adjustment\n        const willStillOverflow = finalScaleFactor > scaleFactor;\n        return {\n            adjustedStyles: {\n                ...originalStyles,\n                fontSize: \"\".concat(Math.round(newFontSize * 100) / 100, \"px\"),\n                // Also adjust line-height proportionally if needed\n                lineHeight: overflowRatio > 1.3 ? Math.max(0.9, parseFloat(originalStyles.lineHeight || \"1.2\") * finalScaleFactor) : originalStyles.lineHeight\n            },\n            adjustmentType: willStillOverflow ? \"partial_font_reduction\" : \"font_size_optimized\",\n            scaleFactor: finalScaleFactor,\n            originalFontSize,\n            newFontSize: Math.round(newFontSize * 100) / 100,\n            stillOverflows: willStillOverflow,\n            reductionApplied: ((1 - finalScaleFactor) * 100).toFixed(1) + \"%\"\n        };\n    }\n    /**\r\n   * Generate CSS styles with InDesign-accurate typography\r\n   * @param {object} inDesignFormatting - Formatting object from InDesign\r\n   * @param {object} frameMetrics - Text frame metrics\r\n   * @returns {object} CSS styles optimized for InDesign compatibility\r\n   */ static generateInDesignCSS(inDesignFormatting, frameMetrics) {\n        const fontSize = inDesignFormatting.fontSize || 12;\n        // Convert leading to CSS\n        const lineHeightInfo = this.convertLeadingToCSS(inDesignFormatting.leading, fontSize, inDesignFormatting.leadingType);\n        // Calculate first baseline offset for positioning\n        const firstBaselineOffset = this.calculateFirstBaselineOffset(inDesignFormatting.firstBaselineOffset || \"AscentOffset\", fontSize, lineHeightInfo.lineHeightPx);\n        return {\n            // Typography\n            fontSize: \"\".concat(fontSize, \"px\"),\n            lineHeight: lineHeightInfo.cssLineHeight,\n            fontFamily: inDesignFormatting.fontFamily || \"Arial, sans-serif\",\n            fontWeight: inDesignFormatting.fontWeight || \"normal\",\n            fontStyle: inDesignFormatting.fontStyle || \"normal\",\n            // Advanced typography\n            letterSpacing: inDesignFormatting.tracking ? \"\".concat(inDesignFormatting.tracking / 1000, \"em\") : \"normal\",\n            textAlign: inDesignFormatting.textAlign || \"left\",\n            color: inDesignFormatting.color || \"black\",\n            // Layout and positioning - minimal padding to avoid excessive top spacing\n            padding: \"\".concat(Math.min(-1, firstBaselineOffset * 0.3), \"px \").concat(frameMetrics.insets.right, \"px \").concat(frameMetrics.insets.bottom, \"px \").concat(frameMetrics.insets.left, \"px\"),\n            margin: 0,\n            // Overflow control\n            width: \"\".concat(frameMetrics.contentArea.width, \"px\"),\n            height: \"\".concat(frameMetrics.contentArea.height, \"px\"),\n            overflow: \"hidden\",\n            boxSizing: \"border-box\",\n            // Text layout optimization\n            whiteSpace: \"normal\",\n            wordWrap: \"break-word\",\n            overflowWrap: \"break-word\",\n            wordBreak: \"normal\",\n            // InDesign-specific adjustments\n            position: \"relative\",\n            top: frameMetrics.hasInsets ? \"\".concat(frameMetrics.offsetY, \"px\") : \"0\",\n            left: frameMetrics.hasInsets ? \"\".concat(frameMetrics.offsetX, \"px\") : \"0\",\n            // Debug info (can be removed in production)\n            \"--indesign-leading\": inDesignFormatting.leading,\n            \"--indesign-leading-type\": inDesignFormatting.leadingType,\n            \"--css-line-height\": lineHeightInfo.cssLineHeight,\n            \"--first-baseline-offset\": \"\".concat(firstBaselineOffset, \"px\")\n        };\n    }\n}\n// Export for use in other modules\nif ( true && module.exports) {\n    module.exports = InDesignTextMetrics;\n} else if (true) {\n    window.InDesignTextMetrics = InDesignTextMetrics;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YW5CLE9BQU8sRUFBQyxRQUFNO1lBQzVEWixNQUFNK0IsYUFBYWpCLFNBQVMsR0FBRyxHQUF3QixPQUFyQmlCLGFBQWFwQixPQUFPLEVBQUMsUUFBTTtZQUU3RCw0Q0FBNEM7WUFDNUMsc0JBQXNCa0YsbUJBQW1CN0UsT0FBTztZQUNoRCwyQkFBMkI2RSxtQkFBbUIzRSxXQUFXO1lBQ3pELHFCQUFxQmlELGVBQWVoRCxhQUFhO1lBQ2pELDJCQUEyQixHQUF1QixPQUFwQk8scUJBQW9CO1FBQ3BEO0lBQ0Y7QUFDRjtBQUVBLGtDQUFrQztBQUNsQyxJQUFJLEtBQWtCLElBQWVnRixPQUFPQyxPQUFPLEVBQUU7SUFDbkRELE9BQU9DLE9BQU8sR0FBR2xIO0FBQ25CLE9BQU8sSUFBSSxJQUFrQixFQUFhO0lBQ3hDbUgsT0FBT25ILG1CQUFtQixHQUFHQTtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvdXRpbHMvSW5EZXNpZ25UZXh0TWV0cmljcy5qcz83ZTVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBJbkRlc2lnblRleHRNZXRyaWNzLmpzIC0gUHJlY2lzZSB0ZXh0IG1lYXN1cmVtZW50IHV0aWxpdHkgZm9yIDE6MSBJbkRlc2lnbiBjb21wYXRpYmlsaXR5XHJcbiAqIEhhbmRsZXMgZm9udCBtZXRyaWNzLCBsZWFkaW5nIGNhbGN1bGF0aW9ucywgYW5kIHRleHQgZnJhbWUgaW5zZXRzIGV4YWN0bHkgbGlrZSBJbkRlc2lnblxyXG4gKi9cclxuXHJcbmNsYXNzIEluRGVzaWduVGV4dE1ldHJpY3Mge1xyXG4gIFxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBwcmVjaXNlIHRleHQgZnJhbWUgZGltZW5zaW9ucyBpbmNsdWRpbmcgSW5EZXNpZ24tc3BlY2lmaWMgaW5zZXRzXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHRleHRGcmFtZSAtIFRoZSB0ZXh0IGZyYW1lIGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge29iamVjdH0gdGV4dEZyYW1lUHJlZnMgLSBUZXh0IGZyYW1lIHByZWZlcmVuY2VzIGZyb20gSW5EZXNpZ25cclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBZGp1c3RlZCBmcmFtZSBkaW1lbnNpb25zXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGN1bGF0ZVRleHRGcmFtZUluc2V0cyh0ZXh0RnJhbWUsIHRleHRGcmFtZVByZWZzKSB7XHJcbiAgICAvLyBJbkRlc2lnbiBkZWZhdWx0IHRleHQgZnJhbWUgaW5zZXRzIChpbiBwb2ludHMpXHJcbiAgICBjb25zdCBERUZBVUxUX0lOU0VUUyA9IHtcclxuICAgICAgdG9wOiAwLFxyXG4gICAgICBib3R0b206IDAsXHJcbiAgICAgIGxlZnQ6IDAsXHJcbiAgICAgIHJpZ2h0OiAwXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGluc2V0cyBmcm9tIHByZWZlcmVuY2VzIGlmIGF2YWlsYWJsZVxyXG4gICAgY29uc3QgaW5zZXRzID0ge1xyXG4gICAgICB0b3A6IHRleHRGcmFtZVByZWZzPy5pbnNldFNwYWNpbmc/LnRvcCB8fCB0ZXh0RnJhbWVQcmVmcz8udGV4dEluc2V0cz8udG9wIHx8IERFRkFVTFRfSU5TRVRTLnRvcCxcclxuICAgICAgYm90dG9tOiB0ZXh0RnJhbWVQcmVmcz8uaW5zZXRTcGFjaW5nPy5ib3R0b20gfHwgdGV4dEZyYW1lUHJlZnM/LnRleHRJbnNldHM/LmJvdHRvbSB8fCBERUZBVUxUX0lOU0VUUy5ib3R0b20sXHJcbiAgICAgIGxlZnQ6IHRleHRGcmFtZVByZWZzPy5pbnNldFNwYWNpbmc/LmxlZnQgfHwgdGV4dEZyYW1lUHJlZnM/LnRleHRJbnNldHM/LmxlZnQgfHwgREVGQVVMVF9JTlNFVFMubGVmdCxcclxuICAgICAgcmlnaHQ6IHRleHRGcmFtZVByZWZzPy5pbnNldFNwYWNpbmc/LnJpZ2h0IHx8IHRleHRGcmFtZVByZWZzPy50ZXh0SW5zZXRzPy5yaWdodCB8fCBERUZBVUxUX0lOU0VUUy5yaWdodFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGNvbnRlbnQgYXJlYSAoYXZhaWxhYmxlIGZvciB0ZXh0KVxyXG4gICAgY29uc3QgY29udGVudEFyZWEgPSB7XHJcbiAgICAgIHdpZHRoOiBNYXRoLm1heCgwLCB0ZXh0RnJhbWUucG9zaXRpb24ud2lkdGggLSBpbnNldHMubGVmdCAtIGluc2V0cy5yaWdodCksXHJcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgdGV4dEZyYW1lLnBvc2l0aW9uLmhlaWdodCAtIGluc2V0cy50b3AgLSBpbnNldHMuYm90dG9tKSxcclxuICAgICAgb2Zmc2V0WDogaW5zZXRzLmxlZnQsXHJcbiAgICAgIG9mZnNldFk6IGluc2V0cy50b3BcclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9yaWdpbmFsRnJhbWU6IHRleHRGcmFtZS5wb3NpdGlvbixcclxuICAgICAgaW5zZXRzLFxyXG4gICAgICBjb250ZW50QXJlYSxcclxuICAgICAgaGFzSW5zZXRzOiBpbnNldHMudG9wID4gMCB8fCBpbnNldHMuYm90dG9tID4gMCB8fCBpbnNldHMubGVmdCA+IDAgfHwgaW5zZXRzLnJpZ2h0ID4gMFxyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBJbkRlc2lnbiBsZWFkaW5nIHRvIHByZWNpc2UgQ1NTIGxpbmUtaGVpZ2h0XHJcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBsZWFkaW5nIC0gSW5EZXNpZ24gbGVhZGluZyB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmb250U2l6ZSAtIEZvbnQgc2l6ZSBpbiBwb2ludHNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGVhZGluZ1R5cGUgLSBUeXBlIG9mIGxlYWRpbmcgKGF1dG8sIGFic29sdXRlLCBwZXJjZW50YWdlKVxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENTUy1jb21wYXRpYmxlIGxpbmUgaGVpZ2h0IGluZm9cclxuICAgKi9cclxuICBzdGF0aWMgY29udmVydExlYWRpbmdUb0NTUyhsZWFkaW5nLCBmb250U2l6ZSwgbGVhZGluZ1R5cGUgPSAnYXV0bycpIHtcclxuICAgIGxldCBjc3NMaW5lSGVpZ2h0O1xyXG4gICAgbGV0IGxpbmVIZWlnaHRQeDtcclxuICAgIFxyXG4gICAgc3dpdGNoIChsZWFkaW5nVHlwZSkge1xyXG4gICAgICBjYXNlICdhdXRvJzpcclxuICAgICAgICAvLyBJbkRlc2lnbiBhdXRvIGxlYWRpbmcgaXMgdHlwaWNhbGx5IDEyMCUgb2YgZm9udCBzaXplXHJcbiAgICAgICAgY3NzTGluZUhlaWdodCA9IDEuMjtcclxuICAgICAgICBsaW5lSGVpZ2h0UHggPSBmb250U2l6ZSAqIDEuMjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBcclxuICAgICAgY2FzZSAnYWJzb2x1dGUnOlxyXG4gICAgICAgIC8vIExlYWRpbmcgaXMgaW4gcG9pbnRzLCBjb252ZXJ0IHRvIGxpbmUtaGVpZ2h0IHJhdGlvXHJcbiAgICAgICAgaWYgKHR5cGVvZiBsZWFkaW5nID09PSAnbnVtYmVyJyAmJiBsZWFkaW5nID4gMCkge1xyXG4gICAgICAgICAgY3NzTGluZUhlaWdodCA9IE1hdGgubWF4KDAuOCwgbGVhZGluZyAvIGZvbnRTaXplKTtcclxuICAgICAgICAgIGxpbmVIZWlnaHRQeCA9IGxlYWRpbmc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNzc0xpbmVIZWlnaHQgPSAxLjI7XHJcbiAgICAgICAgICBsaW5lSGVpZ2h0UHggPSBmb250U2l6ZSAqIDEuMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ3BlcmNlbnRhZ2UnOlxyXG4gICAgICAgIC8vIExlYWRpbmcgaXMgcGVyY2VudGFnZS1iYXNlZFxyXG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KGxlYWRpbmcpIC8gMTAwO1xyXG4gICAgICAgIGNzc0xpbmVIZWlnaHQgPSBNYXRoLm1heCgwLjgsIHBlcmNlbnRhZ2UpO1xyXG4gICAgICAgIGxpbmVIZWlnaHRQeCA9IGZvbnRTaXplICogcGVyY2VudGFnZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjc3NMaW5lSGVpZ2h0ID0gMS4yO1xyXG4gICAgICAgIGxpbmVIZWlnaHRQeCA9IGZvbnRTaXplICogMS4yO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjc3NMaW5lSGVpZ2h0OiBNYXRoLnJvdW5kKGNzc0xpbmVIZWlnaHQgKiAxMDAwKSAvIDEwMDAsIC8vIFJvdW5kIHRvIDMgZGVjaW1hbCBwbGFjZXNcclxuICAgICAgbGluZUhlaWdodFB4OiBNYXRoLnJvdW5kKGxpbmVIZWlnaHRQeCAqIDEwMCkgLyAxMDAsICAgICAvLyBSb3VuZCB0byAyIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgIGxlYWRpbmdUeXBlLFxyXG4gICAgICBvcmlnaW5hbExlYWRpbmc6IGxlYWRpbmdcclxuICAgIH07XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBmaXJzdCBiYXNlbGluZSBvZmZzZXQgYWNjb3JkaW5nIHRvIEluRGVzaWduIHJ1bGVzXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpcnN0QmFzZWxpbmVPZmZzZXQgLSBJbkRlc2lnbiBmaXJzdCBiYXNlbGluZSBvZmZzZXQgc2V0dGluZ1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmb250U2l6ZSAtIEZvbnQgc2l6ZSBpbiBwb2ludHNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZUhlaWdodCAtIExpbmUgaGVpZ2h0IGluIHBvaW50c1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEZpcnN0IGJhc2VsaW5lIG9mZnNldCBpbiBwb2ludHNcclxuICAgKi9cclxuICBzdGF0aWMgY2FsY3VsYXRlRmlyc3RCYXNlbGluZU9mZnNldChmaXJzdEJhc2VsaW5lT2Zmc2V0LCBmb250U2l6ZSwgbGluZUhlaWdodCkge1xyXG4gICAgc3dpdGNoIChmaXJzdEJhc2VsaW5lT2Zmc2V0KSB7XHJcbiAgICAgIGNhc2UgJ0FzY2VudE9mZnNldCc6XHJcbiAgICAgICAgLy8gVGV4dCBzaXRzIGF0IG5hdHVyYWwgYXNjZW50IGxpbmUgKGRlZmF1bHQpXHJcbiAgICAgICAgcmV0dXJuIGZvbnRTaXplICogMC44OyAvLyBBcHByb3hpbWF0ZSBhc2NlbnQgZm9yIG1vc3QgZm9udHNcclxuICAgICAgICBcclxuICAgICAgY2FzZSAnQ2FwSGVpZ2h0T2Zmc2V0JzpcclxuICAgICAgICAvLyBUZXh0IHNpdHMgYXQgY2FwIGhlaWdodFxyXG4gICAgICAgIHJldHVybiBmb250U2l6ZSAqIDAuNzsgLy8gQXBwcm94aW1hdGUgY2FwIGhlaWdodCBmb3IgbW9zdCBmb250c1xyXG4gICAgICAgIFxyXG4gICAgICBjYXNlICdGaXhlZEhlaWdodCc6XHJcbiAgICAgICAgLy8gQ3VzdG9tIGZpeGVkIGhlaWdodCAtIHVzZSBsaW5lIGhlaWdodFxyXG4gICAgICAgIHJldHVybiBsaW5lSGVpZ2h0O1xyXG4gICAgICAgIFxyXG4gICAgICBjYXNlICdYSGVpZ2h0T2Zmc2V0JzpcclxuICAgICAgICAvLyBUZXh0IHNpdHMgYXQgeC1oZWlnaHRcclxuICAgICAgICByZXR1cm4gZm9udFNpemUgKiAwLjU7IC8vIEFwcHJveGltYXRlIHgtaGVpZ2h0IGZvciBtb3N0IGZvbnRzXHJcbiAgICAgICAgXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIGZvbnRTaXplICogMC44OyAvLyBEZWZhdWx0IHRvIGFzY2VudCBvZmZzZXRcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogTWVhc3VyZSB0ZXh0IGFjY3VyYXRlbHkgdXNpbmcgY2FudmFzIHdpdGggSW5EZXNpZ24tc3BlY2lmaWMgYWRqdXN0bWVudHNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgdG8gbWVhc3VyZVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0ZXh0U3R5bGVzIC0gQ29tcGxldGUgdGV4dCBzdHlsaW5nIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmcmFtZU1ldHJpY3MgLSBUZXh0IGZyYW1lIG1ldHJpY3NcclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBQcmVjaXNlIHRleHQgbWVhc3VyZW1lbnQgZGF0YVxyXG4gICAqL1xyXG4gIHN0YXRpYyBtZWFzdXJlVGV4dFByZWNpc2VseSh0ZXh0LCB0ZXh0U3R5bGVzLCBmcmFtZU1ldHJpY3MpIHtcclxuICAgIGlmICghdGV4dCB8fCB0ZXh0LnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXh0V2lkdGg6IDAsXHJcbiAgICAgICAgdGV4dEhlaWdodDogMCxcclxuICAgICAgICBsaW5lQ291bnQ6IDAsXHJcbiAgICAgICAgbGluZXM6IFtdLFxyXG4gICAgICAgIHdpbGxPdmVyZmxvdzogZmFsc2UsXHJcbiAgICAgICAgZml0czogdHJ1ZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgY2FudmFzIGZvciBtZWFzdXJlbWVudFxyXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIFxyXG4gICAgLy8gU2V0IGZvbnQgd2l0aCBwcm9wZXIgZmFsbGJhY2tzXHJcbiAgICBjb25zdCBmb250U2l6ZSA9IHBhcnNlRmxvYXQodGV4dFN0eWxlcy5mb250U2l6ZSkgfHwgMTI7XHJcbiAgICBjb25zdCBmb250RmFtaWx5ID0gdGV4dFN0eWxlcy5mb250RmFtaWx5IHx8ICdBcmlhbCwgc2Fucy1zZXJpZic7XHJcbiAgICBjb25zdCBmb250V2VpZ2h0ID0gdGV4dFN0eWxlcy5mb250V2VpZ2h0IHx8ICdub3JtYWwnO1xyXG4gICAgY29uc3QgZm9udFN0eWxlID0gdGV4dFN0eWxlcy5mb250U3R5bGUgfHwgJ25vcm1hbCc7XHJcbiAgICBcclxuICAgIGN0eC5mb250ID0gYCR7Zm9udFN0eWxlfSAke2ZvbnRXZWlnaHR9ICR7Zm9udFNpemV9cHggJHtmb250RmFtaWx5fWA7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBlZmZlY3RpdmUgY29udGVudCB3aWR0aCBhY2NvdW50aW5nIGZvciB0cmFja2luZ1xyXG4gICAgY29uc3QgdHJhY2tpbmcgPSB0ZXh0U3R5bGVzLnRyYWNraW5nIHx8IDA7XHJcbiAgICBjb25zdCB0cmFja2luZ0FkanVzdG1lbnQgPSB0cmFja2luZyAqIGZvbnRTaXplIC8gMTAwMDsgLy8gQ29udmVydCBlbSB0byBweFxyXG4gICAgY29uc3QgZWZmZWN0aXZlV2lkdGggPSBNYXRoLm1heCgxMCwgZnJhbWVNZXRyaWNzLmNvbnRlbnRBcmVhLndpZHRoIC0gTWF0aC5hYnModHJhY2tpbmdBZGp1c3RtZW50KSAtIDIpOyAvLyBMZWF2ZSAycHggbWFyZ2luXHJcbiAgICBcclxuICAgIC8vIFNwbGl0IHRleHQgaW50byB3b3JkcyBmb3IgYWNjdXJhdGUgd3JhcHBpbmcsIHByZXNlcnZpbmcgbGluZSBicmVha3NcclxuICAgIGNvbnN0IHdvcmRzID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJykuc3BsaXQoLyhcXHMrfFxcbikvKS5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDApO1xyXG4gICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgIGxldCBjdXJyZW50TGluZSA9ICcnO1xyXG4gICAgbGV0IGN1cnJlbnRMaW5lV2lkdGggPSAwO1xyXG4gICAgXHJcbiAgICAvLyBNZWFzdXJlIHNwYWNlIHdpZHRoIG9uY2VcclxuICAgIGNvbnN0IHNwYWNlV2lkdGggPSBjdHgubWVhc3VyZVRleHQoJyAnKS53aWR0aCArIHRyYWNraW5nQWRqdXN0bWVudDtcclxuICAgIFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCB3b3JkID0gd29yZHNbaV07XHJcbiAgICAgIFxyXG4gICAgICAvLyBIYW5kbGUgZXhwbGljaXQgbGluZSBicmVha3NcclxuICAgICAgaWYgKHdvcmQgPT09ICdcXG4nKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lKSB7XHJcbiAgICAgICAgICBsaW5lcy5wdXNoKHtcclxuICAgICAgICAgICAgdGV4dDogY3VycmVudExpbmUsXHJcbiAgICAgICAgICAgIHdpZHRoOiBjdXJyZW50TGluZVdpZHRoXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGN1cnJlbnRMaW5lID0gJyc7XHJcbiAgICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFNraXAgcHVyZSB3aGl0ZXNwYWNlIChleGNlcHQgc3BhY2VzKVxyXG4gICAgICBpZiAoL15cXHMrJC8udGVzdCh3b3JkKSAmJiB3b3JkICE9PSAnICcpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgd29yZFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHdvcmQpLndpZHRoICsgTWF0aC5tYXgoMCwgKHdvcmQubGVuZ3RoIC0gMSkpICogdHJhY2tpbmdBZGp1c3RtZW50O1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgd29yZCBmaXRzIG9uIGN1cnJlbnQgbGluZVxyXG4gICAgICBjb25zdCB3b3JkV2l0aFNwYWNlV2lkdGggPSBjdXJyZW50TGluZSAmJiB3b3JkICE9PSAnICcgPyB3b3JkV2lkdGggKyBzcGFjZVdpZHRoIDogd29yZFdpZHRoO1xyXG4gICAgICBcclxuICAgICAgaWYgKGN1cnJlbnRMaW5lICYmIHdvcmQgIT09ICcgJyAmJiAoY3VycmVudExpbmVXaWR0aCArIHdvcmRXaXRoU3BhY2VXaWR0aCA+IGVmZmVjdGl2ZVdpZHRoKSkge1xyXG4gICAgICAgIC8vIFdvcmQgZG9lc24ndCBmaXQsIHN0YXJ0IG5ldyBsaW5lXHJcbiAgICAgICAgbGluZXMucHVzaCh7XHJcbiAgICAgICAgICB0ZXh0OiBjdXJyZW50TGluZSxcclxuICAgICAgICAgIHdpZHRoOiBjdXJyZW50TGluZVdpZHRoXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY3VycmVudExpbmUgPSB3b3JkO1xyXG4gICAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB3b3JkV2lkdGg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gV29yZCBmaXRzLCBhZGQgdG8gY3VycmVudCBsaW5lXHJcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lICYmIHdvcmQgIT09ICcgJykge1xyXG4gICAgICAgICAgY3VycmVudExpbmUgKz0gJyAnICsgd29yZDtcclxuICAgICAgICAgIGN1cnJlbnRMaW5lV2lkdGggKz0gd29yZFdpdGhTcGFjZVdpZHRoO1xyXG4gICAgICAgIH0gZWxzZSBpZiAod29yZCAhPT0gJyAnKSB7XHJcbiAgICAgICAgICBjdXJyZW50TGluZSA9IHdvcmQ7XHJcbiAgICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gd29yZFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBZGQgdGhlIGxhc3QgbGluZVxyXG4gICAgaWYgKGN1cnJlbnRMaW5lKSB7XHJcbiAgICAgIGxpbmVzLnB1c2goe1xyXG4gICAgICAgIHRleHQ6IGN1cnJlbnRMaW5lLFxyXG4gICAgICAgIHdpZHRoOiBjdXJyZW50TGluZVdpZHRoXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgdGV4dCBoZWlnaHQgdXNpbmcgSW5EZXNpZ24tYWNjdXJhdGUgbGVhZGluZ1xyXG4gICAgY29uc3QgbGluZUhlaWdodEluZm8gPSB0aGlzLmNvbnZlcnRMZWFkaW5nVG9DU1MoXHJcbiAgICAgIHRleHRTdHlsZXMubGVhZGluZywgXHJcbiAgICAgIGZvbnRTaXplLCBcclxuICAgICAgdGV4dFN0eWxlcy5sZWFkaW5nVHlwZVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgY29uc3QgbGluZUNvdW50ID0gTWF0aC5tYXgoMSwgbGluZXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGZpcnN0QmFzZWxpbmVPZmZzZXQgPSB0aGlzLmNhbGN1bGF0ZUZpcnN0QmFzZWxpbmVPZmZzZXQoXHJcbiAgICAgIHRleHRTdHlsZXMuZmlyc3RCYXNlbGluZU9mZnNldCB8fCAnQXNjZW50T2Zmc2V0JyxcclxuICAgICAgZm9udFNpemUsXHJcbiAgICAgIGxpbmVIZWlnaHRJbmZvLmxpbmVIZWlnaHRQeFxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHRleHQgaGVpZ2h0IGluY2x1ZGluZyBmaXJzdCBiYXNlbGluZSBvZmZzZXRcclxuICAgIGNvbnN0IHRleHRIZWlnaHQgPSBmaXJzdEJhc2VsaW5lT2Zmc2V0ICsgKChsaW5lQ291bnQgLSAxKSAqIGxpbmVIZWlnaHRJbmZvLmxpbmVIZWlnaHRQeCk7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIHRleHQgb3ZlcmZsb3dzIHRoZSBhdmFpbGFibGUgaGVpZ2h0XHJcbiAgICBjb25zdCB3aWxsT3ZlcmZsb3cgPSB0ZXh0SGVpZ2h0ID4gZnJhbWVNZXRyaWNzLmNvbnRlbnRBcmVhLmhlaWdodDtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dFdpZHRoOiBNYXRoLm1heCguLi5saW5lcy5tYXAobGluZSA9PiBsaW5lLndpZHRoKSksXHJcbiAgICAgIHRleHRIZWlnaHQ6IE1hdGgucm91bmQodGV4dEhlaWdodCAqIDEwMCkgLyAxMDAsXHJcbiAgICAgIGxpbmVDb3VudCxcclxuICAgICAgbGluZXMsXHJcbiAgICAgIGxpbmVIZWlnaHRQeDogbGluZUhlaWdodEluZm8ubGluZUhlaWdodFB4LFxyXG4gICAgICBmaXJzdEJhc2VsaW5lT2Zmc2V0LFxyXG4gICAgICB3aWxsT3ZlcmZsb3csXHJcbiAgICAgIGZpdHM6ICF3aWxsT3ZlcmZsb3csXHJcbiAgICAgIGF2YWlsYWJsZUhlaWdodDogZnJhbWVNZXRyaWNzLmNvbnRlbnRBcmVhLmhlaWdodCxcclxuICAgICAgb3ZlcmZsb3dBbW91bnQ6IHdpbGxPdmVyZmxvdyA/IHRleHRIZWlnaHQgLSBmcmFtZU1ldHJpY3MuY29udGVudEFyZWEuaGVpZ2h0IDogMCxcclxuICAgICAgLy8gRGV0YWlsZWQgbWV0cmljcyBmb3IgZGVidWdnaW5nXHJcbiAgICAgIG1ldHJpY3M6IHtcclxuICAgICAgICBmb250U2l6ZSxcclxuICAgICAgICBsZWFkaW5nOiB0ZXh0U3R5bGVzLmxlYWRpbmcsXHJcbiAgICAgICAgbGVhZGluZ1R5cGU6IHRleHRTdHlsZXMubGVhZGluZ1R5cGUsXHJcbiAgICAgICAgZWZmZWN0aXZlV2lkdGgsXHJcbiAgICAgICAgdHJhY2tpbmc6IHRyYWNraW5nQWRqdXN0bWVudCxcclxuICAgICAgICBzcGFjZVdpZHRoXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBvcHRpbWFsIGZvbnQgc2l6ZSB0byBwcmV2ZW50IG92ZXJmbG93IHdoaWxlIG1haW50YWluaW5nIGRlc2lnbiBpbnRlZ3JpdHlcclxuICAgKiBAcGFyYW0ge29iamVjdH0gdGV4dE1lYXN1cmVtZW50IC0gUmVzdWx0IGZyb20gbWVhc3VyZVRleHRQcmVjaXNlbHlcclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3JpZ2luYWxTdHlsZXMgLSBPcmlnaW5hbCB0ZXh0IHN0eWxlc1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZWR1Y3Rpb24gLSBNYXhpbXVtIGZvbnQgc2l6ZSByZWR1Y3Rpb24gYWxsb3dlZCAoMC4wLTEuMClcclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBZGp1c3RlZCB0ZXh0IHN0eWxlcyBvciBudWxsIGlmIG5vIGFkanVzdG1lbnQgbmVlZGVkXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGN1bGF0ZU9wdGltYWxGb250U2l6ZSh0ZXh0TWVhc3VyZW1lbnQsIG9yaWdpbmFsU3R5bGVzLCBtYXhSZWR1Y3Rpb24gPSAwLjI1KSB7XHJcbiAgICBpZiAoIXRleHRNZWFzdXJlbWVudC53aWxsT3ZlcmZsb3cpIHtcclxuICAgICAgcmV0dXJuIG51bGw7IC8vIE5vIGFkanVzdG1lbnQgbmVlZGVkXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IG9yaWdpbmFsRm9udFNpemUgPSBwYXJzZUZsb2F0KG9yaWdpbmFsU3R5bGVzLmZvbnRTaXplKSB8fCAxMjtcclxuICAgIGNvbnN0IG92ZXJmbG93UmF0aW8gPSB0ZXh0TWVhc3VyZW1lbnQudGV4dEhlaWdodCAvIHRleHRNZWFzdXJlbWVudC5hdmFpbGFibGVIZWlnaHQ7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCfwn5SnIGNhbGN1bGF0ZU9wdGltYWxGb250U2l6ZTonLCB7XHJcbiAgICAgIG9yaWdpbmFsRm9udFNpemUsXHJcbiAgICAgIHRleHRIZWlnaHQ6IHRleHRNZWFzdXJlbWVudC50ZXh0SGVpZ2h0LFxyXG4gICAgICBhdmFpbGFibGVIZWlnaHQ6IHRleHRNZWFzdXJlbWVudC5hdmFpbGFibGVIZWlnaHQsXHJcbiAgICAgIG92ZXJmbG93UmF0aW8sXHJcbiAgICAgIG92ZXJmbG93QW1vdW50OiB0ZXh0TWVhc3VyZW1lbnQub3ZlcmZsb3dBbW91bnRcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgcmVxdWlyZWQgc2NhbGUgZmFjdG9yIHRvIGZpdCBleGFjdGx5XHJcbiAgICBsZXQgc2NhbGVGYWN0b3IgPSAxIC8gb3ZlcmZsb3dSYXRpbztcclxuICAgIFxyXG4gICAgLy8gQXBwbHkgbWF4aW11bSByZWR1Y3Rpb24gbGltaXQgdG8gcHJlc2VydmUgZGVzaWduIGludGVncml0eVxyXG4gICAgY29uc3QgbWluQWxsb3dlZFNjYWxlID0gMSAtIG1heFJlZHVjdGlvbjtcclxuICAgIGNvbnN0IGZpbmFsU2NhbGVGYWN0b3IgPSBNYXRoLm1heChtaW5BbGxvd2VkU2NhbGUsIHNjYWxlRmFjdG9yKTtcclxuICAgIFxyXG4gICAgY29uc3QgbmV3Rm9udFNpemUgPSBvcmlnaW5hbEZvbnRTaXplICogZmluYWxTY2FsZUZhY3RvcjtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ/CflKcgU2NhbGUgY2FsY3VsYXRpb246Jywge1xyXG4gICAgICByZXF1aXJlZFNjYWxlOiBzY2FsZUZhY3RvcixcclxuICAgICAgbWF4UmVkdWN0aW9uLFxyXG4gICAgICBtaW5BbGxvd2VkU2NhbGUsXHJcbiAgICAgIGZpbmFsU2NhbGVGYWN0b3IsXHJcbiAgICAgIG5ld0ZvbnRTaXplXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGlmIHRleHQgd2lsbCBzdGlsbCBvdmVyZmxvdyBhZnRlciBhZGp1c3RtZW50XHJcbiAgICBjb25zdCB3aWxsU3RpbGxPdmVyZmxvdyA9IGZpbmFsU2NhbGVGYWN0b3IgPiBzY2FsZUZhY3RvcjtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYWRqdXN0ZWRTdHlsZXM6IHtcclxuICAgICAgICAuLi5vcmlnaW5hbFN0eWxlcyxcclxuICAgICAgICBmb250U2l6ZTogYCR7TWF0aC5yb3VuZChuZXdGb250U2l6ZSAqIDEwMCkgLyAxMDB9cHhgLFxyXG4gICAgICAgIC8vIEFsc28gYWRqdXN0IGxpbmUtaGVpZ2h0IHByb3BvcnRpb25hbGx5IGlmIG5lZWRlZFxyXG4gICAgICAgIGxpbmVIZWlnaHQ6IG92ZXJmbG93UmF0aW8gPiAxLjMgPyBcclxuICAgICAgICAgIE1hdGgubWF4KDAuOSwgcGFyc2VGbG9hdChvcmlnaW5hbFN0eWxlcy5saW5lSGVpZ2h0IHx8ICcxLjInKSAqIGZpbmFsU2NhbGVGYWN0b3IpIDpcclxuICAgICAgICAgIG9yaWdpbmFsU3R5bGVzLmxpbmVIZWlnaHRcclxuICAgICAgfSxcclxuICAgICAgYWRqdXN0bWVudFR5cGU6IHdpbGxTdGlsbE92ZXJmbG93ID8gJ3BhcnRpYWxfZm9udF9yZWR1Y3Rpb24nIDogJ2ZvbnRfc2l6ZV9vcHRpbWl6ZWQnLFxyXG4gICAgICBzY2FsZUZhY3RvcjogZmluYWxTY2FsZUZhY3RvcixcclxuICAgICAgb3JpZ2luYWxGb250U2l6ZSxcclxuICAgICAgbmV3Rm9udFNpemU6IE1hdGgucm91bmQobmV3Rm9udFNpemUgKiAxMDApIC8gMTAwLFxyXG4gICAgICBzdGlsbE92ZXJmbG93czogd2lsbFN0aWxsT3ZlcmZsb3csXHJcbiAgICAgIHJlZHVjdGlvbkFwcGxpZWQ6ICgoMSAtIGZpbmFsU2NhbGVGYWN0b3IpICogMTAwKS50b0ZpeGVkKDEpICsgJyUnXHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBDU1Mgc3R5bGVzIHdpdGggSW5EZXNpZ24tYWNjdXJhdGUgdHlwb2dyYXBoeVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbkRlc2lnbkZvcm1hdHRpbmcgLSBGb3JtYXR0aW5nIG9iamVjdCBmcm9tIEluRGVzaWduXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGZyYW1lTWV0cmljcyAtIFRleHQgZnJhbWUgbWV0cmljc1xyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENTUyBzdHlsZXMgb3B0aW1pemVkIGZvciBJbkRlc2lnbiBjb21wYXRpYmlsaXR5XHJcbiAgICovXHJcbiAgc3RhdGljIGdlbmVyYXRlSW5EZXNpZ25DU1MoaW5EZXNpZ25Gb3JtYXR0aW5nLCBmcmFtZU1ldHJpY3MpIHtcclxuICAgIGNvbnN0IGZvbnRTaXplID0gaW5EZXNpZ25Gb3JtYXR0aW5nLmZvbnRTaXplIHx8IDEyO1xyXG4gICAgXHJcbiAgICAvLyBDb252ZXJ0IGxlYWRpbmcgdG8gQ1NTXHJcbiAgICBjb25zdCBsaW5lSGVpZ2h0SW5mbyA9IHRoaXMuY29udmVydExlYWRpbmdUb0NTUyhcclxuICAgICAgaW5EZXNpZ25Gb3JtYXR0aW5nLmxlYWRpbmcsXHJcbiAgICAgIGZvbnRTaXplLFxyXG4gICAgICBpbkRlc2lnbkZvcm1hdHRpbmcubGVhZGluZ1R5cGVcclxuICAgICk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBmaXJzdCBiYXNlbGluZSBvZmZzZXQgZm9yIHBvc2l0aW9uaW5nXHJcbiAgICBjb25zdCBmaXJzdEJhc2VsaW5lT2Zmc2V0ID0gdGhpcy5jYWxjdWxhdGVGaXJzdEJhc2VsaW5lT2Zmc2V0KFxyXG4gICAgICBpbkRlc2lnbkZvcm1hdHRpbmcuZmlyc3RCYXNlbGluZU9mZnNldCB8fCAnQXNjZW50T2Zmc2V0JyxcclxuICAgICAgZm9udFNpemUsXHJcbiAgICAgIGxpbmVIZWlnaHRJbmZvLmxpbmVIZWlnaHRQeFxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLy8gVHlwb2dyYXBoeVxyXG4gICAgICBmb250U2l6ZTogYCR7Zm9udFNpemV9cHhgLFxyXG4gICAgICBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0SW5mby5jc3NMaW5lSGVpZ2h0LFxyXG4gICAgICBmb250RmFtaWx5OiBpbkRlc2lnbkZvcm1hdHRpbmcuZm9udEZhbWlseSB8fCAnQXJpYWwsIHNhbnMtc2VyaWYnLFxyXG4gICAgICBmb250V2VpZ2h0OiBpbkRlc2lnbkZvcm1hdHRpbmcuZm9udFdlaWdodCB8fCAnbm9ybWFsJyxcclxuICAgICAgZm9udFN0eWxlOiBpbkRlc2lnbkZvcm1hdHRpbmcuZm9udFN0eWxlIHx8ICdub3JtYWwnLFxyXG4gICAgICBcclxuICAgICAgLy8gQWR2YW5jZWQgdHlwb2dyYXBoeVxyXG4gICAgICBsZXR0ZXJTcGFjaW5nOiBpbkRlc2lnbkZvcm1hdHRpbmcudHJhY2tpbmcgPyBgJHtpbkRlc2lnbkZvcm1hdHRpbmcudHJhY2tpbmcgLyAxMDAwfWVtYCA6ICdub3JtYWwnLFxyXG4gICAgICB0ZXh0QWxpZ246IGluRGVzaWduRm9ybWF0dGluZy50ZXh0QWxpZ24gfHwgJ2xlZnQnLFxyXG4gICAgICBjb2xvcjogaW5EZXNpZ25Gb3JtYXR0aW5nLmNvbG9yIHx8ICdibGFjaycsXHJcbiAgICAgIFxyXG4gICAgICAvLyBMYXlvdXQgYW5kIHBvc2l0aW9uaW5nIC0gbWluaW1hbCBwYWRkaW5nIHRvIGF2b2lkIGV4Y2Vzc2l2ZSB0b3Agc3BhY2luZ1xyXG4gICAgICBwYWRkaW5nOiBgJHtNYXRoLm1pbigtMSwgZmlyc3RCYXNlbGluZU9mZnNldCAqIDAuMyl9cHggJHtmcmFtZU1ldHJpY3MuaW5zZXRzLnJpZ2h0fXB4ICR7ZnJhbWVNZXRyaWNzLmluc2V0cy5ib3R0b219cHggJHtmcmFtZU1ldHJpY3MuaW5zZXRzLmxlZnR9cHhgLFxyXG4gICAgICBtYXJnaW46IDAsXHJcbiAgICAgIFxyXG4gICAgICAvLyBPdmVyZmxvdyBjb250cm9sXHJcbiAgICAgIHdpZHRoOiBgJHtmcmFtZU1ldHJpY3MuY29udGVudEFyZWEud2lkdGh9cHhgLFxyXG4gICAgICBoZWlnaHQ6IGAke2ZyYW1lTWV0cmljcy5jb250ZW50QXJlYS5oZWlnaHR9cHhgLFxyXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG4gICAgICBcclxuICAgICAgLy8gVGV4dCBsYXlvdXQgb3B0aW1pemF0aW9uXHJcbiAgICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnLFxyXG4gICAgICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnLFxyXG4gICAgICBvdmVyZmxvd1dyYXA6ICdicmVhay13b3JkJyxcclxuICAgICAgd29yZEJyZWFrOiAnbm9ybWFsJyxcclxuICAgICAgXHJcbiAgICAgIC8vIEluRGVzaWduLXNwZWNpZmljIGFkanVzdG1lbnRzXHJcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICB0b3A6IGZyYW1lTWV0cmljcy5oYXNJbnNldHMgPyBgJHtmcmFtZU1ldHJpY3Mub2Zmc2V0WX1weGAgOiAnMCcsXHJcbiAgICAgIGxlZnQ6IGZyYW1lTWV0cmljcy5oYXNJbnNldHMgPyBgJHtmcmFtZU1ldHJpY3Mub2Zmc2V0WH1weGAgOiAnMCcsXHJcbiAgICAgIFxyXG4gICAgICAvLyBEZWJ1ZyBpbmZvIChjYW4gYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uKVxyXG4gICAgICAnLS1pbmRlc2lnbi1sZWFkaW5nJzogaW5EZXNpZ25Gb3JtYXR0aW5nLmxlYWRpbmcsXHJcbiAgICAgICctLWluZGVzaWduLWxlYWRpbmctdHlwZSc6IGluRGVzaWduRm9ybWF0dGluZy5sZWFkaW5nVHlwZSxcclxuICAgICAgJy0tY3NzLWxpbmUtaGVpZ2h0JzogbGluZUhlaWdodEluZm8uY3NzTGluZUhlaWdodCxcclxuICAgICAgJy0tZmlyc3QtYmFzZWxpbmUtb2Zmc2V0JzogYCR7Zmlyc3RCYXNlbGluZU9mZnNldH1weGBcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgZm9yIHVzZSBpbiBvdGhlciBtb2R1bGVzXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gSW5EZXNpZ25UZXh0TWV0cmljcztcclxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gIHdpbmRvdy5JbkRlc2lnblRleHRNZXRyaWNzID0gSW5EZXNpZ25UZXh0TWV0cmljcztcclxufSAiXSwibmFtZXMiOlsiSW5EZXNpZ25UZXh0TWV0cmljcyIsImNhbGN1bGF0ZVRleHRGcmFtZUluc2V0cyIsInRleHRGcmFtZSIsInRleHRGcmFtZVByZWZzIiwiREVGQVVMVF9JTlNFVFMiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJpbnNldHMiLCJpbnNldFNwYWNpbmciLCJ0ZXh0SW5zZXRzIiwiY29udGVudEFyZWEiLCJ3aWR0aCIsIk1hdGgiLCJtYXgiLCJwb3NpdGlvbiIsImhlaWdodCIsIm9mZnNldFgiLCJvZmZzZXRZIiwib3JpZ2luYWxGcmFtZSIsImhhc0luc2V0cyIsImNvbnZlcnRMZWFkaW5nVG9DU1MiLCJsZWFkaW5nIiwiZm9udFNpemUiLCJsZWFkaW5nVHlwZSIsImNzc0xpbmVIZWlnaHQiLCJsaW5lSGVpZ2h0UHgiLCJwZXJjZW50YWdlIiwicGFyc2VGbG9hdCIsInJvdW5kIiwib3JpZ2luYWxMZWFkaW5nIiwiY2FsY3VsYXRlRmlyc3RCYXNlbGluZU9mZnNldCIsImZpcnN0QmFzZWxpbmVPZmZzZXQiLCJsaW5lSGVpZ2h0IiwibWVhc3VyZVRleHRQcmVjaXNlbHkiLCJ0ZXh0IiwidGV4dFN0eWxlcyIsImZyYW1lTWV0cmljcyIsInRyaW0iLCJ0ZXh0V2lkdGgiLCJ0ZXh0SGVpZ2h0IiwibGluZUNvdW50IiwibGluZXMiLCJ3aWxsT3ZlcmZsb3ciLCJmaXRzIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImZvbnRGYW1pbHkiLCJmb250V2VpZ2h0IiwiZm9udFN0eWxlIiwiZm9udCIsInRyYWNraW5nIiwidHJhY2tpbmdBZGp1c3RtZW50IiwiZWZmZWN0aXZlV2lkdGgiLCJhYnMiLCJ3b3JkcyIsInJlcGxhY2UiLCJzcGxpdCIsImZpbHRlciIsIndvcmQiLCJsZW5ndGgiLCJjdXJyZW50TGluZSIsImN1cnJlbnRMaW5lV2lkdGgiLCJzcGFjZVdpZHRoIiwibWVhc3VyZVRleHQiLCJpIiwicHVzaCIsInRlc3QiLCJ3b3JkV2lkdGgiLCJ3b3JkV2l0aFNwYWNlV2lkdGgiLCJsaW5lSGVpZ2h0SW5mbyIsIm1hcCIsImxpbmUiLCJhdmFpbGFibGVIZWlnaHQiLCJvdmVyZmxvd0Ftb3VudCIsIm1ldHJpY3MiLCJjYWxjdWxhdGVPcHRpbWFsRm9udFNpemUiLCJ0ZXh0TWVhc3VyZW1lbnQiLCJvcmlnaW5hbFN0eWxlcyIsIm1heFJlZHVjdGlvbiIsIm9yaWdpbmFsRm9udFNpemUiLCJvdmVyZmxvd1JhdGlvIiwiY29uc29sZSIsImxvZyIsInNjYWxlRmFjdG9yIiwibWluQWxsb3dlZFNjYWxlIiwiZmluYWxTY2FsZUZhY3RvciIsIm5ld0ZvbnRTaXplIiwicmVxdWlyZWRTY2FsZSIsIndpbGxTdGlsbE92ZXJmbG93IiwiYWRqdXN0ZWRTdHlsZXMiLCJhZGp1c3RtZW50VHlwZSIsInN0aWxsT3ZlcmZsb3dzIiwicmVkdWN0aW9uQXBwbGllZCIsInRvRml4ZWQiLCJnZW5lcmF0ZUluRGVzaWduQ1NTIiwiaW5EZXNpZ25Gb3JtYXR0aW5nIiwibGV0dGVyU3BhY2luZyIsInRleHRBbGlnbiIsImNvbG9yIiwicGFkZGluZyIsIm1pbiIsIm1hcmdpbiIsIm92ZXJmbG93IiwiYm94U2l6aW5nIiwid2hpdGVTcGFjZSIsIndvcmRXcmFwIiwib3ZlcmZsb3dXcmFwIiwid29yZEJyZWFrIiwibW9kdWxlIiwiZXhwb3J0cyIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/utils/InDesignTextMetrics.js\n"));

/***/ })

});