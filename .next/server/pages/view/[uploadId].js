"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/view/[uploadId]";
exports.ids = ["pages/view/[uploadId]"];
exports.modules = {

/***/ "./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2Fview%2F%5BuploadId%5D&preferredRegion=&absolutePagePath=.%2Fpages%5Cview%5C%5BuploadId%5D.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2Fview%2F%5BuploadId%5D&preferredRegion=&absolutePagePath=.%2Fpages%5Cview%5C%5BuploadId%5D.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getServerSideProps: () => (/* binding */ getServerSideProps),\n/* harmony export */   getStaticPaths: () => (/* binding */ getStaticPaths),\n/* harmony export */   getStaticProps: () => (/* binding */ getStaticProps),\n/* harmony export */   reportWebVitals: () => (/* binding */ reportWebVitals),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   unstable_getServerProps: () => (/* binding */ unstable_getServerProps),\n/* harmony export */   unstable_getServerSideProps: () => (/* binding */ unstable_getServerSideProps),\n/* harmony export */   unstable_getStaticParams: () => (/* binding */ unstable_getStaticParams),\n/* harmony export */   unstable_getStaticPaths: () => (/* binding */ unstable_getStaticPaths),\n/* harmony export */   unstable_getStaticProps: () => (/* binding */ unstable_getStaticProps)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages/module.compiled */ \"./node_modules/next/dist/server/future/route-modules/pages/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! private-next-pages/_document */ \"./node_modules/next/dist/pages/_document.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! private-next-pages/_app */ \"./node_modules/next/dist/pages/_app.js\");\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pages\\view\\[uploadId].js */ \"./pages/view/[uploadId].js\");\n\n\n\n// Import the app and document modules.\n\n\n// Import the userland code.\n\n// Re-export the component (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"default\"));\n// Re-export methods.\nconst getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"getStaticProps\");\nconst getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"getStaticPaths\");\nconst getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"getServerSideProps\");\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"config\");\nconst reportWebVitals = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"reportWebVitals\");\n// Re-export legacy methods.\nconst unstable_getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticProps\");\nconst unstable_getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticPaths\");\nconst unstable_getStaticParams = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticParams\");\nconst unstable_getServerProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getServerProps\");\nconst unstable_getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getServerSideProps\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES,\n        page: \"/view/[uploadId]\",\n        pathname: \"/view/[uploadId]\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    components: {\n        App: (private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default()),\n        Document: (private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default())\n    },\n    userland: _pages_view_uploadId_js__WEBPACK_IMPORTED_MODULE_5__\n});\n\n//# sourceMappingURL=pages.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTJnBhZ2U9JTJGdmlldyUyRiU1QnVwbG9hZElkJTVEJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlNUN2aWV3JTVDJTVCdXBsb2FkSWQlNUQuanMmYWJzb2x1dGVBcHBQYXRoPXByaXZhdGUtbmV4dC1wYWdlcyUyRl9hcHAmYWJzb2x1dGVEb2N1bWVudFBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2RvY3VtZW50Jm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0Y7QUFDaEM7QUFDTDtBQUMxRDtBQUNvRDtBQUNWO0FBQzFDO0FBQ3lEO0FBQ3pEO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyxvREFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyx1QkFBdUIsd0VBQUssQ0FBQyxvREFBUTtBQUNyQyx1QkFBdUIsd0VBQUssQ0FBQyxvREFBUTtBQUNyQywyQkFBMkIsd0VBQUssQ0FBQyxvREFBUTtBQUN6QyxlQUFlLHdFQUFLLENBQUMsb0RBQVE7QUFDN0Isd0JBQXdCLHdFQUFLLENBQUMsb0RBQVE7QUFDN0M7QUFDTyxnQ0FBZ0Msd0VBQUssQ0FBQyxvREFBUTtBQUM5QyxnQ0FBZ0Msd0VBQUssQ0FBQyxvREFBUTtBQUM5QyxpQ0FBaUMsd0VBQUssQ0FBQyxvREFBUTtBQUMvQyxnQ0FBZ0Msd0VBQUssQ0FBQyxvREFBUTtBQUM5QyxvQ0FBb0Msd0VBQUssQ0FBQyxvREFBUTtBQUN6RDtBQUNPLHdCQUF3Qix5R0FBZ0I7QUFDL0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXO0FBQ1gsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2lkbWwtdmlld2VyLz9lMTYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9wYWdlcy9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgYXBwIGFuZCBkb2N1bWVudCBtb2R1bGVzLlxuaW1wb3J0IERvY3VtZW50IGZyb20gXCJwcml2YXRlLW5leHQtcGFnZXMvX2RvY3VtZW50XCI7XG5pbXBvcnQgQXBwIGZyb20gXCJwcml2YXRlLW5leHQtcGFnZXMvX2FwcFwiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXNcXFxcdmlld1xcXFxbdXBsb2FkSWRdLmpzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGNvbXBvbmVudCAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IG1ldGhvZHMuXG5leHBvcnQgY29uc3QgZ2V0U3RhdGljUHJvcHMgPSBob2lzdCh1c2VybGFuZCwgXCJnZXRTdGF0aWNQcm9wc1wiKTtcbmV4cG9ydCBjb25zdCBnZXRTdGF0aWNQYXRocyA9IGhvaXN0KHVzZXJsYW5kLCBcImdldFN0YXRpY1BhdGhzXCIpO1xuZXhwb3J0IGNvbnN0IGdldFNlcnZlclNpZGVQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCBcImdldFNlcnZlclNpZGVQcm9wc1wiKTtcbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG5leHBvcnQgY29uc3QgcmVwb3J0V2ViVml0YWxzID0gaG9pc3QodXNlcmxhbmQsIFwicmVwb3J0V2ViVml0YWxzXCIpO1xuLy8gUmUtZXhwb3J0IGxlZ2FjeSBtZXRob2RzLlxuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFN0YXRpY1Byb3BzID0gaG9pc3QodXNlcmxhbmQsIFwidW5zdGFibGVfZ2V0U3RhdGljUHJvcHNcIik7XG5leHBvcnQgY29uc3QgdW5zdGFibGVfZ2V0U3RhdGljUGF0aHMgPSBob2lzdCh1c2VybGFuZCwgXCJ1bnN0YWJsZV9nZXRTdGF0aWNQYXRoc1wiKTtcbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9nZXRTdGF0aWNQYXJhbXMgPSBob2lzdCh1c2VybGFuZCwgXCJ1bnN0YWJsZV9nZXRTdGF0aWNQYXJhbXNcIik7XG5leHBvcnQgY29uc3QgdW5zdGFibGVfZ2V0U2VydmVyUHJvcHMgPSBob2lzdCh1c2VybGFuZCwgXCJ1bnN0YWJsZV9nZXRTZXJ2ZXJQcm9wc1wiKTtcbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9nZXRTZXJ2ZXJTaWRlUHJvcHMgPSBob2lzdCh1c2VybGFuZCwgXCJ1bnN0YWJsZV9nZXRTZXJ2ZXJTaWRlUHJvcHNcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc1JvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFUyxcbiAgICAgICAgcGFnZTogXCIvdmlldy9bdXBsb2FkSWRdXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi92aWV3L1t1cGxvYWRJZF1cIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBBcHAsXG4gICAgICAgIERvY3VtZW50XG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2Fview%2F%5BuploadId%5D&preferredRegion=&absolutePagePath=.%2Fpages%5Cview%5C%5BuploadId%5D.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "./lib/IDMLProcessor.js":
/*!******************************!*\
  !*** ./lib/IDMLProcessor.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Core modules\n\nconst IDMLXMLParser = __webpack_require__(/*! ./parsers/XMLParser */ \"./lib/parsers/XMLParser.js\");\nconst FileExtractor = __webpack_require__(/*! ./extractors/FileExtractor */ \"./lib/extractors/FileExtractor.js\");\nconst StyleParser = __webpack_require__(/*! ./parsers/StyleParser */ \"./lib/parsers/StyleParser.js\");\nconst StoryParser = __webpack_require__(/*! ./parsers/StoryParser */ \"./lib/parsers/StoryParser.js\");\nconst ElementParser = __webpack_require__(/*! ./parsers/ElementParser */ \"./lib/parsers/ElementParser.js\");\nconst DocumentParser = __webpack_require__(/*! ./parsers/DocumentParser */ \"./lib/parsers/DocumentParser.js\");\nconst ImageProcessor = __webpack_require__(/*! ./processors/ImageProcessor */ \"./lib/processors/ImageProcessor.js\");\nconst DebugAnalyzer = __webpack_require__(/*! ./debug/DebugAnalyzer */ \"./lib/debug/DebugAnalyzer.js\");\nconst IDMLUtils = __webpack_require__(/*! ./utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nconst UnitConverter = __webpack_require__(/*! ./utils/UnitConverter */ \"./lib/utils/UnitConverter.js\"); // ADDED: Unit conversion support\nconst NextFontMapper = __webpack_require__(/*! ./utils/NextFontMapper */ \"./lib/utils/NextFontMapper.js\"); // ADDED: Next.js font mapping\nconst path = __webpack_require__(/*! path */ \"path\");\nclass IDMLProcessor {\n    constructor(options = {}){\n        // Configuration options\n        this.config = {\n            dpi: options.dpi || 96,\n            convertToPixels: options.convertToPixels !== false,\n            preserveOriginalUnits: options.preserveOriginalUnits !== false,\n            enableNextFonts: options.enableNextFonts !== false,\n            ...options\n        };\n        // ADDED: Initialize unit converter with configured DPI first\n        this.unitConverter = new UnitConverter(this.config.dpi);\n        // ADDED: Initialize Next.js font mapper\n        this.fontMapper = new NextFontMapper();\n        // Initialize all modules\n        this.xmlParser = new IDMLXMLParser();\n        this.fileExtractor = new FileExtractor();\n        this.styleParser = new StyleParser(this.unitConverter); // ADDED: Pass UnitConverter\n        this.elementParser = new ElementParser(this.unitConverter); // ADDED: Pass UnitConverter\n        this.storyParser = new StoryParser(this.styleParser, this.unitConverter); // ADDED: Pass UnitConverter\n        this.documentParser = new DocumentParser(this.elementParser, this.styleParser, this.unitConverter); // FIXED: Pass StyleParser and UnitConverter\n        this.imageProcessor = new ImageProcessor(this.fileExtractor);\n        this.debugAnalyzer = new DebugAnalyzer();\n        // Maintain backward compatibility properties\n        this.document = null;\n        this.resources = {};\n        this.spreads = {};\n        this.stories = {};\n        this.masterSpreads = {};\n        this.documentInfo = {};\n        this.pageInfo = {};\n        this.elements = [];\n        this.layers = [];\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n    }\n    async processIDML(filePath) {\n        console.log(\"Processing IDML file:\", filePath);\n        try {\n            // Extract ZIP contents\n            const extractedData = await this.fileExtractor.extractIDMLContents(filePath);\n            console.log(`Extracted ${Object.keys(extractedData).length} files from IDML`);\n            // Parse main structure\n            await this.parseDocumentStructure(extractedData);\n            // Extract detailed information\n            await this.extractDetailedInformation();\n            // Return the correct structure\n            const documentData = {\n                document: {\n                    version: this.document?.[\"@_DOMVersion\"] || \"Unknown\",\n                    pageCount: Math.max(1, this.elements.length > 0 ? 1 : 0),\n                    name: this.document?.[\"@_Name\"] || \"Untitled\",\n                    dimensions: this.pageInfo.dimensions\n                },\n                // ADDED: Unit conversion information\n                unitConversion: {\n                    enabled: this.config.convertToPixels,\n                    dpi: this.config.dpi,\n                    originalUnits: this.pageInfo.dimensions?.units || \"Unknown\",\n                    convertedToPixels: !!this.pageInfo.dimensions?.pixelDimensions,\n                    conversionAppliedTo: [\n                        \"document dimensions\",\n                        \"element geometric bounds\",\n                        \"element positions\",\n                        \"font sizes\",\n                        \"spacing measurements\",\n                        \"page margins\",\n                        \"transform coordinates\",\n                        \"stroke weights\",\n                        \"text frame insets\"\n                    ].filter(Boolean)\n                },\n                // === ADD GLOBAL STYLE INFO ===\n                paragraphStyles: this.styleParser.getParagraphStyles(),\n                characterStyles: this.styleParser.getCharacterStyles(),\n                fontDefinitions: this.styleParser.getFontDefinitions(),\n                // === END GLOBAL STYLE INFO ===\n                pageInfo: {\n                    dimensions: this.pageInfo.dimensions,\n                    margins: this.pageInfo.margins\n                },\n                elements: this.elements.map((element)=>{\n                    if (!element.pixelPosition) {\n                        console.warn(`âš ï¸ Element ${element.self} is missing pixelPosition! This may cause rendering issues.`);\n                    }\n                    return {\n                        id: element.self,\n                        type: element.type,\n                        name: element.name,\n                        // ENFORCED: Only output pixelPosition (in pixels)\n                        pixelPosition: element.pixelPosition,\n                        fill: element.fillColor,\n                        stroke: element.strokeColor,\n                        strokeWeight: element.strokeWeight,\n                        parentStory: element.parentStory,\n                        linkedImage: element.linkedImage,\n                        visible: element.visible,\n                        locked: element.locked,\n                        // Content frame specific properties\n                        isContentFrame: element.isContentFrame || false,\n                        hasPlacedContent: element.hasPlacedContent || false,\n                        contentType: element.contentType || null,\n                        // Image positioning within frame\n                        imagePosition: element.imagePosition || null,\n                        placedContent: element.placedContent || null\n                    };\n                }),\n                stories: Object.keys(this.stories).reduce((acc, storyId)=>{\n                    const story = this.stories[storyId];\n                    if (story?.content?.plainText) {\n                        acc[storyId] = {\n                            text: story.content.plainText,\n                            wordCount: story.content.wordCount,\n                            characterCount: story.content.characterCount,\n                            textColor: story.content.textColor,\n                            hasLineBreaks: story.content.lineBreakInfo?.hasLineBreaks || false,\n                            lineBreakCount: story.content.lineBreakInfo?.lineBreakCount || 0,\n                            // Include resolved styling information\n                            styling: this.styleParser.getStoryStyleSummary(story),\n                            // Include formatted content with resolved formatting\n                            formattedContent: story.content.formattedContent || []\n                        };\n                    }\n                    return acc;\n                }, {}),\n                debug22: {\n                    measurementUnits: this.documentInfo.preferences?.viewPreferences?.horizontalMeasurementUnits,\n                    coordinateOffset: this.calculateCoordinateOffset(),\n                    contentFramesCount: this.elements.filter((el)=>el.isContentFrame).length,\n                    imagesLinkedCount: this.elements.filter((el)=>el.linkedImage && !el.linkedImage.isEmbedded).length,\n                    embeddedImagesCount: this.elements.filter((el)=>el.linkedImage && el.linkedImage.isEmbedded).length\n                }\n            };\n            // ADDED: Process Next.js fonts if enabled\n            if (this.config.enableNextFonts) {\n                console.log(\"\\uD83D\\uDD24 Processing Next.js fonts...\");\n                documentData.nextFonts = this.processNextFonts(documentData);\n                console.log(`âœ… Font processing completed. Mapped ${documentData.nextFonts.usedFonts.length} unique fonts`);\n            }\n            await this.addComprehensiveTextFormattingDebug();\n            console.log(\"âœ… IDML processing completed. Elements:\", documentData.elements.length);\n            return documentData;\n        } catch (error) {\n            console.error(\"Error processing IDML:\", error);\n            throw error;\n        }\n    }\n    async parseDocumentStructure(extractedData) {\n        console.log(\"Parsing document structure...\");\n        // Parse Resources\n        console.log(\"\\n\\uD83D\\uDCCB === PARSING RESOURCES ===\");\n        for (const [fileName, content] of Object.entries(extractedData)){\n            if (fileName.startsWith(\"Resources/\")) {\n                console.log(\"\\uD83D\\uDD0D Processing resource:\", fileName);\n                await this.styleParser.parseResourceFile(fileName, content, this.xmlParser);\n            }\n        }\n        // Parse document structure (spreads, master spreads)\n        await this.documentParser.parseDocumentStructure(extractedData, this.xmlParser);\n        // Parse Stories\n        console.log(\"\\n\\uD83D\\uDCDD === PARSING STORIES ===\");\n        let storyCount = 0;\n        for (const [fileName, content] of Object.entries(extractedData)){\n            if (fileName.startsWith(\"Stories/\")) {\n                console.log(\"\\uD83D\\uDD0D Found story file:\", fileName);\n                console.log(\"   Content length:\", content.length);\n                console.log(\"   Content preview:\", content.substring(0, 200));\n                storyCount++;\n                await this.storyParser.parseStoryFile(fileName, content, this.xmlParser);\n            }\n        }\n        console.log(`ðŸ“ Total stories processed: ${storyCount}`);\n        // Sync data from modules to maintain backward compatibility\n        this.syncModuleData();\n    }\n    syncModuleData() {\n        // Sync document data\n        this.document = this.documentParser.getDocument();\n        this.spreads = this.documentParser.getSpreads();\n        this.masterSpreads = this.documentParser.getMasterSpreads();\n        this.documentInfo = this.documentParser.getDocumentInfo();\n        this.layers = this.documentParser.getLayers();\n        // Sync style data\n        this.styles = this.styleParser.getStyles();\n        this.resources = this.styleParser.getResources();\n        // Sync story data\n        this.stories = this.storyParser.getStories();\n        // Sync element data\n        this.elements = this.elementParser.getElements();\n    }\n    async extractDetailedInformation() {\n        console.log(\"Extracting detailed information with enhanced processing...\");\n        await this.documentParser.extractDetailedInformation();\n        this.pageInfo = this.documentParser.getPageInfo();\n        // ADDED: Set document units on StoryParser after pageInfo is available\n        if (this.pageInfo?.dimensions?.units) {\n            const documentUnits = this.pageInfo.dimensions.units;\n            console.log(\"\\uD83D\\uDCD0 IDMLProcessor: Setting document units to\", documentUnits, \"on StoryParser\");\n            if (this.storyParser.setDocumentUnits) {\n                this.storyParser.setDocumentUnits(documentUnits);\n            }\n        }\n        console.log(\"âœ… Enhanced detailed information extracted\");\n    }\n    calculateCoordinateOffset() {\n        return this.documentParser.calculateCoordinateOffset();\n    }\n    async addComprehensiveTextFormattingDebug() {\n        return await this.debugAnalyzer.addComprehensiveTextFormattingDebug(this);\n    }\n    // Package processing methods\n    async processIDMLPackage(idmlFilePath, packageStructure, extractedImages = []) {\n        console.log(\"Processing IDML package:\", idmlFilePath);\n        try {\n            // Process the IDML file first\n            const documentData = await this.processIDML(idmlFilePath);\n            // Process linked images and update elements\n            await this.imageProcessor.processLinkedResources(documentData, packageStructure, extractedImages);\n            // Add package info\n            documentData.packageInfo = {\n                hasLinks: packageStructure.resourceMap?.size > 1,\n                hasFonts: false,\n                linksCount: Array.from(packageStructure.resourceMap?.keys() || []).filter((name)=>IDMLUtils.isImageFile(name)).length,\n                fontsCount: 0,\n                extractedImagesCount: extractedImages.length\n            };\n            return documentData;\n        } catch (error) {\n            console.error(\"Error processing IDML package:\", error);\n            throw error;\n        }\n    }\n    // Image processing methods\n    async extractAndSaveEmbeddedImages(idmlPath, uploadDir) {\n        return await this.fileExtractor.extractAndSaveEmbeddedImages(idmlPath, uploadDir);\n    }\n    async extractEmbeddedImageFromSpread(idmlPath, uploadDir) {\n        return await this.imageProcessor.extractEmbeddedImageFromSpread(idmlPath, uploadDir, this.xmlParser);\n    }\n    // Debug methods\n    async debugIDMLContents(idmlPath) {\n        return await this.fileExtractor.debugIDMLContents(idmlPath);\n    }\n    async debugIDMLContentsDetailed(idmlPath) {\n        return await this.fileExtractor.debugIDMLContentsDetailed(idmlPath);\n    }\n    async analyzeSpreadForImageReferences(idmlPath) {\n        return await this.imageProcessor.analyzeSpreadForImageReferences(idmlPath, this.xmlParser);\n    }\n    // Utility methods for backward compatibility\n    getPageContent(pageId) {\n        return this.documentParser.getPageContent(pageId);\n    }\n    // Getter methods for accessing module data\n    getStyles() {\n        return this.styleParser.getStyles();\n    }\n    getResources() {\n        return this.styleParser.getResources();\n    }\n    getStories() {\n        return this.storyParser.getStories();\n    }\n    getElements() {\n        return this.elementParser.getElements();\n    }\n    getSpreads() {\n        return this.documentParser.getSpreads();\n    }\n    getMasterSpreads() {\n        return this.documentParser.getMasterSpreads();\n    }\n    getDocumentInfo() {\n        return this.documentParser.getDocumentInfo();\n    }\n    getPageInfo() {\n        return this.documentParser.getPageInfo();\n    }\n    getLayers() {\n        return this.documentParser.getLayers();\n    }\n    // Module access for advanced usage\n    getXMLParser() {\n        return this.xmlParser;\n    }\n    getFileExtractor() {\n        return this.fileExtractor;\n    }\n    getStyleParser() {\n        return this.styleParser;\n    }\n    getStoryParser() {\n        return this.storyParser;\n    }\n    getElementParser() {\n        return this.elementParser;\n    }\n    getDocumentParser() {\n        return this.documentParser;\n    }\n    getImageProcessor() {\n        return this.imageProcessor;\n    }\n    getDebugAnalyzer() {\n        return this.debugAnalyzer;\n    }\n    /**\r\n   * Process Next.js fonts for the document\r\n   * @param {Object} documentData - Processed IDML document data\r\n   * @returns {Object} Next.js font configuration\r\n   */ processNextFonts(documentData) {\n        console.log(\"\\uD83D\\uDD24 Starting Next.js font processing...\");\n        // Clear previous cache\n        this.fontMapper.clearCache();\n        // Extract and map all unique fonts from the document\n        const mappedFonts = this.fontMapper.extractDocumentFonts(documentData);\n        // Process stories to add Next.js font info to formatted content\n        if (documentData.stories) {\n            Object.values(documentData.stories).forEach((story)=>{\n                if (story.formattedContent) {\n                    story.formattedContent.forEach((segment)=>{\n                        if (segment.formatting && segment.formatting.fontFamily) {\n                            const nextFontConfig = this.fontMapper.mapToNextFont(segment.formatting.fontFamily, segment.formatting.fontStyle, segment.formatting.fontSize);\n                            // Add Next.js font information to the segment\n                            segment.formatting.nextFont = nextFontConfig;\n                        }\n                    });\n                }\n            });\n        }\n        // Generate Next.js code snippets\n        const fontImports = this.fontMapper.generateNextFontImports();\n        const fontVariables = this.fontMapper.generateFontVariables();\n        const usedFontNames = Array.from(this.fontMapper.nextFontImports);\n        // Create CSS variables for all fonts\n        const cssVariables = mappedFonts.map((font)=>`${font.nextFontVariable}: ${font.fontFamilyFallback};`).join(\"\\n  \");\n        const nextFontConfig = {\n            // Mapped fonts\n            usedFonts: mappedFonts,\n            totalFonts: mappedFonts.length,\n            // Next.js code generation\n            imports: fontImports,\n            variables: fontVariables,\n            cssVariables: cssVariables,\n            usedFontNames: usedFontNames,\n            // Usage examples\n            examples: {\n                className: mappedFonts.length > 0 ? `\\${${mappedFonts[0].nextFont.toLowerCase()}.className}` : \"\",\n                variable: mappedFonts.length > 0 ? mappedFonts[0].nextFontVariable : \"\",\n                fontFamily: mappedFonts.length > 0 ? mappedFonts[0].fontFamily : \"\"\n            },\n            // Implementation guide\n            implementation: {\n                step1: \"Add the imports to your page or component\",\n                step2: \"Initialize the fonts with the provided variables\",\n                step3: \"Use the className or CSS variables in your components\",\n                step4: \"All fonts are loaded from Next.js, not user's machine\"\n            }\n        };\n        console.log(`ðŸŽ¯ Next.js font processing summary:`);\n        console.log(`   ðŸ“Š Total fonts mapped: ${mappedFonts.length}`);\n        console.log(`   ðŸ“¦ Google Fonts: ${mappedFonts.filter((f)=>f.isGoogleFont).length}`);\n        console.log(`   ðŸ–¥ï¸  System Fonts: ${mappedFonts.filter((f)=>f.isSystemFont).length}`);\n        console.log(`   ðŸ”— Unique Next.js fonts: ${usedFontNames.length}`);\n        return nextFontConfig;\n    }\n}\nmodule.exports = IDMLProcessor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxDQUFDLDBCQUEwQixFQUFFMkksWUFBWXRJLE1BQU0sQ0FBQyxDQUFDO1FBQzdETixRQUFRQyxHQUFHLENBQ1QsQ0FBQyxvQkFBb0IsRUFBRTJJLFlBQVlySCxNQUFNLENBQUMsQ0FBQ3dKLElBQU1BLEVBQUVDLFlBQVksRUFBRTFLLE1BQU0sQ0FBQyxDQUFDO1FBRTNFTixRQUFRQyxHQUFHLENBQ1QsQ0FBQyxzQkFBc0IsRUFBRTJJLFlBQVlySCxNQUFNLENBQUMsQ0FBQ3dKLElBQU1BLEVBQUVFLFlBQVksRUFBRTNLLE1BQU0sQ0FBQyxDQUFDO1FBRTdFTixRQUFRQyxHQUFHLENBQUMsQ0FBQyw0QkFBNEIsRUFBRTJKLGNBQWN0SixNQUFNLENBQUMsQ0FBQztRQUVqRSxPQUFPNkk7SUFDVDtBQUNGO0FBRUErQixPQUFPQyxPQUFPLEdBQUd0TiIsInNvdXJjZXMiOlsid2VicGFjazovL2lkbWwtdmlld2VyLy4vbGliL0lETUxQcm9jZXNzb3IuanM/MDg5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3JlIG1vZHVsZXNcclxuY29uc3QgSURNTFhNTFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvWE1MUGFyc2VyXCIpO1xyXG5jb25zdCBGaWxlRXh0cmFjdG9yID0gcmVxdWlyZShcIi4vZXh0cmFjdG9ycy9GaWxlRXh0cmFjdG9yXCIpO1xyXG5jb25zdCBTdHlsZVBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvU3R5bGVQYXJzZXJcIik7XHJcbmNvbnN0IFN0b3J5UGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9TdG9yeVBhcnNlclwiKTtcclxuY29uc3QgRWxlbWVudFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvRWxlbWVudFBhcnNlclwiKTtcclxuY29uc3QgRG9jdW1lbnRQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL0RvY3VtZW50UGFyc2VyXCIpO1xyXG5jb25zdCBJbWFnZVByb2Nlc3NvciA9IHJlcXVpcmUoXCIuL3Byb2Nlc3NvcnMvSW1hZ2VQcm9jZXNzb3JcIik7XHJcbmNvbnN0IERlYnVnQW5hbHl6ZXIgPSByZXF1aXJlKFwiLi9kZWJ1Zy9EZWJ1Z0FuYWx5emVyXCIpO1xyXG5jb25zdCBJRE1MVXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy9JRE1MVXRpbHNcIik7XHJcbmNvbnN0IFVuaXRDb252ZXJ0ZXIgPSByZXF1aXJlKFwiLi91dGlscy9Vbml0Q29udmVydGVyXCIpOyAvLyBBRERFRDogVW5pdCBjb252ZXJzaW9uIHN1cHBvcnRcclxuY29uc3QgTmV4dEZvbnRNYXBwZXIgPSByZXF1aXJlKFwiLi91dGlscy9OZXh0Rm9udE1hcHBlclwiKTsgLy8gQURERUQ6IE5leHQuanMgZm9udCBtYXBwaW5nXHJcblxyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcblxyXG5jbGFzcyBJRE1MUHJvY2Vzc29yIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIC8vIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgIGRwaTogb3B0aW9ucy5kcGkgfHwgOTYsIC8vIERlZmF1bHQgd2ViIERQSSwgMzAwLzYwMCBmb3IgcHJpbnRcclxuICAgICAgY29udmVydFRvUGl4ZWxzOiBvcHRpb25zLmNvbnZlcnRUb1BpeGVscyAhPT0gZmFsc2UsIC8vIERlZmF1bHQgdHJ1ZVxyXG4gICAgICBwcmVzZXJ2ZU9yaWdpbmFsVW5pdHM6IG9wdGlvbnMucHJlc2VydmVPcmlnaW5hbFVuaXRzICE9PSBmYWxzZSwgLy8gRGVmYXVsdCB0cnVlXHJcbiAgICAgIGVuYWJsZU5leHRGb250czogb3B0aW9ucy5lbmFibGVOZXh0Rm9udHMgIT09IGZhbHNlLCAvLyBEZWZhdWx0IHRydWUgLSBORVcgT1BUSU9OXHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFEREVEOiBJbml0aWFsaXplIHVuaXQgY29udmVydGVyIHdpdGggY29uZmlndXJlZCBEUEkgZmlyc3RcclxuICAgIHRoaXMudW5pdENvbnZlcnRlciA9IG5ldyBVbml0Q29udmVydGVyKHRoaXMuY29uZmlnLmRwaSk7XHJcblxyXG4gICAgLy8gQURERUQ6IEluaXRpYWxpemUgTmV4dC5qcyBmb250IG1hcHBlclxyXG4gICAgdGhpcy5mb250TWFwcGVyID0gbmV3IE5leHRGb250TWFwcGVyKCk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBhbGwgbW9kdWxlc1xyXG4gICAgdGhpcy54bWxQYXJzZXIgPSBuZXcgSURNTFhNTFBhcnNlcigpO1xyXG4gICAgdGhpcy5maWxlRXh0cmFjdG9yID0gbmV3IEZpbGVFeHRyYWN0b3IoKTtcclxuICAgIHRoaXMuc3R5bGVQYXJzZXIgPSBuZXcgU3R5bGVQYXJzZXIodGhpcy51bml0Q29udmVydGVyKTsgLy8gQURERUQ6IFBhc3MgVW5pdENvbnZlcnRlclxyXG4gICAgdGhpcy5lbGVtZW50UGFyc2VyID0gbmV3IEVsZW1lbnRQYXJzZXIodGhpcy51bml0Q29udmVydGVyKTsgLy8gQURERUQ6IFBhc3MgVW5pdENvbnZlcnRlclxyXG4gICAgdGhpcy5zdG9yeVBhcnNlciA9IG5ldyBTdG9yeVBhcnNlcih0aGlzLnN0eWxlUGFyc2VyLCB0aGlzLnVuaXRDb252ZXJ0ZXIpOyAvLyBBRERFRDogUGFzcyBVbml0Q29udmVydGVyXHJcbiAgICB0aGlzLmRvY3VtZW50UGFyc2VyID0gbmV3IERvY3VtZW50UGFyc2VyKFxyXG4gICAgICB0aGlzLmVsZW1lbnRQYXJzZXIsXHJcbiAgICAgIHRoaXMuc3R5bGVQYXJzZXIsXHJcbiAgICAgIHRoaXMudW5pdENvbnZlcnRlclxyXG4gICAgKTsgLy8gRklYRUQ6IFBhc3MgU3R5bGVQYXJzZXIgYW5kIFVuaXRDb252ZXJ0ZXJcclxuICAgIHRoaXMuaW1hZ2VQcm9jZXNzb3IgPSBuZXcgSW1hZ2VQcm9jZXNzb3IodGhpcy5maWxlRXh0cmFjdG9yKTtcclxuICAgIHRoaXMuZGVidWdBbmFseXplciA9IG5ldyBEZWJ1Z0FuYWx5emVyKCk7XHJcblxyXG4gICAgLy8gTWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eSBwcm9wZXJ0aWVzXHJcbiAgICB0aGlzLmRvY3VtZW50ID0gbnVsbDtcclxuICAgIHRoaXMucmVzb3VyY2VzID0ge307XHJcbiAgICB0aGlzLnNwcmVhZHMgPSB7fTtcclxuICAgIHRoaXMuc3RvcmllcyA9IHt9O1xyXG4gICAgdGhpcy5tYXN0ZXJTcHJlYWRzID0ge307XHJcbiAgICB0aGlzLmRvY3VtZW50SW5mbyA9IHt9O1xyXG4gICAgdGhpcy5wYWdlSW5mbyA9IHt9O1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5sYXllcnMgPSBbXTtcclxuICAgIHRoaXMuc3R5bGVzID0ge1xyXG4gICAgICBwYXJhZ3JhcGg6IHt9LFxyXG4gICAgICBjaGFyYWN0ZXI6IHt9LFxyXG4gICAgICBvYmplY3Q6IHt9LFxyXG4gICAgICB0YWJsZToge30sXHJcbiAgICAgIGNlbGw6IHt9LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHByb2Nlc3NJRE1MKGZpbGVQYXRoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlByb2Nlc3NpbmcgSURNTCBmaWxlOlwiLCBmaWxlUGF0aCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gRXh0cmFjdCBaSVAgY29udGVudHNcclxuICAgICAgY29uc3QgZXh0cmFjdGVkRGF0YSA9IGF3YWl0IHRoaXMuZmlsZUV4dHJhY3Rvci5leHRyYWN0SURNTENvbnRlbnRzKFxyXG4gICAgICAgIGZpbGVQYXRoXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBFeHRyYWN0ZWQgJHtPYmplY3Qua2V5cyhleHRyYWN0ZWREYXRhKS5sZW5ndGh9IGZpbGVzIGZyb20gSURNTGBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFBhcnNlIG1haW4gc3RydWN0dXJlXHJcbiAgICAgIGF3YWl0IHRoaXMucGFyc2VEb2N1bWVudFN0cnVjdHVyZShleHRyYWN0ZWREYXRhKTtcclxuXHJcbiAgICAgIC8vIEV4dHJhY3QgZGV0YWlsZWQgaW5mb3JtYXRpb25cclxuICAgICAgYXdhaXQgdGhpcy5leHRyYWN0RGV0YWlsZWRJbmZvcm1hdGlvbigpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHRoZSBjb3JyZWN0IHN0cnVjdHVyZVxyXG4gICAgICBjb25zdCBkb2N1bWVudERhdGEgPSB7XHJcbiAgICAgICAgZG9jdW1lbnQ6IHtcclxuICAgICAgICAgIHZlcnNpb246IHRoaXMuZG9jdW1lbnQ/LltcIkBfRE9NVmVyc2lvblwiXSB8fCBcIlVua25vd25cIixcclxuICAgICAgICAgIHBhZ2VDb3VudDogTWF0aC5tYXgoMSwgdGhpcy5lbGVtZW50cy5sZW5ndGggPiAwID8gMSA6IDApLFxyXG4gICAgICAgICAgbmFtZTogdGhpcy5kb2N1bWVudD8uW1wiQF9OYW1lXCJdIHx8IFwiVW50aXRsZWRcIixcclxuICAgICAgICAgIGRpbWVuc2lvbnM6IHRoaXMucGFnZUluZm8uZGltZW5zaW9ucyxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBBRERFRDogVW5pdCBjb252ZXJzaW9uIGluZm9ybWF0aW9uXHJcbiAgICAgICAgdW5pdENvbnZlcnNpb246IHtcclxuICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuY29uZmlnLmNvbnZlcnRUb1BpeGVscyxcclxuICAgICAgICAgIGRwaTogdGhpcy5jb25maWcuZHBpLFxyXG4gICAgICAgICAgb3JpZ2luYWxVbml0czogdGhpcy5wYWdlSW5mby5kaW1lbnNpb25zPy51bml0cyB8fCBcIlVua25vd25cIixcclxuICAgICAgICAgIGNvbnZlcnRlZFRvUGl4ZWxzOiAhIXRoaXMucGFnZUluZm8uZGltZW5zaW9ucz8ucGl4ZWxEaW1lbnNpb25zLFxyXG4gICAgICAgICAgY29udmVyc2lvbkFwcGxpZWRUbzogW1xyXG4gICAgICAgICAgICBcImRvY3VtZW50IGRpbWVuc2lvbnNcIixcclxuICAgICAgICAgICAgXCJlbGVtZW50IGdlb21ldHJpYyBib3VuZHNcIixcclxuICAgICAgICAgICAgXCJlbGVtZW50IHBvc2l0aW9uc1wiLFxyXG4gICAgICAgICAgICBcImZvbnQgc2l6ZXNcIixcclxuICAgICAgICAgICAgXCJzcGFjaW5nIG1lYXN1cmVtZW50c1wiLFxyXG4gICAgICAgICAgICBcInBhZ2UgbWFyZ2luc1wiLFxyXG4gICAgICAgICAgICBcInRyYW5zZm9ybSBjb29yZGluYXRlc1wiLFxyXG4gICAgICAgICAgICBcInN0cm9rZSB3ZWlnaHRzXCIsXHJcbiAgICAgICAgICAgIFwidGV4dCBmcmFtZSBpbnNldHNcIixcclxuICAgICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vID09PSBBREQgR0xPQkFMIFNUWUxFIElORk8gPT09XHJcbiAgICAgICAgcGFyYWdyYXBoU3R5bGVzOiB0aGlzLnN0eWxlUGFyc2VyLmdldFBhcmFncmFwaFN0eWxlcygpLFxyXG4gICAgICAgIGNoYXJhY3RlclN0eWxlczogdGhpcy5zdHlsZVBhcnNlci5nZXRDaGFyYWN0ZXJTdHlsZXMoKSxcclxuICAgICAgICBmb250RGVmaW5pdGlvbnM6IHRoaXMuc3R5bGVQYXJzZXIuZ2V0Rm9udERlZmluaXRpb25zKCksXHJcbiAgICAgICAgLy8gPT09IEVORCBHTE9CQUwgU1RZTEUgSU5GTyA9PT1cclxuXHJcbiAgICAgICAgcGFnZUluZm86IHtcclxuICAgICAgICAgIGRpbWVuc2lvbnM6IHRoaXMucGFnZUluZm8uZGltZW5zaW9ucyxcclxuICAgICAgICAgIG1hcmdpbnM6IHRoaXMucGFnZUluZm8ubWFyZ2lucyxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbGVtZW50czogdGhpcy5lbGVtZW50cy5tYXAoKGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgIGlmICghZWxlbWVudC5waXhlbFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgICBg4pqg77iPIEVsZW1lbnQgJHtlbGVtZW50LnNlbGZ9IGlzIG1pc3NpbmcgcGl4ZWxQb3NpdGlvbiEgVGhpcyBtYXkgY2F1c2UgcmVuZGVyaW5nIGlzc3Vlcy5gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogZWxlbWVudC5zZWxmLFxyXG4gICAgICAgICAgICB0eXBlOiBlbGVtZW50LnR5cGUsXHJcbiAgICAgICAgICAgIG5hbWU6IGVsZW1lbnQubmFtZSxcclxuICAgICAgICAgICAgLy8gRU5GT1JDRUQ6IE9ubHkgb3V0cHV0IHBpeGVsUG9zaXRpb24gKGluIHBpeGVscylcclxuICAgICAgICAgICAgcGl4ZWxQb3NpdGlvbjogZWxlbWVudC5waXhlbFBvc2l0aW9uLFxyXG4gICAgICAgICAgICBmaWxsOiBlbGVtZW50LmZpbGxDb2xvcixcclxuICAgICAgICAgICAgc3Ryb2tlOiBlbGVtZW50LnN0cm9rZUNvbG9yLFxyXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IGVsZW1lbnQuc3Ryb2tlV2VpZ2h0LFxyXG4gICAgICAgICAgICBwYXJlbnRTdG9yeTogZWxlbWVudC5wYXJlbnRTdG9yeSxcclxuICAgICAgICAgICAgbGlua2VkSW1hZ2U6IGVsZW1lbnQubGlua2VkSW1hZ2UsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGVsZW1lbnQudmlzaWJsZSxcclxuICAgICAgICAgICAgbG9ja2VkOiBlbGVtZW50LmxvY2tlZCxcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnRlbnQgZnJhbWUgc3BlY2lmaWMgcHJvcGVydGllc1xyXG4gICAgICAgICAgICBpc0NvbnRlbnRGcmFtZTogZWxlbWVudC5pc0NvbnRlbnRGcmFtZSB8fCBmYWxzZSxcclxuICAgICAgICAgICAgaGFzUGxhY2VkQ29udGVudDogZWxlbWVudC5oYXNQbGFjZWRDb250ZW50IHx8IGZhbHNlLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogZWxlbWVudC5jb250ZW50VHlwZSB8fCBudWxsLFxyXG5cclxuICAgICAgICAgICAgLy8gSW1hZ2UgcG9zaXRpb25pbmcgd2l0aGluIGZyYW1lXHJcbiAgICAgICAgICAgIGltYWdlUG9zaXRpb246IGVsZW1lbnQuaW1hZ2VQb3NpdGlvbiB8fCBudWxsLFxyXG4gICAgICAgICAgICBwbGFjZWRDb250ZW50OiBlbGVtZW50LnBsYWNlZENvbnRlbnQgfHwgbnVsbCxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICAgIHN0b3JpZXM6IE9iamVjdC5rZXlzKHRoaXMuc3RvcmllcykucmVkdWNlKChhY2MsIHN0b3J5SWQpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHN0b3J5ID0gdGhpcy5zdG9yaWVzW3N0b3J5SWRdO1xyXG4gICAgICAgICAgaWYgKHN0b3J5Py5jb250ZW50Py5wbGFpblRleHQpIHtcclxuICAgICAgICAgICAgYWNjW3N0b3J5SWRdID0ge1xyXG4gICAgICAgICAgICAgIHRleHQ6IHN0b3J5LmNvbnRlbnQucGxhaW5UZXh0LFxyXG4gICAgICAgICAgICAgIHdvcmRDb3VudDogc3RvcnkuY29udGVudC53b3JkQ291bnQsXHJcbiAgICAgICAgICAgICAgY2hhcmFjdGVyQ291bnQ6IHN0b3J5LmNvbnRlbnQuY2hhcmFjdGVyQ291bnQsXHJcbiAgICAgICAgICAgICAgdGV4dENvbG9yOiBzdG9yeS5jb250ZW50LnRleHRDb2xvcixcclxuICAgICAgICAgICAgICBoYXNMaW5lQnJlYWtzOlxyXG4gICAgICAgICAgICAgICAgc3RvcnkuY29udGVudC5saW5lQnJlYWtJbmZvPy5oYXNMaW5lQnJlYWtzIHx8IGZhbHNlLFxyXG4gICAgICAgICAgICAgIGxpbmVCcmVha0NvdW50OiBzdG9yeS5jb250ZW50LmxpbmVCcmVha0luZm8/LmxpbmVCcmVha0NvdW50IHx8IDAsXHJcblxyXG4gICAgICAgICAgICAgIC8vIEluY2x1ZGUgcmVzb2x2ZWQgc3R5bGluZyBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgIHN0eWxpbmc6IHRoaXMuc3R5bGVQYXJzZXIuZ2V0U3RvcnlTdHlsZVN1bW1hcnkoc3RvcnkpLFxyXG5cclxuICAgICAgICAgICAgICAvLyBJbmNsdWRlIGZvcm1hdHRlZCBjb250ZW50IHdpdGggcmVzb2x2ZWQgZm9ybWF0dGluZ1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQ6IHN0b3J5LmNvbnRlbnQuZm9ybWF0dGVkQ29udGVudCB8fCBbXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfSwge30pLFxyXG5cclxuICAgICAgICBkZWJ1ZzIyOiB7XHJcbiAgICAgICAgICBtZWFzdXJlbWVudFVuaXRzOlxyXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50SW5mby5wcmVmZXJlbmNlcz8udmlld1ByZWZlcmVuY2VzXHJcbiAgICAgICAgICAgICAgPy5ob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cyxcclxuICAgICAgICAgIGNvb3JkaW5hdGVPZmZzZXQ6IHRoaXMuY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldCgpLFxyXG4gICAgICAgICAgY29udGVudEZyYW1lc0NvdW50OiB0aGlzLmVsZW1lbnRzLmZpbHRlcigoZWwpID0+IGVsLmlzQ29udGVudEZyYW1lKVxyXG4gICAgICAgICAgICAubGVuZ3RoLFxyXG4gICAgICAgICAgaW1hZ2VzTGlua2VkQ291bnQ6IHRoaXMuZWxlbWVudHMuZmlsdGVyKFxyXG4gICAgICAgICAgICAoZWwpID0+IGVsLmxpbmtlZEltYWdlICYmICFlbC5saW5rZWRJbWFnZS5pc0VtYmVkZGVkXHJcbiAgICAgICAgICApLmxlbmd0aCxcclxuICAgICAgICAgIGVtYmVkZGVkSW1hZ2VzQ291bnQ6IHRoaXMuZWxlbWVudHMuZmlsdGVyKFxyXG4gICAgICAgICAgICAoZWwpID0+IGVsLmxpbmtlZEltYWdlICYmIGVsLmxpbmtlZEltYWdlLmlzRW1iZWRkZWRcclxuICAgICAgICAgICkubGVuZ3RoLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBBRERFRDogUHJvY2VzcyBOZXh0LmpzIGZvbnRzIGlmIGVuYWJsZWRcclxuICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZU5leHRGb250cykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UpCBQcm9jZXNzaW5nIE5leHQuanMgZm9udHMuLi5cIik7XHJcbiAgICAgICAgZG9jdW1lbnREYXRhLm5leHRGb250cyA9IHRoaXMucHJvY2Vzc05leHRGb250cyhkb2N1bWVudERhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYOKchSBGb250IHByb2Nlc3NpbmcgY29tcGxldGVkLiBNYXBwZWQgJHtkb2N1bWVudERhdGEubmV4dEZvbnRzLnVzZWRGb250cy5sZW5ndGh9IHVuaXF1ZSBmb250c2BcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhd2FpdCB0aGlzLmFkZENvbXByZWhlbnNpdmVUZXh0Rm9ybWF0dGluZ0RlYnVnKCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIuKchSBJRE1MIHByb2Nlc3NpbmcgY29tcGxldGVkLiBFbGVtZW50czpcIixcclxuICAgICAgICBkb2N1bWVudERhdGEuZWxlbWVudHMubGVuZ3RoXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gZG9jdW1lbnREYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHByb2Nlc3NpbmcgSURNTDpcIiwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHBhcnNlRG9jdW1lbnRTdHJ1Y3R1cmUoZXh0cmFjdGVkRGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coXCJQYXJzaW5nIGRvY3VtZW50IHN0cnVjdHVyZS4uLlwiKTtcclxuXHJcbiAgICAvLyBQYXJzZSBSZXNvdXJjZXNcclxuICAgIGNvbnNvbGUubG9nKFwiXFxu8J+TiyA9PT0gUEFSU0lORyBSRVNPVVJDRVMgPT09XCIpO1xyXG4gICAgZm9yIChjb25zdCBbZmlsZU5hbWUsIGNvbnRlbnRdIG9mIE9iamVjdC5lbnRyaWVzKGV4dHJhY3RlZERhdGEpKSB7XHJcbiAgICAgIGlmIChmaWxlTmFtZS5zdGFydHNXaXRoKFwiUmVzb3VyY2VzL1wiKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBQcm9jZXNzaW5nIHJlc291cmNlOlwiLCBmaWxlTmFtZSk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zdHlsZVBhcnNlci5wYXJzZVJlc291cmNlRmlsZShcclxuICAgICAgICAgIGZpbGVOYW1lLFxyXG4gICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgIHRoaXMueG1sUGFyc2VyXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhcnNlIGRvY3VtZW50IHN0cnVjdHVyZSAoc3ByZWFkcywgbWFzdGVyIHNwcmVhZHMpXHJcbiAgICBhd2FpdCB0aGlzLmRvY3VtZW50UGFyc2VyLnBhcnNlRG9jdW1lbnRTdHJ1Y3R1cmUoXHJcbiAgICAgIGV4dHJhY3RlZERhdGEsXHJcbiAgICAgIHRoaXMueG1sUGFyc2VyXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFBhcnNlIFN0b3JpZXNcclxuICAgIGNvbnNvbGUubG9nKFwiXFxu8J+TnSA9PT0gUEFSU0lORyBTVE9SSUVTID09PVwiKTtcclxuICAgIGxldCBzdG9yeUNvdW50ID0gMDtcclxuICAgIGZvciAoY29uc3QgW2ZpbGVOYW1lLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhleHRyYWN0ZWREYXRhKSkge1xyXG4gICAgICBpZiAoZmlsZU5hbWUuc3RhcnRzV2l0aChcIlN0b3JpZXMvXCIpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIEZvdW5kIHN0b3J5IGZpbGU6XCIsIGZpbGVOYW1lKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIiAgIENvbnRlbnQgbGVuZ3RoOlwiLCBjb250ZW50Lmxlbmd0aCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCIgICBDb250ZW50IHByZXZpZXc6XCIsIGNvbnRlbnQuc3Vic3RyaW5nKDAsIDIwMCkpO1xyXG4gICAgICAgIHN0b3J5Q291bnQrKztcclxuICAgICAgICBhd2FpdCB0aGlzLnN0b3J5UGFyc2VyLnBhcnNlU3RvcnlGaWxlKFxyXG4gICAgICAgICAgZmlsZU5hbWUsXHJcbiAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgdGhpcy54bWxQYXJzZXJcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TnSBUb3RhbCBzdG9yaWVzIHByb2Nlc3NlZDogJHtzdG9yeUNvdW50fWApO1xyXG5cclxuICAgIC8vIFN5bmMgZGF0YSBmcm9tIG1vZHVsZXMgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG4gICAgdGhpcy5zeW5jTW9kdWxlRGF0YSgpO1xyXG4gIH1cclxuXHJcbiAgc3luY01vZHVsZURhdGEoKSB7XHJcbiAgICAvLyBTeW5jIGRvY3VtZW50IGRhdGFcclxuICAgIHRoaXMuZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50UGFyc2VyLmdldERvY3VtZW50KCk7XHJcbiAgICB0aGlzLnNwcmVhZHMgPSB0aGlzLmRvY3VtZW50UGFyc2VyLmdldFNwcmVhZHMoKTtcclxuICAgIHRoaXMubWFzdGVyU3ByZWFkcyA9IHRoaXMuZG9jdW1lbnRQYXJzZXIuZ2V0TWFzdGVyU3ByZWFkcygpO1xyXG4gICAgdGhpcy5kb2N1bWVudEluZm8gPSB0aGlzLmRvY3VtZW50UGFyc2VyLmdldERvY3VtZW50SW5mbygpO1xyXG4gICAgdGhpcy5sYXllcnMgPSB0aGlzLmRvY3VtZW50UGFyc2VyLmdldExheWVycygpO1xyXG5cclxuICAgIC8vIFN5bmMgc3R5bGUgZGF0YVxyXG4gICAgdGhpcy5zdHlsZXMgPSB0aGlzLnN0eWxlUGFyc2VyLmdldFN0eWxlcygpO1xyXG4gICAgdGhpcy5yZXNvdXJjZXMgPSB0aGlzLnN0eWxlUGFyc2VyLmdldFJlc291cmNlcygpO1xyXG5cclxuICAgIC8vIFN5bmMgc3RvcnkgZGF0YVxyXG4gICAgdGhpcy5zdG9yaWVzID0gdGhpcy5zdG9yeVBhcnNlci5nZXRTdG9yaWVzKCk7XHJcblxyXG4gICAgLy8gU3luYyBlbGVtZW50IGRhdGFcclxuICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRQYXJzZXIuZ2V0RWxlbWVudHMoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3REZXRhaWxlZEluZm9ybWF0aW9uKCkge1xyXG4gICAgY29uc29sZS5sb2coXCJFeHRyYWN0aW5nIGRldGFpbGVkIGluZm9ybWF0aW9uIHdpdGggZW5oYW5jZWQgcHJvY2Vzc2luZy4uLlwiKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLmRvY3VtZW50UGFyc2VyLmV4dHJhY3REZXRhaWxlZEluZm9ybWF0aW9uKCk7XHJcbiAgICB0aGlzLnBhZ2VJbmZvID0gdGhpcy5kb2N1bWVudFBhcnNlci5nZXRQYWdlSW5mbygpO1xyXG5cclxuICAgIC8vIEFEREVEOiBTZXQgZG9jdW1lbnQgdW5pdHMgb24gU3RvcnlQYXJzZXIgYWZ0ZXIgcGFnZUluZm8gaXMgYXZhaWxhYmxlXHJcbiAgICBpZiAodGhpcy5wYWdlSW5mbz8uZGltZW5zaW9ucz8udW5pdHMpIHtcclxuICAgICAgY29uc3QgZG9jdW1lbnRVbml0cyA9IHRoaXMucGFnZUluZm8uZGltZW5zaW9ucy51bml0cztcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCLwn5OQIElETUxQcm9jZXNzb3I6IFNldHRpbmcgZG9jdW1lbnQgdW5pdHMgdG9cIixcclxuICAgICAgICBkb2N1bWVudFVuaXRzLFxyXG4gICAgICAgIFwib24gU3RvcnlQYXJzZXJcIlxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHRoaXMuc3RvcnlQYXJzZXIuc2V0RG9jdW1lbnRVbml0cykge1xyXG4gICAgICAgIHRoaXMuc3RvcnlQYXJzZXIuc2V0RG9jdW1lbnRVbml0cyhkb2N1bWVudFVuaXRzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwi4pyFIEVuaGFuY2VkIGRldGFpbGVkIGluZm9ybWF0aW9uIGV4dHJhY3RlZFwiKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudFBhcnNlci5jYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBhZGRDb21wcmVoZW5zaXZlVGV4dEZvcm1hdHRpbmdEZWJ1ZygpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmRlYnVnQW5hbHl6ZXIuYWRkQ29tcHJlaGVuc2l2ZVRleHRGb3JtYXR0aW5nRGVidWcodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvLyBQYWNrYWdlIHByb2Nlc3NpbmcgbWV0aG9kc1xyXG4gIGFzeW5jIHByb2Nlc3NJRE1MUGFja2FnZShcclxuICAgIGlkbWxGaWxlUGF0aCxcclxuICAgIHBhY2thZ2VTdHJ1Y3R1cmUsXHJcbiAgICBleHRyYWN0ZWRJbWFnZXMgPSBbXVxyXG4gICkge1xyXG4gICAgY29uc29sZS5sb2coXCJQcm9jZXNzaW5nIElETUwgcGFja2FnZTpcIiwgaWRtbEZpbGVQYXRoKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBQcm9jZXNzIHRoZSBJRE1MIGZpbGUgZmlyc3RcclxuICAgICAgY29uc3QgZG9jdW1lbnREYXRhID0gYXdhaXQgdGhpcy5wcm9jZXNzSURNTChpZG1sRmlsZVBhdGgpO1xyXG5cclxuICAgICAgLy8gUHJvY2VzcyBsaW5rZWQgaW1hZ2VzIGFuZCB1cGRhdGUgZWxlbWVudHNcclxuICAgICAgYXdhaXQgdGhpcy5pbWFnZVByb2Nlc3Nvci5wcm9jZXNzTGlua2VkUmVzb3VyY2VzKFxyXG4gICAgICAgIGRvY3VtZW50RGF0YSxcclxuICAgICAgICBwYWNrYWdlU3RydWN0dXJlLFxyXG4gICAgICAgIGV4dHJhY3RlZEltYWdlc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQWRkIHBhY2thZ2UgaW5mb1xyXG4gICAgICBkb2N1bWVudERhdGEucGFja2FnZUluZm8gPSB7XHJcbiAgICAgICAgaGFzTGlua3M6IHBhY2thZ2VTdHJ1Y3R1cmUucmVzb3VyY2VNYXA/LnNpemUgPiAxLFxyXG4gICAgICAgIGhhc0ZvbnRzOiBmYWxzZSxcclxuICAgICAgICBsaW5rc0NvdW50OiBBcnJheS5mcm9tKFxyXG4gICAgICAgICAgcGFja2FnZVN0cnVjdHVyZS5yZXNvdXJjZU1hcD8ua2V5cygpIHx8IFtdXHJcbiAgICAgICAgKS5maWx0ZXIoKG5hbWUpID0+IElETUxVdGlscy5pc0ltYWdlRmlsZShuYW1lKSkubGVuZ3RoLFxyXG4gICAgICAgIGZvbnRzQ291bnQ6IDAsXHJcbiAgICAgICAgZXh0cmFjdGVkSW1hZ2VzQ291bnQ6IGV4dHJhY3RlZEltYWdlcy5sZW5ndGgsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gZG9jdW1lbnREYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHByb2Nlc3NpbmcgSURNTCBwYWNrYWdlOlwiLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSW1hZ2UgcHJvY2Vzc2luZyBtZXRob2RzXHJcbiAgYXN5bmMgZXh0cmFjdEFuZFNhdmVFbWJlZGRlZEltYWdlcyhpZG1sUGF0aCwgdXBsb2FkRGlyKSB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5maWxlRXh0cmFjdG9yLmV4dHJhY3RBbmRTYXZlRW1iZWRkZWRJbWFnZXMoXHJcbiAgICAgIGlkbWxQYXRoLFxyXG4gICAgICB1cGxvYWREaXJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHRyYWN0RW1iZWRkZWRJbWFnZUZyb21TcHJlYWQoaWRtbFBhdGgsIHVwbG9hZERpcikge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaW1hZ2VQcm9jZXNzb3IuZXh0cmFjdEVtYmVkZGVkSW1hZ2VGcm9tU3ByZWFkKFxyXG4gICAgICBpZG1sUGF0aCxcclxuICAgICAgdXBsb2FkRGlyLFxyXG4gICAgICB0aGlzLnhtbFBhcnNlclxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIERlYnVnIG1ldGhvZHNcclxuICBhc3luYyBkZWJ1Z0lETUxDb250ZW50cyhpZG1sUGF0aCkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmlsZUV4dHJhY3Rvci5kZWJ1Z0lETUxDb250ZW50cyhpZG1sUGF0aCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZWJ1Z0lETUxDb250ZW50c0RldGFpbGVkKGlkbWxQYXRoKSB7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5maWxlRXh0cmFjdG9yLmRlYnVnSURNTENvbnRlbnRzRGV0YWlsZWQoaWRtbFBhdGgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYW5hbHl6ZVNwcmVhZEZvckltYWdlUmVmZXJlbmNlcyhpZG1sUGF0aCkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaW1hZ2VQcm9jZXNzb3IuYW5hbHl6ZVNwcmVhZEZvckltYWdlUmVmZXJlbmNlcyhcclxuICAgICAgaWRtbFBhdGgsXHJcbiAgICAgIHRoaXMueG1sUGFyc2VyXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gVXRpbGl0eSBtZXRob2RzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcbiAgZ2V0UGFnZUNvbnRlbnQocGFnZUlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudFBhcnNlci5nZXRQYWdlQ29udGVudChwYWdlSWQpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0dGVyIG1ldGhvZHMgZm9yIGFjY2Vzc2luZyBtb2R1bGUgZGF0YVxyXG4gIGdldFN0eWxlcygpIHtcclxuICAgIHJldHVybiB0aGlzLnN0eWxlUGFyc2VyLmdldFN0eWxlcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmVzb3VyY2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVQYXJzZXIuZ2V0UmVzb3VyY2VzKCk7XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yaWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcnlQYXJzZXIuZ2V0U3RvcmllcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0RWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50UGFyc2VyLmdldEVsZW1lbnRzKCk7XHJcbiAgfVxyXG5cclxuICBnZXRTcHJlYWRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRQYXJzZXIuZ2V0U3ByZWFkcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0TWFzdGVyU3ByZWFkcygpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50UGFyc2VyLmdldE1hc3RlclNwcmVhZHMoKTtcclxuICB9XHJcblxyXG4gIGdldERvY3VtZW50SW5mbygpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50UGFyc2VyLmdldERvY3VtZW50SW5mbygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0UGFnZUluZm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudFBhcnNlci5nZXRQYWdlSW5mbygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0TGF5ZXJzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRQYXJzZXIuZ2V0TGF5ZXJzKCk7XHJcbiAgfVxyXG5cclxuICAvLyBNb2R1bGUgYWNjZXNzIGZvciBhZHZhbmNlZCB1c2FnZVxyXG4gIGdldFhNTFBhcnNlcigpIHtcclxuICAgIHJldHVybiB0aGlzLnhtbFBhcnNlcjtcclxuICB9XHJcblxyXG4gIGdldEZpbGVFeHRyYWN0b3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5maWxlRXh0cmFjdG9yO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3R5bGVQYXJzZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZVBhcnNlcjtcclxuICB9XHJcblxyXG4gIGdldFN0b3J5UGFyc2VyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcnlQYXJzZXI7XHJcbiAgfVxyXG5cclxuICBnZXRFbGVtZW50UGFyc2VyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFBhcnNlcjtcclxuICB9XHJcblxyXG4gIGdldERvY3VtZW50UGFyc2VyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRQYXJzZXI7XHJcbiAgfVxyXG5cclxuICBnZXRJbWFnZVByb2Nlc3NvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmltYWdlUHJvY2Vzc29yO1xyXG4gIH1cclxuXHJcbiAgZ2V0RGVidWdBbmFseXplcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRlYnVnQW5hbHl6ZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcm9jZXNzIE5leHQuanMgZm9udHMgZm9yIHRoZSBkb2N1bWVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkb2N1bWVudERhdGEgLSBQcm9jZXNzZWQgSURNTCBkb2N1bWVudCBkYXRhXHJcbiAgICogQHJldHVybnMge09iamVjdH0gTmV4dC5qcyBmb250IGNvbmZpZ3VyYXRpb25cclxuICAgKi9cclxuICBwcm9jZXNzTmV4dEZvbnRzKGRvY3VtZW50RGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coXCLwn5SkIFN0YXJ0aW5nIE5leHQuanMgZm9udCBwcm9jZXNzaW5nLi4uXCIpO1xyXG5cclxuICAgIC8vIENsZWFyIHByZXZpb3VzIGNhY2hlXHJcbiAgICB0aGlzLmZvbnRNYXBwZXIuY2xlYXJDYWNoZSgpO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgYW5kIG1hcCBhbGwgdW5pcXVlIGZvbnRzIGZyb20gdGhlIGRvY3VtZW50XHJcbiAgICBjb25zdCBtYXBwZWRGb250cyA9IHRoaXMuZm9udE1hcHBlci5leHRyYWN0RG9jdW1lbnRGb250cyhkb2N1bWVudERhdGEpO1xyXG5cclxuICAgIC8vIFByb2Nlc3Mgc3RvcmllcyB0byBhZGQgTmV4dC5qcyBmb250IGluZm8gdG8gZm9ybWF0dGVkIGNvbnRlbnRcclxuICAgIGlmIChkb2N1bWVudERhdGEuc3Rvcmllcykge1xyXG4gICAgICBPYmplY3QudmFsdWVzKGRvY3VtZW50RGF0YS5zdG9yaWVzKS5mb3JFYWNoKChzdG9yeSkgPT4ge1xyXG4gICAgICAgIGlmIChzdG9yeS5mb3JtYXR0ZWRDb250ZW50KSB7XHJcbiAgICAgICAgICBzdG9yeS5mb3JtYXR0ZWRDb250ZW50LmZvckVhY2goKHNlZ21lbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuZm9ybWF0dGluZyAmJiBzZWdtZW50LmZvcm1hdHRpbmcuZm9udEZhbWlseSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5leHRGb250Q29uZmlnID0gdGhpcy5mb250TWFwcGVyLm1hcFRvTmV4dEZvbnQoXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50LmZvcm1hdHRpbmcuZm9udEZhbWlseSxcclxuICAgICAgICAgICAgICAgIHNlZ21lbnQuZm9ybWF0dGluZy5mb250U3R5bGUsXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50LmZvcm1hdHRpbmcuZm9udFNpemVcclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBBZGQgTmV4dC5qcyBmb250IGluZm9ybWF0aW9uIHRvIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgICAgc2VnbWVudC5mb3JtYXR0aW5nLm5leHRGb250ID0gbmV4dEZvbnRDb25maWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgTmV4dC5qcyBjb2RlIHNuaXBwZXRzXHJcbiAgICBjb25zdCBmb250SW1wb3J0cyA9IHRoaXMuZm9udE1hcHBlci5nZW5lcmF0ZU5leHRGb250SW1wb3J0cygpO1xyXG4gICAgY29uc3QgZm9udFZhcmlhYmxlcyA9IHRoaXMuZm9udE1hcHBlci5nZW5lcmF0ZUZvbnRWYXJpYWJsZXMoKTtcclxuICAgIGNvbnN0IHVzZWRGb250TmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuZm9udE1hcHBlci5uZXh0Rm9udEltcG9ydHMpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBDU1MgdmFyaWFibGVzIGZvciBhbGwgZm9udHNcclxuICAgIGNvbnN0IGNzc1ZhcmlhYmxlcyA9IG1hcHBlZEZvbnRzXHJcbiAgICAgIC5tYXAoKGZvbnQpID0+IGAke2ZvbnQubmV4dEZvbnRWYXJpYWJsZX06ICR7Zm9udC5mb250RmFtaWx5RmFsbGJhY2t9O2ApXHJcbiAgICAgIC5qb2luKFwiXFxuICBcIik7XHJcblxyXG4gICAgY29uc3QgbmV4dEZvbnRDb25maWcgPSB7XHJcbiAgICAgIC8vIE1hcHBlZCBmb250c1xyXG4gICAgICB1c2VkRm9udHM6IG1hcHBlZEZvbnRzLFxyXG4gICAgICB0b3RhbEZvbnRzOiBtYXBwZWRGb250cy5sZW5ndGgsXHJcblxyXG4gICAgICAvLyBOZXh0LmpzIGNvZGUgZ2VuZXJhdGlvblxyXG4gICAgICBpbXBvcnRzOiBmb250SW1wb3J0cyxcclxuICAgICAgdmFyaWFibGVzOiBmb250VmFyaWFibGVzLFxyXG4gICAgICBjc3NWYXJpYWJsZXM6IGNzc1ZhcmlhYmxlcyxcclxuICAgICAgdXNlZEZvbnROYW1lczogdXNlZEZvbnROYW1lcyxcclxuXHJcbiAgICAgIC8vIFVzYWdlIGV4YW1wbGVzXHJcbiAgICAgIGV4YW1wbGVzOiB7XHJcbiAgICAgICAgY2xhc3NOYW1lOlxyXG4gICAgICAgICAgbWFwcGVkRm9udHMubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICA/IGBcXCR7JHttYXBwZWRGb250c1swXS5uZXh0Rm9udC50b0xvd2VyQ2FzZSgpfS5jbGFzc05hbWV9YFxyXG4gICAgICAgICAgICA6IFwiXCIsXHJcbiAgICAgICAgdmFyaWFibGU6IG1hcHBlZEZvbnRzLmxlbmd0aCA+IDAgPyBtYXBwZWRGb250c1swXS5uZXh0Rm9udFZhcmlhYmxlIDogXCJcIixcclxuICAgICAgICBmb250RmFtaWx5OiBtYXBwZWRGb250cy5sZW5ndGggPiAwID8gbWFwcGVkRm9udHNbMF0uZm9udEZhbWlseSA6IFwiXCIsXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBJbXBsZW1lbnRhdGlvbiBndWlkZVxyXG4gICAgICBpbXBsZW1lbnRhdGlvbjoge1xyXG4gICAgICAgIHN0ZXAxOiBcIkFkZCB0aGUgaW1wb3J0cyB0byB5b3VyIHBhZ2Ugb3IgY29tcG9uZW50XCIsXHJcbiAgICAgICAgc3RlcDI6IFwiSW5pdGlhbGl6ZSB0aGUgZm9udHMgd2l0aCB0aGUgcHJvdmlkZWQgdmFyaWFibGVzXCIsXHJcbiAgICAgICAgc3RlcDM6IFwiVXNlIHRoZSBjbGFzc05hbWUgb3IgQ1NTIHZhcmlhYmxlcyBpbiB5b3VyIGNvbXBvbmVudHNcIixcclxuICAgICAgICBzdGVwNDogXCJBbGwgZm9udHMgYXJlIGxvYWRlZCBmcm9tIE5leHQuanMsIG5vdCB1c2VyJ3MgbWFjaGluZVwiLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+OryBOZXh0LmpzIGZvbnQgcHJvY2Vzc2luZyBzdW1tYXJ5OmApO1xyXG4gICAgY29uc29sZS5sb2coYCAgIPCfk4ogVG90YWwgZm9udHMgbWFwcGVkOiAke21hcHBlZEZvbnRzLmxlbmd0aH1gKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBgICAg8J+TpiBHb29nbGUgRm9udHM6ICR7bWFwcGVkRm9udHMuZmlsdGVyKChmKSA9PiBmLmlzR29vZ2xlRm9udCkubGVuZ3RofWBcclxuICAgICk7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYCAgIPCflqXvuI8gIFN5c3RlbSBGb250czogJHttYXBwZWRGb250cy5maWx0ZXIoKGYpID0+IGYuaXNTeXN0ZW1Gb250KS5sZW5ndGh9YFxyXG4gICAgKTtcclxuICAgIGNvbnNvbGUubG9nKGAgICDwn5SXIFVuaXF1ZSBOZXh0LmpzIGZvbnRzOiAke3VzZWRGb250TmFtZXMubGVuZ3RofWApO1xyXG5cclxuICAgIHJldHVybiBuZXh0Rm9udENvbmZpZztcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSURNTFByb2Nlc3NvcjtcclxuIl0sIm5hbWVzIjpbIklETUxYTUxQYXJzZXIiLCJyZXF1aXJlIiwiRmlsZUV4dHJhY3RvciIsIlN0eWxlUGFyc2VyIiwiU3RvcnlQYXJzZXIiLCJFbGVtZW50UGFyc2VyIiwiRG9jdW1lbnRQYXJzZXIiLCJJbWFnZVByb2Nlc3NvciIsIkRlYnVnQW5hbHl6ZXIiLCJJRE1MVXRpbHMiLCJVbml0Q29udmVydGVyIiwiTmV4dEZvbnRNYXBwZXIiLCJwYXRoIiwiSURNTFByb2Nlc3NvciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvbmZpZyIsImRwaSIsImNvbnZlcnRUb1BpeGVscyIsInByZXNlcnZlT3JpZ2luYWxVbml0cyIsImVuYWJsZU5leHRGb250cyIsInVuaXRDb252ZXJ0ZXIiLCJmb250TWFwcGVyIiwieG1sUGFyc2VyIiwiZmlsZUV4dHJhY3RvciIsInN0eWxlUGFyc2VyIiwiZWxlbWVudFBhcnNlciIsInN0b3J5UGFyc2VyIiwiZG9jdW1lbnRQYXJzZXIiLCJpbWFnZVByb2Nlc3NvciIsImRlYnVnQW5hbHl6ZXIiLCJkb2N1bWVudCIsInJlc291cmNlcyIsInNwcmVhZHMiLCJzdG9yaWVzIiwibWFzdGVyU3ByZWFkcyIsImRvY3VtZW50SW5mbyIsInBhZ2VJbmZvIiwiZWxlbWVudHMiLCJsYXllcnMiLCJzdHlsZXMiLCJwYXJhZ3JhcGgiLCJjaGFyYWN0ZXIiLCJvYmplY3QiLCJ0YWJsZSIsImNlbGwiLCJwcm9jZXNzSURNTCIsImZpbGVQYXRoIiwiY29uc29sZSIsImxvZyIsImV4dHJhY3RlZERhdGEiLCJleHRyYWN0SURNTENvbnRlbnRzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInBhcnNlRG9jdW1lbnRTdHJ1Y3R1cmUiLCJleHRyYWN0RGV0YWlsZWRJbmZvcm1hdGlvbiIsImRvY3VtZW50RGF0YSIsInZlcnNpb24iLCJwYWdlQ291bnQiLCJNYXRoIiwibWF4IiwibmFtZSIsImRpbWVuc2lvbnMiLCJ1bml0Q29udmVyc2lvbiIsImVuYWJsZWQiLCJvcmlnaW5hbFVuaXRzIiwidW5pdHMiLCJjb252ZXJ0ZWRUb1BpeGVscyIsInBpeGVsRGltZW5zaW9ucyIsImNvbnZlcnNpb25BcHBsaWVkVG8iLCJmaWx0ZXIiLCJCb29sZWFuIiwicGFyYWdyYXBoU3R5bGVzIiwiZ2V0UGFyYWdyYXBoU3R5bGVzIiwiY2hhcmFjdGVyU3R5bGVzIiwiZ2V0Q2hhcmFjdGVyU3R5bGVzIiwiZm9udERlZmluaXRpb25zIiwiZ2V0Rm9udERlZmluaXRpb25zIiwibWFyZ2lucyIsIm1hcCIsImVsZW1lbnQiLCJwaXhlbFBvc2l0aW9uIiwid2FybiIsInNlbGYiLCJpZCIsInR5cGUiLCJmaWxsIiwiZmlsbENvbG9yIiwic3Ryb2tlIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXZWlnaHQiLCJwYXJlbnRTdG9yeSIsImxpbmtlZEltYWdlIiwidmlzaWJsZSIsImxvY2tlZCIsImlzQ29udGVudEZyYW1lIiwiaGFzUGxhY2VkQ29udGVudCIsImNvbnRlbnRUeXBlIiwiaW1hZ2VQb3NpdGlvbiIsInBsYWNlZENvbnRlbnQiLCJyZWR1Y2UiLCJhY2MiLCJzdG9yeUlkIiwic3RvcnkiLCJjb250ZW50IiwicGxhaW5UZXh0IiwidGV4dCIsIndvcmRDb3VudCIsImNoYXJhY3RlckNvdW50IiwidGV4dENvbG9yIiwiaGFzTGluZUJyZWFrcyIsImxpbmVCcmVha0luZm8iLCJsaW5lQnJlYWtDb3VudCIsInN0eWxpbmciLCJnZXRTdG9yeVN0eWxlU3VtbWFyeSIsImZvcm1hdHRlZENvbnRlbnQiLCJkZWJ1ZzIyIiwibWVhc3VyZW1lbnRVbml0cyIsInByZWZlcmVuY2VzIiwidmlld1ByZWZlcmVuY2VzIiwiaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHMiLCJjb29yZGluYXRlT2Zmc2V0IiwiY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldCIsImNvbnRlbnRGcmFtZXNDb3VudCIsImVsIiwiaW1hZ2VzTGlua2VkQ291bnQiLCJpc0VtYmVkZGVkIiwiZW1iZWRkZWRJbWFnZXNDb3VudCIsIm5leHRGb250cyIsInByb2Nlc3NOZXh0Rm9udHMiLCJ1c2VkRm9udHMiLCJhZGRDb21wcmVoZW5zaXZlVGV4dEZvcm1hdHRpbmdEZWJ1ZyIsImVycm9yIiwiZmlsZU5hbWUiLCJlbnRyaWVzIiwic3RhcnRzV2l0aCIsInBhcnNlUmVzb3VyY2VGaWxlIiwic3RvcnlDb3VudCIsInN1YnN0cmluZyIsInBhcnNlU3RvcnlGaWxlIiwic3luY01vZHVsZURhdGEiLCJnZXREb2N1bWVudCIsImdldFNwcmVhZHMiLCJnZXRNYXN0ZXJTcHJlYWRzIiwiZ2V0RG9jdW1lbnRJbmZvIiwiZ2V0TGF5ZXJzIiwiZ2V0U3R5bGVzIiwiZ2V0UmVzb3VyY2VzIiwiZ2V0U3RvcmllcyIsImdldEVsZW1lbnRzIiwiZ2V0UGFnZUluZm8iLCJkb2N1bWVudFVuaXRzIiwic2V0RG9jdW1lbnRVbml0cyIsInByb2Nlc3NJRE1MUGFja2FnZSIsImlkbWxGaWxlUGF0aCIsInBhY2thZ2VTdHJ1Y3R1cmUiLCJleHRyYWN0ZWRJbWFnZXMiLCJwcm9jZXNzTGlua2VkUmVzb3VyY2VzIiwicGFja2FnZUluZm8iLCJoYXNMaW5rcyIsInJlc291cmNlTWFwIiwic2l6ZSIsImhhc0ZvbnRzIiwibGlua3NDb3VudCIsIkFycmF5IiwiZnJvbSIsImlzSW1hZ2VGaWxlIiwiZm9udHNDb3VudCIsImV4dHJhY3RlZEltYWdlc0NvdW50IiwiZXh0cmFjdEFuZFNhdmVFbWJlZGRlZEltYWdlcyIsImlkbWxQYXRoIiwidXBsb2FkRGlyIiwiZXh0cmFjdEVtYmVkZGVkSW1hZ2VGcm9tU3ByZWFkIiwiZGVidWdJRE1MQ29udGVudHMiLCJkZWJ1Z0lETUxDb250ZW50c0RldGFpbGVkIiwiYW5hbHl6ZVNwcmVhZEZvckltYWdlUmVmZXJlbmNlcyIsImdldFBhZ2VDb250ZW50IiwicGFnZUlkIiwiZ2V0WE1MUGFyc2VyIiwiZ2V0RmlsZUV4dHJhY3RvciIsImdldFN0eWxlUGFyc2VyIiwiZ2V0U3RvcnlQYXJzZXIiLCJnZXRFbGVtZW50UGFyc2VyIiwiZ2V0RG9jdW1lbnRQYXJzZXIiLCJnZXRJbWFnZVByb2Nlc3NvciIsImdldERlYnVnQW5hbHl6ZXIiLCJjbGVhckNhY2hlIiwibWFwcGVkRm9udHMiLCJleHRyYWN0RG9jdW1lbnRGb250cyIsInZhbHVlcyIsImZvckVhY2giLCJzZWdtZW50IiwiZm9ybWF0dGluZyIsImZvbnRGYW1pbHkiLCJuZXh0Rm9udENvbmZpZyIsIm1hcFRvTmV4dEZvbnQiLCJmb250U3R5bGUiLCJmb250U2l6ZSIsIm5leHRGb250IiwiZm9udEltcG9ydHMiLCJnZW5lcmF0ZU5leHRGb250SW1wb3J0cyIsImZvbnRWYXJpYWJsZXMiLCJnZW5lcmF0ZUZvbnRWYXJpYWJsZXMiLCJ1c2VkRm9udE5hbWVzIiwibmV4dEZvbnRJbXBvcnRzIiwiY3NzVmFyaWFibGVzIiwiZm9udCIsIm5leHRGb250VmFyaWFibGUiLCJmb250RmFtaWx5RmFsbGJhY2siLCJqb2luIiwidG90YWxGb250cyIsImltcG9ydHMiLCJ2YXJpYWJsZXMiLCJleGFtcGxlcyIsImNsYXNzTmFtZSIsInRvTG93ZXJDYXNlIiwidmFyaWFibGUiLCJpbXBsZW1lbnRhdGlvbiIsInN0ZXAxIiwic3RlcDIiLCJzdGVwMyIsInN0ZXA0IiwiZiIsImlzR29vZ2xlRm9udCIsImlzU3lzdGVtRm9udCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/IDMLProcessor.js\n");

/***/ }),

/***/ "./lib/debug/DebugAnalyzer.js":
/*!************************************!*\
  !*** ./lib/debug/DebugAnalyzer.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass DebugAnalyzer {\n    constructor(){\n        this.debugData = {};\n    }\n    async addComprehensiveTextFormattingDebug(processor) {\n        console.log(\"\\n\\uD83D\\uDD0D ======= COMPREHENSIVE TEXT FORMATTING DEBUG =======\");\n        const debugInfo = {\n            timestamp: new Date().toISOString(),\n            totalStories: Object.keys(processor.stories || {}).length,\n            totalElements: processor.elements ? processor.elements.length : 0,\n            styleDefinitions: processor.styleParser ? processor.styleParser.getStyles() : {},\n            detailedStoryAnalysis: {},\n            spreadElementAnalysis: {},\n            resourcesAnalysis: {},\n            xmlStructureAnalysis: {},\n            formattingAttributeMapping: {},\n            missingFormattingReasons: []\n        };\n        // 1. ANALYZE STORY CONTENT IN EXTREME DETAIL\n        console.log(\"\\n\\uD83D\\uDCDD === DETAILED STORY CONTENT ANALYSIS ===\");\n        if (processor.storyParser && processor.storyParser.getStories) {\n            const stories = processor.storyParser.getStories();\n            for (const [storyId, story] of Object.entries(stories)){\n                console.log(`\\n--- STORY ${storyId} DEEP DIVE ---`);\n                debugInfo.detailedStoryAnalysis[storyId] = {\n                    storyStructure: this.analyzeStoryStructure(story),\n                    formattingExtraction: this.analyzeFormattingExtraction(story),\n                    xmlAttributes: this.extractAllXMLAttributes(story),\n                    nestedElements: this.findNestedFormattingElements(story),\n                    characterStyleRanges: this.extractCharacterStyleRanges(story),\n                    paragraphStyleRanges: this.extractParagraphStyleRanges(story),\n                    directFormattingAttributes: this.extractDirectFormattingAttributes(story),\n                    styleReferences: this.extractStyleReferences(story)\n                };\n            }\n        }\n        // 2. ANALYZE SPREAD ELEMENTS FOR TEXT FRAMES\n        if (processor.spreads) {\n            for (const [spreadId, spread] of Object.entries(processor.spreads)){\n                debugInfo.spreadElementAnalysis[spreadId] = {\n                    textFrames: spread.pageItems?.filter((item)=>item.type === \"TextFrame\") || [],\n                    textFrameDetails: this.analyzeTextFrameFormatting(spread.pageItems || [])\n                };\n            }\n        }\n        // 3. ANALYZE RESOURCES AND STYLE DEFINITIONS\n        if (processor.styleParser) {\n            debugInfo.resourcesAnalysis = {\n                paragraphStyles: this.analyzeParagraphStyles(processor.styleParser),\n                characterStyles: this.analyzeCharacterStyles(processor.styleParser),\n                styleHierarchy: this.analyzeStyleHierarchy(processor.styleParser),\n                fontDefinitions: this.analyzeFontDefinitions(processor.styleParser)\n            };\n        }\n        // 4. ANALYZE XML STRUCTURE FOR FORMATTING ATTRIBUTES\n        debugInfo.xmlStructureAnalysis = this.performXMLStructureAnalysis(processor);\n        // 5. CREATE FORMATTING ATTRIBUTE MAPPING\n        debugInfo.formattingAttributeMapping = this.createFormattingAttributeMapping();\n        // 6. IDENTIFY MISSING FORMATTING REASONS\n        debugInfo.missingFormattingReasons = this.identifyMissingFormattingReasons(processor);\n        // 7. SAVE DEBUG INFO TO FILE\n        const debugFileName = `idml-text-formatting-debug-${Date.now()}.json`;\n        IDMLUtils.saveDebugInfo(debugInfo, debugFileName);\n        console.log(`\\nâœ… Comprehensive debug completed. Check file: ${debugFileName}`);\n        this.debugData = debugInfo;\n        return debugInfo;\n    }\n    // NEW: Output a debug file with ONLY style definitions (paragraph, character, font)\n    async addStyleOnlyDebug(processor) {\n        console.log(\"\\n\\uD83D\\uDD0D ======= STYLE-ONLY DEBUG =======\");\n        const styleDebug = {\n            timestamp: new Date().toISOString(),\n            paragraphStyles: processor.styleParser ? processor.styleParser.getParagraphStyles && processor.styleParser.getParagraphStyles() : {},\n            characterStyles: processor.styleParser ? processor.styleParser.getCharacterStyles && processor.styleParser.getCharacterStyles() : {},\n            fontDefinitions: processor.styleParser ? processor.styleParser.getFontDefinitions && processor.styleParser.getFontDefinitions() : {}\n        };\n        const debugFileName = `idml-style-debug-${Date.now()}.json`;\n        IDMLUtils.saveDebugInfo(styleDebug, debugFileName);\n        console.log(`\\nâœ… Style-only debug completed. Check file: ${debugFileName}`);\n        this.debugData = styleDebug;\n        return styleDebug;\n    }\n    // NEW: Output a debug file with all extracted story text for whitespace debugging\n    async addExtractedTextDebug(processor) {\n        console.log(\"\\n\\uD83D\\uDD0D ======= EXTRACTED TEXT DEBUG =======\");\n        const stories = processor.storyParser && processor.storyParser.getStories ? processor.storyParser.getStories() : {};\n        const textDebug = {\n            timestamp: new Date().toISOString(),\n            stories: Object.fromEntries(Object.entries(stories).map(([storyId, story])=>[\n                    storyId,\n                    {\n                        plainText: story.content?.plainText || \"\",\n                        preview: (story.content?.plainText || \"\").substring(0, 100),\n                        whitespaceSample: (story.content?.plainText || \"\").replace(/[^\\s]/g, \"_\").substring(0, 100)\n                    }\n                ]))\n        };\n        const debugFileName = `idml-extracted-text-debug-${Date.now()}.json`;\n        IDMLUtils.saveDebugInfo(textDebug, debugFileName);\n        console.log(`\\nâœ… Extracted text debug completed. Check file: ${debugFileName}`);\n        this.debugData = textDebug;\n        return textDebug;\n    }\n    analyzeStoryStructure(story) {\n        const structure = {\n            rawStoryKeys: Object.keys(story),\n            contentKeys: story.content ? Object.keys(story.content) : [],\n            textFormattingKeys: story.textFormatting ? Object.keys(story.textFormatting) : [],\n            hasFormattedContent: !!(story.content && story.content.formattedContent),\n            formattedContentLength: story.content?.formattedContent?.length || 0,\n            rawStoryData: JSON.stringify(story, null, 2).substring(0, 1000) + \"...\"\n        };\n        return structure;\n    }\n    analyzeFormattingExtraction(story) {\n        const formatting = {\n            extractedFormatting: story.content?.formattedContent || [],\n            formattingTypes: {},\n            attributesFound: new Set(),\n            formattingSample: []\n        };\n        if (story.content?.formattedContent) {\n            story.content.formattedContent.forEach((item, index)=>{\n                if (item.formatting) {\n                    Object.keys(item.formatting).forEach((key)=>{\n                        formatting.attributesFound.add(key);\n                        if (!formatting.formattingTypes[key]) {\n                            formatting.formattingTypes[key] = [];\n                        }\n                        formatting.formattingTypes[key].push(item.formatting[key]);\n                    });\n                    if (index < 3) {\n                        formatting.formattingSample.push({\n                            text: item.text?.substring(0, 50),\n                            formatting: item.formatting\n                        });\n                    }\n                }\n            });\n        }\n        formatting.attributesFound = Array.from(formatting.attributesFound);\n        return formatting;\n    }\n    extractAllXMLAttributes(story) {\n        console.log(\"Extracting all XML attributes...\");\n        const attributes = {\n            storyLevelAttributes: {},\n            contentLevelAttributes: {},\n            allAttributeNames: new Set()\n        };\n        // Extract attributes from story object recursively\n        const extractAttributes = (obj, path = \"\")=>{\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key.startsWith(\"@_\")) {\n                        attributes.allAttributeNames.add(key);\n                        const fullPath = path ? `${path}.${key}` : key;\n                        if (!attributes.storyLevelAttributes[fullPath]) {\n                            attributes.storyLevelAttributes[fullPath] = obj[key];\n                        }\n                    } else if (typeof obj[key] === \"object\") {\n                        extractAttributes(obj[key], path ? `${path}.${key}` : key);\n                    }\n                });\n            }\n        };\n        extractAttributes(story);\n        attributes.allAttributeNames = Array.from(attributes.allAttributeNames);\n        console.log(\"XML attributes found:\", attributes.allAttributeNames);\n        return attributes;\n    }\n    findNestedFormattingElements(story) {\n        console.log(\"Finding nested formatting elements...\");\n        const nested = {\n            characterStyleRanges: [],\n            paragraphStyleRanges: [],\n            directFormatting: [],\n            fontReferences: [],\n            colorReferences: []\n        };\n        const findNested = (obj, path = \"\")=>{\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    const value = obj[key];\n                    const currentPath = path ? `${path}.${key}` : key;\n                    if (key === \"CharacterStyleRange\") {\n                        nested.characterStyleRanges.push({\n                            path: currentPath,\n                            data: value\n                        });\n                    } else if (key === \"ParagraphStyleRange\") {\n                        nested.paragraphStyleRanges.push({\n                            path: currentPath,\n                            data: value\n                        });\n                    } else if (key.includes(\"Font\") || key.includes(\"font\")) {\n                        nested.fontReferences.push({\n                            path: currentPath,\n                            value: value\n                        });\n                    } else if (key.includes(\"Color\") || key.includes(\"color\")) {\n                        nested.colorReferences.push({\n                            path: currentPath,\n                            value: value\n                        });\n                    } else if (key.startsWith(\"@_\") && IDMLUtils.isFormattingAttribute(key)) {\n                        nested.directFormatting.push({\n                            path: currentPath,\n                            attribute: key,\n                            value: value\n                        });\n                    } else if (typeof value === \"object\") {\n                        findNested(value, currentPath);\n                    }\n                });\n            }\n        };\n        findNested(story);\n        console.log(\"Nested formatting elements:\", {\n            characterStyleRanges: nested.characterStyleRanges.length,\n            paragraphStyleRanges: nested.paragraphStyleRanges.length,\n            directFormatting: nested.directFormatting.length,\n            fontReferences: nested.fontReferences.length,\n            colorReferences: nested.colorReferences.length\n        });\n        return nested;\n    }\n    extractCharacterStyleRanges(story) {\n        console.log(\"Extracting character style ranges...\");\n        const ranges = [];\n        const extractRanges = (obj)=>{\n            if (typeof obj === \"object\" && obj !== null) {\n                if (obj.CharacterStyleRange) {\n                    const charRanges = Array.isArray(obj.CharacterStyleRange) ? obj.CharacterStyleRange : [\n                        obj.CharacterStyleRange\n                    ];\n                    charRanges.forEach((range)=>{\n                        ranges.push({\n                            appliedCharacterStyle: range[\"@_AppliedCharacterStyle\"],\n                            pointSize: range[\"@_PointSize\"],\n                            appliedFont: range[\"@_AppliedFont\"],\n                            fontStyle: range[\"@_FontStyle\"],\n                            fillColor: range[\"@_FillColor\"],\n                            strokeColor: range[\"@_StrokeColor\"],\n                            tracking: range[\"@_Tracking\"],\n                            leading: range[\"@_Leading\"],\n                            allAttributes: Object.keys(range).filter((k)=>k.startsWith(\"@_\")),\n                            contentLength: range.Content ? Array.isArray(range.Content) ? range.Content.join(\"\").length : String(range.Content).length : 0,\n                            rawRange: range\n                        });\n                    });\n                }\n                Object.values(obj).forEach((value)=>{\n                    if (typeof value === \"object\") {\n                        extractRanges(value);\n                    }\n                });\n            }\n        };\n        extractRanges(story);\n        console.log(`Found ${ranges.length} character style ranges`);\n        ranges.forEach((range, index)=>{\n            console.log(`  Range ${index + 1}:`, {\n                style: range.appliedCharacterStyle,\n                fontSize: range.pointSize,\n                font: range.appliedFont,\n                color: range.fillColor,\n                contentLength: range.contentLength\n            });\n        });\n        return ranges;\n    }\n    extractParagraphStyleRanges(story) {\n        console.log(\"Extracting paragraph style ranges...\");\n        const ranges = [];\n        const extractRanges = (obj)=>{\n            if (typeof obj === \"object\" && obj !== null) {\n                if (obj.ParagraphStyleRange) {\n                    const paraRanges = Array.isArray(obj.ParagraphStyleRange) ? obj.ParagraphStyleRange : [\n                        obj.ParagraphStyleRange\n                    ];\n                    paraRanges.forEach((range)=>{\n                        ranges.push({\n                            appliedParagraphStyle: range[\"@_AppliedParagraphStyle\"],\n                            justification: range[\"@_Justification\"],\n                            leftIndent: range[\"@_LeftIndent\"],\n                            rightIndent: range[\"@_RightIndent\"],\n                            firstLineIndent: range[\"@_FirstLineIndent\"],\n                            spaceBefore: range[\"@_SpaceBefore\"],\n                            spaceAfter: range[\"@_SpaceAfter\"],\n                            allAttributes: Object.keys(range).filter((k)=>k.startsWith(\"@_\")),\n                            hasCharacterStyleRanges: !!range.CharacterStyleRange,\n                            characterStyleRangeCount: range.CharacterStyleRange ? Array.isArray(range.CharacterStyleRange) ? range.CharacterStyleRange.length : 1 : 0,\n                            rawRange: range\n                        });\n                    });\n                }\n                Object.values(obj).forEach((value)=>{\n                    if (typeof value === \"object\") {\n                        extractRanges(value);\n                    }\n                });\n            }\n        };\n        extractRanges(story);\n        console.log(`Found ${ranges.length} paragraph style ranges`);\n        ranges.forEach((range, index)=>{\n            console.log(`  Range ${index + 1}:`, {\n                style: range.appliedParagraphStyle,\n                justification: range.justification,\n                characterRanges: range.characterStyleRangeCount\n            });\n        });\n        return ranges;\n    }\n    extractDirectFormattingAttributes(story) {\n        console.log(\"Extracting direct formatting attributes...\");\n        const directFormatting = [];\n        const extractDirect = (obj, path = \"\")=>{\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key.startsWith(\"@_\") && IDMLUtils.isFormattingAttribute(key)) {\n                        directFormatting.push({\n                            path: path,\n                            attribute: key,\n                            value: obj[key]\n                        });\n                    } else if (typeof obj[key] === \"object\") {\n                        extractDirect(obj[key], path ? `${path}.${key}` : key);\n                    }\n                });\n            }\n        };\n        extractDirect(story);\n        console.log(`Found ${directFormatting.length} direct formatting attributes`);\n        return directFormatting;\n    }\n    extractStyleReferences(story) {\n        console.log(\"Extracting style references...\");\n        const references = {\n            paragraphStyleReferences: new Set(),\n            characterStyleReferences: new Set(),\n            fontReferences: new Set(),\n            colorReferences: new Set()\n        };\n        const extractRefs = (obj)=>{\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    const value = obj[key];\n                    if (key === \"@_AppliedParagraphStyle\" && value) {\n                        references.paragraphStyleReferences.add(value);\n                    } else if (key === \"@_AppliedCharacterStyle\" && value) {\n                        references.characterStyleReferences.add(value);\n                    } else if (key === \"@_AppliedFont\" && value) {\n                        references.fontReferences.add(value);\n                    } else if ((key === \"@_FillColor\" || key === \"@_StrokeColor\") && value) {\n                        references.colorReferences.add(value);\n                    } else if (typeof value === \"object\") {\n                        extractRefs(value);\n                    }\n                });\n            }\n        };\n        extractRefs(story);\n        // Convert sets to arrays\n        Object.keys(references).forEach((key)=>{\n            references[key] = Array.from(references[key]);\n        });\n        console.log(\"Style references found:\", references);\n        return references;\n    }\n    analyzeTextFrameFormatting(pageItems) {\n        console.log(\"Analyzing text frame formatting...\");\n        const textFrames = pageItems.filter((item)=>item.type === \"TextFrame\");\n        const analysis = textFrames.map((frame)=>({\n                id: frame.self,\n                parentStory: frame.parentStory,\n                hasParentStory: !!frame.parentStory,\n                textFramePreferences: frame.textFramePreferences,\n                fillColor: frame.fillColor,\n                strokeColor: frame.strokeColor,\n                rawFrame: frame\n            }));\n        console.log(`Analyzed ${textFrames.length} text frames`);\n        return analysis;\n    }\n    analyzeParagraphStyles(styleParser) {\n        console.log(\"Analyzing paragraph styles...\");\n        const styles = styleParser.getStyles();\n        const analysis = {\n            totalStyles: Object.keys(styles.paragraph).length,\n            styleDetails: {},\n            attributeCoverage: {}\n        };\n        Object.entries(styles.paragraph).forEach(([styleId, style])=>{\n            analysis.styleDetails[styleId] = {\n                name: style.name,\n                pointSize: style.pointSize,\n                appliedFont: style.appliedFont,\n                alignment: style.alignment,\n                fillColor: style.fillColor,\n                allProperties: Object.keys(style)\n            };\n            // Track which attributes are available\n            Object.keys(style).forEach((attr)=>{\n                if (!analysis.attributeCoverage[attr]) {\n                    analysis.attributeCoverage[attr] = 0;\n                }\n                analysis.attributeCoverage[attr]++;\n            });\n        });\n        console.log(\"Paragraph styles analysis:\", analysis);\n        return analysis;\n    }\n    analyzeCharacterStyles(styleParser) {\n        console.log(\"Analyzing character styles...\");\n        const styles = styleParser.getStyles();\n        const analysis = {\n            totalStyles: Object.keys(styles.character).length,\n            styleDetails: {},\n            attributeCoverage: {}\n        };\n        Object.entries(styles.character).forEach(([styleId, style])=>{\n            analysis.styleDetails[styleId] = {\n                name: style.name,\n                pointSize: style.pointSize,\n                appliedFont: style.appliedFont,\n                fontStyle: style.fontStyle,\n                fillColor: style.fillColor,\n                allProperties: Object.keys(style)\n            };\n            // Track which attributes are available\n            Object.keys(style).forEach((attr)=>{\n                if (!analysis.attributeCoverage[attr]) {\n                    analysis.attributeCoverage[attr] = 0;\n                }\n                analysis.attributeCoverage[attr]++;\n            });\n        });\n        console.log(\"Character styles analysis:\", analysis);\n        return analysis;\n    }\n    analyzeStyleHierarchy(styleParser) {\n        console.log(\"Analyzing style hierarchy...\");\n        return {\n            paragraphStyleHierarchy: this.extractStyleHierarchy(styleParser.getStyles().paragraph),\n            characterStyleHierarchy: this.extractStyleHierarchy(styleParser.getStyles().character),\n            styleInheritance: this.analyzeStyleInheritance()\n        };\n    }\n    extractStyleHierarchy(styles) {\n        const hierarchy = {};\n        Object.entries(styles).forEach(([styleId, style])=>{\n            hierarchy[styleId] = {\n                basedOn: style.basedOn || null,\n                children: [],\n                level: 0\n            };\n        });\n        // Build parent-child relationships\n        Object.entries(hierarchy).forEach(([styleId, info])=>{\n            if (info.basedOn && hierarchy[info.basedOn]) {\n                hierarchy[info.basedOn].children.push(styleId);\n                info.level = hierarchy[info.basedOn].level + 1;\n            }\n        });\n        return hierarchy;\n    }\n    analyzeStyleInheritance() {\n        return {\n            inheritanceChains: this.findInheritanceChains(),\n            overrides: this.findStyleOverrides()\n        };\n    }\n    findInheritanceChains() {\n        // Implementation for finding inheritance chains\n        return {};\n    }\n    findStyleOverrides() {\n        // Implementation for finding style overrides\n        return {};\n    }\n    analyzeFontDefinitions(styleParser) {\n        console.log(\"Analyzing font definitions...\");\n        const resources = styleParser.getResources();\n        return {\n            availableFonts: resources.fonts || {},\n            fontUsage: this.analyzeFontUsage(styleParser),\n            missingFonts: this.findMissingFonts(styleParser)\n        };\n    }\n    analyzeFontUsage(styleParser) {\n        const usage = {};\n        const styles = styleParser.getStyles();\n        // Analyze font usage in paragraph styles\n        Object.values(styles.paragraph).forEach((style)=>{\n            if (style.appliedFont) {\n                if (!usage[style.appliedFont]) {\n                    usage[style.appliedFont] = {\n                        paragraphStyles: 0,\n                        characterStyles: 0\n                    };\n                }\n                usage[style.appliedFont].paragraphStyles++;\n            }\n        });\n        // Analyze font usage in character styles\n        Object.values(styles.character).forEach((style)=>{\n            if (style.appliedFont) {\n                if (!usage[style.appliedFont]) {\n                    usage[style.appliedFont] = {\n                        paragraphStyles: 0,\n                        characterStyles: 0\n                    };\n                }\n                usage[style.appliedFont].characterStyles++;\n            }\n        });\n        return usage;\n    }\n    findMissingFonts(styleParser) {\n        const usedFonts = new Set();\n        const resources = styleParser.getResources();\n        const availableFonts = new Set(Object.keys(resources.fonts || {}));\n        const styles = styleParser.getStyles();\n        // Collect used fonts\n        Object.values(styles.paragraph).forEach((style)=>{\n            if (style.appliedFont) usedFonts.add(style.appliedFont);\n        });\n        Object.values(styles.character).forEach((style)=>{\n            if (style.appliedFont) usedFonts.add(style.appliedFont);\n        });\n        // Find missing fonts\n        const missing = Array.from(usedFonts).filter((font)=>!availableFonts.has(font));\n        return {\n            usedFonts: Array.from(usedFonts),\n            availableFonts: Array.from(availableFonts),\n            missingFonts: missing\n        };\n    }\n    performXMLStructureAnalysis(processor) {\n        console.log(\"Performing XML structure analysis...\");\n        const analysis = {\n            storyXMLStructure: {},\n            spreadXMLStructure: {},\n            resourceXMLStructure: {}\n        };\n        if (processor.storyParser) {\n            const stories = processor.storyParser.getStories();\n            Object.entries(stories).forEach(([storyId, story])=>{\n                analysis.storyXMLStructure[storyId] = IDMLUtils.getXMLStructure(story);\n            });\n        }\n        if (processor.spreads) {\n            Object.entries(processor.spreads).forEach(([spreadId, spread])=>{\n                analysis.spreadXMLStructure[spreadId] = IDMLUtils.getXMLStructure(spread);\n            });\n        }\n        if (processor.styleParser) {\n            const styles = processor.styleParser.getStyles();\n            const resources = processor.styleParser.getResources();\n            analysis.resourceXMLStructure = {\n                styles: IDMLUtils.getXMLStructure(styles),\n                fonts: IDMLUtils.getXMLStructure(resources.fonts),\n                colors: IDMLUtils.getXMLStructure(resources.colors)\n            };\n        }\n        return analysis;\n    }\n    createFormattingAttributeMapping() {\n        console.log(\"Creating formatting attribute mapping...\");\n        return {\n            inDesignToCSS: {\n                \"@_PointSize\": \"font-size\",\n                \"@_AppliedFont\": \"font-family\",\n                \"@_FontStyle\": \"font-weight\",\n                \"@_FillColor\": \"color\",\n                \"@_Justification\": \"text-align\",\n                \"@_Leading\": \"line-height\",\n                \"@_Tracking\": \"letter-spacing\",\n                \"@_LeftIndent\": \"margin-left\",\n                \"@_RightIndent\": \"margin-right\",\n                \"@_FirstLineIndent\": \"text-indent\",\n                \"@_SpaceBefore\": \"margin-top\",\n                \"@_SpaceAfter\": \"margin-bottom\"\n            },\n            attributeLocations: {\n                fontSize: [\n                    \"CharacterStyleRange@_PointSize\",\n                    \"ParagraphStyle.pointSize\",\n                    \"CharacterStyle.pointSize\"\n                ],\n                fontFamily: [\n                    \"CharacterStyleRange@_AppliedFont\",\n                    \"ParagraphStyle.appliedFont\",\n                    \"CharacterStyle.appliedFont\"\n                ],\n                alignment: [\n                    \"ParagraphStyleRange@_Justification\",\n                    \"ParagraphStyle.alignment\"\n                ],\n                color: [\n                    \"CharacterStyleRange@_FillColor\",\n                    \"ParagraphStyle.fillColor\",\n                    \"CharacterStyle.fillColor\"\n                ]\n            }\n        };\n    }\n    identifyMissingFormattingReasons(processor) {\n        console.log(\"Identifying missing formatting reasons...\");\n        const reasons = [];\n        // Check if styles are being extracted properly\n        if (processor.styleParser) {\n            const styles = processor.styleParser.getStyles();\n            if (Object.keys(styles.paragraph).length === 0) {\n                reasons.push(\"No paragraph styles extracted - check Resources/Styles.xml parsing\");\n            }\n            if (Object.keys(styles.character).length === 0) {\n                reasons.push(\"No character styles extracted - check Resources/Styles.xml parsing\");\n            }\n        } else {\n            reasons.push(\"StyleParser not available - check initialization\");\n        }\n        // Check if story content has formatting\n        if (processor.storyParser) {\n            const stories = processor.storyParser.getStories();\n            const storiesWithFormatting = Object.values(stories).filter((story)=>story.content?.formattedContent?.some((item)=>item.formatting && Object.keys(item.formatting).length > 1));\n            if (storiesWithFormatting.length === 0) {\n                reasons.push(\"No stories have detailed formatting - check CharacterStyleRange extraction\");\n            }\n        }\n        // Check if text frames are linked to stories\n        if (processor.elements) {\n            const textFrames = processor.elements.filter((el)=>el.type === \"TextFrame\");\n            const linkedFrames = textFrames.filter((frame)=>{\n                if (processor.storyParser) {\n                    const stories = processor.storyParser.getStories();\n                    return frame.parentStory && stories[frame.parentStory];\n                }\n                return false;\n            });\n            if (textFrames.length > 0 && linkedFrames.length === 0) {\n                reasons.push(\"Text frames not properly linked to stories - check parentStory references\");\n            }\n        }\n        return reasons;\n    }\n    getDebugData() {\n        return this.debugData;\n    }\n    clearDebugData() {\n        this.debugData = {};\n    }\n}\nmodule.exports = DebugAnalyzer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ3ZCLENBQUFBLFFBQzFEQSxNQUFNb0QsT0FBTyxFQUFFVyxrQkFBa0J5SSxLQUFLaEwsQ0FBQUEsT0FDcENBLEtBQUs0QyxVQUFVLElBQUl0RixPQUFPQyxJQUFJLENBQUN5QyxLQUFLNEMsVUFBVSxFQUFFbkYsTUFBTSxHQUFHO1lBSTdELElBQUlzTixzQkFBc0J0TixNQUFNLEtBQUssR0FBRztnQkFDdENxTixRQUFReEgsSUFBSSxDQUFDO1lBQ2Y7UUFDRjtRQUVBLDZDQUE2QztRQUM3QyxJQUFJeEcsVUFBVWEsUUFBUSxFQUFFO1lBQ3RCLE1BQU1rQyxhQUFhL0MsVUFBVWEsUUFBUSxDQUFDb0MsTUFBTSxDQUFDa0wsQ0FBQUEsS0FBTUEsR0FBR2hMLElBQUksS0FBSztZQUMvRCxNQUFNaUwsZUFBZXJMLFdBQVdFLE1BQU0sQ0FBQzJILENBQUFBO2dCQUNyQyxJQUFJNUssVUFBVXVCLFdBQVcsRUFBRTtvQkFDekIsTUFBTWIsVUFBVVYsVUFBVXVCLFdBQVcsQ0FBQ0MsVUFBVTtvQkFDaEQsT0FBT29KLE1BQU1HLFdBQVcsSUFBSXJLLE9BQU8sQ0FBQ2tLLE1BQU1HLFdBQVcsQ0FBQztnQkFDeEQ7Z0JBQ0EsT0FBTztZQUNUO1lBRUEsSUFBSWhJLFdBQVdwQyxNQUFNLEdBQUcsS0FBS3lOLGFBQWF6TixNQUFNLEtBQUssR0FBRztnQkFDdERxTixRQUFReEgsSUFBSSxDQUFDO1lBQ2Y7UUFDRjtRQUVBLE9BQU93SDtJQUNUO0lBRUFLLGVBQWU7UUFDYixPQUFPLElBQUksQ0FBQ3ZPLFNBQVM7SUFDdkI7SUFFQXdPLGlCQUFpQjtRQUNmLElBQUksQ0FBQ3hPLFNBQVMsR0FBRyxDQUFDO0lBQ3BCO0FBQ0Y7QUFFQXlPLE9BQU9DLE9BQU8sR0FBRzVPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRtbC12aWV3ZXIvLi9saWIvZGVidWcvRGVidWdBbmFseXplci5qcz8yN2M5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL0lETUxVdGlscycpO1xyXG5cclxuY2xhc3MgRGVidWdBbmFseXplciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmRlYnVnRGF0YSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYWRkQ29tcHJlaGVuc2l2ZVRleHRGb3JtYXR0aW5nRGVidWcocHJvY2Vzc29yKSB7XHJcbiAgICBjb25zb2xlLmxvZygnXFxu8J+UjSA9PT09PT09IENPTVBSRUhFTlNJVkUgVEVYVCBGT1JNQVRUSU5HIERFQlVHID09PT09PT0nKTtcclxuICAgIFxyXG4gICAgY29uc3QgZGVidWdJbmZvID0ge1xyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgdG90YWxTdG9yaWVzOiBPYmplY3Qua2V5cyhwcm9jZXNzb3Iuc3RvcmllcyB8fCB7fSkubGVuZ3RoLFxyXG4gICAgICB0b3RhbEVsZW1lbnRzOiBwcm9jZXNzb3IuZWxlbWVudHMgPyBwcm9jZXNzb3IuZWxlbWVudHMubGVuZ3RoIDogMCxcclxuICAgICAgc3R5bGVEZWZpbml0aW9uczogcHJvY2Vzc29yLnN0eWxlUGFyc2VyID8gcHJvY2Vzc29yLnN0eWxlUGFyc2VyLmdldFN0eWxlcygpIDoge30sXHJcbiAgICAgIGRldGFpbGVkU3RvcnlBbmFseXNpczoge30sXHJcbiAgICAgIHNwcmVhZEVsZW1lbnRBbmFseXNpczoge30sXHJcbiAgICAgIHJlc291cmNlc0FuYWx5c2lzOiB7fSxcclxuICAgICAgeG1sU3RydWN0dXJlQW5hbHlzaXM6IHt9LFxyXG4gICAgICBmb3JtYXR0aW5nQXR0cmlidXRlTWFwcGluZzoge30sXHJcbiAgICAgIG1pc3NpbmdGb3JtYXR0aW5nUmVhc29uczogW11cclxuICAgIH07XHJcblxyXG4gICAgLy8gMS4gQU5BTFlaRSBTVE9SWSBDT05URU5UIElOIEVYVFJFTUUgREVUQUlMXHJcbiAgICBjb25zb2xlLmxvZygnXFxu8J+TnSA9PT0gREVUQUlMRUQgU1RPUlkgQ09OVEVOVCBBTkFMWVNJUyA9PT0nKTtcclxuICAgIFxyXG4gICAgaWYgKHByb2Nlc3Nvci5zdG9yeVBhcnNlciAmJiBwcm9jZXNzb3Iuc3RvcnlQYXJzZXIuZ2V0U3Rvcmllcykge1xyXG4gICAgICBjb25zdCBzdG9yaWVzID0gcHJvY2Vzc29yLnN0b3J5UGFyc2VyLmdldFN0b3JpZXMoKTtcclxuICAgICAgZm9yIChjb25zdCBbc3RvcnlJZCwgc3RvcnldIG9mIE9iamVjdC5lbnRyaWVzKHN0b3JpZXMpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFxcbi0tLSBTVE9SWSAke3N0b3J5SWR9IERFRVAgRElWRSAtLS1gKTtcclxuICAgICAgICBcclxuICAgICAgICBkZWJ1Z0luZm8uZGV0YWlsZWRTdG9yeUFuYWx5c2lzW3N0b3J5SWRdID0ge1xyXG4gICAgICAgICAgc3RvcnlTdHJ1Y3R1cmU6IHRoaXMuYW5hbHl6ZVN0b3J5U3RydWN0dXJlKHN0b3J5KSxcclxuICAgICAgICAgIGZvcm1hdHRpbmdFeHRyYWN0aW9uOiB0aGlzLmFuYWx5emVGb3JtYXR0aW5nRXh0cmFjdGlvbihzdG9yeSksXHJcbiAgICAgICAgICB4bWxBdHRyaWJ1dGVzOiB0aGlzLmV4dHJhY3RBbGxYTUxBdHRyaWJ1dGVzKHN0b3J5KSxcclxuICAgICAgICAgIG5lc3RlZEVsZW1lbnRzOiB0aGlzLmZpbmROZXN0ZWRGb3JtYXR0aW5nRWxlbWVudHMoc3RvcnkpLFxyXG4gICAgICAgICAgY2hhcmFjdGVyU3R5bGVSYW5nZXM6IHRoaXMuZXh0cmFjdENoYXJhY3RlclN0eWxlUmFuZ2VzKHN0b3J5KSxcclxuICAgICAgICAgIHBhcmFncmFwaFN0eWxlUmFuZ2VzOiB0aGlzLmV4dHJhY3RQYXJhZ3JhcGhTdHlsZVJhbmdlcyhzdG9yeSksXHJcbiAgICAgICAgICBkaXJlY3RGb3JtYXR0aW5nQXR0cmlidXRlczogdGhpcy5leHRyYWN0RGlyZWN0Rm9ybWF0dGluZ0F0dHJpYnV0ZXMoc3RvcnkpLFxyXG4gICAgICAgICAgc3R5bGVSZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3RTdHlsZVJlZmVyZW5jZXMoc3RvcnkpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIDIuIEFOQUxZWkUgU1BSRUFEIEVMRU1FTlRTIEZPUiBURVhUIEZSQU1FU1xyXG4gICAgaWYgKHByb2Nlc3Nvci5zcHJlYWRzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW3NwcmVhZElkLCBzcHJlYWRdIG9mIE9iamVjdC5lbnRyaWVzKHByb2Nlc3Nvci5zcHJlYWRzKSkge1xyXG4gICAgICAgIGRlYnVnSW5mby5zcHJlYWRFbGVtZW50QW5hbHlzaXNbc3ByZWFkSWRdID0ge1xyXG4gICAgICAgICAgdGV4dEZyYW1lczogc3ByZWFkLnBhZ2VJdGVtcz8uZmlsdGVyKGl0ZW0gPT4gaXRlbS50eXBlID09PSAnVGV4dEZyYW1lJykgfHwgW10sXHJcbiAgICAgICAgICB0ZXh0RnJhbWVEZXRhaWxzOiB0aGlzLmFuYWx5emVUZXh0RnJhbWVGb3JtYXR0aW5nKHNwcmVhZC5wYWdlSXRlbXMgfHwgW10pXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIDMuIEFOQUxZWkUgUkVTT1VSQ0VTIEFORCBTVFlMRSBERUZJTklUSU9OU1xyXG4gICAgaWYgKHByb2Nlc3Nvci5zdHlsZVBhcnNlcikge1xyXG4gICAgICBkZWJ1Z0luZm8ucmVzb3VyY2VzQW5hbHlzaXMgPSB7XHJcbiAgICAgICAgcGFyYWdyYXBoU3R5bGVzOiB0aGlzLmFuYWx5emVQYXJhZ3JhcGhTdHlsZXMocHJvY2Vzc29yLnN0eWxlUGFyc2VyKSxcclxuICAgICAgICBjaGFyYWN0ZXJTdHlsZXM6IHRoaXMuYW5hbHl6ZUNoYXJhY3RlclN0eWxlcyhwcm9jZXNzb3Iuc3R5bGVQYXJzZXIpLFxyXG4gICAgICAgIHN0eWxlSGllcmFyY2h5OiB0aGlzLmFuYWx5emVTdHlsZUhpZXJhcmNoeShwcm9jZXNzb3Iuc3R5bGVQYXJzZXIpLFxyXG4gICAgICAgIGZvbnREZWZpbml0aW9uczogdGhpcy5hbmFseXplRm9udERlZmluaXRpb25zKHByb2Nlc3Nvci5zdHlsZVBhcnNlcilcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA0LiBBTkFMWVpFIFhNTCBTVFJVQ1RVUkUgRk9SIEZPUk1BVFRJTkcgQVRUUklCVVRFU1xyXG4gICAgZGVidWdJbmZvLnhtbFN0cnVjdHVyZUFuYWx5c2lzID0gdGhpcy5wZXJmb3JtWE1MU3RydWN0dXJlQW5hbHlzaXMocHJvY2Vzc29yKTtcclxuXHJcbiAgICAvLyA1LiBDUkVBVEUgRk9STUFUVElORyBBVFRSSUJVVEUgTUFQUElOR1xyXG4gICAgZGVidWdJbmZvLmZvcm1hdHRpbmdBdHRyaWJ1dGVNYXBwaW5nID0gdGhpcy5jcmVhdGVGb3JtYXR0aW5nQXR0cmlidXRlTWFwcGluZygpO1xyXG5cclxuICAgIC8vIDYuIElERU5USUZZIE1JU1NJTkcgRk9STUFUVElORyBSRUFTT05TXHJcbiAgICBkZWJ1Z0luZm8ubWlzc2luZ0Zvcm1hdHRpbmdSZWFzb25zID0gdGhpcy5pZGVudGlmeU1pc3NpbmdGb3JtYXR0aW5nUmVhc29ucyhwcm9jZXNzb3IpO1xyXG5cclxuICAgIC8vIDcuIFNBVkUgREVCVUcgSU5GTyBUTyBGSUxFXHJcbiAgICBjb25zdCBkZWJ1Z0ZpbGVOYW1lID0gYGlkbWwtdGV4dC1mb3JtYXR0aW5nLWRlYnVnLSR7RGF0ZS5ub3coKX0uanNvbmA7XHJcbiAgICBJRE1MVXRpbHMuc2F2ZURlYnVnSW5mbyhkZWJ1Z0luZm8sIGRlYnVnRmlsZU5hbWUpO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgXFxu4pyFIENvbXByZWhlbnNpdmUgZGVidWcgY29tcGxldGVkLiBDaGVjayBmaWxlOiAke2RlYnVnRmlsZU5hbWV9YCk7XHJcbiAgICBcclxuICAgIHRoaXMuZGVidWdEYXRhID0gZGVidWdJbmZvO1xyXG4gICAgcmV0dXJuIGRlYnVnSW5mbztcclxuICB9XHJcblxyXG4gIC8vIE5FVzogT3V0cHV0IGEgZGVidWcgZmlsZSB3aXRoIE9OTFkgc3R5bGUgZGVmaW5pdGlvbnMgKHBhcmFncmFwaCwgY2hhcmFjdGVyLCBmb250KVxyXG4gIGFzeW5jIGFkZFN0eWxlT25seURlYnVnKHByb2Nlc3Nvcikge1xyXG4gICAgY29uc29sZS5sb2coJ1xcbvCflI0gPT09PT09PSBTVFlMRS1PTkxZIERFQlVHID09PT09PT0nKTtcclxuICAgIGNvbnN0IHN0eWxlRGVidWcgPSB7XHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBwYXJhZ3JhcGhTdHlsZXM6IHByb2Nlc3Nvci5zdHlsZVBhcnNlciA/IHByb2Nlc3Nvci5zdHlsZVBhcnNlci5nZXRQYXJhZ3JhcGhTdHlsZXMgJiYgcHJvY2Vzc29yLnN0eWxlUGFyc2VyLmdldFBhcmFncmFwaFN0eWxlcygpIDoge30sXHJcbiAgICAgIGNoYXJhY3RlclN0eWxlczogcHJvY2Vzc29yLnN0eWxlUGFyc2VyID8gcHJvY2Vzc29yLnN0eWxlUGFyc2VyLmdldENoYXJhY3RlclN0eWxlcyAmJiBwcm9jZXNzb3Iuc3R5bGVQYXJzZXIuZ2V0Q2hhcmFjdGVyU3R5bGVzKCkgOiB7fSxcclxuICAgICAgZm9udERlZmluaXRpb25zOiBwcm9jZXNzb3Iuc3R5bGVQYXJzZXIgPyBwcm9jZXNzb3Iuc3R5bGVQYXJzZXIuZ2V0Rm9udERlZmluaXRpb25zICYmIHByb2Nlc3Nvci5zdHlsZVBhcnNlci5nZXRGb250RGVmaW5pdGlvbnMoKSA6IHt9LFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGRlYnVnRmlsZU5hbWUgPSBgaWRtbC1zdHlsZS1kZWJ1Zy0ke0RhdGUubm93KCl9Lmpzb25gO1xyXG4gICAgSURNTFV0aWxzLnNhdmVEZWJ1Z0luZm8oc3R5bGVEZWJ1ZywgZGVidWdGaWxlTmFtZSk7XHJcbiAgICBjb25zb2xlLmxvZyhgXFxu4pyFIFN0eWxlLW9ubHkgZGVidWcgY29tcGxldGVkLiBDaGVjayBmaWxlOiAke2RlYnVnRmlsZU5hbWV9YCk7XHJcbiAgICB0aGlzLmRlYnVnRGF0YSA9IHN0eWxlRGVidWc7XHJcbiAgICByZXR1cm4gc3R5bGVEZWJ1ZztcclxuICB9XHJcblxyXG4gIC8vIE5FVzogT3V0cHV0IGEgZGVidWcgZmlsZSB3aXRoIGFsbCBleHRyYWN0ZWQgc3RvcnkgdGV4dCBmb3Igd2hpdGVzcGFjZSBkZWJ1Z2dpbmdcclxuICBhc3luYyBhZGRFeHRyYWN0ZWRUZXh0RGVidWcocHJvY2Vzc29yKSB7XHJcbiAgICBjb25zb2xlLmxvZygnXFxu8J+UjSA9PT09PT09IEVYVFJBQ1RFRCBURVhUIERFQlVHID09PT09PT0nKTtcclxuICAgIGNvbnN0IHN0b3JpZXMgPSBwcm9jZXNzb3Iuc3RvcnlQYXJzZXIgJiYgcHJvY2Vzc29yLnN0b3J5UGFyc2VyLmdldFN0b3JpZXMgPyBwcm9jZXNzb3Iuc3RvcnlQYXJzZXIuZ2V0U3RvcmllcygpIDoge307XHJcbiAgICBjb25zdCB0ZXh0RGVidWcgPSB7XHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBzdG9yaWVzOiBPYmplY3QuZnJvbUVudHJpZXMoXHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3RvcmllcykubWFwKChbc3RvcnlJZCwgc3RvcnldKSA9PiBbXHJcbiAgICAgICAgICBzdG9yeUlkLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBwbGFpblRleHQ6IHN0b3J5LmNvbnRlbnQ/LnBsYWluVGV4dCB8fCAnJyxcclxuICAgICAgICAgICAgcHJldmlldzogKHN0b3J5LmNvbnRlbnQ/LnBsYWluVGV4dCB8fCAnJykuc3Vic3RyaW5nKDAsIDEwMCksXHJcbiAgICAgICAgICAgIHdoaXRlc3BhY2VTYW1wbGU6IChzdG9yeS5jb250ZW50Py5wbGFpblRleHQgfHwgJycpLnJlcGxhY2UoL1teXFxzXS9nLCAnXycpLnN1YnN0cmluZygwLCAxMDApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSlcclxuICAgICAgKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGRlYnVnRmlsZU5hbWUgPSBgaWRtbC1leHRyYWN0ZWQtdGV4dC1kZWJ1Zy0ke0RhdGUubm93KCl9Lmpzb25gO1xyXG4gICAgSURNTFV0aWxzLnNhdmVEZWJ1Z0luZm8odGV4dERlYnVnLCBkZWJ1Z0ZpbGVOYW1lKTtcclxuICAgIGNvbnNvbGUubG9nKGBcXG7inIUgRXh0cmFjdGVkIHRleHQgZGVidWcgY29tcGxldGVkLiBDaGVjayBmaWxlOiAke2RlYnVnRmlsZU5hbWV9YCk7XHJcbiAgICB0aGlzLmRlYnVnRGF0YSA9IHRleHREZWJ1ZztcclxuICAgIHJldHVybiB0ZXh0RGVidWc7XHJcbiAgfVxyXG5cclxuICBhbmFseXplU3RvcnlTdHJ1Y3R1cmUoc3RvcnkpIHtcclxuICAgIGNvbnN0IHN0cnVjdHVyZSA9IHtcclxuICAgICAgcmF3U3RvcnlLZXlzOiBPYmplY3Qua2V5cyhzdG9yeSksXHJcbiAgICAgIGNvbnRlbnRLZXlzOiBzdG9yeS5jb250ZW50ID8gT2JqZWN0LmtleXMoc3RvcnkuY29udGVudCkgOiBbXSxcclxuICAgICAgdGV4dEZvcm1hdHRpbmdLZXlzOiBzdG9yeS50ZXh0Rm9ybWF0dGluZyA/IE9iamVjdC5rZXlzKHN0b3J5LnRleHRGb3JtYXR0aW5nKSA6IFtdLFxyXG4gICAgICBoYXNGb3JtYXR0ZWRDb250ZW50OiAhIShzdG9yeS5jb250ZW50ICYmIHN0b3J5LmNvbnRlbnQuZm9ybWF0dGVkQ29udGVudCksXHJcbiAgICAgIGZvcm1hdHRlZENvbnRlbnRMZW5ndGg6IHN0b3J5LmNvbnRlbnQ/LmZvcm1hdHRlZENvbnRlbnQ/Lmxlbmd0aCB8fCAwLFxyXG4gICAgICByYXdTdG9yeURhdGE6IEpTT04uc3RyaW5naWZ5KHN0b3J5LCBudWxsLCAyKS5zdWJzdHJpbmcoMCwgMTAwMCkgKyAnLi4uJ1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIGFuYWx5emVGb3JtYXR0aW5nRXh0cmFjdGlvbihzdG9yeSkge1xyXG4gICAgY29uc3QgZm9ybWF0dGluZyA9IHtcclxuICAgICAgZXh0cmFjdGVkRm9ybWF0dGluZzogc3RvcnkuY29udGVudD8uZm9ybWF0dGVkQ29udGVudCB8fCBbXSxcclxuICAgICAgZm9ybWF0dGluZ1R5cGVzOiB7fSxcclxuICAgICAgYXR0cmlidXRlc0ZvdW5kOiBuZXcgU2V0KCksXHJcbiAgICAgIGZvcm1hdHRpbmdTYW1wbGU6IFtdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBpZiAoc3RvcnkuY29udGVudD8uZm9ybWF0dGVkQ29udGVudCkge1xyXG4gICAgICBzdG9yeS5jb250ZW50LmZvcm1hdHRlZENvbnRlbnQuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAoaXRlbS5mb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICBPYmplY3Qua2V5cyhpdGVtLmZvcm1hdHRpbmcpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgZm9ybWF0dGluZy5hdHRyaWJ1dGVzRm91bmQuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIGlmICghZm9ybWF0dGluZy5mb3JtYXR0aW5nVHlwZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRpbmcuZm9ybWF0dGluZ1R5cGVzW2tleV0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3JtYXR0aW5nLmZvcm1hdHRpbmdUeXBlc1trZXldLnB1c2goaXRlbS5mb3JtYXR0aW5nW2tleV0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChpbmRleCA8IDMpIHsgLy8gU2FtcGxlIGZpcnN0IDMgaXRlbXNcclxuICAgICAgICAgICAgZm9ybWF0dGluZy5mb3JtYXR0aW5nU2FtcGxlLnB1c2goe1xyXG4gICAgICAgICAgICAgIHRleHQ6IGl0ZW0udGV4dD8uc3Vic3RyaW5nKDAsIDUwKSxcclxuICAgICAgICAgICAgICBmb3JtYXR0aW5nOiBpdGVtLmZvcm1hdHRpbmdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZm9ybWF0dGluZy5hdHRyaWJ1dGVzRm91bmQgPSBBcnJheS5mcm9tKGZvcm1hdHRpbmcuYXR0cmlidXRlc0ZvdW5kKTtcclxuICAgIHJldHVybiBmb3JtYXR0aW5nO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdEFsbFhNTEF0dHJpYnV0ZXMoc3RvcnkpIHtcclxuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0aW5nIGFsbCBYTUwgYXR0cmlidXRlcy4uLicpO1xyXG4gICAgXHJcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xyXG4gICAgICBzdG9yeUxldmVsQXR0cmlidXRlczoge30sXHJcbiAgICAgIGNvbnRlbnRMZXZlbEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICBhbGxBdHRyaWJ1dGVOYW1lczogbmV3IFNldCgpXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGF0dHJpYnV0ZXMgZnJvbSBzdG9yeSBvYmplY3QgcmVjdXJzaXZlbHlcclxuICAgIGNvbnN0IGV4dHJhY3RBdHRyaWJ1dGVzID0gKG9iaiwgcGF0aCA9ICcnKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnQF8nKSkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmFsbEF0dHJpYnV0ZU5hbWVzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5O1xyXG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuc3RvcnlMZXZlbEF0dHJpYnV0ZXNbZnVsbFBhdGhdKSB7XHJcbiAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdG9yeUxldmVsQXR0cmlidXRlc1tmdWxsUGF0aF0gPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGV4dHJhY3RBdHRyaWJ1dGVzKG9ialtrZXldLCBwYXRoID8gYCR7cGF0aH0uJHtrZXl9YCA6IGtleSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGV4dHJhY3RBdHRyaWJ1dGVzKHN0b3J5KTtcclxuICAgIFxyXG4gICAgYXR0cmlidXRlcy5hbGxBdHRyaWJ1dGVOYW1lcyA9IEFycmF5LmZyb20oYXR0cmlidXRlcy5hbGxBdHRyaWJ1dGVOYW1lcyk7XHJcbiAgICBjb25zb2xlLmxvZygnWE1MIGF0dHJpYnV0ZXMgZm91bmQ6JywgYXR0cmlidXRlcy5hbGxBdHRyaWJ1dGVOYW1lcyk7XHJcbiAgICByZXR1cm4gYXR0cmlidXRlcztcclxuICB9XHJcblxyXG4gIGZpbmROZXN0ZWRGb3JtYXR0aW5nRWxlbWVudHMoc3RvcnkpIHtcclxuICAgIGNvbnNvbGUubG9nKCdGaW5kaW5nIG5lc3RlZCBmb3JtYXR0aW5nIGVsZW1lbnRzLi4uJyk7XHJcbiAgICBcclxuICAgIGNvbnN0IG5lc3RlZCA9IHtcclxuICAgICAgY2hhcmFjdGVyU3R5bGVSYW5nZXM6IFtdLFxyXG4gICAgICBwYXJhZ3JhcGhTdHlsZVJhbmdlczogW10sXHJcbiAgICAgIGRpcmVjdEZvcm1hdHRpbmc6IFtdLFxyXG4gICAgICBmb250UmVmZXJlbmNlczogW10sXHJcbiAgICAgIGNvbG9yUmVmZXJlbmNlczogW11cclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnN0IGZpbmROZXN0ZWQgPSAob2JqLCBwYXRoID0gJycpID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChrZXkgPT09ICdDaGFyYWN0ZXJTdHlsZVJhbmdlJykge1xyXG4gICAgICAgICAgICBuZXN0ZWQuY2hhcmFjdGVyU3R5bGVSYW5nZXMucHVzaCh7IHBhdGg6IGN1cnJlbnRQYXRoLCBkYXRhOiB2YWx1ZSB9KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnUGFyYWdyYXBoU3R5bGVSYW5nZScpIHtcclxuICAgICAgICAgICAgbmVzdGVkLnBhcmFncmFwaFN0eWxlUmFuZ2VzLnB1c2goeyBwYXRoOiBjdXJyZW50UGF0aCwgZGF0YTogdmFsdWUgfSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGtleS5pbmNsdWRlcygnRm9udCcpIHx8IGtleS5pbmNsdWRlcygnZm9udCcpKSB7XHJcbiAgICAgICAgICAgIG5lc3RlZC5mb250UmVmZXJlbmNlcy5wdXNoKHsgcGF0aDogY3VycmVudFBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmluY2x1ZGVzKCdDb2xvcicpIHx8IGtleS5pbmNsdWRlcygnY29sb3InKSkge1xyXG4gICAgICAgICAgICBuZXN0ZWQuY29sb3JSZWZlcmVuY2VzLnB1c2goeyBwYXRoOiBjdXJyZW50UGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChrZXkuc3RhcnRzV2l0aCgnQF8nKSAmJiBJRE1MVXRpbHMuaXNGb3JtYXR0aW5nQXR0cmlidXRlKGtleSkpIHtcclxuICAgICAgICAgICAgbmVzdGVkLmRpcmVjdEZvcm1hdHRpbmcucHVzaCh7IHBhdGg6IGN1cnJlbnRQYXRoLCBhdHRyaWJ1dGU6IGtleSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGZpbmROZXN0ZWQodmFsdWUsIGN1cnJlbnRQYXRoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZmluZE5lc3RlZChzdG9yeSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdOZXN0ZWQgZm9ybWF0dGluZyBlbGVtZW50czonLCB7XHJcbiAgICAgIGNoYXJhY3RlclN0eWxlUmFuZ2VzOiBuZXN0ZWQuY2hhcmFjdGVyU3R5bGVSYW5nZXMubGVuZ3RoLFxyXG4gICAgICBwYXJhZ3JhcGhTdHlsZVJhbmdlczogbmVzdGVkLnBhcmFncmFwaFN0eWxlUmFuZ2VzLmxlbmd0aCxcclxuICAgICAgZGlyZWN0Rm9ybWF0dGluZzogbmVzdGVkLmRpcmVjdEZvcm1hdHRpbmcubGVuZ3RoLFxyXG4gICAgICBmb250UmVmZXJlbmNlczogbmVzdGVkLmZvbnRSZWZlcmVuY2VzLmxlbmd0aCxcclxuICAgICAgY29sb3JSZWZlcmVuY2VzOiBuZXN0ZWQuY29sb3JSZWZlcmVuY2VzLmxlbmd0aFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXN0ZWQ7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0Q2hhcmFjdGVyU3R5bGVSYW5nZXMoc3RvcnkpIHtcclxuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0aW5nIGNoYXJhY3RlciBzdHlsZSByYW5nZXMuLi4nKTtcclxuICAgIFxyXG4gICAgY29uc3QgcmFuZ2VzID0gW107XHJcbiAgICBcclxuICAgIGNvbnN0IGV4dHJhY3RSYW5nZXMgPSAob2JqKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcclxuICAgICAgICBpZiAob2JqLkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNvbnN0IGNoYXJSYW5nZXMgPSBBcnJheS5pc0FycmF5KG9iai5DaGFyYWN0ZXJTdHlsZVJhbmdlKSBcclxuICAgICAgICAgICAgPyBvYmouQ2hhcmFjdGVyU3R5bGVSYW5nZSBcclxuICAgICAgICAgICAgOiBbb2JqLkNoYXJhY3RlclN0eWxlUmFuZ2VdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjaGFyUmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xyXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgYXBwbGllZENoYXJhY3RlclN0eWxlOiByYW5nZVsnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnXSxcclxuICAgICAgICAgICAgICBwb2ludFNpemU6IHJhbmdlWydAX1BvaW50U2l6ZSddLFxyXG4gICAgICAgICAgICAgIGFwcGxpZWRGb250OiByYW5nZVsnQF9BcHBsaWVkRm9udCddLFxyXG4gICAgICAgICAgICAgIGZvbnRTdHlsZTogcmFuZ2VbJ0BfRm9udFN0eWxlJ10sXHJcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiByYW5nZVsnQF9GaWxsQ29sb3InXSxcclxuICAgICAgICAgICAgICBzdHJva2VDb2xvcjogcmFuZ2VbJ0BfU3Ryb2tlQ29sb3InXSxcclxuICAgICAgICAgICAgICB0cmFja2luZzogcmFuZ2VbJ0BfVHJhY2tpbmcnXSxcclxuICAgICAgICAgICAgICBsZWFkaW5nOiByYW5nZVsnQF9MZWFkaW5nJ10sXHJcbiAgICAgICAgICAgICAgYWxsQXR0cmlidXRlczogT2JqZWN0LmtleXMocmFuZ2UpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnQF8nKSksXHJcbiAgICAgICAgICAgICAgY29udGVudExlbmd0aDogcmFuZ2UuQ29udGVudCA/IChBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpID8gcmFuZ2UuQ29udGVudC5qb2luKCcnKS5sZW5ndGggOiBTdHJpbmcocmFuZ2UuQ29udGVudCkubGVuZ3RoKSA6IDAsXHJcbiAgICAgICAgICAgICAgcmF3UmFuZ2U6IHJhbmdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIE9iamVjdC52YWx1ZXMob2JqKS5mb3JFYWNoKHZhbHVlID0+IHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGV4dHJhY3RSYW5nZXModmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBleHRyYWN0UmFuZ2VzKHN0b3J5KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7cmFuZ2VzLmxlbmd0aH0gY2hhcmFjdGVyIHN0eWxlIHJhbmdlc2ApO1xyXG4gICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhgICBSYW5nZSAke2luZGV4ICsgMX06YCwge1xyXG4gICAgICAgIHN0eWxlOiByYW5nZS5hcHBsaWVkQ2hhcmFjdGVyU3R5bGUsXHJcbiAgICAgICAgZm9udFNpemU6IHJhbmdlLnBvaW50U2l6ZSxcclxuICAgICAgICBmb250OiByYW5nZS5hcHBsaWVkRm9udCxcclxuICAgICAgICBjb2xvcjogcmFuZ2UuZmlsbENvbG9yLFxyXG4gICAgICAgIGNvbnRlbnRMZW5ndGg6IHJhbmdlLmNvbnRlbnRMZW5ndGhcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHJhbmdlcztcclxuICB9XHJcblxyXG4gIGV4dHJhY3RQYXJhZ3JhcGhTdHlsZVJhbmdlcyhzdG9yeSkge1xyXG4gICAgY29uc29sZS5sb2coJ0V4dHJhY3RpbmcgcGFyYWdyYXBoIHN0eWxlIHJhbmdlcy4uLicpO1xyXG4gICAgXHJcbiAgICBjb25zdCByYW5nZXMgPSBbXTtcclxuICAgIFxyXG4gICAgY29uc3QgZXh0cmFjdFJhbmdlcyA9IChvYmopID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChvYmouUGFyYWdyYXBoU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgcGFyYVJhbmdlcyA9IEFycmF5LmlzQXJyYXkob2JqLlBhcmFncmFwaFN0eWxlUmFuZ2UpIFxyXG4gICAgICAgICAgICA/IG9iai5QYXJhZ3JhcGhTdHlsZVJhbmdlIFxyXG4gICAgICAgICAgICA6IFtvYmouUGFyYWdyYXBoU3R5bGVSYW5nZV07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHBhcmFSYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICBhcHBsaWVkUGFyYWdyYXBoU3R5bGU6IHJhbmdlWydAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZSddLFxyXG4gICAgICAgICAgICAgIGp1c3RpZmljYXRpb246IHJhbmdlWydAX0p1c3RpZmljYXRpb24nXSxcclxuICAgICAgICAgICAgICBsZWZ0SW5kZW50OiByYW5nZVsnQF9MZWZ0SW5kZW50J10sXHJcbiAgICAgICAgICAgICAgcmlnaHRJbmRlbnQ6IHJhbmdlWydAX1JpZ2h0SW5kZW50J10sXHJcbiAgICAgICAgICAgICAgZmlyc3RMaW5lSW5kZW50OiByYW5nZVsnQF9GaXJzdExpbmVJbmRlbnQnXSxcclxuICAgICAgICAgICAgICBzcGFjZUJlZm9yZTogcmFuZ2VbJ0BfU3BhY2VCZWZvcmUnXSxcclxuICAgICAgICAgICAgICBzcGFjZUFmdGVyOiByYW5nZVsnQF9TcGFjZUFmdGVyJ10sXHJcbiAgICAgICAgICAgICAgYWxsQXR0cmlidXRlczogT2JqZWN0LmtleXMocmFuZ2UpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnQF8nKSksXHJcbiAgICAgICAgICAgICAgaGFzQ2hhcmFjdGVyU3R5bGVSYW5nZXM6ICEhcmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZSxcclxuICAgICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZVJhbmdlQ291bnQ6IHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2UgXHJcbiAgICAgICAgICAgICAgICA/IChBcnJheS5pc0FycmF5KHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2UpID8gcmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZS5sZW5ndGggOiAxKVxyXG4gICAgICAgICAgICAgICAgOiAwLFxyXG4gICAgICAgICAgICAgIHJhd1JhbmdlOiByYW5nZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBPYmplY3QudmFsdWVzKG9iaikuZm9yRWFjaCh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBleHRyYWN0UmFuZ2VzKHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZXh0cmFjdFJhbmdlcyhzdG9yeSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3Jhbmdlcy5sZW5ndGh9IHBhcmFncmFwaCBzdHlsZSByYW5nZXNgKTtcclxuICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coYCAgUmFuZ2UgJHtpbmRleCArIDF9OmAsIHtcclxuICAgICAgICBzdHlsZTogcmFuZ2UuYXBwbGllZFBhcmFncmFwaFN0eWxlLFxyXG4gICAgICAgIGp1c3RpZmljYXRpb246IHJhbmdlLmp1c3RpZmljYXRpb24sXHJcbiAgICAgICAgY2hhcmFjdGVyUmFuZ2VzOiByYW5nZS5jaGFyYWN0ZXJTdHlsZVJhbmdlQ291bnRcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHJhbmdlcztcclxuICB9XHJcblxyXG4gIGV4dHJhY3REaXJlY3RGb3JtYXR0aW5nQXR0cmlidXRlcyhzdG9yeSkge1xyXG4gICAgY29uc29sZS5sb2coJ0V4dHJhY3RpbmcgZGlyZWN0IGZvcm1hdHRpbmcgYXR0cmlidXRlcy4uLicpO1xyXG4gICAgXHJcbiAgICBjb25zdCBkaXJlY3RGb3JtYXR0aW5nID0gW107XHJcbiAgICBcclxuICAgIGNvbnN0IGV4dHJhY3REaXJlY3QgPSAob2JqLCBwYXRoID0gJycpID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdAXycpICYmIElETUxVdGlscy5pc0Zvcm1hdHRpbmdBdHRyaWJ1dGUoa2V5KSkge1xyXG4gICAgICAgICAgICBkaXJlY3RGb3JtYXR0aW5nLnB1c2goe1xyXG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgICAgICAgYXR0cmlidXRlOiBrZXksXHJcbiAgICAgICAgICAgICAgdmFsdWU6IG9ialtrZXldXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGV4dHJhY3REaXJlY3Qob2JqW2tleV0sIHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZXh0cmFjdERpcmVjdChzdG9yeSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2RpcmVjdEZvcm1hdHRpbmcubGVuZ3RofSBkaXJlY3QgZm9ybWF0dGluZyBhdHRyaWJ1dGVzYCk7XHJcbiAgICByZXR1cm4gZGlyZWN0Rm9ybWF0dGluZztcclxuICB9XHJcblxyXG4gIGV4dHJhY3RTdHlsZVJlZmVyZW5jZXMoc3RvcnkpIHtcclxuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0aW5nIHN0eWxlIHJlZmVyZW5jZXMuLi4nKTtcclxuICAgIFxyXG4gICAgY29uc3QgcmVmZXJlbmNlcyA9IHtcclxuICAgICAgcGFyYWdyYXBoU3R5bGVSZWZlcmVuY2VzOiBuZXcgU2V0KCksXHJcbiAgICAgIGNoYXJhY3RlclN0eWxlUmVmZXJlbmNlczogbmV3IFNldCgpLFxyXG4gICAgICBmb250UmVmZXJlbmNlczogbmV3IFNldCgpLFxyXG4gICAgICBjb2xvclJlZmVyZW5jZXM6IG5ldyBTZXQoKVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgZXh0cmFjdFJlZnMgPSAob2JqKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChrZXkgPT09ICdAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZScgJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmVmZXJlbmNlcy5wYXJhZ3JhcGhTdHlsZVJlZmVyZW5jZXMuYWRkKHZhbHVlKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGUnICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJlZmVyZW5jZXMuY2hhcmFjdGVyU3R5bGVSZWZlcmVuY2VzLmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ0BfQXBwbGllZEZvbnQnICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJlZmVyZW5jZXMuZm9udFJlZmVyZW5jZXMuYWRkKHZhbHVlKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoKGtleSA9PT0gJ0BfRmlsbENvbG9yJyB8fCBrZXkgPT09ICdAX1N0cm9rZUNvbG9yJykgJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmVmZXJlbmNlcy5jb2xvclJlZmVyZW5jZXMuYWRkKHZhbHVlKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBleHRyYWN0UmVmcyh2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGV4dHJhY3RSZWZzKHN0b3J5KTtcclxuICAgIFxyXG4gICAgLy8gQ29udmVydCBzZXRzIHRvIGFycmF5c1xyXG4gICAgT2JqZWN0LmtleXMocmVmZXJlbmNlcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICByZWZlcmVuY2VzW2tleV0gPSBBcnJheS5mcm9tKHJlZmVyZW5jZXNba2V5XSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ1N0eWxlIHJlZmVyZW5jZXMgZm91bmQ6JywgcmVmZXJlbmNlcyk7XHJcbiAgICByZXR1cm4gcmVmZXJlbmNlcztcclxuICB9XHJcblxyXG4gIGFuYWx5emVUZXh0RnJhbWVGb3JtYXR0aW5nKHBhZ2VJdGVtcykge1xyXG4gICAgY29uc29sZS5sb2coJ0FuYWx5emluZyB0ZXh0IGZyYW1lIGZvcm1hdHRpbmcuLi4nKTtcclxuICAgIFxyXG4gICAgY29uc3QgdGV4dEZyYW1lcyA9IHBhZ2VJdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnR5cGUgPT09ICdUZXh0RnJhbWUnKTtcclxuICAgIGNvbnN0IGFuYWx5c2lzID0gdGV4dEZyYW1lcy5tYXAoZnJhbWUgPT4gKHtcclxuICAgICAgaWQ6IGZyYW1lLnNlbGYsXHJcbiAgICAgIHBhcmVudFN0b3J5OiBmcmFtZS5wYXJlbnRTdG9yeSxcclxuICAgICAgaGFzUGFyZW50U3Rvcnk6ICEhZnJhbWUucGFyZW50U3RvcnksXHJcbiAgICAgIHRleHRGcmFtZVByZWZlcmVuY2VzOiBmcmFtZS50ZXh0RnJhbWVQcmVmZXJlbmNlcyxcclxuICAgICAgZmlsbENvbG9yOiBmcmFtZS5maWxsQ29sb3IsXHJcbiAgICAgIHN0cm9rZUNvbG9yOiBmcmFtZS5zdHJva2VDb2xvcixcclxuICAgICAgcmF3RnJhbWU6IGZyYW1lXHJcbiAgICB9KSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBBbmFseXplZCAke3RleHRGcmFtZXMubGVuZ3RofSB0ZXh0IGZyYW1lc2ApO1xyXG4gICAgcmV0dXJuIGFuYWx5c2lzO1xyXG4gIH1cclxuXHJcbiAgYW5hbHl6ZVBhcmFncmFwaFN0eWxlcyhzdHlsZVBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coJ0FuYWx5emluZyBwYXJhZ3JhcGggc3R5bGVzLi4uJyk7XHJcbiAgICBcclxuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlUGFyc2VyLmdldFN0eWxlcygpO1xyXG4gICAgY29uc3QgYW5hbHlzaXMgPSB7XHJcbiAgICAgIHRvdGFsU3R5bGVzOiBPYmplY3Qua2V5cyhzdHlsZXMucGFyYWdyYXBoKS5sZW5ndGgsXHJcbiAgICAgIHN0eWxlRGV0YWlsczoge30sXHJcbiAgICAgIGF0dHJpYnV0ZUNvdmVyYWdlOiB7fVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgT2JqZWN0LmVudHJpZXMoc3R5bGVzLnBhcmFncmFwaCkuZm9yRWFjaCgoW3N0eWxlSWQsIHN0eWxlXSkgPT4ge1xyXG4gICAgICBhbmFseXNpcy5zdHlsZURldGFpbHNbc3R5bGVJZF0gPSB7XHJcbiAgICAgICAgbmFtZTogc3R5bGUubmFtZSxcclxuICAgICAgICBwb2ludFNpemU6IHN0eWxlLnBvaW50U2l6ZSxcclxuICAgICAgICBhcHBsaWVkRm9udDogc3R5bGUuYXBwbGllZEZvbnQsXHJcbiAgICAgICAgYWxpZ25tZW50OiBzdHlsZS5hbGlnbm1lbnQsXHJcbiAgICAgICAgZmlsbENvbG9yOiBzdHlsZS5maWxsQ29sb3IsXHJcbiAgICAgICAgYWxsUHJvcGVydGllczogT2JqZWN0LmtleXMoc3R5bGUpXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBUcmFjayB3aGljaCBhdHRyaWJ1dGVzIGFyZSBhdmFpbGFibGVcclxuICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goYXR0ciA9PiB7XHJcbiAgICAgICAgaWYgKCFhbmFseXNpcy5hdHRyaWJ1dGVDb3ZlcmFnZVthdHRyXSkge1xyXG4gICAgICAgICAgYW5hbHlzaXMuYXR0cmlidXRlQ292ZXJhZ2VbYXR0cl0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhbmFseXNpcy5hdHRyaWJ1dGVDb3ZlcmFnZVthdHRyXSsrO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnUGFyYWdyYXBoIHN0eWxlcyBhbmFseXNpczonLCBhbmFseXNpcyk7XHJcbiAgICByZXR1cm4gYW5hbHlzaXM7XHJcbiAgfVxyXG5cclxuICBhbmFseXplQ2hhcmFjdGVyU3R5bGVzKHN0eWxlUGFyc2VyKSB7XHJcbiAgICBjb25zb2xlLmxvZygnQW5hbHl6aW5nIGNoYXJhY3RlciBzdHlsZXMuLi4nKTtcclxuICAgIFxyXG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVQYXJzZXIuZ2V0U3R5bGVzKCk7XHJcbiAgICBjb25zdCBhbmFseXNpcyA9IHtcclxuICAgICAgdG90YWxTdHlsZXM6IE9iamVjdC5rZXlzKHN0eWxlcy5jaGFyYWN0ZXIpLmxlbmd0aCxcclxuICAgICAgc3R5bGVEZXRhaWxzOiB7fSxcclxuICAgICAgYXR0cmlidXRlQ292ZXJhZ2U6IHt9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBPYmplY3QuZW50cmllcyhzdHlsZXMuY2hhcmFjdGVyKS5mb3JFYWNoKChbc3R5bGVJZCwgc3R5bGVdKSA9PiB7XHJcbiAgICAgIGFuYWx5c2lzLnN0eWxlRGV0YWlsc1tzdHlsZUlkXSA9IHtcclxuICAgICAgICBuYW1lOiBzdHlsZS5uYW1lLFxyXG4gICAgICAgIHBvaW50U2l6ZTogc3R5bGUucG9pbnRTaXplLFxyXG4gICAgICAgIGFwcGxpZWRGb250OiBzdHlsZS5hcHBsaWVkRm9udCxcclxuICAgICAgICBmb250U3R5bGU6IHN0eWxlLmZvbnRTdHlsZSxcclxuICAgICAgICBmaWxsQ29sb3I6IHN0eWxlLmZpbGxDb2xvcixcclxuICAgICAgICBhbGxQcm9wZXJ0aWVzOiBPYmplY3Qua2V5cyhzdHlsZSlcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIFRyYWNrIHdoaWNoIGF0dHJpYnV0ZXMgYXJlIGF2YWlsYWJsZVxyXG4gICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChhdHRyID0+IHtcclxuICAgICAgICBpZiAoIWFuYWx5c2lzLmF0dHJpYnV0ZUNvdmVyYWdlW2F0dHJdKSB7XHJcbiAgICAgICAgICBhbmFseXNpcy5hdHRyaWJ1dGVDb3ZlcmFnZVthdHRyXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFuYWx5c2lzLmF0dHJpYnV0ZUNvdmVyYWdlW2F0dHJdKys7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdDaGFyYWN0ZXIgc3R5bGVzIGFuYWx5c2lzOicsIGFuYWx5c2lzKTtcclxuICAgIHJldHVybiBhbmFseXNpcztcclxuICB9XHJcblxyXG4gIGFuYWx5emVTdHlsZUhpZXJhcmNoeShzdHlsZVBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coJ0FuYWx5emluZyBzdHlsZSBoaWVyYXJjaHkuLi4nKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGFyYWdyYXBoU3R5bGVIaWVyYXJjaHk6IHRoaXMuZXh0cmFjdFN0eWxlSGllcmFyY2h5KHN0eWxlUGFyc2VyLmdldFN0eWxlcygpLnBhcmFncmFwaCksXHJcbiAgICAgIGNoYXJhY3RlclN0eWxlSGllcmFyY2h5OiB0aGlzLmV4dHJhY3RTdHlsZUhpZXJhcmNoeShzdHlsZVBhcnNlci5nZXRTdHlsZXMoKS5jaGFyYWN0ZXIpLFxyXG4gICAgICBzdHlsZUluaGVyaXRhbmNlOiB0aGlzLmFuYWx5emVTdHlsZUluaGVyaXRhbmNlKClcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0U3R5bGVIaWVyYXJjaHkoc3R5bGVzKSB7XHJcbiAgICBjb25zdCBoaWVyYXJjaHkgPSB7fTtcclxuICAgIFxyXG4gICAgT2JqZWN0LmVudHJpZXMoc3R5bGVzKS5mb3JFYWNoKChbc3R5bGVJZCwgc3R5bGVdKSA9PiB7XHJcbiAgICAgIGhpZXJhcmNoeVtzdHlsZUlkXSA9IHtcclxuICAgICAgICBiYXNlZE9uOiBzdHlsZS5iYXNlZE9uIHx8IG51bGwsXHJcbiAgICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICAgIGxldmVsOiAwXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQnVpbGQgcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcHNcclxuICAgIE9iamVjdC5lbnRyaWVzKGhpZXJhcmNoeSkuZm9yRWFjaCgoW3N0eWxlSWQsIGluZm9dKSA9PiB7XHJcbiAgICAgIGlmIChpbmZvLmJhc2VkT24gJiYgaGllcmFyY2h5W2luZm8uYmFzZWRPbl0pIHtcclxuICAgICAgICBoaWVyYXJjaHlbaW5mby5iYXNlZE9uXS5jaGlsZHJlbi5wdXNoKHN0eWxlSWQpO1xyXG4gICAgICAgIGluZm8ubGV2ZWwgPSBoaWVyYXJjaHlbaW5mby5iYXNlZE9uXS5sZXZlbCArIDE7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gaGllcmFyY2h5O1xyXG4gIH1cclxuXHJcbiAgYW5hbHl6ZVN0eWxlSW5oZXJpdGFuY2UoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpbmhlcml0YW5jZUNoYWluczogdGhpcy5maW5kSW5oZXJpdGFuY2VDaGFpbnMoKSxcclxuICAgICAgb3ZlcnJpZGVzOiB0aGlzLmZpbmRTdHlsZU92ZXJyaWRlcygpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZmluZEluaGVyaXRhbmNlQ2hhaW5zKCkge1xyXG4gICAgLy8gSW1wbGVtZW50YXRpb24gZm9yIGZpbmRpbmcgaW5oZXJpdGFuY2UgY2hhaW5zXHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG5cclxuICBmaW5kU3R5bGVPdmVycmlkZXMoKSB7XHJcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBmb3IgZmluZGluZyBzdHlsZSBvdmVycmlkZXNcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcblxyXG4gIGFuYWx5emVGb250RGVmaW5pdGlvbnMoc3R5bGVQYXJzZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKCdBbmFseXppbmcgZm9udCBkZWZpbml0aW9ucy4uLicpO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXNvdXJjZXMgPSBzdHlsZVBhcnNlci5nZXRSZXNvdXJjZXMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGF2YWlsYWJsZUZvbnRzOiByZXNvdXJjZXMuZm9udHMgfHwge30sXHJcbiAgICAgIGZvbnRVc2FnZTogdGhpcy5hbmFseXplRm9udFVzYWdlKHN0eWxlUGFyc2VyKSxcclxuICAgICAgbWlzc2luZ0ZvbnRzOiB0aGlzLmZpbmRNaXNzaW5nRm9udHMoc3R5bGVQYXJzZXIpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYW5hbHl6ZUZvbnRVc2FnZShzdHlsZVBhcnNlcikge1xyXG4gICAgY29uc3QgdXNhZ2UgPSB7fTtcclxuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlUGFyc2VyLmdldFN0eWxlcygpO1xyXG4gICAgXHJcbiAgICAvLyBBbmFseXplIGZvbnQgdXNhZ2UgaW4gcGFyYWdyYXBoIHN0eWxlc1xyXG4gICAgT2JqZWN0LnZhbHVlcyhzdHlsZXMucGFyYWdyYXBoKS5mb3JFYWNoKHN0eWxlID0+IHtcclxuICAgICAgaWYgKHN0eWxlLmFwcGxpZWRGb250KSB7XHJcbiAgICAgICAgaWYgKCF1c2FnZVtzdHlsZS5hcHBsaWVkRm9udF0pIHtcclxuICAgICAgICAgIHVzYWdlW3N0eWxlLmFwcGxpZWRGb250XSA9IHsgcGFyYWdyYXBoU3R5bGVzOiAwLCBjaGFyYWN0ZXJTdHlsZXM6IDAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXNhZ2Vbc3R5bGUuYXBwbGllZEZvbnRdLnBhcmFncmFwaFN0eWxlcysrO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQW5hbHl6ZSBmb250IHVzYWdlIGluIGNoYXJhY3RlciBzdHlsZXNcclxuICAgIE9iamVjdC52YWx1ZXMoc3R5bGVzLmNoYXJhY3RlcikuZm9yRWFjaChzdHlsZSA9PiB7XHJcbiAgICAgIGlmIChzdHlsZS5hcHBsaWVkRm9udCkge1xyXG4gICAgICAgIGlmICghdXNhZ2Vbc3R5bGUuYXBwbGllZEZvbnRdKSB7XHJcbiAgICAgICAgICB1c2FnZVtzdHlsZS5hcHBsaWVkRm9udF0gPSB7IHBhcmFncmFwaFN0eWxlczogMCwgY2hhcmFjdGVyU3R5bGVzOiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVzYWdlW3N0eWxlLmFwcGxpZWRGb250XS5jaGFyYWN0ZXJTdHlsZXMrKztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB1c2FnZTtcclxuICB9XHJcblxyXG4gIGZpbmRNaXNzaW5nRm9udHMoc3R5bGVQYXJzZXIpIHtcclxuICAgIGNvbnN0IHVzZWRGb250cyA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IHJlc291cmNlcyA9IHN0eWxlUGFyc2VyLmdldFJlc291cmNlcygpO1xyXG4gICAgY29uc3QgYXZhaWxhYmxlRm9udHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHJlc291cmNlcy5mb250cyB8fCB7fSkpO1xyXG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVQYXJzZXIuZ2V0U3R5bGVzKCk7XHJcbiAgICBcclxuICAgIC8vIENvbGxlY3QgdXNlZCBmb250c1xyXG4gICAgT2JqZWN0LnZhbHVlcyhzdHlsZXMucGFyYWdyYXBoKS5mb3JFYWNoKHN0eWxlID0+IHtcclxuICAgICAgaWYgKHN0eWxlLmFwcGxpZWRGb250KSB1c2VkRm9udHMuYWRkKHN0eWxlLmFwcGxpZWRGb250KTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBPYmplY3QudmFsdWVzKHN0eWxlcy5jaGFyYWN0ZXIpLmZvckVhY2goc3R5bGUgPT4ge1xyXG4gICAgICBpZiAoc3R5bGUuYXBwbGllZEZvbnQpIHVzZWRGb250cy5hZGQoc3R5bGUuYXBwbGllZEZvbnQpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEZpbmQgbWlzc2luZyBmb250c1xyXG4gICAgY29uc3QgbWlzc2luZyA9IEFycmF5LmZyb20odXNlZEZvbnRzKS5maWx0ZXIoZm9udCA9PiAhYXZhaWxhYmxlRm9udHMuaGFzKGZvbnQpKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdXNlZEZvbnRzOiBBcnJheS5mcm9tKHVzZWRGb250cyksXHJcbiAgICAgIGF2YWlsYWJsZUZvbnRzOiBBcnJheS5mcm9tKGF2YWlsYWJsZUZvbnRzKSxcclxuICAgICAgbWlzc2luZ0ZvbnRzOiBtaXNzaW5nXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcGVyZm9ybVhNTFN0cnVjdHVyZUFuYWx5c2lzKHByb2Nlc3Nvcikge1xyXG4gICAgY29uc29sZS5sb2coJ1BlcmZvcm1pbmcgWE1MIHN0cnVjdHVyZSBhbmFseXNpcy4uLicpO1xyXG4gICAgXHJcbiAgICBjb25zdCBhbmFseXNpcyA9IHtcclxuICAgICAgc3RvcnlYTUxTdHJ1Y3R1cmU6IHt9LFxyXG4gICAgICBzcHJlYWRYTUxTdHJ1Y3R1cmU6IHt9LFxyXG4gICAgICByZXNvdXJjZVhNTFN0cnVjdHVyZToge31cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHByb2Nlc3Nvci5zdG9yeVBhcnNlcikge1xyXG4gICAgICBjb25zdCBzdG9yaWVzID0gcHJvY2Vzc29yLnN0b3J5UGFyc2VyLmdldFN0b3JpZXMoKTtcclxuICAgICAgT2JqZWN0LmVudHJpZXMoc3RvcmllcykuZm9yRWFjaCgoW3N0b3J5SWQsIHN0b3J5XSkgPT4ge1xyXG4gICAgICAgIGFuYWx5c2lzLnN0b3J5WE1MU3RydWN0dXJlW3N0b3J5SWRdID0gSURNTFV0aWxzLmdldFhNTFN0cnVjdHVyZShzdG9yeSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcm9jZXNzb3Iuc3ByZWFkcykge1xyXG4gICAgICBPYmplY3QuZW50cmllcyhwcm9jZXNzb3Iuc3ByZWFkcykuZm9yRWFjaCgoW3NwcmVhZElkLCBzcHJlYWRdKSA9PiB7XHJcbiAgICAgICAgYW5hbHlzaXMuc3ByZWFkWE1MU3RydWN0dXJlW3NwcmVhZElkXSA9IElETUxVdGlscy5nZXRYTUxTdHJ1Y3R1cmUoc3ByZWFkKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb2Nlc3Nvci5zdHlsZVBhcnNlcikge1xyXG4gICAgICBjb25zdCBzdHlsZXMgPSBwcm9jZXNzb3Iuc3R5bGVQYXJzZXIuZ2V0U3R5bGVzKCk7XHJcbiAgICAgIGNvbnN0IHJlc291cmNlcyA9IHByb2Nlc3Nvci5zdHlsZVBhcnNlci5nZXRSZXNvdXJjZXMoKTtcclxuICAgICAgYW5hbHlzaXMucmVzb3VyY2VYTUxTdHJ1Y3R1cmUgPSB7XHJcbiAgICAgICAgc3R5bGVzOiBJRE1MVXRpbHMuZ2V0WE1MU3RydWN0dXJlKHN0eWxlcyksXHJcbiAgICAgICAgZm9udHM6IElETUxVdGlscy5nZXRYTUxTdHJ1Y3R1cmUocmVzb3VyY2VzLmZvbnRzKSxcclxuICAgICAgICBjb2xvcnM6IElETUxVdGlscy5nZXRYTUxTdHJ1Y3R1cmUocmVzb3VyY2VzLmNvbG9ycylcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGFuYWx5c2lzO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlRm9ybWF0dGluZ0F0dHJpYnV0ZU1hcHBpbmcoKSB7XHJcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgZm9ybWF0dGluZyBhdHRyaWJ1dGUgbWFwcGluZy4uLicpO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpbkRlc2lnblRvQ1NTOiB7XHJcbiAgICAgICAgJ0BfUG9pbnRTaXplJzogJ2ZvbnQtc2l6ZScsXHJcbiAgICAgICAgJ0BfQXBwbGllZEZvbnQnOiAnZm9udC1mYW1pbHknLFxyXG4gICAgICAgICdAX0ZvbnRTdHlsZSc6ICdmb250LXdlaWdodCcsXHJcbiAgICAgICAgJ0BfRmlsbENvbG9yJzogJ2NvbG9yJyxcclxuICAgICAgICAnQF9KdXN0aWZpY2F0aW9uJzogJ3RleHQtYWxpZ24nLFxyXG4gICAgICAgICdAX0xlYWRpbmcnOiAnbGluZS1oZWlnaHQnLFxyXG4gICAgICAgICdAX1RyYWNraW5nJzogJ2xldHRlci1zcGFjaW5nJyxcclxuICAgICAgICAnQF9MZWZ0SW5kZW50JzogJ21hcmdpbi1sZWZ0JyxcclxuICAgICAgICAnQF9SaWdodEluZGVudCc6ICdtYXJnaW4tcmlnaHQnLFxyXG4gICAgICAgICdAX0ZpcnN0TGluZUluZGVudCc6ICd0ZXh0LWluZGVudCcsXHJcbiAgICAgICAgJ0BfU3BhY2VCZWZvcmUnOiAnbWFyZ2luLXRvcCcsXHJcbiAgICAgICAgJ0BfU3BhY2VBZnRlcic6ICdtYXJnaW4tYm90dG9tJ1xyXG4gICAgICB9LFxyXG4gICAgICBhdHRyaWJ1dGVMb2NhdGlvbnM6IHtcclxuICAgICAgICBmb250U2l6ZTogWydDaGFyYWN0ZXJTdHlsZVJhbmdlQF9Qb2ludFNpemUnLCAnUGFyYWdyYXBoU3R5bGUucG9pbnRTaXplJywgJ0NoYXJhY3RlclN0eWxlLnBvaW50U2l6ZSddLFxyXG4gICAgICAgIGZvbnRGYW1pbHk6IFsnQ2hhcmFjdGVyU3R5bGVSYW5nZUBfQXBwbGllZEZvbnQnLCAnUGFyYWdyYXBoU3R5bGUuYXBwbGllZEZvbnQnLCAnQ2hhcmFjdGVyU3R5bGUuYXBwbGllZEZvbnQnXSxcclxuICAgICAgICBhbGlnbm1lbnQ6IFsnUGFyYWdyYXBoU3R5bGVSYW5nZUBfSnVzdGlmaWNhdGlvbicsICdQYXJhZ3JhcGhTdHlsZS5hbGlnbm1lbnQnXSxcclxuICAgICAgICBjb2xvcjogWydDaGFyYWN0ZXJTdHlsZVJhbmdlQF9GaWxsQ29sb3InLCAnUGFyYWdyYXBoU3R5bGUuZmlsbENvbG9yJywgJ0NoYXJhY3RlclN0eWxlLmZpbGxDb2xvciddXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpZGVudGlmeU1pc3NpbmdGb3JtYXR0aW5nUmVhc29ucyhwcm9jZXNzb3IpIHtcclxuICAgIGNvbnNvbGUubG9nKCdJZGVudGlmeWluZyBtaXNzaW5nIGZvcm1hdHRpbmcgcmVhc29ucy4uLicpO1xyXG4gICAgXHJcbiAgICBjb25zdCByZWFzb25zID0gW107XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIHN0eWxlcyBhcmUgYmVpbmcgZXh0cmFjdGVkIHByb3Blcmx5XHJcbiAgICBpZiAocHJvY2Vzc29yLnN0eWxlUGFyc2VyKSB7XHJcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHByb2Nlc3Nvci5zdHlsZVBhcnNlci5nZXRTdHlsZXMoKTtcclxuICAgICAgaWYgKE9iamVjdC5rZXlzKHN0eWxlcy5wYXJhZ3JhcGgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJlYXNvbnMucHVzaCgnTm8gcGFyYWdyYXBoIHN0eWxlcyBleHRyYWN0ZWQgLSBjaGVjayBSZXNvdXJjZXMvU3R5bGVzLnhtbCBwYXJzaW5nJyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChPYmplY3Qua2V5cyhzdHlsZXMuY2hhcmFjdGVyKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZWFzb25zLnB1c2goJ05vIGNoYXJhY3RlciBzdHlsZXMgZXh0cmFjdGVkIC0gY2hlY2sgUmVzb3VyY2VzL1N0eWxlcy54bWwgcGFyc2luZycpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZWFzb25zLnB1c2goJ1N0eWxlUGFyc2VyIG5vdCBhdmFpbGFibGUgLSBjaGVjayBpbml0aWFsaXphdGlvbicpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiBzdG9yeSBjb250ZW50IGhhcyBmb3JtYXR0aW5nXHJcbiAgICBpZiAocHJvY2Vzc29yLnN0b3J5UGFyc2VyKSB7XHJcbiAgICAgIGNvbnN0IHN0b3JpZXMgPSBwcm9jZXNzb3Iuc3RvcnlQYXJzZXIuZ2V0U3RvcmllcygpO1xyXG4gICAgICBjb25zdCBzdG9yaWVzV2l0aEZvcm1hdHRpbmcgPSBPYmplY3QudmFsdWVzKHN0b3JpZXMpLmZpbHRlcihzdG9yeSA9PiBcclxuICAgICAgICBzdG9yeS5jb250ZW50Py5mb3JtYXR0ZWRDb250ZW50Py5zb21lKGl0ZW0gPT4gXHJcbiAgICAgICAgICBpdGVtLmZvcm1hdHRpbmcgJiYgT2JqZWN0LmtleXMoaXRlbS5mb3JtYXR0aW5nKS5sZW5ndGggPiAxXHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgaWYgKHN0b3JpZXNXaXRoRm9ybWF0dGluZy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZWFzb25zLnB1c2goJ05vIHN0b3JpZXMgaGF2ZSBkZXRhaWxlZCBmb3JtYXR0aW5nIC0gY2hlY2sgQ2hhcmFjdGVyU3R5bGVSYW5nZSBleHRyYWN0aW9uJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgdGV4dCBmcmFtZXMgYXJlIGxpbmtlZCB0byBzdG9yaWVzXHJcbiAgICBpZiAocHJvY2Vzc29yLmVsZW1lbnRzKSB7XHJcbiAgICAgIGNvbnN0IHRleHRGcmFtZXMgPSBwcm9jZXNzb3IuZWxlbWVudHMuZmlsdGVyKGVsID0+IGVsLnR5cGUgPT09ICdUZXh0RnJhbWUnKTtcclxuICAgICAgY29uc3QgbGlua2VkRnJhbWVzID0gdGV4dEZyYW1lcy5maWx0ZXIoZnJhbWUgPT4ge1xyXG4gICAgICAgIGlmIChwcm9jZXNzb3Iuc3RvcnlQYXJzZXIpIHtcclxuICAgICAgICAgIGNvbnN0IHN0b3JpZXMgPSBwcm9jZXNzb3Iuc3RvcnlQYXJzZXIuZ2V0U3RvcmllcygpO1xyXG4gICAgICAgICAgcmV0dXJuIGZyYW1lLnBhcmVudFN0b3J5ICYmIHN0b3JpZXNbZnJhbWUucGFyZW50U3RvcnldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgaWYgKHRleHRGcmFtZXMubGVuZ3RoID4gMCAmJiBsaW5rZWRGcmFtZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmVhc29ucy5wdXNoKCdUZXh0IGZyYW1lcyBub3QgcHJvcGVybHkgbGlua2VkIHRvIHN0b3JpZXMgLSBjaGVjayBwYXJlbnRTdG9yeSByZWZlcmVuY2VzJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlYXNvbnM7XHJcbiAgfVxyXG5cclxuICBnZXREZWJ1Z0RhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kZWJ1Z0RhdGE7XHJcbiAgfVxyXG5cclxuICBjbGVhckRlYnVnRGF0YSgpIHtcclxuICAgIHRoaXMuZGVidWdEYXRhID0ge307XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlYnVnQW5hbHl6ZXI7IFxyXG4iXSwibmFtZXMiOlsiSURNTFV0aWxzIiwicmVxdWlyZSIsIkRlYnVnQW5hbHl6ZXIiLCJjb25zdHJ1Y3RvciIsImRlYnVnRGF0YSIsImFkZENvbXByZWhlbnNpdmVUZXh0Rm9ybWF0dGluZ0RlYnVnIiwicHJvY2Vzc29yIiwiY29uc29sZSIsImxvZyIsImRlYnVnSW5mbyIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInRvdGFsU3RvcmllcyIsIk9iamVjdCIsImtleXMiLCJzdG9yaWVzIiwibGVuZ3RoIiwidG90YWxFbGVtZW50cyIsImVsZW1lbnRzIiwic3R5bGVEZWZpbml0aW9ucyIsInN0eWxlUGFyc2VyIiwiZ2V0U3R5bGVzIiwiZGV0YWlsZWRTdG9yeUFuYWx5c2lzIiwic3ByZWFkRWxlbWVudEFuYWx5c2lzIiwicmVzb3VyY2VzQW5hbHlzaXMiLCJ4bWxTdHJ1Y3R1cmVBbmFseXNpcyIsImZvcm1hdHRpbmdBdHRyaWJ1dGVNYXBwaW5nIiwibWlzc2luZ0Zvcm1hdHRpbmdSZWFzb25zIiwic3RvcnlQYXJzZXIiLCJnZXRTdG9yaWVzIiwic3RvcnlJZCIsInN0b3J5IiwiZW50cmllcyIsInN0b3J5U3RydWN0dXJlIiwiYW5hbHl6ZVN0b3J5U3RydWN0dXJlIiwiZm9ybWF0dGluZ0V4dHJhY3Rpb24iLCJhbmFseXplRm9ybWF0dGluZ0V4dHJhY3Rpb24iLCJ4bWxBdHRyaWJ1dGVzIiwiZXh0cmFjdEFsbFhNTEF0dHJpYnV0ZXMiLCJuZXN0ZWRFbGVtZW50cyIsImZpbmROZXN0ZWRGb3JtYXR0aW5nRWxlbWVudHMiLCJjaGFyYWN0ZXJTdHlsZVJhbmdlcyIsImV4dHJhY3RDaGFyYWN0ZXJTdHlsZVJhbmdlcyIsInBhcmFncmFwaFN0eWxlUmFuZ2VzIiwiZXh0cmFjdFBhcmFncmFwaFN0eWxlUmFuZ2VzIiwiZGlyZWN0Rm9ybWF0dGluZ0F0dHJpYnV0ZXMiLCJleHRyYWN0RGlyZWN0Rm9ybWF0dGluZ0F0dHJpYnV0ZXMiLCJzdHlsZVJlZmVyZW5jZXMiLCJleHRyYWN0U3R5bGVSZWZlcmVuY2VzIiwic3ByZWFkcyIsInNwcmVhZElkIiwic3ByZWFkIiwidGV4dEZyYW1lcyIsInBhZ2VJdGVtcyIsImZpbHRlciIsIml0ZW0iLCJ0eXBlIiwidGV4dEZyYW1lRGV0YWlscyIsImFuYWx5emVUZXh0RnJhbWVGb3JtYXR0aW5nIiwicGFyYWdyYXBoU3R5bGVzIiwiYW5hbHl6ZVBhcmFncmFwaFN0eWxlcyIsImNoYXJhY3RlclN0eWxlcyIsImFuYWx5emVDaGFyYWN0ZXJTdHlsZXMiLCJzdHlsZUhpZXJhcmNoeSIsImFuYWx5emVTdHlsZUhpZXJhcmNoeSIsImZvbnREZWZpbml0aW9ucyIsImFuYWx5emVGb250RGVmaW5pdGlvbnMiLCJwZXJmb3JtWE1MU3RydWN0dXJlQW5hbHlzaXMiLCJjcmVhdGVGb3JtYXR0aW5nQXR0cmlidXRlTWFwcGluZyIsImlkZW50aWZ5TWlzc2luZ0Zvcm1hdHRpbmdSZWFzb25zIiwiZGVidWdGaWxlTmFtZSIsIm5vdyIsInNhdmVEZWJ1Z0luZm8iLCJhZGRTdHlsZU9ubHlEZWJ1ZyIsInN0eWxlRGVidWciLCJnZXRQYXJhZ3JhcGhTdHlsZXMiLCJnZXRDaGFyYWN0ZXJTdHlsZXMiLCJnZXRGb250RGVmaW5pdGlvbnMiLCJhZGRFeHRyYWN0ZWRUZXh0RGVidWciLCJ0ZXh0RGVidWciLCJmcm9tRW50cmllcyIsIm1hcCIsInBsYWluVGV4dCIsImNvbnRlbnQiLCJwcmV2aWV3Iiwic3Vic3RyaW5nIiwid2hpdGVzcGFjZVNhbXBsZSIsInJlcGxhY2UiLCJzdHJ1Y3R1cmUiLCJyYXdTdG9yeUtleXMiLCJjb250ZW50S2V5cyIsInRleHRGb3JtYXR0aW5nS2V5cyIsInRleHRGb3JtYXR0aW5nIiwiaGFzRm9ybWF0dGVkQ29udGVudCIsImZvcm1hdHRlZENvbnRlbnQiLCJmb3JtYXR0ZWRDb250ZW50TGVuZ3RoIiwicmF3U3RvcnlEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImZvcm1hdHRpbmciLCJleHRyYWN0ZWRGb3JtYXR0aW5nIiwiZm9ybWF0dGluZ1R5cGVzIiwiYXR0cmlidXRlc0ZvdW5kIiwiU2V0IiwiZm9ybWF0dGluZ1NhbXBsZSIsImZvckVhY2giLCJpbmRleCIsImtleSIsImFkZCIsInB1c2giLCJ0ZXh0IiwiQXJyYXkiLCJmcm9tIiwiYXR0cmlidXRlcyIsInN0b3J5TGV2ZWxBdHRyaWJ1dGVzIiwiY29udGVudExldmVsQXR0cmlidXRlcyIsImFsbEF0dHJpYnV0ZU5hbWVzIiwiZXh0cmFjdEF0dHJpYnV0ZXMiLCJvYmoiLCJwYXRoIiwic3RhcnRzV2l0aCIsImZ1bGxQYXRoIiwibmVzdGVkIiwiZGlyZWN0Rm9ybWF0dGluZyIsImZvbnRSZWZlcmVuY2VzIiwiY29sb3JSZWZlcmVuY2VzIiwiZmluZE5lc3RlZCIsInZhbHVlIiwiY3VycmVudFBhdGgiLCJkYXRhIiwiaW5jbHVkZXMiLCJpc0Zvcm1hdHRpbmdBdHRyaWJ1dGUiLCJhdHRyaWJ1dGUiLCJyYW5nZXMiLCJleHRyYWN0UmFuZ2VzIiwiQ2hhcmFjdGVyU3R5bGVSYW5nZSIsImNoYXJSYW5nZXMiLCJpc0FycmF5IiwicmFuZ2UiLCJhcHBsaWVkQ2hhcmFjdGVyU3R5bGUiLCJwb2ludFNpemUiLCJhcHBsaWVkRm9udCIsImZvbnRTdHlsZSIsImZpbGxDb2xvciIsInN0cm9rZUNvbG9yIiwidHJhY2tpbmciLCJsZWFkaW5nIiwiYWxsQXR0cmlidXRlcyIsImsiLCJjb250ZW50TGVuZ3RoIiwiQ29udGVudCIsImpvaW4iLCJTdHJpbmciLCJyYXdSYW5nZSIsInZhbHVlcyIsInN0eWxlIiwiZm9udFNpemUiLCJmb250IiwiY29sb3IiLCJQYXJhZ3JhcGhTdHlsZVJhbmdlIiwicGFyYVJhbmdlcyIsImFwcGxpZWRQYXJhZ3JhcGhTdHlsZSIsImp1c3RpZmljYXRpb24iLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJmaXJzdExpbmVJbmRlbnQiLCJzcGFjZUJlZm9yZSIsInNwYWNlQWZ0ZXIiLCJoYXNDaGFyYWN0ZXJTdHlsZVJhbmdlcyIsImNoYXJhY3RlclN0eWxlUmFuZ2VDb3VudCIsImNoYXJhY3RlclJhbmdlcyIsImV4dHJhY3REaXJlY3QiLCJyZWZlcmVuY2VzIiwicGFyYWdyYXBoU3R5bGVSZWZlcmVuY2VzIiwiY2hhcmFjdGVyU3R5bGVSZWZlcmVuY2VzIiwiZXh0cmFjdFJlZnMiLCJhbmFseXNpcyIsImZyYW1lIiwiaWQiLCJzZWxmIiwicGFyZW50U3RvcnkiLCJoYXNQYXJlbnRTdG9yeSIsInRleHRGcmFtZVByZWZlcmVuY2VzIiwicmF3RnJhbWUiLCJzdHlsZXMiLCJ0b3RhbFN0eWxlcyIsInBhcmFncmFwaCIsInN0eWxlRGV0YWlscyIsImF0dHJpYnV0ZUNvdmVyYWdlIiwic3R5bGVJZCIsIm5hbWUiLCJhbGlnbm1lbnQiLCJhbGxQcm9wZXJ0aWVzIiwiYXR0ciIsImNoYXJhY3RlciIsInBhcmFncmFwaFN0eWxlSGllcmFyY2h5IiwiZXh0cmFjdFN0eWxlSGllcmFyY2h5IiwiY2hhcmFjdGVyU3R5bGVIaWVyYXJjaHkiLCJzdHlsZUluaGVyaXRhbmNlIiwiYW5hbHl6ZVN0eWxlSW5oZXJpdGFuY2UiLCJoaWVyYXJjaHkiLCJiYXNlZE9uIiwiY2hpbGRyZW4iLCJsZXZlbCIsImluZm8iLCJpbmhlcml0YW5jZUNoYWlucyIsImZpbmRJbmhlcml0YW5jZUNoYWlucyIsIm92ZXJyaWRlcyIsImZpbmRTdHlsZU92ZXJyaWRlcyIsInJlc291cmNlcyIsImdldFJlc291cmNlcyIsImF2YWlsYWJsZUZvbnRzIiwiZm9udHMiLCJmb250VXNhZ2UiLCJhbmFseXplRm9udFVzYWdlIiwibWlzc2luZ0ZvbnRzIiwiZmluZE1pc3NpbmdGb250cyIsInVzYWdlIiwidXNlZEZvbnRzIiwibWlzc2luZyIsImhhcyIsInN0b3J5WE1MU3RydWN0dXJlIiwic3ByZWFkWE1MU3RydWN0dXJlIiwicmVzb3VyY2VYTUxTdHJ1Y3R1cmUiLCJnZXRYTUxTdHJ1Y3R1cmUiLCJjb2xvcnMiLCJpbkRlc2lnblRvQ1NTIiwiYXR0cmlidXRlTG9jYXRpb25zIiwiZm9udEZhbWlseSIsInJlYXNvbnMiLCJzdG9yaWVzV2l0aEZvcm1hdHRpbmciLCJzb21lIiwiZWwiLCJsaW5rZWRGcmFtZXMiLCJnZXREZWJ1Z0RhdGEiLCJjbGVhckRlYnVnRGF0YSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/debug/DebugAnalyzer.js\n");

/***/ }),

/***/ "./lib/extractors/FileExtractor.js":
/*!*****************************************!*\
  !*** ./lib/extractors/FileExtractor.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst yauzl = __webpack_require__(/*! yauzl */ \"yauzl\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass FileExtractor {\n    constructor(){\n        this.extractedFiles = new Map();\n    }\n    async extractIDMLContents(filePath) {\n        return new Promise((resolve, reject)=>{\n            const extractedData = {};\n            yauzl.open(filePath, {\n                lazyEntries: true\n            }, (err, zipfile)=>{\n                if (err) return reject(err);\n                const allEntries = [];\n                zipfile.on(\"entry\", (entry)=>{\n                    allEntries.push(entry);\n                    if (entry.fileName.endsWith(\"/\")) {\n                        zipfile.readEntry();\n                        return;\n                    }\n                    zipfile.openReadStream(entry, (err, readStream)=>{\n                        if (err) {\n                            console.error(`Error reading ${entry.fileName}:`, err);\n                            zipfile.readEntry();\n                            return;\n                        }\n                        let content = \"\";\n                        readStream.on(\"data\", (chunk)=>{\n                            content += chunk.toString();\n                        });\n                        readStream.on(\"end\", ()=>{\n                            extractedData[entry.fileName] = content;\n                            console.log(`âœ… Extracted: ${entry.fileName} (${content.length} chars)`);\n                            // Always continue reading entries\n                            zipfile.readEntry();\n                        });\n                    });\n                });\n                zipfile.on(\"end\", ()=>{\n                    console.log(`ZIP reading completed. Extracted ${Object.keys(extractedData).length} files`);\n                    // ADD THIS DEBUG:\n                    console.log(\"\\n\\uD83D\\uDD0D === FILES IN IDML ===\");\n                    Object.keys(extractedData).forEach((fileName)=>{\n                        console.log(`  ðŸ“ ${fileName}`);\n                    });\n                    // CHECK FOR STORIES SPECIFICALLY:\n                    const storyFiles = Object.keys(extractedData).filter((name)=>name.startsWith(\"Stories/\"));\n                    console.log(`\\nðŸ“ Found ${storyFiles.length} story files:`, storyFiles);\n                    resolve(extractedData);\n                });\n                zipfile.readEntry();\n            });\n        });\n    }\n    async debugIDMLContents(idmlPath) {\n        console.log(\"\\n\\uD83D\\uDD0D === DEBUGGING IDML CONTENTS ===\");\n        return new Promise((resolve, reject)=>{\n            yauzl.open(idmlPath, {\n                lazyEntries: true\n            }, (err, zipfile)=>{\n                if (err) return reject(err);\n                const contents = [];\n                zipfile.on(\"entry\", (entry)=>{\n                    console.log(`ðŸ“ Found: ${entry.fileName}`);\n                    if (entry.fileName.startsWith(\"Links/\") && IDMLUtils.isImageFile(entry.fileName)) {\n                        console.log(`ðŸ“· EMBEDDED IMAGE FOUND: ${entry.fileName}`);\n                    }\n                    contents.push(entry.fileName);\n                    zipfile.readEntry();\n                });\n                zipfile.on(\"end\", ()=>{\n                    console.log(`\\nðŸ“Š Total files in IDML: ${contents.length}`);\n                    console.log(\"\\uD83D\\uDCC1 Folders found:\", [\n                        ...new Set(contents.map((f)=>f.split(\"/\")[0]))\n                    ]);\n                    const imageFiles = contents.filter((f)=>IDMLUtils.isImageFile(f));\n                    console.log(`ðŸ“· Image files in IDML: ${imageFiles.length}`);\n                    imageFiles.forEach((img)=>console.log(`  - ${img}`));\n                    resolve(contents);\n                });\n                zipfile.readEntry();\n            });\n        });\n    }\n    async debugIDMLContentsDetailed(idmlPath) {\n        console.log(\"\\n\\uD83D\\uDD0D === DETAILED IDML ANALYSIS ===\");\n        return new Promise((resolve, reject)=>{\n            yauzl.open(idmlPath, {\n                lazyEntries: true\n            }, (err, zipfile)=>{\n                if (err) return reject(err);\n                const detailedAnalysis = {\n                    totalFiles: 0,\n                    filesByType: {},\n                    allFiles: [],\n                    binaryFiles: [],\n                    xmlFiles: [],\n                    imageFiles: [],\n                    unknownFiles: [],\n                    fileDetails: {},\n                    suspiciousFiles: [],\n                    largeBinaryFiles: []\n                };\n                zipfile.on(\"entry\", (entry)=>{\n                    detailedAnalysis.totalFiles++;\n                    detailedAnalysis.allFiles.push(entry.fileName);\n                    // Analyze file type and size\n                    const ext = path.extname(entry.fileName).toLowerCase();\n                    const size = entry.uncompressedSize || 0;\n                    const isDirectory = entry.fileName.endsWith(\"/\");\n                    if (!detailedAnalysis.filesByType[ext]) {\n                        detailedAnalysis.filesByType[ext] = [];\n                    }\n                    detailedAnalysis.filesByType[ext].push(entry.fileName);\n                    // Store detailed file info\n                    detailedAnalysis.fileDetails[entry.fileName] = {\n                        compressedSize: entry.compressedSize,\n                        uncompressedSize: entry.uncompressedSize,\n                        compressionMethod: entry.compressionMethod,\n                        isDirectory: isDirectory,\n                        extension: ext\n                    };\n                    if (!isDirectory) {\n                        // Check for images by extension\n                        if (IDMLUtils.isImageFile(entry.fileName)) {\n                            detailedAnalysis.imageFiles.push({\n                                fileName: entry.fileName,\n                                size: size,\n                                compressed: entry.compressedSize,\n                                ratio: entry.compressedSize / size\n                            });\n                            console.log(`ðŸ“· IMAGE FILE FOUND: ${entry.fileName} (${size} bytes)`);\n                        } else if (ext === \".xml\") {\n                            detailedAnalysis.xmlFiles.push(entry.fileName);\n                        } else if (ext === \"\" && size > 1000) {\n                            detailedAnalysis.suspiciousFiles.push({\n                                fileName: entry.fileName,\n                                size: size,\n                                reason: \"No extension but large size\"\n                            });\n                            console.log(`â“ SUSPICIOUS FILE: ${entry.fileName} (${size} bytes, no extension)`);\n                        } else if (size > 10000 && ext !== \".xml\") {\n                            detailedAnalysis.largeBinaryFiles.push({\n                                fileName: entry.fileName,\n                                size: size,\n                                extension: ext\n                            });\n                            console.log(`ðŸ“¦ LARGE BINARY: ${entry.fileName} (${size} bytes, ${ext})`);\n                        } else if (entry.fileName.includes(\"Link\") || entry.fileName.includes(\"Image\") || entry.fileName.includes(\"Graphic\") || size > 50000) {\n                            detailedAnalysis.suspiciousFiles.push({\n                                fileName: entry.fileName,\n                                size: size,\n                                reason: \"Contains image-related keywords or very large\"\n                            });\n                            console.log(`ðŸ” POTENTIAL IMAGE: ${entry.fileName} (${size} bytes)`);\n                        }\n                    }\n                    zipfile.readEntry();\n                });\n                zipfile.on(\"end\", ()=>{\n                    console.log(`\\nðŸ“Š DETAILED ANALYSIS COMPLETE:`);\n                    console.log(`Total files: ${detailedAnalysis.totalFiles}`);\n                    console.log(`Image files found: ${detailedAnalysis.imageFiles.length}`);\n                    console.log(`Suspicious files: ${detailedAnalysis.suspiciousFiles.length}`);\n                    console.log(`Large binary files: ${detailedAnalysis.largeBinaryFiles.length}`);\n                    console.log(`File types: ${Object.keys(detailedAnalysis.filesByType).join(\", \")}`);\n                    resolve(detailedAnalysis);\n                });\n                zipfile.readEntry();\n            });\n        });\n    }\n    async extractSampleContent(idmlPath, fileName, maxBytes = 1000) {\n        console.log(`ðŸ“– Extracting sample from: ${fileName}`);\n        return new Promise((resolve, reject)=>{\n            yauzl.open(idmlPath, {\n                lazyEntries: true\n            }, (err, zipfile)=>{\n                if (err) return reject(err);\n                zipfile.on(\"entry\", (entry)=>{\n                    if (entry.fileName === fileName) {\n                        zipfile.openReadStream(entry, (err, readStream)=>{\n                            if (err) return reject(err);\n                            let content = \"\";\n                            let bytesRead = 0;\n                            readStream.on(\"data\", (chunk)=>{\n                                if (bytesRead < maxBytes) {\n                                    const remainingBytes = maxBytes - bytesRead;\n                                    const chunkToAdd = chunk.slice(0, remainingBytes);\n                                    content += chunkToAdd.toString(\"hex\"); // Get hex representation\n                                    bytesRead += chunkToAdd.length;\n                                }\n                            });\n                            readStream.on(\"end\", ()=>{\n                                resolve({\n                                    fileName: fileName,\n                                    sampleHex: content,\n                                    sampleText: Buffer.from(content, \"hex\").toString(\"utf8\", 0, Math.min(500, content.length / 2)),\n                                    bytesRead: bytesRead\n                                });\n                            });\n                            readStream.on(\"error\", reject);\n                        });\n                    } else {\n                        zipfile.readEntry();\n                    }\n                });\n                zipfile.readEntry();\n            });\n        });\n    }\n    async extractFileContent(idmlPath, fileName) {\n        return new Promise((resolve, reject)=>{\n            yauzl.open(idmlPath, {\n                lazyEntries: true\n            }, (err, zipfile)=>{\n                if (err) return reject(err);\n                zipfile.on(\"entry\", (entry)=>{\n                    if (entry.fileName === fileName) {\n                        zipfile.openReadStream(entry, (err, readStream)=>{\n                            if (err) return reject(err);\n                            let content = \"\";\n                            readStream.on(\"data\", (chunk)=>{\n                                content += chunk.toString();\n                            });\n                            readStream.on(\"end\", ()=>{\n                                resolve(content);\n                            });\n                            readStream.on(\"error\", reject);\n                        });\n                    } else {\n                        zipfile.readEntry();\n                    }\n                });\n                zipfile.readEntry();\n            });\n        });\n    }\n    async extractAndSaveEmbeddedImages(idmlPath, uploadDir) {\n        console.log(\"\\uD83D\\uDDBCï¸ Extracting and saving embedded images...\");\n        const embeddedImages = [];\n        return new Promise((resolve, reject)=>{\n            yauzl.open(idmlPath, {\n                lazyEntries: true\n            }, (err, zipfile)=>{\n                if (err) return reject(err);\n                const imagesToExtract = [];\n                zipfile.on(\"entry\", (entry)=>{\n                    if (entry.fileName.startsWith(\"Links/\") && IDMLUtils.isImageFile(entry.fileName)) {\n                        console.log(`ðŸ“· Found embedded image: ${entry.fileName}`);\n                        imagesToExtract.push(entry);\n                    }\n                    zipfile.readEntry();\n                });\n                zipfile.on(\"end\", async ()=>{\n                    console.log(`Found ${imagesToExtract.length} embedded images to extract`);\n                    // Create Links folder in upload directory\n                    const linksDir = path.join(uploadDir, \"ExtractedLinks\");\n                    if (!fs.existsSync(linksDir)) {\n                        fs.mkdirSync(linksDir, {\n                            recursive: true\n                        });\n                    }\n                    // Extract each image\n                    for (const imageEntry of imagesToExtract){\n                        try {\n                            await this.extractSingleImage(idmlPath, imageEntry, linksDir);\n                            const fileName = path.basename(imageEntry.fileName);\n                            const extractedPath = path.join(linksDir, fileName);\n                            embeddedImages.push({\n                                originalPath: imageEntry.fileName,\n                                extractedPath: extractedPath,\n                                fileName: fileName,\n                                size: imageEntry.uncompressedSize,\n                                isExtracted: fs.existsSync(extractedPath)\n                            });\n                        } catch (error) {\n                            console.error(`âŒ Failed to extract ${imageEntry.fileName}:`, error);\n                        }\n                    }\n                    console.log(`âœ… Extracted ${embeddedImages.length} embedded images`);\n                    resolve(embeddedImages);\n                });\n                zipfile.readEntry();\n            });\n        });\n    }\n    async extractSingleImage(idmlPath, imageEntry, outputDir) {\n        return new Promise((resolve, reject)=>{\n            yauzl.open(idmlPath, {\n                lazyEntries: true\n            }, (err, zipfile)=>{\n                if (err) return reject(err);\n                zipfile.on(\"entry\", (entry)=>{\n                    if (entry.fileName === imageEntry.fileName) {\n                        zipfile.openReadStream(entry, (err, readStream)=>{\n                            if (err) return reject(err);\n                            const fileName = path.basename(entry.fileName);\n                            const outputPath = path.join(outputDir, fileName);\n                            const writeStream = fs.createWriteStream(outputPath);\n                            readStream.pipe(writeStream);\n                            writeStream.on(\"finish\", ()=>{\n                                console.log(`âœ… Extracted: ${fileName}`);\n                                resolve(outputPath);\n                            });\n                            writeStream.on(\"error\", reject);\n                        });\n                    } else {\n                        zipfile.readEntry();\n                    }\n                });\n                zipfile.readEntry();\n            });\n        });\n    }\n    async buildImageMap(packageStructure) {\n        const imageMap = new Map();\n        console.log(\"Building image map...\");\n        // Check all files in resourceMap first\n        if (packageStructure.resourceMap) {\n            packageStructure.resourceMap.forEach((filePath, fileName)=>{\n                if (IDMLUtils.isImageFile(fileName)) {\n                    imageMap.set(fileName, filePath);\n                    // Also add without extension for matching\n                    const nameWithoutExt = path.parse(fileName).name;\n                    imageMap.set(nameWithoutExt, filePath);\n                    console.log(\"Added to image map:\", fileName, \"->\", filePath);\n                }\n            });\n        }\n        // Check Links folder if it exists\n        if (fs.existsSync(packageStructure.linksFolder)) {\n            const files = fs.readdirSync(packageStructure.linksFolder);\n            console.log(\"Links folder contents:\", files);\n            for (const fileName of files){\n                if (IDMLUtils.isImageFile(fileName)) {\n                    const fullPath = path.join(packageStructure.linksFolder, fileName);\n                    imageMap.set(fileName, fullPath);\n                    const nameWithoutExt = path.parse(fileName).name;\n                    imageMap.set(nameWithoutExt, fullPath);\n                    console.log(\"Added from Links folder:\", fileName, \"->\", fullPath);\n                }\n            }\n        }\n        console.log(`ðŸ“¸ Image map built with ${imageMap.size / 2} unique images`);\n        Array.from(imageMap.keys()).forEach((key)=>{\n            console.log(\"  - Image key:\", key);\n        });\n        return imageMap;\n    }\n    async extractEmbeddedImages(packageStructure) {\n        const embeddedImages = new Map();\n        console.log(\"\\uD83D\\uDD0D Extracting embedded images from package...\");\n        // FIX: Use extractedPath instead of undefined property\n        const extractedPath = packageStructure.extractedPath || packageStructure.uploadDir;\n        // Check if there's a Links folder in the package\n        const linksPath = path.join(extractedPath, \"Links\");\n        if (fs.existsSync(linksPath)) {\n            const linkFiles = fs.readdirSync(linksPath);\n            console.log(\"Found link files:\", linkFiles);\n            for (const fileName of linkFiles){\n                if (IDMLUtils.isImageFile(fileName)) {\n                    const fullPath = path.join(linksPath, fileName);\n                    const stats = fs.statSync(fullPath);\n                    embeddedImages.set(fileName, {\n                        path: fullPath,\n                        size: stats.size,\n                        isEmbedded: true,\n                        originalName: fileName\n                    });\n                    console.log(`ðŸ“Ž Found embedded image: ${fileName} (${stats.size} bytes)`);\n                }\n            }\n        }\n        // ALSO check the main package resourceMap for embedded images\n        if (packageStructure.resourceMap) {\n            packageStructure.resourceMap.forEach((filePath, fileName)=>{\n                if (IDMLUtils.isImageFile(fileName) && !embeddedImages.has(fileName)) {\n                    const stats = fs.existsSync(filePath) ? fs.statSync(filePath) : null;\n                    embeddedImages.set(fileName, {\n                        path: filePath,\n                        size: stats ? stats.size : 0,\n                        isEmbedded: packageStructure.isPackageUpload || false,\n                        originalName: fileName\n                    });\n                    console.log(`ðŸ“Ž Found package image: ${fileName}`);\n                }\n            });\n        }\n        console.log(`âœ… Extracted ${embeddedImages.size} embedded/linked images`);\n        return embeddedImages;\n    }\n    getExtractedFiles() {\n        return this.extractedFiles;\n    }\n    clearExtractedFiles() {\n        this.extractedFiles.clear();\n    }\n}\nmodule.exports = FileExtractor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZXh0cmFjdG9ycy9GaWxlRXh0cmFjdG9yLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUN0QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNRSxLQUFLRixtQkFBT0EsQ0FBQztBQUNuQixNQUFNRyxZQUFZSCxtQkFBT0EsQ0FBQztBQUUxQixNQUFNSTtJQUNKQyxhQUFjO1FBQ1osSUFBSSxDQUFDQyxjQUFjLEdBQUcsSUFBSUM7SUFDNUI7SUFFQSxNQUFNQyxvQkFBb0JDLFFBQVEsRUFBRTtRQUNsQyxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0IsTUFBTUMsZ0JBQWdCLENBQUM7WUFFdkJkLE1BQU1lLElBQUksQ0FBQ0wsVUFBVTtnQkFBRU0sYUFBYTtZQUFLLEdBQUcsQ0FBQ0MsS0FBS0M7Z0JBQ2hELElBQUlELEtBQUssT0FBT0osT0FBT0k7Z0JBRXZCLE1BQU1FLGFBQWEsRUFBRTtnQkFFckJELFFBQVFFLEVBQUUsQ0FBQyxTQUFTLENBQUNDO29CQUNuQkYsV0FBV0csSUFBSSxDQUFDRDtvQkFFaEIsSUFBSUEsTUFBTUUsUUFBUSxDQUFDQyxRQUFRLENBQUMsTUFBTTt3QkFDaENOLFFBQVFPLFNBQVM7d0JBQ2pCO29CQUNGO29CQUVBUCxRQUFRUSxjQUFjLENBQUNMLE9BQU8sQ0FBQ0osS0FBS1U7d0JBQ2xDLElBQUlWLEtBQUs7NEJBQ1BXLFFBQVFDLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRVIsTUFBTUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFTjs0QkFDbERDLFFBQVFPLFNBQVM7NEJBQ2pCO3dCQUNGO3dCQUVBLElBQUlLLFVBQVU7d0JBQ2RILFdBQVdQLEVBQUUsQ0FBQyxRQUFRLENBQUNXOzRCQUNyQkQsV0FBV0MsTUFBTUMsUUFBUTt3QkFDM0I7d0JBRUFMLFdBQVdQLEVBQUUsQ0FBQyxPQUFPOzRCQUNuQk4sYUFBYSxDQUFDTyxNQUFNRSxRQUFRLENBQUMsR0FBR087NEJBQ2hDRixRQUFRSyxHQUFHLENBQUMsQ0FBQyxhQUFhLEVBQUVaLE1BQU1FLFFBQVEsQ0FBQyxFQUFFLEVBQUVPLFFBQVFJLE1BQU0sQ0FBQyxPQUFPLENBQUM7NEJBRXRFLGtDQUFrQzs0QkFDbENoQixRQUFRTyxTQUFTO3dCQUNuQjtvQkFDRjtnQkFDRjtnQkFFQVAsUUFBUUUsRUFBRSxDQUFDLE9BQU87b0JBQ2hCUSxRQUFRSyxHQUFHLENBQUMsQ0FBQyxpQ0FBaUMsRUFBRUUsT0FBT0MsSUFBSSxDQUFDdEIsZUFBZW9CLE1BQU0sQ0FBQyxNQUFNLENBQUM7b0JBRXpGLGtCQUFrQjtvQkFDbEJOLFFBQVFLLEdBQUcsQ0FBQztvQkFDWkUsT0FBT0MsSUFBSSxDQUFDdEIsZUFBZXVCLE9BQU8sQ0FBQ2QsQ0FBQUE7d0JBQ2pDSyxRQUFRSyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUVWLFNBQVMsQ0FBQztvQkFDaEM7b0JBRUEsa0NBQWtDO29CQUNsQyxNQUFNZSxhQUFhSCxPQUFPQyxJQUFJLENBQUN0QixlQUFleUIsTUFBTSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxVQUFVLENBQUM7b0JBQzdFYixRQUFRSyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUVLLFdBQVdKLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRUk7b0JBRTVEMUIsUUFBUUU7Z0JBQ1Y7Z0JBRUFJLFFBQVFPLFNBQVM7WUFDbkI7UUFDRjtJQUNGO0lBRUEsTUFBTWlCLGtCQUFrQkMsUUFBUSxFQUFFO1FBQ2hDZixRQUFRSyxHQUFHLENBQUM7UUFFWixPQUFPLElBQUl0QixRQUFRLENBQUNDLFNBQVNDO1lBQzNCYixNQUFNZSxJQUFJLENBQUM0QixVQUFVO2dCQUFFM0IsYUFBYTtZQUFLLEdBQUcsQ0FBQ0MsS0FBS0M7Z0JBQ2hELElBQUlELEtBQUssT0FBT0osT0FBT0k7Z0JBRXZCLE1BQU0yQixXQUFXLEVBQUU7Z0JBRW5CMUIsUUFBUUUsRUFBRSxDQUFDLFNBQVMsQ0FBQ0M7b0JBQ25CTyxRQUFRSyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUVaLE1BQU1FLFFBQVEsQ0FBQyxDQUFDO29CQUV6QyxJQUFJRixNQUFNRSxRQUFRLENBQUNrQixVQUFVLENBQUMsYUFDMUJyQyxVQUFVeUMsV0FBVyxDQUFDeEIsTUFBTUUsUUFBUSxHQUFHO3dCQUN6Q0ssUUFBUUssR0FBRyxDQUFDLENBQUMseUJBQXlCLEVBQUVaLE1BQU1FLFFBQVEsQ0FBQyxDQUFDO29CQUMxRDtvQkFFQXFCLFNBQVN0QixJQUFJLENBQUNELE1BQU1FLFFBQVE7b0JBQzVCTCxRQUFRTyxTQUFTO2dCQUNuQjtnQkFFQVAsUUFBUUUsRUFBRSxDQUFDLE9BQU87b0JBQ2hCUSxRQUFRSyxHQUFHLENBQUMsQ0FBQywwQkFBMEIsRUFBRVcsU0FBU1YsTUFBTSxDQUFDLENBQUM7b0JBQzFETixRQUFRSyxHQUFHLENBQUMsK0JBQXFCOzJCQUFJLElBQUlhLElBQUlGLFNBQVNHLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO3FCQUFHO29CQUVqRixNQUFNQyxhQUFhTixTQUFTTCxNQUFNLENBQUNTLENBQUFBLElBQUs1QyxVQUFVeUMsV0FBVyxDQUFDRztvQkFDOURwQixRQUFRSyxHQUFHLENBQUMsQ0FBQyx3QkFBd0IsRUFBRWlCLFdBQVdoQixNQUFNLENBQUMsQ0FBQztvQkFDMURnQixXQUFXYixPQUFPLENBQUNjLENBQUFBLE1BQU92QixRQUFRSyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUVrQixJQUFJLENBQUM7b0JBRWxEdkMsUUFBUWdDO2dCQUNWO2dCQUVBMUIsUUFBUU8sU0FBUztZQUNuQjtRQUNGO0lBQ0Y7SUFFQSxNQUFNMkIsMEJBQTBCVCxRQUFRLEVBQUU7UUFDeENmLFFBQVFLLEdBQUcsQ0FBQztRQUVaLE9BQU8sSUFBSXRCLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JiLE1BQU1lLElBQUksQ0FBQzRCLFVBQVU7Z0JBQUUzQixhQUFhO1lBQUssR0FBRyxDQUFDQyxLQUFLQztnQkFDaEQsSUFBSUQsS0FBSyxPQUFPSixPQUFPSTtnQkFFdkIsTUFBTW9DLG1CQUFtQjtvQkFDdkJDLFlBQVk7b0JBQ1pDLGFBQWEsQ0FBQztvQkFDZEMsVUFBVSxFQUFFO29CQUNaQyxhQUFhLEVBQUU7b0JBQ2ZDLFVBQVUsRUFBRTtvQkFDWlIsWUFBWSxFQUFFO29CQUNkUyxjQUFjLEVBQUU7b0JBQ2hCQyxhQUFhLENBQUM7b0JBQ2RDLGlCQUFpQixFQUFFO29CQUNuQkMsa0JBQWtCLEVBQUU7Z0JBQ3RCO2dCQUVBNUMsUUFBUUUsRUFBRSxDQUFDLFNBQVMsQ0FBQ0M7b0JBQ25CZ0MsaUJBQWlCQyxVQUFVO29CQUMzQkQsaUJBQWlCRyxRQUFRLENBQUNsQyxJQUFJLENBQUNELE1BQU1FLFFBQVE7b0JBRTdDLDZCQUE2QjtvQkFDN0IsTUFBTXdDLE1BQU03RCxLQUFLOEQsT0FBTyxDQUFDM0MsTUFBTUUsUUFBUSxFQUFFMEMsV0FBVztvQkFDcEQsTUFBTUMsT0FBTzdDLE1BQU04QyxnQkFBZ0IsSUFBSTtvQkFDdkMsTUFBTUMsY0FBYy9DLE1BQU1FLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDO29CQUU1QyxJQUFJLENBQUM2QixpQkFBaUJFLFdBQVcsQ0FBQ1EsSUFBSSxFQUFFO3dCQUN0Q1YsaUJBQWlCRSxXQUFXLENBQUNRLElBQUksR0FBRyxFQUFFO29CQUN4QztvQkFDQVYsaUJBQWlCRSxXQUFXLENBQUNRLElBQUksQ0FBQ3pDLElBQUksQ0FBQ0QsTUFBTUUsUUFBUTtvQkFFckQsMkJBQTJCO29CQUMzQjhCLGlCQUFpQk8sV0FBVyxDQUFDdkMsTUFBTUUsUUFBUSxDQUFDLEdBQUc7d0JBQzdDOEMsZ0JBQWdCaEQsTUFBTWdELGNBQWM7d0JBQ3BDRixrQkFBa0I5QyxNQUFNOEMsZ0JBQWdCO3dCQUN4Q0csbUJBQW1CakQsTUFBTWlELGlCQUFpQjt3QkFDMUNGLGFBQWFBO3dCQUNiRyxXQUFXUjtvQkFDYjtvQkFFQSxJQUFJLENBQUNLLGFBQWE7d0JBQ2hCLGdDQUFnQzt3QkFDaEMsSUFBSWhFLFVBQVV5QyxXQUFXLENBQUN4QixNQUFNRSxRQUFRLEdBQUc7NEJBQ3pDOEIsaUJBQWlCSCxVQUFVLENBQUM1QixJQUFJLENBQUM7Z0NBQy9CQyxVQUFVRixNQUFNRSxRQUFRO2dDQUN4QjJDLE1BQU1BO2dDQUNOTSxZQUFZbkQsTUFBTWdELGNBQWM7Z0NBQ2hDSSxPQUFPcEQsTUFBTWdELGNBQWMsR0FBR0g7NEJBQ2hDOzRCQUNBdEMsUUFBUUssR0FBRyxDQUFDLENBQUMscUJBQXFCLEVBQUVaLE1BQU1FLFFBQVEsQ0FBQyxFQUFFLEVBQUUyQyxLQUFLLE9BQU8sQ0FBQzt3QkFDdEUsT0FHSyxJQUFJSCxRQUFRLFFBQVE7NEJBQ3ZCVixpQkFBaUJLLFFBQVEsQ0FBQ3BDLElBQUksQ0FBQ0QsTUFBTUUsUUFBUTt3QkFDL0MsT0FHSyxJQUFJd0MsUUFBUSxNQUFNRyxPQUFPLE1BQU07NEJBQ2xDYixpQkFBaUJRLGVBQWUsQ0FBQ3ZDLElBQUksQ0FBQztnQ0FDcENDLFVBQVVGLE1BQU1FLFFBQVE7Z0NBQ3hCMkMsTUFBTUE7Z0NBQ05RLFFBQVE7NEJBQ1Y7NEJBQ0E5QyxRQUFRSyxHQUFHLENBQUMsQ0FBQyxtQkFBbUIsRUFBRVosTUFBTUUsUUFBUSxDQUFDLEVBQUUsRUFBRTJDLEtBQUsscUJBQXFCLENBQUM7d0JBQ2xGLE9BR0ssSUFBSUEsT0FBTyxTQUFTSCxRQUFRLFFBQVE7NEJBQ3ZDVixpQkFBaUJTLGdCQUFnQixDQUFDeEMsSUFBSSxDQUFDO2dDQUNyQ0MsVUFBVUYsTUFBTUUsUUFBUTtnQ0FDeEIyQyxNQUFNQTtnQ0FDTkssV0FBV1I7NEJBQ2I7NEJBQ0FuQyxRQUFRSyxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsRUFBRVosTUFBTUUsUUFBUSxDQUFDLEVBQUUsRUFBRTJDLEtBQUssUUFBUSxFQUFFSCxJQUFJLENBQUMsQ0FBQzt3QkFDMUUsT0FHSyxJQUFJMUMsTUFBTUUsUUFBUSxDQUFDb0QsUUFBUSxDQUFDLFdBQ3hCdEQsTUFBTUUsUUFBUSxDQUFDb0QsUUFBUSxDQUFDLFlBQ3hCdEQsTUFBTUUsUUFBUSxDQUFDb0QsUUFBUSxDQUFDLGNBQ3hCVCxPQUFPLE9BQU87NEJBQ3JCYixpQkFBaUJRLGVBQWUsQ0FBQ3ZDLElBQUksQ0FBQztnQ0FDcENDLFVBQVVGLE1BQU1FLFFBQVE7Z0NBQ3hCMkMsTUFBTUE7Z0NBQ05RLFFBQVE7NEJBQ1Y7NEJBQ0E5QyxRQUFRSyxHQUFHLENBQUMsQ0FBQyxvQkFBb0IsRUFBRVosTUFBTUUsUUFBUSxDQUFDLEVBQUUsRUFBRTJDLEtBQUssT0FBTyxDQUFDO3dCQUNyRTtvQkFDRjtvQkFFQWhELFFBQVFPLFNBQVM7Z0JBQ25CO2dCQUVBUCxRQUFRRSxFQUFFLENBQUMsT0FBTztvQkFDaEJRLFFBQVFLLEdBQUcsQ0FBQyxDQUFDLGdDQUFnQyxDQUFDO29CQUM5Q0wsUUFBUUssR0FBRyxDQUFDLENBQUMsYUFBYSxFQUFFb0IsaUJBQWlCQyxVQUFVLENBQUMsQ0FBQztvQkFDekQxQixRQUFRSyxHQUFHLENBQUMsQ0FBQyxtQkFBbUIsRUFBRW9CLGlCQUFpQkgsVUFBVSxDQUFDaEIsTUFBTSxDQUFDLENBQUM7b0JBQ3RFTixRQUFRSyxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRW9CLGlCQUFpQlEsZUFBZSxDQUFDM0IsTUFBTSxDQUFDLENBQUM7b0JBQzFFTixRQUFRSyxHQUFHLENBQUMsQ0FBQyxvQkFBb0IsRUFBRW9CLGlCQUFpQlMsZ0JBQWdCLENBQUM1QixNQUFNLENBQUMsQ0FBQztvQkFDN0VOLFFBQVFLLEdBQUcsQ0FBQyxDQUFDLFlBQVksRUFBRUUsT0FBT0MsSUFBSSxDQUFDaUIsaUJBQWlCRSxXQUFXLEVBQUVxQixJQUFJLENBQUMsTUFBTSxDQUFDO29CQUVqRmhFLFFBQVF5QztnQkFDVjtnQkFFQW5DLFFBQVFPLFNBQVM7WUFDbkI7UUFDRjtJQUNGO0lBRUEsTUFBTW9ELHFCQUFxQmxDLFFBQVEsRUFBRXBCLFFBQVEsRUFBRXVELFdBQVcsSUFBSSxFQUFFO1FBQzlEbEQsUUFBUUssR0FBRyxDQUFDLENBQUMsMkJBQTJCLEVBQUVWLFNBQVMsQ0FBQztRQUVwRCxPQUFPLElBQUlaLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JiLE1BQU1lLElBQUksQ0FBQzRCLFVBQVU7Z0JBQUUzQixhQUFhO1lBQUssR0FBRyxDQUFDQyxLQUFLQztnQkFDaEQsSUFBSUQsS0FBSyxPQUFPSixPQUFPSTtnQkFFdkJDLFFBQVFFLEVBQUUsQ0FBQyxTQUFTLENBQUNDO29CQUNuQixJQUFJQSxNQUFNRSxRQUFRLEtBQUtBLFVBQVU7d0JBQy9CTCxRQUFRUSxjQUFjLENBQUNMLE9BQU8sQ0FBQ0osS0FBS1U7NEJBQ2xDLElBQUlWLEtBQUssT0FBT0osT0FBT0k7NEJBRXZCLElBQUlhLFVBQVU7NEJBQ2QsSUFBSWlELFlBQVk7NEJBRWhCcEQsV0FBV1AsRUFBRSxDQUFDLFFBQVEsQ0FBQ1c7Z0NBQ3JCLElBQUlnRCxZQUFZRCxVQUFVO29DQUN4QixNQUFNRSxpQkFBaUJGLFdBQVdDO29DQUNsQyxNQUFNRSxhQUFhbEQsTUFBTW1ELEtBQUssQ0FBQyxHQUFHRjtvQ0FDbENsRCxXQUFXbUQsV0FBV2pELFFBQVEsQ0FBQyxRQUFRLHlCQUF5QjtvQ0FDaEUrQyxhQUFhRSxXQUFXL0MsTUFBTTtnQ0FDaEM7NEJBQ0Y7NEJBRUFQLFdBQVdQLEVBQUUsQ0FBQyxPQUFPO2dDQUNuQlIsUUFBUTtvQ0FDTlcsVUFBVUE7b0NBQ1Y0RCxXQUFXckQ7b0NBQ1hzRCxZQUFZQyxPQUFPQyxJQUFJLENBQUN4RCxTQUFTLE9BQU9FLFFBQVEsQ0FBQyxRQUFRLEdBQUd1RCxLQUFLQyxHQUFHLENBQUMsS0FBSzFELFFBQVFJLE1BQU0sR0FBQztvQ0FDekY2QyxXQUFXQTtnQ0FDYjs0QkFDRjs0QkFFQXBELFdBQVdQLEVBQUUsQ0FBQyxTQUFTUDt3QkFDekI7b0JBQ0YsT0FBTzt3QkFDTEssUUFBUU8sU0FBUztvQkFDbkI7Z0JBQ0Y7Z0JBRUFQLFFBQVFPLFNBQVM7WUFDbkI7UUFDRjtJQUNGO0lBRUEsTUFBTWdFLG1CQUFtQjlDLFFBQVEsRUFBRXBCLFFBQVEsRUFBRTtRQUMzQyxPQUFPLElBQUlaLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JiLE1BQU1lLElBQUksQ0FBQzRCLFVBQVU7Z0JBQUUzQixhQUFhO1lBQUssR0FBRyxDQUFDQyxLQUFLQztnQkFDaEQsSUFBSUQsS0FBSyxPQUFPSixPQUFPSTtnQkFFdkJDLFFBQVFFLEVBQUUsQ0FBQyxTQUFTLENBQUNDO29CQUNuQixJQUFJQSxNQUFNRSxRQUFRLEtBQUtBLFVBQVU7d0JBQy9CTCxRQUFRUSxjQUFjLENBQUNMLE9BQU8sQ0FBQ0osS0FBS1U7NEJBQ2xDLElBQUlWLEtBQUssT0FBT0osT0FBT0k7NEJBRXZCLElBQUlhLFVBQVU7NEJBQ2RILFdBQVdQLEVBQUUsQ0FBQyxRQUFRLENBQUNXO2dDQUNyQkQsV0FBV0MsTUFBTUMsUUFBUTs0QkFDM0I7NEJBRUFMLFdBQVdQLEVBQUUsQ0FBQyxPQUFPO2dDQUNuQlIsUUFBUWtCOzRCQUNWOzRCQUVBSCxXQUFXUCxFQUFFLENBQUMsU0FBU1A7d0JBQ3pCO29CQUNGLE9BQU87d0JBQ0xLLFFBQVFPLFNBQVM7b0JBQ25CO2dCQUNGO2dCQUVBUCxRQUFRTyxTQUFTO1lBQ25CO1FBQ0Y7SUFDRjtJQUVBLE1BQU1pRSw2QkFBNkIvQyxRQUFRLEVBQUVnRCxTQUFTLEVBQUU7UUFDdEQvRCxRQUFRSyxHQUFHLENBQUM7UUFFWixNQUFNMkQsaUJBQWlCLEVBQUU7UUFFekIsT0FBTyxJQUFJakYsUUFBUSxDQUFDQyxTQUFTQztZQUMzQmIsTUFBTWUsSUFBSSxDQUFDNEIsVUFBVTtnQkFBRTNCLGFBQWE7WUFBSyxHQUFHLENBQUNDLEtBQUtDO2dCQUNoRCxJQUFJRCxLQUFLLE9BQU9KLE9BQU9JO2dCQUV2QixNQUFNNEUsa0JBQWtCLEVBQUU7Z0JBRTFCM0UsUUFBUUUsRUFBRSxDQUFDLFNBQVMsQ0FBQ0M7b0JBQ25CLElBQUlBLE1BQU1FLFFBQVEsQ0FBQ2tCLFVBQVUsQ0FBQyxhQUFhckMsVUFBVXlDLFdBQVcsQ0FBQ3hCLE1BQU1FLFFBQVEsR0FBRzt3QkFDaEZLLFFBQVFLLEdBQUcsQ0FBQyxDQUFDLHlCQUF5QixFQUFFWixNQUFNRSxRQUFRLENBQUMsQ0FBQzt3QkFDeERzRSxnQkFBZ0J2RSxJQUFJLENBQUNEO29CQUN2QjtvQkFDQUgsUUFBUU8sU0FBUztnQkFDbkI7Z0JBRUFQLFFBQVFFLEVBQUUsQ0FBQyxPQUFPO29CQUNoQlEsUUFBUUssR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFNEQsZ0JBQWdCM0QsTUFBTSxDQUFDLDJCQUEyQixDQUFDO29CQUV4RSwwQ0FBMEM7b0JBQzFDLE1BQU00RCxXQUFXNUYsS0FBSzBFLElBQUksQ0FBQ2UsV0FBVztvQkFDdEMsSUFBSSxDQUFDeEYsR0FBRzRGLFVBQVUsQ0FBQ0QsV0FBVzt3QkFDNUIzRixHQUFHNkYsU0FBUyxDQUFDRixVQUFVOzRCQUFFRyxXQUFXO3dCQUFLO29CQUMzQztvQkFFQSxxQkFBcUI7b0JBQ3JCLEtBQUssTUFBTUMsY0FBY0wsZ0JBQWlCO3dCQUN4QyxJQUFJOzRCQUNGLE1BQU0sSUFBSSxDQUFDTSxrQkFBa0IsQ0FBQ3hELFVBQVV1RCxZQUFZSjs0QkFFcEQsTUFBTXZFLFdBQVdyQixLQUFLa0csUUFBUSxDQUFDRixXQUFXM0UsUUFBUTs0QkFDbEQsTUFBTThFLGdCQUFnQm5HLEtBQUswRSxJQUFJLENBQUNrQixVQUFVdkU7NEJBRTFDcUUsZUFBZXRFLElBQUksQ0FBQztnQ0FDbEJnRixjQUFjSixXQUFXM0UsUUFBUTtnQ0FDakM4RSxlQUFlQTtnQ0FDZjlFLFVBQVVBO2dDQUNWMkMsTUFBTWdDLFdBQVcvQixnQkFBZ0I7Z0NBQ2pDb0MsYUFBYXBHLEdBQUc0RixVQUFVLENBQUNNOzRCQUM3Qjt3QkFFRixFQUFFLE9BQU94RSxPQUFPOzRCQUNkRCxRQUFRQyxLQUFLLENBQUMsQ0FBQyxvQkFBb0IsRUFBRXFFLFdBQVczRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUVNO3dCQUMvRDtvQkFDRjtvQkFFQUQsUUFBUUssR0FBRyxDQUFDLENBQUMsWUFBWSxFQUFFMkQsZUFBZTFELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztvQkFDbEV0QixRQUFRZ0Y7Z0JBQ1Y7Z0JBRUExRSxRQUFRTyxTQUFTO1lBQ25CO1FBQ0Y7SUFDRjtJQUVBLE1BQU0wRSxtQkFBbUJ4RCxRQUFRLEVBQUV1RCxVQUFVLEVBQUVNLFNBQVMsRUFBRTtRQUN4RCxPQUFPLElBQUk3RixRQUFRLENBQUNDLFNBQVNDO1lBQzNCYixNQUFNZSxJQUFJLENBQUM0QixVQUFVO2dCQUFFM0IsYUFBYTtZQUFLLEdBQUcsQ0FBQ0MsS0FBS0M7Z0JBQ2hELElBQUlELEtBQUssT0FBT0osT0FBT0k7Z0JBRXZCQyxRQUFRRSxFQUFFLENBQUMsU0FBUyxDQUFDQztvQkFDbkIsSUFBSUEsTUFBTUUsUUFBUSxLQUFLMkUsV0FBVzNFLFFBQVEsRUFBRTt3QkFDMUNMLFFBQVFRLGNBQWMsQ0FBQ0wsT0FBTyxDQUFDSixLQUFLVTs0QkFDbEMsSUFBSVYsS0FBSyxPQUFPSixPQUFPSTs0QkFFdkIsTUFBTU0sV0FBV3JCLEtBQUtrRyxRQUFRLENBQUMvRSxNQUFNRSxRQUFROzRCQUM3QyxNQUFNa0YsYUFBYXZHLEtBQUswRSxJQUFJLENBQUM0QixXQUFXakY7NEJBQ3hDLE1BQU1tRixjQUFjdkcsR0FBR3dHLGlCQUFpQixDQUFDRjs0QkFFekM5RSxXQUFXaUYsSUFBSSxDQUFDRjs0QkFFaEJBLFlBQVl0RixFQUFFLENBQUMsVUFBVTtnQ0FDdkJRLFFBQVFLLEdBQUcsQ0FBQyxDQUFDLGFBQWEsRUFBRVYsU0FBUyxDQUFDO2dDQUN0Q1gsUUFBUTZGOzRCQUNWOzRCQUVBQyxZQUFZdEYsRUFBRSxDQUFDLFNBQVNQO3dCQUMxQjtvQkFDRixPQUFPO3dCQUNMSyxRQUFRTyxTQUFTO29CQUNuQjtnQkFDRjtnQkFFQVAsUUFBUU8sU0FBUztZQUNuQjtRQUNGO0lBQ0Y7SUFFQSxNQUFNb0YsY0FBY0MsZ0JBQWdCLEVBQUU7UUFDcEMsTUFBTUMsV0FBVyxJQUFJdkc7UUFFckJvQixRQUFRSyxHQUFHLENBQUM7UUFFWix1Q0FBdUM7UUFDdkMsSUFBSTZFLGlCQUFpQkUsV0FBVyxFQUFFO1lBQ2hDRixpQkFBaUJFLFdBQVcsQ0FBQzNFLE9BQU8sQ0FBQyxDQUFDM0IsVUFBVWE7Z0JBQzlDLElBQUluQixVQUFVeUMsV0FBVyxDQUFDdEIsV0FBVztvQkFDbkN3RixTQUFTRSxHQUFHLENBQUMxRixVQUFVYjtvQkFFdkIsMENBQTBDO29CQUMxQyxNQUFNd0csaUJBQWlCaEgsS0FBS2lILEtBQUssQ0FBQzVGLFVBQVVpQixJQUFJO29CQUNoRHVFLFNBQVNFLEdBQUcsQ0FBQ0MsZ0JBQWdCeEc7b0JBRTdCa0IsUUFBUUssR0FBRyxDQUFDLHVCQUF1QlYsVUFBVSxNQUFNYjtnQkFDckQ7WUFDRjtRQUNGO1FBRUEsa0NBQWtDO1FBQ2xDLElBQUlQLEdBQUc0RixVQUFVLENBQUNlLGlCQUFpQk0sV0FBVyxHQUFHO1lBQy9DLE1BQU1DLFFBQVFsSCxHQUFHbUgsV0FBVyxDQUFDUixpQkFBaUJNLFdBQVc7WUFDekR4RixRQUFRSyxHQUFHLENBQUMsMEJBQTBCb0Y7WUFFdEMsS0FBSyxNQUFNOUYsWUFBWThGLE1BQU87Z0JBQzVCLElBQUlqSCxVQUFVeUMsV0FBVyxDQUFDdEIsV0FBVztvQkFDbkMsTUFBTWdHLFdBQVdySCxLQUFLMEUsSUFBSSxDQUFDa0MsaUJBQWlCTSxXQUFXLEVBQUU3RjtvQkFDekR3RixTQUFTRSxHQUFHLENBQUMxRixVQUFVZ0c7b0JBRXZCLE1BQU1MLGlCQUFpQmhILEtBQUtpSCxLQUFLLENBQUM1RixVQUFVaUIsSUFBSTtvQkFDaER1RSxTQUFTRSxHQUFHLENBQUNDLGdCQUFnQks7b0JBRTdCM0YsUUFBUUssR0FBRyxDQUFDLDRCQUE0QlYsVUFBVSxNQUFNZ0c7Z0JBQzFEO1lBQ0Y7UUFDRjtRQUVBM0YsUUFBUUssR0FBRyxDQUFDLENBQUMsd0JBQXdCLEVBQUU4RSxTQUFTN0MsSUFBSSxHQUFHLEVBQUUsY0FBYyxDQUFDO1FBQ3hFc0QsTUFBTWxDLElBQUksQ0FBQ3lCLFNBQVMzRSxJQUFJLElBQUlDLE9BQU8sQ0FBQ29GLENBQUFBO1lBQ2xDN0YsUUFBUUssR0FBRyxDQUFDLGtCQUFrQndGO1FBQ2hDO1FBRUEsT0FBT1Y7SUFDVDtJQUVBLE1BQU1XLHNCQUFzQlosZ0JBQWdCLEVBQUU7UUFDNUMsTUFBTWxCLGlCQUFpQixJQUFJcEY7UUFFM0JvQixRQUFRSyxHQUFHLENBQUM7UUFFWix1REFBdUQ7UUFDdkQsTUFBTW9FLGdCQUFnQlMsaUJBQWlCVCxhQUFhLElBQUlTLGlCQUFpQm5CLFNBQVM7UUFFbEYsaURBQWlEO1FBQ2pELE1BQU1nQyxZQUFZekgsS0FBSzBFLElBQUksQ0FBQ3lCLGVBQWU7UUFFM0MsSUFBSWxHLEdBQUc0RixVQUFVLENBQUM0QixZQUFZO1lBQzVCLE1BQU1DLFlBQVl6SCxHQUFHbUgsV0FBVyxDQUFDSztZQUNqQy9GLFFBQVFLLEdBQUcsQ0FBQyxxQkFBcUIyRjtZQUVqQyxLQUFLLE1BQU1yRyxZQUFZcUcsVUFBVztnQkFDaEMsSUFBSXhILFVBQVV5QyxXQUFXLENBQUN0QixXQUFXO29CQUNuQyxNQUFNZ0csV0FBV3JILEtBQUswRSxJQUFJLENBQUMrQyxXQUFXcEc7b0JBQ3RDLE1BQU1zRyxRQUFRMUgsR0FBRzJILFFBQVEsQ0FBQ1A7b0JBRTFCM0IsZUFBZXFCLEdBQUcsQ0FBQzFGLFVBQVU7d0JBQzNCckIsTUFBTXFIO3dCQUNOckQsTUFBTTJELE1BQU0zRCxJQUFJO3dCQUNoQjZELFlBQVk7d0JBQ1pDLGNBQWN6RztvQkFDaEI7b0JBRUFLLFFBQVFLLEdBQUcsQ0FBQyxDQUFDLHlCQUF5QixFQUFFVixTQUFTLEVBQUUsRUFBRXNHLE1BQU0zRCxJQUFJLENBQUMsT0FBTyxDQUFDO2dCQUMxRTtZQUNGO1FBQ0Y7UUFFQSw4REFBOEQ7UUFDOUQsSUFBSTRDLGlCQUFpQkUsV0FBVyxFQUFFO1lBQ2hDRixpQkFBaUJFLFdBQVcsQ0FBQzNFLE9BQU8sQ0FBQyxDQUFDM0IsVUFBVWE7Z0JBQzlDLElBQUluQixVQUFVeUMsV0FBVyxDQUFDdEIsYUFBYSxDQUFDcUUsZUFBZXFDLEdBQUcsQ0FBQzFHLFdBQVc7b0JBQ3BFLE1BQU1zRyxRQUFRMUgsR0FBRzRGLFVBQVUsQ0FBQ3JGLFlBQVlQLEdBQUcySCxRQUFRLENBQUNwSCxZQUFZO29CQUVoRWtGLGVBQWVxQixHQUFHLENBQUMxRixVQUFVO3dCQUMzQnJCLE1BQU1RO3dCQUNOd0QsTUFBTTJELFFBQVFBLE1BQU0zRCxJQUFJLEdBQUc7d0JBQzNCNkQsWUFBWWpCLGlCQUFpQm9CLGVBQWUsSUFBSTt3QkFDaERGLGNBQWN6RztvQkFDaEI7b0JBRUFLLFFBQVFLLEdBQUcsQ0FBQyxDQUFDLHdCQUF3QixFQUFFVixTQUFTLENBQUM7Z0JBQ25EO1lBQ0Y7UUFDRjtRQUVBSyxRQUFRSyxHQUFHLENBQUMsQ0FBQyxZQUFZLEVBQUUyRCxlQUFlMUIsSUFBSSxDQUFDLHVCQUF1QixDQUFDO1FBQ3ZFLE9BQU8wQjtJQUNUO0lBRUF1QyxvQkFBb0I7UUFDbEIsT0FBTyxJQUFJLENBQUM1SCxjQUFjO0lBQzVCO0lBRUE2SCxzQkFBc0I7UUFDcEIsSUFBSSxDQUFDN0gsY0FBYyxDQUFDOEgsS0FBSztJQUMzQjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR2xJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRtbC12aWV3ZXIvLi9saWIvZXh0cmFjdG9ycy9GaWxlRXh0cmFjdG9yLmpzPzEyN2MiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeWF1emwgPSByZXF1aXJlKCd5YXV6bCcpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL0lETUxVdGlscycpO1xyXG5cclxuY2xhc3MgRmlsZUV4dHJhY3RvciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmV4dHJhY3RlZEZpbGVzID0gbmV3IE1hcCgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdElETUxDb250ZW50cyhmaWxlUGF0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgZXh0cmFjdGVkRGF0YSA9IHt9O1xyXG4gICAgICBcclxuICAgICAgeWF1emwub3BlbihmaWxlUGF0aCwgeyBsYXp5RW50cmllczogdHJ1ZSB9LCAoZXJyLCB6aXBmaWxlKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGFsbEVudHJpZXMgPSBbXTtcclxuICAgICAgICBcclxuICAgICAgICB6aXBmaWxlLm9uKCdlbnRyeScsIChlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgYWxsRW50cmllcy5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGVudHJ5LmZpbGVOYW1lLmVuZHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICB6aXBmaWxlLm9wZW5SZWFkU3RyZWFtKGVudHJ5LCAoZXJyLCByZWFkU3RyZWFtKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWFkaW5nICR7ZW50cnkuZmlsZU5hbWV9OmAsIGVycik7XHJcbiAgICAgICAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICAgICAgICAgIHJlYWRTdHJlYW0ub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICBjb250ZW50ICs9IGNodW5rLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmVhZFN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGV4dHJhY3RlZERhdGFbZW50cnkuZmlsZU5hbWVdID0gY29udGVudDtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEV4dHJhY3RlZDogJHtlbnRyeS5maWxlTmFtZX0gKCR7Y29udGVudC5sZW5ndGh9IGNoYXJzKWApO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEFsd2F5cyBjb250aW51ZSByZWFkaW5nIGVudHJpZXNcclxuICAgICAgICAgICAgICB6aXBmaWxlLnJlYWRFbnRyeSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB6aXBmaWxlLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWklQIHJlYWRpbmcgY29tcGxldGVkLiBFeHRyYWN0ZWQgJHtPYmplY3Qua2V5cyhleHRyYWN0ZWREYXRhKS5sZW5ndGh9IGZpbGVzYCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEFERCBUSElTIERFQlVHOlxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1xcbvCflI0gPT09IEZJTEVTIElOIElETUwgPT09Jyk7XHJcbiAgICAgICAgICBPYmplY3Qua2V5cyhleHRyYWN0ZWREYXRhKS5mb3JFYWNoKGZpbGVOYW1lID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYCAg8J+TgSAke2ZpbGVOYW1lfWApO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENIRUNLIEZPUiBTVE9SSUVTIFNQRUNJRklDQUxMWTpcclxuICAgICAgICAgIGNvbnN0IHN0b3J5RmlsZXMgPSBPYmplY3Qua2V5cyhleHRyYWN0ZWREYXRhKS5maWx0ZXIobmFtZSA9PiBuYW1lLnN0YXJ0c1dpdGgoJ1N0b3JpZXMvJykpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfk50gRm91bmQgJHtzdG9yeUZpbGVzLmxlbmd0aH0gc3RvcnkgZmlsZXM6YCwgc3RvcnlGaWxlcyk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJlc29sdmUoZXh0cmFjdGVkRGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlYnVnSURNTENvbnRlbnRzKGlkbWxQYXRoKSB7XHJcbiAgICBjb25zb2xlLmxvZygnXFxu8J+UjSA9PT0gREVCVUdHSU5HIElETUwgQ09OVEVOVFMgPT09Jyk7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHlhdXpsLm9wZW4oaWRtbFBhdGgsIHsgbGF6eUVudHJpZXM6IHRydWUgfSwgKGVyciwgemlwZmlsZSkgPT4ge1xyXG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBjb250ZW50cyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHppcGZpbGUub24oJ2VudHJ5JywgKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TgSBGb3VuZDogJHtlbnRyeS5maWxlTmFtZX1gKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGVudHJ5LmZpbGVOYW1lLnN0YXJ0c1dpdGgoJ0xpbmtzLycpICYmIFxyXG4gICAgICAgICAgICAgIElETUxVdGlscy5pc0ltYWdlRmlsZShlbnRyeS5maWxlTmFtZSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk7cgRU1CRURERUQgSU1BR0UgRk9VTkQ6ICR7ZW50cnkuZmlsZU5hbWV9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnRlbnRzLnB1c2goZW50cnkuZmlsZU5hbWUpO1xyXG4gICAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB6aXBmaWxlLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgXFxu8J+TiiBUb3RhbCBmaWxlcyBpbiBJRE1MOiAke2NvbnRlbnRzLmxlbmd0aH1gKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OBIEZvbGRlcnMgZm91bmQ6JywgWy4uLm5ldyBTZXQoY29udGVudHMubWFwKGYgPT4gZi5zcGxpdCgnLycpWzBdKSldKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgaW1hZ2VGaWxlcyA9IGNvbnRlbnRzLmZpbHRlcihmID0+IElETUxVdGlscy5pc0ltYWdlRmlsZShmKSk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TtyBJbWFnZSBmaWxlcyBpbiBJRE1MOiAke2ltYWdlRmlsZXMubGVuZ3RofWApO1xyXG4gICAgICAgICAgaW1hZ2VGaWxlcy5mb3JFYWNoKGltZyA9PiBjb25zb2xlLmxvZyhgICAtICR7aW1nfWApKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmVzb2x2ZShjb250ZW50cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlYnVnSURNTENvbnRlbnRzRGV0YWlsZWQoaWRtbFBhdGgpIHtcclxuICAgIGNvbnNvbGUubG9nKCdcXG7wn5SNID09PSBERVRBSUxFRCBJRE1MIEFOQUxZU0lTID09PScpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB5YXV6bC5vcGVuKGlkbWxQYXRoLCB7IGxhenlFbnRyaWVzOiB0cnVlIH0sIChlcnIsIHppcGZpbGUpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgZGV0YWlsZWRBbmFseXNpcyA9IHtcclxuICAgICAgICAgIHRvdGFsRmlsZXM6IDAsXHJcbiAgICAgICAgICBmaWxlc0J5VHlwZToge30sXHJcbiAgICAgICAgICBhbGxGaWxlczogW10sXHJcbiAgICAgICAgICBiaW5hcnlGaWxlczogW10sXHJcbiAgICAgICAgICB4bWxGaWxlczogW10sXHJcbiAgICAgICAgICBpbWFnZUZpbGVzOiBbXSxcclxuICAgICAgICAgIHVua25vd25GaWxlczogW10sXHJcbiAgICAgICAgICBmaWxlRGV0YWlsczoge30sXHJcbiAgICAgICAgICBzdXNwaWNpb3VzRmlsZXM6IFtdLFxyXG4gICAgICAgICAgbGFyZ2VCaW5hcnlGaWxlczogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHppcGZpbGUub24oJ2VudHJ5JywgKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICBkZXRhaWxlZEFuYWx5c2lzLnRvdGFsRmlsZXMrKztcclxuICAgICAgICAgIGRldGFpbGVkQW5hbHlzaXMuYWxsRmlsZXMucHVzaChlbnRyeS5maWxlTmFtZSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEFuYWx5emUgZmlsZSB0eXBlIGFuZCBzaXplXHJcbiAgICAgICAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoZW50cnkuZmlsZU5hbWUpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICBjb25zdCBzaXplID0gZW50cnkudW5jb21wcmVzc2VkU2l6ZSB8fCAwO1xyXG4gICAgICAgICAgY29uc3QgaXNEaXJlY3RvcnkgPSBlbnRyeS5maWxlTmFtZS5lbmRzV2l0aCgnLycpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoIWRldGFpbGVkQW5hbHlzaXMuZmlsZXNCeVR5cGVbZXh0XSkge1xyXG4gICAgICAgICAgICBkZXRhaWxlZEFuYWx5c2lzLmZpbGVzQnlUeXBlW2V4dF0gPSBbXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRldGFpbGVkQW5hbHlzaXMuZmlsZXNCeVR5cGVbZXh0XS5wdXNoKGVudHJ5LmZpbGVOYW1lKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gU3RvcmUgZGV0YWlsZWQgZmlsZSBpbmZvXHJcbiAgICAgICAgICBkZXRhaWxlZEFuYWx5c2lzLmZpbGVEZXRhaWxzW2VudHJ5LmZpbGVOYW1lXSA9IHtcclxuICAgICAgICAgICAgY29tcHJlc3NlZFNpemU6IGVudHJ5LmNvbXByZXNzZWRTaXplLFxyXG4gICAgICAgICAgICB1bmNvbXByZXNzZWRTaXplOiBlbnRyeS51bmNvbXByZXNzZWRTaXplLFxyXG4gICAgICAgICAgICBjb21wcmVzc2lvbk1ldGhvZDogZW50cnkuY29tcHJlc3Npb25NZXRob2QsXHJcbiAgICAgICAgICAgIGlzRGlyZWN0b3J5OiBpc0RpcmVjdG9yeSxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBleHRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICghaXNEaXJlY3RvcnkpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGltYWdlcyBieSBleHRlbnNpb25cclxuICAgICAgICAgICAgaWYgKElETUxVdGlscy5pc0ltYWdlRmlsZShlbnRyeS5maWxlTmFtZSkpIHtcclxuICAgICAgICAgICAgICBkZXRhaWxlZEFuYWx5c2lzLmltYWdlRmlsZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZW50cnkuZmlsZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxyXG4gICAgICAgICAgICAgICAgY29tcHJlc3NlZDogZW50cnkuY29tcHJlc3NlZFNpemUsXHJcbiAgICAgICAgICAgICAgICByYXRpbzogZW50cnkuY29tcHJlc3NlZFNpemUgLyBzaXplXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk7cgSU1BR0UgRklMRSBGT1VORDogJHtlbnRyeS5maWxlTmFtZX0gKCR7c2l6ZX0gYnl0ZXMpYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBYTUwgZmlsZXNcclxuICAgICAgICAgICAgZWxzZSBpZiAoZXh0ID09PSAnLnhtbCcpIHtcclxuICAgICAgICAgICAgICBkZXRhaWxlZEFuYWx5c2lzLnhtbEZpbGVzLnB1c2goZW50cnkuZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZmlsZXMgd2l0aG91dCBleHRlbnNpb24gKGNvdWxkIGJlIGltYWdlcylcclxuICAgICAgICAgICAgZWxzZSBpZiAoZXh0ID09PSAnJyAmJiBzaXplID4gMTAwMCkge1xyXG4gICAgICAgICAgICAgIGRldGFpbGVkQW5hbHlzaXMuc3VzcGljaW91c0ZpbGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGVudHJ5LmZpbGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcclxuICAgICAgICAgICAgICAgIHJlYXNvbjogJ05vIGV4dGVuc2lvbiBidXQgbGFyZ2Ugc2l6ZSdcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4p2TIFNVU1BJQ0lPVVMgRklMRTogJHtlbnRyeS5maWxlTmFtZX0gKCR7c2l6ZX0gYnl0ZXMsIG5vIGV4dGVuc2lvbilgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGxhcmdlIGJpbmFyeSBmaWxlcyAoY291bGQgYmUgZW1iZWRkZWQgaW1hZ2VzKVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID4gMTAwMDAgJiYgZXh0ICE9PSAnLnhtbCcpIHtcclxuICAgICAgICAgICAgICBkZXRhaWxlZEFuYWx5c2lzLmxhcmdlQmluYXJ5RmlsZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZW50cnkuZmlsZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxyXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBleHRcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TpiBMQVJHRSBCSU5BUlk6ICR7ZW50cnkuZmlsZU5hbWV9ICgke3NpemV9IGJ5dGVzLCAke2V4dH0pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZpbGVzIHRoYXQgbWlnaHQgYmUgZW5jb2RlZC9oaWRkZW4gaW1hZ2VzXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5LmZpbGVOYW1lLmluY2x1ZGVzKCdMaW5rJykgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmZpbGVOYW1lLmluY2x1ZGVzKCdJbWFnZScpIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICBlbnRyeS5maWxlTmFtZS5pbmNsdWRlcygnR3JhcGhpYycpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIHNpemUgPiA1MDAwMCkge1xyXG4gICAgICAgICAgICAgIGRldGFpbGVkQW5hbHlzaXMuc3VzcGljaW91c0ZpbGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGVudHJ5LmZpbGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcclxuICAgICAgICAgICAgICAgIHJlYXNvbjogJ0NvbnRhaW5zIGltYWdlLXJlbGF0ZWQga2V5d29yZHMgb3IgdmVyeSBsYXJnZSdcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBQT1RFTlRJQUwgSU1BR0U6ICR7ZW50cnkuZmlsZU5hbWV9ICgke3NpemV9IGJ5dGVzKWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgemlwZmlsZS5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfk4ogREVUQUlMRUQgQU5BTFlTSVMgQ09NUExFVEU6YCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVG90YWwgZmlsZXM6ICR7ZGV0YWlsZWRBbmFseXNpcy50b3RhbEZpbGVzfWApO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYEltYWdlIGZpbGVzIGZvdW5kOiAke2RldGFpbGVkQW5hbHlzaXMuaW1hZ2VGaWxlcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU3VzcGljaW91cyBmaWxlczogJHtkZXRhaWxlZEFuYWx5c2lzLnN1c3BpY2lvdXNGaWxlcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgTGFyZ2UgYmluYXJ5IGZpbGVzOiAke2RldGFpbGVkQW5hbHlzaXMubGFyZ2VCaW5hcnlGaWxlcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRmlsZSB0eXBlczogJHtPYmplY3Qua2V5cyhkZXRhaWxlZEFuYWx5c2lzLmZpbGVzQnlUeXBlKS5qb2luKCcsICcpfWApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXNvbHZlKGRldGFpbGVkQW5hbHlzaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHRyYWN0U2FtcGxlQ29udGVudChpZG1sUGF0aCwgZmlsZU5hbWUsIG1heEJ5dGVzID0gMTAwMCkge1xyXG4gICAgY29uc29sZS5sb2coYPCfk5YgRXh0cmFjdGluZyBzYW1wbGUgZnJvbTogJHtmaWxlTmFtZX1gKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgeWF1emwub3BlbihpZG1sUGF0aCwgeyBsYXp5RW50cmllczogdHJ1ZSB9LCAoZXJyLCB6aXBmaWxlKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHppcGZpbGUub24oJ2VudHJ5JywgKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICBpZiAoZW50cnkuZmlsZU5hbWUgPT09IGZpbGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHppcGZpbGUub3BlblJlYWRTdHJlYW0oZW50cnksIChlcnIsIHJlYWRTdHJlYW0pID0+IHtcclxuICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSAnJztcclxuICAgICAgICAgICAgICBsZXQgYnl0ZXNSZWFkID0gMDtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICByZWFkU3RyZWFtLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNSZWFkIDwgbWF4Qnl0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nQnl0ZXMgPSBtYXhCeXRlcyAtIGJ5dGVzUmVhZDtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtUb0FkZCA9IGNodW5rLnNsaWNlKDAsIHJlbWFpbmluZ0J5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgY29udGVudCArPSBjaHVua1RvQWRkLnRvU3RyaW5nKCdoZXgnKTsgLy8gR2V0IGhleCByZXByZXNlbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgICBieXRlc1JlYWQgKz0gY2h1bmtUb0FkZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgcmVhZFN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgc2FtcGxlSGV4OiBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICBzYW1wbGVUZXh0OiBCdWZmZXIuZnJvbShjb250ZW50LCAnaGV4JykudG9TdHJpbmcoJ3V0ZjgnLCAwLCBNYXRoLm1pbig1MDAsIGNvbnRlbnQubGVuZ3RoLzIpKSxcclxuICAgICAgICAgICAgICAgICAgYnl0ZXNSZWFkOiBieXRlc1JlYWRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIHJlYWRTdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB6aXBmaWxlLnJlYWRFbnRyeSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHRyYWN0RmlsZUNvbnRlbnQoaWRtbFBhdGgsIGZpbGVOYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB5YXV6bC5vcGVuKGlkbWxQYXRoLCB7IGxhenlFbnRyaWVzOiB0cnVlIH0sIChlcnIsIHppcGZpbGUpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgemlwZmlsZS5vbignZW50cnknLCAoZW50cnkpID0+IHtcclxuICAgICAgICAgIGlmIChlbnRyeS5maWxlTmFtZSA9PT0gZmlsZU5hbWUpIHtcclxuICAgICAgICAgICAgemlwZmlsZS5vcGVuUmVhZFN0cmVhbShlbnRyeSwgKGVyciwgcmVhZFN0cmVhbSkgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgICAgICAgICAgIHJlYWRTdHJlYW0ub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gY2h1bmsudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICByZWFkU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIHJlYWRTdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB6aXBmaWxlLnJlYWRFbnRyeSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHRyYWN0QW5kU2F2ZUVtYmVkZGVkSW1hZ2VzKGlkbWxQYXRoLCB1cGxvYWREaXIpIHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5a877iPIEV4dHJhY3RpbmcgYW5kIHNhdmluZyBlbWJlZGRlZCBpbWFnZXMuLi4nKTtcclxuICAgIFxyXG4gICAgY29uc3QgZW1iZWRkZWRJbWFnZXMgPSBbXTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgeWF1emwub3BlbihpZG1sUGF0aCwgeyBsYXp5RW50cmllczogdHJ1ZSB9LCAoZXJyLCB6aXBmaWxlKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGltYWdlc1RvRXh0cmFjdCA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHppcGZpbGUub24oJ2VudHJ5JywgKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICBpZiAoZW50cnkuZmlsZU5hbWUuc3RhcnRzV2l0aCgnTGlua3MvJykgJiYgSURNTFV0aWxzLmlzSW1hZ2VGaWxlKGVudHJ5LmZpbGVOYW1lKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TtyBGb3VuZCBlbWJlZGRlZCBpbWFnZTogJHtlbnRyeS5maWxlTmFtZX1gKTtcclxuICAgICAgICAgICAgaW1hZ2VzVG9FeHRyYWN0LnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB6aXBmaWxlLm9uKCdlbmQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtpbWFnZXNUb0V4dHJhY3QubGVuZ3RofSBlbWJlZGRlZCBpbWFnZXMgdG8gZXh0cmFjdGApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBDcmVhdGUgTGlua3MgZm9sZGVyIGluIHVwbG9hZCBkaXJlY3RvcnlcclxuICAgICAgICAgIGNvbnN0IGxpbmtzRGlyID0gcGF0aC5qb2luKHVwbG9hZERpciwgJ0V4dHJhY3RlZExpbmtzJyk7XHJcbiAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMobGlua3NEaXIpKSB7XHJcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhsaW5rc0RpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEV4dHJhY3QgZWFjaCBpbWFnZVxyXG4gICAgICAgICAgZm9yIChjb25zdCBpbWFnZUVudHJ5IG9mIGltYWdlc1RvRXh0cmFjdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdFNpbmdsZUltYWdlKGlkbWxQYXRoLCBpbWFnZUVudHJ5LCBsaW5rc0Rpcik7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGltYWdlRW50cnkuZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RlZFBhdGggPSBwYXRoLmpvaW4obGlua3NEaXIsIGZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBlbWJlZGRlZEltYWdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUGF0aDogaW1hZ2VFbnRyeS5maWxlTmFtZSxcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFBhdGg6IGV4dHJhY3RlZFBhdGgsXHJcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBzaXplOiBpbWFnZUVudHJ5LnVuY29tcHJlc3NlZFNpemUsXHJcbiAgICAgICAgICAgICAgICBpc0V4dHJhY3RlZDogZnMuZXhpc3RzU3luYyhleHRyYWN0ZWRQYXRoKVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gZXh0cmFjdCAke2ltYWdlRW50cnkuZmlsZU5hbWV9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEV4dHJhY3RlZCAke2VtYmVkZGVkSW1hZ2VzLmxlbmd0aH0gZW1iZWRkZWQgaW1hZ2VzYCk7XHJcbiAgICAgICAgICByZXNvbHZlKGVtYmVkZGVkSW1hZ2VzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB6aXBmaWxlLnJlYWRFbnRyeSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdFNpbmdsZUltYWdlKGlkbWxQYXRoLCBpbWFnZUVudHJ5LCBvdXRwdXREaXIpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHlhdXpsLm9wZW4oaWRtbFBhdGgsIHsgbGF6eUVudHJpZXM6IHRydWUgfSwgKGVyciwgemlwZmlsZSkgPT4ge1xyXG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcclxuICAgICAgICBcclxuICAgICAgICB6aXBmaWxlLm9uKCdlbnRyeScsIChlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGVudHJ5LmZpbGVOYW1lID09PSBpbWFnZUVudHJ5LmZpbGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHppcGZpbGUub3BlblJlYWRTdHJlYW0oZW50cnksIChlcnIsIHJlYWRTdHJlYW0pID0+IHtcclxuICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGVudHJ5LmZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICBjb25zdCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKG91dHB1dERpciwgZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ob3V0cHV0UGF0aCk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgcmVhZFN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICB3cml0ZVN0cmVhbS5vbignZmluaXNoJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBFeHRyYWN0ZWQ6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dFBhdGgpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIHdyaXRlU3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB6aXBmaWxlLnJlYWRFbnRyeSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYnVpbGRJbWFnZU1hcChwYWNrYWdlU3RydWN0dXJlKSB7XHJcbiAgICBjb25zdCBpbWFnZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0J1aWxkaW5nIGltYWdlIG1hcC4uLicpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBhbGwgZmlsZXMgaW4gcmVzb3VyY2VNYXAgZmlyc3RcclxuICAgIGlmIChwYWNrYWdlU3RydWN0dXJlLnJlc291cmNlTWFwKSB7XHJcbiAgICAgIHBhY2thZ2VTdHJ1Y3R1cmUucmVzb3VyY2VNYXAuZm9yRWFjaCgoZmlsZVBhdGgsIGZpbGVOYW1lKSA9PiB7XHJcbiAgICAgICAgaWYgKElETUxVdGlscy5pc0ltYWdlRmlsZShmaWxlTmFtZSkpIHtcclxuICAgICAgICAgIGltYWdlTWFwLnNldChmaWxlTmFtZSwgZmlsZVBhdGgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBBbHNvIGFkZCB3aXRob3V0IGV4dGVuc2lvbiBmb3IgbWF0Y2hpbmdcclxuICAgICAgICAgIGNvbnN0IG5hbWVXaXRob3V0RXh0ID0gcGF0aC5wYXJzZShmaWxlTmFtZSkubmFtZTtcclxuICAgICAgICAgIGltYWdlTWFwLnNldChuYW1lV2l0aG91dEV4dCwgZmlsZVBhdGgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnQWRkZWQgdG8gaW1hZ2UgbWFwOicsIGZpbGVOYW1lLCAnLT4nLCBmaWxlUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgTGlua3MgZm9sZGVyIGlmIGl0IGV4aXN0c1xyXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMocGFja2FnZVN0cnVjdHVyZS5saW5rc0ZvbGRlcikpIHtcclxuICAgICAgY29uc3QgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhwYWNrYWdlU3RydWN0dXJlLmxpbmtzRm9sZGVyKTtcclxuICAgICAgY29uc29sZS5sb2coJ0xpbmtzIGZvbGRlciBjb250ZW50czonLCBmaWxlcyk7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIGZpbGVzKSB7XHJcbiAgICAgICAgaWYgKElETUxVdGlscy5pc0ltYWdlRmlsZShmaWxlTmFtZSkpIHtcclxuICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKHBhY2thZ2VTdHJ1Y3R1cmUubGlua3NGb2xkZXIsIGZpbGVOYW1lKTtcclxuICAgICAgICAgIGltYWdlTWFwLnNldChmaWxlTmFtZSwgZnVsbFBhdGgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBuYW1lV2l0aG91dEV4dCA9IHBhdGgucGFyc2UoZmlsZU5hbWUpLm5hbWU7XHJcbiAgICAgICAgICBpbWFnZU1hcC5zZXQobmFtZVdpdGhvdXRFeHQsIGZ1bGxQYXRoKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0FkZGVkIGZyb20gTGlua3MgZm9sZGVyOicsIGZpbGVOYW1lLCAnLT4nLCBmdWxsUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDwn5O4IEltYWdlIG1hcCBidWlsdCB3aXRoICR7aW1hZ2VNYXAuc2l6ZSAvIDJ9IHVuaXF1ZSBpbWFnZXNgKTtcclxuICAgIEFycmF5LmZyb20oaW1hZ2VNYXAua2V5cygpKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgIC0gSW1hZ2Uga2V5OicsIGtleSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGltYWdlTWFwO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdEVtYmVkZGVkSW1hZ2VzKHBhY2thZ2VTdHJ1Y3R1cmUpIHtcclxuICAgIGNvbnN0IGVtYmVkZGVkSW1hZ2VzID0gbmV3IE1hcCgpO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygn8J+UjSBFeHRyYWN0aW5nIGVtYmVkZGVkIGltYWdlcyBmcm9tIHBhY2thZ2UuLi4nKTtcclxuICAgIFxyXG4gICAgLy8gRklYOiBVc2UgZXh0cmFjdGVkUGF0aCBpbnN0ZWFkIG9mIHVuZGVmaW5lZCBwcm9wZXJ0eVxyXG4gICAgY29uc3QgZXh0cmFjdGVkUGF0aCA9IHBhY2thZ2VTdHJ1Y3R1cmUuZXh0cmFjdGVkUGF0aCB8fCBwYWNrYWdlU3RydWN0dXJlLnVwbG9hZERpcjtcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIExpbmtzIGZvbGRlciBpbiB0aGUgcGFja2FnZVxyXG4gICAgY29uc3QgbGlua3NQYXRoID0gcGF0aC5qb2luKGV4dHJhY3RlZFBhdGgsICdMaW5rcycpO1xyXG4gICAgXHJcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhsaW5rc1BhdGgpKSB7XHJcbiAgICAgIGNvbnN0IGxpbmtGaWxlcyA9IGZzLnJlYWRkaXJTeW5jKGxpbmtzUGF0aCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBsaW5rIGZpbGVzOicsIGxpbmtGaWxlcyk7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIGxpbmtGaWxlcykge1xyXG4gICAgICAgIGlmIChJRE1MVXRpbHMuaXNJbWFnZUZpbGUoZmlsZU5hbWUpKSB7XHJcbiAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihsaW5rc1BhdGgsIGZpbGVOYW1lKTtcclxuICAgICAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZnVsbFBhdGgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBlbWJlZGRlZEltYWdlcy5zZXQoZmlsZU5hbWUsIHtcclxuICAgICAgICAgICAgcGF0aDogZnVsbFBhdGgsXHJcbiAgICAgICAgICAgIHNpemU6IHN0YXRzLnNpemUsXHJcbiAgICAgICAgICAgIGlzRW1iZWRkZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsTmFtZTogZmlsZU5hbWVcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjiBGb3VuZCBlbWJlZGRlZCBpbWFnZTogJHtmaWxlTmFtZX0gKCR7c3RhdHMuc2l6ZX0gYnl0ZXMpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEFMU08gY2hlY2sgdGhlIG1haW4gcGFja2FnZSByZXNvdXJjZU1hcCBmb3IgZW1iZWRkZWQgaW1hZ2VzXHJcbiAgICBpZiAocGFja2FnZVN0cnVjdHVyZS5yZXNvdXJjZU1hcCkge1xyXG4gICAgICBwYWNrYWdlU3RydWN0dXJlLnJlc291cmNlTWFwLmZvckVhY2goKGZpbGVQYXRoLCBmaWxlTmFtZSkgPT4ge1xyXG4gICAgICAgIGlmIChJRE1MVXRpbHMuaXNJbWFnZUZpbGUoZmlsZU5hbWUpICYmICFlbWJlZGRlZEltYWdlcy5oYXMoZmlsZU5hbWUpKSB7XHJcbiAgICAgICAgICBjb25zdCBzdGF0cyA9IGZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpID8gZnMuc3RhdFN5bmMoZmlsZVBhdGgpIDogbnVsbDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZW1iZWRkZWRJbWFnZXMuc2V0KGZpbGVOYW1lLCB7XHJcbiAgICAgICAgICAgIHBhdGg6IGZpbGVQYXRoLFxyXG4gICAgICAgICAgICBzaXplOiBzdGF0cyA/IHN0YXRzLnNpemUgOiAwLFxyXG4gICAgICAgICAgICBpc0VtYmVkZGVkOiBwYWNrYWdlU3RydWN0dXJlLmlzUGFja2FnZVVwbG9hZCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgb3JpZ2luYWxOYW1lOiBmaWxlTmFtZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OOIEZvdW5kIHBhY2thZ2UgaW1hZ2U6ICR7ZmlsZU5hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYOKchSBFeHRyYWN0ZWQgJHtlbWJlZGRlZEltYWdlcy5zaXplfSBlbWJlZGRlZC9saW5rZWQgaW1hZ2VzYCk7XHJcbiAgICByZXR1cm4gZW1iZWRkZWRJbWFnZXM7XHJcbiAgfVxyXG5cclxuICBnZXRFeHRyYWN0ZWRGaWxlcygpIHtcclxuICAgIHJldHVybiB0aGlzLmV4dHJhY3RlZEZpbGVzO1xyXG4gIH1cclxuXHJcbiAgY2xlYXJFeHRyYWN0ZWRGaWxlcygpIHtcclxuICAgIHRoaXMuZXh0cmFjdGVkRmlsZXMuY2xlYXIoKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmlsZUV4dHJhY3RvcjsgIl0sIm5hbWVzIjpbInlhdXpsIiwicmVxdWlyZSIsInBhdGgiLCJmcyIsIklETUxVdGlscyIsIkZpbGVFeHRyYWN0b3IiLCJjb25zdHJ1Y3RvciIsImV4dHJhY3RlZEZpbGVzIiwiTWFwIiwiZXh0cmFjdElETUxDb250ZW50cyIsImZpbGVQYXRoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJleHRyYWN0ZWREYXRhIiwib3BlbiIsImxhenlFbnRyaWVzIiwiZXJyIiwiemlwZmlsZSIsImFsbEVudHJpZXMiLCJvbiIsImVudHJ5IiwicHVzaCIsImZpbGVOYW1lIiwiZW5kc1dpdGgiLCJyZWFkRW50cnkiLCJvcGVuUmVhZFN0cmVhbSIsInJlYWRTdHJlYW0iLCJjb25zb2xlIiwiZXJyb3IiLCJjb250ZW50IiwiY2h1bmsiLCJ0b1N0cmluZyIsImxvZyIsImxlbmd0aCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwic3RvcnlGaWxlcyIsImZpbHRlciIsIm5hbWUiLCJzdGFydHNXaXRoIiwiZGVidWdJRE1MQ29udGVudHMiLCJpZG1sUGF0aCIsImNvbnRlbnRzIiwiaXNJbWFnZUZpbGUiLCJTZXQiLCJtYXAiLCJmIiwic3BsaXQiLCJpbWFnZUZpbGVzIiwiaW1nIiwiZGVidWdJRE1MQ29udGVudHNEZXRhaWxlZCIsImRldGFpbGVkQW5hbHlzaXMiLCJ0b3RhbEZpbGVzIiwiZmlsZXNCeVR5cGUiLCJhbGxGaWxlcyIsImJpbmFyeUZpbGVzIiwieG1sRmlsZXMiLCJ1bmtub3duRmlsZXMiLCJmaWxlRGV0YWlscyIsInN1c3BpY2lvdXNGaWxlcyIsImxhcmdlQmluYXJ5RmlsZXMiLCJleHQiLCJleHRuYW1lIiwidG9Mb3dlckNhc2UiLCJzaXplIiwidW5jb21wcmVzc2VkU2l6ZSIsImlzRGlyZWN0b3J5IiwiY29tcHJlc3NlZFNpemUiLCJjb21wcmVzc2lvbk1ldGhvZCIsImV4dGVuc2lvbiIsImNvbXByZXNzZWQiLCJyYXRpbyIsInJlYXNvbiIsImluY2x1ZGVzIiwiam9pbiIsImV4dHJhY3RTYW1wbGVDb250ZW50IiwibWF4Qnl0ZXMiLCJieXRlc1JlYWQiLCJyZW1haW5pbmdCeXRlcyIsImNodW5rVG9BZGQiLCJzbGljZSIsInNhbXBsZUhleCIsInNhbXBsZVRleHQiLCJCdWZmZXIiLCJmcm9tIiwiTWF0aCIsIm1pbiIsImV4dHJhY3RGaWxlQ29udGVudCIsImV4dHJhY3RBbmRTYXZlRW1iZWRkZWRJbWFnZXMiLCJ1cGxvYWREaXIiLCJlbWJlZGRlZEltYWdlcyIsImltYWdlc1RvRXh0cmFjdCIsImxpbmtzRGlyIiwiZXhpc3RzU3luYyIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsImltYWdlRW50cnkiLCJleHRyYWN0U2luZ2xlSW1hZ2UiLCJiYXNlbmFtZSIsImV4dHJhY3RlZFBhdGgiLCJvcmlnaW5hbFBhdGgiLCJpc0V4dHJhY3RlZCIsIm91dHB1dERpciIsIm91dHB1dFBhdGgiLCJ3cml0ZVN0cmVhbSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwicGlwZSIsImJ1aWxkSW1hZ2VNYXAiLCJwYWNrYWdlU3RydWN0dXJlIiwiaW1hZ2VNYXAiLCJyZXNvdXJjZU1hcCIsInNldCIsIm5hbWVXaXRob3V0RXh0IiwicGFyc2UiLCJsaW5rc0ZvbGRlciIsImZpbGVzIiwicmVhZGRpclN5bmMiLCJmdWxsUGF0aCIsIkFycmF5Iiwia2V5IiwiZXh0cmFjdEVtYmVkZGVkSW1hZ2VzIiwibGlua3NQYXRoIiwibGlua0ZpbGVzIiwic3RhdHMiLCJzdGF0U3luYyIsImlzRW1iZWRkZWQiLCJvcmlnaW5hbE5hbWUiLCJoYXMiLCJpc1BhY2thZ2VVcGxvYWQiLCJnZXRFeHRyYWN0ZWRGaWxlcyIsImNsZWFyRXh0cmFjdGVkRmlsZXMiLCJjbGVhciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/extractors/FileExtractor.js\n");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Main processor\n\nconst IDMLProcessor = __webpack_require__(/*! ./IDMLProcessor */ \"./lib/IDMLProcessor.js\");\n// Individual modules for advanced usage\nconst IDMLXMLParser = __webpack_require__(/*! ./parsers/XMLParser */ \"./lib/parsers/XMLParser.js\");\nconst FileExtractor = __webpack_require__(/*! ./extractors/FileExtractor */ \"./lib/extractors/FileExtractor.js\");\nconst StyleParser = __webpack_require__(/*! ./parsers/StyleParser */ \"./lib/parsers/StyleParser.js\");\nconst StoryParser = __webpack_require__(/*! ./parsers/StoryParser */ \"./lib/parsers/StoryParser.js\");\nconst ElementParser = __webpack_require__(/*! ./parsers/ElementParser */ \"./lib/parsers/ElementParser.js\");\nconst DocumentParser = __webpack_require__(/*! ./parsers/DocumentParser */ \"./lib/parsers/DocumentParser.js\");\nconst ImageProcessor = __webpack_require__(/*! ./processors/ImageProcessor */ \"./lib/processors/ImageProcessor.js\");\nconst DebugAnalyzer = __webpack_require__(/*! ./debug/DebugAnalyzer */ \"./lib/debug/DebugAnalyzer.js\");\nconst IDMLUtils = __webpack_require__(/*! ./utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nconst ColorUtils = __webpack_require__(/*! ./utils/ColorUtils */ \"./lib/utils/ColorUtils.js\");\nconst InDesignTextMetrics = __webpack_require__(/*! ./utils/InDesignTextMetrics */ \"./lib/utils/InDesignTextMetrics.js\");\nmodule.exports = {\n    // Main class (default export)\n    IDMLProcessor,\n    // Individual modules\n    IDMLXMLParser,\n    FileExtractor,\n    StyleParser,\n    StoryParser,\n    ElementParser,\n    DocumentParser,\n    ImageProcessor,\n    DebugAnalyzer,\n    IDMLUtils,\n    ColorUtils,\n    InDesignTextMetrics,\n    // Convenience exports\n    parsers: {\n        XMLParser: IDMLXMLParser,\n        StyleParser,\n        StoryParser,\n        ElementParser,\n        DocumentParser\n    },\n    extractors: {\n        FileExtractor\n    },\n    processors: {\n        ImageProcessor\n    },\n    debug: {\n        DebugAnalyzer\n    },\n    utils: {\n        IDMLUtils,\n        ColorUtils\n    }\n};\n// Default export for backward compatibility\nmodule.exports[\"default\"] = IDMLProcessor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCOztBQUNqQixNQUFNQSxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBRTlCLHdDQUF3QztBQUN4QyxNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1FLGdCQUFnQkYsbUJBQU9BLENBQUM7QUFDOUIsTUFBTUcsY0FBY0gsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUksY0FBY0osbUJBQU9BLENBQUM7QUFDNUIsTUFBTUssZ0JBQWdCTCxtQkFBT0EsQ0FBQztBQUM5QixNQUFNTSxpQkFBaUJOLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU1PLGlCQUFpQlAsbUJBQU9BLENBQUM7QUFDL0IsTUFBTVEsZ0JBQWdCUixtQkFBT0EsQ0FBQztBQUM5QixNQUFNUyxZQUFZVCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNVSxhQUFhVixtQkFBT0EsQ0FBQztBQUMzQixNQUFNVyxzQkFBc0JYLG1CQUFPQSxDQUFDO0FBRXBDWSxPQUFPQyxPQUFPLEdBQUc7SUFDZiw4QkFBOEI7SUFDOUJkO0lBRUEscUJBQXFCO0lBQ3JCRTtJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUVBLHNCQUFzQjtJQUN0QkcsU0FBUztRQUNQQyxXQUFXZDtRQUNYRTtRQUNBQztRQUNBQztRQUNBQztJQUNGO0lBRUFVLFlBQVk7UUFDVmQ7SUFDRjtJQUVBZSxZQUFZO1FBQ1ZWO0lBQ0Y7SUFFQVcsT0FBTztRQUNMVjtJQUNGO0lBRUFXLE9BQU87UUFDTFY7UUFDQUM7SUFDRjtBQUNGO0FBRUEsNENBQTRDO0FBQzVDRSx5QkFBc0IsR0FBR2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZG1sLXZpZXdlci8uL2xpYi9pbmRleC5qcz9hOGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1haW4gcHJvY2Vzc29yXHJcbmNvbnN0IElETUxQcm9jZXNzb3IgPSByZXF1aXJlKCcuL0lETUxQcm9jZXNzb3InKTtcclxuXHJcbi8vIEluZGl2aWR1YWwgbW9kdWxlcyBmb3IgYWR2YW5jZWQgdXNhZ2VcclxuY29uc3QgSURNTFhNTFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2Vycy9YTUxQYXJzZXInKTtcclxuY29uc3QgRmlsZUV4dHJhY3RvciA9IHJlcXVpcmUoJy4vZXh0cmFjdG9ycy9GaWxlRXh0cmFjdG9yJyk7XHJcbmNvbnN0IFN0eWxlUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXJzL1N0eWxlUGFyc2VyJyk7XHJcbmNvbnN0IFN0b3J5UGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXJzL1N0b3J5UGFyc2VyJyk7XHJcbmNvbnN0IEVsZW1lbnRQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcnMvRWxlbWVudFBhcnNlcicpO1xyXG5jb25zdCBEb2N1bWVudFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2Vycy9Eb2N1bWVudFBhcnNlcicpO1xyXG5jb25zdCBJbWFnZVByb2Nlc3NvciA9IHJlcXVpcmUoJy4vcHJvY2Vzc29ycy9JbWFnZVByb2Nlc3NvcicpO1xyXG5jb25zdCBEZWJ1Z0FuYWx5emVyID0gcmVxdWlyZSgnLi9kZWJ1Zy9EZWJ1Z0FuYWx5emVyJyk7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvSURNTFV0aWxzJyk7XHJcbmNvbnN0IENvbG9yVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL0NvbG9yVXRpbHMnKTtcclxuY29uc3QgSW5EZXNpZ25UZXh0TWV0cmljcyA9IHJlcXVpcmUoJy4vdXRpbHMvSW5EZXNpZ25UZXh0TWV0cmljcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgLy8gTWFpbiBjbGFzcyAoZGVmYXVsdCBleHBvcnQpXHJcbiAgSURNTFByb2Nlc3NvcixcclxuICBcclxuICAvLyBJbmRpdmlkdWFsIG1vZHVsZXNcclxuICBJRE1MWE1MUGFyc2VyLFxyXG4gIEZpbGVFeHRyYWN0b3IsXHJcbiAgU3R5bGVQYXJzZXIsXHJcbiAgU3RvcnlQYXJzZXIsXHJcbiAgRWxlbWVudFBhcnNlcixcclxuICBEb2N1bWVudFBhcnNlcixcclxuICBJbWFnZVByb2Nlc3NvcixcclxuICBEZWJ1Z0FuYWx5emVyLFxyXG4gIElETUxVdGlscyxcclxuICBDb2xvclV0aWxzLFxyXG4gIEluRGVzaWduVGV4dE1ldHJpY3MsXHJcbiAgXHJcbiAgLy8gQ29udmVuaWVuY2UgZXhwb3J0c1xyXG4gIHBhcnNlcnM6IHtcclxuICAgIFhNTFBhcnNlcjogSURNTFhNTFBhcnNlcixcclxuICAgIFN0eWxlUGFyc2VyLFxyXG4gICAgU3RvcnlQYXJzZXIsXHJcbiAgICBFbGVtZW50UGFyc2VyLFxyXG4gICAgRG9jdW1lbnRQYXJzZXJcclxuICB9LFxyXG4gIFxyXG4gIGV4dHJhY3RvcnM6IHtcclxuICAgIEZpbGVFeHRyYWN0b3JcclxuICB9LFxyXG4gIFxyXG4gIHByb2Nlc3NvcnM6IHtcclxuICAgIEltYWdlUHJvY2Vzc29yXHJcbiAgfSxcclxuICBcclxuICBkZWJ1Zzoge1xyXG4gICAgRGVidWdBbmFseXplclxyXG4gIH0sXHJcbiAgXHJcbiAgdXRpbHM6IHtcclxuICAgIElETUxVdGlscyxcclxuICAgIENvbG9yVXRpbHNcclxuICB9XHJcbn07XHJcblxyXG4vLyBEZWZhdWx0IGV4cG9ydCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gSURNTFByb2Nlc3NvcjsgIl0sIm5hbWVzIjpbIklETUxQcm9jZXNzb3IiLCJyZXF1aXJlIiwiSURNTFhNTFBhcnNlciIsIkZpbGVFeHRyYWN0b3IiLCJTdHlsZVBhcnNlciIsIlN0b3J5UGFyc2VyIiwiRWxlbWVudFBhcnNlciIsIkRvY3VtZW50UGFyc2VyIiwiSW1hZ2VQcm9jZXNzb3IiLCJEZWJ1Z0FuYWx5emVyIiwiSURNTFV0aWxzIiwiQ29sb3JVdGlscyIsIkluRGVzaWduVGV4dE1ldHJpY3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2VycyIsIlhNTFBhcnNlciIsImV4dHJhY3RvcnMiLCJwcm9jZXNzb3JzIiwiZGVidWciLCJ1dGlscyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/index.js\n");

/***/ }),

/***/ "./lib/parsers/DocumentParser.js":
/*!***************************************!*\
  !*** ./lib/parsers/DocumentParser.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass DocumentParser {\n    constructor(elementParser, styleParser = null, unitConverter = null){\n        this.elementParser = elementParser;\n        this.styleParser = styleParser; // ADDED: Reference to StyleParser for accessing ViewPreferences\n        this.unitConverter = unitConverter; // ADDED: Reference to UnitConverter for unit conversions\n        this.documentInfo = {};\n        this.spreads = {};\n        this.masterSpreads = {};\n        this.layers = [];\n    }\n    async parseDocumentStructure(extractedData, xmlParser) {\n        console.log(\"Parsing document structure...\");\n        console.log(\"\\uD83D\\uDD0D Total files to process:\", Object.keys(extractedData).length);\n        // Parse designmap.xml first (main document structure)\n        if (extractedData[\"designmap.xml\"]) {\n            console.log(\"Parsing designmap.xml...\");\n            try {\n                const designMapData = xmlParser.parse(extractedData[\"designmap.xml\"]);\n                this.document = designMapData.Document || designMapData;\n                await this.extractDocumentInfo(this.document);\n                console.log(\"âœ… DesignMap parsed successfully\");\n            } catch (error) {\n                console.error(\"Error parsing designmap.xml:\", error);\n            }\n        }\n        // Parse Spreads\n        console.log(\"\\n\\uD83D\\uDCC4 === PARSING SPREADS ===\");\n        for (const [fileName, content] of Object.entries(extractedData)){\n            if (fileName.startsWith(\"Spreads/\")) {\n                console.log(\"\\uD83D\\uDD0D Processing spread:\", fileName);\n                await this.parseSpreadFile(fileName, content, xmlParser);\n            }\n        }\n        // Parse Master Spreads\n        console.log(\"\\n\\uD83C\\uDFA8 === PARSING MASTER SPREADS ===\");\n        for (const [fileName, content] of Object.entries(extractedData)){\n            if (fileName.startsWith(\"MasterSpreads/\")) {\n                console.log(\"\\uD83D\\uDD0D Processing master spread:\", fileName);\n                await this.parseMasterSpreadFile(fileName, content, xmlParser);\n            }\n        }\n    }\n    async extractDocumentInfo(document) {\n        console.log(\"Extracting document information...\");\n        if (!document) return;\n        // Extract document preferences and page setup\n        this.documentInfo = {\n            version: document[\"@_DOMVersion\"] || \"Unknown\",\n            self: document[\"@_Self\"] || \"Unknown\",\n            activeLayer: document[\"@_ActiveLayer\"] || null,\n            unusedSwatches: document[\"@_UnusedSwatches\"] || [],\n            // Document preferences\n            documentPreferences: this.extractDocumentPreferences(document),\n            // Page setup\n            pageSetup: this.extractPageSetup(document),\n            // Layers\n            layers: this.extractLayers(document),\n            // Pages\n            pages: this.extractPages(document)\n        };\n        console.log(\"âœ… Document info extracted\");\n    }\n    extractDocumentPreferences(document) {\n        console.log(\"\\uD83D\\uDCCB Extracting document preferences...\");\n        console.log(\"Document keys:\", Object.keys(document));\n        const prefs = {};\n        // Try multiple possible locations for document preferences\n        let docPref = null;\n        if (document.DocumentPreference) {\n            docPref = document.DocumentPreference;\n            console.log(\"Found DocumentPreference\");\n        } else if (document.documentPreference) {\n            docPref = document.documentPreference;\n            console.log(\"Found documentPreference (lowercase)\");\n        } else if (document.Properties && document.Properties.DocumentPreference) {\n            docPref = document.Properties.DocumentPreference;\n            console.log(\"Found DocumentPreference in Properties\");\n        }\n        if (docPref) {\n            console.log(\"DocumentPreference keys:\", Object.keys(docPref));\n            prefs.pageWidth = parseFloat(docPref[\"@_PageWidth\"]) || 0;\n            prefs.pageHeight = parseFloat(docPref[\"@_PageHeight\"]) || 0;\n            prefs.left = parseFloat(docPref[\"@_Left\"]) || 0;\n            prefs.top = parseFloat(docPref[\"@_Top\"]) || 0;\n            prefs.right = parseFloat(docPref[\"@_Right\"]) || 0;\n            prefs.bottom = parseFloat(docPref[\"@_Bottom\"]) || 0;\n            prefs.columnCount = parseInt(docPref[\"@_ColumnCount\"]) || 1;\n            prefs.columnGutter = parseFloat(docPref[\"@_ColumnGutter\"]) || 0;\n            prefs.facingPages = docPref[\"@_FacingPages\"] === \"true\" || docPref[\"@_FacingPages\"] === true;\n            console.log(\"\\uD83D\\uDCCB Extracted document preferences:\", prefs);\n        } else {\n            console.log(\"âš ï¸ No DocumentPreference found in document\");\n        }\n        // Also try to extract margin preferences\n        let marginPref = null;\n        if (document.MarginPreference) {\n            marginPref = document.MarginPreference;\n            console.log(\"Found MarginPreference\");\n        } else if (document.marginPreference) {\n            marginPref = document.marginPreference;\n            console.log(\"Found marginPreference (lowercase)\");\n        } else if (document.Properties && document.Properties.MarginPreference) {\n            marginPref = document.Properties.MarginPreference;\n            console.log(\"Found MarginPreference in Properties\");\n        }\n        if (marginPref) {\n            console.log(\"MarginPreference keys:\", Object.keys(marginPref));\n            prefs.marginTop = parseFloat(marginPref[\"@_Top\"]) || 0;\n            prefs.marginBottom = parseFloat(marginPref[\"@_Bottom\"]) || 0;\n            prefs.marginLeft = parseFloat(marginPref[\"@_Left\"]) || 0;\n            prefs.marginRight = parseFloat(marginPref[\"@_Right\"]) || 0;\n            prefs.marginColumnCount = parseInt(marginPref[\"@_ColumnCount\"]) || 1;\n            prefs.marginColumnGutter = parseFloat(marginPref[\"@_ColumnGutter\"]) || 0;\n            console.log(\"\\uD83D\\uDCCF Extracted margin preferences:\", {\n                top: prefs.marginTop,\n                bottom: prefs.marginBottom,\n                left: prefs.marginLeft,\n                right: prefs.marginRight,\n                columnCount: prefs.marginColumnCount,\n                columnGutter: prefs.marginColumnGutter\n            });\n        }\n        return prefs;\n    }\n    extractPageSetup(document) {\n        const pageSetup = {\n            pages: [],\n            masterPages: [],\n            spreads: []\n        };\n        // Extract page information from document\n        if (document.Page) {\n            const pages = Array.isArray(document.Page) ? document.Page : [\n                document.Page\n            ];\n            pages.forEach((page)=>{\n                pageSetup.pages.push({\n                    self: page[\"@_Self\"],\n                    name: page[\"@_Name\"] || \"\",\n                    appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                    geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                    itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"]),\n                    overrideList: page[\"@_OverrideList\"] || []\n                });\n            });\n        }\n        return pageSetup;\n    }\n    extractLayers(document) {\n        const layers = [];\n        if (document.Layer) {\n            const layerData = Array.isArray(document.Layer) ? document.Layer : [\n                document.Layer\n            ];\n            layerData.forEach((layer)=>{\n                layers.push({\n                    self: layer[\"@_Self\"],\n                    name: layer[\"@_Name\"] || \"\",\n                    visible: layer[\"@_Visible\"] !== false,\n                    locked: layer[\"@_Locked\"] === true,\n                    ignoreWrap: layer[\"@_IgnoreWrap\"] === true,\n                    showGuides: layer[\"@_ShowGuides\"] !== false,\n                    lockGuides: layer[\"@_LockGuides\"] === true,\n                    ui: layer[\"@_UI\"] || \"\",\n                    layerColor: layer[\"@_LayerColor\"] || \"LightBlue\"\n                });\n            });\n        }\n        this.layers = layers;\n        return layers;\n    }\n    extractPages(document) {\n        const pages = [];\n        if (document.Spread) {\n            const spreads = Array.isArray(document.Spread) ? document.Spread : [\n                document.Spread\n            ];\n            spreads.forEach((spread)=>{\n                if (spread.Page) {\n                    const spreadPages = Array.isArray(spread.Page) ? spread.Page : [\n                        spread.Page\n                    ];\n                    spreadPages.forEach((page)=>{\n                        pages.push({\n                            self: page[\"@_Self\"],\n                            name: page[\"@_Name\"] || \"\",\n                            appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                            geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                            itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"]),\n                            spreadParent: spread[\"@_Self\"]\n                        });\n                    });\n                }\n            });\n        }\n        return pages;\n    }\n    async parseSpreadFile(fileName, content, xmlParser) {\n        console.log(`ðŸ“„ Parsing spread: ${fileName}`);\n        try {\n            const parsed = xmlParser.parse(content);\n            const spreadId = path.basename(fileName, \".xml\");\n            const spreadData = parsed.Spread?.Spread || parsed.Spread || parsed;\n            if (parsed.Spread) {\n                console.log(\"Spread wrapper keys:\", Object.keys(parsed.Spread));\n                if (parsed.Spread.Spread) {\n                    console.log(\"Actual spread keys:\", Object.keys(parsed.Spread.Spread));\n                }\n            }\n            if (spreadData.Page) {\n                const pages = Array.isArray(spreadData.Page) ? spreadData.Page : [\n                    spreadData.Page\n                ];\n                console.log(`Found ${pages.length} pages in spread`);\n                pages.forEach((page, index)=>{\n                    console.log(`Page ${index} keys:`, Object.keys(page));\n                    // Look for elements in the page\n                    Object.keys(page).forEach((key)=>{\n                        if (key !== \"@_Self\" && key !== \"@_Name\" && key !== \"@_GeometricBounds\" && key !== \"@_ItemTransform\" && key !== \"@_AppliedMaster\") {\n                            const value = page[key];\n                            if (Array.isArray(value)) {\n                                console.log(`  Found array ${key} with ${value.length} items`);\n                            } else if (typeof value === \"object\") {\n                                console.log(`  Found object ${key}:`, Object.keys(value));\n                            }\n                        }\n                    });\n                });\n            } else {\n                console.log(\"No Page property found in spread\");\n            }\n            // Check for direct elements in spread\n            Object.keys(spreadData).forEach((key)=>{\n                if (key.includes(\"Frame\") || key.includes(\"Rectangle\") || key.includes(\"Text\") || key.includes(\"Group\") || key.includes(\"Oval\")) {\n                    console.log(`Found potential elements directly in spread: ${key}`, Array.isArray(spreadData[key]) ? spreadData[key].length : \"single\");\n                }\n            });\n            // Extract detailed spread information\n            const detailedSpread = {\n                self: spreadData[\"@_Self\"],\n                flattenerOverride: spreadData[\"@_FlattenerOverride\"] || \"\",\n                bindingLocation: parseFloat(spreadData[\"@_BindingLocation\"]) || 0,\n                allowPageShuffle: spreadData[\"@_AllowPageShuffle\"] !== false,\n                // Extract page elements\n                pages: this.elementParser.extractSpreadPages(spreadData),\n                // Extract all page items (text frames, rectangles, etc.)\n                pageItems: this.elementParser.extractPageItems(spreadData)\n            };\n            this.spreads[spreadId] = detailedSpread;\n            console.log(`âœ… Spread ${spreadId} parsed with ${detailedSpread.pageItems.length} items`);\n        } catch (error) {\n            console.error(`âŒ Error parsing spread ${fileName}:`, error.message);\n        }\n    }\n    async parseMasterSpreadFile(fileName, content, xmlParser) {\n        console.log(`ðŸŽ¨ Parsing master spread: ${fileName}`);\n        try {\n            const parsed = xmlParser.parse(content);\n            const masterId = path.basename(fileName, \".xml\");\n            const masterData = parsed.MasterSpread?.MasterSpread || parsed.MasterSpread || parsed;\n            console.log(\"Parsed master spread keys:\", Object.keys(parsed));\n            if (parsed.MasterSpread) {\n                console.log(\"MasterSpread wrapper keys:\", Object.keys(parsed.MasterSpread));\n                if (parsed.MasterSpread.MasterSpread) {\n                    console.log(\"Actual master spread keys:\", Object.keys(parsed.MasterSpread.MasterSpread));\n                }\n            }\n            // Extract detailed master spread information\n            const detailedMaster = {\n                self: masterData[\"@_Self\"],\n                name: masterData[\"@_Name\"] || \"\",\n                namePrefix: masterData[\"@_NamePrefix\"] || \"\",\n                basedOn: masterData[\"@_BasedOn\"] || \"\",\n                itemTransform: IDMLUtils.parseTransform(masterData[\"@_ItemTransform\"]),\n                // Extract master pages\n                pages: this.elementParser.extractMasterPages(masterData),\n                // Extract master page items\n                pageItems: this.elementParser.extractPageItems(masterData)\n            };\n            this.masterSpreads[masterId] = detailedMaster;\n            console.log(`âœ… Master spread ${masterId} parsed with ${detailedMaster.pageItems.length} items`);\n        } catch (error) {\n            console.error(`âŒ Error parsing master spread ${fileName}:`, error.message);\n        }\n    }\n    async extractDetailedInformation() {\n        console.log(\"Extracting detailed information with enhanced processing...\");\n        this.pageInfo = {\n            dimensions: this.calculatePageDimensions(),\n            margins: this.calculateMargins(),\n            bleeds: this.calculateBleeds(),\n            guides: this.extractGuides(),\n            grids: this.extractGrids()\n        };\n        this.elementParser.createElementPositionMapFixed(); // Use the fixed version\n        console.log(\"âœ… Enhanced detailed information extracted\");\n    }\n    calculatePageDimensions() {\n        // Try to get dimensions from spreads first (most reliable)\n        if (this.spreads && Object.keys(this.spreads).length > 0) {\n            const firstSpread = Object.values(this.spreads)[0];\n            if (firstSpread.pages && firstSpread.pages.length > 0) {\n                const firstPage = firstSpread.pages[0];\n                if (firstPage.geometricBounds) {\n                    const bounds = firstPage.geometricBounds;\n                    // FIXED: Get units from ViewPreferences instead of hardcoding 'Points'\n                    let units = \"Points\"; // fallback\n                    // Try to get units from StyleParser's documentInfo first\n                    if (this.styleParser && this.styleParser.getDocumentInfo) {\n                        const styleParserInfo = this.styleParser.getDocumentInfo();\n                        if (styleParserInfo?.preferences?.viewPreferences?.horizontalMeasurementUnits) {\n                            units = styleParserInfo.preferences.viewPreferences.horizontalMeasurementUnits;\n                            console.log(\"\\uD83D\\uDCCF Using measurement units from StyleParser:\", units);\n                        }\n                    }\n                    // Fallback to local documentInfo\n                    if (units === \"Points\" && this.documentInfo?.preferences?.viewPreferences?.horizontalMeasurementUnits) {\n                        units = this.documentInfo.preferences.viewPreferences.horizontalMeasurementUnits;\n                        console.log(\"\\uD83D\\uDCCF Using measurement units from local DocumentInfo:\", units);\n                    }\n                    const width = bounds.width || bounds.right - bounds.left || 0;\n                    const height = bounds.height || bounds.bottom - bounds.top || 0;\n                    const facingPages = Object.values(this.spreads).some((spread)=>spread.pages && spread.pages.length > 1);\n                    const dimensions = {\n                        width: width,\n                        height: height,\n                        facingPages: facingPages,\n                        units: units\n                    };\n                    // ADDED: Set document units on all parsers for consistent conversions\n                    if (this.elementParser && this.elementParser.setDocumentUnits) {\n                        this.elementParser.setDocumentUnits(units);\n                    }\n                    if (this.storyParser && this.storyParser.setDocumentUnits) {\n                        this.storyParser.setDocumentUnits(units);\n                    }\n                    if (this.styleParser && this.styleParser.setDocumentUnits) {\n                        this.styleParser.setDocumentUnits(units);\n                    }\n                    // ADDED: Convert to pixels if UnitConverter is available and conversion is enabled\n                    if (this.unitConverter && this.unitConverter.isSupportedUnit(units)) {\n                        return this.unitConverter.convertDimensions(dimensions);\n                    }\n                    return dimensions;\n                }\n            }\n        }\n        // Fallback to document preferences\n        const docPrefs = this.documentInfo.preferences?.documentPreferences || {};\n        // FIXED: Better units detection for fallback case\n        let units = \"Points\"; // default fallback\n        // Try StyleParser first\n        if (this.styleParser && this.styleParser.getDocumentInfo) {\n            const styleParserInfo = this.styleParser.getDocumentInfo();\n            if (styleParserInfo?.preferences?.viewPreferences?.horizontalMeasurementUnits) {\n                units = styleParserInfo.preferences.viewPreferences.horizontalMeasurementUnits;\n            }\n        }\n        // Then try local documentInfo\n        if (units === \"Points\" && this.documentInfo?.preferences?.viewPreferences?.horizontalMeasurementUnits) {\n            units = this.documentInfo.preferences.viewPreferences.horizontalMeasurementUnits;\n        }\n        console.log(\"\\uD83D\\uDCCF Final measurement units decision:\", units);\n        const dimensions = {\n            width: docPrefs.pageWidth || 0,\n            height: docPrefs.pageHeight || 0,\n            facingPages: docPrefs.facingPages || false,\n            units: units\n        };\n        // ADDED: Set document units on ElementParser, StoryParser, and StyleParser for consistent conversions\n        if (this.elementParser && this.elementParser.setDocumentUnits) {\n            this.elementParser.setDocumentUnits(units);\n        }\n        if (this.storyParser && this.storyParser.setDocumentUnits) {\n            this.storyParser.setDocumentUnits(units);\n        }\n        if (this.styleParser && this.styleParser.setDocumentUnits) {\n            this.styleParser.setDocumentUnits(units);\n        }\n        // ADDED: Convert to pixels if UnitConverter is available and conversion is enabled\n        if (this.unitConverter && this.unitConverter.isSupportedUnit(units)) {\n            return this.unitConverter.convertDimensions(dimensions);\n        }\n        return dimensions;\n    }\n    calculateMargins() {\n        console.log(\"\\uD83D\\uDCCF Calculating margins from multiple sources...\");\n        // Try to get margins from master pages first (most reliable)\n        if (this.masterSpreads && Object.keys(this.masterSpreads).length > 0) {\n            const firstMaster = Object.values(this.masterSpreads)[0];\n            if (firstMaster.pages && firstMaster.pages.length > 0) {\n                const firstMasterPage = firstMaster.pages[0];\n                // Look for margin preferences in master page\n                // This will be populated by the improved master spread parsing\n                if (firstMasterPage.marginPreference) {\n                    const masterMargins = {\n                        top: firstMasterPage.marginPreference.top || 0,\n                        bottom: firstMasterPage.marginPreference.bottom || 0,\n                        left: firstMasterPage.marginPreference.left || 0,\n                        right: firstMasterPage.marginPreference.right || 0,\n                        columnCount: firstMasterPage.marginPreference.columnCount || 1,\n                        columnGutter: firstMasterPage.marginPreference.columnGutter || 0\n                    };\n                    console.log(\"\\uD83D\\uDCCF Found margins from master page:\", masterMargins);\n                    // ADDED: Convert margins to pixels if UnitConverter is available\n                    if (this.unitConverter && this.elementParser?.documentUnits) {\n                        const pixelMargins = this.unitConverter.convertObjectToPixels(masterMargins, this.elementParser.documentUnits);\n                        return {\n                            ...masterMargins,\n                            pixelMargins: pixelMargins\n                        };\n                    }\n                    return masterMargins;\n                }\n            }\n        }\n        // Fallback to document preferences\n        const docPrefs = this.documentInfo.documentPreferences || {};\n        const marginPrefs = this.documentInfo.preferences?.marginPreferences || {};\n        // Check for margin data in document preferences (fallback)\n        const margins = {\n            top: marginPrefs.top || docPrefs.marginTop || docPrefs.top || 0,\n            bottom: marginPrefs.bottom || docPrefs.marginBottom || docPrefs.bottom || 0,\n            left: marginPrefs.left || docPrefs.marginLeft || docPrefs.left || 0,\n            right: marginPrefs.right || docPrefs.marginRight || docPrefs.right || 0,\n            columnCount: marginPrefs.columnCount || docPrefs.marginColumnCount || docPrefs.columnCount || 1,\n            columnGutter: marginPrefs.columnGutter || docPrefs.marginColumnGutter || docPrefs.columnGutter || 0\n        };\n        console.log(\"\\uD83D\\uDCCF Calculated margins (fallback):\", margins);\n        // ADDED: Convert margins to pixels if UnitConverter is available\n        if (this.unitConverter && this.elementParser?.documentUnits) {\n            const pixelMargins = this.unitConverter.convertObjectToPixels(margins, this.elementParser.documentUnits);\n            return {\n                ...margins,\n                pixelMargins: pixelMargins\n            };\n        }\n        return margins;\n    }\n    calculateBleeds() {\n        const docPrefs = this.documentInfo.preferences?.documentPreferences || {};\n        return {\n            top: docPrefs.documentBleedTopOffset || 0,\n            bottom: docPrefs.documentBleedBottomOffset || 0,\n            inside: docPrefs.documentBleedInsideOrLeftOffset || 0,\n            outside: docPrefs.documentBleedOutsideOrRightOffset || 0\n        };\n    }\n    extractGuides() {\n        const guides = [];\n        // Extract guides from spreads\n        Object.values(this.spreads).forEach((spread)=>{\n            if (spread.pageItems) {\n                spread.pageItems.forEach((item)=>{\n                    if (item.type === \"Guide\") {\n                        guides.push({\n                            orientation: item.orientation || \"Horizontal\",\n                            location: item.location || 0,\n                            fitToPage: item.fitToPage || false,\n                            viewThreshold: item.viewThreshold || 0\n                        });\n                    }\n                });\n            }\n        });\n        return guides;\n    }\n    extractGrids() {\n        const gridPrefs = this.documentInfo.preferences?.gridPreferences || {};\n        return {\n            baseline: {\n                start: gridPrefs.baselineStart || 0,\n                division: gridPrefs.baselineDivision || 12,\n                shown: gridPrefs.baselineShown || false,\n                snapTo: gridPrefs.baselineSnapto || false\n            },\n            document: {\n                shown: gridPrefs.documentGridShown || false,\n                snapTo: gridPrefs.documentGridSnapto || false\n            }\n        };\n    }\n    // Utility method to get page content\n    getPageContent(pageId) {\n        return this.elementParser.getPageContent(pageId);\n    }\n    getDocument() {\n        return this.document;\n    }\n    getSpreads() {\n        return this.spreads;\n    }\n    getMasterSpreads() {\n        return this.masterSpreads;\n    }\n    getDocumentInfo() {\n        return this.documentInfo;\n    }\n    getPageInfo() {\n        return this.pageInfo;\n    }\n    getLayers() {\n        return this.layers;\n    }\n    calculateCoordinateOffset() {\n        return IDMLUtils.calculateCoordinateOffset(this.elementParser.getElements());\n    }\n}\nmodule.exports = DocumentParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxDQUFDbEwsTUFBTTtJQUNwQjtJQUVBbUwsNEJBQTRCO1FBQzFCLE9BQU81TCxVQUFVNEwseUJBQXlCLENBQ3hDLElBQUksQ0FBQ3pMLGFBQWEsQ0FBQzBMLFdBQVc7SUFFbEM7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc5TCIsInNvdXJjZXMiOlsid2VicGFjazovL2lkbWwtdmlld2VyLy4vbGliL3BhcnNlcnMvRG9jdW1lbnRQYXJzZXIuanM/OTQxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9JRE1MVXRpbHNcIik7XHJcblxyXG5jbGFzcyBEb2N1bWVudFBhcnNlciB7XHJcbiAgY29uc3RydWN0b3IoZWxlbWVudFBhcnNlciwgc3R5bGVQYXJzZXIgPSBudWxsLCB1bml0Q29udmVydGVyID0gbnVsbCkge1xyXG4gICAgdGhpcy5lbGVtZW50UGFyc2VyID0gZWxlbWVudFBhcnNlcjtcclxuICAgIHRoaXMuc3R5bGVQYXJzZXIgPSBzdHlsZVBhcnNlcjsgLy8gQURERUQ6IFJlZmVyZW5jZSB0byBTdHlsZVBhcnNlciBmb3IgYWNjZXNzaW5nIFZpZXdQcmVmZXJlbmNlc1xyXG4gICAgdGhpcy51bml0Q29udmVydGVyID0gdW5pdENvbnZlcnRlcjsgLy8gQURERUQ6IFJlZmVyZW5jZSB0byBVbml0Q29udmVydGVyIGZvciB1bml0IGNvbnZlcnNpb25zXHJcbiAgICB0aGlzLmRvY3VtZW50SW5mbyA9IHt9O1xyXG4gICAgdGhpcy5zcHJlYWRzID0ge307XHJcbiAgICB0aGlzLm1hc3RlclNwcmVhZHMgPSB7fTtcclxuICAgIHRoaXMubGF5ZXJzID0gW107XHJcbiAgfVxyXG5cclxuICBhc3luYyBwYXJzZURvY3VtZW50U3RydWN0dXJlKGV4dHJhY3RlZERhdGEsIHhtbFBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coXCJQYXJzaW5nIGRvY3VtZW50IHN0cnVjdHVyZS4uLlwiKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIvCflI0gVG90YWwgZmlsZXMgdG8gcHJvY2VzczpcIixcclxuICAgICAgT2JqZWN0LmtleXMoZXh0cmFjdGVkRGF0YSkubGVuZ3RoXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFBhcnNlIGRlc2lnbm1hcC54bWwgZmlyc3QgKG1haW4gZG9jdW1lbnQgc3RydWN0dXJlKVxyXG4gICAgaWYgKGV4dHJhY3RlZERhdGFbXCJkZXNpZ25tYXAueG1sXCJdKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiUGFyc2luZyBkZXNpZ25tYXAueG1sLi4uXCIpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRlc2lnbk1hcERhdGEgPSB4bWxQYXJzZXIucGFyc2UoZXh0cmFjdGVkRGF0YVtcImRlc2lnbm1hcC54bWxcIl0pO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkZXNpZ25NYXBEYXRhLkRvY3VtZW50IHx8IGRlc2lnbk1hcERhdGE7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0RG9jdW1lbnRJbmZvKHRoaXMuZG9jdW1lbnQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIERlc2lnbk1hcCBwYXJzZWQgc3VjY2Vzc2Z1bGx5XCIpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIGRlc2lnbm1hcC54bWw6XCIsIGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhcnNlIFNwcmVhZHNcclxuICAgIGNvbnNvbGUubG9nKFwiXFxu8J+ThCA9PT0gUEFSU0lORyBTUFJFQURTID09PVwiKTtcclxuICAgIGZvciAoY29uc3QgW2ZpbGVOYW1lLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhleHRyYWN0ZWREYXRhKSkge1xyXG4gICAgICBpZiAoZmlsZU5hbWUuc3RhcnRzV2l0aChcIlNwcmVhZHMvXCIpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIFByb2Nlc3Npbmcgc3ByZWFkOlwiLCBmaWxlTmFtZSk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXJzZVNwcmVhZEZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSBNYXN0ZXIgU3ByZWFkc1xyXG4gICAgY29uc29sZS5sb2coXCJcXG7wn46oID09PSBQQVJTSU5HIE1BU1RFUiBTUFJFQURTID09PVwiKTtcclxuICAgIGZvciAoY29uc3QgW2ZpbGVOYW1lLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhleHRyYWN0ZWREYXRhKSkge1xyXG4gICAgICBpZiAoZmlsZU5hbWUuc3RhcnRzV2l0aChcIk1hc3RlclNwcmVhZHMvXCIpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIFByb2Nlc3NpbmcgbWFzdGVyIHNwcmVhZDpcIiwgZmlsZU5hbWUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucGFyc2VNYXN0ZXJTcHJlYWRGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHRyYWN0RG9jdW1lbnRJbmZvKGRvY3VtZW50KSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3RpbmcgZG9jdW1lbnQgaW5mb3JtYXRpb24uLi5cIik7XHJcblxyXG4gICAgaWYgKCFkb2N1bWVudCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgZG9jdW1lbnQgcHJlZmVyZW5jZXMgYW5kIHBhZ2Ugc2V0dXBcclxuICAgIHRoaXMuZG9jdW1lbnRJbmZvID0ge1xyXG4gICAgICB2ZXJzaW9uOiBkb2N1bWVudFtcIkBfRE9NVmVyc2lvblwiXSB8fCBcIlVua25vd25cIixcclxuICAgICAgc2VsZjogZG9jdW1lbnRbXCJAX1NlbGZcIl0gfHwgXCJVbmtub3duXCIsXHJcbiAgICAgIGFjdGl2ZUxheWVyOiBkb2N1bWVudFtcIkBfQWN0aXZlTGF5ZXJcIl0gfHwgbnVsbCxcclxuICAgICAgdW51c2VkU3dhdGNoZXM6IGRvY3VtZW50W1wiQF9VbnVzZWRTd2F0Y2hlc1wiXSB8fCBbXSxcclxuXHJcbiAgICAgIC8vIERvY3VtZW50IHByZWZlcmVuY2VzXHJcbiAgICAgIGRvY3VtZW50UHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdERvY3VtZW50UHJlZmVyZW5jZXMoZG9jdW1lbnQpLFxyXG5cclxuICAgICAgLy8gUGFnZSBzZXR1cFxyXG4gICAgICBwYWdlU2V0dXA6IHRoaXMuZXh0cmFjdFBhZ2VTZXR1cChkb2N1bWVudCksXHJcblxyXG4gICAgICAvLyBMYXllcnNcclxuICAgICAgbGF5ZXJzOiB0aGlzLmV4dHJhY3RMYXllcnMoZG9jdW1lbnQpLFxyXG5cclxuICAgICAgLy8gUGFnZXNcclxuICAgICAgcGFnZXM6IHRoaXMuZXh0cmFjdFBhZ2VzKGRvY3VtZW50KSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc29sZS5sb2coXCLinIUgRG9jdW1lbnQgaW5mbyBleHRyYWN0ZWRcIik7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0RG9jdW1lbnRQcmVmZXJlbmNlcyhkb2N1bWVudCkge1xyXG4gICAgY29uc29sZS5sb2coXCLwn5OLIEV4dHJhY3RpbmcgZG9jdW1lbnQgcHJlZmVyZW5jZXMuLi5cIik7XHJcbiAgICBjb25zb2xlLmxvZyhcIkRvY3VtZW50IGtleXM6XCIsIE9iamVjdC5rZXlzKGRvY3VtZW50KSk7XHJcblxyXG4gICAgY29uc3QgcHJlZnMgPSB7fTtcclxuXHJcbiAgICAvLyBUcnkgbXVsdGlwbGUgcG9zc2libGUgbG9jYXRpb25zIGZvciBkb2N1bWVudCBwcmVmZXJlbmNlc1xyXG4gICAgbGV0IGRvY1ByZWYgPSBudWxsO1xyXG5cclxuICAgIGlmIChkb2N1bWVudC5Eb2N1bWVudFByZWZlcmVuY2UpIHtcclxuICAgICAgZG9jUHJlZiA9IGRvY3VtZW50LkRvY3VtZW50UHJlZmVyZW5jZTtcclxuICAgICAgY29uc29sZS5sb2coXCJGb3VuZCBEb2N1bWVudFByZWZlcmVuY2VcIik7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmRvY3VtZW50UHJlZmVyZW5jZSkge1xyXG4gICAgICBkb2NQcmVmID0gZG9jdW1lbnQuZG9jdW1lbnRQcmVmZXJlbmNlO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIGRvY3VtZW50UHJlZmVyZW5jZSAobG93ZXJjYXNlKVwiKTtcclxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuUHJvcGVydGllcyAmJiBkb2N1bWVudC5Qcm9wZXJ0aWVzLkRvY3VtZW50UHJlZmVyZW5jZSkge1xyXG4gICAgICBkb2NQcmVmID0gZG9jdW1lbnQuUHJvcGVydGllcy5Eb2N1bWVudFByZWZlcmVuY2U7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgRG9jdW1lbnRQcmVmZXJlbmNlIGluIFByb3BlcnRpZXNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRvY1ByZWYpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJEb2N1bWVudFByZWZlcmVuY2Uga2V5czpcIiwgT2JqZWN0LmtleXMoZG9jUHJlZikpO1xyXG4gICAgICBwcmVmcy5wYWdlV2lkdGggPSBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX1BhZ2VXaWR0aFwiXSkgfHwgMDtcclxuICAgICAgcHJlZnMucGFnZUhlaWdodCA9IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfUGFnZUhlaWdodFwiXSkgfHwgMDtcclxuICAgICAgcHJlZnMubGVmdCA9IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfTGVmdFwiXSkgfHwgMDtcclxuICAgICAgcHJlZnMudG9wID0gcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Ub3BcIl0pIHx8IDA7XHJcbiAgICAgIHByZWZzLnJpZ2h0ID0gcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9SaWdodFwiXSkgfHwgMDtcclxuICAgICAgcHJlZnMuYm90dG9tID0gcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Cb3R0b21cIl0pIHx8IDA7XHJcbiAgICAgIHByZWZzLmNvbHVtbkNvdW50ID0gcGFyc2VJbnQoZG9jUHJlZltcIkBfQ29sdW1uQ291bnRcIl0pIHx8IDE7XHJcbiAgICAgIHByZWZzLmNvbHVtbkd1dHRlciA9IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfQ29sdW1uR3V0dGVyXCJdKSB8fCAwO1xyXG4gICAgICBwcmVmcy5mYWNpbmdQYWdlcyA9XHJcbiAgICAgICAgZG9jUHJlZltcIkBfRmFjaW5nUGFnZXNcIl0gPT09IFwidHJ1ZVwiIHx8XHJcbiAgICAgICAgZG9jUHJlZltcIkBfRmFjaW5nUGFnZXNcIl0gPT09IHRydWU7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIvCfk4sgRXh0cmFjdGVkIGRvY3VtZW50IHByZWZlcmVuY2VzOlwiLCBwcmVmcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuKaoO+4jyBObyBEb2N1bWVudFByZWZlcmVuY2UgZm91bmQgaW4gZG9jdW1lbnRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWxzbyB0cnkgdG8gZXh0cmFjdCBtYXJnaW4gcHJlZmVyZW5jZXNcclxuICAgIGxldCBtYXJnaW5QcmVmID0gbnVsbDtcclxuICAgIGlmIChkb2N1bWVudC5NYXJnaW5QcmVmZXJlbmNlKSB7XHJcbiAgICAgIG1hcmdpblByZWYgPSBkb2N1bWVudC5NYXJnaW5QcmVmZXJlbmNlO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIE1hcmdpblByZWZlcmVuY2VcIik7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1hcmdpblByZWZlcmVuY2UpIHtcclxuICAgICAgbWFyZ2luUHJlZiA9IGRvY3VtZW50Lm1hcmdpblByZWZlcmVuY2U7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgbWFyZ2luUHJlZmVyZW5jZSAobG93ZXJjYXNlKVwiKTtcclxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuUHJvcGVydGllcyAmJiBkb2N1bWVudC5Qcm9wZXJ0aWVzLk1hcmdpblByZWZlcmVuY2UpIHtcclxuICAgICAgbWFyZ2luUHJlZiA9IGRvY3VtZW50LlByb3BlcnRpZXMuTWFyZ2luUHJlZmVyZW5jZTtcclxuICAgICAgY29uc29sZS5sb2coXCJGb3VuZCBNYXJnaW5QcmVmZXJlbmNlIGluIFByb3BlcnRpZXNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1hcmdpblByZWYpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJNYXJnaW5QcmVmZXJlbmNlIGtleXM6XCIsIE9iamVjdC5rZXlzKG1hcmdpblByZWYpKTtcclxuICAgICAgcHJlZnMubWFyZ2luVG9wID0gcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9Ub3BcIl0pIHx8IDA7XHJcbiAgICAgIHByZWZzLm1hcmdpbkJvdHRvbSA9IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfQm90dG9tXCJdKSB8fCAwO1xyXG4gICAgICBwcmVmcy5tYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9MZWZ0XCJdKSB8fCAwO1xyXG4gICAgICBwcmVmcy5tYXJnaW5SaWdodCA9IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfUmlnaHRcIl0pIHx8IDA7XHJcbiAgICAgIHByZWZzLm1hcmdpbkNvbHVtbkNvdW50ID0gcGFyc2VJbnQobWFyZ2luUHJlZltcIkBfQ29sdW1uQ291bnRcIl0pIHx8IDE7XHJcbiAgICAgIHByZWZzLm1hcmdpbkNvbHVtbkd1dHRlciA9IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfQ29sdW1uR3V0dGVyXCJdKSB8fCAwO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXCLwn5OPIEV4dHJhY3RlZCBtYXJnaW4gcHJlZmVyZW5jZXM6XCIsIHtcclxuICAgICAgICB0b3A6IHByZWZzLm1hcmdpblRvcCxcclxuICAgICAgICBib3R0b206IHByZWZzLm1hcmdpbkJvdHRvbSxcclxuICAgICAgICBsZWZ0OiBwcmVmcy5tYXJnaW5MZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiBwcmVmcy5tYXJnaW5SaWdodCxcclxuICAgICAgICBjb2x1bW5Db3VudDogcHJlZnMubWFyZ2luQ29sdW1uQ291bnQsXHJcbiAgICAgICAgY29sdW1uR3V0dGVyOiBwcmVmcy5tYXJnaW5Db2x1bW5HdXR0ZXIsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcmVmcztcclxuICB9XHJcblxyXG4gIGV4dHJhY3RQYWdlU2V0dXAoZG9jdW1lbnQpIHtcclxuICAgIGNvbnN0IHBhZ2VTZXR1cCA9IHtcclxuICAgICAgcGFnZXM6IFtdLFxyXG4gICAgICBtYXN0ZXJQYWdlczogW10sXHJcbiAgICAgIHNwcmVhZHM6IFtdLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IHBhZ2UgaW5mb3JtYXRpb24gZnJvbSBkb2N1bWVudFxyXG4gICAgaWYgKGRvY3VtZW50LlBhZ2UpIHtcclxuICAgICAgY29uc3QgcGFnZXMgPSBBcnJheS5pc0FycmF5KGRvY3VtZW50LlBhZ2UpXHJcbiAgICAgICAgPyBkb2N1bWVudC5QYWdlXHJcbiAgICAgICAgOiBbZG9jdW1lbnQuUGFnZV07XHJcblxyXG4gICAgICBwYWdlcy5mb3JFYWNoKChwYWdlKSA9PiB7XHJcbiAgICAgICAgcGFnZVNldHVwLnBhZ2VzLnB1c2goe1xyXG4gICAgICAgICAgc2VsZjogcGFnZVtcIkBfU2VsZlwiXSxcclxuICAgICAgICAgIG5hbWU6IHBhZ2VbXCJAX05hbWVcIl0gfHwgXCJcIixcclxuICAgICAgICAgIGFwcGxpZWRNYXN0ZXI6IHBhZ2VbXCJAX0FwcGxpZWRNYXN0ZXJcIl0gfHwgXCJcIixcclxuICAgICAgICAgIGdlb21ldHJpY0JvdW5kczogSURNTFV0aWxzLnBhcnNlR2VvbWV0cmljQm91bmRzKFxyXG4gICAgICAgICAgICBwYWdlW1wiQF9HZW9tZXRyaWNCb3VuZHNcIl1cclxuICAgICAgICAgICksXHJcbiAgICAgICAgICBpdGVtVHJhbnNmb3JtOiBJRE1MVXRpbHMucGFyc2VUcmFuc2Zvcm0ocGFnZVtcIkBfSXRlbVRyYW5zZm9ybVwiXSksXHJcbiAgICAgICAgICBvdmVycmlkZUxpc3Q6IHBhZ2VbXCJAX092ZXJyaWRlTGlzdFwiXSB8fCBbXSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhZ2VTZXR1cDtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RMYXllcnMoZG9jdW1lbnQpIHtcclxuICAgIGNvbnN0IGxheWVycyA9IFtdO1xyXG5cclxuICAgIGlmIChkb2N1bWVudC5MYXllcikge1xyXG4gICAgICBjb25zdCBsYXllckRhdGEgPSBBcnJheS5pc0FycmF5KGRvY3VtZW50LkxheWVyKVxyXG4gICAgICAgID8gZG9jdW1lbnQuTGF5ZXJcclxuICAgICAgICA6IFtkb2N1bWVudC5MYXllcl07XHJcblxyXG4gICAgICBsYXllckRhdGEuZm9yRWFjaCgobGF5ZXIpID0+IHtcclxuICAgICAgICBsYXllcnMucHVzaCh7XHJcbiAgICAgICAgICBzZWxmOiBsYXllcltcIkBfU2VsZlwiXSxcclxuICAgICAgICAgIG5hbWU6IGxheWVyW1wiQF9OYW1lXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgICB2aXNpYmxlOiBsYXllcltcIkBfVmlzaWJsZVwiXSAhPT0gZmFsc2UsXHJcbiAgICAgICAgICBsb2NrZWQ6IGxheWVyW1wiQF9Mb2NrZWRcIl0gPT09IHRydWUsXHJcbiAgICAgICAgICBpZ25vcmVXcmFwOiBsYXllcltcIkBfSWdub3JlV3JhcFwiXSA9PT0gdHJ1ZSxcclxuICAgICAgICAgIHNob3dHdWlkZXM6IGxheWVyW1wiQF9TaG93R3VpZGVzXCJdICE9PSBmYWxzZSxcclxuICAgICAgICAgIGxvY2tHdWlkZXM6IGxheWVyW1wiQF9Mb2NrR3VpZGVzXCJdID09PSB0cnVlLFxyXG4gICAgICAgICAgdWk6IGxheWVyW1wiQF9VSVwiXSB8fCBcIlwiLFxyXG4gICAgICAgICAgbGF5ZXJDb2xvcjogbGF5ZXJbXCJAX0xheWVyQ29sb3JcIl0gfHwgXCJMaWdodEJsdWVcIixcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sYXllcnMgPSBsYXllcnM7XHJcbiAgICByZXR1cm4gbGF5ZXJzO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBhZ2VzKGRvY3VtZW50KSB7XHJcbiAgICBjb25zdCBwYWdlcyA9IFtdO1xyXG5cclxuICAgIGlmIChkb2N1bWVudC5TcHJlYWQpIHtcclxuICAgICAgY29uc3Qgc3ByZWFkcyA9IEFycmF5LmlzQXJyYXkoZG9jdW1lbnQuU3ByZWFkKVxyXG4gICAgICAgID8gZG9jdW1lbnQuU3ByZWFkXHJcbiAgICAgICAgOiBbZG9jdW1lbnQuU3ByZWFkXTtcclxuXHJcbiAgICAgIHNwcmVhZHMuZm9yRWFjaCgoc3ByZWFkKSA9PiB7XHJcbiAgICAgICAgaWYgKHNwcmVhZC5QYWdlKSB7XHJcbiAgICAgICAgICBjb25zdCBzcHJlYWRQYWdlcyA9IEFycmF5LmlzQXJyYXkoc3ByZWFkLlBhZ2UpXHJcbiAgICAgICAgICAgID8gc3ByZWFkLlBhZ2VcclxuICAgICAgICAgICAgOiBbc3ByZWFkLlBhZ2VdO1xyXG4gICAgICAgICAgc3ByZWFkUGFnZXMuZm9yRWFjaCgocGFnZSkgPT4ge1xyXG4gICAgICAgICAgICBwYWdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICBzZWxmOiBwYWdlW1wiQF9TZWxmXCJdLFxyXG4gICAgICAgICAgICAgIG5hbWU6IHBhZ2VbXCJAX05hbWVcIl0gfHwgXCJcIixcclxuICAgICAgICAgICAgICBhcHBsaWVkTWFzdGVyOiBwYWdlW1wiQF9BcHBsaWVkTWFzdGVyXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgICAgICAgZ2VvbWV0cmljQm91bmRzOiBJRE1MVXRpbHMucGFyc2VHZW9tZXRyaWNCb3VuZHMoXHJcbiAgICAgICAgICAgICAgICBwYWdlW1wiQF9HZW9tZXRyaWNCb3VuZHNcIl1cclxuICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgIGl0ZW1UcmFuc2Zvcm06IElETUxVdGlscy5wYXJzZVRyYW5zZm9ybShwYWdlW1wiQF9JdGVtVHJhbnNmb3JtXCJdKSxcclxuICAgICAgICAgICAgICBzcHJlYWRQYXJlbnQ6IHNwcmVhZFtcIkBfU2VsZlwiXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYWdlcztcclxuICB9XHJcblxyXG4gIGFzeW5jIHBhcnNlU3ByZWFkRmlsZShmaWxlTmFtZSwgY29udGVudCwgeG1sUGFyc2VyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+ThCBQYXJzaW5nIHNwcmVhZDogJHtmaWxlTmFtZX1gKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSB4bWxQYXJzZXIucGFyc2UoY29udGVudCk7XHJcbiAgICAgIGNvbnN0IHNwcmVhZElkID0gcGF0aC5iYXNlbmFtZShmaWxlTmFtZSwgXCIueG1sXCIpO1xyXG5cclxuICAgICAgY29uc3Qgc3ByZWFkRGF0YSA9IHBhcnNlZC5TcHJlYWQ/LlNwcmVhZCB8fCBwYXJzZWQuU3ByZWFkIHx8IHBhcnNlZDtcclxuXHJcbiAgICAgIGlmIChwYXJzZWQuU3ByZWFkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTcHJlYWQgd3JhcHBlciBrZXlzOlwiLCBPYmplY3Qua2V5cyhwYXJzZWQuU3ByZWFkKSk7XHJcbiAgICAgICAgaWYgKHBhcnNlZC5TcHJlYWQuU3ByZWFkKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFjdHVhbCBzcHJlYWQga2V5czpcIiwgT2JqZWN0LmtleXMocGFyc2VkLlNwcmVhZC5TcHJlYWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzcHJlYWREYXRhLlBhZ2UpIHtcclxuICAgICAgICBjb25zdCBwYWdlcyA9IEFycmF5LmlzQXJyYXkoc3ByZWFkRGF0YS5QYWdlKVxyXG4gICAgICAgICAgPyBzcHJlYWREYXRhLlBhZ2VcclxuICAgICAgICAgIDogW3NwcmVhZERhdGEuUGFnZV07XHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7cGFnZXMubGVuZ3RofSBwYWdlcyBpbiBzcHJlYWRgKTtcclxuICAgICAgICBwYWdlcy5mb3JFYWNoKChwYWdlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFBhZ2UgJHtpbmRleH0ga2V5czpgLCBPYmplY3Qua2V5cyhwYWdlKSk7XHJcblxyXG4gICAgICAgICAgLy8gTG9vayBmb3IgZWxlbWVudHMgaW4gdGhlIHBhZ2VcclxuICAgICAgICAgIE9iamVjdC5rZXlzKHBhZ2UpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAga2V5ICE9PSBcIkBfU2VsZlwiICYmXHJcbiAgICAgICAgICAgICAga2V5ICE9PSBcIkBfTmFtZVwiICYmXHJcbiAgICAgICAgICAgICAga2V5ICE9PSBcIkBfR2VvbWV0cmljQm91bmRzXCIgJiZcclxuICAgICAgICAgICAgICBrZXkgIT09IFwiQF9JdGVtVHJhbnNmb3JtXCIgJiZcclxuICAgICAgICAgICAgICBrZXkgIT09IFwiQF9BcHBsaWVkTWFzdGVyXCJcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWdlW2tleV07XHJcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBGb3VuZCBhcnJheSAke2tleX0gd2l0aCAke3ZhbHVlLmxlbmd0aH0gaXRlbXNgKTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgRm91bmQgb2JqZWN0ICR7a2V5fTpgLCBPYmplY3Qua2V5cyh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJObyBQYWdlIHByb3BlcnR5IGZvdW5kIGluIHNwcmVhZFwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIGRpcmVjdCBlbGVtZW50cyBpbiBzcHJlYWRcclxuICAgICAgT2JqZWN0LmtleXMoc3ByZWFkRGF0YSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAga2V5LmluY2x1ZGVzKFwiRnJhbWVcIikgfHxcclxuICAgICAgICAgIGtleS5pbmNsdWRlcyhcIlJlY3RhbmdsZVwiKSB8fFxyXG4gICAgICAgICAga2V5LmluY2x1ZGVzKFwiVGV4dFwiKSB8fFxyXG4gICAgICAgICAga2V5LmluY2x1ZGVzKFwiR3JvdXBcIikgfHxcclxuICAgICAgICAgIGtleS5pbmNsdWRlcyhcIk92YWxcIilcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgRm91bmQgcG90ZW50aWFsIGVsZW1lbnRzIGRpcmVjdGx5IGluIHNwcmVhZDogJHtrZXl9YCxcclxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShzcHJlYWREYXRhW2tleV0pID8gc3ByZWFkRGF0YVtrZXldLmxlbmd0aCA6IFwic2luZ2xlXCJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEV4dHJhY3QgZGV0YWlsZWQgc3ByZWFkIGluZm9ybWF0aW9uXHJcbiAgICAgIGNvbnN0IGRldGFpbGVkU3ByZWFkID0ge1xyXG4gICAgICAgIHNlbGY6IHNwcmVhZERhdGFbXCJAX1NlbGZcIl0sXHJcbiAgICAgICAgZmxhdHRlbmVyT3ZlcnJpZGU6IHNwcmVhZERhdGFbXCJAX0ZsYXR0ZW5lck92ZXJyaWRlXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgYmluZGluZ0xvY2F0aW9uOiBwYXJzZUZsb2F0KHNwcmVhZERhdGFbXCJAX0JpbmRpbmdMb2NhdGlvblwiXSkgfHwgMCxcclxuICAgICAgICBhbGxvd1BhZ2VTaHVmZmxlOiBzcHJlYWREYXRhW1wiQF9BbGxvd1BhZ2VTaHVmZmxlXCJdICE9PSBmYWxzZSxcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBwYWdlIGVsZW1lbnRzXHJcbiAgICAgICAgcGFnZXM6IHRoaXMuZWxlbWVudFBhcnNlci5leHRyYWN0U3ByZWFkUGFnZXMoc3ByZWFkRGF0YSksXHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgYWxsIHBhZ2UgaXRlbXMgKHRleHQgZnJhbWVzLCByZWN0YW5nbGVzLCBldGMuKVxyXG4gICAgICAgIHBhZ2VJdGVtczogdGhpcy5lbGVtZW50UGFyc2VyLmV4dHJhY3RQYWdlSXRlbXMoc3ByZWFkRGF0YSksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLnNwcmVhZHNbc3ByZWFkSWRdID0gZGV0YWlsZWRTcHJlYWQ7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDinIUgU3ByZWFkICR7c3ByZWFkSWR9IHBhcnNlZCB3aXRoICR7ZGV0YWlsZWRTcHJlYWQucGFnZUl0ZW1zLmxlbmd0aH0gaXRlbXNgXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcGFyc2luZyBzcHJlYWQgJHtmaWxlTmFtZX06YCwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBwYXJzZU1hc3RlclNwcmVhZEZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHhtbFBhcnNlcikge1xyXG4gICAgY29uc29sZS5sb2coYPCfjqggUGFyc2luZyBtYXN0ZXIgc3ByZWFkOiAke2ZpbGVOYW1lfWApO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcclxuICAgICAgY29uc3QgbWFzdGVySWQgPSBwYXRoLmJhc2VuYW1lKGZpbGVOYW1lLCBcIi54bWxcIik7XHJcblxyXG4gICAgICBjb25zdCBtYXN0ZXJEYXRhID1cclxuICAgICAgICBwYXJzZWQuTWFzdGVyU3ByZWFkPy5NYXN0ZXJTcHJlYWQgfHwgcGFyc2VkLk1hc3RlclNwcmVhZCB8fCBwYXJzZWQ7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIlBhcnNlZCBtYXN0ZXIgc3ByZWFkIGtleXM6XCIsIE9iamVjdC5rZXlzKHBhcnNlZCkpO1xyXG4gICAgICBpZiAocGFyc2VkLk1hc3RlclNwcmVhZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgXCJNYXN0ZXJTcHJlYWQgd3JhcHBlciBrZXlzOlwiLFxyXG4gICAgICAgICAgT2JqZWN0LmtleXMocGFyc2VkLk1hc3RlclNwcmVhZClcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChwYXJzZWQuTWFzdGVyU3ByZWFkLk1hc3RlclNwcmVhZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIFwiQWN0dWFsIG1hc3RlciBzcHJlYWQga2V5czpcIixcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyc2VkLk1hc3RlclNwcmVhZC5NYXN0ZXJTcHJlYWQpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRXh0cmFjdCBkZXRhaWxlZCBtYXN0ZXIgc3ByZWFkIGluZm9ybWF0aW9uXHJcbiAgICAgIGNvbnN0IGRldGFpbGVkTWFzdGVyID0ge1xyXG4gICAgICAgIHNlbGY6IG1hc3RlckRhdGFbXCJAX1NlbGZcIl0sXHJcbiAgICAgICAgbmFtZTogbWFzdGVyRGF0YVtcIkBfTmFtZVwiXSB8fCBcIlwiLFxyXG4gICAgICAgIG5hbWVQcmVmaXg6IG1hc3RlckRhdGFbXCJAX05hbWVQcmVmaXhcIl0gfHwgXCJcIixcclxuICAgICAgICBiYXNlZE9uOiBtYXN0ZXJEYXRhW1wiQF9CYXNlZE9uXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgaXRlbVRyYW5zZm9ybTogSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKG1hc3RlckRhdGFbXCJAX0l0ZW1UcmFuc2Zvcm1cIl0pLFxyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IG1hc3RlciBwYWdlc1xyXG4gICAgICAgIHBhZ2VzOiB0aGlzLmVsZW1lbnRQYXJzZXIuZXh0cmFjdE1hc3RlclBhZ2VzKG1hc3RlckRhdGEpLFxyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IG1hc3RlciBwYWdlIGl0ZW1zXHJcbiAgICAgICAgcGFnZUl0ZW1zOiB0aGlzLmVsZW1lbnRQYXJzZXIuZXh0cmFjdFBhZ2VJdGVtcyhtYXN0ZXJEYXRhKSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMubWFzdGVyU3ByZWFkc1ttYXN0ZXJJZF0gPSBkZXRhaWxlZE1hc3RlcjtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKchSBNYXN0ZXIgc3ByZWFkICR7bWFzdGVySWR9IHBhcnNlZCB3aXRoICR7ZGV0YWlsZWRNYXN0ZXIucGFnZUl0ZW1zLmxlbmd0aH0gaXRlbXNgXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgIGDinYwgRXJyb3IgcGFyc2luZyBtYXN0ZXIgc3ByZWFkICR7ZmlsZU5hbWV9OmAsXHJcbiAgICAgICAgZXJyb3IubWVzc2FnZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdERldGFpbGVkSW5mb3JtYXRpb24oKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3RpbmcgZGV0YWlsZWQgaW5mb3JtYXRpb24gd2l0aCBlbmhhbmNlZCBwcm9jZXNzaW5nLi4uXCIpO1xyXG5cclxuICAgIHRoaXMucGFnZUluZm8gPSB7XHJcbiAgICAgIGRpbWVuc2lvbnM6IHRoaXMuY2FsY3VsYXRlUGFnZURpbWVuc2lvbnMoKSxcclxuICAgICAgbWFyZ2luczogdGhpcy5jYWxjdWxhdGVNYXJnaW5zKCksXHJcbiAgICAgIGJsZWVkczogdGhpcy5jYWxjdWxhdGVCbGVlZHMoKSxcclxuICAgICAgZ3VpZGVzOiB0aGlzLmV4dHJhY3RHdWlkZXMoKSxcclxuICAgICAgZ3JpZHM6IHRoaXMuZXh0cmFjdEdyaWRzKCksXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZWxlbWVudFBhcnNlci5jcmVhdGVFbGVtZW50UG9zaXRpb25NYXBGaXhlZCgpOyAvLyBVc2UgdGhlIGZpeGVkIHZlcnNpb25cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIuKchSBFbmhhbmNlZCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBleHRyYWN0ZWRcIik7XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVQYWdlRGltZW5zaW9ucygpIHtcclxuICAgIC8vIFRyeSB0byBnZXQgZGltZW5zaW9ucyBmcm9tIHNwcmVhZHMgZmlyc3QgKG1vc3QgcmVsaWFibGUpXHJcbiAgICBpZiAodGhpcy5zcHJlYWRzICYmIE9iamVjdC5rZXlzKHRoaXMuc3ByZWFkcykubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaXJzdFNwcmVhZCA9IE9iamVjdC52YWx1ZXModGhpcy5zcHJlYWRzKVswXTtcclxuICAgICAgaWYgKGZpcnN0U3ByZWFkLnBhZ2VzICYmIGZpcnN0U3ByZWFkLnBhZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSBmaXJzdFNwcmVhZC5wYWdlc1swXTtcclxuICAgICAgICBpZiAoZmlyc3RQYWdlLmdlb21ldHJpY0JvdW5kcykge1xyXG4gICAgICAgICAgY29uc3QgYm91bmRzID0gZmlyc3RQYWdlLmdlb21ldHJpY0JvdW5kcztcclxuXHJcbiAgICAgICAgICAvLyBGSVhFRDogR2V0IHVuaXRzIGZyb20gVmlld1ByZWZlcmVuY2VzIGluc3RlYWQgb2YgaGFyZGNvZGluZyAnUG9pbnRzJ1xyXG4gICAgICAgICAgbGV0IHVuaXRzID0gXCJQb2ludHNcIjsgLy8gZmFsbGJhY2tcclxuXHJcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IHVuaXRzIGZyb20gU3R5bGVQYXJzZXIncyBkb2N1bWVudEluZm8gZmlyc3RcclxuICAgICAgICAgIGlmICh0aGlzLnN0eWxlUGFyc2VyICYmIHRoaXMuc3R5bGVQYXJzZXIuZ2V0RG9jdW1lbnRJbmZvKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlUGFyc2VySW5mbyA9IHRoaXMuc3R5bGVQYXJzZXIuZ2V0RG9jdW1lbnRJbmZvKCk7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICBzdHlsZVBhcnNlckluZm8/LnByZWZlcmVuY2VzPy52aWV3UHJlZmVyZW5jZXNcclxuICAgICAgICAgICAgICAgID8uaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHNcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgdW5pdHMgPVxyXG4gICAgICAgICAgICAgICAgc3R5bGVQYXJzZXJJbmZvLnByZWZlcmVuY2VzLnZpZXdQcmVmZXJlbmNlc1xyXG4gICAgICAgICAgICAgICAgICAuaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHM7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgICBcIvCfk48gVXNpbmcgbWVhc3VyZW1lbnQgdW5pdHMgZnJvbSBTdHlsZVBhcnNlcjpcIixcclxuICAgICAgICAgICAgICAgIHVuaXRzXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGxvY2FsIGRvY3VtZW50SW5mb1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB1bml0cyA9PT0gXCJQb2ludHNcIiAmJlxyXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50SW5mbz8ucHJlZmVyZW5jZXM/LnZpZXdQcmVmZXJlbmNlc1xyXG4gICAgICAgICAgICAgID8uaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHNcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB1bml0cyA9XHJcbiAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudEluZm8ucHJlZmVyZW5jZXMudmlld1ByZWZlcmVuY2VzXHJcbiAgICAgICAgICAgICAgICAuaG9yaXpvbnRhbE1lYXN1cmVtZW50VW5pdHM7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgIFwi8J+TjyBVc2luZyBtZWFzdXJlbWVudCB1bml0cyBmcm9tIGxvY2FsIERvY3VtZW50SW5mbzpcIixcclxuICAgICAgICAgICAgICB1bml0c1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYm91bmRzLndpZHRoIHx8IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0IHx8IDA7XHJcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0IHx8IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wIHx8IDA7XHJcbiAgICAgICAgICBjb25zdCBmYWNpbmdQYWdlcyA9IE9iamVjdC52YWx1ZXModGhpcy5zcHJlYWRzKS5zb21lKFxyXG4gICAgICAgICAgICAoc3ByZWFkKSA9PiBzcHJlYWQucGFnZXMgJiYgc3ByZWFkLnBhZ2VzLmxlbmd0aCA+IDFcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgZmFjaW5nUGFnZXM6IGZhY2luZ1BhZ2VzLFxyXG4gICAgICAgICAgICB1bml0czogdW5pdHMsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIC8vIEFEREVEOiBTZXQgZG9jdW1lbnQgdW5pdHMgb24gYWxsIHBhcnNlcnMgZm9yIGNvbnNpc3RlbnQgY29udmVyc2lvbnNcclxuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRQYXJzZXIgJiYgdGhpcy5lbGVtZW50UGFyc2VyLnNldERvY3VtZW50VW5pdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50UGFyc2VyLnNldERvY3VtZW50VW5pdHModW5pdHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHRoaXMuc3RvcnlQYXJzZXIgJiYgdGhpcy5zdG9yeVBhcnNlci5zZXREb2N1bWVudFVuaXRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcnlQYXJzZXIuc2V0RG9jdW1lbnRVbml0cyh1bml0cyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5zdHlsZVBhcnNlciAmJiB0aGlzLnN0eWxlUGFyc2VyLnNldERvY3VtZW50VW5pdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZVBhcnNlci5zZXREb2N1bWVudFVuaXRzKHVuaXRzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBRERFRDogQ29udmVydCB0byBwaXhlbHMgaWYgVW5pdENvbnZlcnRlciBpcyBhdmFpbGFibGUgYW5kIGNvbnZlcnNpb24gaXMgZW5hYmxlZFxyXG4gICAgICAgICAgaWYgKHRoaXMudW5pdENvbnZlcnRlciAmJiB0aGlzLnVuaXRDb252ZXJ0ZXIuaXNTdXBwb3J0ZWRVbml0KHVuaXRzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bml0Q29udmVydGVyLmNvbnZlcnREaW1lbnNpb25zKGRpbWVuc2lvbnMpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBkaW1lbnNpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZhbGxiYWNrIHRvIGRvY3VtZW50IHByZWZlcmVuY2VzXHJcbiAgICBjb25zdCBkb2NQcmVmcyA9IHRoaXMuZG9jdW1lbnRJbmZvLnByZWZlcmVuY2VzPy5kb2N1bWVudFByZWZlcmVuY2VzIHx8IHt9O1xyXG5cclxuICAgIC8vIEZJWEVEOiBCZXR0ZXIgdW5pdHMgZGV0ZWN0aW9uIGZvciBmYWxsYmFjayBjYXNlXHJcbiAgICBsZXQgdW5pdHMgPSBcIlBvaW50c1wiOyAvLyBkZWZhdWx0IGZhbGxiYWNrXHJcblxyXG4gICAgLy8gVHJ5IFN0eWxlUGFyc2VyIGZpcnN0XHJcbiAgICBpZiAodGhpcy5zdHlsZVBhcnNlciAmJiB0aGlzLnN0eWxlUGFyc2VyLmdldERvY3VtZW50SW5mbykge1xyXG4gICAgICBjb25zdCBzdHlsZVBhcnNlckluZm8gPSB0aGlzLnN0eWxlUGFyc2VyLmdldERvY3VtZW50SW5mbygpO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgc3R5bGVQYXJzZXJJbmZvPy5wcmVmZXJlbmNlcz8udmlld1ByZWZlcmVuY2VzXHJcbiAgICAgICAgICA/Lmhvcml6b250YWxNZWFzdXJlbWVudFVuaXRzXHJcbiAgICAgICkge1xyXG4gICAgICAgIHVuaXRzID1cclxuICAgICAgICAgIHN0eWxlUGFyc2VySW5mby5wcmVmZXJlbmNlcy52aWV3UHJlZmVyZW5jZXNcclxuICAgICAgICAgICAgLmhvcml6b250YWxNZWFzdXJlbWVudFVuaXRzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlbiB0cnkgbG9jYWwgZG9jdW1lbnRJbmZvXHJcbiAgICBpZiAoXHJcbiAgICAgIHVuaXRzID09PSBcIlBvaW50c1wiICYmXHJcbiAgICAgIHRoaXMuZG9jdW1lbnRJbmZvPy5wcmVmZXJlbmNlcz8udmlld1ByZWZlcmVuY2VzXHJcbiAgICAgICAgPy5ob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0c1xyXG4gICAgKSB7XHJcbiAgICAgIHVuaXRzID1cclxuICAgICAgICB0aGlzLmRvY3VtZW50SW5mby5wcmVmZXJlbmNlcy52aWV3UHJlZmVyZW5jZXNcclxuICAgICAgICAgIC5ob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cztcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIvCfk48gRmluYWwgbWVhc3VyZW1lbnQgdW5pdHMgZGVjaXNpb246XCIsIHVuaXRzKTtcclxuXHJcbiAgICBjb25zdCBkaW1lbnNpb25zID0ge1xyXG4gICAgICB3aWR0aDogZG9jUHJlZnMucGFnZVdpZHRoIHx8IDAsXHJcbiAgICAgIGhlaWdodDogZG9jUHJlZnMucGFnZUhlaWdodCB8fCAwLFxyXG4gICAgICBmYWNpbmdQYWdlczogZG9jUHJlZnMuZmFjaW5nUGFnZXMgfHwgZmFsc2UsXHJcbiAgICAgIHVuaXRzOiB1bml0cyxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQURERUQ6IFNldCBkb2N1bWVudCB1bml0cyBvbiBFbGVtZW50UGFyc2VyLCBTdG9yeVBhcnNlciwgYW5kIFN0eWxlUGFyc2VyIGZvciBjb25zaXN0ZW50IGNvbnZlcnNpb25zXHJcbiAgICBpZiAodGhpcy5lbGVtZW50UGFyc2VyICYmIHRoaXMuZWxlbWVudFBhcnNlci5zZXREb2N1bWVudFVuaXRzKSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudFBhcnNlci5zZXREb2N1bWVudFVuaXRzKHVuaXRzKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN0b3J5UGFyc2VyICYmIHRoaXMuc3RvcnlQYXJzZXIuc2V0RG9jdW1lbnRVbml0cykge1xyXG4gICAgICB0aGlzLnN0b3J5UGFyc2VyLnNldERvY3VtZW50VW5pdHModW5pdHMpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuc3R5bGVQYXJzZXIgJiYgdGhpcy5zdHlsZVBhcnNlci5zZXREb2N1bWVudFVuaXRzKSB7XHJcbiAgICAgIHRoaXMuc3R5bGVQYXJzZXIuc2V0RG9jdW1lbnRVbml0cyh1bml0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQURERUQ6IENvbnZlcnQgdG8gcGl4ZWxzIGlmIFVuaXRDb252ZXJ0ZXIgaXMgYXZhaWxhYmxlIGFuZCBjb252ZXJzaW9uIGlzIGVuYWJsZWRcclxuICAgIGlmICh0aGlzLnVuaXRDb252ZXJ0ZXIgJiYgdGhpcy51bml0Q29udmVydGVyLmlzU3VwcG9ydGVkVW5pdCh1bml0cykpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudW5pdENvbnZlcnRlci5jb252ZXJ0RGltZW5zaW9ucyhkaW1lbnNpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGltZW5zaW9ucztcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZU1hcmdpbnMoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIvCfk48gQ2FsY3VsYXRpbmcgbWFyZ2lucyBmcm9tIG11bHRpcGxlIHNvdXJjZXMuLi5cIik7XHJcblxyXG4gICAgLy8gVHJ5IHRvIGdldCBtYXJnaW5zIGZyb20gbWFzdGVyIHBhZ2VzIGZpcnN0IChtb3N0IHJlbGlhYmxlKVxyXG4gICAgaWYgKHRoaXMubWFzdGVyU3ByZWFkcyAmJiBPYmplY3Qua2V5cyh0aGlzLm1hc3RlclNwcmVhZHMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgZmlyc3RNYXN0ZXIgPSBPYmplY3QudmFsdWVzKHRoaXMubWFzdGVyU3ByZWFkcylbMF07XHJcbiAgICAgIGlmIChmaXJzdE1hc3Rlci5wYWdlcyAmJiBmaXJzdE1hc3Rlci5wYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RNYXN0ZXJQYWdlID0gZmlyc3RNYXN0ZXIucGFnZXNbMF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgZm9yIG1hcmdpbiBwcmVmZXJlbmNlcyBpbiBtYXN0ZXIgcGFnZVxyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBwb3B1bGF0ZWQgYnkgdGhlIGltcHJvdmVkIG1hc3RlciBzcHJlYWQgcGFyc2luZ1xyXG4gICAgICAgIGlmIChmaXJzdE1hc3RlclBhZ2UubWFyZ2luUHJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgY29uc3QgbWFzdGVyTWFyZ2lucyA9IHtcclxuICAgICAgICAgICAgdG9wOiBmaXJzdE1hc3RlclBhZ2UubWFyZ2luUHJlZmVyZW5jZS50b3AgfHwgMCxcclxuICAgICAgICAgICAgYm90dG9tOiBmaXJzdE1hc3RlclBhZ2UubWFyZ2luUHJlZmVyZW5jZS5ib3R0b20gfHwgMCxcclxuICAgICAgICAgICAgbGVmdDogZmlyc3RNYXN0ZXJQYWdlLm1hcmdpblByZWZlcmVuY2UubGVmdCB8fCAwLFxyXG4gICAgICAgICAgICByaWdodDogZmlyc3RNYXN0ZXJQYWdlLm1hcmdpblByZWZlcmVuY2UucmlnaHQgfHwgMCxcclxuICAgICAgICAgICAgY29sdW1uQ291bnQ6IGZpcnN0TWFzdGVyUGFnZS5tYXJnaW5QcmVmZXJlbmNlLmNvbHVtbkNvdW50IHx8IDEsXHJcbiAgICAgICAgICAgIGNvbHVtbkd1dHRlcjogZmlyc3RNYXN0ZXJQYWdlLm1hcmdpblByZWZlcmVuY2UuY29sdW1uR3V0dGVyIHx8IDAsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjyBGb3VuZCBtYXJnaW5zIGZyb20gbWFzdGVyIHBhZ2U6XCIsIG1hc3Rlck1hcmdpbnMpO1xyXG5cclxuICAgICAgICAgIC8vIEFEREVEOiBDb252ZXJ0IG1hcmdpbnMgdG8gcGl4ZWxzIGlmIFVuaXRDb252ZXJ0ZXIgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICBpZiAodGhpcy51bml0Q29udmVydGVyICYmIHRoaXMuZWxlbWVudFBhcnNlcj8uZG9jdW1lbnRVbml0cykge1xyXG4gICAgICAgICAgICBjb25zdCBwaXhlbE1hcmdpbnMgPSB0aGlzLnVuaXRDb252ZXJ0ZXIuY29udmVydE9iamVjdFRvUGl4ZWxzKFxyXG4gICAgICAgICAgICAgIG1hc3Rlck1hcmdpbnMsXHJcbiAgICAgICAgICAgICAgdGhpcy5lbGVtZW50UGFyc2VyLmRvY3VtZW50VW5pdHNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAuLi5tYXN0ZXJNYXJnaW5zLFxyXG4gICAgICAgICAgICAgIHBpeGVsTWFyZ2luczogcGl4ZWxNYXJnaW5zLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBtYXN0ZXJNYXJnaW5zO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZhbGxiYWNrIHRvIGRvY3VtZW50IHByZWZlcmVuY2VzXHJcbiAgICBjb25zdCBkb2NQcmVmcyA9IHRoaXMuZG9jdW1lbnRJbmZvLmRvY3VtZW50UHJlZmVyZW5jZXMgfHwge307XHJcbiAgICBjb25zdCBtYXJnaW5QcmVmcyA9IHRoaXMuZG9jdW1lbnRJbmZvLnByZWZlcmVuY2VzPy5tYXJnaW5QcmVmZXJlbmNlcyB8fCB7fTtcclxuXHJcbiAgICAvLyBDaGVjayBmb3IgbWFyZ2luIGRhdGEgaW4gZG9jdW1lbnQgcHJlZmVyZW5jZXMgKGZhbGxiYWNrKVxyXG4gICAgY29uc3QgbWFyZ2lucyA9IHtcclxuICAgICAgdG9wOiBtYXJnaW5QcmVmcy50b3AgfHwgZG9jUHJlZnMubWFyZ2luVG9wIHx8IGRvY1ByZWZzLnRvcCB8fCAwLFxyXG4gICAgICBib3R0b206XHJcbiAgICAgICAgbWFyZ2luUHJlZnMuYm90dG9tIHx8IGRvY1ByZWZzLm1hcmdpbkJvdHRvbSB8fCBkb2NQcmVmcy5ib3R0b20gfHwgMCxcclxuICAgICAgbGVmdDogbWFyZ2luUHJlZnMubGVmdCB8fCBkb2NQcmVmcy5tYXJnaW5MZWZ0IHx8IGRvY1ByZWZzLmxlZnQgfHwgMCxcclxuICAgICAgcmlnaHQ6IG1hcmdpblByZWZzLnJpZ2h0IHx8IGRvY1ByZWZzLm1hcmdpblJpZ2h0IHx8IGRvY1ByZWZzLnJpZ2h0IHx8IDAsXHJcbiAgICAgIGNvbHVtbkNvdW50OlxyXG4gICAgICAgIG1hcmdpblByZWZzLmNvbHVtbkNvdW50IHx8XHJcbiAgICAgICAgZG9jUHJlZnMubWFyZ2luQ29sdW1uQ291bnQgfHxcclxuICAgICAgICBkb2NQcmVmcy5jb2x1bW5Db3VudCB8fFxyXG4gICAgICAgIDEsXHJcbiAgICAgIGNvbHVtbkd1dHRlcjpcclxuICAgICAgICBtYXJnaW5QcmVmcy5jb2x1bW5HdXR0ZXIgfHxcclxuICAgICAgICBkb2NQcmVmcy5tYXJnaW5Db2x1bW5HdXR0ZXIgfHxcclxuICAgICAgICBkb2NQcmVmcy5jb2x1bW5HdXR0ZXIgfHxcclxuICAgICAgICAwLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIvCfk48gQ2FsY3VsYXRlZCBtYXJnaW5zIChmYWxsYmFjayk6XCIsIG1hcmdpbnMpO1xyXG5cclxuICAgIC8vIEFEREVEOiBDb252ZXJ0IG1hcmdpbnMgdG8gcGl4ZWxzIGlmIFVuaXRDb252ZXJ0ZXIgaXMgYXZhaWxhYmxlXHJcbiAgICBpZiAodGhpcy51bml0Q29udmVydGVyICYmIHRoaXMuZWxlbWVudFBhcnNlcj8uZG9jdW1lbnRVbml0cykge1xyXG4gICAgICBjb25zdCBwaXhlbE1hcmdpbnMgPSB0aGlzLnVuaXRDb252ZXJ0ZXIuY29udmVydE9iamVjdFRvUGl4ZWxzKFxyXG4gICAgICAgIG1hcmdpbnMsXHJcbiAgICAgICAgdGhpcy5lbGVtZW50UGFyc2VyLmRvY3VtZW50VW5pdHNcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5tYXJnaW5zLFxyXG4gICAgICAgIHBpeGVsTWFyZ2luczogcGl4ZWxNYXJnaW5zLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtYXJnaW5zO1xyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlQmxlZWRzKCkge1xyXG4gICAgY29uc3QgZG9jUHJlZnMgPSB0aGlzLmRvY3VtZW50SW5mby5wcmVmZXJlbmNlcz8uZG9jdW1lbnRQcmVmZXJlbmNlcyB8fCB7fTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IGRvY1ByZWZzLmRvY3VtZW50QmxlZWRUb3BPZmZzZXQgfHwgMCxcclxuICAgICAgYm90dG9tOiBkb2NQcmVmcy5kb2N1bWVudEJsZWVkQm90dG9tT2Zmc2V0IHx8IDAsXHJcbiAgICAgIGluc2lkZTogZG9jUHJlZnMuZG9jdW1lbnRCbGVlZEluc2lkZU9yTGVmdE9mZnNldCB8fCAwLFxyXG4gICAgICBvdXRzaWRlOiBkb2NQcmVmcy5kb2N1bWVudEJsZWVkT3V0c2lkZU9yUmlnaHRPZmZzZXQgfHwgMCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3VpZGVzKCkge1xyXG4gICAgY29uc3QgZ3VpZGVzID0gW107XHJcblxyXG4gICAgLy8gRXh0cmFjdCBndWlkZXMgZnJvbSBzcHJlYWRzXHJcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuc3ByZWFkcykuZm9yRWFjaCgoc3ByZWFkKSA9PiB7XHJcbiAgICAgIGlmIChzcHJlYWQucGFnZUl0ZW1zKSB7XHJcbiAgICAgICAgc3ByZWFkLnBhZ2VJdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcIkd1aWRlXCIpIHtcclxuICAgICAgICAgICAgZ3VpZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBpdGVtLm9yaWVudGF0aW9uIHx8IFwiSG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiBpdGVtLmxvY2F0aW9uIHx8IDAsXHJcbiAgICAgICAgICAgICAgZml0VG9QYWdlOiBpdGVtLmZpdFRvUGFnZSB8fCBmYWxzZSxcclxuICAgICAgICAgICAgICB2aWV3VGhyZXNob2xkOiBpdGVtLnZpZXdUaHJlc2hvbGQgfHwgMCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBndWlkZXM7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3JpZHMoKSB7XHJcbiAgICBjb25zdCBncmlkUHJlZnMgPSB0aGlzLmRvY3VtZW50SW5mby5wcmVmZXJlbmNlcz8uZ3JpZFByZWZlcmVuY2VzIHx8IHt9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJhc2VsaW5lOiB7XHJcbiAgICAgICAgc3RhcnQ6IGdyaWRQcmVmcy5iYXNlbGluZVN0YXJ0IHx8IDAsXHJcbiAgICAgICAgZGl2aXNpb246IGdyaWRQcmVmcy5iYXNlbGluZURpdmlzaW9uIHx8IDEyLFxyXG4gICAgICAgIHNob3duOiBncmlkUHJlZnMuYmFzZWxpbmVTaG93biB8fCBmYWxzZSxcclxuICAgICAgICBzbmFwVG86IGdyaWRQcmVmcy5iYXNlbGluZVNuYXB0byB8fCBmYWxzZSxcclxuICAgICAgfSxcclxuICAgICAgZG9jdW1lbnQ6IHtcclxuICAgICAgICBzaG93bjogZ3JpZFByZWZzLmRvY3VtZW50R3JpZFNob3duIHx8IGZhbHNlLFxyXG4gICAgICAgIHNuYXBUbzogZ3JpZFByZWZzLmRvY3VtZW50R3JpZFNuYXB0byB8fCBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBnZXQgcGFnZSBjb250ZW50XHJcbiAgZ2V0UGFnZUNvbnRlbnQocGFnZUlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50UGFyc2VyLmdldFBhZ2VDb250ZW50KHBhZ2VJZCk7XHJcbiAgfVxyXG5cclxuICBnZXREb2N1bWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50O1xyXG4gIH1cclxuXHJcbiAgZ2V0U3ByZWFkcygpIHtcclxuICAgIHJldHVybiB0aGlzLnNwcmVhZHM7XHJcbiAgfVxyXG5cclxuICBnZXRNYXN0ZXJTcHJlYWRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWFzdGVyU3ByZWFkcztcclxuICB9XHJcblxyXG4gIGdldERvY3VtZW50SW5mbygpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50SW5mbztcclxuICB9XHJcblxyXG4gIGdldFBhZ2VJbmZvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGFnZUluZm87XHJcbiAgfVxyXG5cclxuICBnZXRMYXllcnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sYXllcnM7XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KCkge1xyXG4gICAgcmV0dXJuIElETUxVdGlscy5jYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KFxyXG4gICAgICB0aGlzLmVsZW1lbnRQYXJzZXIuZ2V0RWxlbWVudHMoKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnRQYXJzZXI7XHJcbiJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIklETUxVdGlscyIsIkRvY3VtZW50UGFyc2VyIiwiY29uc3RydWN0b3IiLCJlbGVtZW50UGFyc2VyIiwic3R5bGVQYXJzZXIiLCJ1bml0Q29udmVydGVyIiwiZG9jdW1lbnRJbmZvIiwic3ByZWFkcyIsIm1hc3RlclNwcmVhZHMiLCJsYXllcnMiLCJwYXJzZURvY3VtZW50U3RydWN0dXJlIiwiZXh0cmFjdGVkRGF0YSIsInhtbFBhcnNlciIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZGVzaWduTWFwRGF0YSIsInBhcnNlIiwiZG9jdW1lbnQiLCJEb2N1bWVudCIsImV4dHJhY3REb2N1bWVudEluZm8iLCJlcnJvciIsImZpbGVOYW1lIiwiY29udGVudCIsImVudHJpZXMiLCJzdGFydHNXaXRoIiwicGFyc2VTcHJlYWRGaWxlIiwicGFyc2VNYXN0ZXJTcHJlYWRGaWxlIiwidmVyc2lvbiIsInNlbGYiLCJhY3RpdmVMYXllciIsInVudXNlZFN3YXRjaGVzIiwiZG9jdW1lbnRQcmVmZXJlbmNlcyIsImV4dHJhY3REb2N1bWVudFByZWZlcmVuY2VzIiwicGFnZVNldHVwIiwiZXh0cmFjdFBhZ2VTZXR1cCIsImV4dHJhY3RMYXllcnMiLCJwYWdlcyIsImV4dHJhY3RQYWdlcyIsInByZWZzIiwiZG9jUHJlZiIsIkRvY3VtZW50UHJlZmVyZW5jZSIsImRvY3VtZW50UHJlZmVyZW5jZSIsIlByb3BlcnRpZXMiLCJwYWdlV2lkdGgiLCJwYXJzZUZsb2F0IiwicGFnZUhlaWdodCIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbHVtbkNvdW50IiwicGFyc2VJbnQiLCJjb2x1bW5HdXR0ZXIiLCJmYWNpbmdQYWdlcyIsIm1hcmdpblByZWYiLCJNYXJnaW5QcmVmZXJlbmNlIiwibWFyZ2luUHJlZmVyZW5jZSIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkNvbHVtbkNvdW50IiwibWFyZ2luQ29sdW1uR3V0dGVyIiwibWFzdGVyUGFnZXMiLCJQYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInBhZ2UiLCJwdXNoIiwibmFtZSIsImFwcGxpZWRNYXN0ZXIiLCJnZW9tZXRyaWNCb3VuZHMiLCJwYXJzZUdlb21ldHJpY0JvdW5kcyIsIml0ZW1UcmFuc2Zvcm0iLCJwYXJzZVRyYW5zZm9ybSIsIm92ZXJyaWRlTGlzdCIsIkxheWVyIiwibGF5ZXJEYXRhIiwibGF5ZXIiLCJ2aXNpYmxlIiwibG9ja2VkIiwiaWdub3JlV3JhcCIsInNob3dHdWlkZXMiLCJsb2NrR3VpZGVzIiwidWkiLCJsYXllckNvbG9yIiwiU3ByZWFkIiwic3ByZWFkIiwic3ByZWFkUGFnZXMiLCJzcHJlYWRQYXJlbnQiLCJwYXJzZWQiLCJzcHJlYWRJZCIsImJhc2VuYW1lIiwic3ByZWFkRGF0YSIsImluZGV4Iiwia2V5IiwidmFsdWUiLCJpbmNsdWRlcyIsImRldGFpbGVkU3ByZWFkIiwiZmxhdHRlbmVyT3ZlcnJpZGUiLCJiaW5kaW5nTG9jYXRpb24iLCJhbGxvd1BhZ2VTaHVmZmxlIiwiZXh0cmFjdFNwcmVhZFBhZ2VzIiwicGFnZUl0ZW1zIiwiZXh0cmFjdFBhZ2VJdGVtcyIsIm1lc3NhZ2UiLCJtYXN0ZXJJZCIsIm1hc3RlckRhdGEiLCJNYXN0ZXJTcHJlYWQiLCJkZXRhaWxlZE1hc3RlciIsIm5hbWVQcmVmaXgiLCJiYXNlZE9uIiwiZXh0cmFjdE1hc3RlclBhZ2VzIiwiZXh0cmFjdERldGFpbGVkSW5mb3JtYXRpb24iLCJwYWdlSW5mbyIsImRpbWVuc2lvbnMiLCJjYWxjdWxhdGVQYWdlRGltZW5zaW9ucyIsIm1hcmdpbnMiLCJjYWxjdWxhdGVNYXJnaW5zIiwiYmxlZWRzIiwiY2FsY3VsYXRlQmxlZWRzIiwiZ3VpZGVzIiwiZXh0cmFjdEd1aWRlcyIsImdyaWRzIiwiZXh0cmFjdEdyaWRzIiwiY3JlYXRlRWxlbWVudFBvc2l0aW9uTWFwRml4ZWQiLCJmaXJzdFNwcmVhZCIsInZhbHVlcyIsImZpcnN0UGFnZSIsImJvdW5kcyIsInVuaXRzIiwiZ2V0RG9jdW1lbnRJbmZvIiwic3R5bGVQYXJzZXJJbmZvIiwicHJlZmVyZW5jZXMiLCJ2aWV3UHJlZmVyZW5jZXMiLCJob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cyIsIndpZHRoIiwiaGVpZ2h0Iiwic29tZSIsInNldERvY3VtZW50VW5pdHMiLCJzdG9yeVBhcnNlciIsImlzU3VwcG9ydGVkVW5pdCIsImNvbnZlcnREaW1lbnNpb25zIiwiZG9jUHJlZnMiLCJmaXJzdE1hc3RlciIsImZpcnN0TWFzdGVyUGFnZSIsIm1hc3Rlck1hcmdpbnMiLCJkb2N1bWVudFVuaXRzIiwicGl4ZWxNYXJnaW5zIiwiY29udmVydE9iamVjdFRvUGl4ZWxzIiwibWFyZ2luUHJlZnMiLCJtYXJnaW5QcmVmZXJlbmNlcyIsImRvY3VtZW50QmxlZWRUb3BPZmZzZXQiLCJkb2N1bWVudEJsZWVkQm90dG9tT2Zmc2V0IiwiaW5zaWRlIiwiZG9jdW1lbnRCbGVlZEluc2lkZU9yTGVmdE9mZnNldCIsIm91dHNpZGUiLCJkb2N1bWVudEJsZWVkT3V0c2lkZU9yUmlnaHRPZmZzZXQiLCJpdGVtIiwidHlwZSIsIm9yaWVudGF0aW9uIiwibG9jYXRpb24iLCJmaXRUb1BhZ2UiLCJ2aWV3VGhyZXNob2xkIiwiZ3JpZFByZWZzIiwiZ3JpZFByZWZlcmVuY2VzIiwiYmFzZWxpbmUiLCJzdGFydCIsImJhc2VsaW5lU3RhcnQiLCJkaXZpc2lvbiIsImJhc2VsaW5lRGl2aXNpb24iLCJzaG93biIsImJhc2VsaW5lU2hvd24iLCJzbmFwVG8iLCJiYXNlbGluZVNuYXB0byIsImRvY3VtZW50R3JpZFNob3duIiwiZG9jdW1lbnRHcmlkU25hcHRvIiwiZ2V0UGFnZUNvbnRlbnQiLCJwYWdlSWQiLCJnZXREb2N1bWVudCIsImdldFNwcmVhZHMiLCJnZXRNYXN0ZXJTcHJlYWRzIiwiZ2V0UGFnZUluZm8iLCJnZXRMYXllcnMiLCJjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0IiwiZ2V0RWxlbWVudHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/parsers/DocumentParser.js\n");

/***/ }),

/***/ "./lib/parsers/ElementParser.js":
/*!**************************************!*\
  !*** ./lib/parsers/ElementParser.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass ElementParser {\n    constructor(unitConverter = null){\n        this.elements = [];\n        this.unitConverter = unitConverter; // ADDED: Unit converter for geometric bounds\n        this.documentUnits = null; // Will be set by DocumentParser\n    }\n    // ADDED: Method to set document units for element conversion\n    setDocumentUnits(units) {\n        this.documentUnits = units;\n        console.log(\"\\uD83D\\uDCD0 ElementParser: Set document units to\", units);\n    }\n    // ADDED: Method to convert geometric bounds if needed\n    convertBoundsToPixels(bounds) {\n        if (!bounds || !this.unitConverter || !this.documentUnits) {\n            return bounds;\n        }\n        // Only convert if we have a supported unit and it's not already pixels\n        if (this.unitConverter.isSupportedUnit(this.documentUnits)) {\n            const convertedBounds = this.unitConverter.convertObjectToPixels(bounds, this.documentUnits);\n            console.log(`ðŸ“ Converted bounds from ${this.documentUnits} to pixels:`, {\n                original: bounds,\n                converted: convertedBounds\n            });\n            return convertedBounds;\n        }\n        return bounds;\n    }\n    // ADDED: Method to convert transform coordinates (tx, ty) to pixels\n    convertTransformToPixels(transform) {\n        if (!transform || !this.unitConverter || !this.documentUnits) {\n            return transform;\n        }\n        // Only convert if we have a supported unit and it's not already pixels\n        if (this.unitConverter.isSupportedUnit(this.documentUnits)) {\n            // Convert only the translation values (tx, ty) to pixels\n            // Keep scale/rotation values (a, b, c, d) unchanged as they're ratios\n            const convertedTransform = {\n                ...transform,\n                tx: transform.tx ? this.unitConverter.toPixels(transform.tx, this.documentUnits) : 0,\n                ty: transform.ty ? this.unitConverter.toPixels(transform.ty, this.documentUnits) : 0\n            };\n            console.log(`ðŸ“ Converted transform from ${this.documentUnits} to pixels:`, {\n                original: {\n                    tx: transform.tx,\n                    ty: transform.ty\n                },\n                converted: {\n                    tx: convertedTransform.tx,\n                    ty: convertedTransform.ty\n                }\n            });\n            return convertedTransform;\n        }\n        return transform;\n    }\n    // ADDED: Method to convert single measurement values to pixels\n    convertMeasurementToPixels(value) {\n        if (typeof value !== \"number\" || isNaN(value) || !this.unitConverter || !this.documentUnits) {\n            return value;\n        }\n        // Only convert if we have a supported unit and it's not already pixels\n        if (this.unitConverter.isSupportedUnit(this.documentUnits)) {\n            const convertedValue = this.unitConverter.toPixels(value, this.documentUnits);\n            console.log(`ðŸ“ Converted measurement: ${value} ${this.documentUnits} â†’ ${convertedValue} px`);\n            return convertedValue;\n        }\n        return value;\n    }\n    extractSpreadPages(spreadData) {\n        const pages = [];\n        if (spreadData.Page) {\n            const pageList = Array.isArray(spreadData.Page) ? spreadData.Page : [\n                spreadData.Page\n            ];\n            pageList.forEach((page, index)=>{\n                pages.push({\n                    self: page[\"@_Self\"],\n                    name: page[\"@_Name\"] || \"\",\n                    appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                    geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                    itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"])\n                });\n            });\n        } else {\n            console.log(\"No pages found in spread data\");\n        }\n        console.log(`Extracted ${pages.length} pages`);\n        return pages;\n    }\n    extractPageItems(spreadData) {\n        const pageItems = [];\n        // Extract different types of page items\n        const itemTypes = [\n            \"Rectangle\",\n            \"Oval\",\n            \"Polygon\",\n            \"GraphicLine\",\n            \"TextFrame\",\n            \"Group\",\n            \"Button\",\n            \"Table\",\n            \"Image\",\n            \"EPS\",\n            \"PDF\",\n            \"PlacedItem\",\n            \"ContentFrame\"\n        ];\n        itemTypes.forEach((itemType)=>{\n            if (spreadData[itemType]) {\n                const items = Array.isArray(spreadData[itemType]) ? spreadData[itemType] : [\n                    spreadData[itemType]\n                ];\n                items.forEach((item)=>{\n                    console.log(`Processing ${itemType}:`, item[\"@_Self\"]);\n                    const pageItem = this.parsePageItem(item, itemType);\n                    if (pageItem) {\n                        pageItems.push(pageItem);\n                        this.elements.push(pageItem);\n                    }\n                });\n            }\n        });\n        this.checkForNestedContent(spreadData, pageItems);\n        // ALSO CHECK FOR NESTED ITEMS IN PAGES\n        if (spreadData.Page) {\n            const pages = Array.isArray(spreadData.Page) ? spreadData.Page : [\n                spreadData.Page\n            ];\n            pages.forEach((page)=>{\n                itemTypes.forEach((itemType)=>{\n                    if (page[itemType]) {\n                        console.log(`Found ${itemType} in page:`, Array.isArray(page[itemType]) ? page[itemType].length : 1);\n                        const items = Array.isArray(page[itemType]) ? page[itemType] : [\n                            page[itemType]\n                        ];\n                        items.forEach((item)=>{\n                            const pageItem = this.parsePageItem(item, itemType);\n                            if (pageItem) {\n                                pageItems.push(pageItem);\n                                this.elements.push(pageItem);\n                            }\n                        });\n                    }\n                });\n            });\n        }\n        console.log(`Total page items extracted: ${pageItems.length}`);\n        return pageItems;\n    }\n    checkForNestedContent(spreadData, pageItems) {\n        console.log(\"\\uD83D\\uDD0D Checking for nested content in elements...\");\n        // Check rectangles for placed images\n        if (spreadData.Rectangle) {\n            const rectangles = Array.isArray(spreadData.Rectangle) ? spreadData.Rectangle : [\n                spreadData.Rectangle\n            ];\n            rectangles.forEach((rect)=>{\n                // Look for ANY content inside rectangle - be more aggressive\n                const possibleContent = rect.Image || rect.PlacedImage || rect.EPS || rect.PDF || rect.Properties?.Image || rect.Properties?.PlacedImage || rect.Link || rect.Properties?.Link;\n                if (possibleContent) {\n                    console.log(`ðŸ“· Found placed content in rectangle ${rect[\"@_Self\"]}:`, possibleContent);\n                    // Update the rectangle to indicate it's a content frame\n                    const existingRect = pageItems.find((item)=>item.self === rect[\"@_Self\"]);\n                    if (existingRect) {\n                        existingRect.hasPlacedContent = true;\n                        existingRect.contentType = \"Image\";\n                        // Only set placedContent if not already set\n                        if (!existingRect.placedContent) {\n                            const nestedLink = possibleContent.Link || null;\n                            existingRect.placedContent = this.extractPlacedContent(possibleContent, nestedLink);\n                        }\n                        // IMPORTANT: Calculate the image position within the frame\n                        existingRect.imagePosition = IDMLUtils.calculateImagePositionInFrame(existingRect.geometricBounds, existingRect.itemTransform, existingRect.placedContent);\n                    }\n                }\n            });\n        }\n    }\n    extractPlacedContent(content, linkObject) {\n        if (!content) return null;\n        console.log(\"\\uD83D\\uDD0D Extracting placed content:\", content);\n        const contentItem = Array.isArray(content) ? content[0] : content;\n        console.log(\"Content item keys:\", Object.keys(contentItem));\n        // ENHANCED: Better href handling using Link object\n        let href = \"\";\n        if (linkObject && linkObject[\"@_LinkResourceURI\"]) {\n            // Remove 'file:' prefix and extract just the filename\n            const uri = linkObject[\"@_LinkResourceURI\"];\n            href = uri.replace(/^file:/, \"\").split(/[\\\\/]/).pop();\n        } else {\n            href = contentItem[\"@_href\"] || contentItem[\"@_ActualPpi\"] || \"\";\n        }\n        let isEmbedded = false;\n        // Check if this is an embedded image reference\n        if (href && !href.startsWith(\"file://\") && !href.includes(\"/\")) {\n            isEmbedded = true;\n            console.log(\"\\uD83D\\uDDBCï¸ Detected embedded image reference:\", href);\n        }\n        console.log(\"Returning placedContent:\", {\n            href,\n            linkObject\n        });\n        return {\n            type: contentItem[\"@_type\"] || \"Image\",\n            href: href,\n            isEmbedded: isEmbedded,\n            bounds: contentItem[\"@_GeometricBounds\"] ? IDMLUtils.parseGeometricBounds(contentItem[\"@_GeometricBounds\"]) : null,\n            transform: contentItem[\"@_ItemTransform\"] ? IDMLUtils.parseTransform(contentItem[\"@_ItemTransform\"]) : null,\n            actualPpi: contentItem[\"@_ActualPpi\"],\n            effectivePpi: contentItem[\"@_EffectivePpi\"],\n            imageTypeName: contentItem[\"@_ImageTypeName\"],\n            space: contentItem[\"@_Space\"]\n        };\n    }\n    parsePageItem(item, itemType) {\n        // ADD: Validation\n        if (!item || !item[\"@_Self\"]) {\n            console.warn(`Invalid ${itemType} item - missing self ID`);\n            return null;\n        }\n        const baseItem = {\n            type: itemType,\n            self: item[\"@_Self\"],\n            name: item[\"@_Name\"] || \"\",\n            visible: item[\"@_Visible\"] !== false,\n            locked: item[\"@_Locked\"] === true,\n            // FIXED: Store original bounds and transforms without conversion\n            // Unit conversion will be handled later in createElementPositionMapFixed\n            geometricBounds: IDMLUtils.calculateBoundsFromPath(item),\n            itemTransform: IDMLUtils.parseTransform(item[\"@_ItemTransform\"]),\n            itemLayer: item[\"@_ItemLayer\"] || \"\",\n            fillColor: item[\"@_FillColor\"] || \"Color/None\",\n            strokeColor: item[\"@_StrokeColor\"] || \"Color/None\",\n            // FIXED: Only convert stroke weight, not positioning data\n            strokeWeight: this.convertMeasurementToPixels(parseFloat(item[\"@_StrokeWeight\"]) || 0),\n            parentStory: item[\"@_ParentStory\"] || null,\n            // ENHANCED: Better content frame detection\n            isContentFrame: false,\n            hasPlacedContent: false,\n            contentType: null\n        };\n        // ADD: Detect content frames more accurately\n        // ENHANCED: Better embedded image detection\n        if (itemType === \"Rectangle\") {\n            // Check for embedded images more thoroughly\n            const embeddedInfo = this.detectEmbeddedImages(item);\n            if (embeddedInfo.hasEmbeddedContent || embeddedInfo.isPlaceholder) {\n                baseItem.isContentFrame = true;\n                baseItem.hasPlacedContent = embeddedInfo.hasEmbeddedContent;\n                baseItem.contentType = embeddedInfo.embeddedType || \"placeholder\";\n                baseItem.isEmbedded = embeddedInfo.hasEmbeddedContent;\n                baseItem.isPlaceholder = embeddedInfo.isPlaceholder;\n                console.log(`ðŸ“¦ Detected ${embeddedInfo.hasEmbeddedContent ? \"embedded\" : \"placeholder\"} content frame: ${baseItem.self}`);\n            }\n            // Existing content frame detection logic...\n            const hasContent = !!(item.Image || item.PlacedImage || item.EPS || item.PDF || item.Properties?.Image || item.Properties?.PlacedImage);\n            if (hasContent && !baseItem.isContentFrame) {\n                baseItem.isContentFrame = true;\n                baseItem.hasPlacedContent = true;\n                baseItem.contentType = \"Image\";\n                // Extract placed content transform for positioning\n                console.log(\"ITEM:\", JSON.stringify(item, null, 2));\n                const placedContent = item.Image || item.PlacedImage || item.EPS || item.PDF;\n                const linkObject = placedContent && placedContent.Link ? placedContent.Link : null;\n                if (placedContent) {\n                    baseItem.placedContent = this.extractPlacedContent(placedContent, linkObject);\n                }\n                console.log(\"Link object for placed content:\", linkObject);\n                console.log(`ðŸ“¦ Detected external content frame: ${baseItem.self}`);\n            }\n        }\n        // Type-specific processing...\n        switch(itemType){\n            case \"TextFrame\":\n                baseItem.textFramePreferences = this.parseTextFramePreferences(item.TextFramePreference);\n                break;\n            case \"Rectangle\":\n                baseItem.cornerEffects = this.parseCornerEffects(item);\n                break;\n            case \"Group\":\n                baseItem.groupItems = this.extractGroupItems(item);\n                break;\n        }\n        return baseItem;\n    }\n    detectEmbeddedImages(element) {\n        const embeddedIndicators = {\n            hasEmbeddedContent: false,\n            embeddedType: null,\n            embeddedData: null,\n            embeddedFileName: null,\n            isPlaceholder: false\n        };\n        // Check if element name indicates placeholder\n        if (element.name && (element.name.includes(\"[YOUR IMAGE HERE]\") || element.name.includes(\"[IMAGE]\") || element.name.toLowerCase().includes(\"placeholder\"))) {\n            embeddedIndicators.isPlaceholder = true;\n            embeddedIndicators.embeddedType = \"placeholder\";\n        }\n        // ENHANCED: Check for actual embedded image data\n        if (element.placedContent) {\n            const content = element.placedContent;\n            // Check if href looks like an embedded reference\n            if (content.href && content.isEmbedded) {\n                embeddedIndicators.hasEmbeddedContent = true;\n                embeddedIndicators.embeddedType = content.imageTypeName || \"unknown\";\n                embeddedIndicators.embeddedData = content.href;\n                embeddedIndicators.embeddedFileName = `${content.href}.${IDMLUtils.getImageExtension(content.imageTypeName)}`;\n            }\n        }\n        return embeddedIndicators;\n    }\n    parseTextFramePreferences(textFramePreference) {\n        if (!textFramePreference) return null;\n        // FIXED: Convert all text frame measurements to pixels\n        const rawTextColumnGutter = parseFloat(textFramePreference[\"@_TextColumnGutter\"]) || 0;\n        const rawInsetTop = parseFloat(textFramePreference[\"@_InsetSpacing\"]?.split(\" \")[0]) || parseFloat(textFramePreference[\"@_TextInsetTop\"]) || 0;\n        const rawInsetRight = parseFloat(textFramePreference[\"@_InsetSpacing\"]?.split(\" \")[1]) || parseFloat(textFramePreference[\"@_TextInsetRight\"]) || 0;\n        const rawInsetBottom = parseFloat(textFramePreference[\"@_InsetSpacing\"]?.split(\" \")[2]) || parseFloat(textFramePreference[\"@_TextInsetBottom\"]) || 0;\n        const rawInsetLeft = parseFloat(textFramePreference[\"@_InsetSpacing\"]?.split(\" \")[3]) || parseFloat(textFramePreference[\"@_TextInsetLeft\"]) || 0;\n        const rawMinimumFirstBaselineOffset = parseFloat(textFramePreference[\"@_MinimumFirstBaselineOffset\"]) || 0;\n        const preferences = {\n            textColumnCount: parseInt(textFramePreference[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: this.convertMeasurementToPixels(rawTextColumnGutter),\n            firstBaselineOffset: textFramePreference[\"@_FirstBaselineOffset\"] || \"AscentOffset\",\n            autoSizingReferencePoint: textFramePreference[\"@_AutoSizingReferencePoint\"] || \"CenterPoint\",\n            autoSizingType: textFramePreference[\"@_AutoSizingType\"] || \"Off\",\n            verticalJustification: textFramePreference[\"@_VerticalJustification\"] || \"TopAlign\",\n            // FIXED: Convert text frame insets to pixels\n            insetSpacing: {\n                top: this.convertMeasurementToPixels(rawInsetTop),\n                right: this.convertMeasurementToPixels(rawInsetRight),\n                bottom: this.convertMeasurementToPixels(rawInsetBottom),\n                left: this.convertMeasurementToPixels(rawInsetLeft)\n            },\n            // FIXED: Store original values for reference\n            originalInsetSpacing: {\n                top: rawInsetTop,\n                right: rawInsetRight,\n                bottom: rawInsetBottom,\n                left: rawInsetLeft\n            },\n            // FIXED: Convert additional measurements to pixels\n            useMinimumHeight: textFramePreference[\"@_UseMinimumHeight\"] === true,\n            minimumFirstBaselineOffset: this.convertMeasurementToPixels(rawMinimumFirstBaselineOffset),\n            originalMinimumFirstBaselineOffset: rawMinimumFirstBaselineOffset,\n            ignoreWrap: textFramePreference[\"@_IgnoreWrap\"] === true\n        };\n        console.log(`ðŸ“ Converted text frame preferences to pixels:`, {\n            textColumnGutter: `${rawTextColumnGutter} â†’ ${preferences.textColumnGutter}px`,\n            insets: `${rawInsetTop},${rawInsetRight},${rawInsetBottom},${rawInsetLeft} â†’ ${preferences.insetSpacing.top},${preferences.insetSpacing.right},${preferences.insetSpacing.bottom},${preferences.insetSpacing.left}px`\n        });\n        return preferences;\n    }\n    parseCornerEffects(item) {\n        // Parse corner effects for rectangles\n        return {\n            topLeftCornerRadius: parseFloat(item[\"@_TopLeftCornerRadius\"]) || 0,\n            topRightCornerRadius: parseFloat(item[\"@_TopRightCornerRadius\"]) || 0,\n            bottomLeftCornerRadius: parseFloat(item[\"@_BottomLeftCornerRadius\"]) || 0,\n            bottomRightCornerRadius: parseFloat(item[\"@_BottomRightCornerRadius\"]) || 0\n        };\n    }\n    extractGroupItems(groupItem) {\n        const groupItems = [];\n        // Groups can contain other page items\n        const itemTypes = [\n            \"Rectangle\",\n            \"Oval\",\n            \"Polygon\",\n            \"TextFrame\"\n        ];\n        itemTypes.forEach((itemType)=>{\n            if (groupItem[itemType]) {\n                const items = Array.isArray(groupItem[itemType]) ? groupItem[itemType] : [\n                    groupItem[itemType]\n                ];\n                items.forEach((item)=>{\n                    const parsedItem = this.parsePageItem(item, itemType);\n                    if (parsedItem) {\n                        groupItems.push(parsedItem);\n                    }\n                });\n            }\n        });\n        return groupItems;\n    }\n    parseTransparency(transparencySettings) {\n        if (!transparencySettings) return null;\n        return {\n            blendingSettings: transparencySettings.BlendingSetting ? {\n                blendMode: transparencySettings.BlendingSetting[\"@_BlendMode\"] || \"Normal\",\n                opacity: parseFloat(transparencySettings.BlendingSetting[\"@_Opacity\"]) || 100\n            } : null\n        };\n    }\n    createElementPositionMapFixed() {\n        console.log(\"Creating PIXEL-PERFECT element position map...\");\n        console.log(`ðŸ“ Unit conversion status: converter=${!!this.unitConverter}, documentUnits=${this.documentUnits}`);\n        // ENHANCED: Use precise coordinate offset calculation for pixel-perfect positioning\n        const coordinateOffset = IDMLUtils.calculateCoordinateOffsetPrecise(this.elements);\n        console.log(\"\\uD83D\\uDCD0 Calculated PRECISE coordinate offset for pixel-perfect positioning:\", coordinateOffset);\n        this.elements.forEach((element, index)=>{\n            console.log(`ðŸ“ ELEMENT ${index + 1} [${element.type}]: Coordinate transformation`);\n            console.log(`   ðŸ“ Bounds: left=${element.geometricBounds.left}, top=${element.geometricBounds.top}, width=${element.geometricBounds.width}, height=${element.geometricBounds.height}`);\n            console.log(`   ðŸ“ Transform: tx=${element.itemTransform.tx}, ty=${element.itemTransform.ty}`);\n            console.log(`   ðŸ“ Coordinate offset: x=${coordinateOffset.x}, y=${coordinateOffset.y}`);\n            // Apply coordinate system transformation to convert from InDesign to web coordinates\n            const webX = element.geometricBounds.left + element.itemTransform.tx + coordinateOffset.x;\n            const webY = element.geometricBounds.top + element.itemTransform.ty + coordinateOffset.y;\n            console.log(`   ðŸ“ Web coordinates: (${webX}, ${webY}) ${element.geometricBounds.width}x${element.geometricBounds.height}`);\n            // Create position object in original units\n            element.position = {\n                x: webX,\n                y: webY,\n                width: element.geometricBounds.width,\n                height: element.geometricBounds.height,\n                rotation: element.itemTransform.rotation || 0,\n                _conversionInfo: {\n                    unitsConverted: false,\n                    originalUnits: this.documentUnits,\n                    pixelConversionApplied: false,\n                    dpi: this.unitConverter?.dpi || 96,\n                    coordinateOffset: coordinateOffset\n                }\n            };\n            // Apply unit conversion to pixels if converter is available\n            if (this.unitConverter) {\n                console.log(\"   \\uD83D\\uDCD0 Applying unit conversion: Points â†’ pixels\");\n                const pixelX = this.unitConverter.toPixels(webX, this.documentUnits);\n                const pixelY = this.unitConverter.toPixels(webY, this.documentUnits);\n                const pixelWidth = this.unitConverter.toPixels(element.geometricBounds.width, this.documentUnits);\n                const pixelHeight = this.unitConverter.toPixels(element.geometricBounds.height, this.documentUnits);\n                element.pixelPosition = {\n                    x: pixelX,\n                    y: pixelY,\n                    width: pixelWidth,\n                    height: pixelHeight,\n                    rotation: element.itemTransform.rotation || 0,\n                    _isConverted: true,\n                    _originalUnits: this.documentUnits,\n                    _dpi: this.unitConverter.dpi\n                };\n                console.log(`   ðŸ“ CONVERTED TO PIXELS: {\r\n  x: ${pixelX},\r\n  y: ${pixelY},\r\n  width: ${pixelWidth},\r\n  height: ${pixelHeight},\r\n  rotation: ${element.itemTransform.rotation || 0},\r\n  _isConverted: true,\r\n  _originalUnits: '${this.documentUnits}',\r\n  _dpi: ${this.unitConverter.dpi}\r\n}`);\n                // Update original position conversion info\n                element.position._conversionInfo.unitsConverted = true;\n                element.position._conversionInfo.pixelConversionApplied = true;\n            }\n            console.log(`   âœ… FINAL POSITIONS (after coordinate system transformation):`);\n            console.log(`      Original: ${JSON.stringify(element.position, null, 2)}`);\n            if (element.pixelPosition) {\n                console.log(`      Pixels: ${JSON.stringify(element.pixelPosition, null, 2)}`);\n            }\n            // PIXEL-PERFECT VALIDATION\n            this.validatePixelPerfectPositioning(element, index + 1);\n        });\n        console.log(\"âœ… PIXEL-PERFECT positioning map created successfully\");\n    }\n    /**\r\n   * Validate pixel-perfect positioning accuracy\r\n   * @param {Object} element - Element to validate\r\n   * @param {number} elementNumber - Element number for logging\r\n   */ validatePixelPerfectPositioning(element, elementNumber) {\n        console.log(`ðŸ” PIXEL-PERFECT VALIDATION - Element ${elementNumber}:`);\n        const position = element.pixelPosition || element.position;\n        // Check for sub-pixel precision issues\n        const hasSubPixelX = position.x % 1 !== 0;\n        const hasSubPixelY = position.y % 1 !== 0;\n        if (hasSubPixelX || hasSubPixelY) {\n            console.log(`   âš ï¸ Sub-pixel positioning detected:`);\n            if (hasSubPixelX) console.log(`      X: ${position.x} (fractional: ${(position.x % 1).toFixed(3)})`);\n            if (hasSubPixelY) console.log(`      Y: ${position.y} (fractional: ${(position.y % 1).toFixed(3)})`);\n            console.log(`   ðŸ“ Note: Sub-pixel positioning is normal for precise layouts`);\n        } else {\n            console.log(`   âœ… Perfect pixel alignment: X=${position.x}, Y=${position.y}`);\n        }\n        // Check for negative coordinates (should be resolved by offset)\n        if (position.x < 0 || position.y < 0) {\n            console.warn(`   ðŸš¨ NEGATIVE COORDINATES DETECTED: X=${position.x}, Y=${position.y}`);\n            console.warn(`   ðŸš¨ This indicates coordinate offset calculation may need adjustment`);\n        }\n        // Check for reasonable positioning bounds\n        const isReasonable = position.x >= 0 && position.y >= 0 && position.x < 10000 && position.y < 10000;\n        if (!isReasonable) {\n            console.warn(`   ðŸš¨ UNREASONABLE POSITIONING: X=${position.x}, Y=${position.y}`);\n            console.warn(`   ðŸš¨ Coordinates are outside expected range for web display`);\n        } else {\n            console.log(`   âœ… Positioning within reasonable bounds`);\n        }\n        // Validate conversion consistency\n        if (element.pixelPosition && element.position._conversionInfo) {\n            const info = element.position._conversionInfo;\n            console.log(`   ðŸ“Š Conversion validation:`);\n            console.log(`      Units converted: ${info.unitsConverted}`);\n            console.log(`      Original units: ${info.originalUnits}`);\n            console.log(`      DPI: ${info.dpi}`);\n            console.log(`      Coordinate offset applied: X=${info.coordinateOffset.x}, Y=${info.coordinateOffset.y}`);\n        }\n    }\n    extractMasterPages(masterData) {\n        const pages = [];\n        if (masterData.Page) {\n            const pageList = Array.isArray(masterData.Page) ? masterData.Page : [\n                masterData.Page\n            ];\n            pageList.forEach((page)=>{\n                // Extract margin preferences from master page\n                let marginPreference = null;\n                if (page.MarginPreference) {\n                    marginPreference = {\n                        top: parseFloat(page.MarginPreference[\"@_Top\"]) || 0,\n                        bottom: parseFloat(page.MarginPreference[\"@_Bottom\"]) || 0,\n                        left: parseFloat(page.MarginPreference[\"@_Left\"]) || 0,\n                        right: parseFloat(page.MarginPreference[\"@_Right\"]) || 0,\n                        columnCount: parseInt(page.MarginPreference[\"@_ColumnCount\"]) || 1,\n                        columnGutter: parseFloat(page.MarginPreference[\"@_ColumnGutter\"]) || 0,\n                        columnDirection: page.MarginPreference[\"@_ColumnDirection\"] || \"Horizontal\",\n                        columnsPositions: page.MarginPreference[\"@_ColumnsPositions\"] || \"\"\n                    };\n                    console.log(\"\\uD83D\\uDCCF Extracted margin preference from master page:\", marginPreference);\n                }\n                pages.push({\n                    self: page[\"@_Self\"],\n                    name: page[\"@_Name\"] || \"\",\n                    geometricBounds: IDMLUtils.parseGeometricBounds(page[\"@_GeometricBounds\"]),\n                    itemTransform: IDMLUtils.parseTransform(page[\"@_ItemTransform\"]),\n                    appliedMaster: page[\"@_AppliedMaster\"] || \"\",\n                    masterPageTransform: IDMLUtils.parseTransform(page[\"@_MasterPageTransform\"]),\n                    marginPreference: marginPreference\n                });\n            });\n        }\n        return pages;\n    }\n    getElements() {\n        return this.elements;\n    }\n    clearElements() {\n        this.elements = [];\n    }\n    getElementIndex(element) {\n        return this.elements.findIndex((el)=>el.self === element.self);\n    }\n    getPageContent(pageId) {\n        const pageElements = this.elements.filter((element)=>{\n            // Check if element belongs to this page based on its bounds\n            return true; // TODO: Implement proper page boundary checking\n        });\n        return {\n            elements: pageElements\n        };\n    }\n}\nmodule.exports = ElementParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGdCQUFnQnRGLE9BQU8sRUFBRTtRQUN2QixPQUFPLElBQUksQ0FBQ25ILFFBQVEsQ0FBQzBNLFNBQVMsQ0FBQyxDQUFDQyxLQUFPQSxHQUFHekssSUFBSSxLQUFLaUYsUUFBUWpGLElBQUk7SUFDakU7SUFFQTBLLGVBQWVDLE1BQU0sRUFBRTtRQUNyQixNQUFNQyxlQUFlLElBQUksQ0FBQzlNLFFBQVEsQ0FBQytNLE1BQU0sQ0FBQyxDQUFDNUY7WUFDekMsNERBQTREO1lBQzVELE9BQU8sTUFBTSxnREFBZ0Q7UUFDL0Q7UUFFQSxPQUFPO1lBQ0xuSCxVQUFVOE07UUFDWjtJQUNGO0FBQ0Y7QUFFQUUsT0FBT0MsT0FBTyxHQUFHcE4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZG1sLXZpZXdlci8uL2xpYi9wYXJzZXJzL0VsZW1lbnRQYXJzZXIuanM/NWI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9JRE1MVXRpbHNcIik7XHJcblxyXG5jbGFzcyBFbGVtZW50UGFyc2VyIHtcclxuICBjb25zdHJ1Y3Rvcih1bml0Q29udmVydGVyID0gbnVsbCkge1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy51bml0Q29udmVydGVyID0gdW5pdENvbnZlcnRlcjsgLy8gQURERUQ6IFVuaXQgY29udmVydGVyIGZvciBnZW9tZXRyaWMgYm91bmRzXHJcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSBudWxsOyAvLyBXaWxsIGJlIHNldCBieSBEb2N1bWVudFBhcnNlclxyXG4gIH1cclxuXHJcbiAgLy8gQURERUQ6IE1ldGhvZCB0byBzZXQgZG9jdW1lbnQgdW5pdHMgZm9yIGVsZW1lbnQgY29udmVyc2lvblxyXG4gIHNldERvY3VtZW50VW5pdHModW5pdHMpIHtcclxuICAgIHRoaXMuZG9jdW1lbnRVbml0cyA9IHVuaXRzO1xyXG4gICAgY29uc29sZS5sb2coXCLwn5OQIEVsZW1lbnRQYXJzZXI6IFNldCBkb2N1bWVudCB1bml0cyB0b1wiLCB1bml0cyk7XHJcbiAgfVxyXG5cclxuICAvLyBBRERFRDogTWV0aG9kIHRvIGNvbnZlcnQgZ2VvbWV0cmljIGJvdW5kcyBpZiBuZWVkZWRcclxuICBjb252ZXJ0Qm91bmRzVG9QaXhlbHMoYm91bmRzKSB7XHJcbiAgICBpZiAoIWJvdW5kcyB8fCAhdGhpcy51bml0Q29udmVydGVyIHx8ICF0aGlzLmRvY3VtZW50VW5pdHMpIHtcclxuICAgICAgcmV0dXJuIGJvdW5kcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBPbmx5IGNvbnZlcnQgaWYgd2UgaGF2ZSBhIHN1cHBvcnRlZCB1bml0IGFuZCBpdCdzIG5vdCBhbHJlYWR5IHBpeGVsc1xyXG4gICAgaWYgKHRoaXMudW5pdENvbnZlcnRlci5pc1N1cHBvcnRlZFVuaXQodGhpcy5kb2N1bWVudFVuaXRzKSkge1xyXG4gICAgICBjb25zdCBjb252ZXJ0ZWRCb3VuZHMgPSB0aGlzLnVuaXRDb252ZXJ0ZXIuY29udmVydE9iamVjdFRvUGl4ZWxzKFxyXG4gICAgICAgIGJvdW5kcyxcclxuICAgICAgICB0aGlzLmRvY3VtZW50VW5pdHNcclxuICAgICAgKTtcclxuICAgICAgY29uc29sZS5sb2coYPCfk5AgQ29udmVydGVkIGJvdW5kcyBmcm9tICR7dGhpcy5kb2N1bWVudFVuaXRzfSB0byBwaXhlbHM6YCwge1xyXG4gICAgICAgIG9yaWdpbmFsOiBib3VuZHMsXHJcbiAgICAgICAgY29udmVydGVkOiBjb252ZXJ0ZWRCb3VuZHMsXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gY29udmVydGVkQm91bmRzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBib3VuZHM7XHJcbiAgfVxyXG5cclxuICAvLyBBRERFRDogTWV0aG9kIHRvIGNvbnZlcnQgdHJhbnNmb3JtIGNvb3JkaW5hdGVzICh0eCwgdHkpIHRvIHBpeGVsc1xyXG4gIGNvbnZlcnRUcmFuc2Zvcm1Ub1BpeGVscyh0cmFuc2Zvcm0pIHtcclxuICAgIGlmICghdHJhbnNmb3JtIHx8ICF0aGlzLnVuaXRDb252ZXJ0ZXIgfHwgIXRoaXMuZG9jdW1lbnRVbml0cykge1xyXG4gICAgICByZXR1cm4gdHJhbnNmb3JtO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9ubHkgY29udmVydCBpZiB3ZSBoYXZlIGEgc3VwcG9ydGVkIHVuaXQgYW5kIGl0J3Mgbm90IGFscmVhZHkgcGl4ZWxzXHJcbiAgICBpZiAodGhpcy51bml0Q29udmVydGVyLmlzU3VwcG9ydGVkVW5pdCh0aGlzLmRvY3VtZW50VW5pdHMpKSB7XHJcbiAgICAgIC8vIENvbnZlcnQgb25seSB0aGUgdHJhbnNsYXRpb24gdmFsdWVzICh0eCwgdHkpIHRvIHBpeGVsc1xyXG4gICAgICAvLyBLZWVwIHNjYWxlL3JvdGF0aW9uIHZhbHVlcyAoYSwgYiwgYywgZCkgdW5jaGFuZ2VkIGFzIHRoZXkncmUgcmF0aW9zXHJcbiAgICAgIGNvbnN0IGNvbnZlcnRlZFRyYW5zZm9ybSA9IHtcclxuICAgICAgICAuLi50cmFuc2Zvcm0sXHJcbiAgICAgICAgdHg6IHRyYW5zZm9ybS50eFxyXG4gICAgICAgICAgPyB0aGlzLnVuaXRDb252ZXJ0ZXIudG9QaXhlbHModHJhbnNmb3JtLnR4LCB0aGlzLmRvY3VtZW50VW5pdHMpXHJcbiAgICAgICAgICA6IDAsXHJcbiAgICAgICAgdHk6IHRyYW5zZm9ybS50eVxyXG4gICAgICAgICAgPyB0aGlzLnVuaXRDb252ZXJ0ZXIudG9QaXhlbHModHJhbnNmb3JtLnR5LCB0aGlzLmRvY3VtZW50VW5pdHMpXHJcbiAgICAgICAgICA6IDAsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg8J+TkCBDb252ZXJ0ZWQgdHJhbnNmb3JtIGZyb20gJHt0aGlzLmRvY3VtZW50VW5pdHN9IHRvIHBpeGVsczpgLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG9yaWdpbmFsOiB7IHR4OiB0cmFuc2Zvcm0udHgsIHR5OiB0cmFuc2Zvcm0udHkgfSxcclxuICAgICAgICAgIGNvbnZlcnRlZDogeyB0eDogY29udmVydGVkVHJhbnNmb3JtLnR4LCB0eTogY29udmVydGVkVHJhbnNmb3JtLnR5IH0sXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIGNvbnZlcnRlZFRyYW5zZm9ybTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xyXG4gIH1cclxuXHJcbiAgLy8gQURERUQ6IE1ldGhvZCB0byBjb252ZXJ0IHNpbmdsZSBtZWFzdXJlbWVudCB2YWx1ZXMgdG8gcGl4ZWxzXHJcbiAgY29udmVydE1lYXN1cmVtZW50VG9QaXhlbHModmFsdWUpIHtcclxuICAgIGlmIChcclxuICAgICAgdHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8XHJcbiAgICAgIGlzTmFOKHZhbHVlKSB8fFxyXG4gICAgICAhdGhpcy51bml0Q29udmVydGVyIHx8XHJcbiAgICAgICF0aGlzLmRvY3VtZW50VW5pdHNcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25seSBjb252ZXJ0IGlmIHdlIGhhdmUgYSBzdXBwb3J0ZWQgdW5pdCBhbmQgaXQncyBub3QgYWxyZWFkeSBwaXhlbHNcclxuICAgIGlmICh0aGlzLnVuaXRDb252ZXJ0ZXIuaXNTdXBwb3J0ZWRVbml0KHRoaXMuZG9jdW1lbnRVbml0cykpIHtcclxuICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSB0aGlzLnVuaXRDb252ZXJ0ZXIudG9QaXhlbHMoXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFVuaXRzXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDwn5OQIENvbnZlcnRlZCBtZWFzdXJlbWVudDogJHt2YWx1ZX0gJHt0aGlzLmRvY3VtZW50VW5pdHN9IOKGkiAke2NvbnZlcnRlZFZhbHVlfSBweGBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGNvbnZlcnRlZFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RTcHJlYWRQYWdlcyhzcHJlYWREYXRhKSB7XHJcbiAgICBjb25zdCBwYWdlcyA9IFtdO1xyXG5cclxuICAgIGlmIChzcHJlYWREYXRhLlBhZ2UpIHtcclxuICAgICAgY29uc3QgcGFnZUxpc3QgPSBBcnJheS5pc0FycmF5KHNwcmVhZERhdGEuUGFnZSlcclxuICAgICAgICA/IHNwcmVhZERhdGEuUGFnZVxyXG4gICAgICAgIDogW3NwcmVhZERhdGEuUGFnZV07XHJcblxyXG4gICAgICBwYWdlTGlzdC5mb3JFYWNoKChwYWdlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIHBhZ2VzLnB1c2goe1xyXG4gICAgICAgICAgc2VsZjogcGFnZVtcIkBfU2VsZlwiXSxcclxuICAgICAgICAgIG5hbWU6IHBhZ2VbXCJAX05hbWVcIl0gfHwgXCJcIixcclxuICAgICAgICAgIGFwcGxpZWRNYXN0ZXI6IHBhZ2VbXCJAX0FwcGxpZWRNYXN0ZXJcIl0gfHwgXCJcIixcclxuICAgICAgICAgIGdlb21ldHJpY0JvdW5kczogSURNTFV0aWxzLnBhcnNlR2VvbWV0cmljQm91bmRzKFxyXG4gICAgICAgICAgICBwYWdlW1wiQF9HZW9tZXRyaWNCb3VuZHNcIl1cclxuICAgICAgICAgICksXHJcbiAgICAgICAgICBpdGVtVHJhbnNmb3JtOiBJRE1MVXRpbHMucGFyc2VUcmFuc2Zvcm0ocGFnZVtcIkBfSXRlbVRyYW5zZm9ybVwiXSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coXCJObyBwYWdlcyBmb3VuZCBpbiBzcHJlYWQgZGF0YVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGVkICR7cGFnZXMubGVuZ3RofSBwYWdlc2ApO1xyXG4gICAgcmV0dXJuIHBhZ2VzO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBhZ2VJdGVtcyhzcHJlYWREYXRhKSB7XHJcbiAgICBjb25zdCBwYWdlSXRlbXMgPSBbXTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IGRpZmZlcmVudCB0eXBlcyBvZiBwYWdlIGl0ZW1zXHJcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBbXHJcbiAgICAgIFwiUmVjdGFuZ2xlXCIsXHJcbiAgICAgIFwiT3ZhbFwiLFxyXG4gICAgICBcIlBvbHlnb25cIixcclxuICAgICAgXCJHcmFwaGljTGluZVwiLFxyXG4gICAgICBcIlRleHRGcmFtZVwiLFxyXG4gICAgICBcIkdyb3VwXCIsXHJcbiAgICAgIFwiQnV0dG9uXCIsXHJcbiAgICAgIFwiVGFibGVcIixcclxuICAgICAgXCJJbWFnZVwiLFxyXG4gICAgICBcIkVQU1wiLFxyXG4gICAgICBcIlBERlwiLFxyXG4gICAgICBcIlBsYWNlZEl0ZW1cIixcclxuICAgICAgXCJDb250ZW50RnJhbWVcIiwgLy8gQWRkIHRoZXNlXHJcbiAgICBdO1xyXG5cclxuICAgIGl0ZW1UeXBlcy5mb3JFYWNoKChpdGVtVHlwZSkgPT4ge1xyXG4gICAgICBpZiAoc3ByZWFkRGF0YVtpdGVtVHlwZV0pIHtcclxuICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmlzQXJyYXkoc3ByZWFkRGF0YVtpdGVtVHlwZV0pXHJcbiAgICAgICAgICA/IHNwcmVhZERhdGFbaXRlbVR5cGVdXHJcbiAgICAgICAgICA6IFtzcHJlYWREYXRhW2l0ZW1UeXBlXV07XHJcblxyXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nICR7aXRlbVR5cGV9OmAsIGl0ZW1bXCJAX1NlbGZcIl0pO1xyXG4gICAgICAgICAgY29uc3QgcGFnZUl0ZW0gPSB0aGlzLnBhcnNlUGFnZUl0ZW0oaXRlbSwgaXRlbVR5cGUpO1xyXG4gICAgICAgICAgaWYgKHBhZ2VJdGVtKSB7XHJcbiAgICAgICAgICAgIHBhZ2VJdGVtcy5wdXNoKHBhZ2VJdGVtKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKHBhZ2VJdGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5jaGVja0Zvck5lc3RlZENvbnRlbnQoc3ByZWFkRGF0YSwgcGFnZUl0ZW1zKTtcclxuXHJcbiAgICAvLyBBTFNPIENIRUNLIEZPUiBORVNURUQgSVRFTVMgSU4gUEFHRVNcclxuICAgIGlmIChzcHJlYWREYXRhLlBhZ2UpIHtcclxuICAgICAgY29uc3QgcGFnZXMgPSBBcnJheS5pc0FycmF5KHNwcmVhZERhdGEuUGFnZSlcclxuICAgICAgICA/IHNwcmVhZERhdGEuUGFnZVxyXG4gICAgICAgIDogW3NwcmVhZERhdGEuUGFnZV07XHJcbiAgICAgIHBhZ2VzLmZvckVhY2goKHBhZ2UpID0+IHtcclxuICAgICAgICBpdGVtVHlwZXMuZm9yRWFjaCgoaXRlbVR5cGUpID0+IHtcclxuICAgICAgICAgIGlmIChwYWdlW2l0ZW1UeXBlXSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICBgRm91bmQgJHtpdGVtVHlwZX0gaW4gcGFnZTpgLFxyXG4gICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFnZVtpdGVtVHlwZV0pID8gcGFnZVtpdGVtVHlwZV0ubGVuZ3RoIDogMVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmlzQXJyYXkocGFnZVtpdGVtVHlwZV0pXHJcbiAgICAgICAgICAgICAgPyBwYWdlW2l0ZW1UeXBlXVxyXG4gICAgICAgICAgICAgIDogW3BhZ2VbaXRlbVR5cGVdXTtcclxuXHJcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBwYWdlSXRlbSA9IHRoaXMucGFyc2VQYWdlSXRlbShpdGVtLCBpdGVtVHlwZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHBhZ2VJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBwYWdlSXRlbXMucHVzaChwYWdlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2gocGFnZUl0ZW0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBUb3RhbCBwYWdlIGl0ZW1zIGV4dHJhY3RlZDogJHtwYWdlSXRlbXMubGVuZ3RofWApO1xyXG4gICAgcmV0dXJuIHBhZ2VJdGVtcztcclxuICB9XHJcblxyXG4gIGNoZWNrRm9yTmVzdGVkQ29udGVudChzcHJlYWREYXRhLCBwYWdlSXRlbXMpIHtcclxuICAgIGNvbnNvbGUubG9nKFwi8J+UjSBDaGVja2luZyBmb3IgbmVzdGVkIGNvbnRlbnQgaW4gZWxlbWVudHMuLi5cIik7XHJcblxyXG4gICAgLy8gQ2hlY2sgcmVjdGFuZ2xlcyBmb3IgcGxhY2VkIGltYWdlc1xyXG4gICAgaWYgKHNwcmVhZERhdGEuUmVjdGFuZ2xlKSB7XHJcbiAgICAgIGNvbnN0IHJlY3RhbmdsZXMgPSBBcnJheS5pc0FycmF5KHNwcmVhZERhdGEuUmVjdGFuZ2xlKVxyXG4gICAgICAgID8gc3ByZWFkRGF0YS5SZWN0YW5nbGVcclxuICAgICAgICA6IFtzcHJlYWREYXRhLlJlY3RhbmdsZV07XHJcblxyXG4gICAgICByZWN0YW5nbGVzLmZvckVhY2goKHJlY3QpID0+IHtcclxuICAgICAgICAvLyBMb29rIGZvciBBTlkgY29udGVudCBpbnNpZGUgcmVjdGFuZ2xlIC0gYmUgbW9yZSBhZ2dyZXNzaXZlXHJcbiAgICAgICAgY29uc3QgcG9zc2libGVDb250ZW50ID1cclxuICAgICAgICAgIHJlY3QuSW1hZ2UgfHxcclxuICAgICAgICAgIHJlY3QuUGxhY2VkSW1hZ2UgfHxcclxuICAgICAgICAgIHJlY3QuRVBTIHx8XHJcbiAgICAgICAgICByZWN0LlBERiB8fFxyXG4gICAgICAgICAgcmVjdC5Qcm9wZXJ0aWVzPy5JbWFnZSB8fFxyXG4gICAgICAgICAgcmVjdC5Qcm9wZXJ0aWVzPy5QbGFjZWRJbWFnZSB8fFxyXG4gICAgICAgICAgcmVjdC5MaW5rIHx8XHJcbiAgICAgICAgICByZWN0LlByb3BlcnRpZXM/Lkxpbms7XHJcblxyXG4gICAgICAgIGlmIChwb3NzaWJsZUNvbnRlbnQpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBg8J+TtyBGb3VuZCBwbGFjZWQgY29udGVudCBpbiByZWN0YW5nbGUgJHtyZWN0W1wiQF9TZWxmXCJdfTpgLFxyXG4gICAgICAgICAgICBwb3NzaWJsZUNvbnRlbnRcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSByZWN0YW5nbGUgdG8gaW5kaWNhdGUgaXQncyBhIGNvbnRlbnQgZnJhbWVcclxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUmVjdCA9IHBhZ2VJdGVtcy5maW5kKFxyXG4gICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5zZWxmID09PSByZWN0W1wiQF9TZWxmXCJdXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgaWYgKGV4aXN0aW5nUmVjdCkge1xyXG4gICAgICAgICAgICBleGlzdGluZ1JlY3QuaGFzUGxhY2VkQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nUmVjdC5jb250ZW50VHlwZSA9IFwiSW1hZ2VcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgc2V0IHBsYWNlZENvbnRlbnQgaWYgbm90IGFscmVhZHkgc2V0XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdSZWN0LnBsYWNlZENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXN0ZWRMaW5rID0gcG9zc2libGVDb250ZW50LkxpbmsgfHwgbnVsbDtcclxuICAgICAgICAgICAgICBleGlzdGluZ1JlY3QucGxhY2VkQ29udGVudCA9IHRoaXMuZXh0cmFjdFBsYWNlZENvbnRlbnQoXHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICBuZXN0ZWRMaW5rXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBDYWxjdWxhdGUgdGhlIGltYWdlIHBvc2l0aW9uIHdpdGhpbiB0aGUgZnJhbWVcclxuICAgICAgICAgICAgZXhpc3RpbmdSZWN0LmltYWdlUG9zaXRpb24gPVxyXG4gICAgICAgICAgICAgIElETUxVdGlscy5jYWxjdWxhdGVJbWFnZVBvc2l0aW9uSW5GcmFtZShcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVjdC5nZW9tZXRyaWNCb3VuZHMsXHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ1JlY3QuaXRlbVRyYW5zZm9ybSxcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVjdC5wbGFjZWRDb250ZW50XHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBsYWNlZENvbnRlbnQoY29udGVudCwgbGlua09iamVjdCkge1xyXG4gICAgaWYgKCFjb250ZW50KSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIvCflI0gRXh0cmFjdGluZyBwbGFjZWQgY29udGVudDpcIiwgY29udGVudCk7XHJcblxyXG4gICAgY29uc3QgY29udGVudEl0ZW0gPSBBcnJheS5pc0FycmF5KGNvbnRlbnQpID8gY29udGVudFswXSA6IGNvbnRlbnQ7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJDb250ZW50IGl0ZW0ga2V5czpcIiwgT2JqZWN0LmtleXMoY29udGVudEl0ZW0pKTtcclxuXHJcbiAgICAvLyBFTkhBTkNFRDogQmV0dGVyIGhyZWYgaGFuZGxpbmcgdXNpbmcgTGluayBvYmplY3RcclxuICAgIGxldCBocmVmID0gXCJcIjtcclxuICAgIGlmIChsaW5rT2JqZWN0ICYmIGxpbmtPYmplY3RbXCJAX0xpbmtSZXNvdXJjZVVSSVwiXSkge1xyXG4gICAgICAvLyBSZW1vdmUgJ2ZpbGU6JyBwcmVmaXggYW5kIGV4dHJhY3QganVzdCB0aGUgZmlsZW5hbWVcclxuICAgICAgY29uc3QgdXJpID0gbGlua09iamVjdFtcIkBfTGlua1Jlc291cmNlVVJJXCJdO1xyXG4gICAgICBocmVmID0gdXJpXHJcbiAgICAgICAgLnJlcGxhY2UoL15maWxlOi8sIFwiXCIpXHJcbiAgICAgICAgLnNwbGl0KC9bXFxcXC9dLylcclxuICAgICAgICAucG9wKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBocmVmID0gY29udGVudEl0ZW1bXCJAX2hyZWZcIl0gfHwgY29udGVudEl0ZW1bXCJAX0FjdHVhbFBwaVwiXSB8fCBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpc0VtYmVkZGVkID0gZmFsc2U7XHJcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGVtYmVkZGVkIGltYWdlIHJlZmVyZW5jZVxyXG4gICAgaWYgKGhyZWYgJiYgIWhyZWYuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikgJiYgIWhyZWYuaW5jbHVkZXMoXCIvXCIpKSB7XHJcbiAgICAgIGlzRW1iZWRkZWQgPSB0cnVlO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCflrzvuI8gRGV0ZWN0ZWQgZW1iZWRkZWQgaW1hZ2UgcmVmZXJlbmNlOlwiLCBocmVmKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlJldHVybmluZyBwbGFjZWRDb250ZW50OlwiLCB7IGhyZWYsIGxpbmtPYmplY3QgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogY29udGVudEl0ZW1bXCJAX3R5cGVcIl0gfHwgXCJJbWFnZVwiLFxyXG4gICAgICBocmVmOiBocmVmLFxyXG4gICAgICBpc0VtYmVkZGVkOiBpc0VtYmVkZGVkLFxyXG4gICAgICBib3VuZHM6IGNvbnRlbnRJdGVtW1wiQF9HZW9tZXRyaWNCb3VuZHNcIl1cclxuICAgICAgICA/IElETUxVdGlscy5wYXJzZUdlb21ldHJpY0JvdW5kcyhjb250ZW50SXRlbVtcIkBfR2VvbWV0cmljQm91bmRzXCJdKVxyXG4gICAgICAgIDogbnVsbCxcclxuICAgICAgdHJhbnNmb3JtOiBjb250ZW50SXRlbVtcIkBfSXRlbVRyYW5zZm9ybVwiXVxyXG4gICAgICAgID8gSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKGNvbnRlbnRJdGVtW1wiQF9JdGVtVHJhbnNmb3JtXCJdKVxyXG4gICAgICAgIDogbnVsbCxcclxuICAgICAgYWN0dWFsUHBpOiBjb250ZW50SXRlbVtcIkBfQWN0dWFsUHBpXCJdLFxyXG4gICAgICBlZmZlY3RpdmVQcGk6IGNvbnRlbnRJdGVtW1wiQF9FZmZlY3RpdmVQcGlcIl0sXHJcbiAgICAgIGltYWdlVHlwZU5hbWU6IGNvbnRlbnRJdGVtW1wiQF9JbWFnZVR5cGVOYW1lXCJdLFxyXG4gICAgICBzcGFjZTogY29udGVudEl0ZW1bXCJAX1NwYWNlXCJdLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHBhcnNlUGFnZUl0ZW0oaXRlbSwgaXRlbVR5cGUpIHtcclxuICAgIC8vIEFERDogVmFsaWRhdGlvblxyXG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtW1wiQF9TZWxmXCJdKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCAke2l0ZW1UeXBlfSBpdGVtIC0gbWlzc2luZyBzZWxmIElEYCk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJhc2VJdGVtID0ge1xyXG4gICAgICB0eXBlOiBpdGVtVHlwZSxcclxuICAgICAgc2VsZjogaXRlbVtcIkBfU2VsZlwiXSxcclxuICAgICAgbmFtZTogaXRlbVtcIkBfTmFtZVwiXSB8fCBcIlwiLFxyXG4gICAgICB2aXNpYmxlOiBpdGVtW1wiQF9WaXNpYmxlXCJdICE9PSBmYWxzZSxcclxuICAgICAgbG9ja2VkOiBpdGVtW1wiQF9Mb2NrZWRcIl0gPT09IHRydWUsXHJcblxyXG4gICAgICAvLyBGSVhFRDogU3RvcmUgb3JpZ2luYWwgYm91bmRzIGFuZCB0cmFuc2Zvcm1zIHdpdGhvdXQgY29udmVyc2lvblxyXG4gICAgICAvLyBVbml0IGNvbnZlcnNpb24gd2lsbCBiZSBoYW5kbGVkIGxhdGVyIGluIGNyZWF0ZUVsZW1lbnRQb3NpdGlvbk1hcEZpeGVkXHJcbiAgICAgIGdlb21ldHJpY0JvdW5kczogSURNTFV0aWxzLmNhbGN1bGF0ZUJvdW5kc0Zyb21QYXRoKGl0ZW0pLFxyXG4gICAgICBpdGVtVHJhbnNmb3JtOiBJRE1MVXRpbHMucGFyc2VUcmFuc2Zvcm0oaXRlbVtcIkBfSXRlbVRyYW5zZm9ybVwiXSksXHJcblxyXG4gICAgICBpdGVtTGF5ZXI6IGl0ZW1bXCJAX0l0ZW1MYXllclwiXSB8fCBcIlwiLFxyXG4gICAgICBmaWxsQ29sb3I6IGl0ZW1bXCJAX0ZpbGxDb2xvclwiXSB8fCBcIkNvbG9yL05vbmVcIixcclxuICAgICAgc3Ryb2tlQ29sb3I6IGl0ZW1bXCJAX1N0cm9rZUNvbG9yXCJdIHx8IFwiQ29sb3IvTm9uZVwiLFxyXG4gICAgICAvLyBGSVhFRDogT25seSBjb252ZXJ0IHN0cm9rZSB3ZWlnaHQsIG5vdCBwb3NpdGlvbmluZyBkYXRhXHJcbiAgICAgIHN0cm9rZVdlaWdodDogdGhpcy5jb252ZXJ0TWVhc3VyZW1lbnRUb1BpeGVscyhcclxuICAgICAgICBwYXJzZUZsb2F0KGl0ZW1bXCJAX1N0cm9rZVdlaWdodFwiXSkgfHwgMFxyXG4gICAgICApLFxyXG5cclxuICAgICAgcGFyZW50U3Rvcnk6IGl0ZW1bXCJAX1BhcmVudFN0b3J5XCJdIHx8IG51bGwsXHJcblxyXG4gICAgICAvLyBFTkhBTkNFRDogQmV0dGVyIGNvbnRlbnQgZnJhbWUgZGV0ZWN0aW9uXHJcbiAgICAgIGlzQ29udGVudEZyYW1lOiBmYWxzZSxcclxuICAgICAgaGFzUGxhY2VkQ29udGVudDogZmFsc2UsXHJcbiAgICAgIGNvbnRlbnRUeXBlOiBudWxsLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBREQ6IERldGVjdCBjb250ZW50IGZyYW1lcyBtb3JlIGFjY3VyYXRlbHlcclxuICAgIC8vIEVOSEFOQ0VEOiBCZXR0ZXIgZW1iZWRkZWQgaW1hZ2UgZGV0ZWN0aW9uXHJcbiAgICBpZiAoaXRlbVR5cGUgPT09IFwiUmVjdGFuZ2xlXCIpIHtcclxuICAgICAgLy8gQ2hlY2sgZm9yIGVtYmVkZGVkIGltYWdlcyBtb3JlIHRob3JvdWdobHlcclxuICAgICAgY29uc3QgZW1iZWRkZWRJbmZvID0gdGhpcy5kZXRlY3RFbWJlZGRlZEltYWdlcyhpdGVtKTtcclxuXHJcbiAgICAgIGlmIChlbWJlZGRlZEluZm8uaGFzRW1iZWRkZWRDb250ZW50IHx8IGVtYmVkZGVkSW5mby5pc1BsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgYmFzZUl0ZW0uaXNDb250ZW50RnJhbWUgPSB0cnVlO1xyXG4gICAgICAgIGJhc2VJdGVtLmhhc1BsYWNlZENvbnRlbnQgPSBlbWJlZGRlZEluZm8uaGFzRW1iZWRkZWRDb250ZW50O1xyXG4gICAgICAgIGJhc2VJdGVtLmNvbnRlbnRUeXBlID0gZW1iZWRkZWRJbmZvLmVtYmVkZGVkVHlwZSB8fCBcInBsYWNlaG9sZGVyXCI7XHJcbiAgICAgICAgYmFzZUl0ZW0uaXNFbWJlZGRlZCA9IGVtYmVkZGVkSW5mby5oYXNFbWJlZGRlZENvbnRlbnQ7XHJcbiAgICAgICAgYmFzZUl0ZW0uaXNQbGFjZWhvbGRlciA9IGVtYmVkZGVkSW5mby5pc1BsYWNlaG9sZGVyO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDwn5OmIERldGVjdGVkICR7XHJcbiAgICAgICAgICAgIGVtYmVkZGVkSW5mby5oYXNFbWJlZGRlZENvbnRlbnQgPyBcImVtYmVkZGVkXCIgOiBcInBsYWNlaG9sZGVyXCJcclxuICAgICAgICAgIH0gY29udGVudCBmcmFtZTogJHtiYXNlSXRlbS5zZWxmfWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFeGlzdGluZyBjb250ZW50IGZyYW1lIGRldGVjdGlvbiBsb2dpYy4uLlxyXG4gICAgICBjb25zdCBoYXNDb250ZW50ID0gISEoXHJcbiAgICAgICAgaXRlbS5JbWFnZSB8fFxyXG4gICAgICAgIGl0ZW0uUGxhY2VkSW1hZ2UgfHxcclxuICAgICAgICBpdGVtLkVQUyB8fFxyXG4gICAgICAgIGl0ZW0uUERGIHx8XHJcbiAgICAgICAgaXRlbS5Qcm9wZXJ0aWVzPy5JbWFnZSB8fFxyXG4gICAgICAgIGl0ZW0uUHJvcGVydGllcz8uUGxhY2VkSW1hZ2VcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChoYXNDb250ZW50ICYmICFiYXNlSXRlbS5pc0NvbnRlbnRGcmFtZSkge1xyXG4gICAgICAgIGJhc2VJdGVtLmlzQ29udGVudEZyYW1lID0gdHJ1ZTtcclxuICAgICAgICBiYXNlSXRlbS5oYXNQbGFjZWRDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICBiYXNlSXRlbS5jb250ZW50VHlwZSA9IFwiSW1hZ2VcIjtcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBwbGFjZWQgY29udGVudCB0cmFuc2Zvcm0gZm9yIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJJVEVNOlwiLCBKU09OLnN0cmluZ2lmeShpdGVtLCBudWxsLCAyKSk7XHJcbiAgICAgICAgY29uc3QgcGxhY2VkQ29udGVudCA9XHJcbiAgICAgICAgICBpdGVtLkltYWdlIHx8IGl0ZW0uUGxhY2VkSW1hZ2UgfHwgaXRlbS5FUFMgfHwgaXRlbS5QREY7XHJcbiAgICAgICAgY29uc3QgbGlua09iamVjdCA9XHJcbiAgICAgICAgICBwbGFjZWRDb250ZW50ICYmIHBsYWNlZENvbnRlbnQuTGluayA/IHBsYWNlZENvbnRlbnQuTGluayA6IG51bGw7XHJcbiAgICAgICAgaWYgKHBsYWNlZENvbnRlbnQpIHtcclxuICAgICAgICAgIGJhc2VJdGVtLnBsYWNlZENvbnRlbnQgPSB0aGlzLmV4dHJhY3RQbGFjZWRDb250ZW50KFxyXG4gICAgICAgICAgICBwbGFjZWRDb250ZW50LFxyXG4gICAgICAgICAgICBsaW5rT2JqZWN0XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhcIkxpbmsgb2JqZWN0IGZvciBwbGFjZWQgY29udGVudDpcIiwgbGlua09iamVjdCk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OmIERldGVjdGVkIGV4dGVybmFsIGNvbnRlbnQgZnJhbWU6ICR7YmFzZUl0ZW0uc2VsZn1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFR5cGUtc3BlY2lmaWMgcHJvY2Vzc2luZy4uLlxyXG4gICAgc3dpdGNoIChpdGVtVHlwZSkge1xyXG4gICAgICBjYXNlIFwiVGV4dEZyYW1lXCI6XHJcbiAgICAgICAgYmFzZUl0ZW0udGV4dEZyYW1lUHJlZmVyZW5jZXMgPSB0aGlzLnBhcnNlVGV4dEZyYW1lUHJlZmVyZW5jZXMoXHJcbiAgICAgICAgICBpdGVtLlRleHRGcmFtZVByZWZlcmVuY2VcclxuICAgICAgICApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiUmVjdGFuZ2xlXCI6XHJcbiAgICAgICAgYmFzZUl0ZW0uY29ybmVyRWZmZWN0cyA9IHRoaXMucGFyc2VDb3JuZXJFZmZlY3RzKGl0ZW0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiR3JvdXBcIjpcclxuICAgICAgICBiYXNlSXRlbS5ncm91cEl0ZW1zID0gdGhpcy5leHRyYWN0R3JvdXBJdGVtcyhpdGVtKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYmFzZUl0ZW07XHJcbiAgfVxyXG5cclxuICBkZXRlY3RFbWJlZGRlZEltYWdlcyhlbGVtZW50KSB7XHJcbiAgICBjb25zdCBlbWJlZGRlZEluZGljYXRvcnMgPSB7XHJcbiAgICAgIGhhc0VtYmVkZGVkQ29udGVudDogZmFsc2UsXHJcbiAgICAgIGVtYmVkZGVkVHlwZTogbnVsbCxcclxuICAgICAgZW1iZWRkZWREYXRhOiBudWxsLFxyXG4gICAgICBlbWJlZGRlZEZpbGVOYW1lOiBudWxsLCAvLyBBREQgVEhJU1xyXG4gICAgICBpc1BsYWNlaG9sZGVyOiBmYWxzZSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBuYW1lIGluZGljYXRlcyBwbGFjZWhvbGRlclxyXG4gICAgaWYgKFxyXG4gICAgICBlbGVtZW50Lm5hbWUgJiZcclxuICAgICAgKGVsZW1lbnQubmFtZS5pbmNsdWRlcyhcIltZT1VSIElNQUdFIEhFUkVdXCIpIHx8XHJcbiAgICAgICAgZWxlbWVudC5uYW1lLmluY2x1ZGVzKFwiW0lNQUdFXVwiKSB8fFxyXG4gICAgICAgIGVsZW1lbnQubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicGxhY2Vob2xkZXJcIikpXHJcbiAgICApIHtcclxuICAgICAgZW1iZWRkZWRJbmRpY2F0b3JzLmlzUGxhY2Vob2xkZXIgPSB0cnVlO1xyXG4gICAgICBlbWJlZGRlZEluZGljYXRvcnMuZW1iZWRkZWRUeXBlID0gXCJwbGFjZWhvbGRlclwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVOSEFOQ0VEOiBDaGVjayBmb3IgYWN0dWFsIGVtYmVkZGVkIGltYWdlIGRhdGFcclxuICAgIGlmIChlbGVtZW50LnBsYWNlZENvbnRlbnQpIHtcclxuICAgICAgY29uc3QgY29udGVudCA9IGVsZW1lbnQucGxhY2VkQ29udGVudDtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGhyZWYgbG9va3MgbGlrZSBhbiBlbWJlZGRlZCByZWZlcmVuY2VcclxuICAgICAgaWYgKGNvbnRlbnQuaHJlZiAmJiBjb250ZW50LmlzRW1iZWRkZWQpIHtcclxuICAgICAgICBlbWJlZGRlZEluZGljYXRvcnMuaGFzRW1iZWRkZWRDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICBlbWJlZGRlZEluZGljYXRvcnMuZW1iZWRkZWRUeXBlID0gY29udGVudC5pbWFnZVR5cGVOYW1lIHx8IFwidW5rbm93blwiO1xyXG4gICAgICAgIGVtYmVkZGVkSW5kaWNhdG9ycy5lbWJlZGRlZERhdGEgPSBjb250ZW50LmhyZWY7XHJcbiAgICAgICAgZW1iZWRkZWRJbmRpY2F0b3JzLmVtYmVkZGVkRmlsZU5hbWUgPSBgJHtcclxuICAgICAgICAgIGNvbnRlbnQuaHJlZlxyXG4gICAgICAgIH0uJHtJRE1MVXRpbHMuZ2V0SW1hZ2VFeHRlbnNpb24oY29udGVudC5pbWFnZVR5cGVOYW1lKX1gO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVtYmVkZGVkSW5kaWNhdG9ycztcclxuICB9XHJcblxyXG4gIHBhcnNlVGV4dEZyYW1lUHJlZmVyZW5jZXModGV4dEZyYW1lUHJlZmVyZW5jZSkge1xyXG4gICAgaWYgKCF0ZXh0RnJhbWVQcmVmZXJlbmNlKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAvLyBGSVhFRDogQ29udmVydCBhbGwgdGV4dCBmcmFtZSBtZWFzdXJlbWVudHMgdG8gcGl4ZWxzXHJcbiAgICBjb25zdCByYXdUZXh0Q29sdW1uR3V0dGVyID1cclxuICAgICAgcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlW1wiQF9UZXh0Q29sdW1uR3V0dGVyXCJdKSB8fCAwO1xyXG4gICAgY29uc3QgcmF3SW5zZXRUb3AgPVxyXG4gICAgICBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbXCJAX0luc2V0U3BhY2luZ1wiXT8uc3BsaXQoXCIgXCIpWzBdKSB8fFxyXG4gICAgICBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbXCJAX1RleHRJbnNldFRvcFwiXSkgfHxcclxuICAgICAgMDtcclxuICAgIGNvbnN0IHJhd0luc2V0UmlnaHQgPVxyXG4gICAgICBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbXCJAX0luc2V0U3BhY2luZ1wiXT8uc3BsaXQoXCIgXCIpWzFdKSB8fFxyXG4gICAgICBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbXCJAX1RleHRJbnNldFJpZ2h0XCJdKSB8fFxyXG4gICAgICAwO1xyXG4gICAgY29uc3QgcmF3SW5zZXRCb3R0b20gPVxyXG4gICAgICBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbXCJAX0luc2V0U3BhY2luZ1wiXT8uc3BsaXQoXCIgXCIpWzJdKSB8fFxyXG4gICAgICBwYXJzZUZsb2F0KHRleHRGcmFtZVByZWZlcmVuY2VbXCJAX1RleHRJbnNldEJvdHRvbVwiXSkgfHxcclxuICAgICAgMDtcclxuICAgIGNvbnN0IHJhd0luc2V0TGVmdCA9XHJcbiAgICAgIHBhcnNlRmxvYXQodGV4dEZyYW1lUHJlZmVyZW5jZVtcIkBfSW5zZXRTcGFjaW5nXCJdPy5zcGxpdChcIiBcIilbM10pIHx8XHJcbiAgICAgIHBhcnNlRmxvYXQodGV4dEZyYW1lUHJlZmVyZW5jZVtcIkBfVGV4dEluc2V0TGVmdFwiXSkgfHxcclxuICAgICAgMDtcclxuICAgIGNvbnN0IHJhd01pbmltdW1GaXJzdEJhc2VsaW5lT2Zmc2V0ID1cclxuICAgICAgcGFyc2VGbG9hdCh0ZXh0RnJhbWVQcmVmZXJlbmNlW1wiQF9NaW5pbXVtRmlyc3RCYXNlbGluZU9mZnNldFwiXSkgfHwgMDtcclxuXHJcbiAgICBjb25zdCBwcmVmZXJlbmNlcyA9IHtcclxuICAgICAgdGV4dENvbHVtbkNvdW50OiBwYXJzZUludCh0ZXh0RnJhbWVQcmVmZXJlbmNlW1wiQF9UZXh0Q29sdW1uQ291bnRcIl0pIHx8IDEsXHJcbiAgICAgIHRleHRDb2x1bW5HdXR0ZXI6IHRoaXMuY29udmVydE1lYXN1cmVtZW50VG9QaXhlbHMocmF3VGV4dENvbHVtbkd1dHRlciksXHJcbiAgICAgIGZpcnN0QmFzZWxpbmVPZmZzZXQ6XHJcbiAgICAgICAgdGV4dEZyYW1lUHJlZmVyZW5jZVtcIkBfRmlyc3RCYXNlbGluZU9mZnNldFwiXSB8fCBcIkFzY2VudE9mZnNldFwiLFxyXG4gICAgICBhdXRvU2l6aW5nUmVmZXJlbmNlUG9pbnQ6XHJcbiAgICAgICAgdGV4dEZyYW1lUHJlZmVyZW5jZVtcIkBfQXV0b1NpemluZ1JlZmVyZW5jZVBvaW50XCJdIHx8IFwiQ2VudGVyUG9pbnRcIixcclxuICAgICAgYXV0b1NpemluZ1R5cGU6IHRleHRGcmFtZVByZWZlcmVuY2VbXCJAX0F1dG9TaXppbmdUeXBlXCJdIHx8IFwiT2ZmXCIsXHJcbiAgICAgIHZlcnRpY2FsSnVzdGlmaWNhdGlvbjpcclxuICAgICAgICB0ZXh0RnJhbWVQcmVmZXJlbmNlW1wiQF9WZXJ0aWNhbEp1c3RpZmljYXRpb25cIl0gfHwgXCJUb3BBbGlnblwiLFxyXG5cclxuICAgICAgLy8gRklYRUQ6IENvbnZlcnQgdGV4dCBmcmFtZSBpbnNldHMgdG8gcGl4ZWxzXHJcbiAgICAgIGluc2V0U3BhY2luZzoge1xyXG4gICAgICAgIHRvcDogdGhpcy5jb252ZXJ0TWVhc3VyZW1lbnRUb1BpeGVscyhyYXdJbnNldFRvcCksXHJcbiAgICAgICAgcmlnaHQ6IHRoaXMuY29udmVydE1lYXN1cmVtZW50VG9QaXhlbHMocmF3SW5zZXRSaWdodCksXHJcbiAgICAgICAgYm90dG9tOiB0aGlzLmNvbnZlcnRNZWFzdXJlbWVudFRvUGl4ZWxzKHJhd0luc2V0Qm90dG9tKSxcclxuICAgICAgICBsZWZ0OiB0aGlzLmNvbnZlcnRNZWFzdXJlbWVudFRvUGl4ZWxzKHJhd0luc2V0TGVmdCksXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBGSVhFRDogU3RvcmUgb3JpZ2luYWwgdmFsdWVzIGZvciByZWZlcmVuY2VcclxuICAgICAgb3JpZ2luYWxJbnNldFNwYWNpbmc6IHtcclxuICAgICAgICB0b3A6IHJhd0luc2V0VG9wLFxyXG4gICAgICAgIHJpZ2h0OiByYXdJbnNldFJpZ2h0LFxyXG4gICAgICAgIGJvdHRvbTogcmF3SW5zZXRCb3R0b20sXHJcbiAgICAgICAgbGVmdDogcmF3SW5zZXRMZWZ0LFxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gRklYRUQ6IENvbnZlcnQgYWRkaXRpb25hbCBtZWFzdXJlbWVudHMgdG8gcGl4ZWxzXHJcbiAgICAgIHVzZU1pbmltdW1IZWlnaHQ6IHRleHRGcmFtZVByZWZlcmVuY2VbXCJAX1VzZU1pbmltdW1IZWlnaHRcIl0gPT09IHRydWUsXHJcbiAgICAgIG1pbmltdW1GaXJzdEJhc2VsaW5lT2Zmc2V0OiB0aGlzLmNvbnZlcnRNZWFzdXJlbWVudFRvUGl4ZWxzKFxyXG4gICAgICAgIHJhd01pbmltdW1GaXJzdEJhc2VsaW5lT2Zmc2V0XHJcbiAgICAgICksXHJcbiAgICAgIG9yaWdpbmFsTWluaW11bUZpcnN0QmFzZWxpbmVPZmZzZXQ6IHJhd01pbmltdW1GaXJzdEJhc2VsaW5lT2Zmc2V0LFxyXG4gICAgICBpZ25vcmVXcmFwOiB0ZXh0RnJhbWVQcmVmZXJlbmNlW1wiQF9JZ25vcmVXcmFwXCJdID09PSB0cnVlLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+TkCBDb252ZXJ0ZWQgdGV4dCBmcmFtZSBwcmVmZXJlbmNlcyB0byBwaXhlbHM6YCwge1xyXG4gICAgICB0ZXh0Q29sdW1uR3V0dGVyOiBgJHtyYXdUZXh0Q29sdW1uR3V0dGVyfSDihpIgJHtwcmVmZXJlbmNlcy50ZXh0Q29sdW1uR3V0dGVyfXB4YCxcclxuICAgICAgaW5zZXRzOiBgJHtyYXdJbnNldFRvcH0sJHtyYXdJbnNldFJpZ2h0fSwke3Jhd0luc2V0Qm90dG9tfSwke3Jhd0luc2V0TGVmdH0g4oaSICR7cHJlZmVyZW5jZXMuaW5zZXRTcGFjaW5nLnRvcH0sJHtwcmVmZXJlbmNlcy5pbnNldFNwYWNpbmcucmlnaHR9LCR7cHJlZmVyZW5jZXMuaW5zZXRTcGFjaW5nLmJvdHRvbX0sJHtwcmVmZXJlbmNlcy5pbnNldFNwYWNpbmcubGVmdH1weGAsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcHJlZmVyZW5jZXM7XHJcbiAgfVxyXG5cclxuICBwYXJzZUNvcm5lckVmZmVjdHMoaXRlbSkge1xyXG4gICAgLy8gUGFyc2UgY29ybmVyIGVmZmVjdHMgZm9yIHJlY3RhbmdsZXNcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXM6IHBhcnNlRmxvYXQoaXRlbVtcIkBfVG9wTGVmdENvcm5lclJhZGl1c1wiXSkgfHwgMCxcclxuICAgICAgdG9wUmlnaHRDb3JuZXJSYWRpdXM6IHBhcnNlRmxvYXQoaXRlbVtcIkBfVG9wUmlnaHRDb3JuZXJSYWRpdXNcIl0pIHx8IDAsXHJcbiAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6IHBhcnNlRmxvYXQoaXRlbVtcIkBfQm90dG9tTGVmdENvcm5lclJhZGl1c1wiXSkgfHwgMCxcclxuICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM6XHJcbiAgICAgICAgcGFyc2VGbG9hdChpdGVtW1wiQF9Cb3R0b21SaWdodENvcm5lclJhZGl1c1wiXSkgfHwgMCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3JvdXBJdGVtcyhncm91cEl0ZW0pIHtcclxuICAgIGNvbnN0IGdyb3VwSXRlbXMgPSBbXTtcclxuXHJcbiAgICAvLyBHcm91cHMgY2FuIGNvbnRhaW4gb3RoZXIgcGFnZSBpdGVtc1xyXG4gICAgY29uc3QgaXRlbVR5cGVzID0gW1wiUmVjdGFuZ2xlXCIsIFwiT3ZhbFwiLCBcIlBvbHlnb25cIiwgXCJUZXh0RnJhbWVcIl07XHJcblxyXG4gICAgaXRlbVR5cGVzLmZvckVhY2goKGl0ZW1UeXBlKSA9PiB7XHJcbiAgICAgIGlmIChncm91cEl0ZW1baXRlbVR5cGVdKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5pc0FycmF5KGdyb3VwSXRlbVtpdGVtVHlwZV0pXHJcbiAgICAgICAgICA/IGdyb3VwSXRlbVtpdGVtVHlwZV1cclxuICAgICAgICAgIDogW2dyb3VwSXRlbVtpdGVtVHlwZV1dO1xyXG5cclxuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBwYXJzZWRJdGVtID0gdGhpcy5wYXJzZVBhZ2VJdGVtKGl0ZW0sIGl0ZW1UeXBlKTtcclxuICAgICAgICAgIGlmIChwYXJzZWRJdGVtKSB7XHJcbiAgICAgICAgICAgIGdyb3VwSXRlbXMucHVzaChwYXJzZWRJdGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGdyb3VwSXRlbXM7XHJcbiAgfVxyXG5cclxuICBwYXJzZVRyYW5zcGFyZW5jeSh0cmFuc3BhcmVuY3lTZXR0aW5ncykge1xyXG4gICAgaWYgKCF0cmFuc3BhcmVuY3lTZXR0aW5ncykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYmxlbmRpbmdTZXR0aW5nczogdHJhbnNwYXJlbmN5U2V0dGluZ3MuQmxlbmRpbmdTZXR0aW5nXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGJsZW5kTW9kZTpcclxuICAgICAgICAgICAgICB0cmFuc3BhcmVuY3lTZXR0aW5ncy5CbGVuZGluZ1NldHRpbmdbXCJAX0JsZW5kTW9kZVwiXSB8fCBcIk5vcm1hbFwiLFxyXG4gICAgICAgICAgICBvcGFjaXR5OlxyXG4gICAgICAgICAgICAgIHBhcnNlRmxvYXQodHJhbnNwYXJlbmN5U2V0dGluZ3MuQmxlbmRpbmdTZXR0aW5nW1wiQF9PcGFjaXR5XCJdKSB8fFxyXG4gICAgICAgICAgICAgIDEwMCxcclxuICAgICAgICAgIH1cclxuICAgICAgICA6IG51bGwsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlRWxlbWVudFBvc2l0aW9uTWFwRml4ZWQoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIFBJWEVMLVBFUkZFQ1QgZWxlbWVudCBwb3NpdGlvbiBtYXAuLi5cIik7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCfk5AgVW5pdCBjb252ZXJzaW9uIHN0YXR1czogY29udmVydGVyPSR7ISF0aGlzXHJcbiAgICAgICAgLnVuaXRDb252ZXJ0ZXJ9LCBkb2N1bWVudFVuaXRzPSR7dGhpcy5kb2N1bWVudFVuaXRzfWBcclxuICAgICk7XHJcblxyXG4gICAgLy8gRU5IQU5DRUQ6IFVzZSBwcmVjaXNlIGNvb3JkaW5hdGUgb2Zmc2V0IGNhbGN1bGF0aW9uIGZvciBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nXHJcbiAgICBjb25zdCBjb29yZGluYXRlT2Zmc2V0ID0gSURNTFV0aWxzLmNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXRQcmVjaXNlKFxyXG4gICAgICB0aGlzLmVsZW1lbnRzXHJcbiAgICApO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwi8J+TkCBDYWxjdWxhdGVkIFBSRUNJU0UgY29vcmRpbmF0ZSBvZmZzZXQgZm9yIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmc6XCIsXHJcbiAgICAgIGNvb3JkaW5hdGVPZmZzZXRcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg8J+TkCBFTEVNRU5UICR7aW5kZXggKyAxfSBbJHtlbGVtZW50LnR5cGV9XTogQ29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvbmBcclxuICAgICAgKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYCAgIPCfk40gQm91bmRzOiBsZWZ0PSR7ZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMubGVmdH0sIHRvcD0ke2VsZW1lbnQuZ2VvbWV0cmljQm91bmRzLnRvcH0sIHdpZHRoPSR7ZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMud2lkdGh9LCBoZWlnaHQ9JHtlbGVtZW50Lmdlb21ldHJpY0JvdW5kcy5oZWlnaHR9YFxyXG4gICAgICApO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgICAg8J+TjSBUcmFuc2Zvcm06IHR4PSR7ZWxlbWVudC5pdGVtVHJhbnNmb3JtLnR4fSwgdHk9JHtlbGVtZW50Lml0ZW1UcmFuc2Zvcm0udHl9YFxyXG4gICAgICApO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgICAg8J+TjSBDb29yZGluYXRlIG9mZnNldDogeD0ke2Nvb3JkaW5hdGVPZmZzZXQueH0sIHk9JHtjb29yZGluYXRlT2Zmc2V0Lnl9YFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQXBwbHkgY29vcmRpbmF0ZSBzeXN0ZW0gdHJhbnNmb3JtYXRpb24gdG8gY29udmVydCBmcm9tIEluRGVzaWduIHRvIHdlYiBjb29yZGluYXRlc1xyXG4gICAgICBjb25zdCB3ZWJYID1cclxuICAgICAgICBlbGVtZW50Lmdlb21ldHJpY0JvdW5kcy5sZWZ0ICtcclxuICAgICAgICBlbGVtZW50Lml0ZW1UcmFuc2Zvcm0udHggK1xyXG4gICAgICAgIGNvb3JkaW5hdGVPZmZzZXQueDtcclxuICAgICAgY29uc3Qgd2ViWSA9XHJcbiAgICAgICAgZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMudG9wICtcclxuICAgICAgICBlbGVtZW50Lml0ZW1UcmFuc2Zvcm0udHkgK1xyXG4gICAgICAgIGNvb3JkaW5hdGVPZmZzZXQueTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGAgICDwn5ONIFdlYiBjb29yZGluYXRlczogKCR7d2ViWH0sICR7d2ViWX0pICR7ZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMud2lkdGh9eCR7ZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMuaGVpZ2h0fWBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBwb3NpdGlvbiBvYmplY3QgaW4gb3JpZ2luYWwgdW5pdHNcclxuICAgICAgZWxlbWVudC5wb3NpdGlvbiA9IHtcclxuICAgICAgICB4OiB3ZWJYLFxyXG4gICAgICAgIHk6IHdlYlksXHJcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQuZ2VvbWV0cmljQm91bmRzLndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMuaGVpZ2h0LFxyXG4gICAgICAgIHJvdGF0aW9uOiBlbGVtZW50Lml0ZW1UcmFuc2Zvcm0ucm90YXRpb24gfHwgMCxcclxuICAgICAgICBfY29udmVyc2lvbkluZm86IHtcclxuICAgICAgICAgIHVuaXRzQ29udmVydGVkOiBmYWxzZSxcclxuICAgICAgICAgIG9yaWdpbmFsVW5pdHM6IHRoaXMuZG9jdW1lbnRVbml0cyxcclxuICAgICAgICAgIHBpeGVsQ29udmVyc2lvbkFwcGxpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgZHBpOiB0aGlzLnVuaXRDb252ZXJ0ZXI/LmRwaSB8fCA5NixcclxuICAgICAgICAgIGNvb3JkaW5hdGVPZmZzZXQ6IGNvb3JkaW5hdGVPZmZzZXQsXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IHVuaXQgY29udmVyc2lvbiB0byBwaXhlbHMgaWYgY29udmVydGVyIGlzIGF2YWlsYWJsZVxyXG4gICAgICBpZiAodGhpcy51bml0Q29udmVydGVyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCIgICDwn5OQIEFwcGx5aW5nIHVuaXQgY29udmVyc2lvbjogUG9pbnRzIOKGkiBwaXhlbHNcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHBpeGVsWCA9IHRoaXMudW5pdENvbnZlcnRlci50b1BpeGVscyh3ZWJYLCB0aGlzLmRvY3VtZW50VW5pdHMpO1xyXG4gICAgICAgIGNvbnN0IHBpeGVsWSA9IHRoaXMudW5pdENvbnZlcnRlci50b1BpeGVscyh3ZWJZLCB0aGlzLmRvY3VtZW50VW5pdHMpO1xyXG4gICAgICAgIGNvbnN0IHBpeGVsV2lkdGggPSB0aGlzLnVuaXRDb252ZXJ0ZXIudG9QaXhlbHMoXHJcbiAgICAgICAgICBlbGVtZW50Lmdlb21ldHJpY0JvdW5kcy53aWR0aCxcclxuICAgICAgICAgIHRoaXMuZG9jdW1lbnRVbml0c1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgcGl4ZWxIZWlnaHQgPSB0aGlzLnVuaXRDb252ZXJ0ZXIudG9QaXhlbHMoXHJcbiAgICAgICAgICBlbGVtZW50Lmdlb21ldHJpY0JvdW5kcy5oZWlnaHQsXHJcbiAgICAgICAgICB0aGlzLmRvY3VtZW50VW5pdHNcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBlbGVtZW50LnBpeGVsUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICB4OiBwaXhlbFgsXHJcbiAgICAgICAgICB5OiBwaXhlbFksXHJcbiAgICAgICAgICB3aWR0aDogcGl4ZWxXaWR0aCxcclxuICAgICAgICAgIGhlaWdodDogcGl4ZWxIZWlnaHQsXHJcbiAgICAgICAgICByb3RhdGlvbjogZWxlbWVudC5pdGVtVHJhbnNmb3JtLnJvdGF0aW9uIHx8IDAsXHJcbiAgICAgICAgICBfaXNDb252ZXJ0ZWQ6IHRydWUsXHJcbiAgICAgICAgICBfb3JpZ2luYWxVbml0czogdGhpcy5kb2N1bWVudFVuaXRzLFxyXG4gICAgICAgICAgX2RwaTogdGhpcy51bml0Q29udmVydGVyLmRwaSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgICAg8J+TkCBDT05WRVJURUQgVE8gUElYRUxTOiB7XHJcbiAgeDogJHtwaXhlbFh9LFxyXG4gIHk6ICR7cGl4ZWxZfSxcclxuICB3aWR0aDogJHtwaXhlbFdpZHRofSxcclxuICBoZWlnaHQ6ICR7cGl4ZWxIZWlnaHR9LFxyXG4gIHJvdGF0aW9uOiAke2VsZW1lbnQuaXRlbVRyYW5zZm9ybS5yb3RhdGlvbiB8fCAwfSxcclxuICBfaXNDb252ZXJ0ZWQ6IHRydWUsXHJcbiAgX29yaWdpbmFsVW5pdHM6ICcke3RoaXMuZG9jdW1lbnRVbml0c30nLFxyXG4gIF9kcGk6ICR7dGhpcy51bml0Q29udmVydGVyLmRwaX1cclxufWApO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgb3JpZ2luYWwgcG9zaXRpb24gY29udmVyc2lvbiBpbmZvXHJcbiAgICAgICAgZWxlbWVudC5wb3NpdGlvbi5fY29udmVyc2lvbkluZm8udW5pdHNDb252ZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGVsZW1lbnQucG9zaXRpb24uX2NvbnZlcnNpb25JbmZvLnBpeGVsQ29udmVyc2lvbkFwcGxpZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgICAg4pyFIEZJTkFMIFBPU0lUSU9OUyAoYWZ0ZXIgY29vcmRpbmF0ZSBzeXN0ZW0gdHJhbnNmb3JtYXRpb24pOmBcclxuICAgICAgKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYCAgICAgIE9yaWdpbmFsOiAke0pTT04uc3RyaW5naWZ5KGVsZW1lbnQucG9zaXRpb24sIG51bGwsIDIpfWBcclxuICAgICAgKTtcclxuICAgICAgaWYgKGVsZW1lbnQucGl4ZWxQb3NpdGlvbikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgICAgIFBpeGVsczogJHtKU09OLnN0cmluZ2lmeShlbGVtZW50LnBpeGVsUG9zaXRpb24sIG51bGwsIDIpfWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQSVhFTC1QRVJGRUNUIFZBTElEQVRJT05cclxuICAgICAgdGhpcy52YWxpZGF0ZVBpeGVsUGVyZmVjdFBvc2l0aW9uaW5nKGVsZW1lbnQsIGluZGV4ICsgMSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIuKchSBQSVhFTC1QRVJGRUNUIHBvc2l0aW9uaW5nIG1hcCBjcmVhdGVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcgYWNjdXJhY3lcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gdmFsaWRhdGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZWxlbWVudE51bWJlciAtIEVsZW1lbnQgbnVtYmVyIGZvciBsb2dnaW5nXHJcbiAgICovXHJcbiAgdmFsaWRhdGVQaXhlbFBlcmZlY3RQb3NpdGlvbmluZyhlbGVtZW50LCBlbGVtZW50TnVtYmVyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBQSVhFTC1QRVJGRUNUIFZBTElEQVRJT04gLSBFbGVtZW50ICR7ZWxlbWVudE51bWJlcn06YCk7XHJcblxyXG4gICAgY29uc3QgcG9zaXRpb24gPSBlbGVtZW50LnBpeGVsUG9zaXRpb24gfHwgZWxlbWVudC5wb3NpdGlvbjtcclxuXHJcbiAgICAvLyBDaGVjayBmb3Igc3ViLXBpeGVsIHByZWNpc2lvbiBpc3N1ZXNcclxuICAgIGNvbnN0IGhhc1N1YlBpeGVsWCA9IHBvc2l0aW9uLnggJSAxICE9PSAwO1xyXG4gICAgY29uc3QgaGFzU3ViUGl4ZWxZID0gcG9zaXRpb24ueSAlIDEgIT09IDA7XHJcblxyXG4gICAgaWYgKGhhc1N1YlBpeGVsWCB8fCBoYXNTdWJQaXhlbFkpIHtcclxuICAgICAgY29uc29sZS5sb2coYCAgIOKaoO+4jyBTdWItcGl4ZWwgcG9zaXRpb25pbmcgZGV0ZWN0ZWQ6YCk7XHJcbiAgICAgIGlmIChoYXNTdWJQaXhlbFgpXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgICAgICAgWDogJHtwb3NpdGlvbi54fSAoZnJhY3Rpb25hbDogJHsocG9zaXRpb24ueCAlIDEpLnRvRml4ZWQoMyl9KWBcclxuICAgICAgICApO1xyXG4gICAgICBpZiAoaGFzU3ViUGl4ZWxZKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgICAgIFk6ICR7cG9zaXRpb24ueX0gKGZyYWN0aW9uYWw6ICR7KHBvc2l0aW9uLnkgJSAxKS50b0ZpeGVkKDMpfSlgXHJcbiAgICAgICAgKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYCAgIPCfk50gTm90ZTogU3ViLXBpeGVsIHBvc2l0aW9uaW5nIGlzIG5vcm1hbCBmb3IgcHJlY2lzZSBsYXlvdXRzYFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYCAgIOKchSBQZXJmZWN0IHBpeGVsIGFsaWdubWVudDogWD0ke3Bvc2l0aW9uLnh9LCBZPSR7cG9zaXRpb24ueX1gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIGNvb3JkaW5hdGVzIChzaG91bGQgYmUgcmVzb2x2ZWQgYnkgb2Zmc2V0KVxyXG4gICAgaWYgKHBvc2l0aW9uLnggPCAwIHx8IHBvc2l0aW9uLnkgPCAwKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgICAg8J+aqCBORUdBVElWRSBDT09SRElOQVRFUyBERVRFQ1RFRDogWD0ke3Bvc2l0aW9uLnh9LCBZPSR7cG9zaXRpb24ueX1gXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgICAg8J+aqCBUaGlzIGluZGljYXRlcyBjb29yZGluYXRlIG9mZnNldCBjYWxjdWxhdGlvbiBtYXkgbmVlZCBhZGp1c3RtZW50YFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGZvciByZWFzb25hYmxlIHBvc2l0aW9uaW5nIGJvdW5kc1xyXG4gICAgY29uc3QgaXNSZWFzb25hYmxlID1cclxuICAgICAgcG9zaXRpb24ueCA+PSAwICYmXHJcbiAgICAgIHBvc2l0aW9uLnkgPj0gMCAmJlxyXG4gICAgICBwb3NpdGlvbi54IDwgMTAwMDAgJiZcclxuICAgICAgcG9zaXRpb24ueSA8IDEwMDAwO1xyXG5cclxuICAgIGlmICghaXNSZWFzb25hYmxlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgICAg8J+aqCBVTlJFQVNPTkFCTEUgUE9TSVRJT05JTkc6IFg9JHtwb3NpdGlvbi54fSwgWT0ke3Bvc2l0aW9uLnl9YFxyXG4gICAgICApO1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYCAgIPCfmqggQ29vcmRpbmF0ZXMgYXJlIG91dHNpZGUgZXhwZWN0ZWQgcmFuZ2UgZm9yIHdlYiBkaXNwbGF5YFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coYCAgIOKchSBQb3NpdGlvbmluZyB3aXRoaW4gcmVhc29uYWJsZSBib3VuZHNgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBjb252ZXJzaW9uIGNvbnNpc3RlbmN5XHJcbiAgICBpZiAoZWxlbWVudC5waXhlbFBvc2l0aW9uICYmIGVsZW1lbnQucG9zaXRpb24uX2NvbnZlcnNpb25JbmZvKSB7XHJcbiAgICAgIGNvbnN0IGluZm8gPSBlbGVtZW50LnBvc2l0aW9uLl9jb252ZXJzaW9uSW5mbztcclxuICAgICAgY29uc29sZS5sb2coYCAgIPCfk4ogQ29udmVyc2lvbiB2YWxpZGF0aW9uOmApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgICAgVW5pdHMgY29udmVydGVkOiAke2luZm8udW5pdHNDb252ZXJ0ZWR9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAgICBPcmlnaW5hbCB1bml0czogJHtpbmZvLm9yaWdpbmFsVW5pdHN9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICAgICBEUEk6ICR7aW5mby5kcGl9YCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGAgICAgICBDb29yZGluYXRlIG9mZnNldCBhcHBsaWVkOiBYPSR7aW5mby5jb29yZGluYXRlT2Zmc2V0Lnh9LCBZPSR7aW5mby5jb29yZGluYXRlT2Zmc2V0Lnl9YFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0cmFjdE1hc3RlclBhZ2VzKG1hc3RlckRhdGEpIHtcclxuICAgIGNvbnN0IHBhZ2VzID0gW107XHJcblxyXG4gICAgaWYgKG1hc3RlckRhdGEuUGFnZSkge1xyXG4gICAgICBjb25zdCBwYWdlTGlzdCA9IEFycmF5LmlzQXJyYXkobWFzdGVyRGF0YS5QYWdlKVxyXG4gICAgICAgID8gbWFzdGVyRGF0YS5QYWdlXHJcbiAgICAgICAgOiBbbWFzdGVyRGF0YS5QYWdlXTtcclxuXHJcbiAgICAgIHBhZ2VMaXN0LmZvckVhY2goKHBhZ2UpID0+IHtcclxuICAgICAgICAvLyBFeHRyYWN0IG1hcmdpbiBwcmVmZXJlbmNlcyBmcm9tIG1hc3RlciBwYWdlXHJcbiAgICAgICAgbGV0IG1hcmdpblByZWZlcmVuY2UgPSBudWxsO1xyXG4gICAgICAgIGlmIChwYWdlLk1hcmdpblByZWZlcmVuY2UpIHtcclxuICAgICAgICAgIG1hcmdpblByZWZlcmVuY2UgPSB7XHJcbiAgICAgICAgICAgIHRvcDogcGFyc2VGbG9hdChwYWdlLk1hcmdpblByZWZlcmVuY2VbXCJAX1RvcFwiXSkgfHwgMCxcclxuICAgICAgICAgICAgYm90dG9tOiBwYXJzZUZsb2F0KHBhZ2UuTWFyZ2luUHJlZmVyZW5jZVtcIkBfQm90dG9tXCJdKSB8fCAwLFxyXG4gICAgICAgICAgICBsZWZ0OiBwYXJzZUZsb2F0KHBhZ2UuTWFyZ2luUHJlZmVyZW5jZVtcIkBfTGVmdFwiXSkgfHwgMCxcclxuICAgICAgICAgICAgcmlnaHQ6IHBhcnNlRmxvYXQocGFnZS5NYXJnaW5QcmVmZXJlbmNlW1wiQF9SaWdodFwiXSkgfHwgMCxcclxuICAgICAgICAgICAgY29sdW1uQ291bnQ6IHBhcnNlSW50KHBhZ2UuTWFyZ2luUHJlZmVyZW5jZVtcIkBfQ29sdW1uQ291bnRcIl0pIHx8IDEsXHJcbiAgICAgICAgICAgIGNvbHVtbkd1dHRlcjpcclxuICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhZ2UuTWFyZ2luUHJlZmVyZW5jZVtcIkBfQ29sdW1uR3V0dGVyXCJdKSB8fCAwLFxyXG4gICAgICAgICAgICBjb2x1bW5EaXJlY3Rpb246XHJcbiAgICAgICAgICAgICAgcGFnZS5NYXJnaW5QcmVmZXJlbmNlW1wiQF9Db2x1bW5EaXJlY3Rpb25cIl0gfHwgXCJIb3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgIGNvbHVtbnNQb3NpdGlvbnM6IHBhZ2UuTWFyZ2luUHJlZmVyZW5jZVtcIkBfQ29sdW1uc1Bvc2l0aW9uc1wiXSB8fCBcIlwiLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBcIvCfk48gRXh0cmFjdGVkIG1hcmdpbiBwcmVmZXJlbmNlIGZyb20gbWFzdGVyIHBhZ2U6XCIsXHJcbiAgICAgICAgICAgIG1hcmdpblByZWZlcmVuY2VcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYWdlcy5wdXNoKHtcclxuICAgICAgICAgIHNlbGY6IHBhZ2VbXCJAX1NlbGZcIl0sXHJcbiAgICAgICAgICBuYW1lOiBwYWdlW1wiQF9OYW1lXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgICBnZW9tZXRyaWNCb3VuZHM6IElETUxVdGlscy5wYXJzZUdlb21ldHJpY0JvdW5kcyhcclxuICAgICAgICAgICAgcGFnZVtcIkBfR2VvbWV0cmljQm91bmRzXCJdXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgaXRlbVRyYW5zZm9ybTogSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKHBhZ2VbXCJAX0l0ZW1UcmFuc2Zvcm1cIl0pLFxyXG4gICAgICAgICAgYXBwbGllZE1hc3RlcjogcGFnZVtcIkBfQXBwbGllZE1hc3RlclwiXSB8fCBcIlwiLFxyXG4gICAgICAgICAgbWFzdGVyUGFnZVRyYW5zZm9ybTogSURNTFV0aWxzLnBhcnNlVHJhbnNmb3JtKFxyXG4gICAgICAgICAgICBwYWdlW1wiQF9NYXN0ZXJQYWdlVHJhbnNmb3JtXCJdXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgbWFyZ2luUHJlZmVyZW5jZTogbWFyZ2luUHJlZmVyZW5jZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhZ2VzO1xyXG4gIH1cclxuXHJcbiAgZ2V0RWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50cztcclxuICB9XHJcblxyXG4gIGNsZWFyRWxlbWVudHMoKSB7XHJcbiAgICB0aGlzLmVsZW1lbnRzID0gW107XHJcbiAgfVxyXG5cclxuICBnZXRFbGVtZW50SW5kZXgoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuZmluZEluZGV4KChlbCkgPT4gZWwuc2VsZiA9PT0gZWxlbWVudC5zZWxmKTtcclxuICB9XHJcblxyXG4gIGdldFBhZ2VDb250ZW50KHBhZ2VJZCkge1xyXG4gICAgY29uc3QgcGFnZUVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5maWx0ZXIoKGVsZW1lbnQpID0+IHtcclxuICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBiZWxvbmdzIHRvIHRoaXMgcGFnZSBiYXNlZCBvbiBpdHMgYm91bmRzXHJcbiAgICAgIHJldHVybiB0cnVlOyAvLyBUT0RPOiBJbXBsZW1lbnQgcHJvcGVyIHBhZ2UgYm91bmRhcnkgY2hlY2tpbmdcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGVsZW1lbnRzOiBwYWdlRWxlbWVudHMsXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50UGFyc2VyO1xyXG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJJRE1MVXRpbHMiLCJFbGVtZW50UGFyc2VyIiwiY29uc3RydWN0b3IiLCJ1bml0Q29udmVydGVyIiwiZWxlbWVudHMiLCJkb2N1bWVudFVuaXRzIiwic2V0RG9jdW1lbnRVbml0cyIsInVuaXRzIiwiY29uc29sZSIsImxvZyIsImNvbnZlcnRCb3VuZHNUb1BpeGVscyIsImJvdW5kcyIsImlzU3VwcG9ydGVkVW5pdCIsImNvbnZlcnRlZEJvdW5kcyIsImNvbnZlcnRPYmplY3RUb1BpeGVscyIsIm9yaWdpbmFsIiwiY29udmVydGVkIiwiY29udmVydFRyYW5zZm9ybVRvUGl4ZWxzIiwidHJhbnNmb3JtIiwiY29udmVydGVkVHJhbnNmb3JtIiwidHgiLCJ0b1BpeGVscyIsInR5IiwiY29udmVydE1lYXN1cmVtZW50VG9QaXhlbHMiLCJ2YWx1ZSIsImlzTmFOIiwiY29udmVydGVkVmFsdWUiLCJleHRyYWN0U3ByZWFkUGFnZXMiLCJzcHJlYWREYXRhIiwicGFnZXMiLCJQYWdlIiwicGFnZUxpc3QiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwicGFnZSIsImluZGV4IiwicHVzaCIsInNlbGYiLCJuYW1lIiwiYXBwbGllZE1hc3RlciIsImdlb21ldHJpY0JvdW5kcyIsInBhcnNlR2VvbWV0cmljQm91bmRzIiwiaXRlbVRyYW5zZm9ybSIsInBhcnNlVHJhbnNmb3JtIiwibGVuZ3RoIiwiZXh0cmFjdFBhZ2VJdGVtcyIsInBhZ2VJdGVtcyIsIml0ZW1UeXBlcyIsIml0ZW1UeXBlIiwiaXRlbXMiLCJpdGVtIiwicGFnZUl0ZW0iLCJwYXJzZVBhZ2VJdGVtIiwiY2hlY2tGb3JOZXN0ZWRDb250ZW50IiwiUmVjdGFuZ2xlIiwicmVjdGFuZ2xlcyIsInJlY3QiLCJwb3NzaWJsZUNvbnRlbnQiLCJJbWFnZSIsIlBsYWNlZEltYWdlIiwiRVBTIiwiUERGIiwiUHJvcGVydGllcyIsIkxpbmsiLCJleGlzdGluZ1JlY3QiLCJmaW5kIiwiaGFzUGxhY2VkQ29udGVudCIsImNvbnRlbnRUeXBlIiwicGxhY2VkQ29udGVudCIsIm5lc3RlZExpbmsiLCJleHRyYWN0UGxhY2VkQ29udGVudCIsImltYWdlUG9zaXRpb24iLCJjYWxjdWxhdGVJbWFnZVBvc2l0aW9uSW5GcmFtZSIsImNvbnRlbnQiLCJsaW5rT2JqZWN0IiwiY29udGVudEl0ZW0iLCJPYmplY3QiLCJrZXlzIiwiaHJlZiIsInVyaSIsInJlcGxhY2UiLCJzcGxpdCIsInBvcCIsImlzRW1iZWRkZWQiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJ0eXBlIiwiYWN0dWFsUHBpIiwiZWZmZWN0aXZlUHBpIiwiaW1hZ2VUeXBlTmFtZSIsInNwYWNlIiwid2FybiIsImJhc2VJdGVtIiwidmlzaWJsZSIsImxvY2tlZCIsImNhbGN1bGF0ZUJvdW5kc0Zyb21QYXRoIiwiaXRlbUxheWVyIiwiZmlsbENvbG9yIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXZWlnaHQiLCJwYXJzZUZsb2F0IiwicGFyZW50U3RvcnkiLCJpc0NvbnRlbnRGcmFtZSIsImVtYmVkZGVkSW5mbyIsImRldGVjdEVtYmVkZGVkSW1hZ2VzIiwiaGFzRW1iZWRkZWRDb250ZW50IiwiaXNQbGFjZWhvbGRlciIsImVtYmVkZGVkVHlwZSIsImhhc0NvbnRlbnQiLCJKU09OIiwic3RyaW5naWZ5IiwidGV4dEZyYW1lUHJlZmVyZW5jZXMiLCJwYXJzZVRleHRGcmFtZVByZWZlcmVuY2VzIiwiVGV4dEZyYW1lUHJlZmVyZW5jZSIsImNvcm5lckVmZmVjdHMiLCJwYXJzZUNvcm5lckVmZmVjdHMiLCJncm91cEl0ZW1zIiwiZXh0cmFjdEdyb3VwSXRlbXMiLCJlbGVtZW50IiwiZW1iZWRkZWRJbmRpY2F0b3JzIiwiZW1iZWRkZWREYXRhIiwiZW1iZWRkZWRGaWxlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0SW1hZ2VFeHRlbnNpb24iLCJ0ZXh0RnJhbWVQcmVmZXJlbmNlIiwicmF3VGV4dENvbHVtbkd1dHRlciIsInJhd0luc2V0VG9wIiwicmF3SW5zZXRSaWdodCIsInJhd0luc2V0Qm90dG9tIiwicmF3SW5zZXRMZWZ0IiwicmF3TWluaW11bUZpcnN0QmFzZWxpbmVPZmZzZXQiLCJwcmVmZXJlbmNlcyIsInRleHRDb2x1bW5Db3VudCIsInBhcnNlSW50IiwidGV4dENvbHVtbkd1dHRlciIsImZpcnN0QmFzZWxpbmVPZmZzZXQiLCJhdXRvU2l6aW5nUmVmZXJlbmNlUG9pbnQiLCJhdXRvU2l6aW5nVHlwZSIsInZlcnRpY2FsSnVzdGlmaWNhdGlvbiIsImluc2V0U3BhY2luZyIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIm9yaWdpbmFsSW5zZXRTcGFjaW5nIiwidXNlTWluaW11bUhlaWdodCIsIm1pbmltdW1GaXJzdEJhc2VsaW5lT2Zmc2V0Iiwib3JpZ2luYWxNaW5pbXVtRmlyc3RCYXNlbGluZU9mZnNldCIsImlnbm9yZVdyYXAiLCJpbnNldHMiLCJ0b3BMZWZ0Q29ybmVyUmFkaXVzIiwidG9wUmlnaHRDb3JuZXJSYWRpdXMiLCJib3R0b21MZWZ0Q29ybmVyUmFkaXVzIiwiYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMiLCJncm91cEl0ZW0iLCJwYXJzZWRJdGVtIiwicGFyc2VUcmFuc3BhcmVuY3kiLCJ0cmFuc3BhcmVuY3lTZXR0aW5ncyIsImJsZW5kaW5nU2V0dGluZ3MiLCJCbGVuZGluZ1NldHRpbmciLCJibGVuZE1vZGUiLCJvcGFjaXR5IiwiY3JlYXRlRWxlbWVudFBvc2l0aW9uTWFwRml4ZWQiLCJjb29yZGluYXRlT2Zmc2V0IiwiY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldFByZWNpc2UiLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5Iiwid2ViWCIsIndlYlkiLCJwb3NpdGlvbiIsInJvdGF0aW9uIiwiX2NvbnZlcnNpb25JbmZvIiwidW5pdHNDb252ZXJ0ZWQiLCJvcmlnaW5hbFVuaXRzIiwicGl4ZWxDb252ZXJzaW9uQXBwbGllZCIsImRwaSIsInBpeGVsWCIsInBpeGVsWSIsInBpeGVsV2lkdGgiLCJwaXhlbEhlaWdodCIsInBpeGVsUG9zaXRpb24iLCJfaXNDb252ZXJ0ZWQiLCJfb3JpZ2luYWxVbml0cyIsIl9kcGkiLCJ2YWxpZGF0ZVBpeGVsUGVyZmVjdFBvc2l0aW9uaW5nIiwiZWxlbWVudE51bWJlciIsImhhc1N1YlBpeGVsWCIsImhhc1N1YlBpeGVsWSIsInRvRml4ZWQiLCJpc1JlYXNvbmFibGUiLCJpbmZvIiwiZXh0cmFjdE1hc3RlclBhZ2VzIiwibWFzdGVyRGF0YSIsIm1hcmdpblByZWZlcmVuY2UiLCJNYXJnaW5QcmVmZXJlbmNlIiwiY29sdW1uQ291bnQiLCJjb2x1bW5HdXR0ZXIiLCJjb2x1bW5EaXJlY3Rpb24iLCJjb2x1bW5zUG9zaXRpb25zIiwibWFzdGVyUGFnZVRyYW5zZm9ybSIsImdldEVsZW1lbnRzIiwiY2xlYXJFbGVtZW50cyIsImdldEVsZW1lbnRJbmRleCIsImZpbmRJbmRleCIsImVsIiwiZ2V0UGFnZUNvbnRlbnQiLCJwYWdlSWQiLCJwYWdlRWxlbWVudHMiLCJmaWx0ZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/parsers/ElementParser.js\n");

/***/ }),

/***/ "./lib/parsers/StoryParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StoryParser.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StoryParser {\n    constructor(styleParser, unitConverter = null){\n        this.styleParser = styleParser;\n        this.unitConverter = unitConverter; // ADDED: Unit converter for font sizes and spacing\n        this.documentUnits = null; // Will be set from document units\n        this.stories = {};\n    }\n    // ADDED: Method to set document units for font size conversion\n    setDocumentUnits(units) {\n        this.documentUnits = units;\n        console.log(\"\\uD83D\\uDCD0 StoryParser: Set document units to\", units);\n    }\n    // ADDED: Method to convert font size to pixels if needed\n    convertFontSizeToPixels(fontSize) {\n        if (!fontSize || !this.unitConverter || !this.documentUnits) {\n            return fontSize;\n        }\n        // Font sizes in IDML are typically in Points, but let's use document units as fallback\n        const fontUnits = this.documentUnits === \"Pixels\" ? \"Pixels\" : \"Points\"; // Font sizes are usually points\n        if (this.unitConverter.isSupportedUnit(fontUnits)) {\n            const pixelSize = this.unitConverter.toPixels(fontSize, fontUnits);\n            console.log(`ðŸ“ Converted font size: ${fontSize} ${fontUnits} â†’ ${pixelSize} px`);\n            return pixelSize;\n        }\n        return fontSize;\n    }\n    async parseStoryFile(fileName, content, xmlParser) {\n        console.log(`ðŸ“ Parsing story: ${fileName}`);\n        try {\n            const parsed = xmlParser.parse(content);\n            const storyId = path.basename(fileName, \".xml\");\n            const storyData = parsed.Story || parsed;\n            // ADD DEBUGGING FOR BR ELEMENTS IN RAW XML\n            console.log(\"=== RAW XML CONTENT DEBUG ===\");\n            console.log(\"Raw XML content sample:\", content.substring(0, 1000));\n            // Count Br elements in raw XML\n            const brMatches = content.match(/<Br[^>]*>/g) || [];\n            console.log(`Found ${brMatches.length} <Br> elements in raw XML:`, brMatches);\n            // Look for consecutive Br elements\n            const consecutiveBrPattern = /(<Br[^>]*>\\s*){2,}/g;\n            const consecutiveBrMatches = content.match(consecutiveBrPattern) || [];\n            console.log(`Found ${consecutiveBrMatches.length} groups of consecutive <Br> elements:`, consecutiveBrMatches);\n            // CRITICAL FIX: Parse raw XML to preserve document order\n            this.parseRawXMLForDocumentOrder(content, fileName);\n            // ADD THESE SIMPLE LOGS FIRST:\n            console.log(\"=== SIMPLE DEBUG TEST ===\");\n            console.log(\"Story file name:\", fileName);\n            console.log(\"Parsed story keys:\", Object.keys(storyData));\n            console.log(\"Raw story data sample:\", JSON.stringify(storyData, null, 2).substring(0, 500));\n            // Extract detailed story information\n            const detailedStory = {\n                self: storyData[\"@_Self\"],\n                appliedTOCStyle: storyData[\"@_AppliedTOCStyle\"] || \"n\",\n                userText: storyData[\"@_UserText\"] !== false,\n                // Extract story content with formatting\n                content: this.extractDetailedStoryContent(storyData, fileName),\n                // Extract text formatting\n                textFormatting: this.extractTextFormatting(storyData)\n            };\n            // ADD DEBUGGING FOR PARSED BR STRUCTURE\n            console.log(\"=== PARSED XML STRUCTURE DEBUG ===\");\n            this.debugBrElementsInParsedStructure(storyData, \"root\");\n            const cleanStoryId = storyId.replace(\"Story_\", \"\");\n            this.stories[cleanStoryId] = detailedStory;\n            // Enhanced logging to show line breaks\n            const { plainText, lineBreakInfo } = detailedStory.content;\n            console.log(`âœ… Story ${storyId} parsed:`);\n            console.log(`   - Characters: ${plainText.length}`);\n            console.log(`   - Words: ${detailedStory.content.wordCount}`);\n            console.log(`   - Line breaks: ${lineBreakInfo?.lineBreakCount || 0}`);\n            console.log(`   - Text preview: \"${plainText.substring(0, 50).replace(/\\n/g, \"\\\\n\")}...\"`);\n        } catch (error) {\n            console.error(`âŒ Error parsing story ${fileName}:`, error.message);\n        }\n    }\n    // Replace the existing extractDetailedStoryContent method with this corrected version\n    extractDetailedStoryContent(storyData, fileName = \"unknown\") {\n        let content = \"\";\n        let formattedContent = [];\n        let textColor = null;\n        let debugInfo = [];\n        const extractTextRecursively = (element, depth = 0, context = {})=>{\n            if (typeof element === \"string\") {\n                content += element;\n                return;\n            }\n            if (element && typeof element === \"object\") {\n                // ENHANCED: Special handling for CharacterStyleRange with sophisticated Br detection\n                if (element.CharacterStyleRange) {\n                    const ranges = Array.isArray(element.CharacterStyleRange) ? element.CharacterStyleRange : [\n                        element.CharacterStyleRange\n                    ];\n                    ranges.forEach((range, rangeIndex)=>{\n                        // Extract direct font references from the XML range\n                        const directFontRef = range[\"@_AppliedFont\"] || range[\"@_FontFamily\"] || range[\"@_Font\"] || \"\";\n                        const formatting = {\n                            paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                            characterStyle: range[\"@_AppliedCharacterStyle\"] || null,\n                            fontSize: range[\"@_PointSize\"] ? this.convertFontSizeToPixels(parseFloat(range[\"@_PointSize\"])) // ADDED: Convert to pixels\n                             : null,\n                            originalFontSize: range[\"@_PointSize\"] ? parseFloat(range[\"@_PointSize\"]) : null,\n                            fontReference: directFontRef,\n                            fillColor: range[\"@_FillColor\"] || null,\n                            fontStyle: range[\"@_FontStyle\"] || null,\n                            // CRITICAL FIX: Inherit paragraph alignment from context if not explicitly set\n                            alignment: range[\"@_Justification\"] || range[\"@_Alignment\"] || context.paragraphAlignment || null\n                        };\n                        const resolvedFormatting = this.styleParser.resolveStyleFormatting(formatting);\n                        // CRITICAL FIX: Process Content and Br elements in document order\n                        // This handles interleaved <Content> and <Br> elements correctly\n                        content = this.processCharacterRangeInOrder(range, resolvedFormatting, rangeIndex, ranges.length, content, formattedContent, debugInfo, context, fileName);\n                        // CRITICAL FIX: Add space between character style ranges if needed\n                        if (rangeIndex < ranges.length - 1) {\n                            const nextRange = ranges[rangeIndex + 1];\n                            // More robust space detection\n                            const currentText = content.slice(-10); // Check last 10 characters\n                            const currentRangeEndsWithSpace = /\\s$/.test(currentText); // Any whitespace at end\n                            const nextContent = nextRange.Content ? String(Array.isArray(nextRange.Content) ? nextRange.Content[0] : nextRange.Content) : \"\";\n                            const nextRangeStartsWithSpace = /^\\s/.test(nextContent); // Any whitespace at start\n                            // AGGRESSIVE FIX: Add space between ALL ranges unless explicitly not needed\n                            const shouldSkipSpace = currentRangeEndsWithSpace || nextRangeStartsWithSpace || this.shouldInsertImplicitLineBreak(range, nextRange, context) || !nextRange.Content || // Skip if next range has no content\n                            nextContent.trim() === \"\";\n                            if (!shouldSkipSpace) {\n                                const currentStyle = range[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const nextStyle = nextRange[\"@_AppliedCharacterStyle\"] || \"none\";\n                                const spaceText = \" \";\n                                content += spaceText;\n                                formattedContent.push({\n                                    text: spaceText,\n                                    formatting: {\n                                        isSpace: true,\n                                        source: \"between character style ranges (aggressive)\",\n                                        currentStyle,\n                                        nextStyle\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Space inserted between character styles (aggressive)\",\n                                    location: `Between ranges ${rangeIndex} and ${rangeIndex + 1}`,\n                                    currentStyle,\n                                    nextStyle,\n                                    reason: \"Default space insertion - words likely split across ranges\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            } else {\n                                debugInfo.push({\n                                    type: \"Space insertion skipped\",\n                                    location: `Between ranges ${rangeIndex} and ${rangeIndex + 1}`,\n                                    reason: currentRangeEndsWithSpace ? \"Current range ends with space\" : nextRangeStartsWithSpace ? \"Next range starts with space\" : !nextRange.Content ? \"Next range has no content\" : nextContent.trim() === \"\" ? \"Next content is only whitespace\" : \"Line break would be inserted\",\n                                    currentTextEnd: currentText.slice(-5),\n                                    nextTextStart: nextContent.slice(0, 5)\n                                });\n                            }\n                            // Handle explicit line breaks between ranges (for cases where shouldInsertImplicitLineBreak is true)\n                            if (this.shouldInsertImplicitLineBreak(range, nextRange, context)) {\n                                const implicitBreak = \"\\n\";\n                                content += implicitBreak;\n                                formattedContent.push({\n                                    text: implicitBreak,\n                                    formatting: {\n                                        isBreak: true,\n                                        breakType: \"implicit\",\n                                        source: \"between ranges\"\n                                    }\n                                });\n                                debugInfo.push({\n                                    type: \"Implicit line break\",\n                                    location: `Between ranges ${rangeIndex} and ${rangeIndex + 1}`\n                                });\n                            }\n                        }\n                    });\n                    return; // Don't continue processing to avoid duplication\n                }\n                // ENHANCED: Handle ParagraphStyleRange with context\n                if (element.ParagraphStyleRange) {\n                    const ranges = Array.isArray(element.ParagraphStyleRange) ? element.ParagraphStyleRange : [\n                        element.ParagraphStyleRange\n                    ];\n                    ranges.forEach((range, index)=>{\n                        const paragraphContext = {\n                            ...context,\n                            paragraphIndex: index,\n                            totalParagraphs: ranges.length,\n                            appliedStyle: range[\"@_AppliedParagraphStyle\"],\n                            // CRITICAL FIX: Pass down direct paragraph-level alignment\n                            paragraphAlignment: range[\"@_Justification\"] || range[\"@_Alignment\"]\n                        };\n                        // Track content length before\n                        const beforeLen = content.length;\n                        extractTextRecursively(range, depth + 1, paragraphContext);\n                        // Track content length after\n                        const afterLen = content.length;\n                        // If nothing was added, this is an empty paragraph: add a newline\n                        if (afterLen === beforeLen) {\n                            content += \"\\n\";\n                            formattedContent.push({\n                                text: \"\\n\",\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"empty-paragraph\",\n                                    source: \"empty ParagraphStyleRange\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Empty paragraph detected\",\n                                location: `ParagraphStyleRange[${index}]`\n                            });\n                        }\n                        // Add paragraph break between paragraphs (but not after the last one)\n                        if (index < ranges.length - 1) {\n                            const paragraphBreak = \"\\n\\n\"; // Use double newline for paragraph breaks\n                            content += paragraphBreak;\n                            formattedContent.push({\n                                text: paragraphBreak,\n                                formatting: {\n                                    isBreak: true,\n                                    breakType: \"paragraph\",\n                                    source: \"between paragraphs\"\n                                }\n                            });\n                            debugInfo.push({\n                                type: \"Paragraph break\",\n                                location: `between paragraphs ${index} and ${index + 1}`\n                            });\n                        }\n                    });\n                    return;\n                }\n                // Handle direct Content elements (when not inside CharacterStyleRange)\n                if (element.Content && !element.CharacterStyleRange) {\n                    let text = Array.isArray(element.Content) ? element.Content.join(\"\") : String(element.Content);\n                    text = IDMLUtils.decodeXMLEntities(text);\n                    content += text;\n                    const formatting = {\n                        paragraphStyle: element[\"@_AppliedParagraphStyle\"] || context.appliedStyle || null,\n                        characterStyle: element[\"@_AppliedCharacterStyle\"] || null,\n                        fontSize: element[\"@_PointSize\"] || null,\n                        fontFamily: element[\"@_AppliedFont\"] || null,\n                        fillColor: element[\"@_FillColor\"] || null,\n                        // CRITICAL FIX: Inherit paragraph alignment from context if not explicitly set\n                        alignment: element[\"@_Justification\"] || element[\"@_Alignment\"] || context.paragraphAlignment || null\n                    };\n                    const resolvedFormatting = this.styleParser.resolveStyleFormatting(formatting);\n                    formattedContent.push({\n                        text: text.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                        formatting: resolvedFormatting\n                    });\n                }\n                // ENHANCED: Direct Br element handling (outside of ranges)\n                if (element.Br !== undefined) {\n                    const brElements = Array.isArray(element.Br) ? element.Br : [\n                        element.Br\n                    ];\n                    console.log(`ðŸ”§ Processing ${brElements.length} direct Br elements:`, brElements);\n                    brElements.forEach((br, index)=>{\n                        const lineBreakText = \"\\n\";\n                        console.log(`ðŸ”§ Direct Br element ${index + 1}/${brElements.length} creates: ${JSON.stringify(lineBreakText)}`);\n                        content += lineBreakText;\n                        formattedContent.push({\n                            text: lineBreakText,\n                            formatting: {\n                                isBreak: true,\n                                breakType: \"explicit\",\n                                source: \"direct Br element\"\n                            }\n                        });\n                        debugInfo.push({\n                            type: \"Direct Br element\",\n                            location: `Direct element, index ${index}`\n                        });\n                    });\n                    console.log(`ðŸ”§ After processing ${brElements.length} direct Br elements, content ends with:`, JSON.stringify(content.slice(-10)));\n                }\n                // Continue with other nested elements\n                Object.entries(element).forEach(([key, value])=>{\n                    if (!key.startsWith(\"@_\") && key !== \"Content\" && key !== \"Br\" && key !== \"CharacterStyleRange\" && key !== \"ParagraphStyleRange\") {\n                        if (Array.isArray(value)) {\n                            value.forEach((item)=>extractTextRecursively(item, depth + 1, context));\n                        } else if (typeof value === \"object\" && depth < 10) {\n                            extractTextRecursively(value, depth + 1, context);\n                        }\n                    }\n                });\n            }\n        };\n        extractTextRecursively(storyData);\n        // DEBUG: Print the full raw content string with visible newlines before processing\n        console.log(\"\\uD83D\\uDCDD === COMPLETE CONTENT ANALYSIS ===\");\n        console.log(\"   - Raw content before processing:\", JSON.stringify(content));\n        console.log(\"   - Raw content newline count:\", (content.match(/\\n/g) || []).length);\n        console.log(\"   - Raw content character breakdown:\");\n        const chars = content.split(\"\").map((char, i)=>`${i}: ${JSON.stringify(char)}`);\n        console.log(\"   - First 50 characters:\", chars.slice(0, 50));\n        if (content.length > 50) {\n            console.log(\"   - Last 20 characters:\", chars.slice(-20));\n        }\n        // ENHANCED: Process and clean up the content with sophisticated line break preservation\n        let processedContent = IDMLUtils.sophisticatedLineBreakProcessing(content);\n        // CRITICAL: Explicitly preserve all newlines as-is (no merging or stripping)\n        processedContent = processedContent.replace(/\\r\\n?/g, \"\\n\"); // Normalize CRLF/CR to LF\n        // Do NOT collapse multiple newlines into one; preserve as-is\n        console.log(\"\\uD83D\\uDCDD === PROCESSED CONTENT ANALYSIS ===\");\n        console.log(\"   - Processed content:\", JSON.stringify(processedContent));\n        console.log(\"   - Processed content newline count:\", (processedContent.match(/\\n/g) || []).length);\n        console.log(\"   - Content length change:\", content.length, \"â†’\", processedContent.length);\n        // Show differences if any\n        if (content !== processedContent) {\n            console.log(\"âš ï¸  CONTENT WAS MODIFIED DURING PROCESSING!\");\n            console.log(\"   - Original:\", JSON.stringify(content.slice(0, 100)));\n            console.log(\"   - Processed:\", JSON.stringify(processedContent.slice(0, 100)));\n        } else {\n            console.log(\"âœ… Content preserved exactly during processing\");\n        }\n        // DEBUG: Log space preservation results\n        console.log(\"\\uD83D\\uDCDD Text extraction results:\");\n        console.log(\"   - Original content length:\", content.length);\n        console.log(\"   - Processed content length:\", processedContent.length);\n        console.log(\"   - Space preservation events:\", debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length);\n        // DEBUG: Show first 300 chars with visible newlines\n        console.log(\"   - Extracted text preview:\", JSON.stringify(processedContent.slice(0, 300)));\n        // SPECIFIC DEBUG: Check for the problematic \"pavoluptusda\" text (simplified)\n        if (processedContent.includes(\"pavoluptusda\") || processedContent.includes(\"pa\") && processedContent.includes(\"voluptusda\")) {\n            console.log(\"\\uD83D\\uDEA8 FOUND PROBLEMATIC TEXT:\");\n            console.log('   - Contains \"pavoluptusda\":', processedContent.includes(\"pavoluptusda\"));\n            console.log('   - Contains \"pa voluptusda\":', processedContent.includes(\"pa voluptusda\"));\n            console.log(\"   - FormattedContent breakdown:\", formattedContent.map((item)=>item.text).join(\"|\"));\n        }\n        const lineBreakInfo = {\n            hasLineBreaks: processedContent.includes(\"\\n\"),\n            lineBreakCount: (processedContent.match(/\\n/g) || []).length,\n            lineBreakTypes: this.analyzeLineBreakTypes(formattedContent),\n            debugInfo: debugInfo,\n            spacePreservationCount: debugInfo.filter((info)=>info.type.includes(\"Space inserted\")).length\n        };\n        return {\n            plainText: processedContent,\n            formattedContent: formattedContent.filter((item)=>item.text && item.text.length > 0),\n            wordCount: IDMLUtils.countWords(processedContent.replace(/\\n/g, \" \")),\n            characterCount: processedContent.length,\n            textColor: textColor,\n            lineBreakInfo: lineBreakInfo\n        };\n    }\n    // NEW: Process CharacterStyleRange content and breaks in document order - FULLY DYNAMIC\n    processCharacterRangeInOrder(range, resolvedFormatting, rangeIndex, totalRanges, content, formattedContent, debugInfo, context, fileName) {\n        console.log(`ðŸ”§ Processing CharacterStyleRange[${rangeIndex}] in document order:`, {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentType: Array.isArray(range.Content) ? \"array\" : typeof range.Content,\n            brType: Array.isArray(range.Br) ? \"array\" : typeof range.Br\n        });\n        // COMPREHENSIVE EDGE CASE HANDLING\n        try {\n            // Case 1: Both Content and Br elements exist - most common case\n            if (range.Content && range.Br !== undefined) {\n                console.log(`ðŸ”§ Processing range with both content and breaks`);\n                return this.processInterleavedContentAndBr(range, resolvedFormatting, content, formattedContent, debugInfo, fileName);\n            } else if (range.Content && range.Br === undefined) {\n                console.log(`ðŸ”§ Processing range with only content`);\n                return this.processContentElements(range, resolvedFormatting, content, formattedContent, fileName);\n            } else if (!range.Content && range.Br !== undefined) {\n                console.log(`ðŸ”§ Processing range with only breaks`);\n                return this.processBrElements(range, content, formattedContent, debugInfo, rangeIndex, fileName);\n            } else {\n                console.log(`âš ï¸ Empty range encountered - no content or breaks`);\n                return content;\n            }\n        } catch (error) {\n            // ULTIMATE FALLBACK: If anything goes wrong, try to salvage what we can\n            console.log(`âŒ Error processing CharacterStyleRange[${rangeIndex}]: ${error.message}`);\n            console.log(`ðŸ”„ Attempting emergency content extraction...`);\n            return this.emergencyContentExtraction(range, resolvedFormatting, content, formattedContent, fileName);\n        }\n    }\n    // EMERGENCY FALLBACK: Extract content from malformed or unexpected XML structures\n    emergencyContentExtraction(range, resolvedFormatting, content, formattedContent, fileName) {\n        console.log(`ðŸš¨ Emergency content extraction for unusual XML structure`);\n        try {\n            // Try to extract any text content using different approaches\n            const extractedTexts = [];\n            const extractedBreaks = [];\n            // Approach 1: Direct property access\n            if (range.Content) {\n                const contents = Array.isArray(range.Content) ? range.Content : [\n                    range.Content\n                ];\n                contents.forEach((c)=>{\n                    if (typeof c === \"string\" && c.trim()) {\n                        extractedTexts.push(c.trim());\n                    }\n                });\n            }\n            // Approach 2: Search for any text-like properties\n            Object.keys(range).forEach((key)=>{\n                if (typeof range[key] === \"string\" && range[key].trim() && key !== \"@_Self\" && !key.startsWith(\"@_\")) {\n                    extractedTexts.push(range[key].trim());\n                }\n            });\n            // Approach 3: Count any break-like properties\n            if (range.Br !== undefined) {\n                const breaks = Array.isArray(range.Br) ? range.Br : [\n                    range.Br\n                ];\n                extractedBreaks.push(...breaks);\n            }\n            // Add extracted content\n            extractedTexts.forEach((text, index)=>{\n                const cleanText = IDMLUtils.decodeXMLEntities(text);\n                content += cleanText;\n                formattedContent.push({\n                    text: cleanText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                    formatting: resolvedFormatting\n                });\n                console.log(`ðŸš¨ Emergency extracted content[${index}]: ${JSON.stringify(cleanText)}`);\n                // Add breaks between content items (simple 1:1 ratio)\n                if (index < extractedBreaks.length) {\n                    const lineBreakText = \"\\n\";\n                    content += lineBreakText;\n                    formattedContent.push({\n                        text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                        formatting: {\n                            isBreak: true,\n                            breakType: \"line\",\n                            source: \"emergency extraction\",\n                            emergencyIndex: index\n                        }\n                    });\n                    console.log(`ðŸš¨ Emergency extracted break[${index}]: ${JSON.stringify(lineBreakText)}`);\n                }\n            });\n            // Add any remaining breaks at the end\n            for(let i = extractedTexts.length; i < extractedBreaks.length; i++){\n                const lineBreakText = \"\\n\";\n                content += lineBreakText;\n                formattedContent.push({\n                    text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                    formatting: {\n                        isBreak: true,\n                        breakType: \"line\",\n                        source: \"emergency trailing break\",\n                        emergencyIndex: i\n                    }\n                });\n                console.log(`ðŸš¨ Emergency extracted trailing break[${i}]: ${JSON.stringify(lineBreakText)}`);\n            }\n            console.log(`âœ… Emergency extraction successful: ${extractedTexts.length} texts, ${extractedBreaks.length} breaks`);\n        } catch (emergencyError) {\n            console.log(`ðŸ’€ Emergency extraction failed: ${emergencyError.message}`);\n            // Last resort: just add a warning comment\n            const warningText = \"<!-- XML parsing error -->\";\n            content += warningText;\n            formattedContent.push({\n                text: warningText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: resolvedFormatting\n            });\n        }\n        return content;\n    }\n    // Process interleaved Content and Br elements - FULLY DYNAMIC\n    processInterleavedContentAndBr(range, resolvedFormatting, content, formattedContent, debugInfo, fileName) {\n        const contents = Array.isArray(range.Content) ? range.Content : [\n            range.Content\n        ];\n        const brElements = Array.isArray(range.Br) ? range.Br : [\n            range.Br\n        ];\n        console.log(`ðŸ”§ Processing interleaved content: ${contents.length} content items, ${brElements.length} Br elements`);\n        // EDGE CASE: No content or breaks\n        if (!range.Content && !range.Br) {\n            console.log(`âš ï¸ No content or breaks to process in range`);\n            return content;\n        }\n        // EDGE CASE: Only content, no breaks\n        if (range.Content && !range.Br) {\n            console.log(`ðŸ“ Only content, no breaks - processing content only`);\n            return this.processContentElements(range, resolvedFormatting, content, formattedContent, fileName);\n        }\n        // EDGE CASE: Only breaks, no content\n        if (!range.Content && range.Br) {\n            console.log(`ðŸ”— Only breaks, no content - processing breaks only`);\n            return this.processBrElements(range, content, formattedContent, debugInfo, 0, fileName);\n        }\n        // DYNAMIC: Try to use cached document order if available\n        const cachedOrder = this.documentOrderCache && this.documentOrderCache[fileName];\n        if (cachedOrder && cachedOrder.breakPattern && cachedOrder.breakPattern.length > 0) {\n            console.log(`âœ… Using cached document order for precise break distribution`);\n            try {\n                return this.processContentWithCachedPattern(contents, resolvedFormatting, content, formattedContent, cachedOrder.breakPattern, fileName);\n            } catch (error) {\n                console.log(`âŒ Error using cached pattern: ${error.message}, falling back to dynamic distribution`);\n            }\n        } else {\n            console.log(`âš ï¸ No cached document order available, using dynamic fallback distribution`);\n        }\n        // DYNAMIC FALLBACK: Distribute breaks intelligently based on content structure\n        return this.processInterleavedContentDynamicFallback(contents, brElements, resolvedFormatting, content, formattedContent, fileName);\n    }\n    // DYNAMIC FALLBACK: Intelligent break distribution for any content structure\n    processInterleavedContentDynamicFallback(contents, brElements, resolvedFormatting, content, formattedContent, fileName) {\n        console.log(`ðŸ”„ Using dynamic fallback for ${contents.length} content items and ${brElements.length} breaks`);\n        let brIndex = 0;\n        const contentLength = contents.length;\n        contents.forEach((contentItem, contentIndex)=>{\n            // Add the content\n            const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n            content += text;\n            formattedContent.push({\n                text: text.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: resolvedFormatting\n            });\n            console.log(`ðŸ”§ Added content[${contentIndex}]: ${JSON.stringify(text)}`);\n            // DYNAMIC: Calculate how many breaks to add after this content\n            const breaksToAdd = this.calculateBreaksAfterContent(contentIndex, contentLength, brElements.length);\n            // Add the calculated number of breaks\n            for(let i = 0; i < breaksToAdd && brIndex < brElements.length; i++){\n                const lineBreakText = \"\\n\";\n                content += lineBreakText;\n                formattedContent.push({\n                    text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                    formatting: {\n                        isBreak: true,\n                        breakType: \"line\",\n                        source: \"dynamic fallback distribution\",\n                        brIndex: brIndex,\n                        afterContent: contentIndex,\n                        calculatedBreaks: breaksToAdd\n                    }\n                });\n                console.log(`ðŸ”§ Added Br[${brIndex}] after content[${contentIndex}]: ${JSON.stringify(lineBreakText)}`);\n                brIndex++;\n            }\n        });\n        // EDGE CASE: Handle any remaining breaks\n        if (brIndex < brElements.length) {\n            const remainingBreaks = brElements.length - brIndex;\n            console.log(`ðŸ”§ Adding ${remainingBreaks} remaining breaks at the end`);\n            while(brIndex < brElements.length){\n                const lineBreakText = \"\\n\";\n                content += lineBreakText;\n                formattedContent.push({\n                    text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                    formatting: {\n                        isBreak: true,\n                        breakType: \"line\",\n                        source: \"trailing breaks (dynamic fallback)\",\n                        brIndex: brIndex\n                    }\n                });\n                console.log(`ðŸ”§ Added trailing Br[${brIndex}]: ${JSON.stringify(lineBreakText)}`);\n                brIndex++;\n            }\n        }\n        // VALIDATION: Ensure all breaks were processed\n        if (brIndex !== brElements.length) {\n            console.log(`âš ï¸ Warning: Expected to process ${brElements.length} breaks but processed ${brIndex}`);\n        }\n        return content;\n    }\n    // Process content using cached document order pattern - FULLY DYNAMIC\n    processContentWithCachedPattern(contents, resolvedFormatting, content, formattedContent, breakPattern, fileName) {\n        console.log(`ðŸŽ¯ Processing ${contents.length} content items with cached pattern (${breakPattern.length} pattern entries)`);\n        // DYNAMIC: Handle any number of content items and any break distribution\n        contents.forEach((contentItem, contentIndex)=>{\n            // Add the content\n            const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n            content += text;\n            formattedContent.push({\n                text: text.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: resolvedFormatting\n            });\n            console.log(`ðŸ”§ Added content[${contentIndex}]: ${JSON.stringify(text)}`);\n            // DYNAMIC: Find the corresponding pattern entry\n            const patternEntry = breakPattern.find((p)=>p.contentIndex === contentIndex);\n            if (patternEntry) {\n                const breaksToAdd = patternEntry.breaksAfter;\n                console.log(`ðŸŽ¯ Pattern says content[${contentIndex}] should have ${breaksToAdd} breaks after it`);\n                // DYNAMIC: Add the exact number of breaks specified in the pattern\n                for(let i = 0; i < breaksToAdd; i++){\n                    const lineBreakText = \"\\n\";\n                    content += lineBreakText;\n                    formattedContent.push({\n                        text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                        formatting: {\n                            isBreak: true,\n                            breakType: \"line\",\n                            source: \"precise document order\",\n                            contentIndex: contentIndex,\n                            breakIndex: i,\n                            totalBreaksAfterContent: breaksToAdd,\n                            patternEntry: patternEntry\n                        }\n                    });\n                    console.log(`ðŸŽ¯ Added precise Br[${i + 1}/${breaksToAdd}] after content[${contentIndex}]: ${JSON.stringify(lineBreakText)}`);\n                }\n            } else {\n                console.log(`âš ï¸ No pattern entry found for content[${contentIndex}] - this is unusual but not critical`);\n            // DYNAMIC: If no pattern entry, don't add any breaks (the pattern should cover all content)\n            }\n        });\n        // VALIDATION: Check if we processed all expected content\n        const expectedContentCount = breakPattern.length;\n        if (contents.length !== expectedContentCount) {\n            console.log(`âš ï¸ Warning: Expected ${expectedContentCount} content items but processed ${contents.length}`);\n        }\n        return content;\n    }\n    // DYNAMIC: Calculate breaks distribution as fallback - completely generic\n    calculateBreaksAfterContent(contentIndex, totalContent, totalBreaks) {\n        console.log(`ðŸ”§ FALLBACK: Calculating breaks for content[${contentIndex}] of ${totalContent} total, ${totalBreaks} total breaks`);\n        // EDGE CASE: No breaks to distribute\n        if (totalBreaks === 0) {\n            console.log(`ðŸ”§ No breaks to distribute`);\n            return 0;\n        }\n        // EDGE CASE: Only one content item\n        if (totalContent === 1) {\n            console.log(`ðŸ”§ Single content item gets all ${totalBreaks} breaks`);\n            return contentIndex === 0 ? totalBreaks : 0;\n        }\n        // EDGE CASE: Last content item\n        if (contentIndex === totalContent - 1) {\n            console.log(`ðŸ”§ Last content item gets no breaks in standard distribution`);\n            return 0;\n        }\n        // DYNAMIC: Distribute breaks among non-last content items\n        const nonLastContentItems = totalContent - 1;\n        const baseBreaks = Math.floor(totalBreaks / nonLastContentItems);\n        const extraBreaks = totalBreaks % nonLastContentItems;\n        // DYNAMIC: Distribute extra breaks starting from the end to match common IDML patterns\n        // where later content tends to have more breaks\n        const breaksForThisContent = baseBreaks + (contentIndex >= nonLastContentItems - extraBreaks ? 1 : 0);\n        console.log(`ðŸ”§ Content[${contentIndex}] gets ${breaksForThisContent} breaks (base: ${baseBreaks}, extra: ${extraBreaks})`);\n        return breaksForThisContent;\n    }\n    // Process only Content elements\n    processContentElements(range, resolvedFormatting, content, formattedContent, fileName) {\n        const contents = Array.isArray(range.Content) ? range.Content : [\n            range.Content\n        ];\n        contents.forEach((contentItem)=>{\n            const text = IDMLUtils.decodeXMLEntities(String(contentItem));\n            content += text;\n            formattedContent.push({\n                text: text.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: resolvedFormatting\n            });\n        });\n        return content;\n    }\n    // Process only Br elements\n    processBrElements(range, content, formattedContent, debugInfo, rangeIndex, fileName) {\n        const brElements = Array.isArray(range.Br) ? range.Br : [\n            range.Br\n        ];\n        brElements.forEach((br, brIndex)=>{\n            const lineBreakText = \"\\n\";\n            content += lineBreakText;\n            formattedContent.push({\n                text: lineBreakText.replace(/\\u2028/g, \"\\n\").replace(/\\u2029/g, \"\\n\\n\"),\n                formatting: {\n                    isBreak: true,\n                    breakType: \"line\",\n                    source: \"standalone Br element\",\n                    rangeIndex: rangeIndex,\n                    brIndex: brIndex\n                }\n            });\n            debugInfo.push({\n                type: \"Standalone Br element\",\n                location: `CharacterStyleRange[${rangeIndex}], Br[${brIndex}]`\n            });\n        });\n        return content;\n    }\n    // Add this helper method to better handle mixed content and Br elements\n    analyzeContentStructure(range) {\n        const structure = {\n            hasContent: !!range.Content,\n            hasBr: range.Br !== undefined,\n            contentItems: range.Content ? Array.isArray(range.Content) ? range.Content : [\n                range.Content\n            ] : [],\n            brElements: range.Br ? Array.isArray(range.Br) ? range.Br : [\n                range.Br\n            ] : []\n        };\n        console.log(\"Content structure analysis:\", structure);\n        return structure;\n    }\n    // Enhanced helper for processing interleaved content and breaks\n    processInterleavedContent(range, resolvedFormatting) {\n        const results = [];\n        let content = \"\";\n        // This method would need access to the actual XML structure to determine\n        // the exact order of Content and Br elements. For now, we'll use the\n        // approach above which handles the most common case.\n        return results;\n    }\n    // SOPHISTICATED: Helper method to extract Br elements with context\n    extractBrElements(range) {\n        const brElements = [];\n        if (range.Br !== undefined) {\n            console.log(\"\\uD83D\\uDD27 Processing Br elements:\", {\n                isArray: Array.isArray(range.Br),\n                count: Array.isArray(range.Br) ? range.Br.length : 1,\n                rawBr: range.Br\n            });\n            if (Array.isArray(range.Br)) {\n                range.Br.forEach((br, index)=>{\n                    brElements.push({\n                        type: \"line\",\n                        position: index === 0 ? \"start\" : \"middle\",\n                        element: br\n                    });\n                });\n                console.log(`ðŸ”§ Created ${brElements.length} line break elements from array - EACH SHOULD CREATE ONE \\\\n`);\n            } else {\n                brElements.push({\n                    type: \"line\",\n                    position: \"end\",\n                    element: range.Br\n                });\n                console.log(\"\\uD83D\\uDD27 Created 1 line break element from single Br\");\n            }\n        }\n        return brElements;\n    }\n    // SOPHISTICATED: Determine the appropriate line break type\n    determineLineBreakType(brInfo, context) {\n        // Different line break characters based on context\n        switch(brInfo.type){\n            case \"paragraph\":\n                return \"\\n\\n\"; // Double line break for paragraph separation\n            case \"forced\":\n                return \"\\n\"; // Forced line break (Shift+Enter equivalent)\n            case \"line\":\n            default:\n                return \"\\n\"; // Standard line break\n        }\n    }\n    // SOPHISTICATED: Determine if an implicit line break should be inserted\n    shouldInsertImplicitLineBreak(currentRange, nextRange, context) {\n        // Don't insert implicit breaks if explicit Br elements are present\n        if (currentRange.Br !== undefined || nextRange.Br !== undefined) {\n            return false;\n        }\n        // Insert breaks between different character styles in different paragraphs\n        const currentCharStyle = currentRange[\"@_AppliedCharacterStyle\"];\n        const nextCharStyle = nextRange[\"@_AppliedCharacterStyle\"];\n        // If we're in a context where styles change significantly, add a break\n        if (currentCharStyle && nextCharStyle && currentCharStyle !== nextCharStyle) {\n            // Check if this might be a title/heading followed by body text\n            const styleIndicatesBreak = this.styleIndicatesLineBreak(currentCharStyle, nextCharStyle);\n            return styleIndicatesBreak;\n        }\n        return false;\n    }\n    // SOPHISTICATED: Analyze if style change indicates a line break\n    styleIndicatesLineBreak(currentStyle, nextStyle) {\n        const titleIndicators = [\n            \"title\",\n            \"heading\",\n            \"header\"\n        ];\n        const bodyIndicators = [\n            \"body\",\n            \"text\",\n            \"normal\"\n        ];\n        const currentIsTitle = titleIndicators.some((indicator)=>currentStyle.toLowerCase().includes(indicator));\n        const nextIsBody = bodyIndicators.some((indicator)=>nextStyle.toLowerCase().includes(indicator));\n        return currentIsTitle && nextIsBody;\n    }\n    // SOPHISTICATED: Analyze line break types in formatted content\n    analyzeLineBreakTypes(formattedContent) {\n        const types = {\n            explicit: 0,\n            implicit: 0,\n            paragraph: 0,\n            direct: 0\n        };\n        formattedContent.forEach((item)=>{\n            if (item.formatting?.isBreak) {\n                const breakType = item.formatting.breakType || \"unknown\";\n                if (types.hasOwnProperty(breakType)) {\n                    types[breakType]++;\n                }\n            }\n        });\n        return types;\n    }\n    extractDetailedFormattingFromRange(range) {\n        const formatting = {};\n        // Extract all possible font attributes\n        const fontAttributes = [\n            \"@_AppliedFont\",\n            \"@_FontFamily\",\n            \"@_Font\",\n            \"@_PostScriptName\",\n            \"@_FontName\"\n        ];\n        fontAttributes.forEach((attr)=>{\n            if (range[attr]) {\n                formatting.fontReference = range[attr];\n            }\n        });\n        // Extract font and size attributes\n        const rawFontSize = IDMLUtils.parseNumeric(range[\"@_PointSize\"]);\n        formatting.fontSize = this.convertFontSizeToPixels(rawFontSize); // ADDED: Convert to pixels\n        formatting.originalFontSize = rawFontSize; // ADDED: Preserve original\n        // ENHANCED: Extract leading with proper processing\n        const rawLeading = range[\"@_Leading\"];\n        formatting.leading = this.processLeadingValue(rawLeading, formatting.fontSize);\n        formatting.leadingType = this.determineLeadingType(rawLeading);\n        // Extract color and style attributes\n        formatting.fillColor = range[\"@_FillColor\"];\n        formatting.strokeColor = range[\"@_StrokeColor\"];\n        formatting.fontStyle = range[\"@_FontStyle\"];\n        // Extract advanced typography attributes\n        formatting.tracking = IDMLUtils.parseNumeric(range[\"@_Tracking\"]);\n        formatting.baselineShift = IDMLUtils.parseNumeric(range[\"@_BaselineShift\"]);\n        formatting.kerning = IDMLUtils.parseNumeric(range[\"@_Kerning\"]);\n        formatting.horizontalScale = IDMLUtils.parseNumeric(range[\"@_HorizontalScale\"]) || 100;\n        formatting.verticalScale = IDMLUtils.parseNumeric(range[\"@_VerticalScale\"]) || 100;\n        // ENHANCED: Extract InDesign-specific text layout properties for precise rendering\n        formatting.baselineGridAlign = range[\"@_AlignToBaseline\"] || \"None\";\n        formatting.dropCapLines = IDMLUtils.parseNumeric(range[\"@_DropCapLines\"]) || 0;\n        formatting.dropCapCharacters = IDMLUtils.parseNumeric(range[\"@_DropCapCharacters\"]) || 0;\n        // Extract paragraph-level attributes if present\n        // CRITICAL FIX: Only set alignment if explicitly specified, allowing paragraph inheritance\n        const explicitAlignment = range[\"@_Justification\"] || range[\"@_Alignment\"];\n        if (explicitAlignment) {\n            formatting.alignment = explicitAlignment;\n        }\n        formatting.leftIndent = IDMLUtils.parseNumeric(range[\"@_LeftIndent\"]);\n        formatting.rightIndent = IDMLUtils.parseNumeric(range[\"@_RightIndent\"]);\n        formatting.firstLineIndent = IDMLUtils.parseNumeric(range[\"@_FirstLineIndent\"]);\n        formatting.spaceBefore = IDMLUtils.parseNumeric(range[\"@_SpaceBefore\"]);\n        formatting.spaceAfter = IDMLUtils.parseNumeric(range[\"@_SpaceAfter\"]);\n        // Calculate effective line height for CSS\n        formatting.effectiveLineHeight = this.calculateEffectiveLineHeight(formatting);\n        return formatting;\n    }\n    // FIXED: Process leading values with InDesign-specific logic and convert to pixels\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points) - FIXED: Convert to pixels\n        const numericLeading = IDMLUtils.parseNumeric(rawLeading);\n        if (numericLeading) {\n            // FIXED: Convert numeric leading to pixels if unitConverter is available\n            if (this.unitConverter && this.documentUnits && this.unitConverter.isSupportedUnit(this.documentUnits)) {\n                const pixelLeading = this.unitConverter.toPixels(numericLeading, this.documentUnits);\n                console.log(`ðŸ“ Converted leading: ${numericLeading} ${this.documentUnits} â†’ ${pixelLeading} px`);\n                return pixelLeading;\n            }\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (IDMLUtils.parseNumeric(rawLeading)) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(formatting) {\n        const fontSize = formatting.fontSize || 12;\n        const leading = formatting.leading;\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\") {\n            // Convert points to CSS line-height ratio\n            return leading / fontSize;\n        }\n        return 1.2; // Fallback\n    }\n    extractTextFormatting(storyData) {\n        const formatting = {\n            paragraphStyles: [],\n            characterStyles: [],\n            appliedStyles: []\n        };\n        // Extract applied paragraph styles\n        if (storyData.ParagraphStyleRange) {\n            const ranges = Array.isArray(storyData.ParagraphStyleRange) ? storyData.ParagraphStyleRange : [\n                storyData.ParagraphStyleRange\n            ];\n            ranges.forEach((range)=>{\n                const appliedStyle = range[\"@_AppliedParagraphStyle\"];\n                if (appliedStyle && !formatting.paragraphStyles.includes(appliedStyle)) {\n                    formatting.paragraphStyles.push(appliedStyle);\n                }\n                // Extract character styles within paragraph ranges\n                if (range.CharacterStyleRange) {\n                    const charRanges = Array.isArray(range.CharacterStyleRange) ? range.CharacterStyleRange : [\n                        range.CharacterStyleRange\n                    ];\n                    charRanges.forEach((charRange)=>{\n                        const charStyle = charRange[\"@_AppliedCharacterStyle\"];\n                        if (charStyle && !formatting.characterStyles.includes(charStyle)) {\n                            formatting.characterStyles.push(charStyle);\n                        }\n                    });\n                }\n            });\n        }\n        return formatting;\n    }\n    // Add this method to debug raw story content\n    debugRawStoryContent(storyData) {\n        console.log(\"\\n\\uD83D\\uDD0D RAW STORY CONTENT DEBUG:\");\n        console.log(\"Story keys:\", Object.keys(storyData));\n        const findCharacterRanges = (obj, path = \"\")=>{\n            if (typeof obj === \"object\" && obj !== null) {\n                Object.keys(obj).forEach((key)=>{\n                    if (key === \"CharacterStyleRange\") {\n                        console.log(`\\nðŸ“ Found CharacterStyleRange at ${path}:`, obj[key]);\n                        const ranges = Array.isArray(obj[key]) ? obj[key] : [\n                            obj[key]\n                        ];\n                        ranges.forEach((range, index)=>{\n                            console.log(`  Range ${index + 1} attributes:`, Object.keys(range).filter((k)=>k.startsWith(\"@_\")));\n                            console.log(`  Range ${index + 1} font info:`, {\n                                AppliedFont: range[\"@_AppliedFont\"],\n                                FontStyle: range[\"@_FontStyle\"],\n                                PointSize: range[\"@_PointSize\"]\n                            });\n                        });\n                    } else if (typeof obj[key] === \"object\") {\n                        findCharacterRanges(obj[key], `${path}.${key}`);\n                    }\n                });\n            }\n        };\n        findCharacterRanges(storyData);\n    }\n    // ADD DEBUGGING FOR PARSED BR STRUCTURE\n    debugBrElementsInParsedStructure(parsedData, path = \"\") {\n        if (typeof parsedData === \"object\" && parsedData !== null) {\n            Object.entries(parsedData).forEach(([key, value])=>{\n                if (key === \"Br\") {\n                    console.log(`${path} has Br element:`, value);\n                } else if (typeof value === \"object\" && value !== null) {\n                    this.debugBrElementsInParsedStructure(value, `${path}.${key}`);\n                }\n            });\n        }\n    }\n    // CRITICAL FIX: Parse raw XML to preserve exact document order - FULLY DYNAMIC\n    parseRawXMLForDocumentOrder(rawXMLContent, fileName) {\n        console.log(`ðŸ” Parsing raw XML for document order: ${fileName}`);\n        // DYNAMIC: Handle multiple CharacterStyleRange elements\n        const charRangePattern = /<CharacterStyleRange[^>]*>(.*?)<\\/CharacterStyleRange>/gs;\n        const charRangeMatches = [\n            ...rawXMLContent.matchAll(charRangePattern)\n        ];\n        if (charRangeMatches.length === 0) {\n            console.log(\"âŒ No CharacterStyleRange found in XML\");\n            return null;\n        }\n        console.log(`ðŸ“„ Found ${charRangeMatches.length} CharacterStyleRange elements`);\n        // DYNAMIC: Process all CharacterStyleRange elements\n        const allDocumentOrder = [];\n        charRangeMatches.forEach((match, rangeIndex)=>{\n            const charRangeContent = match[1];\n            console.log(`ðŸ“„ Processing CharacterStyleRange[${rangeIndex}]:`, charRangeContent.substring(0, 200) + \"...\");\n            // ENHANCED: More flexible pattern to handle different XML structures\n            // Matches: <Content>text</Content>, <Content/>, <Br/>, <Br></Br>, <Br />\n            const elementPattern = /<(Content|Br)(?:\\s+[^>]*)?>([^<]*)<\\/\\1>|<(Content|Br)(?:\\s+[^>]*)?\\/?>|<(Content|Br)(?:\\s+[^>]*)?>([^<]*)/g;\n            let elementMatch;\n            const rangeElements = [];\n            while((elementMatch = elementPattern.exec(charRangeContent)) !== null){\n                const elementType = elementMatch[1] || elementMatch[3] || elementMatch[4];\n                const elementContent = elementMatch[2] || elementMatch[5] || \"\";\n                if (elementType === \"Content\") {\n                    const contentText = elementContent.trim();\n                    if (contentText) {\n                        // Only add non-empty content\n                        rangeElements.push({\n                            type: \"Content\",\n                            text: contentText,\n                            rangeIndex: rangeIndex\n                        });\n                        console.log(`ðŸ“ Found Content[${rangeIndex}]: \"${contentText}\"`);\n                    }\n                } else if (elementType === \"Br\") {\n                    rangeElements.push({\n                        type: \"Br\",\n                        rangeIndex: rangeIndex\n                    });\n                    console.log(`ðŸ”— Found Br[${rangeIndex}]`);\n                }\n            }\n            // Add range elements to overall document order\n            allDocumentOrder.push(...rangeElements);\n        });\n        if (allDocumentOrder.length === 0) {\n            console.log(\"âŒ No Content or Br elements found in any CharacterStyleRange\");\n            return null;\n        }\n        // DYNAMIC: Analyze the break pattern for any structure\n        const breakPattern = this.analyzeBreakPatternDynamic(allDocumentOrder);\n        console.log(\"\\uD83D\\uDCCA Dynamic break pattern analysis:\", breakPattern);\n        // Store this for later use in processing\n        this.documentOrderCache = this.documentOrderCache || {};\n        this.documentOrderCache[fileName] = {\n            documentOrder: allDocumentOrder,\n            breakPattern: breakPattern,\n            totalCharacterRanges: charRangeMatches.length\n        };\n        return {\n            documentOrder: allDocumentOrder,\n            breakPattern: breakPattern,\n            totalCharacterRanges: charRangeMatches.length\n        };\n    }\n    // DYNAMIC: Analyze break pattern for any document structure\n    analyzeBreakPatternDynamic(documentOrder) {\n        const pattern = [];\n        let contentIndex = 0;\n        for(let i = 0; i < documentOrder.length; i++){\n            const element = documentOrder[i];\n            if (element.type === \"Content\") {\n                // DYNAMIC: Count consecutive breaks after this content\n                let breaksAfter = 0;\n                let j = i + 1;\n                // Count all consecutive Br elements following this Content\n                while(j < documentOrder.length && documentOrder[j].type === \"Br\"){\n                    breaksAfter++;\n                    j++;\n                }\n                pattern.push({\n                    contentIndex: contentIndex,\n                    contentText: element.text,\n                    breaksAfter: breaksAfter,\n                    rangeIndex: element.rangeIndex,\n                    documentPosition: i\n                });\n                console.log(`ðŸ“‹ Content[${contentIndex}] \"${element.text}\" has ${breaksAfter} breaks after it (doc pos: ${i})`);\n                contentIndex++;\n            }\n        }\n        // VALIDATION: Ensure pattern makes sense\n        const totalContent = pattern.length;\n        const totalBreaks = pattern.reduce((sum, p)=>sum + p.breaksAfter, 0);\n        console.log(`ðŸ” Pattern validation: ${totalContent} content items, ${totalBreaks} total breaks`);\n        if (totalContent === 0) {\n            console.log(\"âš ï¸ Warning: No content items found in pattern\");\n        }\n        return pattern;\n    }\n    getStories() {\n        return this.stories;\n    }\n    getStory(storyId) {\n        return this.stories[storyId];\n    }\n    clearStories() {\n        this.stories = {};\n    }\n}\nmodule.exports = StoryParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFjZ0csUUFBUUcsTUFBTSxDQUFDLENBQUNDLEtBQUsxRyxJQUFNMEcsTUFBTTFHLEVBQUVDLFdBQVcsRUFBRTtRQUVwRTdLLFFBQVFDLEdBQUcsQ0FDVCxDQUFDLHVCQUF1QixFQUFFZ0wsYUFBYSxnQkFBZ0IsRUFBRUMsWUFBWSxhQUFhLENBQUM7UUFHckYsSUFBSUQsaUJBQWlCLEdBQUc7WUFDdEJqTCxRQUFRQyxHQUFHLENBQUM7UUFDZDtRQUVBLE9BQU9pUjtJQUNUO0lBRUFLLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQzFSLE9BQU87SUFDckI7SUFFQTJSLFNBQVMxUSxPQUFPLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNqQixPQUFPLENBQUNpQixRQUFRO0lBQzlCO0lBRUEyUSxlQUFlO1FBQ2IsSUFBSSxDQUFDNVIsT0FBTyxHQUFHLENBQUM7SUFDbEI7QUFDRjtBQUVBNlIsT0FBT0MsT0FBTyxHQUFHblMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZG1sLXZpZXdlci8uL2xpYi9wYXJzZXJzL1N0b3J5UGFyc2VyLmpzPzY4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5jb25zdCBJRE1MVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvSURNTFV0aWxzXCIpO1xyXG5cclxuY2xhc3MgU3RvcnlQYXJzZXIge1xyXG4gIGNvbnN0cnVjdG9yKHN0eWxlUGFyc2VyLCB1bml0Q29udmVydGVyID0gbnVsbCkge1xyXG4gICAgdGhpcy5zdHlsZVBhcnNlciA9IHN0eWxlUGFyc2VyO1xyXG4gICAgdGhpcy51bml0Q29udmVydGVyID0gdW5pdENvbnZlcnRlcjsgLy8gQURERUQ6IFVuaXQgY29udmVydGVyIGZvciBmb250IHNpemVzIGFuZCBzcGFjaW5nXHJcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSBudWxsOyAvLyBXaWxsIGJlIHNldCBmcm9tIGRvY3VtZW50IHVuaXRzXHJcbiAgICB0aGlzLnN0b3JpZXMgPSB7fTtcclxuICB9XHJcblxyXG4gIC8vIEFEREVEOiBNZXRob2QgdG8gc2V0IGRvY3VtZW50IHVuaXRzIGZvciBmb250IHNpemUgY29udmVyc2lvblxyXG4gIHNldERvY3VtZW50VW5pdHModW5pdHMpIHtcclxuICAgIHRoaXMuZG9jdW1lbnRVbml0cyA9IHVuaXRzO1xyXG4gICAgY29uc29sZS5sb2coXCLwn5OQIFN0b3J5UGFyc2VyOiBTZXQgZG9jdW1lbnQgdW5pdHMgdG9cIiwgdW5pdHMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQURERUQ6IE1ldGhvZCB0byBjb252ZXJ0IGZvbnQgc2l6ZSB0byBwaXhlbHMgaWYgbmVlZGVkXHJcbiAgY29udmVydEZvbnRTaXplVG9QaXhlbHMoZm9udFNpemUpIHtcclxuICAgIGlmICghZm9udFNpemUgfHwgIXRoaXMudW5pdENvbnZlcnRlciB8fCAhdGhpcy5kb2N1bWVudFVuaXRzKSB7XHJcbiAgICAgIHJldHVybiBmb250U2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGb250IHNpemVzIGluIElETUwgYXJlIHR5cGljYWxseSBpbiBQb2ludHMsIGJ1dCBsZXQncyB1c2UgZG9jdW1lbnQgdW5pdHMgYXMgZmFsbGJhY2tcclxuICAgIGNvbnN0IGZvbnRVbml0cyA9IHRoaXMuZG9jdW1lbnRVbml0cyA9PT0gXCJQaXhlbHNcIiA/IFwiUGl4ZWxzXCIgOiBcIlBvaW50c1wiOyAvLyBGb250IHNpemVzIGFyZSB1c3VhbGx5IHBvaW50c1xyXG5cclxuICAgIGlmICh0aGlzLnVuaXRDb252ZXJ0ZXIuaXNTdXBwb3J0ZWRVbml0KGZvbnRVbml0cykpIHtcclxuICAgICAgY29uc3QgcGl4ZWxTaXplID0gdGhpcy51bml0Q29udmVydGVyLnRvUGl4ZWxzKGZvbnRTaXplLCBmb250VW5pdHMpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg8J+TkCBDb252ZXJ0ZWQgZm9udCBzaXplOiAke2ZvbnRTaXplfSAke2ZvbnRVbml0c30g4oaSICR7cGl4ZWxTaXplfSBweGBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHBpeGVsU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9udFNpemU7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwYXJzZVN0b3J5RmlsZShmaWxlTmFtZSwgY29udGVudCwgeG1sUGFyc2VyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TnSBQYXJzaW5nIHN0b3J5OiAke2ZpbGVOYW1lfWApO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZShjb250ZW50KTtcclxuICAgICAgY29uc3Qgc3RvcnlJZCA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUsIFwiLnhtbFwiKTtcclxuXHJcbiAgICAgIGNvbnN0IHN0b3J5RGF0YSA9IHBhcnNlZC5TdG9yeSB8fCBwYXJzZWQ7XHJcblxyXG4gICAgICAvLyBBREQgREVCVUdHSU5HIEZPUiBCUiBFTEVNRU5UUyBJTiBSQVcgWE1MXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiPT09IFJBVyBYTUwgQ09OVEVOVCBERUJVRyA9PT1cIik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiUmF3IFhNTCBjb250ZW50IHNhbXBsZTpcIiwgY29udGVudC5zdWJzdHJpbmcoMCwgMTAwMCkpO1xyXG5cclxuICAgICAgLy8gQ291bnQgQnIgZWxlbWVudHMgaW4gcmF3IFhNTFxyXG4gICAgICBjb25zdCBick1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKC88QnJbXj5dKj4vZykgfHwgW107XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBGb3VuZCAke2JyTWF0Y2hlcy5sZW5ndGh9IDxCcj4gZWxlbWVudHMgaW4gcmF3IFhNTDpgLFxyXG4gICAgICAgIGJyTWF0Y2hlc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gTG9vayBmb3IgY29uc2VjdXRpdmUgQnIgZWxlbWVudHNcclxuICAgICAgY29uc3QgY29uc2VjdXRpdmVCclBhdHRlcm4gPSAvKDxCcltePl0qPlxccyopezIsfS9nO1xyXG4gICAgICBjb25zdCBjb25zZWN1dGl2ZUJyTWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goY29uc2VjdXRpdmVCclBhdHRlcm4pIHx8IFtdO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgRm91bmQgJHtjb25zZWN1dGl2ZUJyTWF0Y2hlcy5sZW5ndGh9IGdyb3VwcyBvZiBjb25zZWN1dGl2ZSA8QnI+IGVsZW1lbnRzOmAsXHJcbiAgICAgICAgY29uc2VjdXRpdmVCck1hdGNoZXNcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIENSSVRJQ0FMIEZJWDogUGFyc2UgcmF3IFhNTCB0byBwcmVzZXJ2ZSBkb2N1bWVudCBvcmRlclxyXG4gICAgICB0aGlzLnBhcnNlUmF3WE1MRm9yRG9jdW1lbnRPcmRlcihjb250ZW50LCBmaWxlTmFtZSk7XHJcblxyXG4gICAgICAvLyBBREQgVEhFU0UgU0lNUExFIExPR1MgRklSU1Q6XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiPT09IFNJTVBMRSBERUJVRyBURVNUID09PVwiKTtcclxuICAgICAgY29uc29sZS5sb2coXCJTdG9yeSBmaWxlIG5hbWU6XCIsIGZpbGVOYW1lKTtcclxuICAgICAgY29uc29sZS5sb2coXCJQYXJzZWQgc3Rvcnkga2V5czpcIiwgT2JqZWN0LmtleXMoc3RvcnlEYXRhKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwiUmF3IHN0b3J5IGRhdGEgc2FtcGxlOlwiLFxyXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHN0b3J5RGF0YSwgbnVsbCwgMikuc3Vic3RyaW5nKDAsIDUwMClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEV4dHJhY3QgZGV0YWlsZWQgc3RvcnkgaW5mb3JtYXRpb25cclxuICAgICAgY29uc3QgZGV0YWlsZWRTdG9yeSA9IHtcclxuICAgICAgICBzZWxmOiBzdG9yeURhdGFbXCJAX1NlbGZcIl0sXHJcbiAgICAgICAgYXBwbGllZFRPQ1N0eWxlOiBzdG9yeURhdGFbXCJAX0FwcGxpZWRUT0NTdHlsZVwiXSB8fCBcIm5cIixcclxuICAgICAgICB1c2VyVGV4dDogc3RvcnlEYXRhW1wiQF9Vc2VyVGV4dFwiXSAhPT0gZmFsc2UsXHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3Qgc3RvcnkgY29udGVudCB3aXRoIGZvcm1hdHRpbmdcclxuICAgICAgICBjb250ZW50OiB0aGlzLmV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudChzdG9yeURhdGEsIGZpbGVOYW1lKSxcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCB0ZXh0IGZvcm1hdHRpbmdcclxuICAgICAgICB0ZXh0Rm9ybWF0dGluZzogdGhpcy5leHRyYWN0VGV4dEZvcm1hdHRpbmcoc3RvcnlEYXRhKSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEFERCBERUJVR0dJTkcgRk9SIFBBUlNFRCBCUiBTVFJVQ1RVUkVcclxuICAgICAgY29uc29sZS5sb2coXCI9PT0gUEFSU0VEIFhNTCBTVFJVQ1RVUkUgREVCVUcgPT09XCIpO1xyXG4gICAgICB0aGlzLmRlYnVnQnJFbGVtZW50c0luUGFyc2VkU3RydWN0dXJlKHN0b3J5RGF0YSwgXCJyb290XCIpO1xyXG5cclxuICAgICAgY29uc3QgY2xlYW5TdG9yeUlkID0gc3RvcnlJZC5yZXBsYWNlKFwiU3RvcnlfXCIsIFwiXCIpO1xyXG4gICAgICB0aGlzLnN0b3JpZXNbY2xlYW5TdG9yeUlkXSA9IGRldGFpbGVkU3Rvcnk7XHJcblxyXG4gICAgICAvLyBFbmhhbmNlZCBsb2dnaW5nIHRvIHNob3cgbGluZSBicmVha3NcclxuICAgICAgY29uc3QgeyBwbGFpblRleHQsIGxpbmVCcmVha0luZm8gfSA9IGRldGFpbGVkU3RvcnkuY29udGVudDtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBTdG9yeSAke3N0b3J5SWR9IHBhcnNlZDpgKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIC0gQ2hhcmFjdGVyczogJHtwbGFpblRleHQubGVuZ3RofWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBXb3JkczogJHtkZXRhaWxlZFN0b3J5LmNvbnRlbnQud29yZENvdW50fWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgLSBMaW5lIGJyZWFrczogJHtsaW5lQnJlYWtJbmZvPy5saW5lQnJlYWtDb3VudCB8fCAwfWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgICAgLSBUZXh0IHByZXZpZXc6IFwiJHtwbGFpblRleHRcclxuICAgICAgICAgIC5zdWJzdHJpbmcoMCwgNTApXHJcbiAgICAgICAgICAucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIil9Li4uXCJgXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcGFyc2luZyBzdG9yeSAke2ZpbGVOYW1lfTpgLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlcGxhY2UgdGhlIGV4aXN0aW5nIGV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudCBtZXRob2Qgd2l0aCB0aGlzIGNvcnJlY3RlZCB2ZXJzaW9uXHJcbiAgZXh0cmFjdERldGFpbGVkU3RvcnlDb250ZW50KHN0b3J5RGF0YSwgZmlsZU5hbWUgPSBcInVua25vd25cIikge1xyXG4gICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xyXG4gICAgbGV0IGZvcm1hdHRlZENvbnRlbnQgPSBbXTtcclxuICAgIGxldCB0ZXh0Q29sb3IgPSBudWxsO1xyXG4gICAgbGV0IGRlYnVnSW5mbyA9IFtdO1xyXG5cclxuICAgIGNvbnN0IGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkgPSAoZWxlbWVudCwgZGVwdGggPSAwLCBjb250ZXh0ID0ge30pID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgY29udGVudCArPSBlbGVtZW50O1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAvLyBFTkhBTkNFRDogU3BlY2lhbCBoYW5kbGluZyBmb3IgQ2hhcmFjdGVyU3R5bGVSYW5nZSB3aXRoIHNvcGhpc3RpY2F0ZWQgQnIgZGV0ZWN0aW9uXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkNoYXJhY3RlclN0eWxlUmFuZ2UpXHJcbiAgICAgICAgICAgID8gZWxlbWVudC5DaGFyYWN0ZXJTdHlsZVJhbmdlXHJcbiAgICAgICAgICAgIDogW2VsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZV07XHJcblxyXG4gICAgICAgICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlLCByYW5nZUluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgZGlyZWN0IGZvbnQgcmVmZXJlbmNlcyBmcm9tIHRoZSBYTUwgcmFuZ2VcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0Rm9udFJlZiA9XHJcbiAgICAgICAgICAgICAgcmFuZ2VbXCJAX0FwcGxpZWRGb250XCJdIHx8XHJcbiAgICAgICAgICAgICAgcmFuZ2VbXCJAX0ZvbnRGYW1pbHlcIl0gfHxcclxuICAgICAgICAgICAgICByYW5nZVtcIkBfRm9udFwiXSB8fFxyXG4gICAgICAgICAgICAgIFwiXCI7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0aW5nID0ge1xyXG4gICAgICAgICAgICAgIHBhcmFncmFwaFN0eWxlOlxyXG4gICAgICAgICAgICAgICAgZWxlbWVudFtcIkBfQXBwbGllZFBhcmFncmFwaFN0eWxlXCJdIHx8XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFwcGxpZWRTdHlsZSB8fFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZTogcmFuZ2VbXCJAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZVwiXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgIGZvbnRTaXplOiByYW5nZVtcIkBfUG9pbnRTaXplXCJdXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29udmVydEZvbnRTaXplVG9QaXhlbHMocGFyc2VGbG9hdChyYW5nZVtcIkBfUG9pbnRTaXplXCJdKSkgLy8gQURERUQ6IENvbnZlcnQgdG8gcGl4ZWxzXHJcbiAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgb3JpZ2luYWxGb250U2l6ZTogcmFuZ2VbXCJAX1BvaW50U2l6ZVwiXVxyXG4gICAgICAgICAgICAgICAgPyBwYXJzZUZsb2F0KHJhbmdlW1wiQF9Qb2ludFNpemVcIl0pXHJcbiAgICAgICAgICAgICAgICA6IG51bGwsIC8vIEFEREVEOiBQcmVzZXJ2ZSBvcmlnaW5hbFxyXG4gICAgICAgICAgICAgIGZvbnRSZWZlcmVuY2U6IGRpcmVjdEZvbnRSZWYsXHJcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiByYW5nZVtcIkBfRmlsbENvbG9yXCJdIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgZm9udFN0eWxlOiByYW5nZVtcIkBfRm9udFN0eWxlXCJdIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBJbmhlcml0IHBhcmFncmFwaCBhbGlnbm1lbnQgZnJvbSBjb250ZXh0IGlmIG5vdCBleHBsaWNpdGx5IHNldFxyXG4gICAgICAgICAgICAgIGFsaWdubWVudDpcclxuICAgICAgICAgICAgICAgIHJhbmdlW1wiQF9KdXN0aWZpY2F0aW9uXCJdIHx8XHJcbiAgICAgICAgICAgICAgICByYW5nZVtcIkBfQWxpZ25tZW50XCJdIHx8XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnBhcmFncmFwaEFsaWdubWVudCB8fFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkRm9ybWF0dGluZyA9XHJcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nKGZvcm1hdHRpbmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBQcm9jZXNzIENvbnRlbnQgYW5kIEJyIGVsZW1lbnRzIGluIGRvY3VtZW50IG9yZGVyXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyBpbnRlcmxlYXZlZCA8Q29udGVudD4gYW5kIDxCcj4gZWxlbWVudHMgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnByb2Nlc3NDaGFyYWN0ZXJSYW5nZUluT3JkZXIoXHJcbiAgICAgICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICAgICAgcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgICAgICAgICAgIHJhbmdlSW5kZXgsXHJcbiAgICAgICAgICAgICAgcmFuZ2VzLmxlbmd0aCxcclxuICAgICAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQsXHJcbiAgICAgICAgICAgICAgZGVidWdJbmZvLFxyXG4gICAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgZmlsZU5hbWVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogQWRkIHNwYWNlIGJldHdlZW4gY2hhcmFjdGVyIHN0eWxlIHJhbmdlcyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKHJhbmdlSW5kZXggPCByYW5nZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5leHRSYW5nZSA9IHJhbmdlc1tyYW5nZUluZGV4ICsgMV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIE1vcmUgcm9idXN0IHNwYWNlIGRldGVjdGlvblxyXG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gY29udGVudC5zbGljZSgtMTApOyAvLyBDaGVjayBsYXN0IDEwIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlID0gL1xccyQvLnRlc3QoY3VycmVudFRleHQpOyAvLyBBbnkgd2hpdGVzcGFjZSBhdCBlbmRcclxuXHJcbiAgICAgICAgICAgICAgY29uc3QgbmV4dENvbnRlbnQgPSBuZXh0UmFuZ2UuQ29udGVudFxyXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcoXHJcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShuZXh0UmFuZ2UuQ29udGVudClcclxuICAgICAgICAgICAgICAgICAgICAgID8gbmV4dFJhbmdlLkNvbnRlbnRbMF1cclxuICAgICAgICAgICAgICAgICAgICAgIDogbmV4dFJhbmdlLkNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSA9IC9eXFxzLy50ZXN0KG5leHRDb250ZW50KTsgLy8gQW55IHdoaXRlc3BhY2UgYXQgc3RhcnRcclxuXHJcbiAgICAgICAgICAgICAgLy8gQUdHUkVTU0lWRSBGSVg6IEFkZCBzcGFjZSBiZXR3ZWVuIEFMTCByYW5nZXMgdW5sZXNzIGV4cGxpY2l0bHkgbm90IG5lZWRlZFxyXG4gICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBTcGFjZSA9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlIHx8XHJcbiAgICAgICAgICAgICAgICBuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2UgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkSW5zZXJ0SW1wbGljaXRMaW5lQnJlYWsocmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkgfHxcclxuICAgICAgICAgICAgICAgICFuZXh0UmFuZ2UuQ29udGVudCB8fCAvLyBTa2lwIGlmIG5leHQgcmFuZ2UgaGFzIG5vIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgIG5leHRDb250ZW50LnRyaW0oKSA9PT0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFzaG91bGRTa2lwU3BhY2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZSA9IHJhbmdlW1wiQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGVcIl0gfHwgXCJub25lXCI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U3R5bGUgPVxyXG4gICAgICAgICAgICAgICAgICBuZXh0UmFuZ2VbXCJAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZVwiXSB8fCBcIm5vbmVcIjtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFjZVRleHQgPSBcIiBcIjtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gc3BhY2VUZXh0O1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdGV4dDogc3BhY2VUZXh0LFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTcGFjZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwiYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGUgcmFuZ2VzIChhZ2dyZXNzaXZlKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiU3BhY2UgaW5zZXJ0ZWQgYmV0d2VlbiBjaGFyYWN0ZXIgc3R5bGVzIChhZ2dyZXNzaXZlKVwiLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VJbmRleCArIDFcclxuICAgICAgICAgICAgICAgICAgfWAsXHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgbmV4dFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICByZWFzb246XHJcbiAgICAgICAgICAgICAgICAgICAgXCJEZWZhdWx0IHNwYWNlIGluc2VydGlvbiAtIHdvcmRzIGxpa2VseSBzcGxpdCBhY3Jvc3MgcmFuZ2VzXCIsXHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0RW5kOiBjdXJyZW50VGV4dC5zbGljZSgtNSksXHJcbiAgICAgICAgICAgICAgICAgIG5leHRUZXh0U3RhcnQ6IG5leHRDb250ZW50LnNsaWNlKDAsIDUpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJTcGFjZSBpbnNlcnRpb24gc2tpcHBlZFwiLFxyXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYEJldHdlZW4gcmFuZ2VzICR7cmFuZ2VJbmRleH0gYW5kICR7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VJbmRleCArIDFcclxuICAgICAgICAgICAgICAgICAgfWAsXHJcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogY3VycmVudFJhbmdlRW5kc1dpdGhTcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgID8gXCJDdXJyZW50IHJhbmdlIGVuZHMgd2l0aCBzcGFjZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgOiBuZXh0UmFuZ2VTdGFydHNXaXRoU3BhY2VcclxuICAgICAgICAgICAgICAgICAgICA/IFwiTmV4dCByYW5nZSBzdGFydHMgd2l0aCBzcGFjZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgOiAhbmV4dFJhbmdlLkNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICA/IFwiTmV4dCByYW5nZSBoYXMgbm8gY29udGVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgOiBuZXh0Q29udGVudC50cmltKCkgPT09IFwiXCJcclxuICAgICAgICAgICAgICAgICAgICA/IFwiTmV4dCBjb250ZW50IGlzIG9ubHkgd2hpdGVzcGFjZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgOiBcIkxpbmUgYnJlYWsgd291bGQgYmUgaW5zZXJ0ZWRcIixcclxuICAgICAgICAgICAgICAgICAgY3VycmVudFRleHRFbmQ6IGN1cnJlbnRUZXh0LnNsaWNlKC01KSxcclxuICAgICAgICAgICAgICAgICAgbmV4dFRleHRTdGFydDogbmV4dENvbnRlbnQuc2xpY2UoMCwgNSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBleHBsaWNpdCBsaW5lIGJyZWFrcyBiZXR3ZWVuIHJhbmdlcyAoZm9yIGNhc2VzIHdoZXJlIHNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrIGlzIHRydWUpXHJcbiAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayhyYW5nZSwgbmV4dFJhbmdlLCBjb250ZXh0KVxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1wbGljaXRCcmVhayA9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGltcGxpY2l0QnJlYWs7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBpbXBsaWNpdEJyZWFrLFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBicmVha1R5cGU6IFwiaW1wbGljaXRcIixcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwiYmV0d2VlbiByYW5nZXNcIixcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJJbXBsaWNpdCBsaW5lIGJyZWFrXCIsXHJcbiAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgQmV0d2VlbiByYW5nZXMgJHtyYW5nZUluZGV4fSBhbmQgJHtcclxuICAgICAgICAgICAgICAgICAgICByYW5nZUluZGV4ICsgMVxyXG4gICAgICAgICAgICAgICAgICB9YCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm47IC8vIERvbid0IGNvbnRpbnVlIHByb2Nlc3NpbmcgdG8gYXZvaWQgZHVwbGljYXRpb25cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVOSEFOQ0VEOiBIYW5kbGUgUGFyYWdyYXBoU3R5bGVSYW5nZSB3aXRoIGNvbnRleHRcclxuICAgICAgICBpZiAoZWxlbWVudC5QYXJhZ3JhcGhTdHlsZVJhbmdlKSB7XHJcbiAgICAgICAgICBjb25zdCByYW5nZXMgPSBBcnJheS5pc0FycmF5KGVsZW1lbnQuUGFyYWdyYXBoU3R5bGVSYW5nZSlcclxuICAgICAgICAgICAgPyBlbGVtZW50LlBhcmFncmFwaFN0eWxlUmFuZ2VcclxuICAgICAgICAgICAgOiBbZWxlbWVudC5QYXJhZ3JhcGhTdHlsZVJhbmdlXTtcclxuXHJcbiAgICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaENvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgLi4uY29udGV4dCxcclxuICAgICAgICAgICAgICBwYXJhZ3JhcGhJbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgdG90YWxQYXJhZ3JhcGhzOiByYW5nZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgIGFwcGxpZWRTdHlsZTogcmFuZ2VbXCJAX0FwcGxpZWRQYXJhZ3JhcGhTdHlsZVwiXSxcclxuICAgICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IFBhc3MgZG93biBkaXJlY3QgcGFyYWdyYXBoLWxldmVsIGFsaWdubWVudFxyXG4gICAgICAgICAgICAgIHBhcmFncmFwaEFsaWdubWVudDpcclxuICAgICAgICAgICAgICAgIHJhbmdlW1wiQF9KdXN0aWZpY2F0aW9uXCJdIHx8IHJhbmdlW1wiQF9BbGlnbm1lbnRcIl0sXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBUcmFjayBjb250ZW50IGxlbmd0aCBiZWZvcmVcclxuICAgICAgICAgICAgY29uc3QgYmVmb3JlTGVuID0gY29udGVudC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkocmFuZ2UsIGRlcHRoICsgMSwgcGFyYWdyYXBoQ29udGV4dCk7XHJcbiAgICAgICAgICAgIC8vIFRyYWNrIGNvbnRlbnQgbGVuZ3RoIGFmdGVyXHJcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyTGVuID0gY29udGVudC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBub3RoaW5nIHdhcyBhZGRlZCwgdGhpcyBpcyBhbiBlbXB0eSBwYXJhZ3JhcGg6IGFkZCBhIG5ld2xpbmVcclxuICAgICAgICAgICAgaWYgKGFmdGVyTGVuID09PSBiZWZvcmVMZW4pIHtcclxuICAgICAgICAgICAgICBjb250ZW50ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXFxuXCIsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrVHlwZTogXCJlbXB0eS1wYXJhZ3JhcGhcIixcclxuICAgICAgICAgICAgICAgICAgc291cmNlOiBcImVtcHR5IFBhcmFncmFwaFN0eWxlUmFuZ2VcIixcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJFbXB0eSBwYXJhZ3JhcGggZGV0ZWN0ZWRcIixcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBgUGFyYWdyYXBoU3R5bGVSYW5nZVske2luZGV4fV1gLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgcGFyYWdyYXBoIGJyZWFrIGJldHdlZW4gcGFyYWdyYXBocyAoYnV0IG5vdCBhZnRlciB0aGUgbGFzdCBvbmUpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHJhbmdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoQnJlYWsgPSBcIlxcblxcblwiOyAvLyBVc2UgZG91YmxlIG5ld2xpbmUgZm9yIHBhcmFncmFwaCBicmVha3NcclxuICAgICAgICAgICAgICBjb250ZW50ICs9IHBhcmFncmFwaEJyZWFrO1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhZ3JhcGhCcmVhayxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgYnJlYWtUeXBlOiBcInBhcmFncmFwaFwiLFxyXG4gICAgICAgICAgICAgICAgICBzb3VyY2U6IFwiYmV0d2VlbiBwYXJhZ3JhcGhzXCIsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiUGFyYWdyYXBoIGJyZWFrXCIsXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogYGJldHdlZW4gcGFyYWdyYXBocyAke2luZGV4fSBhbmQgJHtpbmRleCArIDF9YCxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgZGlyZWN0IENvbnRlbnQgZWxlbWVudHMgKHdoZW4gbm90IGluc2lkZSBDaGFyYWN0ZXJTdHlsZVJhbmdlKVxyXG4gICAgICAgIGlmIChlbGVtZW50LkNvbnRlbnQgJiYgIWVsZW1lbnQuQ2hhcmFjdGVyU3R5bGVSYW5nZSkge1xyXG4gICAgICAgICAgbGV0IHRleHQgPSBBcnJheS5pc0FycmF5KGVsZW1lbnQuQ29udGVudClcclxuICAgICAgICAgICAgPyBlbGVtZW50LkNvbnRlbnQuam9pbihcIlwiKVxyXG4gICAgICAgICAgICA6IFN0cmluZyhlbGVtZW50LkNvbnRlbnQpO1xyXG4gICAgICAgICAgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyh0ZXh0KTtcclxuICAgICAgICAgIGNvbnRlbnQgKz0gdGV4dDtcclxuXHJcbiAgICAgICAgICBjb25zdCBmb3JtYXR0aW5nID0ge1xyXG4gICAgICAgICAgICBwYXJhZ3JhcGhTdHlsZTpcclxuICAgICAgICAgICAgICBlbGVtZW50W1wiQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGVcIl0gfHxcclxuICAgICAgICAgICAgICBjb250ZXh0LmFwcGxpZWRTdHlsZSB8fFxyXG4gICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIGNoYXJhY3RlclN0eWxlOiBlbGVtZW50W1wiQF9BcHBsaWVkQ2hhcmFjdGVyU3R5bGVcIl0gfHwgbnVsbCxcclxuICAgICAgICAgICAgZm9udFNpemU6IGVsZW1lbnRbXCJAX1BvaW50U2l6ZVwiXSB8fCBudWxsLFxyXG4gICAgICAgICAgICBmb250RmFtaWx5OiBlbGVtZW50W1wiQF9BcHBsaWVkRm9udFwiXSB8fCBudWxsLFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IGVsZW1lbnRbXCJAX0ZpbGxDb2xvclwiXSB8fCBudWxsLFxyXG4gICAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IEluaGVyaXQgcGFyYWdyYXBoIGFsaWdubWVudCBmcm9tIGNvbnRleHQgaWYgbm90IGV4cGxpY2l0bHkgc2V0XHJcbiAgICAgICAgICAgIGFsaWdubWVudDpcclxuICAgICAgICAgICAgICBlbGVtZW50W1wiQF9KdXN0aWZpY2F0aW9uXCJdIHx8XHJcbiAgICAgICAgICAgICAgZWxlbWVudFtcIkBfQWxpZ25tZW50XCJdIHx8XHJcbiAgICAgICAgICAgICAgY29udGV4dC5wYXJhZ3JhcGhBbGlnbm1lbnQgfHxcclxuICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBjb25zdCByZXNvbHZlZEZvcm1hdHRpbmcgPVxyXG4gICAgICAgICAgICB0aGlzLnN0eWxlUGFyc2VyLnJlc29sdmVTdHlsZUZvcm1hdHRpbmcoZm9ybWF0dGluZyk7XHJcblxyXG4gICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXG5cXG5cIiksXHJcbiAgICAgICAgICAgIGZvcm1hdHRpbmc6IHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRU5IQU5DRUQ6IERpcmVjdCBCciBlbGVtZW50IGhhbmRsaW5nIChvdXRzaWRlIG9mIHJhbmdlcylcclxuICAgICAgICBpZiAoZWxlbWVudC5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zdCBickVsZW1lbnRzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LkJyKVxyXG4gICAgICAgICAgICA/IGVsZW1lbnQuQnJcclxuICAgICAgICAgICAgOiBbZWxlbWVudC5Ccl07XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYPCflKcgUHJvY2Vzc2luZyAke2JyRWxlbWVudHMubGVuZ3RofSBkaXJlY3QgQnIgZWxlbWVudHM6YCxcclxuICAgICAgICAgICAgYnJFbGVtZW50c1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBickVsZW1lbnRzLmZvckVhY2goKGJyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gXCJcXG5cIjtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYPCflKcgRGlyZWN0IEJyIGVsZW1lbnQgJHtpbmRleCArIDF9LyR7XHJcbiAgICAgICAgICAgICAgICBickVsZW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICAgICAgIH0gY3JlYXRlczogJHtKU09OLnN0cmluZ2lmeShsaW5lQnJlYWtUZXh0KX1gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0LFxyXG4gICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBicmVha1R5cGU6IFwiZXhwbGljaXRcIixcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogXCJkaXJlY3QgQnIgZWxlbWVudFwiLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgdHlwZTogXCJEaXJlY3QgQnIgZWxlbWVudFwiLFxyXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiBgRGlyZWN0IGVsZW1lbnQsIGluZGV4ICR7aW5kZXh9YCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYPCflKcgQWZ0ZXIgcHJvY2Vzc2luZyAke2JyRWxlbWVudHMubGVuZ3RofSBkaXJlY3QgQnIgZWxlbWVudHMsIGNvbnRlbnQgZW5kcyB3aXRoOmAsXHJcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQuc2xpY2UoLTEwKSlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb250aW51ZSB3aXRoIG90aGVyIG5lc3RlZCBlbGVtZW50c1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGVsZW1lbnQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAha2V5LnN0YXJ0c1dpdGgoXCJAX1wiKSAmJlxyXG4gICAgICAgICAgICBrZXkgIT09IFwiQ29udGVudFwiICYmXHJcbiAgICAgICAgICAgIGtleSAhPT0gXCJCclwiICYmXHJcbiAgICAgICAgICAgIGtleSAhPT0gXCJDaGFyYWN0ZXJTdHlsZVJhbmdlXCIgJiZcclxuICAgICAgICAgICAga2V5ICE9PSBcIlBhcmFncmFwaFN0eWxlUmFuZ2VcIlxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+XHJcbiAgICAgICAgICAgICAgICBleHRyYWN0VGV4dFJlY3Vyc2l2ZWx5KGl0ZW0sIGRlcHRoICsgMSwgY29udGV4dClcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBkZXB0aCA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgZXh0cmFjdFRleHRSZWN1cnNpdmVseSh2YWx1ZSwgZGVwdGggKyAxLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlbHkoc3RvcnlEYXRhKTtcclxuXHJcbiAgICAvLyBERUJVRzogUHJpbnQgdGhlIGZ1bGwgcmF3IGNvbnRlbnQgc3RyaW5nIHdpdGggdmlzaWJsZSBuZXdsaW5lcyBiZWZvcmUgcHJvY2Vzc2luZ1xyXG4gICAgY29uc29sZS5sb2coXCLwn5OdID09PSBDT01QTEVURSBDT05URU5UIEFOQUxZU0lTID09PVwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwiICAgLSBSYXcgY29udGVudCBiZWZvcmUgcHJvY2Vzc2luZzpcIiwgSlNPTi5zdHJpbmdpZnkoY29udGVudCkpO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwiICAgLSBSYXcgY29udGVudCBuZXdsaW5lIGNvdW50OlwiLFxyXG4gICAgICAoY29udGVudC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGhcclxuICAgICk7XHJcbiAgICBjb25zb2xlLmxvZyhcIiAgIC0gUmF3IGNvbnRlbnQgY2hhcmFjdGVyIGJyZWFrZG93bjpcIik7XHJcbiAgICBjb25zdCBjaGFycyA9IGNvbnRlbnRcclxuICAgICAgLnNwbGl0KFwiXCIpXHJcbiAgICAgIC5tYXAoKGNoYXIsIGkpID0+IGAke2l9OiAke0pTT04uc3RyaW5naWZ5KGNoYXIpfWApO1xyXG4gICAgY29uc29sZS5sb2coXCIgICAtIEZpcnN0IDUwIGNoYXJhY3RlcnM6XCIsIGNoYXJzLnNsaWNlKDAsIDUwKSk7XHJcbiAgICBpZiAoY29udGVudC5sZW5ndGggPiA1MCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIiAgIC0gTGFzdCAyMCBjaGFyYWN0ZXJzOlwiLCBjaGFycy5zbGljZSgtMjApKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFTkhBTkNFRDogUHJvY2VzcyBhbmQgY2xlYW4gdXAgdGhlIGNvbnRlbnQgd2l0aCBzb3BoaXN0aWNhdGVkIGxpbmUgYnJlYWsgcHJlc2VydmF0aW9uXHJcbiAgICBsZXQgcHJvY2Vzc2VkQ29udGVudCA9IElETUxVdGlscy5zb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyhjb250ZW50KTtcclxuXHJcbiAgICAvLyBDUklUSUNBTDogRXhwbGljaXRseSBwcmVzZXJ2ZSBhbGwgbmV3bGluZXMgYXMtaXMgKG5vIG1lcmdpbmcgb3Igc3RyaXBwaW5nKVxyXG4gICAgcHJvY2Vzc2VkQ29udGVudCA9IHByb2Nlc3NlZENvbnRlbnQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTsgLy8gTm9ybWFsaXplIENSTEYvQ1IgdG8gTEZcclxuICAgIC8vIERvIE5PVCBjb2xsYXBzZSBtdWx0aXBsZSBuZXdsaW5lcyBpbnRvIG9uZTsgcHJlc2VydmUgYXMtaXNcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIvCfk50gPT09IFBST0NFU1NFRCBDT05URU5UIEFOQUxZU0lTID09PVwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwiICAgLSBQcm9jZXNzZWQgY29udGVudDpcIiwgSlNPTi5zdHJpbmdpZnkocHJvY2Vzc2VkQ29udGVudCkpO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwiICAgLSBQcm9jZXNzZWQgY29udGVudCBuZXdsaW5lIGNvdW50OlwiLFxyXG4gICAgICAocHJvY2Vzc2VkQ29udGVudC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGhcclxuICAgICk7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgXCIgICAtIENvbnRlbnQgbGVuZ3RoIGNoYW5nZTpcIixcclxuICAgICAgY29udGVudC5sZW5ndGgsXHJcbiAgICAgIFwi4oaSXCIsXHJcbiAgICAgIHByb2Nlc3NlZENvbnRlbnQubGVuZ3RoXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFNob3cgZGlmZmVyZW5jZXMgaWYgYW55XHJcbiAgICBpZiAoY29udGVudCAhPT0gcHJvY2Vzc2VkQ29udGVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuKaoO+4jyAgQ09OVEVOVCBXQVMgTU9ESUZJRUQgRFVSSU5HIFBST0NFU1NJTkchXCIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIiAgIC0gT3JpZ2luYWw6XCIsIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQuc2xpY2UoMCwgMTAwKSkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIiAgIC0gUHJvY2Vzc2VkOlwiLFxyXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHByb2Nlc3NlZENvbnRlbnQuc2xpY2UoMCwgMTAwKSlcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi4pyFIENvbnRlbnQgcHJlc2VydmVkIGV4YWN0bHkgZHVyaW5nIHByb2Nlc3NpbmdcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gREVCVUc6IExvZyBzcGFjZSBwcmVzZXJ2YXRpb24gcmVzdWx0c1xyXG4gICAgY29uc29sZS5sb2coXCLwn5OdIFRleHQgZXh0cmFjdGlvbiByZXN1bHRzOlwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwiICAgLSBPcmlnaW5hbCBjb250ZW50IGxlbmd0aDpcIiwgY29udGVudC5sZW5ndGgpO1xyXG4gICAgY29uc29sZS5sb2coXCIgICAtIFByb2Nlc3NlZCBjb250ZW50IGxlbmd0aDpcIiwgcHJvY2Vzc2VkQ29udGVudC5sZW5ndGgpO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwiICAgLSBTcGFjZSBwcmVzZXJ2YXRpb24gZXZlbnRzOlwiLFxyXG4gICAgICBkZWJ1Z0luZm8uZmlsdGVyKChpbmZvKSA9PiBpbmZvLnR5cGUuaW5jbHVkZXMoXCJTcGFjZSBpbnNlcnRlZFwiKSkubGVuZ3RoXHJcbiAgICApO1xyXG4gICAgLy8gREVCVUc6IFNob3cgZmlyc3QgMzAwIGNoYXJzIHdpdGggdmlzaWJsZSBuZXdsaW5lc1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwiICAgLSBFeHRyYWN0ZWQgdGV4dCBwcmV2aWV3OlwiLFxyXG4gICAgICBKU09OLnN0cmluZ2lmeShwcm9jZXNzZWRDb250ZW50LnNsaWNlKDAsIDMwMCkpXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFNQRUNJRklDIERFQlVHOiBDaGVjayBmb3IgdGhlIHByb2JsZW1hdGljIFwicGF2b2x1cHR1c2RhXCIgdGV4dCAoc2ltcGxpZmllZClcclxuICAgIGlmIChcclxuICAgICAgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcyhcInBhdm9sdXB0dXNkYVwiKSB8fFxyXG4gICAgICAocHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcyhcInBhXCIpICYmXHJcbiAgICAgICAgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcyhcInZvbHVwdHVzZGFcIikpXHJcbiAgICApIHtcclxuICAgICAgY29uc29sZS5sb2coXCLwn5qoIEZPVU5EIFBST0JMRU1BVElDIFRFWFQ6XCIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAnICAgLSBDb250YWlucyBcInBhdm9sdXB0dXNkYVwiOicsXHJcbiAgICAgICAgcHJvY2Vzc2VkQ29udGVudC5pbmNsdWRlcyhcInBhdm9sdXB0dXNkYVwiKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAnICAgLSBDb250YWlucyBcInBhIHZvbHVwdHVzZGFcIjonLFxyXG4gICAgICAgIHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoXCJwYSB2b2x1cHR1c2RhXCIpXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwiICAgLSBGb3JtYXR0ZWRDb250ZW50IGJyZWFrZG93bjpcIixcclxuICAgICAgICBmb3JtYXR0ZWRDb250ZW50Lm1hcCgoaXRlbSkgPT4gaXRlbS50ZXh0KS5qb2luKFwifFwiKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxpbmVCcmVha0luZm8gPSB7XHJcbiAgICAgIGhhc0xpbmVCcmVha3M6IHByb2Nlc3NlZENvbnRlbnQuaW5jbHVkZXMoXCJcXG5cIiksXHJcbiAgICAgIGxpbmVCcmVha0NvdW50OiAocHJvY2Vzc2VkQ29udGVudC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGgsXHJcbiAgICAgIGxpbmVCcmVha1R5cGVzOiB0aGlzLmFuYWx5emVMaW5lQnJlYWtUeXBlcyhmb3JtYXR0ZWRDb250ZW50KSxcclxuICAgICAgZGVidWdJbmZvOiBkZWJ1Z0luZm8sXHJcbiAgICAgIHNwYWNlUHJlc2VydmF0aW9uQ291bnQ6IGRlYnVnSW5mby5maWx0ZXIoKGluZm8pID0+XHJcbiAgICAgICAgaW5mby50eXBlLmluY2x1ZGVzKFwiU3BhY2UgaW5zZXJ0ZWRcIilcclxuICAgICAgKS5sZW5ndGgsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHBsYWluVGV4dDogcHJvY2Vzc2VkQ29udGVudCxcclxuICAgICAgZm9ybWF0dGVkQ29udGVudDogZm9ybWF0dGVkQ29udGVudC5maWx0ZXIoXHJcbiAgICAgICAgKGl0ZW0pID0+IGl0ZW0udGV4dCAmJiBpdGVtLnRleHQubGVuZ3RoID4gMFxyXG4gICAgICApLFxyXG4gICAgICB3b3JkQ291bnQ6IElETUxVdGlscy5jb3VudFdvcmRzKHByb2Nlc3NlZENvbnRlbnQucmVwbGFjZSgvXFxuL2csIFwiIFwiKSksXHJcbiAgICAgIGNoYXJhY3RlckNvdW50OiBwcm9jZXNzZWRDb250ZW50Lmxlbmd0aCxcclxuICAgICAgdGV4dENvbG9yOiB0ZXh0Q29sb3IsXHJcbiAgICAgIGxpbmVCcmVha0luZm86IGxpbmVCcmVha0luZm8sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBQcm9jZXNzIENoYXJhY3RlclN0eWxlUmFuZ2UgY29udGVudCBhbmQgYnJlYWtzIGluIGRvY3VtZW50IG9yZGVyIC0gRlVMTFkgRFlOQU1JQ1xyXG4gIHByb2Nlc3NDaGFyYWN0ZXJSYW5nZUluT3JkZXIoXHJcbiAgICByYW5nZSxcclxuICAgIHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgIHJhbmdlSW5kZXgsXHJcbiAgICB0b3RhbFJhbmdlcyxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgZGVidWdJbmZvLFxyXG4gICAgY29udGV4dCxcclxuICAgIGZpbGVOYW1lXHJcbiAgKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCflKcgUHJvY2Vzc2luZyBDaGFyYWN0ZXJTdHlsZVJhbmdlWyR7cmFuZ2VJbmRleH1dIGluIGRvY3VtZW50IG9yZGVyOmAsXHJcbiAgICAgIHtcclxuICAgICAgICBoYXNDb250ZW50OiAhIXJhbmdlLkNvbnRlbnQsXHJcbiAgICAgICAgaGFzQnI6IHJhbmdlLkJyICE9PSB1bmRlZmluZWQsXHJcbiAgICAgICAgY29udGVudFR5cGU6IEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudClcclxuICAgICAgICAgID8gXCJhcnJheVwiXHJcbiAgICAgICAgICA6IHR5cGVvZiByYW5nZS5Db250ZW50LFxyXG4gICAgICAgIGJyVHlwZTogQXJyYXkuaXNBcnJheShyYW5nZS5CcikgPyBcImFycmF5XCIgOiB0eXBlb2YgcmFuZ2UuQnIsXHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgLy8gQ09NUFJFSEVOU0lWRSBFREdFIENBU0UgSEFORExJTkdcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENhc2UgMTogQm90aCBDb250ZW50IGFuZCBCciBlbGVtZW50cyBleGlzdCAtIG1vc3QgY29tbW9uIGNhc2VcclxuICAgICAgaWYgKHJhbmdlLkNvbnRlbnQgJiYgcmFuZ2UuQnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SnIFByb2Nlc3NpbmcgcmFuZ2Ugd2l0aCBib3RoIGNvbnRlbnQgYW5kIGJyZWFrc2ApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NJbnRlcmxlYXZlZENvbnRlbnRBbmRCcihcclxuICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQsXHJcbiAgICAgICAgICBkZWJ1Z0luZm8sXHJcbiAgICAgICAgICBmaWxlTmFtZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhc2UgMjogT25seSBDb250ZW50LCBubyBCciBlbGVtZW50c1xyXG4gICAgICBlbHNlIGlmIChyYW5nZS5Db250ZW50ICYmIHJhbmdlLkJyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UpyBQcm9jZXNzaW5nIHJhbmdlIHdpdGggb25seSBjb250ZW50YCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0NvbnRlbnRFbGVtZW50cyhcclxuICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQsXHJcbiAgICAgICAgICBmaWxlTmFtZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhc2UgMzogT25seSBCciBlbGVtZW50cywgbm8gQ29udGVudFxyXG4gICAgICBlbHNlIGlmICghcmFuZ2UuQ29udGVudCAmJiByYW5nZS5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYPCflKcgUHJvY2Vzc2luZyByYW5nZSB3aXRoIG9ubHkgYnJlYWtzYCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0JyRWxlbWVudHMoXHJcbiAgICAgICAgICByYW5nZSxcclxuICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgICAgICAgZGVidWdJbmZvLFxyXG4gICAgICAgICAgcmFuZ2VJbmRleCxcclxuICAgICAgICAgIGZpbGVOYW1lXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2FzZSA0OiBOZWl0aGVyIENvbnRlbnQgbm9yIEJyIC0gZW1wdHkgcmFuZ2VcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBFbXB0eSByYW5nZSBlbmNvdW50ZXJlZCAtIG5vIGNvbnRlbnQgb3IgYnJlYWtzYCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIFVMVElNQVRFIEZBTExCQUNLOiBJZiBhbnl0aGluZyBnb2VzIHdyb25nLCB0cnkgdG8gc2FsdmFnZSB3aGF0IHdlIGNhblxyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4p2MIEVycm9yIHByb2Nlc3NpbmcgQ2hhcmFjdGVyU3R5bGVSYW5nZVske3JhbmdlSW5kZXh9XTogJHtlcnJvci5tZXNzYWdlfWBcclxuICAgICAgKTtcclxuICAgICAgY29uc29sZS5sb2coYPCflIQgQXR0ZW1wdGluZyBlbWVyZ2VuY3kgY29udGVudCBleHRyYWN0aW9uLi4uYCk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5lbWVyZ2VuY3lDb250ZW50RXh0cmFjdGlvbihcclxuICAgICAgICByYW5nZSxcclxuICAgICAgICByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgICAgIGZpbGVOYW1lXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBFTUVSR0VOQ1kgRkFMTEJBQ0s6IEV4dHJhY3QgY29udGVudCBmcm9tIG1hbGZvcm1lZCBvciB1bmV4cGVjdGVkIFhNTCBzdHJ1Y3R1cmVzXHJcbiAgZW1lcmdlbmN5Q29udGVudEV4dHJhY3Rpb24oXHJcbiAgICByYW5nZSxcclxuICAgIHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgZmlsZU5hbWVcclxuICApIHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5qoIEVtZXJnZW5jeSBjb250ZW50IGV4dHJhY3Rpb24gZm9yIHVudXN1YWwgWE1MIHN0cnVjdHVyZWApO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRyeSB0byBleHRyYWN0IGFueSB0ZXh0IGNvbnRlbnQgdXNpbmcgZGlmZmVyZW50IGFwcHJvYWNoZXNcclxuICAgICAgY29uc3QgZXh0cmFjdGVkVGV4dHMgPSBbXTtcclxuICAgICAgY29uc3QgZXh0cmFjdGVkQnJlYWtzID0gW107XHJcblxyXG4gICAgICAvLyBBcHByb2FjaCAxOiBEaXJlY3QgcHJvcGVydHkgYWNjZXNzXHJcbiAgICAgIGlmIChyYW5nZS5Db250ZW50KSB7XHJcbiAgICAgICAgY29uc3QgY29udGVudHMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpXHJcbiAgICAgICAgICA/IHJhbmdlLkNvbnRlbnRcclxuICAgICAgICAgIDogW3JhbmdlLkNvbnRlbnRdO1xyXG4gICAgICAgIGNvbnRlbnRzLmZvckVhY2goKGMpID0+IHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIiAmJiBjLnRyaW0oKSkge1xyXG4gICAgICAgICAgICBleHRyYWN0ZWRUZXh0cy5wdXNoKGMudHJpbSgpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXBwcm9hY2ggMjogU2VhcmNoIGZvciBhbnkgdGV4dC1saWtlIHByb3BlcnRpZXNcclxuICAgICAgT2JqZWN0LmtleXMocmFuZ2UpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHR5cGVvZiByYW5nZVtrZXldID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgICByYW5nZVtrZXldLnRyaW0oKSAmJlxyXG4gICAgICAgICAga2V5ICE9PSBcIkBfU2VsZlwiICYmXHJcbiAgICAgICAgICAha2V5LnN0YXJ0c1dpdGgoXCJAX1wiKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgZXh0cmFjdGVkVGV4dHMucHVzaChyYW5nZVtrZXldLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFwcHJvYWNoIDM6IENvdW50IGFueSBicmVhay1saWtlIHByb3BlcnRpZXNcclxuICAgICAgaWYgKHJhbmdlLkJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zdCBicmVha3MgPSBBcnJheS5pc0FycmF5KHJhbmdlLkJyKSA/IHJhbmdlLkJyIDogW3JhbmdlLkJyXTtcclxuICAgICAgICBleHRyYWN0ZWRCcmVha3MucHVzaCguLi5icmVha3MpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgZXh0cmFjdGVkIGNvbnRlbnRcclxuICAgICAgZXh0cmFjdGVkVGV4dHMuZm9yRWFjaCgodGV4dCwgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBjbGVhblRleHQgPSBJRE1MVXRpbHMuZGVjb2RlWE1MRW50aXRpZXModGV4dCk7XHJcbiAgICAgICAgY29udGVudCArPSBjbGVhblRleHQ7XHJcbiAgICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICAgIHRleHQ6IGNsZWFuVGV4dC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXG5cXG5cIiksXHJcbiAgICAgICAgICBmb3JtYXR0aW5nOiByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfmqggRW1lcmdlbmN5IGV4dHJhY3RlZCBjb250ZW50WyR7aW5kZXh9XTogJHtKU09OLnN0cmluZ2lmeShcclxuICAgICAgICAgICAgY2xlYW5UZXh0XHJcbiAgICAgICAgICApfWBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBBZGQgYnJlYWtzIGJldHdlZW4gY29udGVudCBpdGVtcyAoc2ltcGxlIDE6MSByYXRpbylcclxuICAgICAgICBpZiAoaW5kZXggPCBleHRyYWN0ZWRCcmVha3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICBjb25zdCBsaW5lQnJlYWtUZXh0ID0gXCJcXG5cIjtcclxuICAgICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgIHRleHQ6IGxpbmVCcmVha1RleHRcclxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKVxyXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgICBicmVha1R5cGU6IFwibGluZVwiLFxyXG4gICAgICAgICAgICAgIHNvdXJjZTogXCJlbWVyZ2VuY3kgZXh0cmFjdGlvblwiLFxyXG4gICAgICAgICAgICAgIGVtZXJnZW5jeUluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBg8J+aqCBFbWVyZ2VuY3kgZXh0cmFjdGVkIGJyZWFrWyR7aW5kZXh9XTogJHtKU09OLnN0cmluZ2lmeShcclxuICAgICAgICAgICAgICBsaW5lQnJlYWtUZXh0XHJcbiAgICAgICAgICAgICl9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gQWRkIGFueSByZW1haW5pbmcgYnJlYWtzIGF0IHRoZSBlbmRcclxuICAgICAgZm9yIChsZXQgaSA9IGV4dHJhY3RlZFRleHRzLmxlbmd0aDsgaSA8IGV4dHJhY3RlZEJyZWFrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSBcIlxcblwiO1xyXG4gICAgICAgIGNvbnRlbnQgKz0gbGluZUJyZWFrVGV4dDtcclxuICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgdGV4dDogbGluZUJyZWFrVGV4dFxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcblxcblwiKSxcclxuICAgICAgICAgIGZvcm1hdHRpbmc6IHtcclxuICAgICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgICAgYnJlYWtUeXBlOiBcImxpbmVcIixcclxuICAgICAgICAgICAgc291cmNlOiBcImVtZXJnZW5jeSB0cmFpbGluZyBicmVha1wiLFxyXG4gICAgICAgICAgICBlbWVyZ2VuY3lJbmRleDogaSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfmqggRW1lcmdlbmN5IGV4dHJhY3RlZCB0cmFpbGluZyBicmVha1ske2l9XTogJHtKU09OLnN0cmluZ2lmeShcclxuICAgICAgICAgICAgbGluZUJyZWFrVGV4dFxyXG4gICAgICAgICAgKX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKchSBFbWVyZ2VuY3kgZXh0cmFjdGlvbiBzdWNjZXNzZnVsOiAke2V4dHJhY3RlZFRleHRzLmxlbmd0aH0gdGV4dHMsICR7ZXh0cmFjdGVkQnJlYWtzLmxlbmd0aH0gYnJlYWtzYFxyXG4gICAgICApO1xyXG4gICAgfSBjYXRjaCAoZW1lcmdlbmN5RXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfkoAgRW1lcmdlbmN5IGV4dHJhY3Rpb24gZmFpbGVkOiAke2VtZXJnZW5jeUVycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgIC8vIExhc3QgcmVzb3J0OiBqdXN0IGFkZCBhIHdhcm5pbmcgY29tbWVudFxyXG4gICAgICBjb25zdCB3YXJuaW5nVGV4dCA9IFwiPCEtLSBYTUwgcGFyc2luZyBlcnJvciAtLT5cIjtcclxuICAgICAgY29udGVudCArPSB3YXJuaW5nVGV4dDtcclxuICAgICAgZm9ybWF0dGVkQ29udGVudC5wdXNoKHtcclxuICAgICAgICB0ZXh0OiB3YXJuaW5nVGV4dC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXG5cXG5cIiksXHJcbiAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGVudDtcclxuICB9XHJcblxyXG4gIC8vIFByb2Nlc3MgaW50ZXJsZWF2ZWQgQ29udGVudCBhbmQgQnIgZWxlbWVudHMgLSBGVUxMWSBEWU5BTUlDXHJcbiAgcHJvY2Vzc0ludGVybGVhdmVkQ29udGVudEFuZEJyKFxyXG4gICAgcmFuZ2UsXHJcbiAgICByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICBjb250ZW50LFxyXG4gICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgIGRlYnVnSW5mbyxcclxuICAgIGZpbGVOYW1lXHJcbiAgKSB7XHJcbiAgICBjb25zdCBjb250ZW50cyA9IEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudClcclxuICAgICAgPyByYW5nZS5Db250ZW50XHJcbiAgICAgIDogW3JhbmdlLkNvbnRlbnRdO1xyXG4gICAgY29uc3QgYnJFbGVtZW50cyA9IEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpID8gcmFuZ2UuQnIgOiBbcmFuZ2UuQnJdO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBg8J+UpyBQcm9jZXNzaW5nIGludGVybGVhdmVkIGNvbnRlbnQ6ICR7Y29udGVudHMubGVuZ3RofSBjb250ZW50IGl0ZW1zLCAke2JyRWxlbWVudHMubGVuZ3RofSBCciBlbGVtZW50c2BcclxuICAgICk7XHJcblxyXG4gICAgLy8gRURHRSBDQVNFOiBObyBjb250ZW50IG9yIGJyZWFrc1xyXG4gICAgaWYgKCFyYW5nZS5Db250ZW50ICYmICFyYW5nZS5Ccikge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIE5vIGNvbnRlbnQgb3IgYnJlYWtzIHRvIHByb2Nlc3MgaW4gcmFuZ2VgKTtcclxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRURHRSBDQVNFOiBPbmx5IGNvbnRlbnQsIG5vIGJyZWFrc1xyXG4gICAgaWYgKHJhbmdlLkNvbnRlbnQgJiYgIXJhbmdlLkJyKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIE9ubHkgY29udGVudCwgbm8gYnJlYWtzIC0gcHJvY2Vzc2luZyBjb250ZW50IG9ubHlgKTtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0NvbnRlbnRFbGVtZW50cyhcclxuICAgICAgICByYW5nZSxcclxuICAgICAgICByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgICAgIGZpbGVOYW1lXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRURHRSBDQVNFOiBPbmx5IGJyZWFrcywgbm8gY29udGVudFxyXG4gICAgaWYgKCFyYW5nZS5Db250ZW50ICYmIHJhbmdlLkJyKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SXIE9ubHkgYnJlYWtzLCBubyBjb250ZW50IC0gcHJvY2Vzc2luZyBicmVha3Mgb25seWApO1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzQnJFbGVtZW50cyhcclxuICAgICAgICByYW5nZSxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGZvcm1hdHRlZENvbnRlbnQsXHJcbiAgICAgICAgZGVidWdJbmZvLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgZmlsZU5hbWVcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEWU5BTUlDOiBUcnkgdG8gdXNlIGNhY2hlZCBkb2N1bWVudCBvcmRlciBpZiBhdmFpbGFibGVcclxuICAgIGNvbnN0IGNhY2hlZE9yZGVyID1cclxuICAgICAgdGhpcy5kb2N1bWVudE9yZGVyQ2FjaGUgJiYgdGhpcy5kb2N1bWVudE9yZGVyQ2FjaGVbZmlsZU5hbWVdO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgY2FjaGVkT3JkZXIgJiZcclxuICAgICAgY2FjaGVkT3JkZXIuYnJlYWtQYXR0ZXJuICYmXHJcbiAgICAgIGNhY2hlZE9yZGVyLmJyZWFrUGF0dGVybi5sZW5ndGggPiAwXHJcbiAgICApIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKchSBVc2luZyBjYWNoZWQgZG9jdW1lbnQgb3JkZXIgZm9yIHByZWNpc2UgYnJlYWsgZGlzdHJpYnV0aW9uYFxyXG4gICAgICApO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NDb250ZW50V2l0aENhY2hlZFBhdHRlcm4oXHJcbiAgICAgICAgICBjb250ZW50cyxcclxuICAgICAgICAgIHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgICAgICAgY2FjaGVkT3JkZXIuYnJlYWtQYXR0ZXJuLFxyXG4gICAgICAgICAgZmlsZU5hbWVcclxuICAgICAgICApO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYOKdjCBFcnJvciB1c2luZyBjYWNoZWQgcGF0dGVybjogJHtlcnJvci5tZXNzYWdlfSwgZmFsbGluZyBiYWNrIHRvIGR5bmFtaWMgZGlzdHJpYnV0aW9uYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDimqDvuI8gTm8gY2FjaGVkIGRvY3VtZW50IG9yZGVyIGF2YWlsYWJsZSwgdXNpbmcgZHluYW1pYyBmYWxsYmFjayBkaXN0cmlidXRpb25gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRFlOQU1JQyBGQUxMQkFDSzogRGlzdHJpYnV0ZSBicmVha3MgaW50ZWxsaWdlbnRseSBiYXNlZCBvbiBjb250ZW50IHN0cnVjdHVyZVxyXG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0ludGVybGVhdmVkQ29udGVudER5bmFtaWNGYWxsYmFjayhcclxuICAgICAgY29udGVudHMsXHJcbiAgICAgIGJyRWxlbWVudHMsXHJcbiAgICAgIHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgY29udGVudCxcclxuICAgICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgICAgZmlsZU5hbWVcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBEWU5BTUlDIEZBTExCQUNLOiBJbnRlbGxpZ2VudCBicmVhayBkaXN0cmlidXRpb24gZm9yIGFueSBjb250ZW50IHN0cnVjdHVyZVxyXG4gIHByb2Nlc3NJbnRlcmxlYXZlZENvbnRlbnREeW5hbWljRmFsbGJhY2soXHJcbiAgICBjb250ZW50cyxcclxuICAgIGJyRWxlbWVudHMsXHJcbiAgICByZXNvbHZlZEZvcm1hdHRpbmcsXHJcbiAgICBjb250ZW50LFxyXG4gICAgZm9ybWF0dGVkQ29udGVudCxcclxuICAgIGZpbGVOYW1lXHJcbiAgKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCflIQgVXNpbmcgZHluYW1pYyBmYWxsYmFjayBmb3IgJHtjb250ZW50cy5sZW5ndGh9IGNvbnRlbnQgaXRlbXMgYW5kICR7YnJFbGVtZW50cy5sZW5ndGh9IGJyZWFrc2BcclxuICAgICk7XHJcblxyXG4gICAgbGV0IGJySW5kZXggPSAwO1xyXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IGNvbnRlbnRzLmxlbmd0aDtcclxuXHJcbiAgICBjb250ZW50cy5mb3JFYWNoKChjb250ZW50SXRlbSwgY29udGVudEluZGV4KSA9PiB7XHJcbiAgICAgIC8vIEFkZCB0aGUgY29udGVudFxyXG4gICAgICBjb25zdCB0ZXh0ID0gSURNTFV0aWxzLmRlY29kZVhNTEVudGl0aWVzKFN0cmluZyhjb250ZW50SXRlbSkpO1xyXG4gICAgICBjb250ZW50ICs9IHRleHQ7XHJcbiAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgdGV4dDogdGV4dC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXG5cXG5cIiksXHJcbiAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SnIEFkZGVkIGNvbnRlbnRbJHtjb250ZW50SW5kZXh9XTogJHtKU09OLnN0cmluZ2lmeSh0ZXh0KX1gKTtcclxuXHJcbiAgICAgIC8vIERZTkFNSUM6IENhbGN1bGF0ZSBob3cgbWFueSBicmVha3MgdG8gYWRkIGFmdGVyIHRoaXMgY29udGVudFxyXG4gICAgICBjb25zdCBicmVha3NUb0FkZCA9IHRoaXMuY2FsY3VsYXRlQnJlYWtzQWZ0ZXJDb250ZW50KFxyXG4gICAgICAgIGNvbnRlbnRJbmRleCxcclxuICAgICAgICBjb250ZW50TGVuZ3RoLFxyXG4gICAgICAgIGJyRWxlbWVudHMubGVuZ3RoXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBBZGQgdGhlIGNhbGN1bGF0ZWQgbnVtYmVyIG9mIGJyZWFrc1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJyZWFrc1RvQWRkICYmIGJySW5kZXggPCBickVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluZUJyZWFrVGV4dCA9IFwiXFxuXCI7XHJcbiAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0XHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICBicmVha1R5cGU6IFwibGluZVwiLFxyXG4gICAgICAgICAgICBzb3VyY2U6IFwiZHluYW1pYyBmYWxsYmFjayBkaXN0cmlidXRpb25cIixcclxuICAgICAgICAgICAgYnJJbmRleDogYnJJbmRleCxcclxuICAgICAgICAgICAgYWZ0ZXJDb250ZW50OiBjb250ZW50SW5kZXgsXHJcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRCcmVha3M6IGJyZWFrc1RvQWRkLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBg8J+UpyBBZGRlZCBCclske2JySW5kZXh9XSBhZnRlciBjb250ZW50WyR7Y29udGVudEluZGV4fV06ICR7SlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgICAgICAgIGxpbmVCcmVha1RleHRcclxuICAgICAgICAgICl9YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYnJJbmRleCsrO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBFREdFIENBU0U6IEhhbmRsZSBhbnkgcmVtYWluaW5nIGJyZWFrc1xyXG4gICAgaWYgKGJySW5kZXggPCBickVsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCByZW1haW5pbmdCcmVha3MgPSBickVsZW1lbnRzLmxlbmd0aCAtIGJySW5kZXg7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SnIEFkZGluZyAke3JlbWFpbmluZ0JyZWFrc30gcmVtYWluaW5nIGJyZWFrcyBhdCB0aGUgZW5kYCk7XHJcblxyXG4gICAgICB3aGlsZSAoYnJJbmRleCA8IGJyRWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgbGluZUJyZWFrVGV4dCA9IFwiXFxuXCI7XHJcbiAgICAgICAgY29udGVudCArPSBsaW5lQnJlYWtUZXh0O1xyXG4gICAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0XHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICBpc0JyZWFrOiB0cnVlLFxyXG4gICAgICAgICAgICBicmVha1R5cGU6IFwibGluZVwiLFxyXG4gICAgICAgICAgICBzb3VyY2U6IFwidHJhaWxpbmcgYnJlYWtzIChkeW5hbWljIGZhbGxiYWNrKVwiLFxyXG4gICAgICAgICAgICBickluZGV4OiBickluZGV4LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBg8J+UpyBBZGRlZCB0cmFpbGluZyBCclske2JySW5kZXh9XTogJHtKU09OLnN0cmluZ2lmeShsaW5lQnJlYWtUZXh0KX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgICBickluZGV4Kys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBWQUxJREFUSU9OOiBFbnN1cmUgYWxsIGJyZWFrcyB3ZXJlIHByb2Nlc3NlZFxyXG4gICAgaWYgKGJySW5kZXggIT09IGJyRWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDimqDvuI8gV2FybmluZzogRXhwZWN0ZWQgdG8gcHJvY2VzcyAke2JyRWxlbWVudHMubGVuZ3RofSBicmVha3MgYnV0IHByb2Nlc3NlZCAke2JySW5kZXh9YFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gUHJvY2VzcyBjb250ZW50IHVzaW5nIGNhY2hlZCBkb2N1bWVudCBvcmRlciBwYXR0ZXJuIC0gRlVMTFkgRFlOQU1JQ1xyXG4gIHByb2Nlc3NDb250ZW50V2l0aENhY2hlZFBhdHRlcm4oXHJcbiAgICBjb250ZW50cyxcclxuICAgIHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBmb3JtYXR0ZWRDb250ZW50LFxyXG4gICAgYnJlYWtQYXR0ZXJuLFxyXG4gICAgZmlsZU5hbWVcclxuICApIHtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBg8J+OryBQcm9jZXNzaW5nICR7Y29udGVudHMubGVuZ3RofSBjb250ZW50IGl0ZW1zIHdpdGggY2FjaGVkIHBhdHRlcm4gKCR7YnJlYWtQYXR0ZXJuLmxlbmd0aH0gcGF0dGVybiBlbnRyaWVzKWBcclxuICAgICk7XHJcblxyXG4gICAgLy8gRFlOQU1JQzogSGFuZGxlIGFueSBudW1iZXIgb2YgY29udGVudCBpdGVtcyBhbmQgYW55IGJyZWFrIGRpc3RyaWJ1dGlvblxyXG4gICAgY29udGVudHMuZm9yRWFjaCgoY29udGVudEl0ZW0sIGNvbnRlbnRJbmRleCkgPT4ge1xyXG4gICAgICAvLyBBZGQgdGhlIGNvbnRlbnRcclxuICAgICAgY29uc3QgdGV4dCA9IElETUxVdGlscy5kZWNvZGVYTUxFbnRpdGllcyhTdHJpbmcoY29udGVudEl0ZW0pKTtcclxuICAgICAgY29udGVudCArPSB0ZXh0O1xyXG4gICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgIHRleHQ6IHRleHQucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpLFxyXG4gICAgICAgIGZvcm1hdHRpbmc6IHJlc29sdmVkRm9ybWF0dGluZyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UpyBBZGRlZCBjb250ZW50WyR7Y29udGVudEluZGV4fV06ICR7SlNPTi5zdHJpbmdpZnkodGV4dCl9YCk7XHJcblxyXG4gICAgICAvLyBEWU5BTUlDOiBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIHBhdHRlcm4gZW50cnlcclxuICAgICAgY29uc3QgcGF0dGVybkVudHJ5ID0gYnJlYWtQYXR0ZXJuLmZpbmQoXHJcbiAgICAgICAgKHApID0+IHAuY29udGVudEluZGV4ID09PSBjb250ZW50SW5kZXhcclxuICAgICAgKTtcclxuICAgICAgaWYgKHBhdHRlcm5FbnRyeSkge1xyXG4gICAgICAgIGNvbnN0IGJyZWFrc1RvQWRkID0gcGF0dGVybkVudHJ5LmJyZWFrc0FmdGVyO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfjq8gUGF0dGVybiBzYXlzIGNvbnRlbnRbJHtjb250ZW50SW5kZXh9XSBzaG91bGQgaGF2ZSAke2JyZWFrc1RvQWRkfSBicmVha3MgYWZ0ZXIgaXRgXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRFlOQU1JQzogQWRkIHRoZSBleGFjdCBudW1iZXIgb2YgYnJlYWtzIHNwZWNpZmllZCBpbiB0aGUgcGF0dGVyblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnJlYWtzVG9BZGQ7IGkrKykge1xyXG4gICAgICAgICAgY29uc3QgbGluZUJyZWFrVGV4dCA9IFwiXFxuXCI7XHJcbiAgICAgICAgICBjb250ZW50ICs9IGxpbmVCcmVha1RleHQ7XHJcbiAgICAgICAgICBmb3JtYXR0ZWRDb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICB0ZXh0OiBsaW5lQnJlYWtUZXh0XHJcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXG5cIilcclxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcblxcblwiKSxcclxuICAgICAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICAgIGlzQnJlYWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgYnJlYWtUeXBlOiBcImxpbmVcIixcclxuICAgICAgICAgICAgICBzb3VyY2U6IFwicHJlY2lzZSBkb2N1bWVudCBvcmRlclwiLFxyXG4gICAgICAgICAgICAgIGNvbnRlbnRJbmRleDogY29udGVudEluZGV4LFxyXG4gICAgICAgICAgICAgIGJyZWFrSW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgdG90YWxCcmVha3NBZnRlckNvbnRlbnQ6IGJyZWFrc1RvQWRkLFxyXG4gICAgICAgICAgICAgIHBhdHRlcm5FbnRyeTogcGF0dGVybkVudHJ5LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGDwn46vIEFkZGVkIHByZWNpc2UgQnJbJHtcclxuICAgICAgICAgICAgICBpICsgMVxyXG4gICAgICAgICAgICB9LyR7YnJlYWtzVG9BZGR9XSBhZnRlciBjb250ZW50WyR7Y29udGVudEluZGV4fV06ICR7SlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgICAgICAgICAgbGluZUJyZWFrVGV4dFxyXG4gICAgICAgICAgICApfWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYOKaoO+4jyBObyBwYXR0ZXJuIGVudHJ5IGZvdW5kIGZvciBjb250ZW50WyR7Y29udGVudEluZGV4fV0gLSB0aGlzIGlzIHVudXN1YWwgYnV0IG5vdCBjcml0aWNhbGBcclxuICAgICAgICApO1xyXG4gICAgICAgIC8vIERZTkFNSUM6IElmIG5vIHBhdHRlcm4gZW50cnksIGRvbid0IGFkZCBhbnkgYnJlYWtzICh0aGUgcGF0dGVybiBzaG91bGQgY292ZXIgYWxsIGNvbnRlbnQpXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFZBTElEQVRJT046IENoZWNrIGlmIHdlIHByb2Nlc3NlZCBhbGwgZXhwZWN0ZWQgY29udGVudFxyXG4gICAgY29uc3QgZXhwZWN0ZWRDb250ZW50Q291bnQgPSBicmVha1BhdHRlcm4ubGVuZ3RoO1xyXG4gICAgaWYgKGNvbnRlbnRzLmxlbmd0aCAhPT0gZXhwZWN0ZWRDb250ZW50Q291bnQpIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKaoO+4jyBXYXJuaW5nOiBFeHBlY3RlZCAke2V4cGVjdGVkQ29udGVudENvdW50fSBjb250ZW50IGl0ZW1zIGJ1dCBwcm9jZXNzZWQgJHtjb250ZW50cy5sZW5ndGh9YFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gRFlOQU1JQzogQ2FsY3VsYXRlIGJyZWFrcyBkaXN0cmlidXRpb24gYXMgZmFsbGJhY2sgLSBjb21wbGV0ZWx5IGdlbmVyaWNcclxuICBjYWxjdWxhdGVCcmVha3NBZnRlckNvbnRlbnQoY29udGVudEluZGV4LCB0b3RhbENvbnRlbnQsIHRvdGFsQnJlYWtzKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCflKcgRkFMTEJBQ0s6IENhbGN1bGF0aW5nIGJyZWFrcyBmb3IgY29udGVudFske2NvbnRlbnRJbmRleH1dIG9mICR7dG90YWxDb250ZW50fSB0b3RhbCwgJHt0b3RhbEJyZWFrc30gdG90YWwgYnJlYWtzYFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBFREdFIENBU0U6IE5vIGJyZWFrcyB0byBkaXN0cmlidXRlXHJcbiAgICBpZiAodG90YWxCcmVha3MgPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coYPCflKcgTm8gYnJlYWtzIHRvIGRpc3RyaWJ1dGVgKTtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRURHRSBDQVNFOiBPbmx5IG9uZSBjb250ZW50IGl0ZW1cclxuICAgIGlmICh0b3RhbENvbnRlbnQgPT09IDEpIHtcclxuICAgICAgY29uc29sZS5sb2coYPCflKcgU2luZ2xlIGNvbnRlbnQgaXRlbSBnZXRzIGFsbCAke3RvdGFsQnJlYWtzfSBicmVha3NgKTtcclxuICAgICAgcmV0dXJuIGNvbnRlbnRJbmRleCA9PT0gMCA/IHRvdGFsQnJlYWtzIDogMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFREdFIENBU0U6IExhc3QgY29udGVudCBpdGVtXHJcbiAgICBpZiAoY29udGVudEluZGV4ID09PSB0b3RhbENvbnRlbnQgLSAxKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDwn5SnIExhc3QgY29udGVudCBpdGVtIGdldHMgbm8gYnJlYWtzIGluIHN0YW5kYXJkIGRpc3RyaWJ1dGlvbmBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRFlOQU1JQzogRGlzdHJpYnV0ZSBicmVha3MgYW1vbmcgbm9uLWxhc3QgY29udGVudCBpdGVtc1xyXG4gICAgY29uc3Qgbm9uTGFzdENvbnRlbnRJdGVtcyA9IHRvdGFsQ29udGVudCAtIDE7XHJcbiAgICBjb25zdCBiYXNlQnJlYWtzID0gTWF0aC5mbG9vcih0b3RhbEJyZWFrcyAvIG5vbkxhc3RDb250ZW50SXRlbXMpO1xyXG4gICAgY29uc3QgZXh0cmFCcmVha3MgPSB0b3RhbEJyZWFrcyAlIG5vbkxhc3RDb250ZW50SXRlbXM7XHJcblxyXG4gICAgLy8gRFlOQU1JQzogRGlzdHJpYnV0ZSBleHRyYSBicmVha3Mgc3RhcnRpbmcgZnJvbSB0aGUgZW5kIHRvIG1hdGNoIGNvbW1vbiBJRE1MIHBhdHRlcm5zXHJcbiAgICAvLyB3aGVyZSBsYXRlciBjb250ZW50IHRlbmRzIHRvIGhhdmUgbW9yZSBicmVha3NcclxuICAgIGNvbnN0IGJyZWFrc0ZvclRoaXNDb250ZW50ID1cclxuICAgICAgYmFzZUJyZWFrcyArIChjb250ZW50SW5kZXggPj0gbm9uTGFzdENvbnRlbnRJdGVtcyAtIGV4dHJhQnJlYWtzID8gMSA6IDApO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBg8J+UpyBDb250ZW50WyR7Y29udGVudEluZGV4fV0gZ2V0cyAke2JyZWFrc0ZvclRoaXNDb250ZW50fSBicmVha3MgKGJhc2U6ICR7YmFzZUJyZWFrc30sIGV4dHJhOiAke2V4dHJhQnJlYWtzfSlgXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBicmVha3NGb3JUaGlzQ29udGVudDtcclxuICB9XHJcblxyXG4gIC8vIFByb2Nlc3Mgb25seSBDb250ZW50IGVsZW1lbnRzXHJcbiAgcHJvY2Vzc0NvbnRlbnRFbGVtZW50cyhcclxuICAgIHJhbmdlLFxyXG4gICAgcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgY29udGVudCxcclxuICAgIGZvcm1hdHRlZENvbnRlbnQsXHJcbiAgICBmaWxlTmFtZVxyXG4gICkge1xyXG4gICAgY29uc3QgY29udGVudHMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkNvbnRlbnQpXHJcbiAgICAgID8gcmFuZ2UuQ29udGVudFxyXG4gICAgICA6IFtyYW5nZS5Db250ZW50XTtcclxuXHJcbiAgICBjb250ZW50cy5mb3JFYWNoKChjb250ZW50SXRlbSkgPT4ge1xyXG4gICAgICBjb25zdCB0ZXh0ID0gSURNTFV0aWxzLmRlY29kZVhNTEVudGl0aWVzKFN0cmluZyhjb250ZW50SXRlbSkpO1xyXG4gICAgICBjb250ZW50ICs9IHRleHQ7XHJcbiAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgdGV4dDogdGV4dC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXG5cXG5cIiksXHJcbiAgICAgICAgZm9ybWF0dGluZzogcmVzb2x2ZWRGb3JtYXR0aW5nLFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICAvLyBQcm9jZXNzIG9ubHkgQnIgZWxlbWVudHNcclxuICBwcm9jZXNzQnJFbGVtZW50cyhcclxuICAgIHJhbmdlLFxyXG4gICAgY29udGVudCxcclxuICAgIGZvcm1hdHRlZENvbnRlbnQsXHJcbiAgICBkZWJ1Z0luZm8sXHJcbiAgICByYW5nZUluZGV4LFxyXG4gICAgZmlsZU5hbWVcclxuICApIHtcclxuICAgIGNvbnN0IGJyRWxlbWVudHMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkJyKSA/IHJhbmdlLkJyIDogW3JhbmdlLkJyXTtcclxuXHJcbiAgICBickVsZW1lbnRzLmZvckVhY2goKGJyLCBickluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGxpbmVCcmVha1RleHQgPSBcIlxcblwiO1xyXG4gICAgICBjb250ZW50ICs9IGxpbmVCcmVha1RleHQ7XHJcbiAgICAgIGZvcm1hdHRlZENvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgdGV4dDogbGluZUJyZWFrVGV4dC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXG5cXG5cIiksXHJcbiAgICAgICAgZm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgaXNCcmVhazogdHJ1ZSxcclxuICAgICAgICAgIGJyZWFrVHlwZTogXCJsaW5lXCIsXHJcbiAgICAgICAgICBzb3VyY2U6IFwic3RhbmRhbG9uZSBCciBlbGVtZW50XCIsXHJcbiAgICAgICAgICByYW5nZUluZGV4OiByYW5nZUluZGV4LFxyXG4gICAgICAgICAgYnJJbmRleDogYnJJbmRleCxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGRlYnVnSW5mby5wdXNoKHtcclxuICAgICAgICB0eXBlOiBcIlN0YW5kYWxvbmUgQnIgZWxlbWVudFwiLFxyXG4gICAgICAgIGxvY2F0aW9uOiBgQ2hhcmFjdGVyU3R5bGVSYW5nZVske3JhbmdlSW5kZXh9XSwgQnJbJHtickluZGV4fV1gLFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgdGhpcyBoZWxwZXIgbWV0aG9kIHRvIGJldHRlciBoYW5kbGUgbWl4ZWQgY29udGVudCBhbmQgQnIgZWxlbWVudHNcclxuICBhbmFseXplQ29udGVudFN0cnVjdHVyZShyYW5nZSkge1xyXG4gICAgY29uc3Qgc3RydWN0dXJlID0ge1xyXG4gICAgICBoYXNDb250ZW50OiAhIXJhbmdlLkNvbnRlbnQsXHJcbiAgICAgIGhhc0JyOiByYW5nZS5CciAhPT0gdW5kZWZpbmVkLFxyXG4gICAgICBjb250ZW50SXRlbXM6IHJhbmdlLkNvbnRlbnRcclxuICAgICAgICA/IEFycmF5LmlzQXJyYXkocmFuZ2UuQ29udGVudClcclxuICAgICAgICAgID8gcmFuZ2UuQ29udGVudFxyXG4gICAgICAgICAgOiBbcmFuZ2UuQ29udGVudF1cclxuICAgICAgICA6IFtdLFxyXG4gICAgICBickVsZW1lbnRzOiByYW5nZS5CclxyXG4gICAgICAgID8gQXJyYXkuaXNBcnJheShyYW5nZS5CcilcclxuICAgICAgICAgID8gcmFuZ2UuQnJcclxuICAgICAgICAgIDogW3JhbmdlLkJyXVxyXG4gICAgICAgIDogW10sXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiQ29udGVudCBzdHJ1Y3R1cmUgYW5hbHlzaXM6XCIsIHN0cnVjdHVyZSk7XHJcbiAgICByZXR1cm4gc3RydWN0dXJlO1xyXG4gIH1cclxuXHJcbiAgLy8gRW5oYW5jZWQgaGVscGVyIGZvciBwcm9jZXNzaW5nIGludGVybGVhdmVkIGNvbnRlbnQgYW5kIGJyZWFrc1xyXG4gIHByb2Nlc3NJbnRlcmxlYXZlZENvbnRlbnQocmFuZ2UsIHJlc29sdmVkRm9ybWF0dGluZykge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xyXG5cclxuICAgIC8vIFRoaXMgbWV0aG9kIHdvdWxkIG5lZWQgYWNjZXNzIHRvIHRoZSBhY3R1YWwgWE1MIHN0cnVjdHVyZSB0byBkZXRlcm1pbmVcclxuICAgIC8vIHRoZSBleGFjdCBvcmRlciBvZiBDb250ZW50IGFuZCBCciBlbGVtZW50cy4gRm9yIG5vdywgd2UnbGwgdXNlIHRoZVxyXG4gICAgLy8gYXBwcm9hY2ggYWJvdmUgd2hpY2ggaGFuZGxlcyB0aGUgbW9zdCBjb21tb24gY2FzZS5cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IEhlbHBlciBtZXRob2QgdG8gZXh0cmFjdCBCciBlbGVtZW50cyB3aXRoIGNvbnRleHRcclxuICBleHRyYWN0QnJFbGVtZW50cyhyYW5nZSkge1xyXG4gICAgY29uc3QgYnJFbGVtZW50cyA9IFtdO1xyXG5cclxuICAgIGlmIChyYW5nZS5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBQcm9jZXNzaW5nIEJyIGVsZW1lbnRzOlwiLCB7XHJcbiAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheShyYW5nZS5CciksXHJcbiAgICAgICAgY291bnQ6IEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpID8gcmFuZ2UuQnIubGVuZ3RoIDogMSxcclxuICAgICAgICByYXdCcjogcmFuZ2UuQnIsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmFuZ2UuQnIpKSB7XHJcbiAgICAgICAgcmFuZ2UuQnIuZm9yRWFjaCgoYnIsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICBickVsZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiBcImxpbmVcIixcclxuICAgICAgICAgICAgcG9zaXRpb246IGluZGV4ID09PSAwID8gXCJzdGFydFwiIDogXCJtaWRkbGVcIixcclxuICAgICAgICAgICAgZWxlbWVudDogYnIsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDwn5SnIENyZWF0ZWQgJHtickVsZW1lbnRzLmxlbmd0aH0gbGluZSBicmVhayBlbGVtZW50cyBmcm9tIGFycmF5IC0gRUFDSCBTSE9VTEQgQ1JFQVRFIE9ORSBcXFxcbmBcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJyRWxlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcclxuICAgICAgICAgIHBvc2l0aW9uOiBcImVuZFwiLFxyXG4gICAgICAgICAgZWxlbWVudDogcmFuZ2UuQnIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SnIENyZWF0ZWQgMSBsaW5lIGJyZWFrIGVsZW1lbnQgZnJvbSBzaW5nbGUgQnJcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYnJFbGVtZW50cztcclxuICB9XHJcblxyXG4gIC8vIFNPUEhJU1RJQ0FURUQ6IERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgbGluZSBicmVhayB0eXBlXHJcbiAgZGV0ZXJtaW5lTGluZUJyZWFrVHlwZShickluZm8sIGNvbnRleHQpIHtcclxuICAgIC8vIERpZmZlcmVudCBsaW5lIGJyZWFrIGNoYXJhY3RlcnMgYmFzZWQgb24gY29udGV4dFxyXG4gICAgc3dpdGNoIChickluZm8udHlwZSkge1xyXG4gICAgICBjYXNlIFwicGFyYWdyYXBoXCI6XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuXFxuXCI7IC8vIERvdWJsZSBsaW5lIGJyZWFrIGZvciBwYXJhZ3JhcGggc2VwYXJhdGlvblxyXG4gICAgICBjYXNlIFwiZm9yY2VkXCI6XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuXCI7IC8vIEZvcmNlZCBsaW5lIGJyZWFrIChTaGlmdCtFbnRlciBlcXVpdmFsZW50KVxyXG4gICAgICBjYXNlIFwibGluZVwiOlxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBcIlxcblwiOyAvLyBTdGFuZGFyZCBsaW5lIGJyZWFrXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBEZXRlcm1pbmUgaWYgYW4gaW1wbGljaXQgbGluZSBicmVhayBzaG91bGQgYmUgaW5zZXJ0ZWRcclxuICBzaG91bGRJbnNlcnRJbXBsaWNpdExpbmVCcmVhayhjdXJyZW50UmFuZ2UsIG5leHRSYW5nZSwgY29udGV4dCkge1xyXG4gICAgLy8gRG9uJ3QgaW5zZXJ0IGltcGxpY2l0IGJyZWFrcyBpZiBleHBsaWNpdCBCciBlbGVtZW50cyBhcmUgcHJlc2VudFxyXG4gICAgaWYgKGN1cnJlbnRSYW5nZS5CciAhPT0gdW5kZWZpbmVkIHx8IG5leHRSYW5nZS5CciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbnNlcnQgYnJlYWtzIGJldHdlZW4gZGlmZmVyZW50IGNoYXJhY3RlciBzdHlsZXMgaW4gZGlmZmVyZW50IHBhcmFncmFwaHNcclxuICAgIGNvbnN0IGN1cnJlbnRDaGFyU3R5bGUgPSBjdXJyZW50UmFuZ2VbXCJAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZVwiXTtcclxuICAgIGNvbnN0IG5leHRDaGFyU3R5bGUgPSBuZXh0UmFuZ2VbXCJAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZVwiXTtcclxuXHJcbiAgICAvLyBJZiB3ZSdyZSBpbiBhIGNvbnRleHQgd2hlcmUgc3R5bGVzIGNoYW5nZSBzaWduaWZpY2FudGx5LCBhZGQgYSBicmVha1xyXG4gICAgaWYgKFxyXG4gICAgICBjdXJyZW50Q2hhclN0eWxlICYmXHJcbiAgICAgIG5leHRDaGFyU3R5bGUgJiZcclxuICAgICAgY3VycmVudENoYXJTdHlsZSAhPT0gbmV4dENoYXJTdHlsZVxyXG4gICAgKSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgbWlnaHQgYmUgYSB0aXRsZS9oZWFkaW5nIGZvbGxvd2VkIGJ5IGJvZHkgdGV4dFxyXG4gICAgICBjb25zdCBzdHlsZUluZGljYXRlc0JyZWFrID0gdGhpcy5zdHlsZUluZGljYXRlc0xpbmVCcmVhayhcclxuICAgICAgICBjdXJyZW50Q2hhclN0eWxlLFxyXG4gICAgICAgIG5leHRDaGFyU3R5bGVcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHN0eWxlSW5kaWNhdGVzQnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gU09QSElTVElDQVRFRDogQW5hbHl6ZSBpZiBzdHlsZSBjaGFuZ2UgaW5kaWNhdGVzIGEgbGluZSBicmVha1xyXG4gIHN0eWxlSW5kaWNhdGVzTGluZUJyZWFrKGN1cnJlbnRTdHlsZSwgbmV4dFN0eWxlKSB7XHJcbiAgICBjb25zdCB0aXRsZUluZGljYXRvcnMgPSBbXCJ0aXRsZVwiLCBcImhlYWRpbmdcIiwgXCJoZWFkZXJcIl07XHJcbiAgICBjb25zdCBib2R5SW5kaWNhdG9ycyA9IFtcImJvZHlcIiwgXCJ0ZXh0XCIsIFwibm9ybWFsXCJdO1xyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRJc1RpdGxlID0gdGl0bGVJbmRpY2F0b3JzLnNvbWUoKGluZGljYXRvcikgPT5cclxuICAgICAgY3VycmVudFN0eWxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5kaWNhdG9yKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IG5leHRJc0JvZHkgPSBib2R5SW5kaWNhdG9ycy5zb21lKChpbmRpY2F0b3IpID0+XHJcbiAgICAgIG5leHRTdHlsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGluZGljYXRvcilcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIGN1cnJlbnRJc1RpdGxlICYmIG5leHRJc0JvZHk7XHJcbiAgfVxyXG5cclxuICAvLyBTT1BISVNUSUNBVEVEOiBBbmFseXplIGxpbmUgYnJlYWsgdHlwZXMgaW4gZm9ybWF0dGVkIGNvbnRlbnRcclxuICBhbmFseXplTGluZUJyZWFrVHlwZXMoZm9ybWF0dGVkQ29udGVudCkge1xyXG4gICAgY29uc3QgdHlwZXMgPSB7XHJcbiAgICAgIGV4cGxpY2l0OiAwLCAvLyBGcm9tIDxCci8+IGVsZW1lbnRzXHJcbiAgICAgIGltcGxpY2l0OiAwLCAvLyBJbmZlcnJlZCBmcm9tIHN0eWxlIGNoYW5nZXNcclxuICAgICAgcGFyYWdyYXBoOiAwLCAvLyBCZXR3ZWVuIHBhcmFncmFwaHNcclxuICAgICAgZGlyZWN0OiAwLCAvLyBEaXJlY3QgQnIgZWxlbWVudHNcclxuICAgIH07XHJcblxyXG4gICAgZm9ybWF0dGVkQ29udGVudC5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgIGlmIChpdGVtLmZvcm1hdHRpbmc/LmlzQnJlYWspIHtcclxuICAgICAgICBjb25zdCBicmVha1R5cGUgPSBpdGVtLmZvcm1hdHRpbmcuYnJlYWtUeXBlIHx8IFwidW5rbm93blwiO1xyXG4gICAgICAgIGlmICh0eXBlcy5oYXNPd25Qcm9wZXJ0eShicmVha1R5cGUpKSB7XHJcbiAgICAgICAgICB0eXBlc1ticmVha1R5cGVdKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdHlwZXM7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0RGV0YWlsZWRGb3JtYXR0aW5nRnJvbVJhbmdlKHJhbmdlKSB7XHJcbiAgICBjb25zdCBmb3JtYXR0aW5nID0ge307XHJcblxyXG4gICAgLy8gRXh0cmFjdCBhbGwgcG9zc2libGUgZm9udCBhdHRyaWJ1dGVzXHJcbiAgICBjb25zdCBmb250QXR0cmlidXRlcyA9IFtcclxuICAgICAgXCJAX0FwcGxpZWRGb250XCIsXHJcbiAgICAgIFwiQF9Gb250RmFtaWx5XCIsXHJcbiAgICAgIFwiQF9Gb250XCIsXHJcbiAgICAgIFwiQF9Qb3N0U2NyaXB0TmFtZVwiLFxyXG4gICAgICBcIkBfRm9udE5hbWVcIixcclxuICAgIF07XHJcblxyXG4gICAgZm9udEF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xyXG4gICAgICBpZiAocmFuZ2VbYXR0cl0pIHtcclxuICAgICAgICBmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UgPSByYW5nZVthdHRyXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRXh0cmFjdCBmb250IGFuZCBzaXplIGF0dHJpYnV0ZXNcclxuICAgIGNvbnN0IHJhd0ZvbnRTaXplID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfUG9pbnRTaXplXCJdKTtcclxuICAgIGZvcm1hdHRpbmcuZm9udFNpemUgPSB0aGlzLmNvbnZlcnRGb250U2l6ZVRvUGl4ZWxzKHJhd0ZvbnRTaXplKTsgLy8gQURERUQ6IENvbnZlcnQgdG8gcGl4ZWxzXHJcbiAgICBmb3JtYXR0aW5nLm9yaWdpbmFsRm9udFNpemUgPSByYXdGb250U2l6ZTsgLy8gQURERUQ6IFByZXNlcnZlIG9yaWdpbmFsXHJcblxyXG4gICAgLy8gRU5IQU5DRUQ6IEV4dHJhY3QgbGVhZGluZyB3aXRoIHByb3BlciBwcm9jZXNzaW5nXHJcbiAgICBjb25zdCByYXdMZWFkaW5nID0gcmFuZ2VbXCJAX0xlYWRpbmdcIl07XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmcgPSB0aGlzLnByb2Nlc3NMZWFkaW5nVmFsdWUoXHJcbiAgICAgIHJhd0xlYWRpbmcsXHJcbiAgICAgIGZvcm1hdHRpbmcuZm9udFNpemVcclxuICAgICk7XHJcbiAgICBmb3JtYXR0aW5nLmxlYWRpbmdUeXBlID0gdGhpcy5kZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IGNvbG9yIGFuZCBzdHlsZSBhdHRyaWJ1dGVzXHJcbiAgICBmb3JtYXR0aW5nLmZpbGxDb2xvciA9IHJhbmdlW1wiQF9GaWxsQ29sb3JcIl07XHJcbiAgICBmb3JtYXR0aW5nLnN0cm9rZUNvbG9yID0gcmFuZ2VbXCJAX1N0cm9rZUNvbG9yXCJdO1xyXG4gICAgZm9ybWF0dGluZy5mb250U3R5bGUgPSByYW5nZVtcIkBfRm9udFN0eWxlXCJdO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgYWR2YW5jZWQgdHlwb2dyYXBoeSBhdHRyaWJ1dGVzXHJcbiAgICBmb3JtYXR0aW5nLnRyYWNraW5nID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfVHJhY2tpbmdcIl0pO1xyXG4gICAgZm9ybWF0dGluZy5iYXNlbGluZVNoaWZ0ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfQmFzZWxpbmVTaGlmdFwiXSk7XHJcbiAgICBmb3JtYXR0aW5nLmtlcm5pbmcgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlW1wiQF9LZXJuaW5nXCJdKTtcclxuICAgIGZvcm1hdHRpbmcuaG9yaXpvbnRhbFNjYWxlID1cclxuICAgICAgSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfSG9yaXpvbnRhbFNjYWxlXCJdKSB8fCAxMDA7XHJcbiAgICBmb3JtYXR0aW5nLnZlcnRpY2FsU2NhbGUgPVxyXG4gICAgICBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlW1wiQF9WZXJ0aWNhbFNjYWxlXCJdKSB8fCAxMDA7XHJcblxyXG4gICAgLy8gRU5IQU5DRUQ6IEV4dHJhY3QgSW5EZXNpZ24tc3BlY2lmaWMgdGV4dCBsYXlvdXQgcHJvcGVydGllcyBmb3IgcHJlY2lzZSByZW5kZXJpbmdcclxuICAgIGZvcm1hdHRpbmcuYmFzZWxpbmVHcmlkQWxpZ24gPSByYW5nZVtcIkBfQWxpZ25Ub0Jhc2VsaW5lXCJdIHx8IFwiTm9uZVwiO1xyXG4gICAgZm9ybWF0dGluZy5kcm9wQ2FwTGluZXMgPVxyXG4gICAgICBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlW1wiQF9Ecm9wQ2FwTGluZXNcIl0pIHx8IDA7XHJcbiAgICBmb3JtYXR0aW5nLmRyb3BDYXBDaGFyYWN0ZXJzID1cclxuICAgICAgSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhyYW5nZVtcIkBfRHJvcENhcENoYXJhY3RlcnNcIl0pIHx8IDA7XHJcblxyXG4gICAgLy8gRXh0cmFjdCBwYXJhZ3JhcGgtbGV2ZWwgYXR0cmlidXRlcyBpZiBwcmVzZW50XHJcbiAgICAvLyBDUklUSUNBTCBGSVg6IE9ubHkgc2V0IGFsaWdubWVudCBpZiBleHBsaWNpdGx5IHNwZWNpZmllZCwgYWxsb3dpbmcgcGFyYWdyYXBoIGluaGVyaXRhbmNlXHJcbiAgICBjb25zdCBleHBsaWNpdEFsaWdubWVudCA9IHJhbmdlW1wiQF9KdXN0aWZpY2F0aW9uXCJdIHx8IHJhbmdlW1wiQF9BbGlnbm1lbnRcIl07XHJcbiAgICBpZiAoZXhwbGljaXRBbGlnbm1lbnQpIHtcclxuICAgICAgZm9ybWF0dGluZy5hbGlnbm1lbnQgPSBleHBsaWNpdEFsaWdubWVudDtcclxuICAgIH1cclxuICAgIGZvcm1hdHRpbmcubGVmdEluZGVudCA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbXCJAX0xlZnRJbmRlbnRcIl0pO1xyXG4gICAgZm9ybWF0dGluZy5yaWdodEluZGVudCA9IElETUxVdGlscy5wYXJzZU51bWVyaWMocmFuZ2VbXCJAX1JpZ2h0SW5kZW50XCJdKTtcclxuICAgIGZvcm1hdHRpbmcuZmlyc3RMaW5lSW5kZW50ID0gSURNTFV0aWxzLnBhcnNlTnVtZXJpYyhcclxuICAgICAgcmFuZ2VbXCJAX0ZpcnN0TGluZUluZGVudFwiXVxyXG4gICAgKTtcclxuICAgIGZvcm1hdHRpbmcuc3BhY2VCZWZvcmUgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlW1wiQF9TcGFjZUJlZm9yZVwiXSk7XHJcbiAgICBmb3JtYXR0aW5nLnNwYWNlQWZ0ZXIgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhbmdlW1wiQF9TcGFjZUFmdGVyXCJdKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1NcclxuICAgIGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodCA9XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChmb3JtYXR0aW5nKTtcclxuXHJcbiAgICByZXR1cm4gZm9ybWF0dGluZztcclxuICB9XHJcblxyXG4gIC8vIEZJWEVEOiBQcm9jZXNzIGxlYWRpbmcgdmFsdWVzIHdpdGggSW5EZXNpZ24tc3BlY2lmaWMgbG9naWMgYW5kIGNvbnZlcnQgdG8gcGl4ZWxzXHJcbiAgcHJvY2Vzc0xlYWRpbmdWYWx1ZShyYXdMZWFkaW5nLCBmb250U2l6ZSkge1xyXG4gICAgaWYgKCFyYXdMZWFkaW5nKSByZXR1cm4gXCJhdXRvXCI7XHJcblxyXG4gICAgLy8gSGFuZGxlIFwiYXV0b1wiIGxlYWRpbmdcclxuICAgIGlmIChyYXdMZWFkaW5nID09PSBcImF1dG9cIiB8fCByYXdMZWFkaW5nID09PSBcIkF1dG9cIikge1xyXG4gICAgICByZXR1cm4gZm9udFNpemUgPyBmb250U2l6ZSAqIDEuMiA6IFwiYXV0b1wiOyAvLyBJbkRlc2lnbiBkZWZhdWx0IGF1dG8gbGVhZGluZyBpcyAxMjAlXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIG51bWVyaWMgbGVhZGluZyAoaW4gcG9pbnRzKSAtIEZJWEVEOiBDb252ZXJ0IHRvIHBpeGVsc1xyXG4gICAgY29uc3QgbnVtZXJpY0xlYWRpbmcgPSBJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhd0xlYWRpbmcpO1xyXG4gICAgaWYgKG51bWVyaWNMZWFkaW5nKSB7XHJcbiAgICAgIC8vIEZJWEVEOiBDb252ZXJ0IG51bWVyaWMgbGVhZGluZyB0byBwaXhlbHMgaWYgdW5pdENvbnZlcnRlciBpcyBhdmFpbGFibGVcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHRoaXMudW5pdENvbnZlcnRlciAmJlxyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRVbml0cyAmJlxyXG4gICAgICAgIHRoaXMudW5pdENvbnZlcnRlci5pc1N1cHBvcnRlZFVuaXQodGhpcy5kb2N1bWVudFVuaXRzKVxyXG4gICAgICApIHtcclxuICAgICAgICBjb25zdCBwaXhlbExlYWRpbmcgPSB0aGlzLnVuaXRDb252ZXJ0ZXIudG9QaXhlbHMoXHJcbiAgICAgICAgICBudW1lcmljTGVhZGluZyxcclxuICAgICAgICAgIHRoaXMuZG9jdW1lbnRVbml0c1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBg8J+TkCBDb252ZXJ0ZWQgbGVhZGluZzogJHtudW1lcmljTGVhZGluZ30gJHt0aGlzLmRvY3VtZW50VW5pdHN9IOKGkiAke3BpeGVsTGVhZGluZ30gcHhgXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gcGl4ZWxMZWFkaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudW1lcmljTGVhZGluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgcGVyY2VudGFnZS1iYXNlZCBsZWFkaW5nXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcyhcIiVcIikpIHtcclxuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQocmF3TGVhZGluZy5yZXBsYWNlKFwiJVwiLCBcIlwiKSk7XHJcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IChmb250U2l6ZSAqIHBlcmNlbnRhZ2UpIC8gMTAwIDogXCJhdXRvXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFwiYXV0b1wiO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgbGVhZGluZyBiZWluZyB1c2VkXHJcbiAgZGV0ZXJtaW5lTGVhZGluZ1R5cGUocmF3TGVhZGluZykge1xyXG4gICAgaWYgKCFyYXdMZWFkaW5nIHx8IHJhd0xlYWRpbmcgPT09IFwiYXV0b1wiIHx8IHJhd0xlYWRpbmcgPT09IFwiQXV0b1wiKSB7XHJcbiAgICAgIHJldHVybiBcImF1dG9cIjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmF3TGVhZGluZy5pbmNsdWRlcyhcIiVcIikpIHtcclxuICAgICAgcmV0dXJuIFwicGVyY2VudGFnZVwiO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChJRE1MVXRpbHMucGFyc2VOdW1lcmljKHJhd0xlYWRpbmcpKSB7XHJcbiAgICAgIHJldHVybiBcImFic29sdXRlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1MgcmVuZGVyaW5nXHJcbiAgY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChmb3JtYXR0aW5nKSB7XHJcbiAgICBjb25zdCBmb250U2l6ZSA9IGZvcm1hdHRpbmcuZm9udFNpemUgfHwgMTI7XHJcbiAgICBjb25zdCBsZWFkaW5nID0gZm9ybWF0dGluZy5sZWFkaW5nO1xyXG5cclxuICAgIGlmIChsZWFkaW5nID09PSBcImF1dG9cIikge1xyXG4gICAgICByZXR1cm4gMS4yOyAvLyBDU1MgbGluZS1oZWlnaHQgcmF0aW8gZm9yIGF1dG9cclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGxlYWRpbmcgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgLy8gQ29udmVydCBwb2ludHMgdG8gQ1NTIGxpbmUtaGVpZ2h0IHJhdGlvXHJcbiAgICAgIHJldHVybiBsZWFkaW5nIC8gZm9udFNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDEuMjsgLy8gRmFsbGJhY2tcclxuICB9XHJcblxyXG4gIGV4dHJhY3RUZXh0Rm9ybWF0dGluZyhzdG9yeURhdGEpIHtcclxuICAgIGNvbnN0IGZvcm1hdHRpbmcgPSB7XHJcbiAgICAgIHBhcmFncmFwaFN0eWxlczogW10sXHJcbiAgICAgIGNoYXJhY3RlclN0eWxlczogW10sXHJcbiAgICAgIGFwcGxpZWRTdHlsZXM6IFtdLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IGFwcGxpZWQgcGFyYWdyYXBoIHN0eWxlc1xyXG4gICAgaWYgKHN0b3J5RGF0YS5QYXJhZ3JhcGhTdHlsZVJhbmdlKSB7XHJcbiAgICAgIGNvbnN0IHJhbmdlcyA9IEFycmF5LmlzQXJyYXkoc3RvcnlEYXRhLlBhcmFncmFwaFN0eWxlUmFuZ2UpXHJcbiAgICAgICAgPyBzdG9yeURhdGEuUGFyYWdyYXBoU3R5bGVSYW5nZVxyXG4gICAgICAgIDogW3N0b3J5RGF0YS5QYXJhZ3JhcGhTdHlsZVJhbmdlXTtcclxuXHJcbiAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFwcGxpZWRTdHlsZSA9IHJhbmdlW1wiQF9BcHBsaWVkUGFyYWdyYXBoU3R5bGVcIl07XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgYXBwbGllZFN0eWxlICYmXHJcbiAgICAgICAgICAhZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZXMuaW5jbHVkZXMoYXBwbGllZFN0eWxlKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZXMucHVzaChhcHBsaWVkU3R5bGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBjaGFyYWN0ZXIgc3R5bGVzIHdpdGhpbiBwYXJhZ3JhcGggcmFuZ2VzXHJcbiAgICAgICAgaWYgKHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNvbnN0IGNoYXJSYW5nZXMgPSBBcnJheS5pc0FycmF5KHJhbmdlLkNoYXJhY3RlclN0eWxlUmFuZ2UpXHJcbiAgICAgICAgICAgID8gcmFuZ2UuQ2hhcmFjdGVyU3R5bGVSYW5nZVxyXG4gICAgICAgICAgICA6IFtyYW5nZS5DaGFyYWN0ZXJTdHlsZVJhbmdlXTtcclxuXHJcbiAgICAgICAgICBjaGFyUmFuZ2VzLmZvckVhY2goKGNoYXJSYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFyU3R5bGUgPSBjaGFyUmFuZ2VbXCJAX0FwcGxpZWRDaGFyYWN0ZXJTdHlsZVwiXTtcclxuICAgICAgICAgICAgaWYgKGNoYXJTdHlsZSAmJiAhZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZXMuaW5jbHVkZXMoY2hhclN0eWxlKSkge1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGVzLnB1c2goY2hhclN0eWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9ybWF0dGluZztcclxuICB9XHJcblxyXG4gIC8vIEFkZCB0aGlzIG1ldGhvZCB0byBkZWJ1ZyByYXcgc3RvcnkgY29udGVudFxyXG4gIGRlYnVnUmF3U3RvcnlDb250ZW50KHN0b3J5RGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coXCJcXG7wn5SNIFJBVyBTVE9SWSBDT05URU5UIERFQlVHOlwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwiU3Rvcnkga2V5czpcIiwgT2JqZWN0LmtleXMoc3RvcnlEYXRhKSk7XHJcblxyXG4gICAgY29uc3QgZmluZENoYXJhY3RlclJhbmdlcyA9IChvYmosIHBhdGggPSBcIlwiKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICBpZiAoa2V5ID09PSBcIkNoYXJhY3RlclN0eWxlUmFuZ2VcIikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgXFxu8J+TnSBGb3VuZCBDaGFyYWN0ZXJTdHlsZVJhbmdlIGF0ICR7cGF0aH06YCwgb2JqW2tleV0pO1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZXMgPSBBcnJheS5pc0FycmF5KG9ialtrZXldKSA/IG9ialtrZXldIDogW29ialtrZXldXTtcclxuICAgICAgICAgICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICAgYCAgUmFuZ2UgJHtpbmRleCArIDF9IGF0dHJpYnV0ZXM6YCxcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhbmdlKS5maWx0ZXIoKGspID0+IGsuc3RhcnRzV2l0aChcIkBfXCIpKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgUmFuZ2UgJHtpbmRleCArIDF9IGZvbnQgaW5mbzpgLCB7XHJcbiAgICAgICAgICAgICAgICBBcHBsaWVkRm9udDogcmFuZ2VbXCJAX0FwcGxpZWRGb250XCJdLFxyXG4gICAgICAgICAgICAgICAgRm9udFN0eWxlOiByYW5nZVtcIkBfRm9udFN0eWxlXCJdLFxyXG4gICAgICAgICAgICAgICAgUG9pbnRTaXplOiByYW5nZVtcIkBfUG9pbnRTaXplXCJdLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtrZXldID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGZpbmRDaGFyYWN0ZXJSYW5nZXMob2JqW2tleV0sIGAke3BhdGh9LiR7a2V5fWApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZpbmRDaGFyYWN0ZXJSYW5nZXMoc3RvcnlEYXRhKTtcclxuICB9XHJcblxyXG4gIC8vIEFERCBERUJVR0dJTkcgRk9SIFBBUlNFRCBCUiBTVFJVQ1RVUkVcclxuICBkZWJ1Z0JyRWxlbWVudHNJblBhcnNlZFN0cnVjdHVyZShwYXJzZWREYXRhLCBwYXRoID0gXCJcIikge1xyXG4gICAgaWYgKHR5cGVvZiBwYXJzZWREYXRhID09PSBcIm9iamVjdFwiICYmIHBhcnNlZERhdGEgIT09IG51bGwpIHtcclxuICAgICAgT2JqZWN0LmVudHJpZXMocGFyc2VkRGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJCclwiKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtwYXRofSBoYXMgQnIgZWxlbWVudDpgLCB2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgIHRoaXMuZGVidWdCckVsZW1lbnRzSW5QYXJzZWRTdHJ1Y3R1cmUodmFsdWUsIGAke3BhdGh9LiR7a2V5fWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDUklUSUNBTCBGSVg6IFBhcnNlIHJhdyBYTUwgdG8gcHJlc2VydmUgZXhhY3QgZG9jdW1lbnQgb3JkZXIgLSBGVUxMWSBEWU5BTUlDXHJcbiAgcGFyc2VSYXdYTUxGb3JEb2N1bWVudE9yZGVyKHJhd1hNTENvbnRlbnQsIGZpbGVOYW1lKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBQYXJzaW5nIHJhdyBYTUwgZm9yIGRvY3VtZW50IG9yZGVyOiAke2ZpbGVOYW1lfWApO1xyXG5cclxuICAgIC8vIERZTkFNSUM6IEhhbmRsZSBtdWx0aXBsZSBDaGFyYWN0ZXJTdHlsZVJhbmdlIGVsZW1lbnRzXHJcbiAgICBjb25zdCBjaGFyUmFuZ2VQYXR0ZXJuID1cclxuICAgICAgLzxDaGFyYWN0ZXJTdHlsZVJhbmdlW14+XSo+KC4qPyk8XFwvQ2hhcmFjdGVyU3R5bGVSYW5nZT4vZ3M7XHJcbiAgICBjb25zdCBjaGFyUmFuZ2VNYXRjaGVzID0gWy4uLnJhd1hNTENvbnRlbnQubWF0Y2hBbGwoY2hhclJhbmdlUGF0dGVybildO1xyXG5cclxuICAgIGlmIChjaGFyUmFuZ2VNYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuKdjCBObyBDaGFyYWN0ZXJTdHlsZVJhbmdlIGZvdW5kIGluIFhNTFwiKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5OEIEZvdW5kICR7Y2hhclJhbmdlTWF0Y2hlcy5sZW5ndGh9IENoYXJhY3RlclN0eWxlUmFuZ2UgZWxlbWVudHNgXHJcbiAgICApO1xyXG5cclxuICAgIC8vIERZTkFNSUM6IFByb2Nlc3MgYWxsIENoYXJhY3RlclN0eWxlUmFuZ2UgZWxlbWVudHNcclxuICAgIGNvbnN0IGFsbERvY3VtZW50T3JkZXIgPSBbXTtcclxuXHJcbiAgICBjaGFyUmFuZ2VNYXRjaGVzLmZvckVhY2goKG1hdGNoLCByYW5nZUluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNoYXJSYW5nZUNvbnRlbnQgPSBtYXRjaFsxXTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYPCfk4QgUHJvY2Vzc2luZyBDaGFyYWN0ZXJTdHlsZVJhbmdlWyR7cmFuZ2VJbmRleH1dOmAsXHJcbiAgICAgICAgY2hhclJhbmdlQ29udGVudC5zdWJzdHJpbmcoMCwgMjAwKSArIFwiLi4uXCJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEVOSEFOQ0VEOiBNb3JlIGZsZXhpYmxlIHBhdHRlcm4gdG8gaGFuZGxlIGRpZmZlcmVudCBYTUwgc3RydWN0dXJlc1xyXG4gICAgICAvLyBNYXRjaGVzOiA8Q29udGVudD50ZXh0PC9Db250ZW50PiwgPENvbnRlbnQvPiwgPEJyLz4sIDxCcj48L0JyPiwgPEJyIC8+XHJcbiAgICAgIGNvbnN0IGVsZW1lbnRQYXR0ZXJuID1cclxuICAgICAgICAvPChDb250ZW50fEJyKSg/OlxccytbXj5dKik/PihbXjxdKik8XFwvXFwxPnw8KENvbnRlbnR8QnIpKD86XFxzK1tePl0qKT9cXC8/Pnw8KENvbnRlbnR8QnIpKD86XFxzK1tePl0qKT8+KFtePF0qKS9nO1xyXG5cclxuICAgICAgbGV0IGVsZW1lbnRNYXRjaDtcclxuICAgICAgY29uc3QgcmFuZ2VFbGVtZW50cyA9IFtdO1xyXG5cclxuICAgICAgd2hpbGUgKChlbGVtZW50TWF0Y2ggPSBlbGVtZW50UGF0dGVybi5leGVjKGNoYXJSYW5nZUNvbnRlbnQpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID1cclxuICAgICAgICAgIGVsZW1lbnRNYXRjaFsxXSB8fCBlbGVtZW50TWF0Y2hbM10gfHwgZWxlbWVudE1hdGNoWzRdO1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRDb250ZW50ID0gZWxlbWVudE1hdGNoWzJdIHx8IGVsZW1lbnRNYXRjaFs1XSB8fCBcIlwiO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFwiQ29udGVudFwiKSB7XHJcbiAgICAgICAgICBjb25zdCBjb250ZW50VGV4dCA9IGVsZW1lbnRDb250ZW50LnRyaW0oKTtcclxuICAgICAgICAgIGlmIChjb250ZW50VGV4dCkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IGFkZCBub24tZW1wdHkgY29udGVudFxyXG4gICAgICAgICAgICByYW5nZUVsZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIHR5cGU6IFwiQ29udGVudFwiLFxyXG4gICAgICAgICAgICAgIHRleHQ6IGNvbnRlbnRUZXh0LFxyXG4gICAgICAgICAgICAgIHJhbmdlSW5kZXg6IHJhbmdlSW5kZXgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TnSBGb3VuZCBDb250ZW50WyR7cmFuZ2VJbmRleH1dOiBcIiR7Y29udGVudFRleHR9XCJgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBcIkJyXCIpIHtcclxuICAgICAgICAgIHJhbmdlRWxlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiQnJcIixcclxuICAgICAgICAgICAgcmFuZ2VJbmRleDogcmFuZ2VJbmRleCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCflJcgRm91bmQgQnJbJHtyYW5nZUluZGV4fV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCByYW5nZSBlbGVtZW50cyB0byBvdmVyYWxsIGRvY3VtZW50IG9yZGVyXHJcbiAgICAgIGFsbERvY3VtZW50T3JkZXIucHVzaCguLi5yYW5nZUVsZW1lbnRzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChhbGxEb2N1bWVudE9yZGVyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIuKdjCBObyBDb250ZW50IG9yIEJyIGVsZW1lbnRzIGZvdW5kIGluIGFueSBDaGFyYWN0ZXJTdHlsZVJhbmdlXCJcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRFlOQU1JQzogQW5hbHl6ZSB0aGUgYnJlYWsgcGF0dGVybiBmb3IgYW55IHN0cnVjdHVyZVxyXG4gICAgY29uc3QgYnJlYWtQYXR0ZXJuID0gdGhpcy5hbmFseXplQnJlYWtQYXR0ZXJuRHluYW1pYyhhbGxEb2N1bWVudE9yZGVyKTtcclxuICAgIGNvbnNvbGUubG9nKFwi8J+TiiBEeW5hbWljIGJyZWFrIHBhdHRlcm4gYW5hbHlzaXM6XCIsIGJyZWFrUGF0dGVybik7XHJcblxyXG4gICAgLy8gU3RvcmUgdGhpcyBmb3IgbGF0ZXIgdXNlIGluIHByb2Nlc3NpbmdcclxuICAgIHRoaXMuZG9jdW1lbnRPcmRlckNhY2hlID0gdGhpcy5kb2N1bWVudE9yZGVyQ2FjaGUgfHwge307XHJcbiAgICB0aGlzLmRvY3VtZW50T3JkZXJDYWNoZVtmaWxlTmFtZV0gPSB7XHJcbiAgICAgIGRvY3VtZW50T3JkZXI6IGFsbERvY3VtZW50T3JkZXIsXHJcbiAgICAgIGJyZWFrUGF0dGVybjogYnJlYWtQYXR0ZXJuLFxyXG4gICAgICB0b3RhbENoYXJhY3RlclJhbmdlczogY2hhclJhbmdlTWF0Y2hlcy5sZW5ndGgsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRvY3VtZW50T3JkZXI6IGFsbERvY3VtZW50T3JkZXIsXHJcbiAgICAgIGJyZWFrUGF0dGVybjogYnJlYWtQYXR0ZXJuLFxyXG4gICAgICB0b3RhbENoYXJhY3RlclJhbmdlczogY2hhclJhbmdlTWF0Y2hlcy5sZW5ndGgsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gRFlOQU1JQzogQW5hbHl6ZSBicmVhayBwYXR0ZXJuIGZvciBhbnkgZG9jdW1lbnQgc3RydWN0dXJlXHJcbiAgYW5hbHl6ZUJyZWFrUGF0dGVybkR5bmFtaWMoZG9jdW1lbnRPcmRlcikge1xyXG4gICAgY29uc3QgcGF0dGVybiA9IFtdO1xyXG4gICAgbGV0IGNvbnRlbnRJbmRleCA9IDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2N1bWVudE9yZGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudE9yZGVyW2ldO1xyXG5cclxuICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJDb250ZW50XCIpIHtcclxuICAgICAgICAvLyBEWU5BTUlDOiBDb3VudCBjb25zZWN1dGl2ZSBicmVha3MgYWZ0ZXIgdGhpcyBjb250ZW50XHJcbiAgICAgICAgbGV0IGJyZWFrc0FmdGVyID0gMDtcclxuICAgICAgICBsZXQgaiA9IGkgKyAxO1xyXG5cclxuICAgICAgICAvLyBDb3VudCBhbGwgY29uc2VjdXRpdmUgQnIgZWxlbWVudHMgZm9sbG93aW5nIHRoaXMgQ29udGVudFxyXG4gICAgICAgIHdoaWxlIChqIDwgZG9jdW1lbnRPcmRlci5sZW5ndGggJiYgZG9jdW1lbnRPcmRlcltqXS50eXBlID09PSBcIkJyXCIpIHtcclxuICAgICAgICAgIGJyZWFrc0FmdGVyKys7XHJcbiAgICAgICAgICBqKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXR0ZXJuLnB1c2goe1xyXG4gICAgICAgICAgY29udGVudEluZGV4OiBjb250ZW50SW5kZXgsXHJcbiAgICAgICAgICBjb250ZW50VGV4dDogZWxlbWVudC50ZXh0LFxyXG4gICAgICAgICAgYnJlYWtzQWZ0ZXI6IGJyZWFrc0FmdGVyLFxyXG4gICAgICAgICAgcmFuZ2VJbmRleDogZWxlbWVudC5yYW5nZUluZGV4LFxyXG4gICAgICAgICAgZG9jdW1lbnRQb3NpdGlvbjogaSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBg8J+TiyBDb250ZW50WyR7Y29udGVudEluZGV4fV0gXCIke2VsZW1lbnQudGV4dH1cIiBoYXMgJHticmVha3NBZnRlcn0gYnJlYWtzIGFmdGVyIGl0IChkb2MgcG9zOiAke2l9KWBcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnRlbnRJbmRleCsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVkFMSURBVElPTjogRW5zdXJlIHBhdHRlcm4gbWFrZXMgc2Vuc2VcclxuICAgIGNvbnN0IHRvdGFsQ29udGVudCA9IHBhdHRlcm4ubGVuZ3RoO1xyXG4gICAgY29uc3QgdG90YWxCcmVha3MgPSBwYXR0ZXJuLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLmJyZWFrc0FmdGVyLCAwKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCflI0gUGF0dGVybiB2YWxpZGF0aW9uOiAke3RvdGFsQ29udGVudH0gY29udGVudCBpdGVtcywgJHt0b3RhbEJyZWFrc30gdG90YWwgYnJlYWtzYFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAodG90YWxDb250ZW50ID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi4pqg77iPIFdhcm5pbmc6IE5vIGNvbnRlbnQgaXRlbXMgZm91bmQgaW4gcGF0dGVyblwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGF0dGVybjtcclxuICB9XHJcblxyXG4gIGdldFN0b3JpZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdG9yaWVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3Rvcnkoc3RvcnlJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3Rvcmllc1tzdG9yeUlkXTtcclxuICB9XHJcblxyXG4gIGNsZWFyU3RvcmllcygpIHtcclxuICAgIHRoaXMuc3RvcmllcyA9IHt9O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9yeVBhcnNlcjtcclxuIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiSURNTFV0aWxzIiwiU3RvcnlQYXJzZXIiLCJjb25zdHJ1Y3RvciIsInN0eWxlUGFyc2VyIiwidW5pdENvbnZlcnRlciIsImRvY3VtZW50VW5pdHMiLCJzdG9yaWVzIiwic2V0RG9jdW1lbnRVbml0cyIsInVuaXRzIiwiY29uc29sZSIsImxvZyIsImNvbnZlcnRGb250U2l6ZVRvUGl4ZWxzIiwiZm9udFNpemUiLCJmb250VW5pdHMiLCJpc1N1cHBvcnRlZFVuaXQiLCJwaXhlbFNpemUiLCJ0b1BpeGVscyIsInBhcnNlU3RvcnlGaWxlIiwiZmlsZU5hbWUiLCJjb250ZW50IiwieG1sUGFyc2VyIiwicGFyc2VkIiwicGFyc2UiLCJzdG9yeUlkIiwiYmFzZW5hbWUiLCJzdG9yeURhdGEiLCJTdG9yeSIsInN1YnN0cmluZyIsImJyTWF0Y2hlcyIsIm1hdGNoIiwibGVuZ3RoIiwiY29uc2VjdXRpdmVCclBhdHRlcm4iLCJjb25zZWN1dGl2ZUJyTWF0Y2hlcyIsInBhcnNlUmF3WE1MRm9yRG9jdW1lbnRPcmRlciIsIk9iamVjdCIsImtleXMiLCJKU09OIiwic3RyaW5naWZ5IiwiZGV0YWlsZWRTdG9yeSIsInNlbGYiLCJhcHBsaWVkVE9DU3R5bGUiLCJ1c2VyVGV4dCIsImV4dHJhY3REZXRhaWxlZFN0b3J5Q29udGVudCIsInRleHRGb3JtYXR0aW5nIiwiZXh0cmFjdFRleHRGb3JtYXR0aW5nIiwiZGVidWdCckVsZW1lbnRzSW5QYXJzZWRTdHJ1Y3R1cmUiLCJjbGVhblN0b3J5SWQiLCJyZXBsYWNlIiwicGxhaW5UZXh0IiwibGluZUJyZWFrSW5mbyIsIndvcmRDb3VudCIsImxpbmVCcmVha0NvdW50IiwiZXJyb3IiLCJtZXNzYWdlIiwiZm9ybWF0dGVkQ29udGVudCIsInRleHRDb2xvciIsImRlYnVnSW5mbyIsImV4dHJhY3RUZXh0UmVjdXJzaXZlbHkiLCJlbGVtZW50IiwiZGVwdGgiLCJjb250ZXh0IiwiQ2hhcmFjdGVyU3R5bGVSYW5nZSIsInJhbmdlcyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJyYW5nZSIsInJhbmdlSW5kZXgiLCJkaXJlY3RGb250UmVmIiwiZm9ybWF0dGluZyIsInBhcmFncmFwaFN0eWxlIiwiYXBwbGllZFN0eWxlIiwiY2hhcmFjdGVyU3R5bGUiLCJwYXJzZUZsb2F0Iiwib3JpZ2luYWxGb250U2l6ZSIsImZvbnRSZWZlcmVuY2UiLCJmaWxsQ29sb3IiLCJmb250U3R5bGUiLCJhbGlnbm1lbnQiLCJwYXJhZ3JhcGhBbGlnbm1lbnQiLCJyZXNvbHZlZEZvcm1hdHRpbmciLCJyZXNvbHZlU3R5bGVGb3JtYXR0aW5nIiwicHJvY2Vzc0NoYXJhY3RlclJhbmdlSW5PcmRlciIsIm5leHRSYW5nZSIsImN1cnJlbnRUZXh0Iiwic2xpY2UiLCJjdXJyZW50UmFuZ2VFbmRzV2l0aFNwYWNlIiwidGVzdCIsIm5leHRDb250ZW50IiwiQ29udGVudCIsIlN0cmluZyIsIm5leHRSYW5nZVN0YXJ0c1dpdGhTcGFjZSIsInNob3VsZFNraXBTcGFjZSIsInNob3VsZEluc2VydEltcGxpY2l0TGluZUJyZWFrIiwidHJpbSIsImN1cnJlbnRTdHlsZSIsIm5leHRTdHlsZSIsInNwYWNlVGV4dCIsInB1c2giLCJ0ZXh0IiwiaXNTcGFjZSIsInNvdXJjZSIsInR5cGUiLCJsb2NhdGlvbiIsInJlYXNvbiIsImN1cnJlbnRUZXh0RW5kIiwibmV4dFRleHRTdGFydCIsImltcGxpY2l0QnJlYWsiLCJpc0JyZWFrIiwiYnJlYWtUeXBlIiwiUGFyYWdyYXBoU3R5bGVSYW5nZSIsImluZGV4IiwicGFyYWdyYXBoQ29udGV4dCIsInBhcmFncmFwaEluZGV4IiwidG90YWxQYXJhZ3JhcGhzIiwiYmVmb3JlTGVuIiwiYWZ0ZXJMZW4iLCJwYXJhZ3JhcGhCcmVhayIsImpvaW4iLCJkZWNvZGVYTUxFbnRpdGllcyIsImZvbnRGYW1pbHkiLCJCciIsInVuZGVmaW5lZCIsImJyRWxlbWVudHMiLCJiciIsImxpbmVCcmVha1RleHQiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJzdGFydHNXaXRoIiwiaXRlbSIsImNoYXJzIiwic3BsaXQiLCJtYXAiLCJjaGFyIiwiaSIsInByb2Nlc3NlZENvbnRlbnQiLCJzb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyIsImZpbHRlciIsImluZm8iLCJpbmNsdWRlcyIsImhhc0xpbmVCcmVha3MiLCJsaW5lQnJlYWtUeXBlcyIsImFuYWx5emVMaW5lQnJlYWtUeXBlcyIsInNwYWNlUHJlc2VydmF0aW9uQ291bnQiLCJjb3VudFdvcmRzIiwiY2hhcmFjdGVyQ291bnQiLCJ0b3RhbFJhbmdlcyIsImhhc0NvbnRlbnQiLCJoYXNCciIsImNvbnRlbnRUeXBlIiwiYnJUeXBlIiwicHJvY2Vzc0ludGVybGVhdmVkQ29udGVudEFuZEJyIiwicHJvY2Vzc0NvbnRlbnRFbGVtZW50cyIsInByb2Nlc3NCckVsZW1lbnRzIiwiZW1lcmdlbmN5Q29udGVudEV4dHJhY3Rpb24iLCJleHRyYWN0ZWRUZXh0cyIsImV4dHJhY3RlZEJyZWFrcyIsImNvbnRlbnRzIiwiYyIsImJyZWFrcyIsImNsZWFuVGV4dCIsImVtZXJnZW5jeUluZGV4IiwiZW1lcmdlbmN5RXJyb3IiLCJ3YXJuaW5nVGV4dCIsImNhY2hlZE9yZGVyIiwiZG9jdW1lbnRPcmRlckNhY2hlIiwiYnJlYWtQYXR0ZXJuIiwicHJvY2Vzc0NvbnRlbnRXaXRoQ2FjaGVkUGF0dGVybiIsInByb2Nlc3NJbnRlcmxlYXZlZENvbnRlbnREeW5hbWljRmFsbGJhY2siLCJickluZGV4IiwiY29udGVudExlbmd0aCIsImNvbnRlbnRJdGVtIiwiY29udGVudEluZGV4IiwiYnJlYWtzVG9BZGQiLCJjYWxjdWxhdGVCcmVha3NBZnRlckNvbnRlbnQiLCJhZnRlckNvbnRlbnQiLCJjYWxjdWxhdGVkQnJlYWtzIiwicmVtYWluaW5nQnJlYWtzIiwicGF0dGVybkVudHJ5IiwiZmluZCIsInAiLCJicmVha3NBZnRlciIsImJyZWFrSW5kZXgiLCJ0b3RhbEJyZWFrc0FmdGVyQ29udGVudCIsImV4cGVjdGVkQ29udGVudENvdW50IiwidG90YWxDb250ZW50IiwidG90YWxCcmVha3MiLCJub25MYXN0Q29udGVudEl0ZW1zIiwiYmFzZUJyZWFrcyIsIk1hdGgiLCJmbG9vciIsImV4dHJhQnJlYWtzIiwiYnJlYWtzRm9yVGhpc0NvbnRlbnQiLCJhbmFseXplQ29udGVudFN0cnVjdHVyZSIsInN0cnVjdHVyZSIsImNvbnRlbnRJdGVtcyIsInByb2Nlc3NJbnRlcmxlYXZlZENvbnRlbnQiLCJyZXN1bHRzIiwiZXh0cmFjdEJyRWxlbWVudHMiLCJjb3VudCIsInJhd0JyIiwicG9zaXRpb24iLCJkZXRlcm1pbmVMaW5lQnJlYWtUeXBlIiwiYnJJbmZvIiwiY3VycmVudFJhbmdlIiwiY3VycmVudENoYXJTdHlsZSIsIm5leHRDaGFyU3R5bGUiLCJzdHlsZUluZGljYXRlc0JyZWFrIiwic3R5bGVJbmRpY2F0ZXNMaW5lQnJlYWsiLCJ0aXRsZUluZGljYXRvcnMiLCJib2R5SW5kaWNhdG9ycyIsImN1cnJlbnRJc1RpdGxlIiwic29tZSIsImluZGljYXRvciIsInRvTG93ZXJDYXNlIiwibmV4dElzQm9keSIsInR5cGVzIiwiZXhwbGljaXQiLCJpbXBsaWNpdCIsInBhcmFncmFwaCIsImRpcmVjdCIsImhhc093blByb3BlcnR5IiwiZXh0cmFjdERldGFpbGVkRm9ybWF0dGluZ0Zyb21SYW5nZSIsImZvbnRBdHRyaWJ1dGVzIiwiYXR0ciIsInJhd0ZvbnRTaXplIiwicGFyc2VOdW1lcmljIiwicmF3TGVhZGluZyIsImxlYWRpbmciLCJwcm9jZXNzTGVhZGluZ1ZhbHVlIiwibGVhZGluZ1R5cGUiLCJkZXRlcm1pbmVMZWFkaW5nVHlwZSIsInN0cm9rZUNvbG9yIiwidHJhY2tpbmciLCJiYXNlbGluZVNoaWZ0Iiwia2VybmluZyIsImhvcml6b250YWxTY2FsZSIsInZlcnRpY2FsU2NhbGUiLCJiYXNlbGluZUdyaWRBbGlnbiIsImRyb3BDYXBMaW5lcyIsImRyb3BDYXBDaGFyYWN0ZXJzIiwiZXhwbGljaXRBbGlnbm1lbnQiLCJsZWZ0SW5kZW50IiwicmlnaHRJbmRlbnQiLCJmaXJzdExpbmVJbmRlbnQiLCJzcGFjZUJlZm9yZSIsInNwYWNlQWZ0ZXIiLCJlZmZlY3RpdmVMaW5lSGVpZ2h0IiwiY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodCIsIm51bWVyaWNMZWFkaW5nIiwicGl4ZWxMZWFkaW5nIiwicGVyY2VudGFnZSIsInBhcmFncmFwaFN0eWxlcyIsImNoYXJhY3RlclN0eWxlcyIsImFwcGxpZWRTdHlsZXMiLCJjaGFyUmFuZ2VzIiwiY2hhclJhbmdlIiwiY2hhclN0eWxlIiwiZGVidWdSYXdTdG9yeUNvbnRlbnQiLCJmaW5kQ2hhcmFjdGVyUmFuZ2VzIiwib2JqIiwiayIsIkFwcGxpZWRGb250IiwiRm9udFN0eWxlIiwiUG9pbnRTaXplIiwicGFyc2VkRGF0YSIsInJhd1hNTENvbnRlbnQiLCJjaGFyUmFuZ2VQYXR0ZXJuIiwiY2hhclJhbmdlTWF0Y2hlcyIsIm1hdGNoQWxsIiwiYWxsRG9jdW1lbnRPcmRlciIsImNoYXJSYW5nZUNvbnRlbnQiLCJlbGVtZW50UGF0dGVybiIsImVsZW1lbnRNYXRjaCIsInJhbmdlRWxlbWVudHMiLCJleGVjIiwiZWxlbWVudFR5cGUiLCJlbGVtZW50Q29udGVudCIsImNvbnRlbnRUZXh0IiwiYW5hbHl6ZUJyZWFrUGF0dGVybkR5bmFtaWMiLCJkb2N1bWVudE9yZGVyIiwidG90YWxDaGFyYWN0ZXJSYW5nZXMiLCJwYXR0ZXJuIiwiaiIsImRvY3VtZW50UG9zaXRpb24iLCJyZWR1Y2UiLCJzdW0iLCJnZXRTdG9yaWVzIiwiZ2V0U3RvcnkiLCJjbGVhclN0b3JpZXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/parsers/StoryParser.js\n");

/***/ }),

/***/ "./lib/parsers/StyleParser.js":
/*!************************************!*\
  !*** ./lib/parsers/StyleParser.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass StyleParser {\n    constructor(unitConverter = null){\n        this.styles = {\n            paragraph: {},\n            character: {},\n            object: {},\n            table: {},\n            cell: {}\n        };\n        this.resources = {\n            fonts: {},\n            colors: {},\n            gradients: {}\n        };\n        this.fontMap = new Map(); // Global font lookup map\n        this.unitConverter = unitConverter; // ADDED: Unit converter for typography measurements\n        this.documentUnits = null; // Will be set from document units\n    }\n    // ADDED: Method to set document units for typography conversion\n    setDocumentUnits(units) {\n        this.documentUnits = units;\n        console.log(\"\\uD83D\\uDCD0 StyleParser: Set document units to\", units);\n    }\n    // ADDED: Method to convert typography measurements to pixels\n    convertTypographyToPixels(value) {\n        if (typeof value !== \"number\" || isNaN(value) || !this.unitConverter || !this.documentUnits) {\n            return value;\n        }\n        // Only convert if we have a supported unit and it's not already pixels\n        if (this.unitConverter.isSupportedUnit(this.documentUnits)) {\n            const convertedValue = this.unitConverter.toPixels(value, this.documentUnits);\n            console.log(`ðŸ“ Converted typography: ${value} ${this.documentUnits} â†’ ${convertedValue} px`);\n            return convertedValue;\n        }\n        return value;\n    }\n    // ADDED: Method to convert an entire style object's measurements to pixels\n    convertStyleMeasurementsToPixels(style) {\n        if (!this.unitConverter || !this.documentUnits) {\n            return style;\n        }\n        const convertedStyle = {\n            ...style\n        };\n        // Convert measurements that need pixel conversion\n        const measurementFields = [\n            \"leftIndent\",\n            \"rightIndent\",\n            \"firstLineIndent\",\n            \"spaceBefore\",\n            \"spaceAfter\",\n            \"tracking\",\n            \"kerning\"\n        ];\n        measurementFields.forEach((field)=>{\n            if (typeof convertedStyle[field] === \"number\") {\n                convertedStyle[field] = this.convertTypographyToPixels(convertedStyle[field]);\n            }\n        });\n        // Convert leading if it's a numeric value\n        if (typeof convertedStyle.leading === \"number\") {\n            convertedStyle.leading = this.convertTypographyToPixels(convertedStyle.leading);\n        }\n        return convertedStyle;\n    }\n    async parseResourceFile(fileName, content, xmlParser) {\n        console.log(`ðŸ“‹ Parsing resource: ${fileName}`);\n        try {\n            const parsed = xmlParser.parse(content);\n            const resourceName = path.basename(fileName, \".xml\");\n            // Handle different resource types\n            if (fileName.includes(\"Styles.xml\")) {\n                await this.extractStyles(parsed);\n            } else if (fileName.includes(\"Fonts.xml\")) {\n                await this.extractFonts(parsed);\n            } else if (fileName.includes(\"Graphic.xml\")) {\n                await this.extractGraphics(parsed);\n            } else if (fileName.includes(\"Preferences.xml\")) {\n                await this.extractPreferences(parsed);\n            }\n            console.log(`âœ… Resource ${resourceName} parsed`);\n        } catch (error) {\n            console.error(`âŒ Error parsing ${fileName}:`, error.message);\n        }\n    }\n    async extractStyles(stylesData) {\n        console.log(\"Extracting styles...\");\n        const styles = stylesData.Styles || stylesData;\n        // Extract Paragraph Styles\n        if (styles.RootParagraphStyleGroup) {\n            this.extractParagraphStyles(styles.RootParagraphStyleGroup);\n        }\n        // Extract Character Styles\n        if (styles.RootCharacterStyleGroup) {\n            this.extractCharacterStyles(styles.RootCharacterStyleGroup);\n        }\n    }\n    extractParagraphStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.ParagraphStyle) {\n                const styles = Array.isArray(group.ParagraphStyle) ? group.ParagraphStyle : [\n                    group.ParagraphStyle\n                ];\n                styles.forEach((style)=>{\n                    // CRITICAL: Extract font reference from multiple possible locations\n                    const fontRef = this.extractFontFromStyle(style);\n                    // ENHANCED: Process leading with proper InDesign logic\n                    const fontSize = parseFloat(style[\"@_PointSize\"]) || 12;\n                    const rawLeading = style[\"@_Leading\"];\n                    const processedLeading = this.processLeadingValue(rawLeading, fontSize);\n                    // FIXED: Extract raw typography measurements for conversion\n                    const rawLeftIndent = parseFloat(style[\"@_LeftIndent\"]) || 0;\n                    const rawRightIndent = parseFloat(style[\"@_RightIndent\"]) || 0;\n                    const rawFirstLineIndent = parseFloat(style[\"@_FirstLineIndent\"]) || 0;\n                    const rawSpaceBefore = parseFloat(style[\"@_SpaceBefore\"]) || 0;\n                    const rawSpaceAfter = parseFloat(style[\"@_SpaceAfter\"]) || 0;\n                    const rawTracking = parseFloat(style[\"@_Tracking\"]) || 0;\n                    const rawKerning = parseFloat(style[\"@_Kerning\"]) || 0;\n                    // FIXED: Create base style object with raw values\n                    const baseStyle = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: fontSize,\n                        leading: processedLeading,\n                        leadingType: this.determineLeadingType(rawLeading),\n                        effectiveLineHeight: this.calculateEffectiveLineHeight(processedLeading, fontSize),\n                        alignment: style[\"@_Justification\"] || \"LeftAlign\",\n                        // Raw measurements (will be converted to pixels)\n                        leftIndent: rawLeftIndent,\n                        rightIndent: rawRightIndent,\n                        firstLineIndent: rawFirstLineIndent,\n                        spaceBefore: rawSpaceBefore,\n                        spaceAfter: rawSpaceAfter,\n                        tracking: rawTracking,\n                        kerning: rawKerning,\n                        // Store original values for reference\n                        originalLeftIndent: rawLeftIndent,\n                        originalRightIndent: rawRightIndent,\n                        originalFirstLineIndent: rawFirstLineIndent,\n                        originalSpaceBefore: rawSpaceBefore,\n                        originalSpaceAfter: rawSpaceAfter,\n                        originalTracking: rawTracking,\n                        originalKerning: rawKerning,\n                        horizontalScale: parseFloat(style[\"@_HorizontalScale\"]) || 100,\n                        verticalScale: parseFloat(style[\"@_VerticalScale\"]) || 100,\n                        // ENHANCED: Use the new extraction method\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || \"Color/Black\",\n                        rawStyle: style\n                    };\n                    // FIXED: Apply unit conversion to create pixel-converted style\n                    this.styles.paragraph[style[\"@_Self\"]] = this.convertStyleMeasurementsToPixels(baseStyle);\n                    console.log(`âœ… Paragraph Style: ${style[\"@_Name\"]} -> Font: \"${fontRef}\"`);\n                });\n            }\n            if (group.ParagraphStyleGroup) {\n                const subGroups = Array.isArray(group.ParagraphStyleGroup) ? group.ParagraphStyleGroup : [\n                    group.ParagraphStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    extractFontFromStyle(style) {\n        // Try direct attributes first\n        let fontRef = style[\"@_AppliedFont\"] || style[\"@_FontFamily\"] || style[\"@_Font\"] || \"\";\n        // If not found, try Properties nested structure\n        if (!fontRef && style.Properties) {\n            if (style.Properties.AppliedFont) {\n                fontRef = style.Properties.AppliedFont[\"#text\"] || style.Properties.AppliedFont || \"\";\n            }\n            // Also try other property variations\n            if (!fontRef && style.Properties.FontFamily) {\n                fontRef = style.Properties.FontFamily[\"#text\"] || style.Properties.FontFamily || \"\";\n            }\n        }\n        return fontRef || \"\";\n    }\n    extractCharacterStyles(styleGroup) {\n        const extractStylesRecursively = (group)=>{\n            if (group.CharacterStyle) {\n                const styles = Array.isArray(group.CharacterStyle) ? group.CharacterStyle : [\n                    group.CharacterStyle\n                ];\n                styles.forEach((style)=>{\n                    const fontRef = this.extractFontFromStyle(style);\n                    this.styles.character[style[\"@_Self\"]] = {\n                        self: style[\"@_Self\"],\n                        name: style[\"@_Name\"] || \"\",\n                        fontStyle: style[\"@_FontStyle\"] || \"Regular\",\n                        pointSize: parseFloat(style[\"@_PointSize\"]) || null,\n                        appliedFont: fontRef,\n                        originalFontRef: fontRef,\n                        fillColor: style[\"@_FillColor\"] || null,\n                        strokeColor: style[\"@_StrokeColor\"] || null,\n                        rawStyle: style\n                    };\n                    console.log(`âœ… Character Style: ${style[\"@_Name\"]} -> Font: \"${fontRef}\"`);\n                });\n            }\n            if (group.CharacterStyleGroup) {\n                const subGroups = Array.isArray(group.CharacterStyleGroup) ? group.CharacterStyleGroup : [\n                    group.CharacterStyleGroup\n                ];\n                subGroups.forEach(extractStylesRecursively);\n            }\n        };\n        extractStylesRecursively(styleGroup);\n    }\n    async extractFonts(fontsData) {\n        console.log(\"Extracting fonts with enhanced mapping...\");\n        const fonts = fontsData.Fonts || fontsData;\n        this.resources.fonts = {};\n        this.fontMap = new Map(); // Global font lookup map\n        if (fonts.FontFamily) {\n            const fontFamilies = Array.isArray(fonts.FontFamily) ? fonts.FontFamily : [\n                fonts.FontFamily\n            ];\n            fontFamilies.forEach((family)=>{\n                const familyInfo = {\n                    self: family[\"@_Self\"],\n                    name: family[\"@_Name\"] || \"\",\n                    fonts: []\n                };\n                if (family.Font) {\n                    const fontList = Array.isArray(family.Font) ? family.Font : [\n                        family.Font\n                    ];\n                    fontList.forEach((font)=>{\n                        const fontInfo = {\n                            self: font[\"@_Self\"],\n                            fontFamily: font[\"@_FontFamily\"] || familyInfo.name,\n                            name: font[\"@_Name\"] || \"\",\n                            postScriptName: font[\"@_PostScriptName\"] || \"\",\n                            status: font[\"@_Status\"] || \"Unknown\",\n                            fontStyleName: font[\"@_FontStyleName\"] || \"Regular\"\n                        };\n                        familyInfo.fonts.push(fontInfo);\n                        // Create multiple lookup entries for this font\n                        this.fontMap.set(font[\"@_Self\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_PostScriptName\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_Name\"], familyInfo.name);\n                        this.fontMap.set(font[\"@_FontFamily\"], familyInfo.name);\n                        console.log(`Font mapping: ${font[\"@_Self\"]} -> ${familyInfo.name}`);\n                    });\n                }\n                this.resources.fonts[family[\"@_Self\"]] = familyInfo;\n            });\n        }\n        console.log(`âœ… Fonts extracted: ${Object.keys(this.resources.fonts).length} families`);\n        console.log(`Font map entries: ${this.fontMap.size}`);\n    }\n    async extractGraphics(graphicsData) {\n        console.log(\"Extracting graphics and colors...\");\n        const graphics = graphicsData.Graphic || graphicsData;\n        this.resources.colors = {};\n        this.resources.gradients = {};\n        // Extract Colors\n        if (graphics.Color) {\n            const colors = Array.isArray(graphics.Color) ? graphics.Color : [\n                graphics.Color\n            ];\n            colors.forEach((color)=>{\n                // Extract individual channel values from attributes (if present)\n                const cyan = parseFloat(color[\"@_Cyan\"]) || 0;\n                const magenta = parseFloat(color[\"@_Magenta\"]) || 0;\n                const yellow = parseFloat(color[\"@_Yellow\"]) || 0;\n                const black = parseFloat(color[\"@_Black\"]) || 0;\n                const red = parseFloat(color[\"@_Red\"]) || 0;\n                const green = parseFloat(color[\"@_Green\"]) || 0;\n                const blue = parseFloat(color[\"@_Blue\"]) || 0;\n                // Get color space and model information\n                const colorSpace = color[\"@_Space\"] || \"CMYK\";\n                const colorModel = color[\"@_Model\"] || \"Process\";\n                const colorValue = color[\"@_ColorValue\"];\n                const colorName = color[\"@_Name\"] || \"\";\n                const colorSelf = color[\"@_Self\"] || \"\";\n                console.log(`ðŸŽ¨ Processing color: ${colorSelf}`);\n                console.log(`   Name: \"${colorName}\", Space: ${colorSpace}, Model: ${colorModel}`);\n                console.log(`   ColorValue: \"${colorValue}\"`);\n                console.log(`   Individual channels - C:${cyan} M:${magenta} Y:${yellow} K:${black} R:${red} G:${green} B:${blue}`);\n                // CRITICAL: Determine if this is a custom color that should use RGB ColorValue\n                const isCustomColor = this.isCustomColorName(colorSelf, colorName);\n                console.log(`   ðŸ” Is custom color: ${isCustomColor}`);\n                // Initialize color data structure\n                let finalColorData = {\n                    self: colorSelf,\n                    name: colorName,\n                    model: colorModel,\n                    space: colorSpace,\n                    cyan: 0,\n                    magenta: 0,\n                    yellow: 0,\n                    black: 0,\n                    red: 0,\n                    green: 0,\n                    blue: 0,\n                    // Additional fields to track color source\n                    colorSource: \"unknown\",\n                    hasDirectRGB: false,\n                    hasDirectCMYK: false,\n                    hasColorValue: !!colorValue,\n                    isCustomColor: isCustomColor\n                };\n                // STRATEGY 1: Check for direct RGB values in individual attributes\n                if (red > 0 || green > 0 || blue > 0) {\n                    console.log(`   âœ… Using direct RGB from individual channels: R:${red} G:${green} B:${blue}`);\n                    finalColorData.red = red;\n                    finalColorData.green = green;\n                    finalColorData.blue = blue;\n                    finalColorData.colorSource = \"direct_rgb_channels\";\n                    finalColorData.hasDirectRGB = true;\n                } else if (cyan > 0 || magenta > 0 || yellow > 0 || black > 0) {\n                    console.log(`   âœ… Using direct CMYK from individual channels: C:${cyan} M:${magenta} Y:${yellow} K:${black}`);\n                    finalColorData.cyan = cyan;\n                    finalColorData.magenta = magenta;\n                    finalColorData.yellow = yellow;\n                    finalColorData.black = black;\n                    finalColorData.colorSource = \"direct_cmyk_channels\";\n                    finalColorData.hasDirectCMYK = true;\n                } else if (colorValue && isCustomColor) {\n                    console.log(`   ðŸ” Parsing ColorValue for CUSTOM color: \"${colorValue}\"`);\n                    // Split ColorValue into numeric parts\n                    const valueParts = colorValue.split(/\\s+/).map(Number).filter((v)=>!isNaN(v));\n                    if (valueParts.length === 3 && colorSpace === \"RGB\") {\n                        // RGB ColorValue: \"255 137 0\" -> R:255 G:137 B:0\n                        console.log(`   âœ… Using RGB ColorValue for custom color: R:${valueParts[0]} G:${valueParts[1]} B:${valueParts[2]}`);\n                        finalColorData.red = valueParts[0];\n                        finalColorData.green = valueParts[1];\n                        finalColorData.blue = valueParts[2];\n                        finalColorData.colorSource = \"colorvalue_rgb_custom\";\n                        finalColorData.hasDirectRGB = true;\n                    } else if (valueParts.length === 4 && colorSpace === \"CMYK\") {\n                        // CMYK ColorValue: \"0 0 0 100\" -> C:0 M:0 Y:0 K:100\n                        console.log(`   âœ… Using CMYK ColorValue for custom color: C:${valueParts[0]} M:${valueParts[1]} Y:${valueParts[2]} K:${valueParts[3]}`);\n                        finalColorData.cyan = valueParts[0];\n                        finalColorData.magenta = valueParts[1];\n                        finalColorData.yellow = valueParts[2];\n                        finalColorData.black = valueParts[3];\n                        finalColorData.colorSource = \"colorvalue_cmyk_custom\";\n                        finalColorData.hasDirectCMYK = true;\n                    } else if (valueParts.length === 3) {\n                        // Assume RGB if space is unknown but we have 3 values (for custom colors)\n                        console.log(`   âš ï¸  Assuming RGB for 3-value ColorValue on custom color: R:${valueParts[0]} G:${valueParts[1]} B:${valueParts[2]}`);\n                        finalColorData.red = valueParts[0];\n                        finalColorData.green = valueParts[1];\n                        finalColorData.blue = valueParts[2];\n                        finalColorData.space = \"RGB\";\n                        finalColorData.colorSource = \"colorvalue_assumed_rgb_custom\";\n                        finalColorData.hasDirectRGB = true;\n                    } else {\n                        console.log(`   âš ï¸  Could not parse ColorValue for custom color: \"${colorValue}\" (${valueParts.length} parts)`);\n                        finalColorData.colorSource = \"colorvalue_unparseable_custom\";\n                    }\n                } else if (colorValue && !isCustomColor) {\n                    console.log(`   ðŸ” Parsing ColorValue for STANDARD color: \"${colorValue}\"`);\n                    // Split ColorValue into numeric parts\n                    const valueParts = colorValue.split(/\\s+/).map(Number).filter((v)=>!isNaN(v));\n                    if (valueParts.length === 4 && colorSpace === \"CMYK\") {\n                        // Only use CMYK ColorValue for standard colors, ignore RGB ColorValue\n                        console.log(`   âœ… Using CMYK ColorValue for standard color: C:${valueParts[0]} M:${valueParts[1]} Y:${valueParts[2]} K:${valueParts[3]}`);\n                        finalColorData.cyan = valueParts[0];\n                        finalColorData.magenta = valueParts[1];\n                        finalColorData.yellow = valueParts[2];\n                        finalColorData.black = valueParts[3];\n                        finalColorData.colorSource = \"colorvalue_cmyk_standard\";\n                        finalColorData.hasDirectCMYK = true;\n                    } else if (valueParts.length === 3 && colorSpace === \"RGB\") {\n                        // Skip RGB ColorValue for standard colors to avoid \"0 0 0\" issues\n                        console.log(`   âš ï¸  Skipping RGB ColorValue for standard color (avoiding black fallback): \"${colorValue}\"`);\n                        finalColorData.colorSource = \"colorvalue_rgb_skipped_standard\";\n                    } else {\n                        console.log(`   âš ï¸  Could not parse ColorValue for standard color: \"${colorValue}\" (${valueParts.length} parts)`);\n                        finalColorData.colorSource = \"colorvalue_unparseable_standard\";\n                    }\n                }\n                // STRATEGY 5: Handle special color types (fallback)\n                if (finalColorData.colorSource === \"unknown\") {\n                    console.log(`   ðŸ”„ Using fallback handling for color: ${colorSelf}`);\n                    finalColorData.colorSource = \"fallback\";\n                    // For standard colors with no data, don't store them at all\n                    // This will cause them to fall through to the gray fallback in ColorUtils\n                    if (!isCustomColor && finalColorData.cyan === 0 && finalColorData.magenta === 0 && finalColorData.yellow === 0 && finalColorData.black === 0 && finalColorData.red === 0 && finalColorData.green === 0 && finalColorData.blue === 0) {\n                        console.log(`   âš ï¸  Standard color with no valid data - skipping storage to allow gray fallback`);\n                        return; // Skip storing this color completely\n                    }\n                }\n                // Store the color data\n                this.resources.colors[colorSelf] = finalColorData;\n                console.log(`   ðŸ’¾ Stored color data:`, {\n                    self: finalColorData.self,\n                    source: finalColorData.colorSource,\n                    hasRGB: finalColorData.hasDirectRGB,\n                    hasCMYK: finalColorData.hasDirectCMYK,\n                    isCustom: finalColorData.isCustomColor,\n                    rgb: `${finalColorData.red},${finalColorData.green},${finalColorData.blue}`,\n                    cmyk: `${finalColorData.cyan},${finalColorData.magenta},${finalColorData.yellow},${finalColorData.black}`\n                });\n            });\n        }\n        // Extract Gradients\n        if (graphics.Gradient) {\n            const gradients = Array.isArray(graphics.Gradient) ? graphics.Gradient : [\n                graphics.Gradient\n            ];\n            gradients.forEach((gradient)=>{\n                this.resources.gradients[gradient[\"@_Self\"]] = {\n                    self: gradient[\"@_Self\"],\n                    name: gradient[\"@_Name\"] || \"\",\n                    type: gradient[\"@_Type\"] || \"Linear\",\n                    gradientStops: this.extractGradientStops(gradient)\n                };\n            });\n        }\n        console.log(`âœ… Graphics extraction complete. Colors: ${Object.keys(this.resources.colors).length}, Gradients: ${Object.keys(this.resources.gradients).length}`);\n    }\n    // NEW METHOD: Determine if a color is custom and should use RGB ColorValue\n    isCustomColorName(colorSelf, colorName) {\n        // Standard/predefined InDesign colors that should NOT use RGB ColorValue\n        const standardColors = [\n            \"Color/Black\",\n            \"Color/White\",\n            \"Color/Red\",\n            \"Color/Green\",\n            \"Color/Blue\",\n            \"Color/Cyan\",\n            \"Color/Magenta\",\n            \"Color/Yellow\",\n            \"Color/Paper\",\n            \"Color/Registration\",\n            \"Color/None\"\n        ];\n        // Standard color patterns (CMYK values in the name)\n        const cmykPattern = /Color\\/C=[\\d.]+\\s*M=[\\d.]+\\s*Y=[\\d.]+\\s*K=[\\d.]+/;\n        const rgbPattern = /Color\\/R=[\\d.]+\\s*G=[\\d.]+\\s*B=[\\d.]+/;\n        // Check if it's a standard color\n        if (standardColors.includes(colorSelf)) {\n            return false;\n        }\n        // Check if it follows CMYK or RGB pattern (these are auto-generated, not custom)\n        if (cmykPattern.test(colorSelf) || rgbPattern.test(colorSelf)) {\n            return false;\n        }\n        // Check for hidden/system colors\n        if (colorSelf.includes(\"/u\") && /\\/u\\d+$/.test(colorSelf)) {\n            return false;\n        }\n        // If color name is generic or empty, it's likely not custom\n        if (!colorName || colorName === \"\" || colorName === \"$ID/\") {\n            return false;\n        }\n        // Custom colors typically have meaningful names like \"Main\", \"Brand\", \"Accent\", etc.\n        const customColorPatterns = [\n            /main/i,\n            /brand/i,\n            /accent/i,\n            /primary/i,\n            /secondary/i,\n            /theme/i,\n            /custom/i\n        ];\n        // Check if the name matches custom patterns\n        const hasCustomPattern = customColorPatterns.some((pattern)=>pattern.test(colorName) || pattern.test(colorSelf));\n        if (hasCustomPattern) {\n            return true;\n        }\n        // If it's not a standard color and has a meaningful name, consider it custom\n        return colorName.length > 2 && !colorName.includes(\"$ID/\");\n    }\n    extractGradientStops(gradient) {\n        const stops = [];\n        if (gradient.GradientStop) {\n            const stopList = Array.isArray(gradient.GradientStop) ? gradient.GradientStop : [\n                gradient.GradientStop\n            ];\n            stopList.forEach((stop)=>{\n                stops.push({\n                    self: stop[\"@_Self\"],\n                    stopColor: stop[\"@_StopColor\"] || \"\",\n                    location: parseFloat(stop[\"@_Location\"]) || 0,\n                    midpoint: parseFloat(stop[\"@_Midpoint\"]) || 50\n                });\n            });\n        }\n        return stops;\n    }\n    async extractPreferences(preferencesData) {\n        console.log(\"Extracting document preferences...\");\n        const prefs = preferencesData.Preferences || preferencesData;\n        // Extract various document preferences\n        this.documentInfo = {\n            preferences: {\n                documentPreferences: this.extractDocumentPrefs(prefs.DocumentPreference),\n                viewPreferences: this.extractViewPrefs(prefs.ViewPreference),\n                guidePreferences: this.extractGuidePrefs(prefs.GuidePreference),\n                gridPreferences: this.extractGridPrefs(prefs.GridPreference),\n                marginPreferences: this.extractMarginPrefs(prefs.MarginPreference),\n                columnPreferences: this.extractColumnPrefs(prefs.ColumnPreference)\n            }\n        };\n    }\n    extractDocumentPrefs(docPref) {\n        if (!docPref) return {};\n        return {\n            pageWidth: parseFloat(docPref[\"@_PageWidth\"]) || 0,\n            pageHeight: parseFloat(docPref[\"@_PageHeight\"]) || 0,\n            left: parseFloat(docPref[\"@_Left\"]) || 0,\n            top: parseFloat(docPref[\"@_Top\"]) || 0,\n            right: parseFloat(docPref[\"@_Right\"]) || 0,\n            bottom: parseFloat(docPref[\"@_Bottom\"]) || 0,\n            columnCount: parseInt(docPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(docPref[\"@_ColumnGutter\"]) || 0,\n            facingPages: docPref[\"@_FacingPages\"] === true,\n            allowPageShuffle: docPref[\"@_AllowPageShuffle\"] !== false,\n            slugBleedType: docPref[\"@_SlugBleedType\"] || \"None\",\n            documentBleedTopOffset: parseFloat(docPref[\"@_DocumentBleedTopOffset\"]) || 0,\n            documentBleedBottomOffset: parseFloat(docPref[\"@_DocumentBleedBottomOffset\"]) || 0,\n            documentBleedInsideOrLeftOffset: parseFloat(docPref[\"@_DocumentBleedInsideOrLeftOffset\"]) || 0,\n            documentBleedOutsideOrRightOffset: parseFloat(docPref[\"@_DocumentBleedOutsideOrRightOffset\"]) || 0\n        };\n    }\n    extractViewPrefs(viewPref) {\n        if (!viewPref) return {};\n        return {\n            horizontalMeasurementUnits: viewPref[\"@_HorizontalMeasurementUnits\"] || \"Points\",\n            verticalMeasurementUnits: viewPref[\"@_VerticalMeasurementUnits\"] || \"Points\",\n            rulerOrigin: viewPref[\"@_RulerOrigin\"] || \"SpreadOrigin\",\n            showRulers: viewPref[\"@_ShowRulers\"] !== false\n        };\n    }\n    extractGuidePrefs(guidePref) {\n        if (!guidePref) return {};\n        return {\n            rulerGuideColor: guidePref[\"@_RulerGuideColor\"] || \"Green\",\n            guidesInBack: guidePref[\"@_GuidesInBack\"] === true,\n            guidesLocked: guidePref[\"@_GuidesLocked\"] === true,\n            guidesShown: guidePref[\"@_GuidesShown\"] !== false,\n            guidesSnapto: guidePref[\"@_GuidesSnapto\"] !== false\n        };\n    }\n    extractGridPrefs(gridPref) {\n        if (!gridPref) return {};\n        return {\n            baselineStart: parseFloat(gridPref[\"@_BaselineStart\"]) || 0,\n            baselineDivision: parseFloat(gridPref[\"@_BaselineDivision\"]) || 12,\n            baselineShown: gridPref[\"@_BaselineShown\"] === true,\n            baselineSnapto: gridPref[\"@_BaselineSnapto\"] === true,\n            documentGridShown: gridPref[\"@_DocumentGridShown\"] === true,\n            documentGridSnapto: gridPref[\"@_DocumentGridSnapto\"] === true\n        };\n    }\n    extractMarginPrefs(marginPref) {\n        if (!marginPref) return {};\n        return {\n            top: parseFloat(marginPref[\"@_Top\"]) || 0,\n            bottom: parseFloat(marginPref[\"@_Bottom\"]) || 0,\n            left: parseFloat(marginPref[\"@_Left\"]) || 0,\n            right: parseFloat(marginPref[\"@_Right\"]) || 0,\n            columnCount: parseInt(marginPref[\"@_ColumnCount\"]) || 1,\n            columnGutter: parseFloat(marginPref[\"@_ColumnGutter\"]) || 0\n        };\n    }\n    extractColumnPrefs(columnPref) {\n        if (!columnPref) return {};\n        return {\n            textColumnCount: parseInt(columnPref[\"@_TextColumnCount\"]) || 1,\n            textColumnGutter: parseFloat(columnPref[\"@_TextColumnGutter\"]) || 0\n        };\n    }\n    resolveStyleFormatting(formatting) {\n        const resolved = {\n            ...formatting\n        };\n        // DEBUG: Check if formatting is being applied (generic check)\n        const hasAnyFormatting = formatting.paragraphStyle || formatting.characterStyle || formatting.fontStyle || formatting.fontReference || formatting.fontSize;\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Input:\", {\n                paragraphStyle: formatting.paragraphStyle,\n                characterStyle: formatting.characterStyle,\n                directFontStyle: formatting.fontStyle,\n                directFontRef: formatting.fontReference,\n                directFontSize: formatting.fontSize\n            });\n        }\n        // Resolve paragraph style (base layer)\n        if (formatting.paragraphStyle && this.styles.paragraph[formatting.paragraphStyle]) {\n            const pStyle = this.styles.paragraph[formatting.paragraphStyle];\n            if (!resolved.fontSize && pStyle.pointSize) resolved.fontSize = pStyle.pointSize;\n            if (!resolved.fillColor && pStyle.fillColor) resolved.fillColor = pStyle.fillColor;\n            // CRITICAL FIX: Always inherit paragraph alignment unless explicitly overridden\n            if (pStyle.alignment) resolved.alignment = pStyle.alignment;\n            if (!resolved.fontStyle && pStyle.fontStyle) {\n                resolved.fontStyle = pStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log(`   FontStyle from paragraph style: \"${pStyle.fontStyle}\"`);\n                }\n            }\n            // CRITICAL: Resolve font from paragraph style\n            if (!resolved.fontFamily && pStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(pStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(`   Font from paragraph style: ${pStyle.appliedFont} -> ${resolved.fontFamily}`);\n                }\n            }\n            // Add other paragraph properties with enhanced leading support\n            resolved.leading = pStyle.leading;\n            resolved.leadingType = pStyle.leadingType;\n            resolved.effectiveLineHeight = pStyle.effectiveLineHeight;\n            resolved.leftIndent = pStyle.leftIndent;\n            resolved.rightIndent = pStyle.rightIndent;\n            resolved.firstLineIndent = pStyle.firstLineIndent;\n            resolved.spaceBefore = pStyle.spaceBefore;\n            resolved.spaceAfter = pStyle.spaceAfter;\n            resolved.tracking = pStyle.tracking;\n            resolved.kerning = pStyle.kerning;\n        }\n        // Resolve character style (override layer)\n        if (formatting.characterStyle && this.styles.character[formatting.characterStyle]) {\n            const cStyle = this.styles.character[formatting.characterStyle];\n            if (cStyle.pointSize) resolved.fontSize = cStyle.pointSize;\n            if (cStyle.fillColor) resolved.fillColor = cStyle.fillColor;\n            if (cStyle.fontStyle) {\n                resolved.fontStyle = cStyle.fontStyle;\n                if (hasAnyFormatting) {\n                    console.log(`   FontStyle from character style: \"${cStyle.fontStyle}\"`);\n                }\n            }\n            if (cStyle.strokeColor) resolved.strokeColor = cStyle.strokeColor;\n            // Include leading information from character style\n            if (cStyle.leading) resolved.leading = cStyle.leading;\n            if (cStyle.leadingType) resolved.leadingType = cStyle.leadingType;\n            if (cStyle.effectiveLineHeight) resolved.effectiveLineHeight = cStyle.effectiveLineHeight;\n            // CRITICAL: Character style font overrides paragraph style\n            if (cStyle.appliedFont) {\n                resolved.fontFamily = this.resolveFontReference(cStyle.appliedFont);\n                if (hasAnyFormatting) {\n                    console.log(`   Font from character style: ${cStyle.appliedFont} -> ${resolved.fontFamily}`);\n                }\n            }\n        }\n        // Apply direct formatting (highest priority)\n        if (formatting.fontReference) {\n            resolved.fontFamily = this.resolveFontReference(formatting.fontReference);\n            if (hasAnyFormatting) {\n                console.log(`   Font from direct formatting: ${formatting.fontReference} -> ${resolved.fontFamily}`);\n            }\n        }\n        // CRITICAL: Apply direct fontStyle if provided (this might be the issue)\n        if (formatting.fontStyle) {\n            resolved.fontStyle = formatting.fontStyle;\n            if (hasAnyFormatting) {\n                console.log(`   FontStyle from direct formatting: \"${formatting.fontStyle}\"`);\n            }\n        }\n        // Apply direct leading information (highest priority)\n        if (formatting.leading !== undefined) resolved.leading = formatting.leading;\n        if (formatting.leadingType) resolved.leadingType = formatting.leadingType;\n        if (formatting.effectiveLineHeight) resolved.effectiveLineHeight = formatting.effectiveLineHeight;\n        // Apply other direct formatting attributes\n        if (formatting.fontSize) resolved.fontSize = formatting.fontSize;\n        if (formatting.tracking) resolved.tracking = formatting.tracking;\n        if (formatting.kerning) resolved.kerning = formatting.kerning;\n        // CRITICAL FIX: Apply direct alignment if explicitly specified (overrides paragraph alignment)\n        if (formatting.alignment) {\n            resolved.alignment = formatting.alignment;\n            if (hasAnyFormatting) {\n                console.log(`   Alignment from direct formatting: \"${formatting.alignment}\"`);\n            }\n        }\n        // FIXED: Ensure fontStyle defaults to Regular/normal if not set\n        if (!resolved.fontStyle || resolved.fontStyle === \"\") {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log(`   FontStyle defaulted to: \"Regular\"`);\n            }\n        }\n        // ADDITIONAL FIX: If no styles were applied from any source, ensure clean defaults\n        if (!formatting.paragraphStyle && !formatting.characterStyle && !formatting.fontStyle && !formatting.fontReference) {\n            resolved.fontStyle = \"Regular\";\n            if (hasAnyFormatting) {\n                console.log(`   No source styles found - ensuring clean defaults`);\n            }\n        }\n        // Final fallback\n        if (!resolved.fontFamily || resolved.fontFamily === \"\") {\n            resolved.fontFamily = this.getDefaultFont();\n            if (hasAnyFormatting) {\n                console.log(`   Using fallback font: ${resolved.fontFamily}`);\n            }\n        }\n        // Ensure line height is calculated if not explicitly set\n        if (!resolved.effectiveLineHeight && resolved.fontSize && resolved.leading) {\n            resolved.effectiveLineHeight = this.calculateEffectiveLineHeight(resolved.leading, resolved.fontSize);\n        }\n        if (hasAnyFormatting) {\n            console.log(\"\\uD83D\\uDD27 StyleParser.resolveStyleFormatting - Final Output:\", {\n                fontSize: resolved.fontSize,\n                fontFamily: resolved.fontFamily,\n                fontStyle: resolved.fontStyle,\n                fillColor: resolved.fillColor,\n                leading: resolved.leading,\n                effectiveLineHeight: resolved.effectiveLineHeight\n            });\n        }\n        return resolved;\n    }\n    resolveFontReference(fontRef) {\n        if (!fontRef || fontRef === \"\") {\n            console.log(\"Empty font reference, using fallback\");\n            return this.getDefaultFont();\n        }\n        // Try direct lookup in font map\n        if (this.fontMap && this.fontMap.has(fontRef)) {\n            const resolvedFont = this.fontMap.get(fontRef);\n            console.log(`Font resolved: \"${fontRef}\" -> \"${resolvedFont}\"`);\n            return resolvedFont;\n        }\n        // Try partial matching for font families\n        if (this.resources.fonts) {\n            for (const [familyId, familyInfo] of Object.entries(this.resources.fonts)){\n                // Check family name match\n                if (familyInfo.name && (familyInfo.name.toLowerCase().includes(fontRef.toLowerCase()) || fontRef.toLowerCase().includes(familyInfo.name.toLowerCase()))) {\n                    console.log(`Font partially matched: \"${fontRef}\" -> \"${familyInfo.name}\"`);\n                    return familyInfo.name;\n                }\n                // Check individual font matches\n                if (familyInfo.fonts) {\n                    for (const font of familyInfo.fonts){\n                        if (font.self === fontRef || font.postScriptName === fontRef || font.name === fontRef) {\n                            console.log(`Font exactly matched: \"${fontRef}\" -> \"${familyInfo.name}\"`);\n                            return familyInfo.name;\n                        }\n                    }\n                }\n            }\n        }\n        console.log(`Font not found: \"${fontRef}\", using fallback`);\n        return this.getDefaultFont() || fontRef;\n    }\n    getDefaultFont() {\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFamily = Object.values(this.resources.fonts)[0];\n            return firstFamily.name || \"Arial\";\n        }\n        return \"Arial\";\n    }\n    inferFontFromContext() {\n        // If we have font definitions but no explicit references,\n        // return the first available font as a fallback\n        if (this.resources.fonts && Object.keys(this.resources.fonts).length > 0) {\n            const firstFontFamily = Object.values(this.resources.fonts)[0];\n            return firstFontFamily.name;\n        }\n        return null;\n    }\n    getStoryStyleSummary(story) {\n        const summary = {\n            fontSize: null,\n            fontFamily: null,\n            alignment: null,\n            fillColor: null,\n            fontStyle: null,\n            leading: null,\n            leadingType: null,\n            effectiveLineHeight: null,\n            tracking: null,\n            kerning: null\n        };\n        // Get the most common or first formatting values\n        if (story.content?.formattedContent?.length > 0) {\n            const firstFormatted = story.content.formattedContent.find((item)=>item.formatting && !item.formatting.isBreak);\n            if (firstFormatted?.formatting) {\n                const fmt = firstFormatted.formatting;\n                summary.fontSize = fmt.fontSize;\n                summary.fontFamily = fmt.fontFamily;\n                summary.alignment = fmt.alignment;\n                summary.fillColor = fmt.fillColor;\n                summary.fontStyle = fmt.fontStyle;\n                summary.leading = fmt.leading;\n                summary.leadingType = fmt.leadingType;\n                summary.effectiveLineHeight = fmt.effectiveLineHeight;\n                summary.tracking = fmt.tracking;\n                summary.kerning = fmt.kerning;\n            }\n        }\n        return summary;\n    }\n    // NEW: Process leading values with InDesign-specific logic (shared with StoryParser)\n    processLeadingValue(rawLeading, fontSize) {\n        if (!rawLeading) return \"auto\";\n        // Handle \"auto\" leading\n        if (rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return fontSize ? fontSize * 1.2 : \"auto\"; // InDesign default auto leading is 120%\n        }\n        // Handle numeric leading (in points)\n        const numericLeading = parseFloat(rawLeading);\n        if (!isNaN(numericLeading)) {\n            return numericLeading;\n        }\n        // Handle percentage-based leading\n        if (rawLeading.includes(\"%\")) {\n            const percentage = parseFloat(rawLeading.replace(\"%\", \"\"));\n            return fontSize ? fontSize * percentage / 100 : \"auto\";\n        }\n        return \"auto\";\n    }\n    // NEW: Determine the type of leading being used\n    determineLeadingType(rawLeading) {\n        if (!rawLeading || rawLeading === \"auto\" || rawLeading === \"Auto\") {\n            return \"auto\";\n        }\n        if (rawLeading.includes(\"%\")) {\n            return \"percentage\";\n        }\n        if (!isNaN(parseFloat(rawLeading))) {\n            return \"absolute\";\n        }\n        return \"unknown\";\n    }\n    // NEW: Calculate effective line height for CSS rendering\n    calculateEffectiveLineHeight(leading, fontSize) {\n        if (leading === \"auto\") {\n            return 1.2; // CSS line-height ratio for auto\n        }\n        if (typeof leading === \"number\" && fontSize) {\n            // Convert points to CSS line-height ratio\n            return Math.max(0.8, leading / fontSize); // Ensure minimum line height\n        }\n        return 1.2; // Fallback\n    }\n    getStyles() {\n        return this.styles;\n    }\n    getResources() {\n        return this.resources;\n    }\n    getFontMap() {\n        return this.fontMap;\n    }\n    // Add methods to return style and font definitions for debug\n    getParagraphStyles() {\n        return this.styles.paragraph;\n    }\n    getCharacterStyles() {\n        return this.styles.character;\n    }\n    getFontDefinitions() {\n        // Prefer plain object for debug output\n        if (this.resources && this.resources.fonts) {\n            return this.resources.fonts;\n        }\n        // Fallback: convert fontMap to object\n        if (this.fontMap && typeof this.fontMap.entries === \"function\") {\n            return Object.fromEntries(this.fontMap.entries());\n        }\n        return {};\n    }\n    // FIXED: Add method to access document preferences including ViewPreferences\n    getDocumentInfo() {\n        return this.documentInfo;\n    }\n}\nmodule.exports = StyleParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcsQ0FBQyxLQUFLalEsVUFBVThCLFdBQVcsNkJBQTZCO1FBQ3pFO1FBRUEsT0FBTyxLQUFLLFdBQVc7SUFDekI7SUFFQW9PLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQy9SLE1BQU07SUFDcEI7SUFFQWdTLGVBQWU7UUFDYixPQUFPLElBQUksQ0FBQzFSLFNBQVM7SUFDdkI7SUFFQTJSLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQ3ZSLE9BQU87SUFDckI7SUFFQSw2REFBNkQ7SUFDN0R3UixxQkFBcUI7UUFDbkIsT0FBTyxJQUFJLENBQUNsUyxNQUFNLENBQUNDLFNBQVM7SUFDOUI7SUFDQWtTLHFCQUFxQjtRQUNuQixPQUFPLElBQUksQ0FBQ25TLE1BQU0sQ0FBQ0UsU0FBUztJQUM5QjtJQUNBa1MscUJBQXFCO1FBQ25CLHVDQUF1QztRQUN2QyxJQUFJLElBQUksQ0FBQzlSLFNBQVMsSUFBSSxJQUFJLENBQUNBLFNBQVMsQ0FBQ0MsS0FBSyxFQUFFO1lBQzFDLE9BQU8sSUFBSSxDQUFDRCxTQUFTLENBQUNDLEtBQUs7UUFDN0I7UUFDQSxzQ0FBc0M7UUFDdEMsSUFBSSxJQUFJLENBQUNHLE9BQU8sSUFBSSxPQUFPLElBQUksQ0FBQ0EsT0FBTyxDQUFDaVEsT0FBTyxLQUFLLFlBQVk7WUFDOUQsT0FBTy9JLE9BQU95SyxXQUFXLENBQUMsSUFBSSxDQUFDM1IsT0FBTyxDQUFDaVEsT0FBTztRQUNoRDtRQUNBLE9BQU8sQ0FBQztJQUNWO0lBRUEsNkVBQTZFO0lBQzdFMkIsa0JBQWtCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDekcsWUFBWTtJQUMxQjtBQUNGO0FBRUEwRyxPQUFPQyxPQUFPLEdBQUczUyIsInNvdXJjZXMiOlsid2VicGFjazovL2lkbWwtdmlld2VyLy4vbGliL3BhcnNlcnMvU3R5bGVQYXJzZXIuanM/NjlhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9JRE1MVXRpbHNcIik7XHJcblxyXG5jbGFzcyBTdHlsZVBhcnNlciB7XHJcbiAgY29uc3RydWN0b3IodW5pdENvbnZlcnRlciA9IG51bGwpIHtcclxuICAgIHRoaXMuc3R5bGVzID0ge1xyXG4gICAgICBwYXJhZ3JhcGg6IHt9LFxyXG4gICAgICBjaGFyYWN0ZXI6IHt9LFxyXG4gICAgICBvYmplY3Q6IHt9LFxyXG4gICAgICB0YWJsZToge30sXHJcbiAgICAgIGNlbGw6IHt9LFxyXG4gICAgfTtcclxuICAgIHRoaXMucmVzb3VyY2VzID0ge1xyXG4gICAgICBmb250czoge30sXHJcbiAgICAgIGNvbG9yczoge30sXHJcbiAgICAgIGdyYWRpZW50czoge30sXHJcbiAgICB9O1xyXG4gICAgdGhpcy5mb250TWFwID0gbmV3IE1hcCgpOyAvLyBHbG9iYWwgZm9udCBsb29rdXAgbWFwXHJcbiAgICB0aGlzLnVuaXRDb252ZXJ0ZXIgPSB1bml0Q29udmVydGVyOyAvLyBBRERFRDogVW5pdCBjb252ZXJ0ZXIgZm9yIHR5cG9ncmFwaHkgbWVhc3VyZW1lbnRzXHJcbiAgICB0aGlzLmRvY3VtZW50VW5pdHMgPSBudWxsOyAvLyBXaWxsIGJlIHNldCBmcm9tIGRvY3VtZW50IHVuaXRzXHJcbiAgfVxyXG5cclxuICAvLyBBRERFRDogTWV0aG9kIHRvIHNldCBkb2N1bWVudCB1bml0cyBmb3IgdHlwb2dyYXBoeSBjb252ZXJzaW9uXHJcbiAgc2V0RG9jdW1lbnRVbml0cyh1bml0cykge1xyXG4gICAgdGhpcy5kb2N1bWVudFVuaXRzID0gdW5pdHM7XHJcbiAgICBjb25zb2xlLmxvZyhcIvCfk5AgU3R5bGVQYXJzZXI6IFNldCBkb2N1bWVudCB1bml0cyB0b1wiLCB1bml0cyk7XHJcbiAgfVxyXG5cclxuICAvLyBBRERFRDogTWV0aG9kIHRvIGNvbnZlcnQgdHlwb2dyYXBoeSBtZWFzdXJlbWVudHMgdG8gcGl4ZWxzXHJcbiAgY29udmVydFR5cG9ncmFwaHlUb1BpeGVscyh2YWx1ZSkge1xyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHxcclxuICAgICAgaXNOYU4odmFsdWUpIHx8XHJcbiAgICAgICF0aGlzLnVuaXRDb252ZXJ0ZXIgfHxcclxuICAgICAgIXRoaXMuZG9jdW1lbnRVbml0c1xyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPbmx5IGNvbnZlcnQgaWYgd2UgaGF2ZSBhIHN1cHBvcnRlZCB1bml0IGFuZCBpdCdzIG5vdCBhbHJlYWR5IHBpeGVsc1xyXG4gICAgaWYgKHRoaXMudW5pdENvbnZlcnRlci5pc1N1cHBvcnRlZFVuaXQodGhpcy5kb2N1bWVudFVuaXRzKSkge1xyXG4gICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IHRoaXMudW5pdENvbnZlcnRlci50b1BpeGVscyhcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICB0aGlzLmRvY3VtZW50VW5pdHNcclxuICAgICAgKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYPCfk5AgQ29udmVydGVkIHR5cG9ncmFwaHk6ICR7dmFsdWV9ICR7dGhpcy5kb2N1bWVudFVuaXRzfSDihpIgJHtjb252ZXJ0ZWRWYWx1ZX0gcHhgXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBjb252ZXJ0ZWRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvLyBBRERFRDogTWV0aG9kIHRvIGNvbnZlcnQgYW4gZW50aXJlIHN0eWxlIG9iamVjdCdzIG1lYXN1cmVtZW50cyB0byBwaXhlbHNcclxuICBjb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyhzdHlsZSkge1xyXG4gICAgaWYgKCF0aGlzLnVuaXRDb252ZXJ0ZXIgfHwgIXRoaXMuZG9jdW1lbnRVbml0cykge1xyXG4gICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29udmVydGVkU3R5bGUgPSB7IC4uLnN0eWxlIH07XHJcblxyXG4gICAgLy8gQ29udmVydCBtZWFzdXJlbWVudHMgdGhhdCBuZWVkIHBpeGVsIGNvbnZlcnNpb25cclxuICAgIGNvbnN0IG1lYXN1cmVtZW50RmllbGRzID0gW1xyXG4gICAgICBcImxlZnRJbmRlbnRcIixcclxuICAgICAgXCJyaWdodEluZGVudFwiLFxyXG4gICAgICBcImZpcnN0TGluZUluZGVudFwiLFxyXG4gICAgICBcInNwYWNlQmVmb3JlXCIsXHJcbiAgICAgIFwic3BhY2VBZnRlclwiLFxyXG4gICAgICBcInRyYWNraW5nXCIsXHJcbiAgICAgIFwia2VybmluZ1wiLFxyXG4gICAgXTtcclxuXHJcbiAgICBtZWFzdXJlbWVudEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIGNvbnZlcnRlZFN0eWxlW2ZpZWxkXSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIGNvbnZlcnRlZFN0eWxlW2ZpZWxkXSA9IHRoaXMuY29udmVydFR5cG9ncmFwaHlUb1BpeGVscyhcclxuICAgICAgICAgIGNvbnZlcnRlZFN0eWxlW2ZpZWxkXVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENvbnZlcnQgbGVhZGluZyBpZiBpdCdzIGEgbnVtZXJpYyB2YWx1ZVxyXG4gICAgaWYgKHR5cGVvZiBjb252ZXJ0ZWRTdHlsZS5sZWFkaW5nID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIGNvbnZlcnRlZFN0eWxlLmxlYWRpbmcgPSB0aGlzLmNvbnZlcnRUeXBvZ3JhcGh5VG9QaXhlbHMoXHJcbiAgICAgICAgY29udmVydGVkU3R5bGUubGVhZGluZ1xyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb252ZXJ0ZWRTdHlsZTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHBhcnNlUmVzb3VyY2VGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB4bWxQYXJzZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OLIFBhcnNpbmcgcmVzb3VyY2U6ICR7ZmlsZU5hbWV9YCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGFyc2VkID0geG1sUGFyc2VyLnBhcnNlKGNvbnRlbnQpO1xyXG4gICAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVOYW1lLCBcIi54bWxcIik7XHJcblxyXG4gICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHJlc291cmNlIHR5cGVzXHJcbiAgICAgIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhcIlN0eWxlcy54bWxcIikpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RTdHlsZXMocGFyc2VkKTtcclxuICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5pbmNsdWRlcyhcIkZvbnRzLnhtbFwiKSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdEZvbnRzKHBhcnNlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoXCJHcmFwaGljLnhtbFwiKSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdEdyYXBoaWNzKHBhcnNlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoXCJQcmVmZXJlbmNlcy54bWxcIikpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RQcmVmZXJlbmNlcyhwYXJzZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFJlc291cmNlICR7cmVzb3VyY2VOYW1lfSBwYXJzZWRgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBwYXJzaW5nICR7ZmlsZU5hbWV9OmAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXh0cmFjdFN0eWxlcyhzdHlsZXNEYXRhKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3Rpbmcgc3R5bGVzLi4uXCIpO1xyXG5cclxuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlc0RhdGEuU3R5bGVzIHx8IHN0eWxlc0RhdGE7XHJcblxyXG4gICAgLy8gRXh0cmFjdCBQYXJhZ3JhcGggU3R5bGVzXHJcbiAgICBpZiAoc3R5bGVzLlJvb3RQYXJhZ3JhcGhTdHlsZUdyb3VwKSB7XHJcbiAgICAgIHRoaXMuZXh0cmFjdFBhcmFncmFwaFN0eWxlcyhzdHlsZXMuUm9vdFBhcmFncmFwaFN0eWxlR3JvdXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dHJhY3QgQ2hhcmFjdGVyIFN0eWxlc1xyXG4gICAgaWYgKHN0eWxlcy5Sb290Q2hhcmFjdGVyU3R5bGVHcm91cCkge1xyXG4gICAgICB0aGlzLmV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVzLlJvb3RDaGFyYWN0ZXJTdHlsZUdyb3VwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMoc3R5bGVHcm91cCkge1xyXG4gICAgY29uc3QgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5ID0gKGdyb3VwKSA9PiB7XHJcbiAgICAgIGlmIChncm91cC5QYXJhZ3JhcGhTdHlsZSkge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuUGFyYWdyYXBoU3R5bGUpXHJcbiAgICAgICAgICA/IGdyb3VwLlBhcmFncmFwaFN0eWxlXHJcbiAgICAgICAgICA6IFtncm91cC5QYXJhZ3JhcGhTdHlsZV07XHJcblxyXG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKChzdHlsZSkgPT4ge1xyXG4gICAgICAgICAgLy8gQ1JJVElDQUw6IEV4dHJhY3QgZm9udCByZWZlcmVuY2UgZnJvbSBtdWx0aXBsZSBwb3NzaWJsZSBsb2NhdGlvbnNcclxuICAgICAgICAgIGNvbnN0IGZvbnRSZWYgPSB0aGlzLmV4dHJhY3RGb250RnJvbVN0eWxlKHN0eWxlKTtcclxuXHJcbiAgICAgICAgICAvLyBFTkhBTkNFRDogUHJvY2VzcyBsZWFkaW5nIHdpdGggcHJvcGVyIEluRGVzaWduIGxvZ2ljXHJcbiAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IHBhcnNlRmxvYXQoc3R5bGVbXCJAX1BvaW50U2l6ZVwiXSkgfHwgMTI7XHJcbiAgICAgICAgICBjb25zdCByYXdMZWFkaW5nID0gc3R5bGVbXCJAX0xlYWRpbmdcIl07XHJcbiAgICAgICAgICBjb25zdCBwcm9jZXNzZWRMZWFkaW5nID0gdGhpcy5wcm9jZXNzTGVhZGluZ1ZhbHVlKFxyXG4gICAgICAgICAgICByYXdMZWFkaW5nLFxyXG4gICAgICAgICAgICBmb250U2l6ZVxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvLyBGSVhFRDogRXh0cmFjdCByYXcgdHlwb2dyYXBoeSBtZWFzdXJlbWVudHMgZm9yIGNvbnZlcnNpb25cclxuICAgICAgICAgIGNvbnN0IHJhd0xlZnRJbmRlbnQgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9MZWZ0SW5kZW50XCJdKSB8fCAwO1xyXG4gICAgICAgICAgY29uc3QgcmF3UmlnaHRJbmRlbnQgPSBwYXJzZUZsb2F0KHN0eWxlW1wiQF9SaWdodEluZGVudFwiXSkgfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHJhd0ZpcnN0TGluZUluZGVudCA9XHJcbiAgICAgICAgICAgIHBhcnNlRmxvYXQoc3R5bGVbXCJAX0ZpcnN0TGluZUluZGVudFwiXSkgfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHJhd1NwYWNlQmVmb3JlID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfU3BhY2VCZWZvcmVcIl0pIHx8IDA7XHJcbiAgICAgICAgICBjb25zdCByYXdTcGFjZUFmdGVyID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfU3BhY2VBZnRlclwiXSkgfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHJhd1RyYWNraW5nID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfVHJhY2tpbmdcIl0pIHx8IDA7XHJcbiAgICAgICAgICBjb25zdCByYXdLZXJuaW5nID0gcGFyc2VGbG9hdChzdHlsZVtcIkBfS2VybmluZ1wiXSkgfHwgMDtcclxuXHJcbiAgICAgICAgICAvLyBGSVhFRDogQ3JlYXRlIGJhc2Ugc3R5bGUgb2JqZWN0IHdpdGggcmF3IHZhbHVlc1xyXG4gICAgICAgICAgY29uc3QgYmFzZVN0eWxlID0ge1xyXG4gICAgICAgICAgICBzZWxmOiBzdHlsZVtcIkBfU2VsZlwiXSxcclxuICAgICAgICAgICAgbmFtZTogc3R5bGVbXCJAX05hbWVcIl0gfHwgXCJcIixcclxuICAgICAgICAgICAgZm9udFN0eWxlOiBzdHlsZVtcIkBfRm9udFN0eWxlXCJdIHx8IFwiUmVndWxhclwiLFxyXG4gICAgICAgICAgICBwb2ludFNpemU6IGZvbnRTaXplLFxyXG4gICAgICAgICAgICBsZWFkaW5nOiBwcm9jZXNzZWRMZWFkaW5nLFxyXG4gICAgICAgICAgICBsZWFkaW5nVHlwZTogdGhpcy5kZXRlcm1pbmVMZWFkaW5nVHlwZShyYXdMZWFkaW5nKSxcclxuICAgICAgICAgICAgZWZmZWN0aXZlTGluZUhlaWdodDogdGhpcy5jYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0KFxyXG4gICAgICAgICAgICAgIHByb2Nlc3NlZExlYWRpbmcsXHJcbiAgICAgICAgICAgICAgZm9udFNpemVcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgYWxpZ25tZW50OiBzdHlsZVtcIkBfSnVzdGlmaWNhdGlvblwiXSB8fCBcIkxlZnRBbGlnblwiLFxyXG5cclxuICAgICAgICAgICAgLy8gUmF3IG1lYXN1cmVtZW50cyAod2lsbCBiZSBjb252ZXJ0ZWQgdG8gcGl4ZWxzKVxyXG4gICAgICAgICAgICBsZWZ0SW5kZW50OiByYXdMZWZ0SW5kZW50LFxyXG4gICAgICAgICAgICByaWdodEluZGVudDogcmF3UmlnaHRJbmRlbnQsXHJcbiAgICAgICAgICAgIGZpcnN0TGluZUluZGVudDogcmF3Rmlyc3RMaW5lSW5kZW50LFxyXG4gICAgICAgICAgICBzcGFjZUJlZm9yZTogcmF3U3BhY2VCZWZvcmUsXHJcbiAgICAgICAgICAgIHNwYWNlQWZ0ZXI6IHJhd1NwYWNlQWZ0ZXIsXHJcbiAgICAgICAgICAgIHRyYWNraW5nOiByYXdUcmFja2luZyxcclxuICAgICAgICAgICAga2VybmluZzogcmF3S2VybmluZyxcclxuXHJcbiAgICAgICAgICAgIC8vIFN0b3JlIG9yaWdpbmFsIHZhbHVlcyBmb3IgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIG9yaWdpbmFsTGVmdEluZGVudDogcmF3TGVmdEluZGVudCxcclxuICAgICAgICAgICAgb3JpZ2luYWxSaWdodEluZGVudDogcmF3UmlnaHRJbmRlbnQsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsRmlyc3RMaW5lSW5kZW50OiByYXdGaXJzdExpbmVJbmRlbnQsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3BhY2VCZWZvcmU6IHJhd1NwYWNlQmVmb3JlLFxyXG4gICAgICAgICAgICBvcmlnaW5hbFNwYWNlQWZ0ZXI6IHJhd1NwYWNlQWZ0ZXIsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsVHJhY2tpbmc6IHJhd1RyYWNraW5nLFxyXG4gICAgICAgICAgICBvcmlnaW5hbEtlcm5pbmc6IHJhd0tlcm5pbmcsXHJcblxyXG4gICAgICAgICAgICBob3Jpem9udGFsU2NhbGU6IHBhcnNlRmxvYXQoc3R5bGVbXCJAX0hvcml6b250YWxTY2FsZVwiXSkgfHwgMTAwLFxyXG4gICAgICAgICAgICB2ZXJ0aWNhbFNjYWxlOiBwYXJzZUZsb2F0KHN0eWxlW1wiQF9WZXJ0aWNhbFNjYWxlXCJdKSB8fCAxMDAsXHJcblxyXG4gICAgICAgICAgICAvLyBFTkhBTkNFRDogVXNlIHRoZSBuZXcgZXh0cmFjdGlvbiBtZXRob2RcclxuICAgICAgICAgICAgYXBwbGllZEZvbnQ6IGZvbnRSZWYsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsRm9udFJlZjogZm9udFJlZixcclxuXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogc3R5bGVbXCJAX0ZpbGxDb2xvclwiXSB8fCBcIkNvbG9yL0JsYWNrXCIsXHJcbiAgICAgICAgICAgIHJhd1N0eWxlOiBzdHlsZSxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgLy8gRklYRUQ6IEFwcGx5IHVuaXQgY29udmVyc2lvbiB0byBjcmVhdGUgcGl4ZWwtY29udmVydGVkIHN0eWxlXHJcbiAgICAgICAgICB0aGlzLnN0eWxlcy5wYXJhZ3JhcGhbc3R5bGVbXCJAX1NlbGZcIl1dID1cclxuICAgICAgICAgICAgdGhpcy5jb252ZXJ0U3R5bGVNZWFzdXJlbWVudHNUb1BpeGVscyhiYXNlU3R5bGUpO1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBg4pyFIFBhcmFncmFwaCBTdHlsZTogJHtzdHlsZVtcIkBfTmFtZVwiXX0gLT4gRm9udDogXCIke2ZvbnRSZWZ9XCJgXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cCkge1xyXG4gICAgICAgIGNvbnN0IHN1Ykdyb3VwcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cClcclxuICAgICAgICAgID8gZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cFxyXG4gICAgICAgICAgOiBbZ3JvdXAuUGFyYWdyYXBoU3R5bGVHcm91cF07XHJcbiAgICAgICAgc3ViR3JvdXBzLmZvckVhY2goZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkoc3R5bGVHcm91cCk7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0Rm9udEZyb21TdHlsZShzdHlsZSkge1xyXG4gICAgLy8gVHJ5IGRpcmVjdCBhdHRyaWJ1dGVzIGZpcnN0XHJcbiAgICBsZXQgZm9udFJlZiA9XHJcbiAgICAgIHN0eWxlW1wiQF9BcHBsaWVkRm9udFwiXSB8fCBzdHlsZVtcIkBfRm9udEZhbWlseVwiXSB8fCBzdHlsZVtcIkBfRm9udFwiXSB8fCBcIlwiO1xyXG5cclxuICAgIC8vIElmIG5vdCBmb3VuZCwgdHJ5IFByb3BlcnRpZXMgbmVzdGVkIHN0cnVjdHVyZVxyXG4gICAgaWYgKCFmb250UmVmICYmIHN0eWxlLlByb3BlcnRpZXMpIHtcclxuICAgICAgaWYgKHN0eWxlLlByb3BlcnRpZXMuQXBwbGllZEZvbnQpIHtcclxuICAgICAgICBmb250UmVmID1cclxuICAgICAgICAgIHN0eWxlLlByb3BlcnRpZXMuQXBwbGllZEZvbnRbXCIjdGV4dFwiXSB8fFxyXG4gICAgICAgICAgc3R5bGUuUHJvcGVydGllcy5BcHBsaWVkRm9udCB8fFxyXG4gICAgICAgICAgXCJcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWxzbyB0cnkgb3RoZXIgcHJvcGVydHkgdmFyaWF0aW9uc1xyXG4gICAgICBpZiAoIWZvbnRSZWYgJiYgc3R5bGUuUHJvcGVydGllcy5Gb250RmFtaWx5KSB7XHJcbiAgICAgICAgZm9udFJlZiA9XHJcbiAgICAgICAgICBzdHlsZS5Qcm9wZXJ0aWVzLkZvbnRGYW1pbHlbXCIjdGV4dFwiXSB8fFxyXG4gICAgICAgICAgc3R5bGUuUHJvcGVydGllcy5Gb250RmFtaWx5IHx8XHJcbiAgICAgICAgICBcIlwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvbnRSZWYgfHwgXCJcIjtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMoc3R5bGVHcm91cCkge1xyXG4gICAgY29uc3QgZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5ID0gKGdyb3VwKSA9PiB7XHJcbiAgICAgIGlmIChncm91cC5DaGFyYWN0ZXJTdHlsZSkge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmlzQXJyYXkoZ3JvdXAuQ2hhcmFjdGVyU3R5bGUpXHJcbiAgICAgICAgICA/IGdyb3VwLkNoYXJhY3RlclN0eWxlXHJcbiAgICAgICAgICA6IFtncm91cC5DaGFyYWN0ZXJTdHlsZV07XHJcblxyXG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKChzdHlsZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZm9udFJlZiA9IHRoaXMuZXh0cmFjdEZvbnRGcm9tU3R5bGUoc3R5bGUpO1xyXG5cclxuICAgICAgICAgIHRoaXMuc3R5bGVzLmNoYXJhY3RlcltzdHlsZVtcIkBfU2VsZlwiXV0gPSB7XHJcbiAgICAgICAgICAgIHNlbGY6IHN0eWxlW1wiQF9TZWxmXCJdLFxyXG4gICAgICAgICAgICBuYW1lOiBzdHlsZVtcIkBfTmFtZVwiXSB8fCBcIlwiLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6IHN0eWxlW1wiQF9Gb250U3R5bGVcIl0gfHwgXCJSZWd1bGFyXCIsXHJcbiAgICAgICAgICAgIHBvaW50U2l6ZTogcGFyc2VGbG9hdChzdHlsZVtcIkBfUG9pbnRTaXplXCJdKSB8fCBudWxsLFxyXG5cclxuICAgICAgICAgICAgYXBwbGllZEZvbnQ6IGZvbnRSZWYsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsRm9udFJlZjogZm9udFJlZixcclxuXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogc3R5bGVbXCJAX0ZpbGxDb2xvclwiXSB8fCBudWxsLFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogc3R5bGVbXCJAX1N0cm9rZUNvbG9yXCJdIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHJhd1N0eWxlOiBzdHlsZSxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGDinIUgQ2hhcmFjdGVyIFN0eWxlOiAke3N0eWxlW1wiQF9OYW1lXCJdfSAtPiBGb250OiBcIiR7Zm9udFJlZn1cImBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwKSB7XHJcbiAgICAgICAgY29uc3Qgc3ViR3JvdXBzID0gQXJyYXkuaXNBcnJheShncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwKVxyXG4gICAgICAgICAgPyBncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwXHJcbiAgICAgICAgICA6IFtncm91cC5DaGFyYWN0ZXJTdHlsZUdyb3VwXTtcclxuICAgICAgICBzdWJHcm91cHMuZm9yRWFjaChleHRyYWN0U3R5bGVzUmVjdXJzaXZlbHkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGV4dHJhY3RTdHlsZXNSZWN1cnNpdmVseShzdHlsZUdyb3VwKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3RGb250cyhmb250c0RhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBmb250cyB3aXRoIGVuaGFuY2VkIG1hcHBpbmcuLi5cIik7XHJcblxyXG4gICAgY29uc3QgZm9udHMgPSBmb250c0RhdGEuRm9udHMgfHwgZm9udHNEYXRhO1xyXG4gICAgdGhpcy5yZXNvdXJjZXMuZm9udHMgPSB7fTtcclxuICAgIHRoaXMuZm9udE1hcCA9IG5ldyBNYXAoKTsgLy8gR2xvYmFsIGZvbnQgbG9va3VwIG1hcFxyXG5cclxuICAgIGlmIChmb250cy5Gb250RmFtaWx5KSB7XHJcbiAgICAgIGNvbnN0IGZvbnRGYW1pbGllcyA9IEFycmF5LmlzQXJyYXkoZm9udHMuRm9udEZhbWlseSlcclxuICAgICAgICA/IGZvbnRzLkZvbnRGYW1pbHlcclxuICAgICAgICA6IFtmb250cy5Gb250RmFtaWx5XTtcclxuXHJcbiAgICAgIGZvbnRGYW1pbGllcy5mb3JFYWNoKChmYW1pbHkpID0+IHtcclxuICAgICAgICBjb25zdCBmYW1pbHlJbmZvID0ge1xyXG4gICAgICAgICAgc2VsZjogZmFtaWx5W1wiQF9TZWxmXCJdLFxyXG4gICAgICAgICAgbmFtZTogZmFtaWx5W1wiQF9OYW1lXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgICBmb250czogW10sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKGZhbWlseS5Gb250KSB7XHJcbiAgICAgICAgICBjb25zdCBmb250TGlzdCA9IEFycmF5LmlzQXJyYXkoZmFtaWx5LkZvbnQpXHJcbiAgICAgICAgICAgID8gZmFtaWx5LkZvbnRcclxuICAgICAgICAgICAgOiBbZmFtaWx5LkZvbnRdO1xyXG5cclxuICAgICAgICAgIGZvbnRMaXN0LmZvckVhY2goKGZvbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZm9udEluZm8gPSB7XHJcbiAgICAgICAgICAgICAgc2VsZjogZm9udFtcIkBfU2VsZlwiXSxcclxuICAgICAgICAgICAgICBmb250RmFtaWx5OiBmb250W1wiQF9Gb250RmFtaWx5XCJdIHx8IGZhbWlseUluZm8ubmFtZSxcclxuICAgICAgICAgICAgICBuYW1lOiBmb250W1wiQF9OYW1lXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgICAgICAgcG9zdFNjcmlwdE5hbWU6IGZvbnRbXCJAX1Bvc3RTY3JpcHROYW1lXCJdIHx8IFwiXCIsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiBmb250W1wiQF9TdGF0dXNcIl0gfHwgXCJVbmtub3duXCIsXHJcbiAgICAgICAgICAgICAgZm9udFN0eWxlTmFtZTogZm9udFtcIkBfRm9udFN0eWxlTmFtZVwiXSB8fCBcIlJlZ3VsYXJcIixcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZhbWlseUluZm8uZm9udHMucHVzaChmb250SW5mbyk7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgbXVsdGlwbGUgbG9va3VwIGVudHJpZXMgZm9yIHRoaXMgZm9udFxyXG4gICAgICAgICAgICB0aGlzLmZvbnRNYXAuc2V0KGZvbnRbXCJAX1NlbGZcIl0sIGZhbWlseUluZm8ubmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udE1hcC5zZXQoZm9udFtcIkBfUG9zdFNjcmlwdE5hbWVcIl0sIGZhbWlseUluZm8ubmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udE1hcC5zZXQoZm9udFtcIkBfTmFtZVwiXSwgZmFtaWx5SW5mby5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5mb250TWFwLnNldChmb250W1wiQF9Gb250RmFtaWx5XCJdLCBmYW1pbHlJbmZvLm5hbWUpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYEZvbnQgbWFwcGluZzogJHtmb250W1wiQF9TZWxmXCJdfSAtPiAke2ZhbWlseUluZm8ubmFtZX1gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzLmZvbnRzW2ZhbWlseVtcIkBfU2VsZlwiXV0gPSBmYW1pbHlJbmZvO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYOKchSBGb250cyBleHRyYWN0ZWQ6ICR7T2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuZm9udHMpLmxlbmd0aH0gZmFtaWxpZXNgXHJcbiAgICApO1xyXG4gICAgY29uc29sZS5sb2coYEZvbnQgbWFwIGVudHJpZXM6ICR7dGhpcy5mb250TWFwLnNpemV9YCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHRyYWN0R3JhcGhpY3MoZ3JhcGhpY3NEYXRhKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3RpbmcgZ3JhcGhpY3MgYW5kIGNvbG9ycy4uLlwiKTtcclxuXHJcbiAgICBjb25zdCBncmFwaGljcyA9IGdyYXBoaWNzRGF0YS5HcmFwaGljIHx8IGdyYXBoaWNzRGF0YTtcclxuICAgIHRoaXMucmVzb3VyY2VzLmNvbG9ycyA9IHt9O1xyXG4gICAgdGhpcy5yZXNvdXJjZXMuZ3JhZGllbnRzID0ge307XHJcblxyXG4gICAgLy8gRXh0cmFjdCBDb2xvcnNcclxuICAgIGlmIChncmFwaGljcy5Db2xvcikge1xyXG4gICAgICBjb25zdCBjb2xvcnMgPSBBcnJheS5pc0FycmF5KGdyYXBoaWNzLkNvbG9yKVxyXG4gICAgICAgID8gZ3JhcGhpY3MuQ29sb3JcclxuICAgICAgICA6IFtncmFwaGljcy5Db2xvcl07XHJcblxyXG4gICAgICBjb2xvcnMuZm9yRWFjaCgoY29sb3IpID0+IHtcclxuICAgICAgICAvLyBFeHRyYWN0IGluZGl2aWR1YWwgY2hhbm5lbCB2YWx1ZXMgZnJvbSBhdHRyaWJ1dGVzIChpZiBwcmVzZW50KVxyXG4gICAgICAgIGNvbnN0IGN5YW4gPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9DeWFuXCJdKSB8fCAwO1xyXG4gICAgICAgIGNvbnN0IG1hZ2VudGEgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9NYWdlbnRhXCJdKSB8fCAwO1xyXG4gICAgICAgIGNvbnN0IHllbGxvdyA9IHBhcnNlRmxvYXQoY29sb3JbXCJAX1llbGxvd1wiXSkgfHwgMDtcclxuICAgICAgICBjb25zdCBibGFjayA9IHBhcnNlRmxvYXQoY29sb3JbXCJAX0JsYWNrXCJdKSB8fCAwO1xyXG4gICAgICAgIGNvbnN0IHJlZCA9IHBhcnNlRmxvYXQoY29sb3JbXCJAX1JlZFwiXSkgfHwgMDtcclxuICAgICAgICBjb25zdCBncmVlbiA9IHBhcnNlRmxvYXQoY29sb3JbXCJAX0dyZWVuXCJdKSB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGJsdWUgPSBwYXJzZUZsb2F0KGNvbG9yW1wiQF9CbHVlXCJdKSB8fCAwO1xyXG5cclxuICAgICAgICAvLyBHZXQgY29sb3Igc3BhY2UgYW5kIG1vZGVsIGluZm9ybWF0aW9uXHJcbiAgICAgICAgY29uc3QgY29sb3JTcGFjZSA9IGNvbG9yW1wiQF9TcGFjZVwiXSB8fCBcIkNNWUtcIjtcclxuICAgICAgICBjb25zdCBjb2xvck1vZGVsID0gY29sb3JbXCJAX01vZGVsXCJdIHx8IFwiUHJvY2Vzc1wiO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yVmFsdWUgPSBjb2xvcltcIkBfQ29sb3JWYWx1ZVwiXTtcclxuICAgICAgICBjb25zdCBjb2xvck5hbWUgPSBjb2xvcltcIkBfTmFtZVwiXSB8fCBcIlwiO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yU2VsZiA9IGNvbG9yW1wiQF9TZWxmXCJdIHx8IFwiXCI7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46oIFByb2Nlc3NpbmcgY29sb3I6ICR7Y29sb3JTZWxmfWApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgIE5hbWU6IFwiJHtjb2xvck5hbWV9XCIsIFNwYWNlOiAke2NvbG9yU3BhY2V9LCBNb2RlbDogJHtjb2xvck1vZGVsfWBcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBDb2xvclZhbHVlOiBcIiR7Y29sb3JWYWx1ZX1cImApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgIEluZGl2aWR1YWwgY2hhbm5lbHMgLSBDOiR7Y3lhbn0gTToke21hZ2VudGF9IFk6JHt5ZWxsb3d9IEs6JHtibGFja30gUjoke3JlZH0gRzoke2dyZWVufSBCOiR7Ymx1ZX1gXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQ1JJVElDQUw6IERldGVybWluZSBpZiB0aGlzIGlzIGEgY3VzdG9tIGNvbG9yIHRoYXQgc2hvdWxkIHVzZSBSR0IgQ29sb3JWYWx1ZVxyXG4gICAgICAgIGNvbnN0IGlzQ3VzdG9tQ29sb3IgPSB0aGlzLmlzQ3VzdG9tQ29sb3JOYW1lKGNvbG9yU2VsZiwgY29sb3JOYW1lKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgICAg8J+UjSBJcyBjdXN0b20gY29sb3I6ICR7aXNDdXN0b21Db2xvcn1gKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjb2xvciBkYXRhIHN0cnVjdHVyZVxyXG4gICAgICAgIGxldCBmaW5hbENvbG9yRGF0YSA9IHtcclxuICAgICAgICAgIHNlbGY6IGNvbG9yU2VsZixcclxuICAgICAgICAgIG5hbWU6IGNvbG9yTmFtZSxcclxuICAgICAgICAgIG1vZGVsOiBjb2xvck1vZGVsLFxyXG4gICAgICAgICAgc3BhY2U6IGNvbG9yU3BhY2UsXHJcbiAgICAgICAgICBjeWFuOiAwLFxyXG4gICAgICAgICAgbWFnZW50YTogMCxcclxuICAgICAgICAgIHllbGxvdzogMCxcclxuICAgICAgICAgIGJsYWNrOiAwLFxyXG4gICAgICAgICAgcmVkOiAwLFxyXG4gICAgICAgICAgZ3JlZW46IDAsXHJcbiAgICAgICAgICBibHVlOiAwLFxyXG4gICAgICAgICAgLy8gQWRkaXRpb25hbCBmaWVsZHMgdG8gdHJhY2sgY29sb3Igc291cmNlXHJcbiAgICAgICAgICBjb2xvclNvdXJjZTogXCJ1bmtub3duXCIsXHJcbiAgICAgICAgICBoYXNEaXJlY3RSR0I6IGZhbHNlLFxyXG4gICAgICAgICAgaGFzRGlyZWN0Q01ZSzogZmFsc2UsXHJcbiAgICAgICAgICBoYXNDb2xvclZhbHVlOiAhIWNvbG9yVmFsdWUsXHJcbiAgICAgICAgICBpc0N1c3RvbUNvbG9yOiBpc0N1c3RvbUNvbG9yLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNUUkFURUdZIDE6IENoZWNrIGZvciBkaXJlY3QgUkdCIHZhbHVlcyBpbiBpbmRpdmlkdWFsIGF0dHJpYnV0ZXNcclxuICAgICAgICBpZiAocmVkID4gMCB8fCBncmVlbiA+IDAgfHwgYmx1ZSA+IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgICAg4pyFIFVzaW5nIGRpcmVjdCBSR0IgZnJvbSBpbmRpdmlkdWFsIGNoYW5uZWxzOiBSOiR7cmVkfSBHOiR7Z3JlZW59IEI6JHtibHVlfWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5yZWQgPSByZWQ7XHJcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5ncmVlbiA9IGdyZWVuO1xyXG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuYmx1ZSA9IGJsdWU7XHJcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiZGlyZWN0X3JnYl9jaGFubmVsc1wiO1xyXG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuaGFzRGlyZWN0UkdCID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU1RSQVRFR1kgMjogQ2hlY2sgZm9yIGRpcmVjdCBDTVlLIHZhbHVlcyBpbiBpbmRpdmlkdWFsIGF0dHJpYnV0ZXNcclxuICAgICAgICBlbHNlIGlmIChjeWFuID4gMCB8fCBtYWdlbnRhID4gMCB8fCB5ZWxsb3cgPiAwIHx8IGJsYWNrID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGAgICDinIUgVXNpbmcgZGlyZWN0IENNWUsgZnJvbSBpbmRpdmlkdWFsIGNoYW5uZWxzOiBDOiR7Y3lhbn0gTToke21hZ2VudGF9IFk6JHt5ZWxsb3d9IEs6JHtibGFja31gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgZmluYWxDb2xvckRhdGEuY3lhbiA9IGN5YW47XHJcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5tYWdlbnRhID0gbWFnZW50YTtcclxuICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLnllbGxvdyA9IHllbGxvdztcclxuICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmJsYWNrID0gYmxhY2s7XHJcbiAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiZGlyZWN0X2NteWtfY2hhbm5lbHNcIjtcclxuICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmhhc0RpcmVjdENNWUsgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTVFJBVEVHWSAzOiBQYXJzZSBDb2xvclZhbHVlIGF0dHJpYnV0ZSAoT05MWSBmb3IgY3VzdG9tIGNvbG9ycylcclxuICAgICAgICBlbHNlIGlmIChjb2xvclZhbHVlICYmIGlzQ3VzdG9tQ29sb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgICAg8J+UjSBQYXJzaW5nIENvbG9yVmFsdWUgZm9yIENVU1RPTSBjb2xvcjogXCIke2NvbG9yVmFsdWV9XCJgXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIFNwbGl0IENvbG9yVmFsdWUgaW50byBudW1lcmljIHBhcnRzXHJcbiAgICAgICAgICBjb25zdCB2YWx1ZVBhcnRzID0gY29sb3JWYWx1ZVxyXG4gICAgICAgICAgICAuc3BsaXQoL1xccysvKVxyXG4gICAgICAgICAgICAubWFwKE51bWJlcilcclxuICAgICAgICAgICAgLmZpbHRlcigodikgPT4gIWlzTmFOKHYpKTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsdWVQYXJ0cy5sZW5ndGggPT09IDMgJiYgY29sb3JTcGFjZSA9PT0gXCJSR0JcIikge1xyXG4gICAgICAgICAgICAvLyBSR0IgQ29sb3JWYWx1ZTogXCIyNTUgMTM3IDBcIiAtPiBSOjI1NSBHOjEzNyBCOjBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYCAgIOKchSBVc2luZyBSR0IgQ29sb3JWYWx1ZSBmb3IgY3VzdG9tIGNvbG9yOiBSOiR7dmFsdWVQYXJ0c1swXX0gRzoke3ZhbHVlUGFydHNbMV19IEI6JHt2YWx1ZVBhcnRzWzJdfWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEucmVkID0gdmFsdWVQYXJ0c1swXTtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuZ3JlZW4gPSB2YWx1ZVBhcnRzWzFdO1xyXG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5ibHVlID0gdmFsdWVQYXJ0c1syXTtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImNvbG9ydmFsdWVfcmdiX2N1c3RvbVwiO1xyXG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RSR0IgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVBhcnRzLmxlbmd0aCA9PT0gNCAmJiBjb2xvclNwYWNlID09PSBcIkNNWUtcIikge1xyXG4gICAgICAgICAgICAvLyBDTVlLIENvbG9yVmFsdWU6IFwiMCAwIDAgMTAwXCIgLT4gQzowIE06MCBZOjAgSzoxMDBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYCAgIOKchSBVc2luZyBDTVlLIENvbG9yVmFsdWUgZm9yIGN1c3RvbSBjb2xvcjogQzoke3ZhbHVlUGFydHNbMF19IE06JHt2YWx1ZVBhcnRzWzFdfSBZOiR7dmFsdWVQYXJ0c1syXX0gSzoke3ZhbHVlUGFydHNbM119YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jeWFuID0gdmFsdWVQYXJ0c1swXTtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEubWFnZW50YSA9IHZhbHVlUGFydHNbMV07XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLnllbGxvdyA9IHZhbHVlUGFydHNbMl07XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmJsYWNrID0gdmFsdWVQYXJ0c1szXTtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImNvbG9ydmFsdWVfY215a19jdXN0b21cIjtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuaGFzRGlyZWN0Q01ZSyA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlUGFydHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgIC8vIEFzc3VtZSBSR0IgaWYgc3BhY2UgaXMgdW5rbm93biBidXQgd2UgaGF2ZSAzIHZhbHVlcyAoZm9yIGN1c3RvbSBjb2xvcnMpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgIGAgICDimqDvuI8gIEFzc3VtaW5nIFJHQiBmb3IgMy12YWx1ZSBDb2xvclZhbHVlIG9uIGN1c3RvbSBjb2xvcjogUjoke3ZhbHVlUGFydHNbMF19IEc6JHt2YWx1ZVBhcnRzWzFdfSBCOiR7dmFsdWVQYXJ0c1syXX1gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLnJlZCA9IHZhbHVlUGFydHNbMF07XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmdyZWVuID0gdmFsdWVQYXJ0c1sxXTtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuYmx1ZSA9IHZhbHVlUGFydHNbMl07XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLnNwYWNlID0gXCJSR0JcIjtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImNvbG9ydmFsdWVfYXNzdW1lZF9yZ2JfY3VzdG9tXCI7XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmhhc0RpcmVjdFJHQiA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICBgICAg4pqg77iPICBDb3VsZCBub3QgcGFyc2UgQ29sb3JWYWx1ZSBmb3IgY3VzdG9tIGNvbG9yOiBcIiR7Y29sb3JWYWx1ZX1cIiAoJHt2YWx1ZVBhcnRzLmxlbmd0aH0gcGFydHMpYFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jb2xvclNvdXJjZSA9IFwiY29sb3J2YWx1ZV91bnBhcnNlYWJsZV9jdXN0b21cIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU1RSQVRFR1kgNDogSGFuZGxlIENvbG9yVmFsdWUgZm9yIHN0YW5kYXJkIGNvbG9ycyAodXNlIGZvciBDTVlLIG9ubHksIHNraXAgUkdCKVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbG9yVmFsdWUgJiYgIWlzQ3VzdG9tQ29sb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgICAg8J+UjSBQYXJzaW5nIENvbG9yVmFsdWUgZm9yIFNUQU5EQVJEIGNvbG9yOiBcIiR7Y29sb3JWYWx1ZX1cImBcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gU3BsaXQgQ29sb3JWYWx1ZSBpbnRvIG51bWVyaWMgcGFydHNcclxuICAgICAgICAgIGNvbnN0IHZhbHVlUGFydHMgPSBjb2xvclZhbHVlXHJcbiAgICAgICAgICAgIC5zcGxpdCgvXFxzKy8pXHJcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxyXG4gICAgICAgICAgICAuZmlsdGVyKCh2KSA9PiAhaXNOYU4odikpO1xyXG5cclxuICAgICAgICAgIGlmICh2YWx1ZVBhcnRzLmxlbmd0aCA9PT0gNCAmJiBjb2xvclNwYWNlID09PSBcIkNNWUtcIikge1xyXG4gICAgICAgICAgICAvLyBPbmx5IHVzZSBDTVlLIENvbG9yVmFsdWUgZm9yIHN0YW5kYXJkIGNvbG9ycywgaWdub3JlIFJHQiBDb2xvclZhbHVlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgIGAgICDinIUgVXNpbmcgQ01ZSyBDb2xvclZhbHVlIGZvciBzdGFuZGFyZCBjb2xvcjogQzoke3ZhbHVlUGFydHNbMF19IE06JHt2YWx1ZVBhcnRzWzFdfSBZOiR7dmFsdWVQYXJ0c1syXX0gSzoke3ZhbHVlUGFydHNbM119YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5jeWFuID0gdmFsdWVQYXJ0c1swXTtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEubWFnZW50YSA9IHZhbHVlUGFydHNbMV07XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLnllbGxvdyA9IHZhbHVlUGFydHNbMl07XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmJsYWNrID0gdmFsdWVQYXJ0c1szXTtcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuY29sb3JTb3VyY2UgPSBcImNvbG9ydmFsdWVfY215a19zdGFuZGFyZFwiO1xyXG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RDTVlLID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVQYXJ0cy5sZW5ndGggPT09IDMgJiYgY29sb3JTcGFjZSA9PT0gXCJSR0JcIikge1xyXG4gICAgICAgICAgICAvLyBTa2lwIFJHQiBDb2xvclZhbHVlIGZvciBzdGFuZGFyZCBjb2xvcnMgdG8gYXZvaWQgXCIwIDAgMFwiIGlzc3Vlc1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICBgICAg4pqg77iPICBTa2lwcGluZyBSR0IgQ29sb3JWYWx1ZSBmb3Igc3RhbmRhcmQgY29sb3IgKGF2b2lkaW5nIGJsYWNrIGZhbGxiYWNrKTogXCIke2NvbG9yVmFsdWV9XCJgXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlID0gXCJjb2xvcnZhbHVlX3JnYl9za2lwcGVkX3N0YW5kYXJkXCI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICBgICAg4pqg77iPICBDb3VsZCBub3QgcGFyc2UgQ29sb3JWYWx1ZSBmb3Igc3RhbmRhcmQgY29sb3I6IFwiJHtjb2xvclZhbHVlfVwiICgke3ZhbHVlUGFydHMubGVuZ3RofSBwYXJ0cylgXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlID0gXCJjb2xvcnZhbHVlX3VucGFyc2VhYmxlX3N0YW5kYXJkXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTVFJBVEVHWSA1OiBIYW5kbGUgc3BlY2lhbCBjb2xvciB0eXBlcyAoZmFsbGJhY2spXHJcbiAgICAgICAgaWYgKGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlID09PSBcInVua25vd25cIikge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIPCflIQgVXNpbmcgZmFsbGJhY2sgaGFuZGxpbmcgZm9yIGNvbG9yOiAke2NvbG9yU2VsZn1gKTtcclxuICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlID0gXCJmYWxsYmFja1wiO1xyXG5cclxuICAgICAgICAgIC8vIEZvciBzdGFuZGFyZCBjb2xvcnMgd2l0aCBubyBkYXRhLCBkb24ndCBzdG9yZSB0aGVtIGF0IGFsbFxyXG4gICAgICAgICAgLy8gVGhpcyB3aWxsIGNhdXNlIHRoZW0gdG8gZmFsbCB0aHJvdWdoIHRvIHRoZSBncmF5IGZhbGxiYWNrIGluIENvbG9yVXRpbHNcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgIWlzQ3VzdG9tQ29sb3IgJiZcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuY3lhbiA9PT0gMCAmJlxyXG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5tYWdlbnRhID09PSAwICYmXHJcbiAgICAgICAgICAgIGZpbmFsQ29sb3JEYXRhLnllbGxvdyA9PT0gMCAmJlxyXG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5ibGFjayA9PT0gMCAmJlxyXG4gICAgICAgICAgICBmaW5hbENvbG9yRGF0YS5yZWQgPT09IDAgJiZcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuZ3JlZW4gPT09IDAgJiZcclxuICAgICAgICAgICAgZmluYWxDb2xvckRhdGEuYmx1ZSA9PT0gMFxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgIGAgICDimqDvuI8gIFN0YW5kYXJkIGNvbG9yIHdpdGggbm8gdmFsaWQgZGF0YSAtIHNraXBwaW5nIHN0b3JhZ2UgdG8gYWxsb3cgZ3JheSBmYWxsYmFja2BcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBTa2lwIHN0b3JpbmcgdGhpcyBjb2xvciBjb21wbGV0ZWx5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9yZSB0aGUgY29sb3IgZGF0YVxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzLmNvbG9yc1tjb2xvclNlbGZdID0gZmluYWxDb2xvckRhdGE7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICDwn5K+IFN0b3JlZCBjb2xvciBkYXRhOmAsIHtcclxuICAgICAgICAgIHNlbGY6IGZpbmFsQ29sb3JEYXRhLnNlbGYsXHJcbiAgICAgICAgICBzb3VyY2U6IGZpbmFsQ29sb3JEYXRhLmNvbG9yU291cmNlLFxyXG4gICAgICAgICAgaGFzUkdCOiBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RSR0IsXHJcbiAgICAgICAgICBoYXNDTVlLOiBmaW5hbENvbG9yRGF0YS5oYXNEaXJlY3RDTVlLLFxyXG4gICAgICAgICAgaXNDdXN0b206IGZpbmFsQ29sb3JEYXRhLmlzQ3VzdG9tQ29sb3IsXHJcbiAgICAgICAgICByZ2I6IGAke2ZpbmFsQ29sb3JEYXRhLnJlZH0sJHtmaW5hbENvbG9yRGF0YS5ncmVlbn0sJHtmaW5hbENvbG9yRGF0YS5ibHVlfWAsXHJcbiAgICAgICAgICBjbXlrOiBgJHtmaW5hbENvbG9yRGF0YS5jeWFufSwke2ZpbmFsQ29sb3JEYXRhLm1hZ2VudGF9LCR7ZmluYWxDb2xvckRhdGEueWVsbG93fSwke2ZpbmFsQ29sb3JEYXRhLmJsYWNrfWAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dHJhY3QgR3JhZGllbnRzXHJcbiAgICBpZiAoZ3JhcGhpY3MuR3JhZGllbnQpIHtcclxuICAgICAgY29uc3QgZ3JhZGllbnRzID0gQXJyYXkuaXNBcnJheShncmFwaGljcy5HcmFkaWVudClcclxuICAgICAgICA/IGdyYXBoaWNzLkdyYWRpZW50XHJcbiAgICAgICAgOiBbZ3JhcGhpY3MuR3JhZGllbnRdO1xyXG5cclxuICAgICAgZ3JhZGllbnRzLmZvckVhY2goKGdyYWRpZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZ3JhZGllbnRzW2dyYWRpZW50W1wiQF9TZWxmXCJdXSA9IHtcclxuICAgICAgICAgIHNlbGY6IGdyYWRpZW50W1wiQF9TZWxmXCJdLFxyXG4gICAgICAgICAgbmFtZTogZ3JhZGllbnRbXCJAX05hbWVcIl0gfHwgXCJcIixcclxuICAgICAgICAgIHR5cGU6IGdyYWRpZW50W1wiQF9UeXBlXCJdIHx8IFwiTGluZWFyXCIsXHJcbiAgICAgICAgICBncmFkaWVudFN0b3BzOiB0aGlzLmV4dHJhY3RHcmFkaWVudFN0b3BzKGdyYWRpZW50KSxcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYOKchSBHcmFwaGljcyBleHRyYWN0aW9uIGNvbXBsZXRlLiBDb2xvcnM6ICR7XHJcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuY29sb3JzKS5sZW5ndGhcclxuICAgICAgfSwgR3JhZGllbnRzOiAke09iamVjdC5rZXlzKHRoaXMucmVzb3VyY2VzLmdyYWRpZW50cykubGVuZ3RofWBcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBORVcgTUVUSE9EOiBEZXRlcm1pbmUgaWYgYSBjb2xvciBpcyBjdXN0b20gYW5kIHNob3VsZCB1c2UgUkdCIENvbG9yVmFsdWVcclxuICBpc0N1c3RvbUNvbG9yTmFtZShjb2xvclNlbGYsIGNvbG9yTmFtZSkge1xyXG4gICAgLy8gU3RhbmRhcmQvcHJlZGVmaW5lZCBJbkRlc2lnbiBjb2xvcnMgdGhhdCBzaG91bGQgTk9UIHVzZSBSR0IgQ29sb3JWYWx1ZVxyXG4gICAgY29uc3Qgc3RhbmRhcmRDb2xvcnMgPSBbXHJcbiAgICAgIFwiQ29sb3IvQmxhY2tcIixcclxuICAgICAgXCJDb2xvci9XaGl0ZVwiLFxyXG4gICAgICBcIkNvbG9yL1JlZFwiLFxyXG4gICAgICBcIkNvbG9yL0dyZWVuXCIsXHJcbiAgICAgIFwiQ29sb3IvQmx1ZVwiLFxyXG4gICAgICBcIkNvbG9yL0N5YW5cIixcclxuICAgICAgXCJDb2xvci9NYWdlbnRhXCIsXHJcbiAgICAgIFwiQ29sb3IvWWVsbG93XCIsXHJcbiAgICAgIFwiQ29sb3IvUGFwZXJcIixcclxuICAgICAgXCJDb2xvci9SZWdpc3RyYXRpb25cIixcclxuICAgICAgXCJDb2xvci9Ob25lXCIsXHJcbiAgICBdO1xyXG5cclxuICAgIC8vIFN0YW5kYXJkIGNvbG9yIHBhdHRlcm5zIChDTVlLIHZhbHVlcyBpbiB0aGUgbmFtZSlcclxuICAgIGNvbnN0IGNteWtQYXR0ZXJuID0gL0NvbG9yXFwvQz1bXFxkLl0rXFxzKk09W1xcZC5dK1xccypZPVtcXGQuXStcXHMqSz1bXFxkLl0rLztcclxuICAgIGNvbnN0IHJnYlBhdHRlcm4gPSAvQ29sb3JcXC9SPVtcXGQuXStcXHMqRz1bXFxkLl0rXFxzKkI9W1xcZC5dKy87XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIHN0YW5kYXJkIGNvbG9yXHJcbiAgICBpZiAoc3RhbmRhcmRDb2xvcnMuaW5jbHVkZXMoY29sb3JTZWxmKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgaXQgZm9sbG93cyBDTVlLIG9yIFJHQiBwYXR0ZXJuICh0aGVzZSBhcmUgYXV0by1nZW5lcmF0ZWQsIG5vdCBjdXN0b20pXHJcbiAgICBpZiAoY215a1BhdHRlcm4udGVzdChjb2xvclNlbGYpIHx8IHJnYlBhdHRlcm4udGVzdChjb2xvclNlbGYpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBmb3IgaGlkZGVuL3N5c3RlbSBjb2xvcnNcclxuICAgIGlmIChjb2xvclNlbGYuaW5jbHVkZXMoXCIvdVwiKSAmJiAvXFwvdVxcZCskLy50ZXN0KGNvbG9yU2VsZikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGNvbG9yIG5hbWUgaXMgZ2VuZXJpYyBvciBlbXB0eSwgaXQncyBsaWtlbHkgbm90IGN1c3RvbVxyXG4gICAgaWYgKCFjb2xvck5hbWUgfHwgY29sb3JOYW1lID09PSBcIlwiIHx8IGNvbG9yTmFtZSA9PT0gXCIkSUQvXCIpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEN1c3RvbSBjb2xvcnMgdHlwaWNhbGx5IGhhdmUgbWVhbmluZ2Z1bCBuYW1lcyBsaWtlIFwiTWFpblwiLCBcIkJyYW5kXCIsIFwiQWNjZW50XCIsIGV0Yy5cclxuICAgIGNvbnN0IGN1c3RvbUNvbG9yUGF0dGVybnMgPSBbXHJcbiAgICAgIC9tYWluL2ksXHJcbiAgICAgIC9icmFuZC9pLFxyXG4gICAgICAvYWNjZW50L2ksXHJcbiAgICAgIC9wcmltYXJ5L2ksXHJcbiAgICAgIC9zZWNvbmRhcnkvaSxcclxuICAgICAgL3RoZW1lL2ksXHJcbiAgICAgIC9jdXN0b20vaSxcclxuICAgIF07XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG5hbWUgbWF0Y2hlcyBjdXN0b20gcGF0dGVybnNcclxuICAgIGNvbnN0IGhhc0N1c3RvbVBhdHRlcm4gPSBjdXN0b21Db2xvclBhdHRlcm5zLnNvbWUoXHJcbiAgICAgIChwYXR0ZXJuKSA9PiBwYXR0ZXJuLnRlc3QoY29sb3JOYW1lKSB8fCBwYXR0ZXJuLnRlc3QoY29sb3JTZWxmKVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoaGFzQ3VzdG9tUGF0dGVybikge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBpdCdzIG5vdCBhIHN0YW5kYXJkIGNvbG9yIGFuZCBoYXMgYSBtZWFuaW5nZnVsIG5hbWUsIGNvbnNpZGVyIGl0IGN1c3RvbVxyXG4gICAgcmV0dXJuIGNvbG9yTmFtZS5sZW5ndGggPiAyICYmICFjb2xvck5hbWUuaW5jbHVkZXMoXCIkSUQvXCIpO1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdEdyYWRpZW50U3RvcHMoZ3JhZGllbnQpIHtcclxuICAgIGNvbnN0IHN0b3BzID0gW107XHJcblxyXG4gICAgaWYgKGdyYWRpZW50LkdyYWRpZW50U3RvcCkge1xyXG4gICAgICBjb25zdCBzdG9wTGlzdCA9IEFycmF5LmlzQXJyYXkoZ3JhZGllbnQuR3JhZGllbnRTdG9wKVxyXG4gICAgICAgID8gZ3JhZGllbnQuR3JhZGllbnRTdG9wXHJcbiAgICAgICAgOiBbZ3JhZGllbnQuR3JhZGllbnRTdG9wXTtcclxuXHJcbiAgICAgIHN0b3BMaXN0LmZvckVhY2goKHN0b3ApID0+IHtcclxuICAgICAgICBzdG9wcy5wdXNoKHtcclxuICAgICAgICAgIHNlbGY6IHN0b3BbXCJAX1NlbGZcIl0sXHJcbiAgICAgICAgICBzdG9wQ29sb3I6IHN0b3BbXCJAX1N0b3BDb2xvclwiXSB8fCBcIlwiLFxyXG4gICAgICAgICAgbG9jYXRpb246IHBhcnNlRmxvYXQoc3RvcFtcIkBfTG9jYXRpb25cIl0pIHx8IDAsXHJcbiAgICAgICAgICBtaWRwb2ludDogcGFyc2VGbG9hdChzdG9wW1wiQF9NaWRwb2ludFwiXSkgfHwgNTAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdG9wcztcclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3RQcmVmZXJlbmNlcyhwcmVmZXJlbmNlc0RhdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBkb2N1bWVudCBwcmVmZXJlbmNlcy4uLlwiKTtcclxuXHJcbiAgICBjb25zdCBwcmVmcyA9IHByZWZlcmVuY2VzRGF0YS5QcmVmZXJlbmNlcyB8fCBwcmVmZXJlbmNlc0RhdGE7XHJcblxyXG4gICAgLy8gRXh0cmFjdCB2YXJpb3VzIGRvY3VtZW50IHByZWZlcmVuY2VzXHJcbiAgICB0aGlzLmRvY3VtZW50SW5mbyA9IHtcclxuICAgICAgcHJlZmVyZW5jZXM6IHtcclxuICAgICAgICBkb2N1bWVudFByZWZlcmVuY2VzOiB0aGlzLmV4dHJhY3REb2N1bWVudFByZWZzKFxyXG4gICAgICAgICAgcHJlZnMuRG9jdW1lbnRQcmVmZXJlbmNlXHJcbiAgICAgICAgKSxcclxuICAgICAgICB2aWV3UHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdFZpZXdQcmVmcyhwcmVmcy5WaWV3UHJlZmVyZW5jZSksXHJcbiAgICAgICAgZ3VpZGVQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0R3VpZGVQcmVmcyhwcmVmcy5HdWlkZVByZWZlcmVuY2UpLFxyXG4gICAgICAgIGdyaWRQcmVmZXJlbmNlczogdGhpcy5leHRyYWN0R3JpZFByZWZzKHByZWZzLkdyaWRQcmVmZXJlbmNlKSxcclxuICAgICAgICBtYXJnaW5QcmVmZXJlbmNlczogdGhpcy5leHRyYWN0TWFyZ2luUHJlZnMocHJlZnMuTWFyZ2luUHJlZmVyZW5jZSksXHJcbiAgICAgICAgY29sdW1uUHJlZmVyZW5jZXM6IHRoaXMuZXh0cmFjdENvbHVtblByZWZzKHByZWZzLkNvbHVtblByZWZlcmVuY2UpLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3REb2N1bWVudFByZWZzKGRvY1ByZWYpIHtcclxuICAgIGlmICghZG9jUHJlZikgcmV0dXJuIHt9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHBhZ2VXaWR0aDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9QYWdlV2lkdGhcIl0pIHx8IDAsXHJcbiAgICAgIHBhZ2VIZWlnaHQ6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfUGFnZUhlaWdodFwiXSkgfHwgMCxcclxuICAgICAgbGVmdDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9MZWZ0XCJdKSB8fCAwLFxyXG4gICAgICB0b3A6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfVG9wXCJdKSB8fCAwLFxyXG4gICAgICByaWdodDogcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9SaWdodFwiXSkgfHwgMCxcclxuICAgICAgYm90dG9tOiBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0JvdHRvbVwiXSkgfHwgMCxcclxuICAgICAgY29sdW1uQ291bnQ6IHBhcnNlSW50KGRvY1ByZWZbXCJAX0NvbHVtbkNvdW50XCJdKSB8fCAxLFxyXG4gICAgICBjb2x1bW5HdXR0ZXI6IHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfQ29sdW1uR3V0dGVyXCJdKSB8fCAwLFxyXG4gICAgICBmYWNpbmdQYWdlczogZG9jUHJlZltcIkBfRmFjaW5nUGFnZXNcIl0gPT09IHRydWUsXHJcbiAgICAgIGFsbG93UGFnZVNodWZmbGU6IGRvY1ByZWZbXCJAX0FsbG93UGFnZVNodWZmbGVcIl0gIT09IGZhbHNlLFxyXG4gICAgICBzbHVnQmxlZWRUeXBlOiBkb2NQcmVmW1wiQF9TbHVnQmxlZWRUeXBlXCJdIHx8IFwiTm9uZVwiLFxyXG4gICAgICBkb2N1bWVudEJsZWVkVG9wT2Zmc2V0OlxyXG4gICAgICAgIHBhcnNlRmxvYXQoZG9jUHJlZltcIkBfRG9jdW1lbnRCbGVlZFRvcE9mZnNldFwiXSkgfHwgMCxcclxuICAgICAgZG9jdW1lbnRCbGVlZEJvdHRvbU9mZnNldDpcclxuICAgICAgICBwYXJzZUZsb2F0KGRvY1ByZWZbXCJAX0RvY3VtZW50QmxlZWRCb3R0b21PZmZzZXRcIl0pIHx8IDAsXHJcbiAgICAgIGRvY3VtZW50QmxlZWRJbnNpZGVPckxlZnRPZmZzZXQ6XHJcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0XCJdKSB8fCAwLFxyXG4gICAgICBkb2N1bWVudEJsZWVkT3V0c2lkZU9yUmlnaHRPZmZzZXQ6XHJcbiAgICAgICAgcGFyc2VGbG9hdChkb2NQcmVmW1wiQF9Eb2N1bWVudEJsZWVkT3V0c2lkZU9yUmlnaHRPZmZzZXRcIl0pIHx8IDAsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFZpZXdQcmVmcyh2aWV3UHJlZikge1xyXG4gICAgaWYgKCF2aWV3UHJlZikgcmV0dXJuIHt9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGhvcml6b250YWxNZWFzdXJlbWVudFVuaXRzOlxyXG4gICAgICAgIHZpZXdQcmVmW1wiQF9Ib3Jpem9udGFsTWVhc3VyZW1lbnRVbml0c1wiXSB8fCBcIlBvaW50c1wiLFxyXG4gICAgICB2ZXJ0aWNhbE1lYXN1cmVtZW50VW5pdHM6XHJcbiAgICAgICAgdmlld1ByZWZbXCJAX1ZlcnRpY2FsTWVhc3VyZW1lbnRVbml0c1wiXSB8fCBcIlBvaW50c1wiLFxyXG4gICAgICBydWxlck9yaWdpbjogdmlld1ByZWZbXCJAX1J1bGVyT3JpZ2luXCJdIHx8IFwiU3ByZWFkT3JpZ2luXCIsXHJcbiAgICAgIHNob3dSdWxlcnM6IHZpZXdQcmVmW1wiQF9TaG93UnVsZXJzXCJdICE9PSBmYWxzZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBleHRyYWN0R3VpZGVQcmVmcyhndWlkZVByZWYpIHtcclxuICAgIGlmICghZ3VpZGVQcmVmKSByZXR1cm4ge307XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcnVsZXJHdWlkZUNvbG9yOiBndWlkZVByZWZbXCJAX1J1bGVyR3VpZGVDb2xvclwiXSB8fCBcIkdyZWVuXCIsXHJcbiAgICAgIGd1aWRlc0luQmFjazogZ3VpZGVQcmVmW1wiQF9HdWlkZXNJbkJhY2tcIl0gPT09IHRydWUsXHJcbiAgICAgIGd1aWRlc0xvY2tlZDogZ3VpZGVQcmVmW1wiQF9HdWlkZXNMb2NrZWRcIl0gPT09IHRydWUsXHJcbiAgICAgIGd1aWRlc1Nob3duOiBndWlkZVByZWZbXCJAX0d1aWRlc1Nob3duXCJdICE9PSBmYWxzZSxcclxuICAgICAgZ3VpZGVzU25hcHRvOiBndWlkZVByZWZbXCJAX0d1aWRlc1NuYXB0b1wiXSAhPT0gZmFsc2UsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdEdyaWRQcmVmcyhncmlkUHJlZikge1xyXG4gICAgaWYgKCFncmlkUHJlZikgcmV0dXJuIHt9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJhc2VsaW5lU3RhcnQ6IHBhcnNlRmxvYXQoZ3JpZFByZWZbXCJAX0Jhc2VsaW5lU3RhcnRcIl0pIHx8IDAsXHJcbiAgICAgIGJhc2VsaW5lRGl2aXNpb246IHBhcnNlRmxvYXQoZ3JpZFByZWZbXCJAX0Jhc2VsaW5lRGl2aXNpb25cIl0pIHx8IDEyLFxyXG4gICAgICBiYXNlbGluZVNob3duOiBncmlkUHJlZltcIkBfQmFzZWxpbmVTaG93blwiXSA9PT0gdHJ1ZSxcclxuICAgICAgYmFzZWxpbmVTbmFwdG86IGdyaWRQcmVmW1wiQF9CYXNlbGluZVNuYXB0b1wiXSA9PT0gdHJ1ZSxcclxuICAgICAgZG9jdW1lbnRHcmlkU2hvd246IGdyaWRQcmVmW1wiQF9Eb2N1bWVudEdyaWRTaG93blwiXSA9PT0gdHJ1ZSxcclxuICAgICAgZG9jdW1lbnRHcmlkU25hcHRvOiBncmlkUHJlZltcIkBfRG9jdW1lbnRHcmlkU25hcHRvXCJdID09PSB0cnVlLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RNYXJnaW5QcmVmcyhtYXJnaW5QcmVmKSB7XHJcbiAgICBpZiAoIW1hcmdpblByZWYpIHJldHVybiB7fTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfVG9wXCJdKSB8fCAwLFxyXG4gICAgICBib3R0b206IHBhcnNlRmxvYXQobWFyZ2luUHJlZltcIkBfQm90dG9tXCJdKSB8fCAwLFxyXG4gICAgICBsZWZ0OiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX0xlZnRcIl0pIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBwYXJzZUZsb2F0KG1hcmdpblByZWZbXCJAX1JpZ2h0XCJdKSB8fCAwLFxyXG4gICAgICBjb2x1bW5Db3VudDogcGFyc2VJbnQobWFyZ2luUHJlZltcIkBfQ29sdW1uQ291bnRcIl0pIHx8IDEsXHJcbiAgICAgIGNvbHVtbkd1dHRlcjogcGFyc2VGbG9hdChtYXJnaW5QcmVmW1wiQF9Db2x1bW5HdXR0ZXJcIl0pIHx8IDAsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdENvbHVtblByZWZzKGNvbHVtblByZWYpIHtcclxuICAgIGlmICghY29sdW1uUHJlZikgcmV0dXJuIHt9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHRDb2x1bW5Db3VudDogcGFyc2VJbnQoY29sdW1uUHJlZltcIkBfVGV4dENvbHVtbkNvdW50XCJdKSB8fCAxLFxyXG4gICAgICB0ZXh0Q29sdW1uR3V0dGVyOiBwYXJzZUZsb2F0KGNvbHVtblByZWZbXCJAX1RleHRDb2x1bW5HdXR0ZXJcIl0pIHx8IDAsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmVzb2x2ZVN0eWxlRm9ybWF0dGluZyhmb3JtYXR0aW5nKSB7XHJcbiAgICBjb25zdCByZXNvbHZlZCA9IHsgLi4uZm9ybWF0dGluZyB9O1xyXG5cclxuICAgIC8vIERFQlVHOiBDaGVjayBpZiBmb3JtYXR0aW5nIGlzIGJlaW5nIGFwcGxpZWQgKGdlbmVyaWMgY2hlY2spXHJcbiAgICBjb25zdCBoYXNBbnlGb3JtYXR0aW5nID1cclxuICAgICAgZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSB8fFxyXG4gICAgICBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlIHx8XHJcbiAgICAgIGZvcm1hdHRpbmcuZm9udFN0eWxlIHx8XHJcbiAgICAgIGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSB8fFxyXG4gICAgICBmb3JtYXR0aW5nLmZvbnRTaXplO1xyXG5cclxuICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBTdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nIC0gSW5wdXQ6XCIsIHtcclxuICAgICAgICBwYXJhZ3JhcGhTdHlsZTogZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSxcclxuICAgICAgICBjaGFyYWN0ZXJTdHlsZTogZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZSxcclxuICAgICAgICBkaXJlY3RGb250U3R5bGU6IGZvcm1hdHRpbmcuZm9udFN0eWxlLFxyXG4gICAgICAgIGRpcmVjdEZvbnRSZWY6IGZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZSxcclxuICAgICAgICBkaXJlY3RGb250U2l6ZTogZm9ybWF0dGluZy5mb250U2l6ZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzb2x2ZSBwYXJhZ3JhcGggc3R5bGUgKGJhc2UgbGF5ZXIpXHJcbiAgICBpZiAoXHJcbiAgICAgIGZvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGUgJiZcclxuICAgICAgdGhpcy5zdHlsZXMucGFyYWdyYXBoW2Zvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVdXHJcbiAgICApIHtcclxuICAgICAgY29uc3QgcFN0eWxlID0gdGhpcy5zdHlsZXMucGFyYWdyYXBoW2Zvcm1hdHRpbmcucGFyYWdyYXBoU3R5bGVdO1xyXG5cclxuICAgICAgaWYgKCFyZXNvbHZlZC5mb250U2l6ZSAmJiBwU3R5bGUucG9pbnRTaXplKVxyXG4gICAgICAgIHJlc29sdmVkLmZvbnRTaXplID0gcFN0eWxlLnBvaW50U2l6ZTtcclxuICAgICAgaWYgKCFyZXNvbHZlZC5maWxsQ29sb3IgJiYgcFN0eWxlLmZpbGxDb2xvcilcclxuICAgICAgICByZXNvbHZlZC5maWxsQ29sb3IgPSBwU3R5bGUuZmlsbENvbG9yO1xyXG4gICAgICAvLyBDUklUSUNBTCBGSVg6IEFsd2F5cyBpbmhlcml0IHBhcmFncmFwaCBhbGlnbm1lbnQgdW5sZXNzIGV4cGxpY2l0bHkgb3ZlcnJpZGRlblxyXG4gICAgICBpZiAocFN0eWxlLmFsaWdubWVudCkgcmVzb2x2ZWQuYWxpZ25tZW50ID0gcFN0eWxlLmFsaWdubWVudDtcclxuICAgICAgaWYgKCFyZXNvbHZlZC5mb250U3R5bGUgJiYgcFN0eWxlLmZvbnRTdHlsZSkge1xyXG4gICAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IHBTdHlsZS5mb250U3R5bGU7XHJcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgICAgRm9udFN0eWxlIGZyb20gcGFyYWdyYXBoIHN0eWxlOiBcIiR7cFN0eWxlLmZvbnRTdHlsZX1cImBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDUklUSUNBTDogUmVzb2x2ZSBmb250IGZyb20gcGFyYWdyYXBoIHN0eWxlXHJcbiAgICAgIGlmICghcmVzb2x2ZWQuZm9udEZhbWlseSAmJiBwU3R5bGUuYXBwbGllZEZvbnQpIHtcclxuICAgICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShwU3R5bGUuYXBwbGllZEZvbnQpO1xyXG4gICAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYCAgIEZvbnQgZnJvbSBwYXJhZ3JhcGggc3R5bGU6ICR7cFN0eWxlLmFwcGxpZWRGb250fSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCBvdGhlciBwYXJhZ3JhcGggcHJvcGVydGllcyB3aXRoIGVuaGFuY2VkIGxlYWRpbmcgc3VwcG9ydFxyXG4gICAgICByZXNvbHZlZC5sZWFkaW5nID0gcFN0eWxlLmxlYWRpbmc7XHJcbiAgICAgIHJlc29sdmVkLmxlYWRpbmdUeXBlID0gcFN0eWxlLmxlYWRpbmdUeXBlO1xyXG4gICAgICByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0ID0gcFN0eWxlLmVmZmVjdGl2ZUxpbmVIZWlnaHQ7XHJcbiAgICAgIHJlc29sdmVkLmxlZnRJbmRlbnQgPSBwU3R5bGUubGVmdEluZGVudDtcclxuICAgICAgcmVzb2x2ZWQucmlnaHRJbmRlbnQgPSBwU3R5bGUucmlnaHRJbmRlbnQ7XHJcbiAgICAgIHJlc29sdmVkLmZpcnN0TGluZUluZGVudCA9IHBTdHlsZS5maXJzdExpbmVJbmRlbnQ7XHJcbiAgICAgIHJlc29sdmVkLnNwYWNlQmVmb3JlID0gcFN0eWxlLnNwYWNlQmVmb3JlO1xyXG4gICAgICByZXNvbHZlZC5zcGFjZUFmdGVyID0gcFN0eWxlLnNwYWNlQWZ0ZXI7XHJcbiAgICAgIHJlc29sdmVkLnRyYWNraW5nID0gcFN0eWxlLnRyYWNraW5nO1xyXG4gICAgICByZXNvbHZlZC5rZXJuaW5nID0gcFN0eWxlLmtlcm5pbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzb2x2ZSBjaGFyYWN0ZXIgc3R5bGUgKG92ZXJyaWRlIGxheWVyKVxyXG4gICAgaWYgKFxyXG4gICAgICBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlICYmXHJcbiAgICAgIHRoaXMuc3R5bGVzLmNoYXJhY3Rlcltmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlXVxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnN0IGNTdHlsZSA9IHRoaXMuc3R5bGVzLmNoYXJhY3Rlcltmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlXTtcclxuXHJcbiAgICAgIGlmIChjU3R5bGUucG9pbnRTaXplKSByZXNvbHZlZC5mb250U2l6ZSA9IGNTdHlsZS5wb2ludFNpemU7XHJcbiAgICAgIGlmIChjU3R5bGUuZmlsbENvbG9yKSByZXNvbHZlZC5maWxsQ29sb3IgPSBjU3R5bGUuZmlsbENvbG9yO1xyXG4gICAgICBpZiAoY1N0eWxlLmZvbnRTdHlsZSkge1xyXG4gICAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IGNTdHlsZS5mb250U3R5bGU7XHJcbiAgICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgICAgRm9udFN0eWxlIGZyb20gY2hhcmFjdGVyIHN0eWxlOiBcIiR7Y1N0eWxlLmZvbnRTdHlsZX1cImBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjU3R5bGUuc3Ryb2tlQ29sb3IpIHJlc29sdmVkLnN0cm9rZUNvbG9yID0gY1N0eWxlLnN0cm9rZUNvbG9yO1xyXG5cclxuICAgICAgLy8gSW5jbHVkZSBsZWFkaW5nIGluZm9ybWF0aW9uIGZyb20gY2hhcmFjdGVyIHN0eWxlXHJcbiAgICAgIGlmIChjU3R5bGUubGVhZGluZykgcmVzb2x2ZWQubGVhZGluZyA9IGNTdHlsZS5sZWFkaW5nO1xyXG4gICAgICBpZiAoY1N0eWxlLmxlYWRpbmdUeXBlKSByZXNvbHZlZC5sZWFkaW5nVHlwZSA9IGNTdHlsZS5sZWFkaW5nVHlwZTtcclxuICAgICAgaWYgKGNTdHlsZS5lZmZlY3RpdmVMaW5lSGVpZ2h0KVxyXG4gICAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSBjU3R5bGUuZWZmZWN0aXZlTGluZUhlaWdodDtcclxuXHJcbiAgICAgIC8vIENSSVRJQ0FMOiBDaGFyYWN0ZXIgc3R5bGUgZm9udCBvdmVycmlkZXMgcGFyYWdyYXBoIHN0eWxlXHJcbiAgICAgIGlmIChjU3R5bGUuYXBwbGllZEZvbnQpIHtcclxuICAgICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5yZXNvbHZlRm9udFJlZmVyZW5jZShjU3R5bGUuYXBwbGllZEZvbnQpO1xyXG4gICAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYCAgIEZvbnQgZnJvbSBjaGFyYWN0ZXIgc3R5bGU6ICR7Y1N0eWxlLmFwcGxpZWRGb250fSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBseSBkaXJlY3QgZm9ybWF0dGluZyAoaGlnaGVzdCBwcmlvcml0eSlcclxuICAgIGlmIChmb3JtYXR0aW5nLmZvbnRSZWZlcmVuY2UpIHtcclxuICAgICAgcmVzb2x2ZWQuZm9udEZhbWlseSA9IHRoaXMucmVzb2x2ZUZvbnRSZWZlcmVuY2UoZm9ybWF0dGluZy5mb250UmVmZXJlbmNlKTtcclxuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGAgICBGb250IGZyb20gZGlyZWN0IGZvcm1hdHRpbmc6ICR7Zm9ybWF0dGluZy5mb250UmVmZXJlbmNlfSAtPiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDUklUSUNBTDogQXBwbHkgZGlyZWN0IGZvbnRTdHlsZSBpZiBwcm92aWRlZCAodGhpcyBtaWdodCBiZSB0aGUgaXNzdWUpXHJcbiAgICBpZiAoZm9ybWF0dGluZy5mb250U3R5bGUpIHtcclxuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gZm9ybWF0dGluZy5mb250U3R5bGU7XHJcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgICAgRm9udFN0eWxlIGZyb20gZGlyZWN0IGZvcm1hdHRpbmc6IFwiJHtmb3JtYXR0aW5nLmZvbnRTdHlsZX1cImBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXBwbHkgZGlyZWN0IGxlYWRpbmcgaW5mb3JtYXRpb24gKGhpZ2hlc3QgcHJpb3JpdHkpXHJcbiAgICBpZiAoZm9ybWF0dGluZy5sZWFkaW5nICE9PSB1bmRlZmluZWQpIHJlc29sdmVkLmxlYWRpbmcgPSBmb3JtYXR0aW5nLmxlYWRpbmc7XHJcbiAgICBpZiAoZm9ybWF0dGluZy5sZWFkaW5nVHlwZSkgcmVzb2x2ZWQubGVhZGluZ1R5cGUgPSBmb3JtYXR0aW5nLmxlYWRpbmdUeXBlO1xyXG4gICAgaWYgKGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodClcclxuICAgICAgcmVzb2x2ZWQuZWZmZWN0aXZlTGluZUhlaWdodCA9IGZvcm1hdHRpbmcuZWZmZWN0aXZlTGluZUhlaWdodDtcclxuXHJcbiAgICAvLyBBcHBseSBvdGhlciBkaXJlY3QgZm9ybWF0dGluZyBhdHRyaWJ1dGVzXHJcbiAgICBpZiAoZm9ybWF0dGluZy5mb250U2l6ZSkgcmVzb2x2ZWQuZm9udFNpemUgPSBmb3JtYXR0aW5nLmZvbnRTaXplO1xyXG4gICAgaWYgKGZvcm1hdHRpbmcudHJhY2tpbmcpIHJlc29sdmVkLnRyYWNraW5nID0gZm9ybWF0dGluZy50cmFja2luZztcclxuICAgIGlmIChmb3JtYXR0aW5nLmtlcm5pbmcpIHJlc29sdmVkLmtlcm5pbmcgPSBmb3JtYXR0aW5nLmtlcm5pbmc7XHJcblxyXG4gICAgLy8gQ1JJVElDQUwgRklYOiBBcHBseSBkaXJlY3QgYWxpZ25tZW50IGlmIGV4cGxpY2l0bHkgc3BlY2lmaWVkIChvdmVycmlkZXMgcGFyYWdyYXBoIGFsaWdubWVudClcclxuICAgIGlmIChmb3JtYXR0aW5nLmFsaWdubWVudCkge1xyXG4gICAgICByZXNvbHZlZC5hbGlnbm1lbnQgPSBmb3JtYXR0aW5nLmFsaWdubWVudDtcclxuICAgICAgaWYgKGhhc0FueUZvcm1hdHRpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGAgICBBbGlnbm1lbnQgZnJvbSBkaXJlY3QgZm9ybWF0dGluZzogXCIke2Zvcm1hdHRpbmcuYWxpZ25tZW50fVwiYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGSVhFRDogRW5zdXJlIGZvbnRTdHlsZSBkZWZhdWx0cyB0byBSZWd1bGFyL25vcm1hbCBpZiBub3Qgc2V0XHJcbiAgICBpZiAoIXJlc29sdmVkLmZvbnRTdHlsZSB8fCByZXNvbHZlZC5mb250U3R5bGUgPT09IFwiXCIpIHtcclxuICAgICAgcmVzb2x2ZWQuZm9udFN0eWxlID0gXCJSZWd1bGFyXCI7XHJcbiAgICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAgIEZvbnRTdHlsZSBkZWZhdWx0ZWQgdG86IFwiUmVndWxhclwiYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBRERJVElPTkFMIEZJWDogSWYgbm8gc3R5bGVzIHdlcmUgYXBwbGllZCBmcm9tIGFueSBzb3VyY2UsIGVuc3VyZSBjbGVhbiBkZWZhdWx0c1xyXG4gICAgaWYgKFxyXG4gICAgICAhZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSAmJlxyXG4gICAgICAhZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZSAmJlxyXG4gICAgICAhZm9ybWF0dGluZy5mb250U3R5bGUgJiZcclxuICAgICAgIWZvcm1hdHRpbmcuZm9udFJlZmVyZW5jZVxyXG4gICAgKSB7XHJcbiAgICAgIHJlc29sdmVkLmZvbnRTdHlsZSA9IFwiUmVndWxhclwiO1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBObyBzb3VyY2Ugc3R5bGVzIGZvdW5kIC0gZW5zdXJpbmcgY2xlYW4gZGVmYXVsdHNgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmFsIGZhbGxiYWNrXHJcbiAgICBpZiAoIXJlc29sdmVkLmZvbnRGYW1pbHkgfHwgcmVzb2x2ZWQuZm9udEZhbWlseSA9PT0gXCJcIikge1xyXG4gICAgICByZXNvbHZlZC5mb250RmFtaWx5ID0gdGhpcy5nZXREZWZhdWx0Rm9udCgpO1xyXG4gICAgICBpZiAoaGFzQW55Rm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBVc2luZyBmYWxsYmFjayBmb250OiAke3Jlc29sdmVkLmZvbnRGYW1pbHl9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgbGluZSBoZWlnaHQgaXMgY2FsY3VsYXRlZCBpZiBub3QgZXhwbGljaXRseSBzZXRcclxuICAgIGlmIChcclxuICAgICAgIXJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgJiZcclxuICAgICAgcmVzb2x2ZWQuZm9udFNpemUgJiZcclxuICAgICAgcmVzb2x2ZWQubGVhZGluZ1xyXG4gICAgKSB7XHJcbiAgICAgIHJlc29sdmVkLmVmZmVjdGl2ZUxpbmVIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZUVmZmVjdGl2ZUxpbmVIZWlnaHQoXHJcbiAgICAgICAgcmVzb2x2ZWQubGVhZGluZyxcclxuICAgICAgICByZXNvbHZlZC5mb250U2l6ZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChoYXNBbnlGb3JtYXR0aW5nKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBTdHlsZVBhcnNlci5yZXNvbHZlU3R5bGVGb3JtYXR0aW5nIC0gRmluYWwgT3V0cHV0OlwiLCB7XHJcbiAgICAgICAgZm9udFNpemU6IHJlc29sdmVkLmZvbnRTaXplLFxyXG4gICAgICAgIGZvbnRGYW1pbHk6IHJlc29sdmVkLmZvbnRGYW1pbHksXHJcbiAgICAgICAgZm9udFN0eWxlOiByZXNvbHZlZC5mb250U3R5bGUsXHJcbiAgICAgICAgZmlsbENvbG9yOiByZXNvbHZlZC5maWxsQ29sb3IsXHJcbiAgICAgICAgbGVhZGluZzogcmVzb2x2ZWQubGVhZGluZyxcclxuICAgICAgICBlZmZlY3RpdmVMaW5lSGVpZ2h0OiByZXNvbHZlZC5lZmZlY3RpdmVMaW5lSGVpZ2h0LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzb2x2ZWQ7XHJcbiAgfVxyXG5cclxuICByZXNvbHZlRm9udFJlZmVyZW5jZShmb250UmVmKSB7XHJcbiAgICBpZiAoIWZvbnRSZWYgfHwgZm9udFJlZiA9PT0gXCJcIikge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkVtcHR5IGZvbnQgcmVmZXJlbmNlLCB1c2luZyBmYWxsYmFja1wiKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdEZvbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgZGlyZWN0IGxvb2t1cCBpbiBmb250IG1hcFxyXG4gICAgaWYgKHRoaXMuZm9udE1hcCAmJiB0aGlzLmZvbnRNYXAuaGFzKGZvbnRSZWYpKSB7XHJcbiAgICAgIGNvbnN0IHJlc29sdmVkRm9udCA9IHRoaXMuZm9udE1hcC5nZXQoZm9udFJlZik7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBGb250IHJlc29sdmVkOiBcIiR7Zm9udFJlZn1cIiAtPiBcIiR7cmVzb2x2ZWRGb250fVwiYCk7XHJcbiAgICAgIHJldHVybiByZXNvbHZlZEZvbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IHBhcnRpYWwgbWF0Y2hpbmcgZm9yIGZvbnQgZmFtaWxpZXNcclxuICAgIGlmICh0aGlzLnJlc291cmNlcy5mb250cykge1xyXG4gICAgICBmb3IgKGNvbnN0IFtmYW1pbHlJZCwgZmFtaWx5SW5mb10gb2YgT2JqZWN0LmVudHJpZXMoXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZm9udHNcclxuICAgICAgKSkge1xyXG4gICAgICAgIC8vIENoZWNrIGZhbWlseSBuYW1lIG1hdGNoXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZmFtaWx5SW5mby5uYW1lICYmXHJcbiAgICAgICAgICAoZmFtaWx5SW5mby5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZm9udFJlZi50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICBmb250UmVmLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmFtaWx5SW5mby5uYW1lLnRvTG93ZXJDYXNlKCkpKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGBGb250IHBhcnRpYWxseSBtYXRjaGVkOiBcIiR7Zm9udFJlZn1cIiAtPiBcIiR7ZmFtaWx5SW5mby5uYW1lfVwiYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJldHVybiBmYW1pbHlJbmZvLm5hbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpbmRpdmlkdWFsIGZvbnQgbWF0Y2hlc1xyXG4gICAgICAgIGlmIChmYW1pbHlJbmZvLmZvbnRzKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IGZvbnQgb2YgZmFtaWx5SW5mby5mb250cykge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgZm9udC5zZWxmID09PSBmb250UmVmIHx8XHJcbiAgICAgICAgICAgICAgZm9udC5wb3N0U2NyaXB0TmFtZSA9PT0gZm9udFJlZiB8fFxyXG4gICAgICAgICAgICAgIGZvbnQubmFtZSA9PT0gZm9udFJlZlxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgIGBGb250IGV4YWN0bHkgbWF0Y2hlZDogXCIke2ZvbnRSZWZ9XCIgLT4gXCIke2ZhbWlseUluZm8ubmFtZX1cImBcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYW1pbHlJbmZvLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhgRm9udCBub3QgZm91bmQ6IFwiJHtmb250UmVmfVwiLCB1c2luZyBmYWxsYmFja2ApO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdEZvbnQoKSB8fCBmb250UmVmO1xyXG4gIH1cclxuXHJcbiAgZ2V0RGVmYXVsdEZvbnQoKSB7XHJcbiAgICBpZiAodGhpcy5yZXNvdXJjZXMuZm9udHMgJiYgT2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuZm9udHMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgZmlyc3RGYW1pbHkgPSBPYmplY3QudmFsdWVzKHRoaXMucmVzb3VyY2VzLmZvbnRzKVswXTtcclxuICAgICAgcmV0dXJuIGZpcnN0RmFtaWx5Lm5hbWUgfHwgXCJBcmlhbFwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiQXJpYWxcIjtcclxuICB9XHJcblxyXG4gIGluZmVyRm9udEZyb21Db250ZXh0KCkge1xyXG4gICAgLy8gSWYgd2UgaGF2ZSBmb250IGRlZmluaXRpb25zIGJ1dCBubyBleHBsaWNpdCByZWZlcmVuY2VzLFxyXG4gICAgLy8gcmV0dXJuIHRoZSBmaXJzdCBhdmFpbGFibGUgZm9udCBhcyBhIGZhbGxiYWNrXHJcbiAgICBpZiAodGhpcy5yZXNvdXJjZXMuZm9udHMgJiYgT2JqZWN0LmtleXModGhpcy5yZXNvdXJjZXMuZm9udHMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgZmlyc3RGb250RmFtaWx5ID0gT2JqZWN0LnZhbHVlcyh0aGlzLnJlc291cmNlcy5mb250cylbMF07XHJcbiAgICAgIHJldHVybiBmaXJzdEZvbnRGYW1pbHkubmFtZTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3RvcnlTdHlsZVN1bW1hcnkoc3RvcnkpIHtcclxuICAgIGNvbnN0IHN1bW1hcnkgPSB7XHJcbiAgICAgIGZvbnRTaXplOiBudWxsLFxyXG4gICAgICBmb250RmFtaWx5OiBudWxsLFxyXG4gICAgICBhbGlnbm1lbnQ6IG51bGwsXHJcbiAgICAgIGZpbGxDb2xvcjogbnVsbCxcclxuICAgICAgZm9udFN0eWxlOiBudWxsLFxyXG4gICAgICBsZWFkaW5nOiBudWxsLFxyXG4gICAgICBsZWFkaW5nVHlwZTogbnVsbCxcclxuICAgICAgZWZmZWN0aXZlTGluZUhlaWdodDogbnVsbCxcclxuICAgICAgdHJhY2tpbmc6IG51bGwsXHJcbiAgICAgIGtlcm5pbmc6IG51bGwsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdldCB0aGUgbW9zdCBjb21tb24gb3IgZmlyc3QgZm9ybWF0dGluZyB2YWx1ZXNcclxuICAgIGlmIChzdG9yeS5jb250ZW50Py5mb3JtYXR0ZWRDb250ZW50Py5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGZpcnN0Rm9ybWF0dGVkID0gc3RvcnkuY29udGVudC5mb3JtYXR0ZWRDb250ZW50LmZpbmQoXHJcbiAgICAgICAgKGl0ZW0pID0+IGl0ZW0uZm9ybWF0dGluZyAmJiAhaXRlbS5mb3JtYXR0aW5nLmlzQnJlYWtcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChmaXJzdEZvcm1hdHRlZD8uZm9ybWF0dGluZykge1xyXG4gICAgICAgIGNvbnN0IGZtdCA9IGZpcnN0Rm9ybWF0dGVkLmZvcm1hdHRpbmc7XHJcbiAgICAgICAgc3VtbWFyeS5mb250U2l6ZSA9IGZtdC5mb250U2l6ZTtcclxuICAgICAgICBzdW1tYXJ5LmZvbnRGYW1pbHkgPSBmbXQuZm9udEZhbWlseTtcclxuICAgICAgICBzdW1tYXJ5LmFsaWdubWVudCA9IGZtdC5hbGlnbm1lbnQ7XHJcbiAgICAgICAgc3VtbWFyeS5maWxsQ29sb3IgPSBmbXQuZmlsbENvbG9yO1xyXG4gICAgICAgIHN1bW1hcnkuZm9udFN0eWxlID0gZm10LmZvbnRTdHlsZTtcclxuICAgICAgICBzdW1tYXJ5LmxlYWRpbmcgPSBmbXQubGVhZGluZztcclxuICAgICAgICBzdW1tYXJ5LmxlYWRpbmdUeXBlID0gZm10LmxlYWRpbmdUeXBlO1xyXG4gICAgICAgIHN1bW1hcnkuZWZmZWN0aXZlTGluZUhlaWdodCA9IGZtdC5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xyXG4gICAgICAgIHN1bW1hcnkudHJhY2tpbmcgPSBmbXQudHJhY2tpbmc7XHJcbiAgICAgICAgc3VtbWFyeS5rZXJuaW5nID0gZm10Lmtlcm5pbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3VtbWFyeTtcclxuICB9XHJcblxyXG4gIC8vIE5FVzogUHJvY2VzcyBsZWFkaW5nIHZhbHVlcyB3aXRoIEluRGVzaWduLXNwZWNpZmljIGxvZ2ljIChzaGFyZWQgd2l0aCBTdG9yeVBhcnNlcilcclxuICBwcm9jZXNzTGVhZGluZ1ZhbHVlKHJhd0xlYWRpbmcsIGZvbnRTaXplKSB7XHJcbiAgICBpZiAoIXJhd0xlYWRpbmcpIHJldHVybiBcImF1dG9cIjtcclxuXHJcbiAgICAvLyBIYW5kbGUgXCJhdXRvXCIgbGVhZGluZ1xyXG4gICAgaWYgKHJhd0xlYWRpbmcgPT09IFwiYXV0b1wiIHx8IHJhd0xlYWRpbmcgPT09IFwiQXV0b1wiKSB7XHJcbiAgICAgIHJldHVybiBmb250U2l6ZSA/IGZvbnRTaXplICogMS4yIDogXCJhdXRvXCI7IC8vIEluRGVzaWduIGRlZmF1bHQgYXV0byBsZWFkaW5nIGlzIDEyMCVcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgbnVtZXJpYyBsZWFkaW5nIChpbiBwb2ludHMpXHJcbiAgICBjb25zdCBudW1lcmljTGVhZGluZyA9IHBhcnNlRmxvYXQocmF3TGVhZGluZyk7XHJcbiAgICBpZiAoIWlzTmFOKG51bWVyaWNMZWFkaW5nKSkge1xyXG4gICAgICByZXR1cm4gbnVtZXJpY0xlYWRpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIHBlcmNlbnRhZ2UtYmFzZWQgbGVhZGluZ1xyXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoXCIlXCIpKSB7XHJcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KHJhd0xlYWRpbmcucmVwbGFjZShcIiVcIiwgXCJcIikpO1xyXG4gICAgICByZXR1cm4gZm9udFNpemUgPyAoZm9udFNpemUgKiBwZXJjZW50YWdlKSAvIDEwMCA6IFwiYXV0b1wiO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBcImF1dG9cIjtcclxuICB9XHJcblxyXG4gIC8vIE5FVzogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGxlYWRpbmcgYmVpbmcgdXNlZFxyXG4gIGRldGVybWluZUxlYWRpbmdUeXBlKHJhd0xlYWRpbmcpIHtcclxuICAgIGlmICghcmF3TGVhZGluZyB8fCByYXdMZWFkaW5nID09PSBcImF1dG9cIiB8fCByYXdMZWFkaW5nID09PSBcIkF1dG9cIikge1xyXG4gICAgICByZXR1cm4gXCJhdXRvXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJhd0xlYWRpbmcuaW5jbHVkZXMoXCIlXCIpKSB7XHJcbiAgICAgIHJldHVybiBcInBlcmNlbnRhZ2VcIjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQocmF3TGVhZGluZykpKSB7XHJcbiAgICAgIHJldHVybiBcImFic29sdXRlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBDYWxjdWxhdGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGZvciBDU1MgcmVuZGVyaW5nXHJcbiAgY2FsY3VsYXRlRWZmZWN0aXZlTGluZUhlaWdodChsZWFkaW5nLCBmb250U2l6ZSkge1xyXG4gICAgaWYgKGxlYWRpbmcgPT09IFwiYXV0b1wiKSB7XHJcbiAgICAgIHJldHVybiAxLjI7IC8vIENTUyBsaW5lLWhlaWdodCByYXRpbyBmb3IgYXV0b1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgbGVhZGluZyA9PT0gXCJudW1iZXJcIiAmJiBmb250U2l6ZSkge1xyXG4gICAgICAvLyBDb252ZXJ0IHBvaW50cyB0byBDU1MgbGluZS1oZWlnaHQgcmF0aW9cclxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAuOCwgbGVhZGluZyAvIGZvbnRTaXplKTsgLy8gRW5zdXJlIG1pbmltdW0gbGluZSBoZWlnaHRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gMS4yOyAvLyBGYWxsYmFja1xyXG4gIH1cclxuXHJcbiAgZ2V0U3R5bGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmVzb3VyY2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzO1xyXG4gIH1cclxuXHJcbiAgZ2V0Rm9udE1hcCgpIHtcclxuICAgIHJldHVybiB0aGlzLmZvbnRNYXA7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgbWV0aG9kcyB0byByZXR1cm4gc3R5bGUgYW5kIGZvbnQgZGVmaW5pdGlvbnMgZm9yIGRlYnVnXHJcbiAgZ2V0UGFyYWdyYXBoU3R5bGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzLnBhcmFncmFwaDtcclxuICB9XHJcbiAgZ2V0Q2hhcmFjdGVyU3R5bGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzLmNoYXJhY3RlcjtcclxuICB9XHJcbiAgZ2V0Rm9udERlZmluaXRpb25zKCkge1xyXG4gICAgLy8gUHJlZmVyIHBsYWluIG9iamVjdCBmb3IgZGVidWcgb3V0cHV0XHJcbiAgICBpZiAodGhpcy5yZXNvdXJjZXMgJiYgdGhpcy5yZXNvdXJjZXMuZm9udHMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzLmZvbnRzO1xyXG4gICAgfVxyXG4gICAgLy8gRmFsbGJhY2s6IGNvbnZlcnQgZm9udE1hcCB0byBvYmplY3RcclxuICAgIGlmICh0aGlzLmZvbnRNYXAgJiYgdHlwZW9mIHRoaXMuZm9udE1hcC5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLmZvbnRNYXAuZW50cmllcygpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcblxyXG4gIC8vIEZJWEVEOiBBZGQgbWV0aG9kIHRvIGFjY2VzcyBkb2N1bWVudCBwcmVmZXJlbmNlcyBpbmNsdWRpbmcgVmlld1ByZWZlcmVuY2VzXHJcbiAgZ2V0RG9jdW1lbnRJbmZvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRJbmZvO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZVBhcnNlcjtcclxuIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiSURNTFV0aWxzIiwiU3R5bGVQYXJzZXIiLCJjb25zdHJ1Y3RvciIsInVuaXRDb252ZXJ0ZXIiLCJzdHlsZXMiLCJwYXJhZ3JhcGgiLCJjaGFyYWN0ZXIiLCJvYmplY3QiLCJ0YWJsZSIsImNlbGwiLCJyZXNvdXJjZXMiLCJmb250cyIsImNvbG9ycyIsImdyYWRpZW50cyIsImZvbnRNYXAiLCJNYXAiLCJkb2N1bWVudFVuaXRzIiwic2V0RG9jdW1lbnRVbml0cyIsInVuaXRzIiwiY29uc29sZSIsImxvZyIsImNvbnZlcnRUeXBvZ3JhcGh5VG9QaXhlbHMiLCJ2YWx1ZSIsImlzTmFOIiwiaXNTdXBwb3J0ZWRVbml0IiwiY29udmVydGVkVmFsdWUiLCJ0b1BpeGVscyIsImNvbnZlcnRTdHlsZU1lYXN1cmVtZW50c1RvUGl4ZWxzIiwic3R5bGUiLCJjb252ZXJ0ZWRTdHlsZSIsIm1lYXN1cmVtZW50RmllbGRzIiwiZm9yRWFjaCIsImZpZWxkIiwibGVhZGluZyIsInBhcnNlUmVzb3VyY2VGaWxlIiwiZmlsZU5hbWUiLCJjb250ZW50IiwieG1sUGFyc2VyIiwicGFyc2VkIiwicGFyc2UiLCJyZXNvdXJjZU5hbWUiLCJiYXNlbmFtZSIsImluY2x1ZGVzIiwiZXh0cmFjdFN0eWxlcyIsImV4dHJhY3RGb250cyIsImV4dHJhY3RHcmFwaGljcyIsImV4dHJhY3RQcmVmZXJlbmNlcyIsImVycm9yIiwibWVzc2FnZSIsInN0eWxlc0RhdGEiLCJTdHlsZXMiLCJSb290UGFyYWdyYXBoU3R5bGVHcm91cCIsImV4dHJhY3RQYXJhZ3JhcGhTdHlsZXMiLCJSb290Q2hhcmFjdGVyU3R5bGVHcm91cCIsImV4dHJhY3RDaGFyYWN0ZXJTdHlsZXMiLCJzdHlsZUdyb3VwIiwiZXh0cmFjdFN0eWxlc1JlY3Vyc2l2ZWx5IiwiZ3JvdXAiLCJQYXJhZ3JhcGhTdHlsZSIsIkFycmF5IiwiaXNBcnJheSIsImZvbnRSZWYiLCJleHRyYWN0Rm9udEZyb21TdHlsZSIsImZvbnRTaXplIiwicGFyc2VGbG9hdCIsInJhd0xlYWRpbmciLCJwcm9jZXNzZWRMZWFkaW5nIiwicHJvY2Vzc0xlYWRpbmdWYWx1ZSIsInJhd0xlZnRJbmRlbnQiLCJyYXdSaWdodEluZGVudCIsInJhd0ZpcnN0TGluZUluZGVudCIsInJhd1NwYWNlQmVmb3JlIiwicmF3U3BhY2VBZnRlciIsInJhd1RyYWNraW5nIiwicmF3S2VybmluZyIsImJhc2VTdHlsZSIsInNlbGYiLCJuYW1lIiwiZm9udFN0eWxlIiwicG9pbnRTaXplIiwibGVhZGluZ1R5cGUiLCJkZXRlcm1pbmVMZWFkaW5nVHlwZSIsImVmZmVjdGl2ZUxpbmVIZWlnaHQiLCJjYWxjdWxhdGVFZmZlY3RpdmVMaW5lSGVpZ2h0IiwiYWxpZ25tZW50IiwibGVmdEluZGVudCIsInJpZ2h0SW5kZW50IiwiZmlyc3RMaW5lSW5kZW50Iiwic3BhY2VCZWZvcmUiLCJzcGFjZUFmdGVyIiwidHJhY2tpbmciLCJrZXJuaW5nIiwib3JpZ2luYWxMZWZ0SW5kZW50Iiwib3JpZ2luYWxSaWdodEluZGVudCIsIm9yaWdpbmFsRmlyc3RMaW5lSW5kZW50Iiwib3JpZ2luYWxTcGFjZUJlZm9yZSIsIm9yaWdpbmFsU3BhY2VBZnRlciIsIm9yaWdpbmFsVHJhY2tpbmciLCJvcmlnaW5hbEtlcm5pbmciLCJob3Jpem9udGFsU2NhbGUiLCJ2ZXJ0aWNhbFNjYWxlIiwiYXBwbGllZEZvbnQiLCJvcmlnaW5hbEZvbnRSZWYiLCJmaWxsQ29sb3IiLCJyYXdTdHlsZSIsIlBhcmFncmFwaFN0eWxlR3JvdXAiLCJzdWJHcm91cHMiLCJQcm9wZXJ0aWVzIiwiQXBwbGllZEZvbnQiLCJGb250RmFtaWx5IiwiQ2hhcmFjdGVyU3R5bGUiLCJzdHJva2VDb2xvciIsIkNoYXJhY3RlclN0eWxlR3JvdXAiLCJmb250c0RhdGEiLCJGb250cyIsImZvbnRGYW1pbGllcyIsImZhbWlseSIsImZhbWlseUluZm8iLCJGb250IiwiZm9udExpc3QiLCJmb250IiwiZm9udEluZm8iLCJmb250RmFtaWx5IiwicG9zdFNjcmlwdE5hbWUiLCJzdGF0dXMiLCJmb250U3R5bGVOYW1lIiwicHVzaCIsInNldCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzaXplIiwiZ3JhcGhpY3NEYXRhIiwiZ3JhcGhpY3MiLCJHcmFwaGljIiwiQ29sb3IiLCJjb2xvciIsImN5YW4iLCJtYWdlbnRhIiwieWVsbG93IiwiYmxhY2siLCJyZWQiLCJncmVlbiIsImJsdWUiLCJjb2xvclNwYWNlIiwiY29sb3JNb2RlbCIsImNvbG9yVmFsdWUiLCJjb2xvck5hbWUiLCJjb2xvclNlbGYiLCJpc0N1c3RvbUNvbG9yIiwiaXNDdXN0b21Db2xvck5hbWUiLCJmaW5hbENvbG9yRGF0YSIsIm1vZGVsIiwic3BhY2UiLCJjb2xvclNvdXJjZSIsImhhc0RpcmVjdFJHQiIsImhhc0RpcmVjdENNWUsiLCJoYXNDb2xvclZhbHVlIiwidmFsdWVQYXJ0cyIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwiZmlsdGVyIiwidiIsInNvdXJjZSIsImhhc1JHQiIsImhhc0NNWUsiLCJpc0N1c3RvbSIsInJnYiIsImNteWsiLCJHcmFkaWVudCIsImdyYWRpZW50IiwidHlwZSIsImdyYWRpZW50U3RvcHMiLCJleHRyYWN0R3JhZGllbnRTdG9wcyIsInN0YW5kYXJkQ29sb3JzIiwiY215a1BhdHRlcm4iLCJyZ2JQYXR0ZXJuIiwidGVzdCIsImN1c3RvbUNvbG9yUGF0dGVybnMiLCJoYXNDdXN0b21QYXR0ZXJuIiwic29tZSIsInBhdHRlcm4iLCJzdG9wcyIsIkdyYWRpZW50U3RvcCIsInN0b3BMaXN0Iiwic3RvcCIsInN0b3BDb2xvciIsImxvY2F0aW9uIiwibWlkcG9pbnQiLCJwcmVmZXJlbmNlc0RhdGEiLCJwcmVmcyIsIlByZWZlcmVuY2VzIiwiZG9jdW1lbnRJbmZvIiwicHJlZmVyZW5jZXMiLCJkb2N1bWVudFByZWZlcmVuY2VzIiwiZXh0cmFjdERvY3VtZW50UHJlZnMiLCJEb2N1bWVudFByZWZlcmVuY2UiLCJ2aWV3UHJlZmVyZW5jZXMiLCJleHRyYWN0Vmlld1ByZWZzIiwiVmlld1ByZWZlcmVuY2UiLCJndWlkZVByZWZlcmVuY2VzIiwiZXh0cmFjdEd1aWRlUHJlZnMiLCJHdWlkZVByZWZlcmVuY2UiLCJncmlkUHJlZmVyZW5jZXMiLCJleHRyYWN0R3JpZFByZWZzIiwiR3JpZFByZWZlcmVuY2UiLCJtYXJnaW5QcmVmZXJlbmNlcyIsImV4dHJhY3RNYXJnaW5QcmVmcyIsIk1hcmdpblByZWZlcmVuY2UiLCJjb2x1bW5QcmVmZXJlbmNlcyIsImV4dHJhY3RDb2x1bW5QcmVmcyIsIkNvbHVtblByZWZlcmVuY2UiLCJkb2NQcmVmIiwicGFnZVdpZHRoIiwicGFnZUhlaWdodCIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbHVtbkNvdW50IiwicGFyc2VJbnQiLCJjb2x1bW5HdXR0ZXIiLCJmYWNpbmdQYWdlcyIsImFsbG93UGFnZVNodWZmbGUiLCJzbHVnQmxlZWRUeXBlIiwiZG9jdW1lbnRCbGVlZFRvcE9mZnNldCIsImRvY3VtZW50QmxlZWRCb3R0b21PZmZzZXQiLCJkb2N1bWVudEJsZWVkSW5zaWRlT3JMZWZ0T2Zmc2V0IiwiZG9jdW1lbnRCbGVlZE91dHNpZGVPclJpZ2h0T2Zmc2V0Iiwidmlld1ByZWYiLCJob3Jpem9udGFsTWVhc3VyZW1lbnRVbml0cyIsInZlcnRpY2FsTWVhc3VyZW1lbnRVbml0cyIsInJ1bGVyT3JpZ2luIiwic2hvd1J1bGVycyIsImd1aWRlUHJlZiIsInJ1bGVyR3VpZGVDb2xvciIsImd1aWRlc0luQmFjayIsImd1aWRlc0xvY2tlZCIsImd1aWRlc1Nob3duIiwiZ3VpZGVzU25hcHRvIiwiZ3JpZFByZWYiLCJiYXNlbGluZVN0YXJ0IiwiYmFzZWxpbmVEaXZpc2lvbiIsImJhc2VsaW5lU2hvd24iLCJiYXNlbGluZVNuYXB0byIsImRvY3VtZW50R3JpZFNob3duIiwiZG9jdW1lbnRHcmlkU25hcHRvIiwibWFyZ2luUHJlZiIsImNvbHVtblByZWYiLCJ0ZXh0Q29sdW1uQ291bnQiLCJ0ZXh0Q29sdW1uR3V0dGVyIiwicmVzb2x2ZVN0eWxlRm9ybWF0dGluZyIsImZvcm1hdHRpbmciLCJyZXNvbHZlZCIsImhhc0FueUZvcm1hdHRpbmciLCJwYXJhZ3JhcGhTdHlsZSIsImNoYXJhY3RlclN0eWxlIiwiZm9udFJlZmVyZW5jZSIsImRpcmVjdEZvbnRTdHlsZSIsImRpcmVjdEZvbnRSZWYiLCJkaXJlY3RGb250U2l6ZSIsInBTdHlsZSIsInJlc29sdmVGb250UmVmZXJlbmNlIiwiY1N0eWxlIiwidW5kZWZpbmVkIiwiZ2V0RGVmYXVsdEZvbnQiLCJoYXMiLCJyZXNvbHZlZEZvbnQiLCJnZXQiLCJmYW1pbHlJZCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsImZpcnN0RmFtaWx5IiwidmFsdWVzIiwiaW5mZXJGb250RnJvbUNvbnRleHQiLCJmaXJzdEZvbnRGYW1pbHkiLCJnZXRTdG9yeVN0eWxlU3VtbWFyeSIsInN0b3J5Iiwic3VtbWFyeSIsImZvcm1hdHRlZENvbnRlbnQiLCJmaXJzdEZvcm1hdHRlZCIsImZpbmQiLCJpdGVtIiwiaXNCcmVhayIsImZtdCIsIm51bWVyaWNMZWFkaW5nIiwicGVyY2VudGFnZSIsInJlcGxhY2UiLCJNYXRoIiwibWF4IiwiZ2V0U3R5bGVzIiwiZ2V0UmVzb3VyY2VzIiwiZ2V0Rm9udE1hcCIsImdldFBhcmFncmFwaFN0eWxlcyIsImdldENoYXJhY3RlclN0eWxlcyIsImdldEZvbnREZWZpbml0aW9ucyIsImZyb21FbnRyaWVzIiwiZ2V0RG9jdW1lbnRJbmZvIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/parsers/StyleParser.js\n");

/***/ }),

/***/ "./lib/parsers/XMLParser.js":
/*!**********************************!*\
  !*** ./lib/parsers/XMLParser.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { XMLParser } = __webpack_require__(/*! fast-xml-parser */ \"fast-xml-parser\");\nclass IDMLXMLParser {\n    constructor(){\n        // Critical parser configuration for IDML files\n        this.xmlParser = new XMLParser({\n            ignoreAttributes: false,\n            attributeNamePrefix: \"@_\",\n            removeNSPrefix: true,\n            parseAttributeValue: true,\n            trimValues: true,\n            parseTrueNumberOnly: false,\n            textNodeName: \"#text\"\n        });\n    }\n    parse(xmlContent) {\n        try {\n            return this.xmlParser.parse(xmlContent);\n        } catch (error) {\n            console.error(\"Error parsing XML:\", error);\n            throw error;\n        }\n    }\n    parseWithErrorHandling(xmlContent, fileName = \"unknown\") {\n        try {\n            const parsed = this.xmlParser.parse(xmlContent);\n            return {\n                success: true,\n                data: parsed,\n                error: null\n            };\n        } catch (error) {\n            console.error(`Error parsing XML file ${fileName}:`, error.message);\n            return {\n                success: false,\n                data: null,\n                error: error.message\n            };\n        }\n    }\n    validateXMLStructure(xmlContent) {\n        if (!xmlContent || typeof xmlContent !== \"string\") {\n            return {\n                valid: false,\n                error: \"Invalid XML content\"\n            };\n        }\n        if (!xmlContent.trim().startsWith(\"<\")) {\n            return {\n                valid: false,\n                error: \"Content does not appear to be XML\"\n            };\n        }\n        try {\n            this.xmlParser.parse(xmlContent);\n            return {\n                valid: true,\n                error: null\n            };\n        } catch (error) {\n            return {\n                valid: false,\n                error: error.message\n            };\n        }\n    }\n    extractRootElement(parsedXML) {\n        if (!parsedXML || typeof parsedXML !== \"object\") {\n            return null;\n        }\n        const keys = Object.keys(parsedXML);\n        if (keys.length === 1) {\n            return parsedXML[keys[0]];\n        }\n        return parsedXML;\n    }\n    findElementsByAttribute(obj, attributeName, attributeValue = null) {\n        const results = [];\n        const search = (current, path = \"\")=>{\n            if (typeof current === \"object\" && current !== null) {\n                // Check if current object has the attribute\n                if (current[attributeName] !== undefined) {\n                    if (attributeValue === null || current[attributeName] === attributeValue) {\n                        results.push({\n                            element: current,\n                            path: path,\n                            value: current[attributeName]\n                        });\n                    }\n                }\n                // Recursively search nested objects\n                Object.keys(current).forEach((key)=>{\n                    if (typeof current[key] === \"object\") {\n                        search(current[key], path ? `${path}.${key}` : key);\n                    }\n                });\n            }\n        };\n        search(obj);\n        return results;\n    }\n    findElementsByType(obj, elementType) {\n        const results = [];\n        const search = (current, path = \"\")=>{\n            if (typeof current === \"object\" && current !== null) {\n                // Check if we found the element type\n                if (current[elementType]) {\n                    const elements = Array.isArray(current[elementType]) ? current[elementType] : [\n                        current[elementType]\n                    ];\n                    elements.forEach((element, index)=>{\n                        results.push({\n                            element: element,\n                            path: `${path}.${elementType}[${index}]`,\n                            type: elementType\n                        });\n                    });\n                }\n                // Continue searching in nested objects\n                Object.keys(current).forEach((key)=>{\n                    if (typeof current[key] === \"object\" && key !== elementType) {\n                        search(current[key], path ? `${path}.${key}` : key);\n                    }\n                });\n            }\n        };\n        search(obj);\n        return results;\n    }\n    extractAllAttributes(obj, prefix = \"@_\") {\n        const attributes = {};\n        const extract = (current, path = \"\")=>{\n            if (typeof current === \"object\" && current !== null) {\n                Object.keys(current).forEach((key)=>{\n                    if (key.startsWith(prefix)) {\n                        const fullPath = path ? `${path}.${key}` : key;\n                        attributes[fullPath] = current[key];\n                    } else if (typeof current[key] === \"object\") {\n                        extract(current[key], path ? `${path}.${key}` : key);\n                    }\n                });\n            }\n        };\n        extract(obj);\n        return attributes;\n    }\n    getElementHierarchy(obj, maxDepth = 5) {\n        const hierarchy = {};\n        const buildHierarchy = (current, depth = 0, path = \"\")=>{\n            if (depth >= maxDepth || typeof current !== \"object\" || current === null) {\n                return typeof current;\n            }\n            const structure = {};\n            Object.keys(current).forEach((key)=>{\n                if (Array.isArray(current[key])) {\n                    structure[key] = {\n                        type: \"array\",\n                        length: current[key].length,\n                        children: current[key].length > 0 ? buildHierarchy(current[key][0], depth + 1, `${path}.${key}[0]`) : null\n                    };\n                } else if (typeof current[key] === \"object\" && current[key] !== null) {\n                    structure[key] = {\n                        type: \"object\",\n                        children: buildHierarchy(current[key], depth + 1, `${path}.${key}`)\n                    };\n                } else {\n                    structure[key] = {\n                        type: typeof current[key],\n                        value: key.startsWith(\"@_\") ? current[key] : null\n                    };\n                }\n            });\n            return structure;\n        };\n        return buildHierarchy(obj);\n    }\n    normalizeXMLContent(xmlContent) {\n        return xmlContent.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\").trim();\n    }\n    logXMLStructure(parsedXML, maxDepth = 3) {\n        console.log(\"XML Structure Analysis:\");\n        const analyzeStructure = (obj, depth = 0, prefix = \"\")=>{\n            if (depth >= maxDepth || typeof obj !== \"object\" || obj === null) {\n                return;\n            }\n            Object.keys(obj).forEach((key)=>{\n                const value = obj[key];\n                const indent = \"  \".repeat(depth);\n                if (Array.isArray(value)) {\n                    console.log(`${indent}${prefix}${key}: Array[${value.length}]`);\n                    if (value.length > 0 && typeof value[0] === \"object\") {\n                        analyzeStructure(value[0], depth + 1, `${prefix}${key}[0].`);\n                    }\n                } else if (typeof value === \"object\" && value !== null) {\n                    console.log(`${indent}${prefix}${key}: Object`);\n                    analyzeStructure(value, depth + 1, `${prefix}${key}.`);\n                } else if (key.startsWith(\"@_\")) {\n                    console.log(`${indent}${prefix}${key}: ${typeof value} = ${value}`);\n                } else {\n                    console.log(`${indent}${prefix}${key}: ${typeof value}`);\n                }\n            });\n        };\n        analyzeStructure(parsedXML);\n    }\n}\nmodule.exports = IDMLXMLParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dmlld2VyLy4vbGliL3BhcnNlcnMvWE1MUGFyc2VyLmpzPzBkMmIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBYTUxQYXJzZXIgfSA9IHJlcXVpcmUoJ2Zhc3QteG1sLXBhcnNlcicpO1xyXG5cclxuY2xhc3MgSURNTFhNTFBhcnNlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvLyBDcml0aWNhbCBwYXJzZXIgY29uZmlndXJhdGlvbiBmb3IgSURNTCBmaWxlc1xyXG4gICAgdGhpcy54bWxQYXJzZXIgPSBuZXcgWE1MUGFyc2VyKHtcclxuICAgICAgaWdub3JlQXR0cmlidXRlczogZmFsc2UsXHJcbiAgICAgIGF0dHJpYnV0ZU5hbWVQcmVmaXg6ICdAXycsXHJcbiAgICAgIHJlbW92ZU5TUHJlZml4OiB0cnVlLCAvLyBDUklUSUNBTDogUmVtb3ZlcyBpZFBrZzogcHJlZml4ZXNcclxuICAgICAgcGFyc2VBdHRyaWJ1dGVWYWx1ZTogdHJ1ZSwgLy8gUGFyc2UgbnVtYmVycyBhbmQgYm9vbGVhbnNcclxuICAgICAgdHJpbVZhbHVlczogdHJ1ZSxcclxuICAgICAgcGFyc2VUcnVlTnVtYmVyT25seTogZmFsc2UsXHJcbiAgICAgIHRleHROb2RlTmFtZTogJyN0ZXh0JyxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcGFyc2UoeG1sQ29udGVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIHRoaXMueG1sUGFyc2VyLnBhcnNlKHhtbENvbnRlbnQpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBYTUw6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHBhcnNlV2l0aEVycm9ySGFuZGxpbmcoeG1sQ29udGVudCwgZmlsZU5hbWUgPSAndW5rbm93bicpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMueG1sUGFyc2VyLnBhcnNlKHhtbENvbnRlbnQpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBwYXJzZWQsIGVycm9yOiBudWxsIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwYXJzaW5nIFhNTCBmaWxlICR7ZmlsZU5hbWV9OmAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZGF0YTogbnVsbCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhbGlkYXRlWE1MU3RydWN0dXJlKHhtbENvbnRlbnQpIHtcclxuICAgIGlmICgheG1sQ29udGVudCB8fCB0eXBlb2YgeG1sQ29udGVudCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgWE1MIGNvbnRlbnQnIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF4bWxDb250ZW50LnRyaW0oKS5zdGFydHNXaXRoKCc8JykpIHtcclxuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0NvbnRlbnQgZG9lcyBub3QgYXBwZWFyIHRvIGJlIFhNTCcgfTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnhtbFBhcnNlci5wYXJzZSh4bWxDb250ZW50KTtcclxuICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGVycm9yOiBudWxsIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRyYWN0Um9vdEVsZW1lbnQocGFyc2VkWE1MKSB7XHJcbiAgICBpZiAoIXBhcnNlZFhNTCB8fCB0eXBlb2YgcGFyc2VkWE1MICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocGFyc2VkWE1MKTtcclxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gcGFyc2VkWE1MW2tleXNbMF1dO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJzZWRYTUw7XHJcbiAgfVxyXG5cclxuICBmaW5kRWxlbWVudHNCeUF0dHJpYnV0ZShvYmosIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlID0gbnVsbCkge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgXHJcbiAgICBjb25zdCBzZWFyY2ggPSAoY3VycmVudCwgcGF0aCA9ICcnKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ29iamVjdCcgJiYgY3VycmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgb2JqZWN0IGhhcyB0aGUgYXR0cmlidXRlXHJcbiAgICAgICAgaWYgKGN1cnJlbnRbYXR0cmlidXRlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlID09PSBudWxsIHx8IGN1cnJlbnRbYXR0cmlidXRlTmFtZV0gPT09IGF0dHJpYnV0ZVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgZWxlbWVudDogY3VycmVudCxcclxuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50W2F0dHJpYnV0ZU5hbWVdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VhcmNoIG5lc3RlZCBvYmplY3RzXHJcbiAgICAgICAgT2JqZWN0LmtleXMoY3VycmVudCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50W2tleV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaChjdXJyZW50W2tleV0sIHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWFyY2gob2JqKTtcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxuXHJcbiAgZmluZEVsZW1lbnRzQnlUeXBlKG9iaiwgZWxlbWVudFR5cGUpIHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgIFxyXG4gICAgY29uc3Qgc2VhcmNoID0gKGN1cnJlbnQsIHBhdGggPSAnJykgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBmb3VuZCB0aGUgZWxlbWVudCB0eXBlXHJcbiAgICAgICAgaWYgKGN1cnJlbnRbZWxlbWVudFR5cGVdKSB7XHJcbiAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IEFycmF5LmlzQXJyYXkoY3VycmVudFtlbGVtZW50VHlwZV0pIFxyXG4gICAgICAgICAgICA/IGN1cnJlbnRbZWxlbWVudFR5cGVdIFxyXG4gICAgICAgICAgICA6IFtjdXJyZW50W2VsZW1lbnRUeXBlXV07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICAgICAgICBwYXRoOiBgJHtwYXRofS4ke2VsZW1lbnRUeXBlfVske2luZGV4fV1gLFxyXG4gICAgICAgICAgICAgIHR5cGU6IGVsZW1lbnRUeXBlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb250aW51ZSBzZWFyY2hpbmcgaW4gbmVzdGVkIG9iamVjdHNcclxuICAgICAgICBPYmplY3Qua2V5cyhjdXJyZW50KS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRba2V5XSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBlbGVtZW50VHlwZSkge1xyXG4gICAgICAgICAgICBzZWFyY2goY3VycmVudFtrZXldLCBwYXRoID8gYCR7cGF0aH0uJHtrZXl9YCA6IGtleSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VhcmNoKG9iaik7XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIGV4dHJhY3RBbGxBdHRyaWJ1dGVzKG9iaiwgcHJlZml4ID0gJ0BfJykge1xyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgXHJcbiAgICBjb25zdCBleHRyYWN0ID0gKGN1cnJlbnQsIHBhdGggPSAnJykgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhjdXJyZW50KS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5O1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzW2Z1bGxQYXRoXSA9IGN1cnJlbnRba2V5XTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1cnJlbnRba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZXh0cmFjdChjdXJyZW50W2tleV0sIHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBleHRyYWN0KG9iaik7XHJcbiAgICByZXR1cm4gYXR0cmlidXRlcztcclxuICB9XHJcblxyXG4gIGdldEVsZW1lbnRIaWVyYXJjaHkob2JqLCBtYXhEZXB0aCA9IDUpIHtcclxuICAgIGNvbnN0IGhpZXJhcmNoeSA9IHt9O1xyXG4gICAgXHJcbiAgICBjb25zdCBidWlsZEhpZXJhcmNoeSA9IChjdXJyZW50LCBkZXB0aCA9IDAsIHBhdGggPSAnJykgPT4ge1xyXG4gICAgICBpZiAoZGVwdGggPj0gbWF4RGVwdGggfHwgdHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnIHx8IGN1cnJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGN1cnJlbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICBPYmplY3Qua2V5cyhjdXJyZW50KS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFtrZXldKSkge1xyXG4gICAgICAgICAgc3RydWN0dXJlW2tleV0gPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXHJcbiAgICAgICAgICAgIGxlbmd0aDogY3VycmVudFtrZXldLmxlbmd0aCxcclxuICAgICAgICAgICAgY2hpbGRyZW46IGN1cnJlbnRba2V5XS5sZW5ndGggPiAwIFxyXG4gICAgICAgICAgICAgID8gYnVpbGRIaWVyYXJjaHkoY3VycmVudFtrZXldWzBdLCBkZXB0aCArIDEsIGAke3BhdGh9LiR7a2V5fVswXWApXHJcbiAgICAgICAgICAgICAgOiBudWxsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1cnJlbnRba2V5XSA9PT0gJ29iamVjdCcgJiYgY3VycmVudFtrZXldICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHJ1Y3R1cmVba2V5XSA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBidWlsZEhpZXJhcmNoeShjdXJyZW50W2tleV0sIGRlcHRoICsgMSwgYCR7cGF0aH0uJHtrZXl9YClcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0cnVjdHVyZVtrZXldID0ge1xyXG4gICAgICAgICAgICB0eXBlOiB0eXBlb2YgY3VycmVudFtrZXldLFxyXG4gICAgICAgICAgICB2YWx1ZToga2V5LnN0YXJ0c1dpdGgoJ0BfJykgPyBjdXJyZW50W2tleV0gOiBudWxsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gc3RydWN0dXJlO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gYnVpbGRIaWVyYXJjaHkob2JqKTtcclxuICB9XHJcblxyXG4gIG5vcm1hbGl6ZVhNTENvbnRlbnQoeG1sQ29udGVudCkge1xyXG4gICAgcmV0dXJuIHhtbENvbnRlbnRcclxuICAgICAgLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJylcclxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxuJylcclxuICAgICAgLnRyaW0oKTtcclxuICB9XHJcblxyXG4gIGxvZ1hNTFN0cnVjdHVyZShwYXJzZWRYTUwsIG1heERlcHRoID0gMykge1xyXG4gICAgY29uc29sZS5sb2coJ1hNTCBTdHJ1Y3R1cmUgQW5hbHlzaXM6Jyk7XHJcbiAgICBcclxuICAgIGNvbnN0IGFuYWx5emVTdHJ1Y3R1cmUgPSAob2JqLCBkZXB0aCA9IDAsIHByZWZpeCA9ICcnKSA9PiB7XHJcbiAgICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XHJcbiAgICAgICAgY29uc3QgaW5kZW50ID0gJyAgJy5yZXBlYXQoZGVwdGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCR7aW5kZW50fSR7cHJlZml4fSR7a2V5fTogQXJyYXlbJHt2YWx1ZS5sZW5ndGh9XWApO1xyXG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHZhbHVlWzBdID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBhbmFseXplU3RydWN0dXJlKHZhbHVlWzBdLCBkZXB0aCArIDEsIGAke3ByZWZpeH0ke2tleX1bMF0uYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnR9JHtwcmVmaXh9JHtrZXl9OiBPYmplY3RgKTtcclxuICAgICAgICAgIGFuYWx5emVTdHJ1Y3R1cmUodmFsdWUsIGRlcHRoICsgMSwgYCR7cHJlZml4fSR7a2V5fS5gKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGtleS5zdGFydHNXaXRoKCdAXycpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnR9JHtwcmVmaXh9JHtrZXl9OiAke3R5cGVvZiB2YWx1ZX0gPSAke3ZhbHVlfWApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnR9JHtwcmVmaXh9JHtrZXl9OiAke3R5cGVvZiB2YWx1ZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBhbmFseXplU3RydWN0dXJlKHBhcnNlZFhNTCk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElETUxYTUxQYXJzZXI7ICJdLCJuYW1lcyI6WyJYTUxQYXJzZXIiLCJyZXF1aXJlIiwiSURNTFhNTFBhcnNlciIsImNvbnN0cnVjdG9yIiwieG1sUGFyc2VyIiwiaWdub3JlQXR0cmlidXRlcyIsImF0dHJpYnV0ZU5hbWVQcmVmaXgiLCJyZW1vdmVOU1ByZWZpeCIsInBhcnNlQXR0cmlidXRlVmFsdWUiLCJ0cmltVmFsdWVzIiwicGFyc2VUcnVlTnVtYmVyT25seSIsInRleHROb2RlTmFtZSIsInBhcnNlIiwieG1sQ29udGVudCIsImVycm9yIiwiY29uc29sZSIsInBhcnNlV2l0aEVycm9ySGFuZGxpbmciLCJmaWxlTmFtZSIsInBhcnNlZCIsInN1Y2Nlc3MiLCJkYXRhIiwibWVzc2FnZSIsInZhbGlkYXRlWE1MU3RydWN0dXJlIiwidmFsaWQiLCJ0cmltIiwic3RhcnRzV2l0aCIsImV4dHJhY3RSb290RWxlbWVudCIsInBhcnNlZFhNTCIsImtleXMiLCJPYmplY3QiLCJsZW5ndGgiLCJmaW5kRWxlbWVudHNCeUF0dHJpYnV0ZSIsIm9iaiIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVWYWx1ZSIsInJlc3VsdHMiLCJzZWFyY2giLCJjdXJyZW50IiwicGF0aCIsInVuZGVmaW5lZCIsInB1c2giLCJlbGVtZW50IiwidmFsdWUiLCJmb3JFYWNoIiwia2V5IiwiZmluZEVsZW1lbnRzQnlUeXBlIiwiZWxlbWVudFR5cGUiLCJlbGVtZW50cyIsIkFycmF5IiwiaXNBcnJheSIsImluZGV4IiwidHlwZSIsImV4dHJhY3RBbGxBdHRyaWJ1dGVzIiwicHJlZml4IiwiYXR0cmlidXRlcyIsImV4dHJhY3QiLCJmdWxsUGF0aCIsImdldEVsZW1lbnRIaWVyYXJjaHkiLCJtYXhEZXB0aCIsImhpZXJhcmNoeSIsImJ1aWxkSGllcmFyY2h5IiwiZGVwdGgiLCJzdHJ1Y3R1cmUiLCJjaGlsZHJlbiIsIm5vcm1hbGl6ZVhNTENvbnRlbnQiLCJyZXBsYWNlIiwibG9nWE1MU3RydWN0dXJlIiwibG9nIiwiYW5hbHl6ZVN0cnVjdHVyZSIsImluZGVudCIsInJlcGVhdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/parsers/XMLParser.js\n");

/***/ }),

/***/ "./lib/processors/ImageProcessor.js":
/*!******************************************!*\
  !*** ./lib/processors/ImageProcessor.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst IDMLUtils = __webpack_require__(/*! ../utils/IDMLUtils */ \"./lib/utils/IDMLUtils.js\");\nclass ImageProcessor {\n    constructor(fileExtractor){\n        this.fileExtractor = fileExtractor;\n    }\n    async processIDMLPackage(idmlFilePath, packageStructure, extractedImages = []) {\n        console.log(\"Processing IDML package:\", idmlFilePath);\n        try {\n            // Process linked images and update elements\n            const imageMap = await this.buildImageMap(packageStructure);\n            // Add extracted images to the map\n            extractedImages.forEach((embeddedInfo)=>{\n                imageMap.set(embeddedInfo.fileName, embeddedInfo.extractedPath);\n                console.log(`ðŸ“Ž Added extracted image to map: ${embeddedInfo.fileName}`);\n            });\n            return imageMap;\n        } catch (error) {\n            console.error(\"Error processing IDML package:\", error);\n            throw error;\n        }\n    }\n    async buildImageMap(packageStructure) {\n        const imageMap = new Map();\n        console.log(\"Building image map...\");\n        // Check all files in resourceMap first\n        if (packageStructure.resourceMap) {\n            packageStructure.resourceMap.forEach((filePath, fileName)=>{\n                if (IDMLUtils.isImageFile(fileName)) {\n                    imageMap.set(fileName, filePath);\n                    // Also add without extension for matching\n                    const nameWithoutExt = path.parse(fileName).name;\n                    imageMap.set(nameWithoutExt, filePath);\n                    console.log(\"Added to image map:\", fileName, \"->\", filePath);\n                }\n            });\n        }\n        // Check Links folder if it exists\n        if (packageStructure.linksFolder && fs.existsSync(packageStructure.linksFolder)) {\n            const files = fs.readdirSync(packageStructure.linksFolder);\n            console.log(\"Links folder contents:\", files);\n            for (const fileName of files){\n                if (IDMLUtils.isImageFile(fileName)) {\n                    const fullPath = path.join(packageStructure.linksFolder, fileName);\n                    imageMap.set(fileName, fullPath);\n                    const nameWithoutExt = path.parse(fileName).name;\n                    imageMap.set(nameWithoutExt, fullPath);\n                    console.log(\"Added from Links folder:\", fileName, \"->\", fullPath);\n                }\n            }\n        }\n        console.log(`ðŸ“¸ Image map built with ${imageMap.size / 2} unique images`);\n        Array.from(imageMap.keys()).forEach((key)=>{\n            console.log(\"  - Image key:\", key);\n        });\n        return imageMap;\n    }\n    async processLinkedResources(documentData, packageStructure, extractedImages = []) {\n        console.log(\"Processing linked resources...\");\n        const imageMap = await this.buildImageMap(packageStructure);\n        // Add extracted images to the map\n        extractedImages.forEach((embeddedInfo)=>{\n            imageMap.set(embeddedInfo.fileName, embeddedInfo.extractedPath);\n            console.log(`ðŸ“Ž Added extracted image to map: ${embeddedInfo.fileName}`);\n        });\n        // Process elements and link them to package resources\n        for (const element of documentData.elements || []){\n            if (this.hasImageReference(element)) {\n                await this.linkElementToImage(element, packageStructure, imageMap, extractedImages);\n            }\n            // Also check for nested elements (groups, etc.)\n            if (element.groupItems && element.groupItems.length > 0) {\n                for (const groupItem of element.groupItems){\n                    if (this.hasImageReference(groupItem)) {\n                        await this.linkElementToImage(groupItem, packageStructure, imageMap, extractedImages);\n                    }\n                }\n            }\n        }\n        await this.processTextImages(documentData, packageStructure, imageMap);\n        console.log(\"âœ… Linked resources processed\");\n        console.log(`ðŸ“Š Summary: ${imageMap.size - extractedImages.length} external images, ${extractedImages.length} extracted embedded images`);\n    }\n    hasImageReference(element) {\n        // ENHANCED: Check for embedded images first\n        if (element.isContentFrame && element.hasPlacedContent) {\n            return true;\n        }\n        // Check for embedded image data in element properties\n        if (element.placedContent && (element.placedContent.href || element.placedContent.imageTypeName || element.placedContent.actualPpi)) {\n            return true;\n        }\n        // For rectangles, check if they could be content frames\n        if (element.type === \"Rectangle\") {\n            return true; // Most rectangles are potential image containers\n        }\n        // ENHANCED: Check for embedded image indicators\n        const hasEmbeddedImage = element.name && element.name.includes(\"[\") && element.name.includes(\"]\") || // [YOUR IMAGE HERE]\n        element.fillColor && element.fillColor.includes(\"Image/\") || element.Properties && (element.Properties.Image || element.Properties.PlacedImage || element.Properties.EPS || element.Properties.PDF);\n        return hasEmbeddedImage || element.Image || element.Link || element.PlacedImage || element.imageReference || element.linkedImage;\n    }\n    findImageByName(searchName, imageMap) {\n        if (!searchName) return null;\n        // Remove file: prefix and any leading slashes\n        let cleanName = searchName.replace(/^file:/, \"\").replace(/^\\/+/, \"\");\n        // Only use the base filename for matching\n        const baseName = path.basename(cleanName);\n        const nameWithoutExt = path.parse(baseName).name;\n        // Try exact match first\n        if (imageMap.has(baseName)) {\n            return baseName;\n        }\n        // Try with Links/ prefix\n        if (imageMap.has(`Links/${baseName}`)) {\n            return `Links/${baseName}`;\n        }\n        // Try without extension\n        if (imageMap.has(nameWithoutExt)) {\n            return nameWithoutExt;\n        }\n        // Try partial matching (optional)\n        const possibleMatches = Array.from(imageMap.keys()).filter((key)=>key.toLowerCase().includes(baseName.toLowerCase()));\n        if (possibleMatches.length > 0) {\n            return possibleMatches[0];\n        }\n        return null;\n    }\n    async linkElementToImage(element, packageStructure, imageMap, extractedImages) {\n        console.log(\"\\uD83D\\uDD0D Linking images for element:\", element.id || element.self, element.type);\n        try {\n            let imageFileName = null;\n            const uploadId = packageStructure.uploadId;\n            // Check for embedded images first\n            const embeddedInfo = this.detectEmbeddedImages(element);\n            // --- EMBEDDED IMAGE HANDLING ---\n            if (embeddedInfo.hasEmbeddedContent) {\n                // Find the extracted image in ExtractedImages\n                const matchingExtractedImage = extractedImages?.find((img)=>img.fileName === embeddedInfo.embeddedFileName || img.fileName === element.placedContent?.fileName || img.fileName.toLowerCase() === (element.placedContent?.fileName || \"\").toLowerCase());\n                if (matchingExtractedImage) {\n                    element.linkedImage = {\n                        fileName: matchingExtractedImage.fileName,\n                        url: `/api/image/${uploadId}/ExtractedImages/${matchingExtractedImage.fileName}`,\n                        originalPath: matchingExtractedImage.extractedPath,\n                        isEmbedded: true,\n                        isExtracted: true,\n                        embeddedType: embeddedInfo.embeddedType,\n                        embeddedData: embeddedInfo.embeddedData,\n                        framePosition: element.position,\n                        imagePosition: element.imagePosition\n                    };\n                    console.log(`âœ… Linked extracted embedded image: ${matchingExtractedImage.fileName}`);\n                    return true;\n                } else {\n                    // Fallback to placeholder if no extracted image found\n                    element.linkedImage = {\n                        fileName: embeddedInfo.embeddedFileName || `embedded_${element.id || element.self}`,\n                        url: null,\n                        isEmbedded: true,\n                        embeddedType: embeddedInfo.embeddedType,\n                        embeddedData: embeddedInfo.embeddedData,\n                        framePosition: element.position,\n                        imagePosition: element.imagePosition\n                    };\n                    console.log(`ðŸ“‹ Created placeholder for embedded image: ${element.id || element.self}`);\n                    return true;\n                }\n            }\n            // --- LINKED IMAGE HANDLING ---\n            if (element.isContentFrame && element.hasPlacedContent) {\n                if (element.placedContent?.href) {\n                    const referencedImage = path.basename(element.placedContent.href);\n                    imageFileName = this.findImageByName(referencedImage, imageMap);\n                }\n                if (!imageFileName) {\n                    // No image found for this element, so do NOT auto-link the first image.\n                    // Optionally, log a warning:\n                    console.warn(`No image found for element ${element.id || element.self} with href: ${element.placedContent?.href}`);\n                    return false; // Stop here, don't assign a wrong image\n                }\n            }\n            if (imageFileName && imageMap.has(imageFileName)) {\n                // Determine if the image is in Links or ExtractedImages\n                let urlFolder = \"Links\";\n                let isEmbedded = \"false\";\n                const imagePath = imageMap.get(imageFileName);\n                if (imagePath && imagePath.includes(\"ExtractedImages\")) {\n                    urlFolder = \"ExtractedImages\";\n                    isEmbedded = \"true\";\n                }\n                element.linkedImage = {\n                    fileName: imageFileName,\n                    url: `/api/image/${uploadId}/${urlFolder}/${imageFileName}`,\n                    originalPath: imagePath,\n                    isEmbedded: isEmbedded,\n                    framePosition: element.position,\n                    imagePosition: element.imagePosition\n                };\n            }\n            console.log(`âŒ No image linked for ${element.id || element.self}`);\n            return true;\n        } catch (error) {\n            console.error(`âŒ Error linking image:`, error);\n            return false;\n        }\n    }\n    detectEmbeddedImages(element) {\n        const embeddedIndicators = {\n            hasEmbeddedContent: false,\n            embeddedType: null,\n            embeddedData: null,\n            embeddedFileName: null,\n            isPlaceholder: false\n        };\n        // Only set hasEmbeddedContent if there is actual base64 data\n        if (element.placedContent && element.placedContent.href && element.placedContent.isEmbedded) {\n            // Check if href is a large base64 string (not just a number or short string)\n            if (element.placedContent.href.length > 100) {\n                // adjust threshold as needed\n                embeddedIndicators.hasEmbeddedContent = true;\n                embeddedIndicators.embeddedType = element.placedContent.imageTypeName || \"unknown\";\n                embeddedIndicators.embeddedData = element.placedContent.href;\n                embeddedIndicators.embeddedFileName = `${element.placedContent.href}.${IDMLUtils.getImageExtension(element.placedContent.imageTypeName)}`;\n            }\n        }\n        return embeddedIndicators;\n    }\n    findElementImageReference(element, imageMap) {\n        // Check for placed content references\n        if (element.placedContent?.href) {\n            const imageName = path.basename(element.placedContent.href);\n            return this.findImageByName(imageName, imageMap);\n        }\n        // Check element name for image hints\n        if (element.name && element.name !== \"$ID/\") {\n            return this.findImageByName(element.name, imageMap);\n        }\n        return null;\n    }\n    matchImageBySize(element, imageMap) {\n        // TODO: Implement image size matching if metadata available\n        return null;\n    }\n    async processTextImages(documentData, packageStructure, imageMap) {\n        // Process images that might be embedded in text stories\n        Object.values(documentData.stories || {}).forEach((story)=>{\n            if (story.content && story.content.formattedContent) {\n                story.content.formattedContent.forEach((content)=>{\n                    // Look for image references in text content\n                    if (content.text && content.text.includes(\"Image/\")) {\n                        // Extract and process image references\n                        const imageRefs = content.text.match(/Image\\/[^\\s\\]]+/g);\n                        if (imageRefs) {\n                            imageRefs.forEach((ref)=>{\n                                const imageName = ref.replace(\"Image/\", \"\");\n                                const fileName = this.findImageByName(imageName, imageMap);\n                                if (fileName) {\n                                    content.linkedImage = fileName;\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n        });\n    }\n    async analyzeSpreadForImageReferences(idmlPath, xmlParser) {\n        console.log(\"\\n\\uD83D\\uDD0D === ANALYZING SPREADS FOR IMAGE REFERENCES ===\");\n        const spreadAnalysis = {\n            spreadsAnalyzed: 0,\n            imageReferences: [],\n            linkReferences: [],\n            placedContentDetails: []\n        };\n        try {\n            const extractedData = await this.fileExtractor.extractIDMLContents(idmlPath);\n            // Find spread files\n            const spreadFiles = Object.keys(extractedData).filter((name)=>name.startsWith(\"Spreads/\") && name.endsWith(\".xml\"));\n            // Analyze each spread\n            for (const spreadFile of spreadFiles){\n                try {\n                    const spreadContent = extractedData[spreadFile];\n                    const analysis = this.analyzeSpreadXMLForImages(spreadContent, spreadFile, xmlParser);\n                    spreadAnalysis.spreadsAnalyzed++;\n                    spreadAnalysis.imageReferences.push(...analysis.imageReferences);\n                    spreadAnalysis.linkReferences.push(...analysis.linkReferences);\n                    spreadAnalysis.placedContentDetails.push(...analysis.placedContentDetails);\n                } catch (error) {\n                    console.error(`Error analyzing ${spreadFile}:`, error);\n                }\n            }\n            return spreadAnalysis;\n        } catch (error) {\n            console.error(\"Error analyzing spreads for image references:\", error);\n            return spreadAnalysis;\n        }\n    }\n    analyzeSpreadXMLForImages(xmlContent, fileName, xmlParser) {\n        console.log(`ðŸ” Analyzing ${fileName} for image references...`);\n        const analysis = {\n            imageReferences: [],\n            linkReferences: [],\n            placedContentDetails: []\n        };\n        try {\n            const parsed = xmlParser.parse(xmlContent);\n            // Look for any image-related attributes\n            const findImageRefs = (obj, path = \"\")=>{\n                if (typeof obj === \"object\" && obj !== null) {\n                    Object.keys(obj).forEach((key)=>{\n                        const value = obj[key];\n                        // Look for href attributes\n                        if (key.includes(\"href\") || key.includes(\"Href\")) {\n                            analysis.linkReferences.push({\n                                file: fileName,\n                                path: `${path}.${key}`,\n                                value: value\n                            });\n                            console.log(`ðŸ”— Found href: ${path}.${key} = ${value}`);\n                        }\n                        // Look for image type names\n                        if (key.includes(\"ImageType\") || key.includes(\"imageType\")) {\n                            analysis.imageReferences.push({\n                                file: fileName,\n                                path: `${path}.${key}`,\n                                value: value\n                            });\n                            console.log(`ðŸ–¼ï¸ Found image type: ${path}.${key} = ${value}`);\n                        }\n                        // Look for Links or Link references\n                        if (key === \"Link\" || key === \"Links\") {\n                            analysis.linkReferences.push({\n                                file: fileName,\n                                path: `${path}.${key}`,\n                                value: JSON.stringify(value).substring(0, 200)\n                            });\n                            console.log(`ðŸ”— Found Link object at: ${path}.${key}`);\n                        }\n                        // Look for placed content\n                        if (key.includes(\"Image\") || key.includes(\"EPS\") || key.includes(\"PDF\")) {\n                            analysis.placedContentDetails.push({\n                                file: fileName,\n                                elementType: key,\n                                path: `${path}.${key}`,\n                                details: value\n                            });\n                            console.log(`ðŸ“Ž Found placed content: ${key} at ${path}`);\n                        }\n                        if (typeof value === \"object\") {\n                            findImageRefs(value, path ? `${path}.${key}` : key);\n                        }\n                    });\n                }\n            };\n            findImageRefs(parsed);\n        } catch (error) {\n            console.error(`Error parsing XML in ${fileName}:`, error);\n        }\n        return analysis;\n    }\n    async extractEmbeddedImageFromSpread(idmlPath, uploadDir, xmlParser) {\n        console.log(\"\\uD83D\\uDDBCï¸ Extracting embedded images from spread XML...\");\n        const embeddedImages = [];\n        try {\n            const spreadAnalysis = await this.analyzeSpreadForImageReferences(idmlPath, xmlParser);\n            for (const placedContent of spreadAnalysis.placedContentDetails){\n                if (placedContent.elementType === \"Image\" && placedContent.details && placedContent.details.Properties && placedContent.details.Properties.Contents) {\n                    const base64Data = placedContent.details.Properties.Contents;\n                    console.log(`ðŸ“· Found Base64 image data: ${base64Data.length} characters`);\n                    const linkInfo = placedContent.details.Link || {};\n                    const imageName = IDMLUtils.extractImageNameFromLink(linkInfo[\"@_LinkResourceURI\"]) || \"embedded_image\";\n                    const imageType = linkInfo[\"@_LinkResourceFormat\"] || \"$ID/JPEG\";\n                    const extension = IDMLUtils.getImageExtensionFromFormat(imageType);\n                    // Create filename with timestamp to avoid conflicts\n                    const fileName = `${imageName}.${extension}`;\n                    const outputPath = path.join(uploadDir, \"ExtractedImages\", fileName);\n                    // Create directory\n                    const outputDir = path.dirname(outputPath);\n                    if (!fs.existsSync(outputDir)) {\n                        fs.mkdirSync(outputDir, {\n                            recursive: true\n                        });\n                    }\n                    try {\n                        const imageBuffer = Buffer.from(base64Data, \"base64\");\n                        fs.writeFileSync(outputPath, imageBuffer);\n                        embeddedImages.push({\n                            originalPath: placedContent.path,\n                            extractedPath: outputPath,\n                            fileName: fileName,\n                            size: imageBuffer.length,\n                            base64Length: base64Data.length,\n                            linkInfo: linkInfo,\n                            isExtracted: true\n                        });\n                        console.log(`âœ… Extracted image: ${fileName} (${imageBuffer.length} bytes)`);\n                    } catch (error) {\n                        console.error(`âŒ Failed to convert Base64 to image:`, error);\n                    }\n                }\n            }\n        } catch (error) {\n            console.error(\"âŒ Error extracting embedded images from spread:\", error);\n        }\n        console.log(`âœ… Extracted ${embeddedImages.length} embedded images from spread`);\n        return embeddedImages;\n    }\n}\nmodule.exports = ImageProcessor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUksQ0FBQ2tILFlBQVk7d0JBQzVDcEosR0FBR2lLLGFBQWEsQ0FBQ1AsWUFBWUs7d0JBRTdCYixlQUFlZCxJQUFJLENBQUM7NEJBQ2xCOUMsY0FBY3JDLGNBQWNuRCxJQUFJOzRCQUNoQ21CLGVBQWV5STs0QkFDZjFJLFVBQVVBOzRCQUNWZ0IsTUFBTStILFlBQVluSCxNQUFNOzRCQUN4QnNILGNBQWNkLFdBQVd4RyxNQUFNOzRCQUMvQnlHLFVBQVVBOzRCQUNWN0QsYUFBYTt3QkFDZjt3QkFFQS9FLFFBQVFDLEdBQUcsQ0FDVCxDQUFDLG1CQUFtQixFQUFFTSxTQUFTLEVBQUUsRUFBRStJLFlBQVluSCxNQUFNLENBQUMsT0FBTyxDQUFDO29CQUVsRSxFQUFFLE9BQU8xQixPQUFPO3dCQUNkVCxRQUFRUyxLQUFLLENBQUMsQ0FBQyxvQ0FBb0MsQ0FBQyxFQUFFQTtvQkFDeEQ7Z0JBQ0Y7WUFDRjtRQUNGLEVBQUUsT0FBT0EsT0FBTztZQUNkVCxRQUFRUyxLQUFLLENBQUMsbURBQW1EQTtRQUNuRTtRQUVBVCxRQUFRQyxHQUFHLENBQ1QsQ0FBQyxZQUFZLEVBQUV3SSxlQUFldEcsTUFBTSxDQUFDLDRCQUE0QixDQUFDO1FBRXBFLE9BQU9zRztJQUNUO0FBQ0Y7QUFFQWlCLE9BQU9DLE9BQU8sR0FBR2xLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRtbC12aWV3ZXIvLi9saWIvcHJvY2Vzc29ycy9JbWFnZVByb2Nlc3Nvci5qcz9kNTEwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbmNvbnN0IElETUxVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9JRE1MVXRpbHNcIik7XHJcblxyXG5jbGFzcyBJbWFnZVByb2Nlc3NvciB7XHJcbiAgY29uc3RydWN0b3IoZmlsZUV4dHJhY3Rvcikge1xyXG4gICAgdGhpcy5maWxlRXh0cmFjdG9yID0gZmlsZUV4dHJhY3RvcjtcclxuICB9XHJcblxyXG4gIGFzeW5jIHByb2Nlc3NJRE1MUGFja2FnZShcclxuICAgIGlkbWxGaWxlUGF0aCxcclxuICAgIHBhY2thZ2VTdHJ1Y3R1cmUsXHJcbiAgICBleHRyYWN0ZWRJbWFnZXMgPSBbXVxyXG4gICkge1xyXG4gICAgY29uc29sZS5sb2coXCJQcm9jZXNzaW5nIElETUwgcGFja2FnZTpcIiwgaWRtbEZpbGVQYXRoKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBQcm9jZXNzIGxpbmtlZCBpbWFnZXMgYW5kIHVwZGF0ZSBlbGVtZW50c1xyXG4gICAgICBjb25zdCBpbWFnZU1hcCA9IGF3YWl0IHRoaXMuYnVpbGRJbWFnZU1hcChwYWNrYWdlU3RydWN0dXJlKTtcclxuXHJcbiAgICAgIC8vIEFkZCBleHRyYWN0ZWQgaW1hZ2VzIHRvIHRoZSBtYXBcclxuICAgICAgZXh0cmFjdGVkSW1hZ2VzLmZvckVhY2goKGVtYmVkZGVkSW5mbykgPT4ge1xyXG4gICAgICAgIGltYWdlTWFwLnNldChlbWJlZGRlZEluZm8uZmlsZU5hbWUsIGVtYmVkZGVkSW5mby5leHRyYWN0ZWRQYXRoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDwn5OOIEFkZGVkIGV4dHJhY3RlZCBpbWFnZSB0byBtYXA6ICR7ZW1iZWRkZWRJbmZvLmZpbGVOYW1lfWBcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBpbWFnZU1hcDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIElETUwgcGFja2FnZTpcIiwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGJ1aWxkSW1hZ2VNYXAocGFja2FnZVN0cnVjdHVyZSkge1xyXG4gICAgY29uc3QgaW1hZ2VNYXAgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJCdWlsZGluZyBpbWFnZSBtYXAuLi5cIik7XHJcblxyXG4gICAgLy8gQ2hlY2sgYWxsIGZpbGVzIGluIHJlc291cmNlTWFwIGZpcnN0XHJcbiAgICBpZiAocGFja2FnZVN0cnVjdHVyZS5yZXNvdXJjZU1hcCkge1xyXG4gICAgICBwYWNrYWdlU3RydWN0dXJlLnJlc291cmNlTWFwLmZvckVhY2goKGZpbGVQYXRoLCBmaWxlTmFtZSkgPT4ge1xyXG4gICAgICAgIGlmIChJRE1MVXRpbHMuaXNJbWFnZUZpbGUoZmlsZU5hbWUpKSB7XHJcbiAgICAgICAgICBpbWFnZU1hcC5zZXQoZmlsZU5hbWUsIGZpbGVQYXRoKTtcclxuXHJcbiAgICAgICAgICAvLyBBbHNvIGFkZCB3aXRob3V0IGV4dGVuc2lvbiBmb3IgbWF0Y2hpbmdcclxuICAgICAgICAgIGNvbnN0IG5hbWVXaXRob3V0RXh0ID0gcGF0aC5wYXJzZShmaWxlTmFtZSkubmFtZTtcclxuICAgICAgICAgIGltYWdlTWFwLnNldChuYW1lV2l0aG91dEV4dCwgZmlsZVBhdGgpO1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWRkZWQgdG8gaW1hZ2UgbWFwOlwiLCBmaWxlTmFtZSwgXCItPlwiLCBmaWxlUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBMaW5rcyBmb2xkZXIgaWYgaXQgZXhpc3RzXHJcbiAgICBpZiAoXHJcbiAgICAgIHBhY2thZ2VTdHJ1Y3R1cmUubGlua3NGb2xkZXIgJiZcclxuICAgICAgZnMuZXhpc3RzU3luYyhwYWNrYWdlU3RydWN0dXJlLmxpbmtzRm9sZGVyKVxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnN0IGZpbGVzID0gZnMucmVhZGRpclN5bmMocGFja2FnZVN0cnVjdHVyZS5saW5rc0ZvbGRlcik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiTGlua3MgZm9sZGVyIGNvbnRlbnRzOlwiLCBmaWxlcyk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIGZpbGVzKSB7XHJcbiAgICAgICAgaWYgKElETUxVdGlscy5pc0ltYWdlRmlsZShmaWxlTmFtZSkpIHtcclxuICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKHBhY2thZ2VTdHJ1Y3R1cmUubGlua3NGb2xkZXIsIGZpbGVOYW1lKTtcclxuICAgICAgICAgIGltYWdlTWFwLnNldChmaWxlTmFtZSwgZnVsbFBhdGgpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IG5hbWVXaXRob3V0RXh0ID0gcGF0aC5wYXJzZShmaWxlTmFtZSkubmFtZTtcclxuICAgICAgICAgIGltYWdlTWFwLnNldChuYW1lV2l0aG91dEV4dCwgZnVsbFBhdGgpO1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWRkZWQgZnJvbSBMaW5rcyBmb2xkZXI6XCIsIGZpbGVOYW1lLCBcIi0+XCIsIGZ1bGxQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+TuCBJbWFnZSBtYXAgYnVpbHQgd2l0aCAke2ltYWdlTWFwLnNpemUgLyAyfSB1bmlxdWUgaW1hZ2VzYCk7XHJcbiAgICBBcnJheS5mcm9tKGltYWdlTWFwLmtleXMoKSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiICAtIEltYWdlIGtleTpcIiwga2V5KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBpbWFnZU1hcDtcclxuICB9XHJcblxyXG4gIGFzeW5jIHByb2Nlc3NMaW5rZWRSZXNvdXJjZXMoXHJcbiAgICBkb2N1bWVudERhdGEsXHJcbiAgICBwYWNrYWdlU3RydWN0dXJlLFxyXG4gICAgZXh0cmFjdGVkSW1hZ2VzID0gW11cclxuICApIHtcclxuICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2luZyBsaW5rZWQgcmVzb3VyY2VzLi4uXCIpO1xyXG5cclxuICAgIGNvbnN0IGltYWdlTWFwID0gYXdhaXQgdGhpcy5idWlsZEltYWdlTWFwKHBhY2thZ2VTdHJ1Y3R1cmUpO1xyXG5cclxuICAgIC8vIEFkZCBleHRyYWN0ZWQgaW1hZ2VzIHRvIHRoZSBtYXBcclxuICAgIGV4dHJhY3RlZEltYWdlcy5mb3JFYWNoKChlbWJlZGRlZEluZm8pID0+IHtcclxuICAgICAgaW1hZ2VNYXAuc2V0KGVtYmVkZGVkSW5mby5maWxlTmFtZSwgZW1iZWRkZWRJbmZvLmV4dHJhY3RlZFBhdGgpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TjiBBZGRlZCBleHRyYWN0ZWQgaW1hZ2UgdG8gbWFwOiAke2VtYmVkZGVkSW5mby5maWxlTmFtZX1gKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFByb2Nlc3MgZWxlbWVudHMgYW5kIGxpbmsgdGhlbSB0byBwYWNrYWdlIHJlc291cmNlc1xyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRvY3VtZW50RGF0YS5lbGVtZW50cyB8fCBbXSkge1xyXG4gICAgICBpZiAodGhpcy5oYXNJbWFnZVJlZmVyZW5jZShlbGVtZW50KSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMubGlua0VsZW1lbnRUb0ltYWdlKFxyXG4gICAgICAgICAgZWxlbWVudCxcclxuICAgICAgICAgIHBhY2thZ2VTdHJ1Y3R1cmUsXHJcbiAgICAgICAgICBpbWFnZU1hcCxcclxuICAgICAgICAgIGV4dHJhY3RlZEltYWdlc1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFsc28gY2hlY2sgZm9yIG5lc3RlZCBlbGVtZW50cyAoZ3JvdXBzLCBldGMuKVxyXG4gICAgICBpZiAoZWxlbWVudC5ncm91cEl0ZW1zICYmIGVsZW1lbnQuZ3JvdXBJdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBncm91cEl0ZW0gb2YgZWxlbWVudC5ncm91cEl0ZW1zKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5oYXNJbWFnZVJlZmVyZW5jZShncm91cEl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubGlua0VsZW1lbnRUb0ltYWdlKFxyXG4gICAgICAgICAgICAgIGdyb3VwSXRlbSxcclxuICAgICAgICAgICAgICBwYWNrYWdlU3RydWN0dXJlLFxyXG4gICAgICAgICAgICAgIGltYWdlTWFwLFxyXG4gICAgICAgICAgICAgIGV4dHJhY3RlZEltYWdlc1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGF3YWl0IHRoaXMucHJvY2Vzc1RleHRJbWFnZXMoZG9jdW1lbnREYXRhLCBwYWNrYWdlU3RydWN0dXJlLCBpbWFnZU1hcCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCLinIUgTGlua2VkIHJlc291cmNlcyBwcm9jZXNzZWRcIik7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCfk4ogU3VtbWFyeTogJHtpbWFnZU1hcC5zaXplIC0gZXh0cmFjdGVkSW1hZ2VzLmxlbmd0aH0gZXh0ZXJuYWwgaW1hZ2VzLCAke1xyXG4gICAgICAgIGV4dHJhY3RlZEltYWdlcy5sZW5ndGhcclxuICAgICAgfSBleHRyYWN0ZWQgZW1iZWRkZWQgaW1hZ2VzYFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGhhc0ltYWdlUmVmZXJlbmNlKGVsZW1lbnQpIHtcclxuICAgIC8vIEVOSEFOQ0VEOiBDaGVjayBmb3IgZW1iZWRkZWQgaW1hZ2VzIGZpcnN0XHJcbiAgICBpZiAoZWxlbWVudC5pc0NvbnRlbnRGcmFtZSAmJiBlbGVtZW50Lmhhc1BsYWNlZENvbnRlbnQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIGVtYmVkZGVkIGltYWdlIGRhdGEgaW4gZWxlbWVudCBwcm9wZXJ0aWVzXHJcbiAgICBpZiAoXHJcbiAgICAgIGVsZW1lbnQucGxhY2VkQ29udGVudCAmJlxyXG4gICAgICAoZWxlbWVudC5wbGFjZWRDb250ZW50LmhyZWYgfHxcclxuICAgICAgICBlbGVtZW50LnBsYWNlZENvbnRlbnQuaW1hZ2VUeXBlTmFtZSB8fFxyXG4gICAgICAgIGVsZW1lbnQucGxhY2VkQ29udGVudC5hY3R1YWxQcGkpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yIHJlY3RhbmdsZXMsIGNoZWNrIGlmIHRoZXkgY291bGQgYmUgY29udGVudCBmcmFtZXNcclxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiUmVjdGFuZ2xlXCIpIHtcclxuICAgICAgcmV0dXJuIHRydWU7IC8vIE1vc3QgcmVjdGFuZ2xlcyBhcmUgcG90ZW50aWFsIGltYWdlIGNvbnRhaW5lcnNcclxuICAgIH1cclxuXHJcbiAgICAvLyBFTkhBTkNFRDogQ2hlY2sgZm9yIGVtYmVkZGVkIGltYWdlIGluZGljYXRvcnNcclxuICAgIGNvbnN0IGhhc0VtYmVkZGVkSW1hZ2UgPVxyXG4gICAgICAoZWxlbWVudC5uYW1lICYmXHJcbiAgICAgICAgZWxlbWVudC5uYW1lLmluY2x1ZGVzKFwiW1wiKSAmJlxyXG4gICAgICAgIGVsZW1lbnQubmFtZS5pbmNsdWRlcyhcIl1cIikpIHx8IC8vIFtZT1VSIElNQUdFIEhFUkVdXHJcbiAgICAgIChlbGVtZW50LmZpbGxDb2xvciAmJiBlbGVtZW50LmZpbGxDb2xvci5pbmNsdWRlcyhcIkltYWdlL1wiKSkgfHxcclxuICAgICAgKGVsZW1lbnQuUHJvcGVydGllcyAmJlxyXG4gICAgICAgIChlbGVtZW50LlByb3BlcnRpZXMuSW1hZ2UgfHxcclxuICAgICAgICAgIGVsZW1lbnQuUHJvcGVydGllcy5QbGFjZWRJbWFnZSB8fFxyXG4gICAgICAgICAgZWxlbWVudC5Qcm9wZXJ0aWVzLkVQUyB8fFxyXG4gICAgICAgICAgZWxlbWVudC5Qcm9wZXJ0aWVzLlBERikpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIGhhc0VtYmVkZGVkSW1hZ2UgfHxcclxuICAgICAgZWxlbWVudC5JbWFnZSB8fFxyXG4gICAgICBlbGVtZW50LkxpbmsgfHxcclxuICAgICAgZWxlbWVudC5QbGFjZWRJbWFnZSB8fFxyXG4gICAgICBlbGVtZW50LmltYWdlUmVmZXJlbmNlIHx8XHJcbiAgICAgIGVsZW1lbnQubGlua2VkSW1hZ2VcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmaW5kSW1hZ2VCeU5hbWUoc2VhcmNoTmFtZSwgaW1hZ2VNYXApIHtcclxuICAgIGlmICghc2VhcmNoTmFtZSkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGZpbGU6IHByZWZpeCBhbmQgYW55IGxlYWRpbmcgc2xhc2hlc1xyXG4gICAgbGV0IGNsZWFuTmFtZSA9IHNlYXJjaE5hbWUucmVwbGFjZSgvXmZpbGU6LywgXCJcIikucmVwbGFjZSgvXlxcLysvLCBcIlwiKTtcclxuXHJcbiAgICAvLyBPbmx5IHVzZSB0aGUgYmFzZSBmaWxlbmFtZSBmb3IgbWF0Y2hpbmdcclxuICAgIGNvbnN0IGJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShjbGVhbk5hbWUpO1xyXG4gICAgY29uc3QgbmFtZVdpdGhvdXRFeHQgPSBwYXRoLnBhcnNlKGJhc2VOYW1lKS5uYW1lO1xyXG5cclxuICAgIC8vIFRyeSBleGFjdCBtYXRjaCBmaXJzdFxyXG4gICAgaWYgKGltYWdlTWFwLmhhcyhiYXNlTmFtZSkpIHtcclxuICAgICAgcmV0dXJuIGJhc2VOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB3aXRoIExpbmtzLyBwcmVmaXhcclxuICAgIGlmIChpbWFnZU1hcC5oYXMoYExpbmtzLyR7YmFzZU5hbWV9YCkpIHtcclxuICAgICAgcmV0dXJuIGBMaW5rcy8ke2Jhc2VOYW1lfWA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IHdpdGhvdXQgZXh0ZW5zaW9uXHJcbiAgICBpZiAoaW1hZ2VNYXAuaGFzKG5hbWVXaXRob3V0RXh0KSkge1xyXG4gICAgICByZXR1cm4gbmFtZVdpdGhvdXRFeHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IHBhcnRpYWwgbWF0Y2hpbmcgKG9wdGlvbmFsKVxyXG4gICAgY29uc3QgcG9zc2libGVNYXRjaGVzID0gQXJyYXkuZnJvbShpbWFnZU1hcC5rZXlzKCkpLmZpbHRlcigoa2V5KSA9PlxyXG4gICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhiYXNlTmFtZS50b0xvd2VyQ2FzZSgpKVxyXG4gICAgKTtcclxuICAgIGlmIChwb3NzaWJsZU1hdGNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXR1cm4gcG9zc2libGVNYXRjaGVzWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgbGlua0VsZW1lbnRUb0ltYWdlKFxyXG4gICAgZWxlbWVudCxcclxuICAgIHBhY2thZ2VTdHJ1Y3R1cmUsXHJcbiAgICBpbWFnZU1hcCxcclxuICAgIGV4dHJhY3RlZEltYWdlc1xyXG4gICkge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwi8J+UjSBMaW5raW5nIGltYWdlcyBmb3IgZWxlbWVudDpcIixcclxuICAgICAgZWxlbWVudC5pZCB8fCBlbGVtZW50LnNlbGYsXHJcbiAgICAgIGVsZW1lbnQudHlwZVxyXG4gICAgKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGxldCBpbWFnZUZpbGVOYW1lID0gbnVsbDtcclxuICAgICAgY29uc3QgdXBsb2FkSWQgPSBwYWNrYWdlU3RydWN0dXJlLnVwbG9hZElkO1xyXG4gICAgICAvLyBDaGVjayBmb3IgZW1iZWRkZWQgaW1hZ2VzIGZpcnN0XHJcbiAgICAgIGNvbnN0IGVtYmVkZGVkSW5mbyA9IHRoaXMuZGV0ZWN0RW1iZWRkZWRJbWFnZXMoZWxlbWVudCk7XHJcbiAgICAgIC8vIC0tLSBFTUJFRERFRCBJTUFHRSBIQU5ETElORyAtLS1cclxuICAgICAgaWYgKGVtYmVkZGVkSW5mby5oYXNFbWJlZGRlZENvbnRlbnQpIHtcclxuICAgICAgICAvLyBGaW5kIHRoZSBleHRyYWN0ZWQgaW1hZ2UgaW4gRXh0cmFjdGVkSW1hZ2VzXHJcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdFeHRyYWN0ZWRJbWFnZSA9IGV4dHJhY3RlZEltYWdlcz8uZmluZChcclxuICAgICAgICAgIChpbWcpID0+XHJcbiAgICAgICAgICAgIGltZy5maWxlTmFtZSA9PT0gZW1iZWRkZWRJbmZvLmVtYmVkZGVkRmlsZU5hbWUgfHxcclxuICAgICAgICAgICAgaW1nLmZpbGVOYW1lID09PSBlbGVtZW50LnBsYWNlZENvbnRlbnQ/LmZpbGVOYW1lIHx8XHJcbiAgICAgICAgICAgIGltZy5maWxlTmFtZS50b0xvd2VyQ2FzZSgpID09PVxyXG4gICAgICAgICAgICAgIChlbGVtZW50LnBsYWNlZENvbnRlbnQ/LmZpbGVOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKClcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChtYXRjaGluZ0V4dHJhY3RlZEltYWdlKSB7XHJcbiAgICAgICAgICBlbGVtZW50LmxpbmtlZEltYWdlID0ge1xyXG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hpbmdFeHRyYWN0ZWRJbWFnZS5maWxlTmFtZSxcclxuICAgICAgICAgICAgdXJsOiBgL2FwaS9pbWFnZS8ke3VwbG9hZElkfS9FeHRyYWN0ZWRJbWFnZXMvJHttYXRjaGluZ0V4dHJhY3RlZEltYWdlLmZpbGVOYW1lfWAsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsUGF0aDogbWF0Y2hpbmdFeHRyYWN0ZWRJbWFnZS5leHRyYWN0ZWRQYXRoLFxyXG4gICAgICAgICAgICBpc0VtYmVkZGVkOiB0cnVlLFxyXG4gICAgICAgICAgICBpc0V4dHJhY3RlZDogdHJ1ZSxcclxuICAgICAgICAgICAgZW1iZWRkZWRUeXBlOiBlbWJlZGRlZEluZm8uZW1iZWRkZWRUeXBlLFxyXG4gICAgICAgICAgICBlbWJlZGRlZERhdGE6IGVtYmVkZGVkSW5mby5lbWJlZGRlZERhdGEsXHJcbiAgICAgICAgICAgIGZyYW1lUG9zaXRpb246IGVsZW1lbnQucG9zaXRpb24sXHJcbiAgICAgICAgICAgIGltYWdlUG9zaXRpb246IGVsZW1lbnQuaW1hZ2VQb3NpdGlvbixcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYOKchSBMaW5rZWQgZXh0cmFjdGVkIGVtYmVkZGVkIGltYWdlOiAke21hdGNoaW5nRXh0cmFjdGVkSW1hZ2UuZmlsZU5hbWV9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBwbGFjZWhvbGRlciBpZiBubyBleHRyYWN0ZWQgaW1hZ2UgZm91bmRcclxuICAgICAgICAgIGVsZW1lbnQubGlua2VkSW1hZ2UgPSB7XHJcbiAgICAgICAgICAgIGZpbGVOYW1lOlxyXG4gICAgICAgICAgICAgIGVtYmVkZGVkSW5mby5lbWJlZGRlZEZpbGVOYW1lIHx8XHJcbiAgICAgICAgICAgICAgYGVtYmVkZGVkXyR7ZWxlbWVudC5pZCB8fCBlbGVtZW50LnNlbGZ9YCxcclxuICAgICAgICAgICAgdXJsOiBudWxsLFxyXG4gICAgICAgICAgICBpc0VtYmVkZGVkOiB0cnVlLFxyXG4gICAgICAgICAgICBlbWJlZGRlZFR5cGU6IGVtYmVkZGVkSW5mby5lbWJlZGRlZFR5cGUsXHJcbiAgICAgICAgICAgIGVtYmVkZGVkRGF0YTogZW1iZWRkZWRJbmZvLmVtYmVkZGVkRGF0YSxcclxuICAgICAgICAgICAgZnJhbWVQb3NpdGlvbjogZWxlbWVudC5wb3NpdGlvbixcclxuICAgICAgICAgICAgaW1hZ2VQb3NpdGlvbjogZWxlbWVudC5pbWFnZVBvc2l0aW9uLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBg8J+TiyBDcmVhdGVkIHBsYWNlaG9sZGVyIGZvciBlbWJlZGRlZCBpbWFnZTogJHtcclxuICAgICAgICAgICAgICBlbGVtZW50LmlkIHx8IGVsZW1lbnQuc2VsZlxyXG4gICAgICAgICAgICB9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyAtLS0gTElOS0VEIElNQUdFIEhBTkRMSU5HIC0tLVxyXG4gICAgICBpZiAoZWxlbWVudC5pc0NvbnRlbnRGcmFtZSAmJiBlbGVtZW50Lmhhc1BsYWNlZENvbnRlbnQpIHtcclxuICAgICAgICBpZiAoZWxlbWVudC5wbGFjZWRDb250ZW50Py5ocmVmKSB7XHJcbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VkSW1hZ2UgPSBwYXRoLmJhc2VuYW1lKGVsZW1lbnQucGxhY2VkQ29udGVudC5ocmVmKTtcclxuICAgICAgICAgIGltYWdlRmlsZU5hbWUgPSB0aGlzLmZpbmRJbWFnZUJ5TmFtZShyZWZlcmVuY2VkSW1hZ2UsIGltYWdlTWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpbWFnZUZpbGVOYW1lKSB7XHJcbiAgICAgICAgICAvLyBObyBpbWFnZSBmb3VuZCBmb3IgdGhpcyBlbGVtZW50LCBzbyBkbyBOT1QgYXV0by1saW5rIHRoZSBmaXJzdCBpbWFnZS5cclxuICAgICAgICAgIC8vIE9wdGlvbmFsbHksIGxvZyBhIHdhcm5pbmc6XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgIGBObyBpbWFnZSBmb3VuZCBmb3IgZWxlbWVudCAke1xyXG4gICAgICAgICAgICAgIGVsZW1lbnQuaWQgfHwgZWxlbWVudC5zZWxmXHJcbiAgICAgICAgICAgIH0gd2l0aCBocmVmOiAke2VsZW1lbnQucGxhY2VkQ29udGVudD8uaHJlZn1gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTdG9wIGhlcmUsIGRvbid0IGFzc2lnbiBhIHdyb25nIGltYWdlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbWFnZUZpbGVOYW1lICYmIGltYWdlTWFwLmhhcyhpbWFnZUZpbGVOYW1lKSkge1xyXG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgaW1hZ2UgaXMgaW4gTGlua3Mgb3IgRXh0cmFjdGVkSW1hZ2VzXHJcbiAgICAgICAgbGV0IHVybEZvbGRlciA9IFwiTGlua3NcIjtcclxuICAgICAgICBsZXQgaXNFbWJlZGRlZCA9IFwiZmFsc2VcIjtcclxuICAgICAgICBjb25zdCBpbWFnZVBhdGggPSBpbWFnZU1hcC5nZXQoaW1hZ2VGaWxlTmFtZSk7XHJcbiAgICAgICAgaWYgKGltYWdlUGF0aCAmJiBpbWFnZVBhdGguaW5jbHVkZXMoXCJFeHRyYWN0ZWRJbWFnZXNcIikpIHtcclxuICAgICAgICAgIHVybEZvbGRlciA9IFwiRXh0cmFjdGVkSW1hZ2VzXCI7XHJcbiAgICAgICAgICBpc0VtYmVkZGVkID0gXCJ0cnVlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQubGlua2VkSW1hZ2UgPSB7XHJcbiAgICAgICAgICBmaWxlTmFtZTogaW1hZ2VGaWxlTmFtZSxcclxuICAgICAgICAgIHVybDogYC9hcGkvaW1hZ2UvJHt1cGxvYWRJZH0vJHt1cmxGb2xkZXJ9LyR7aW1hZ2VGaWxlTmFtZX1gLFxyXG4gICAgICAgICAgb3JpZ2luYWxQYXRoOiBpbWFnZVBhdGgsXHJcbiAgICAgICAgICBpc0VtYmVkZGVkOiBpc0VtYmVkZGVkLFxyXG4gICAgICAgICAgZnJhbWVQb3NpdGlvbjogZWxlbWVudC5wb3NpdGlvbixcclxuICAgICAgICAgIGltYWdlUG9zaXRpb246IGVsZW1lbnQuaW1hZ2VQb3NpdGlvbixcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinYwgTm8gaW1hZ2UgbGlua2VkIGZvciAke2VsZW1lbnQuaWQgfHwgZWxlbWVudC5zZWxmfWApO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBsaW5raW5nIGltYWdlOmAsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICBkZXRlY3RFbWJlZGRlZEltYWdlcyhlbGVtZW50KSB7XHJcbiAgICBjb25zdCBlbWJlZGRlZEluZGljYXRvcnMgPSB7XHJcbiAgICAgIGhhc0VtYmVkZGVkQ29udGVudDogZmFsc2UsXHJcbiAgICAgIGVtYmVkZGVkVHlwZTogbnVsbCxcclxuICAgICAgZW1iZWRkZWREYXRhOiBudWxsLFxyXG4gICAgICBlbWJlZGRlZEZpbGVOYW1lOiBudWxsLFxyXG4gICAgICBpc1BsYWNlaG9sZGVyOiBmYWxzZSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gT25seSBzZXQgaGFzRW1iZWRkZWRDb250ZW50IGlmIHRoZXJlIGlzIGFjdHVhbCBiYXNlNjQgZGF0YVxyXG4gICAgaWYgKFxyXG4gICAgICBlbGVtZW50LnBsYWNlZENvbnRlbnQgJiZcclxuICAgICAgZWxlbWVudC5wbGFjZWRDb250ZW50LmhyZWYgJiZcclxuICAgICAgZWxlbWVudC5wbGFjZWRDb250ZW50LmlzRW1iZWRkZWRcclxuICAgICkge1xyXG4gICAgICAvLyBDaGVjayBpZiBocmVmIGlzIGEgbGFyZ2UgYmFzZTY0IHN0cmluZyAobm90IGp1c3QgYSBudW1iZXIgb3Igc2hvcnQgc3RyaW5nKVxyXG4gICAgICBpZiAoZWxlbWVudC5wbGFjZWRDb250ZW50LmhyZWYubGVuZ3RoID4gMTAwKSB7XHJcbiAgICAgICAgLy8gYWRqdXN0IHRocmVzaG9sZCBhcyBuZWVkZWRcclxuICAgICAgICBlbWJlZGRlZEluZGljYXRvcnMuaGFzRW1iZWRkZWRDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICBlbWJlZGRlZEluZGljYXRvcnMuZW1iZWRkZWRUeXBlID1cclxuICAgICAgICAgIGVsZW1lbnQucGxhY2VkQ29udGVudC5pbWFnZVR5cGVOYW1lIHx8IFwidW5rbm93blwiO1xyXG4gICAgICAgIGVtYmVkZGVkSW5kaWNhdG9ycy5lbWJlZGRlZERhdGEgPSBlbGVtZW50LnBsYWNlZENvbnRlbnQuaHJlZjtcclxuICAgICAgICBlbWJlZGRlZEluZGljYXRvcnMuZW1iZWRkZWRGaWxlTmFtZSA9IGAke1xyXG4gICAgICAgICAgZWxlbWVudC5wbGFjZWRDb250ZW50LmhyZWZcclxuICAgICAgICB9LiR7SURNTFV0aWxzLmdldEltYWdlRXh0ZW5zaW9uKGVsZW1lbnQucGxhY2VkQ29udGVudC5pbWFnZVR5cGVOYW1lKX1gO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVtYmVkZGVkSW5kaWNhdG9ycztcclxuICB9XHJcblxyXG4gIGZpbmRFbGVtZW50SW1hZ2VSZWZlcmVuY2UoZWxlbWVudCwgaW1hZ2VNYXApIHtcclxuICAgIC8vIENoZWNrIGZvciBwbGFjZWQgY29udGVudCByZWZlcmVuY2VzXHJcbiAgICBpZiAoZWxlbWVudC5wbGFjZWRDb250ZW50Py5ocmVmKSB7XHJcbiAgICAgIGNvbnN0IGltYWdlTmFtZSA9IHBhdGguYmFzZW5hbWUoZWxlbWVudC5wbGFjZWRDb250ZW50LmhyZWYpO1xyXG4gICAgICByZXR1cm4gdGhpcy5maW5kSW1hZ2VCeU5hbWUoaW1hZ2VOYW1lLCBpbWFnZU1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZWxlbWVudCBuYW1lIGZvciBpbWFnZSBoaW50c1xyXG4gICAgaWYgKGVsZW1lbnQubmFtZSAmJiBlbGVtZW50Lm5hbWUgIT09IFwiJElEL1wiKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbmRJbWFnZUJ5TmFtZShlbGVtZW50Lm5hbWUsIGltYWdlTWFwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIG1hdGNoSW1hZ2VCeVNpemUoZWxlbWVudCwgaW1hZ2VNYXApIHtcclxuICAgIC8vIFRPRE86IEltcGxlbWVudCBpbWFnZSBzaXplIG1hdGNoaW5nIGlmIG1ldGFkYXRhIGF2YWlsYWJsZVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcm9jZXNzVGV4dEltYWdlcyhkb2N1bWVudERhdGEsIHBhY2thZ2VTdHJ1Y3R1cmUsIGltYWdlTWFwKSB7XHJcbiAgICAvLyBQcm9jZXNzIGltYWdlcyB0aGF0IG1pZ2h0IGJlIGVtYmVkZGVkIGluIHRleHQgc3Rvcmllc1xyXG4gICAgT2JqZWN0LnZhbHVlcyhkb2N1bWVudERhdGEuc3RvcmllcyB8fCB7fSkuZm9yRWFjaCgoc3RvcnkpID0+IHtcclxuICAgICAgaWYgKHN0b3J5LmNvbnRlbnQgJiYgc3RvcnkuY29udGVudC5mb3JtYXR0ZWRDb250ZW50KSB7XHJcbiAgICAgICAgc3RvcnkuY29udGVudC5mb3JtYXR0ZWRDb250ZW50LmZvckVhY2goKGNvbnRlbnQpID0+IHtcclxuICAgICAgICAgIC8vIExvb2sgZm9yIGltYWdlIHJlZmVyZW5jZXMgaW4gdGV4dCBjb250ZW50XHJcbiAgICAgICAgICBpZiAoY29udGVudC50ZXh0ICYmIGNvbnRlbnQudGV4dC5pbmNsdWRlcyhcIkltYWdlL1wiKSkge1xyXG4gICAgICAgICAgICAvLyBFeHRyYWN0IGFuZCBwcm9jZXNzIGltYWdlIHJlZmVyZW5jZXNcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VSZWZzID0gY29udGVudC50ZXh0Lm1hdGNoKC9JbWFnZVxcL1teXFxzXFxdXSsvZyk7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZVJlZnMpIHtcclxuICAgICAgICAgICAgICBpbWFnZVJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZU5hbWUgPSByZWYucmVwbGFjZShcIkltYWdlL1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5maW5kSW1hZ2VCeU5hbWUoaW1hZ2VOYW1lLCBpbWFnZU1hcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgY29udGVudC5saW5rZWRJbWFnZSA9IGZpbGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYW5hbHl6ZVNwcmVhZEZvckltYWdlUmVmZXJlbmNlcyhpZG1sUGF0aCwgeG1sUGFyc2VyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlxcbvCflI0gPT09IEFOQUxZWklORyBTUFJFQURTIEZPUiBJTUFHRSBSRUZFUkVOQ0VTID09PVwiKTtcclxuXHJcbiAgICBjb25zdCBzcHJlYWRBbmFseXNpcyA9IHtcclxuICAgICAgc3ByZWFkc0FuYWx5emVkOiAwLFxyXG4gICAgICBpbWFnZVJlZmVyZW5jZXM6IFtdLFxyXG4gICAgICBsaW5rUmVmZXJlbmNlczogW10sXHJcbiAgICAgIHBsYWNlZENvbnRlbnREZXRhaWxzOiBbXSxcclxuICAgIH07XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZXh0cmFjdGVkRGF0YSA9IGF3YWl0IHRoaXMuZmlsZUV4dHJhY3Rvci5leHRyYWN0SURNTENvbnRlbnRzKFxyXG4gICAgICAgIGlkbWxQYXRoXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBGaW5kIHNwcmVhZCBmaWxlc1xyXG4gICAgICBjb25zdCBzcHJlYWRGaWxlcyA9IE9iamVjdC5rZXlzKGV4dHJhY3RlZERhdGEpLmZpbHRlcihcclxuICAgICAgICAobmFtZSkgPT4gbmFtZS5zdGFydHNXaXRoKFwiU3ByZWFkcy9cIikgJiYgbmFtZS5lbmRzV2l0aChcIi54bWxcIilcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEFuYWx5emUgZWFjaCBzcHJlYWRcclxuICAgICAgZm9yIChjb25zdCBzcHJlYWRGaWxlIG9mIHNwcmVhZEZpbGVzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHNwcmVhZENvbnRlbnQgPSBleHRyYWN0ZWREYXRhW3NwcmVhZEZpbGVdO1xyXG4gICAgICAgICAgY29uc3QgYW5hbHlzaXMgPSB0aGlzLmFuYWx5emVTcHJlYWRYTUxGb3JJbWFnZXMoXHJcbiAgICAgICAgICAgIHNwcmVhZENvbnRlbnQsXHJcbiAgICAgICAgICAgIHNwcmVhZEZpbGUsXHJcbiAgICAgICAgICAgIHhtbFBhcnNlclxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBzcHJlYWRBbmFseXNpcy5zcHJlYWRzQW5hbHl6ZWQrKztcclxuICAgICAgICAgIHNwcmVhZEFuYWx5c2lzLmltYWdlUmVmZXJlbmNlcy5wdXNoKC4uLmFuYWx5c2lzLmltYWdlUmVmZXJlbmNlcyk7XHJcbiAgICAgICAgICBzcHJlYWRBbmFseXNpcy5saW5rUmVmZXJlbmNlcy5wdXNoKC4uLmFuYWx5c2lzLmxpbmtSZWZlcmVuY2VzKTtcclxuICAgICAgICAgIHNwcmVhZEFuYWx5c2lzLnBsYWNlZENvbnRlbnREZXRhaWxzLnB1c2goXHJcbiAgICAgICAgICAgIC4uLmFuYWx5c2lzLnBsYWNlZENvbnRlbnREZXRhaWxzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhbmFseXppbmcgJHtzcHJlYWRGaWxlfTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3ByZWFkQW5hbHlzaXM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYW5hbHl6aW5nIHNwcmVhZHMgZm9yIGltYWdlIHJlZmVyZW5jZXM6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHNwcmVhZEFuYWx5c2lzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYW5hbHl6ZVNwcmVhZFhNTEZvckltYWdlcyh4bWxDb250ZW50LCBmaWxlTmFtZSwgeG1sUGFyc2VyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBBbmFseXppbmcgJHtmaWxlTmFtZX0gZm9yIGltYWdlIHJlZmVyZW5jZXMuLi5gKTtcclxuXHJcbiAgICBjb25zdCBhbmFseXNpcyA9IHtcclxuICAgICAgaW1hZ2VSZWZlcmVuY2VzOiBbXSxcclxuICAgICAgbGlua1JlZmVyZW5jZXM6IFtdLFxyXG4gICAgICBwbGFjZWRDb250ZW50RGV0YWlsczogW10sXHJcbiAgICB9O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHhtbFBhcnNlci5wYXJzZSh4bWxDb250ZW50KTtcclxuXHJcbiAgICAgIC8vIExvb2sgZm9yIGFueSBpbWFnZS1yZWxhdGVkIGF0dHJpYnV0ZXNcclxuICAgICAgY29uc3QgZmluZEltYWdlUmVmcyA9IChvYmosIHBhdGggPSBcIlwiKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xyXG5cclxuICAgICAgICAgICAgLy8gTG9vayBmb3IgaHJlZiBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgIGlmIChrZXkuaW5jbHVkZXMoXCJocmVmXCIpIHx8IGtleS5pbmNsdWRlcyhcIkhyZWZcIikpIHtcclxuICAgICAgICAgICAgICBhbmFseXNpcy5saW5rUmVmZXJlbmNlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGZpbGU6IGZpbGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogYCR7cGF0aH0uJHtrZXl9YCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UlyBGb3VuZCBocmVmOiAke3BhdGh9LiR7a2V5fSA9ICR7dmFsdWV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGltYWdlIHR5cGUgbmFtZXNcclxuICAgICAgICAgICAgaWYgKGtleS5pbmNsdWRlcyhcIkltYWdlVHlwZVwiKSB8fCBrZXkuaW5jbHVkZXMoXCJpbWFnZVR5cGVcIikpIHtcclxuICAgICAgICAgICAgICBhbmFseXNpcy5pbWFnZVJlZmVyZW5jZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBmaWxlOiBmaWxlTmFtZSxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGAke3BhdGh9LiR7a2V5fWAsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflrzvuI8gRm91bmQgaW1hZ2UgdHlwZTogJHtwYXRofS4ke2tleX0gPSAke3ZhbHVlfWApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMb29rIGZvciBMaW5rcyBvciBMaW5rIHJlZmVyZW5jZXNcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJMaW5rXCIgfHwga2V5ID09PSBcIkxpbmtzXCIpIHtcclxuICAgICAgICAgICAgICBhbmFseXNpcy5saW5rUmVmZXJlbmNlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGZpbGU6IGZpbGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogYCR7cGF0aH0uJHtrZXl9YCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkuc3Vic3RyaW5nKDAsIDIwMCksXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflJcgRm91bmQgTGluayBvYmplY3QgYXQ6ICR7cGF0aH0uJHtrZXl9YCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIHBsYWNlZCBjb250ZW50XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICBrZXkuaW5jbHVkZXMoXCJJbWFnZVwiKSB8fFxyXG4gICAgICAgICAgICAgIGtleS5pbmNsdWRlcyhcIkVQU1wiKSB8fFxyXG4gICAgICAgICAgICAgIGtleS5pbmNsdWRlcyhcIlBERlwiKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBhbmFseXNpcy5wbGFjZWRDb250ZW50RGV0YWlscy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGZpbGU6IGZpbGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudFR5cGU6IGtleSxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGAke3BhdGh9LiR7a2V5fWAsXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB2YWx1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjiBGb3VuZCBwbGFjZWQgY29udGVudDogJHtrZXl9IGF0ICR7cGF0aH1gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgIGZpbmRJbWFnZVJlZnModmFsdWUsIHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgZmluZEltYWdlUmVmcyhwYXJzZWQpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcGFyc2luZyBYTUwgaW4gJHtmaWxlTmFtZX06YCwgZXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhbmFseXNpcztcclxuICB9XHJcblxyXG4gIGFzeW5jIGV4dHJhY3RFbWJlZGRlZEltYWdlRnJvbVNwcmVhZChpZG1sUGF0aCwgdXBsb2FkRGlyLCB4bWxQYXJzZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKFwi8J+WvO+4jyBFeHRyYWN0aW5nIGVtYmVkZGVkIGltYWdlcyBmcm9tIHNwcmVhZCBYTUwuLi5cIik7XHJcblxyXG4gICAgY29uc3QgZW1iZWRkZWRJbWFnZXMgPSBbXTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzcHJlYWRBbmFseXNpcyA9IGF3YWl0IHRoaXMuYW5hbHl6ZVNwcmVhZEZvckltYWdlUmVmZXJlbmNlcyhcclxuICAgICAgICBpZG1sUGF0aCxcclxuICAgICAgICB4bWxQYXJzZXJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgcGxhY2VkQ29udGVudCBvZiBzcHJlYWRBbmFseXNpcy5wbGFjZWRDb250ZW50RGV0YWlscykge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHBsYWNlZENvbnRlbnQuZWxlbWVudFR5cGUgPT09IFwiSW1hZ2VcIiAmJlxyXG4gICAgICAgICAgcGxhY2VkQ29udGVudC5kZXRhaWxzICYmXHJcbiAgICAgICAgICBwbGFjZWRDb250ZW50LmRldGFpbHMuUHJvcGVydGllcyAmJlxyXG4gICAgICAgICAgcGxhY2VkQ29udGVudC5kZXRhaWxzLlByb3BlcnRpZXMuQ29udGVudHNcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSBwbGFjZWRDb250ZW50LmRldGFpbHMuUHJvcGVydGllcy5Db250ZW50cztcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBg8J+TtyBGb3VuZCBCYXNlNjQgaW1hZ2UgZGF0YTogJHtiYXNlNjREYXRhLmxlbmd0aH0gY2hhcmFjdGVyc2BcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgY29uc3QgbGlua0luZm8gPSBwbGFjZWRDb250ZW50LmRldGFpbHMuTGluayB8fCB7fTtcclxuICAgICAgICAgIGNvbnN0IGltYWdlTmFtZSA9XHJcbiAgICAgICAgICAgIElETUxVdGlscy5leHRyYWN0SW1hZ2VOYW1lRnJvbUxpbmsobGlua0luZm9bXCJAX0xpbmtSZXNvdXJjZVVSSVwiXSkgfHxcclxuICAgICAgICAgICAgXCJlbWJlZGRlZF9pbWFnZVwiO1xyXG4gICAgICAgICAgY29uc3QgaW1hZ2VUeXBlID0gbGlua0luZm9bXCJAX0xpbmtSZXNvdXJjZUZvcm1hdFwiXSB8fCBcIiRJRC9KUEVHXCI7XHJcbiAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBJRE1MVXRpbHMuZ2V0SW1hZ2VFeHRlbnNpb25Gcm9tRm9ybWF0KGltYWdlVHlwZSk7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIGZpbGVuYW1lIHdpdGggdGltZXN0YW1wIHRvIGF2b2lkIGNvbmZsaWN0c1xyXG4gICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBgJHtpbWFnZU5hbWV9LiR7ZXh0ZW5zaW9ufWA7XHJcbiAgICAgICAgICBjb25zdCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKHVwbG9hZERpciwgXCJFeHRyYWN0ZWRJbWFnZXNcIiwgZmlsZU5hbWUpO1xyXG5cclxuICAgICAgICAgIC8vIENyZWF0ZSBkaXJlY3RvcnlcclxuICAgICAgICAgIGNvbnN0IG91dHB1dERpciA9IHBhdGguZGlybmFtZShvdXRwdXRQYXRoKTtcclxuICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhvdXRwdXREaXIpKSB7XHJcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhvdXRwdXREaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlQnVmZmVyID0gQnVmZmVyLmZyb20oYmFzZTY0RGF0YSwgXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0UGF0aCwgaW1hZ2VCdWZmZXIpO1xyXG5cclxuICAgICAgICAgICAgZW1iZWRkZWRJbWFnZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgb3JpZ2luYWxQYXRoOiBwbGFjZWRDb250ZW50LnBhdGgsXHJcbiAgICAgICAgICAgICAgZXh0cmFjdGVkUGF0aDogb3V0cHV0UGF0aCxcclxuICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXHJcbiAgICAgICAgICAgICAgc2l6ZTogaW1hZ2VCdWZmZXIubGVuZ3RoLFxyXG4gICAgICAgICAgICAgIGJhc2U2NExlbmd0aDogYmFzZTY0RGF0YS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgbGlua0luZm86IGxpbmtJbmZvLFxyXG4gICAgICAgICAgICAgIGlzRXh0cmFjdGVkOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgIGDinIUgRXh0cmFjdGVkIGltYWdlOiAke2ZpbGVOYW1lfSAoJHtpbWFnZUJ1ZmZlci5sZW5ndGh9IGJ5dGVzKWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gY29udmVydCBCYXNlNjQgdG8gaW1hZ2U6YCwgZXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBleHRyYWN0aW5nIGVtYmVkZGVkIGltYWdlcyBmcm9tIHNwcmVhZDpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBg4pyFIEV4dHJhY3RlZCAke2VtYmVkZGVkSW1hZ2VzLmxlbmd0aH0gZW1iZWRkZWQgaW1hZ2VzIGZyb20gc3ByZWFkYFxyXG4gICAgKTtcclxuICAgIHJldHVybiBlbWJlZGRlZEltYWdlcztcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VQcm9jZXNzb3I7XHJcbiJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImZzIiwiSURNTFV0aWxzIiwiSW1hZ2VQcm9jZXNzb3IiLCJjb25zdHJ1Y3RvciIsImZpbGVFeHRyYWN0b3IiLCJwcm9jZXNzSURNTFBhY2thZ2UiLCJpZG1sRmlsZVBhdGgiLCJwYWNrYWdlU3RydWN0dXJlIiwiZXh0cmFjdGVkSW1hZ2VzIiwiY29uc29sZSIsImxvZyIsImltYWdlTWFwIiwiYnVpbGRJbWFnZU1hcCIsImZvckVhY2giLCJlbWJlZGRlZEluZm8iLCJzZXQiLCJmaWxlTmFtZSIsImV4dHJhY3RlZFBhdGgiLCJlcnJvciIsIk1hcCIsInJlc291cmNlTWFwIiwiZmlsZVBhdGgiLCJpc0ltYWdlRmlsZSIsIm5hbWVXaXRob3V0RXh0IiwicGFyc2UiLCJuYW1lIiwibGlua3NGb2xkZXIiLCJleGlzdHNTeW5jIiwiZmlsZXMiLCJyZWFkZGlyU3luYyIsImZ1bGxQYXRoIiwiam9pbiIsInNpemUiLCJBcnJheSIsImZyb20iLCJrZXlzIiwia2V5IiwicHJvY2Vzc0xpbmtlZFJlc291cmNlcyIsImRvY3VtZW50RGF0YSIsImVsZW1lbnQiLCJlbGVtZW50cyIsImhhc0ltYWdlUmVmZXJlbmNlIiwibGlua0VsZW1lbnRUb0ltYWdlIiwiZ3JvdXBJdGVtcyIsImxlbmd0aCIsImdyb3VwSXRlbSIsInByb2Nlc3NUZXh0SW1hZ2VzIiwiaXNDb250ZW50RnJhbWUiLCJoYXNQbGFjZWRDb250ZW50IiwicGxhY2VkQ29udGVudCIsImhyZWYiLCJpbWFnZVR5cGVOYW1lIiwiYWN0dWFsUHBpIiwidHlwZSIsImhhc0VtYmVkZGVkSW1hZ2UiLCJpbmNsdWRlcyIsImZpbGxDb2xvciIsIlByb3BlcnRpZXMiLCJJbWFnZSIsIlBsYWNlZEltYWdlIiwiRVBTIiwiUERGIiwiTGluayIsImltYWdlUmVmZXJlbmNlIiwibGlua2VkSW1hZ2UiLCJmaW5kSW1hZ2VCeU5hbWUiLCJzZWFyY2hOYW1lIiwiY2xlYW5OYW1lIiwicmVwbGFjZSIsImJhc2VOYW1lIiwiYmFzZW5hbWUiLCJoYXMiLCJwb3NzaWJsZU1hdGNoZXMiLCJmaWx0ZXIiLCJ0b0xvd2VyQ2FzZSIsImlkIiwic2VsZiIsImltYWdlRmlsZU5hbWUiLCJ1cGxvYWRJZCIsImRldGVjdEVtYmVkZGVkSW1hZ2VzIiwiaGFzRW1iZWRkZWRDb250ZW50IiwibWF0Y2hpbmdFeHRyYWN0ZWRJbWFnZSIsImZpbmQiLCJpbWciLCJlbWJlZGRlZEZpbGVOYW1lIiwidXJsIiwib3JpZ2luYWxQYXRoIiwiaXNFbWJlZGRlZCIsImlzRXh0cmFjdGVkIiwiZW1iZWRkZWRUeXBlIiwiZW1iZWRkZWREYXRhIiwiZnJhbWVQb3NpdGlvbiIsInBvc2l0aW9uIiwiaW1hZ2VQb3NpdGlvbiIsInJlZmVyZW5jZWRJbWFnZSIsIndhcm4iLCJ1cmxGb2xkZXIiLCJpbWFnZVBhdGgiLCJnZXQiLCJlbWJlZGRlZEluZGljYXRvcnMiLCJpc1BsYWNlaG9sZGVyIiwiZ2V0SW1hZ2VFeHRlbnNpb24iLCJmaW5kRWxlbWVudEltYWdlUmVmZXJlbmNlIiwiaW1hZ2VOYW1lIiwibWF0Y2hJbWFnZUJ5U2l6ZSIsIk9iamVjdCIsInZhbHVlcyIsInN0b3JpZXMiLCJzdG9yeSIsImNvbnRlbnQiLCJmb3JtYXR0ZWRDb250ZW50IiwidGV4dCIsImltYWdlUmVmcyIsIm1hdGNoIiwicmVmIiwiYW5hbHl6ZVNwcmVhZEZvckltYWdlUmVmZXJlbmNlcyIsImlkbWxQYXRoIiwieG1sUGFyc2VyIiwic3ByZWFkQW5hbHlzaXMiLCJzcHJlYWRzQW5hbHl6ZWQiLCJpbWFnZVJlZmVyZW5jZXMiLCJsaW5rUmVmZXJlbmNlcyIsInBsYWNlZENvbnRlbnREZXRhaWxzIiwiZXh0cmFjdGVkRGF0YSIsImV4dHJhY3RJRE1MQ29udGVudHMiLCJzcHJlYWRGaWxlcyIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNwcmVhZEZpbGUiLCJzcHJlYWRDb250ZW50IiwiYW5hbHlzaXMiLCJhbmFseXplU3ByZWFkWE1MRm9ySW1hZ2VzIiwicHVzaCIsInhtbENvbnRlbnQiLCJwYXJzZWQiLCJmaW5kSW1hZ2VSZWZzIiwib2JqIiwidmFsdWUiLCJmaWxlIiwiSlNPTiIsInN0cmluZ2lmeSIsInN1YnN0cmluZyIsImVsZW1lbnRUeXBlIiwiZGV0YWlscyIsImV4dHJhY3RFbWJlZGRlZEltYWdlRnJvbVNwcmVhZCIsInVwbG9hZERpciIsImVtYmVkZGVkSW1hZ2VzIiwiQ29udGVudHMiLCJiYXNlNjREYXRhIiwibGlua0luZm8iLCJleHRyYWN0SW1hZ2VOYW1lRnJvbUxpbmsiLCJpbWFnZVR5cGUiLCJleHRlbnNpb24iLCJnZXRJbWFnZUV4dGVuc2lvbkZyb21Gb3JtYXQiLCJvdXRwdXRQYXRoIiwib3V0cHV0RGlyIiwiZGlybmFtZSIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsImltYWdlQnVmZmVyIiwiQnVmZmVyIiwid3JpdGVGaWxlU3luYyIsImJhc2U2NExlbmd0aCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/processors/ImageProcessor.js\n");

/***/ }),

/***/ "./lib/utils/ColorUtils.js":
/*!*********************************!*\
  !*** ./lib/utils/ColorUtils.js ***!
  \*********************************/
/***/ ((module) => {

eval("/**\r\n * ColorUtils.js - Comprehensive color conversion and manipulation utilities\r\n * Handles CMYK, RGB, HEX, and other color format conversions for IDML processing\r\n */ \nclass ColorUtils {\n    /**\r\n   * Convert CMYK color values to RGB\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {object} RGB object with r, g, b values (0-255)\r\n   */ static cmykToRgb(c, m, y, k) {\n        // Normalize CMYK values to 0-1 range\n        const cNorm = c / 100;\n        const mNorm = m / 100;\n        const yNorm = y / 100;\n        const kNorm = k / 100;\n        // Convert to RGB using standard formula\n        const r = Math.round(255 * (1 - cNorm) * (1 - kNorm));\n        const g = Math.round(255 * (1 - mNorm) * (1 - kNorm));\n        const b = Math.round(255 * (1 - yNorm) * (1 - kNorm));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    /**\r\n   * Convert CMYK to RGB CSS string\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {string} CSS rgb() string\r\n   */ static cmykToRgbString(c, m, y, k) {\n        const { r, g, b } = this.cmykToRgb(c, m, y, k);\n        return `rgb(${r}, ${g}, ${b})`;\n    }\n    /**\r\n   * Convert RGB to HEX\r\n   * @param {number} r - Red (0-255)\r\n   * @param {number} g - Green (0-255)\r\n   * @param {number} b - Blue (0-255)\r\n   * @returns {string} HEX color string\r\n   */ static rgbToHex(r, g, b) {\n        const toHex = (component)=>{\n            const hex = component.toString(16);\n            return hex.length === 1 ? \"0\" + hex : hex;\n        };\n        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n    }\n    /**\r\n   * Convert CMYK to HEX\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {string} HEX color string\r\n   */ static cmykToHex(c, m, y, k) {\n        const { r, g, b } = this.cmykToRgb(c, m, y, k);\n        return this.rgbToHex(r, g, b);\n    }\n    /**\r\n   * Parse CMYK values from IDML color reference string\r\n   * @param {string} colorRef - IDML color reference (e.g., \"Color/C=1 M=18 Y=16 K=0\")\r\n   * @returns {object|null} Object with c, m, y, k values or null if not parseable\r\n   */ static parseCmykFromColorRef(colorRef) {\n        if (!colorRef || typeof colorRef !== \"string\") {\n            return null;\n        }\n        // Match CMYK pattern in IDML color references\n        const cmykMatch = colorRef.match(/Color\\/C=([\\d.]+)\\s*M=([\\d.]+)\\s*Y=([\\d.]+)\\s*K=([\\d.]+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map((val)=>parseFloat(val));\n            return {\n                c,\n                m,\n                y,\n                k\n            };\n        }\n        return null;\n    }\n    /**\r\n   * Convert IDML color reference to RGB CSS string\r\n   * @param {string} colorRef - IDML color reference\r\n   * @returns {string} CSS color string (rgb, hex, or named color)\r\n   */ static convertIdmlColorToRgb(colorRefOrObj) {\n        if (!colorRefOrObj || colorRefOrObj === \"Color/None\") {\n            return \"transparent\";\n        }\n        // ENHANCED: Handle color objects with intelligent RGB/CMYK prioritization\n        if (typeof colorRefOrObj === \"object\") {\n            console.log(`ðŸŽ¨ Converting color object:`, {\n                self: colorRefOrObj.self,\n                source: colorRefOrObj.colorSource,\n                hasRGB: colorRefOrObj.hasDirectRGB,\n                hasCMYK: colorRefOrObj.hasDirectCMYK,\n                space: colorRefOrObj.space\n            });\n            // PRIORITY 1: Use direct RGB values (ONLY if they're meaningful, not all zeros)\n            if (colorRefOrObj.hasDirectRGB && (colorRefOrObj.red !== undefined && colorRefOrObj.red > 0 || colorRefOrObj.green !== undefined && colorRefOrObj.green > 0 || colorRefOrObj.blue !== undefined && colorRefOrObj.blue > 0)) {\n                const rgbString = `rgb(${colorRefOrObj.red || 0}, ${colorRefOrObj.green || 0}, ${colorRefOrObj.blue || 0})`;\n                console.log(`   âœ… Using direct RGB values: ${rgbString} (source: ${colorRefOrObj.colorSource})`);\n                return rgbString;\n            }\n            // PRIORITY 2: Convert CMYK values to RGB (when RGB not available or RGB is all zeros)\n            if (colorRefOrObj.hasDirectCMYK && (colorRefOrObj.cyan !== undefined || colorRefOrObj.magenta !== undefined || colorRefOrObj.yellow !== undefined || colorRefOrObj.black !== undefined)) {\n                const { r, g, b } = this.cmykToRgb(colorRefOrObj.cyan || 0, colorRefOrObj.magenta || 0, colorRefOrObj.yellow || 0, colorRefOrObj.black || 0);\n                const rgbString = `rgb(${r}, ${g}, ${b})`;\n                console.log(`   ðŸ”„ Converted CMYK to RGB: C:${colorRefOrObj.cyan} M:${colorRefOrObj.magenta} Y:${colorRefOrObj.yellow} K:${colorRefOrObj.black} â†’ ${rgbString} (source: ${colorRefOrObj.colorSource})`);\n                return rgbString;\n            }\n            // PRIORITY 3: Handle special case where RGB values are all zero but it's marked as RGB source\n            // This should NOT use \"0 0 0\" for standard colors\n            if (colorRefOrObj.hasDirectRGB && colorRefOrObj.red === 0 && colorRefOrObj.green === 0 && colorRefOrObj.blue === 0 && colorRefOrObj.isCustomColor === true) {\n                // Only use RGB \"0 0 0\" for custom colors that explicitly want black\n                const rgbString = `rgb(0, 0, 0)`;\n                console.log(`   âœ… Using RGB black for custom color: ${rgbString} (source: ${colorRefOrObj.colorSource})`);\n                return rgbString;\n            }\n            // FALLBACK: Legacy object handling (backward compatibility)\n            // Check for legacy red/green/blue properties (but avoid all-zero unless it's a custom color)\n            if (colorRefOrObj.red !== undefined && colorRefOrObj.green !== undefined && colorRefOrObj.blue !== undefined) {\n                // Only use RGB if it has actual color values OR it's explicitly a custom color\n                if (colorRefOrObj.red > 0 || colorRefOrObj.green > 0 || colorRefOrObj.blue > 0 || colorRefOrObj.isCustomColor === true) {\n                    const rgbString = `rgb(${colorRefOrObj.red}, ${colorRefOrObj.green}, ${colorRefOrObj.blue})`;\n                    console.log(`   âœ… Using legacy RGB properties: ${rgbString}`);\n                    return rgbString;\n                } else {\n                    console.log(`   âš ï¸  Skipping legacy RGB \"0 0 0\" for non-custom color`);\n                }\n            }\n            // Check for legacy cyan/magenta/yellow/black properties\n            if (colorRefOrObj.cyan !== undefined && colorRefOrObj.magenta !== undefined && colorRefOrObj.yellow !== undefined && colorRefOrObj.black !== undefined) {\n                // Only convert CMYK if it has meaningful values OR it's from a CMYK source that should be processed\n                const hasValidCMYK = colorRefOrObj.cyan > 0 || colorRefOrObj.magenta > 0 || colorRefOrObj.yellow > 0 || colorRefOrObj.black > 0;\n                const isCMYKSource = colorRefOrObj.colorSource && colorRefOrObj.colorSource.includes(\"cmyk\");\n                if (hasValidCMYK || isCMYKSource || colorRefOrObj.isCustomColor === true) {\n                    const { r, g, b } = this.cmykToRgb(colorRefOrObj.cyan, colorRefOrObj.magenta, colorRefOrObj.yellow, colorRefOrObj.black);\n                    const rgbString = `rgb(${r}, ${g}, ${b})`;\n                    console.log(`   ðŸ”„ Converted legacy CMYK to RGB: ${rgbString}`);\n                    return rgbString;\n                } else {\n                    console.log(`   âš ï¸  Skipping legacy CMYK \"0 0 0 0\" for non-CMYK source`);\n                }\n            }\n        }\n        // Handle string-based color references (color names like \"Color/Main\", \"Color/Black\", etc.)\n        if (typeof colorRefOrObj === \"string\") {\n            console.log(`ðŸŽ¨ Processing string color reference: \"${colorRefOrObj}\"`);\n            // Try to parse CMYK pattern from string\n            const cmyk = this.parseCmykFromColorRef(colorRefOrObj);\n            if (cmyk) {\n                const rgbString = this.cmykToRgbString(cmyk.c, cmyk.m, cmyk.y, cmyk.k);\n                console.log(`   ðŸ”„ Parsed and converted CMYK string: ${colorRefOrObj} â†’ ${rgbString}`);\n                return rgbString;\n            }\n            // Check predefined named colors\n            const namedColors = {\n                \"Color/Black\": \"rgb(0, 0, 0)\",\n                \"Color/White\": \"rgb(255, 255, 255)\",\n                \"Color/Red\": \"rgb(255, 0, 0)\",\n                \"Color/Green\": \"rgb(0, 255, 0)\",\n                \"Color/Blue\": \"rgb(0, 0, 255)\",\n                \"Color/Cyan\": \"rgb(0, 255, 255)\",\n                \"Color/Magenta\": \"rgb(255, 0, 255)\",\n                \"Color/Yellow\": \"rgb(255, 255, 0)\",\n                \"Color/Paper\": \"rgb(255, 255, 255)\"\n            };\n            if (namedColors[colorRefOrObj]) {\n                console.log(`   âœ… Using predefined named color: ${colorRefOrObj} â†’ ${namedColors[colorRefOrObj]}`);\n                return namedColors[colorRefOrObj];\n            }\n        }\n        // Ultimate fallback\n        console.log(`   âš ï¸  No valid color data found, using default gray: ${JSON.stringify(colorRefOrObj)}`);\n        return \"rgb(200, 200, 200)\";\n    }\n    /**\r\n   * Determine if a CMYK color is suitable for use as a background\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {object} Analysis result with isLightBackground boolean and reasoning\r\n   */ static analyzeCmykForBackground(c, m, y, k) {\n        const maxCMY = Math.max(c, m, y);\n        const avgCMY = (c + m + y) / 3;\n        const analysis = {\n            c,\n            m,\n            y,\n            k,\n            maxCMY,\n            avgCMY,\n            isLightBackground: false,\n            category: \"unknown\",\n            reasoning: \"\"\n        };\n        // Very light colors: low K and low CMY values\n        if (k <= 20 && maxCMY <= 30 && avgCMY <= 20) {\n            analysis.isLightBackground = true;\n            analysis.category = \"very_light\";\n            analysis.reasoning = \"Very light color suitable for background\";\n            return analysis;\n        }\n        // Light tinted colors: very low K, slightly higher CMY (like light pink, light blue, etc.)\n        if (k <= 10 && maxCMY <= 50 && avgCMY <= 25) {\n            analysis.isLightBackground = true;\n            analysis.category = \"light_tinted\";\n            analysis.reasoning = \"Light tinted color suitable for background\";\n            return analysis;\n        }\n        // Light gray: balanced CMY, moderate K\n        if (k >= 5 && k <= 60 && maxCMY <= 15 && Math.abs(c - m) <= 5 && Math.abs(m - y) <= 5) {\n            analysis.isLightBackground = true;\n            analysis.category = \"light_gray\";\n            analysis.reasoning = \"Light gray color suitable for background\";\n            return analysis;\n        }\n        // Not suitable for background\n        analysis.reasoning = \"Too dark or saturated for background use\";\n        return analysis;\n    }\n    /**\r\n   * Analyze IDML color reference for background suitability\r\n   * @param {string} colorRef - IDML color reference\r\n   * @returns {object|null} Analysis result or null if not CMYK\r\n   */ static analyzeIdmlColorForBackground(colorRef) {\n        // Handle Paper color specially\n        if (colorRef === \"Color/Paper\" || colorRef.includes(\"Paper\")) {\n            return {\n                isLightBackground: true,\n                category: \"paper\",\n                reasoning: \"InDesign Paper color - ideal for background\",\n                colorRef\n            };\n        }\n        const cmyk = this.parseCmykFromColorRef(colorRef);\n        if (!cmyk) {\n            return null;\n        }\n        const analysis = this.analyzeCmykForBackground(cmyk.c, cmyk.m, cmyk.y, cmyk.k);\n        analysis.colorRef = colorRef;\n        return analysis;\n    }\n    /**\r\n   * Get RGB brightness value (0-255, higher = brighter)\r\n   * @param {number} r - Red (0-255)\r\n   * @param {number} g - Green (0-255)\r\n   * @param {number} b - Blue (0-255)\r\n   * @returns {number} Brightness value\r\n   */ static getRgbBrightness(r, g, b) {\n        // Use relative luminance formula\n        return 0.299 * r + 0.587 * g + 0.114 * b;\n    }\n    /**\r\n   * Get brightness from CMYK values\r\n   * @param {number} c - Cyan (0-100)\r\n   * @param {number} m - Magenta (0-100)\r\n   * @param {number} y - Yellow (0-100)\r\n   * @param {number} k - Black/Key (0-100)\r\n   * @returns {number} Brightness value (0-255)\r\n   */ static getCmykBrightness(c, m, y, k) {\n        const { r, g, b } = this.cmykToRgb(c, m, y, k);\n        return this.getRgbBrightness(r, g, b);\n    }\n    /**\r\n   * Sort colors by lightness (lightest first)\r\n   * @param {Array} colorRefs - Array of IDML color references\r\n   * @returns {Array} Sorted array with lightest colors first\r\n   */ static sortColorsByLightness(colorRefs) {\n        return colorRefs.sort((a, b)=>{\n            // Analyze both colors for background suitability\n            const analysisA = this.analyzeIdmlColorForBackground(a);\n            const analysisB = this.analyzeIdmlColorForBackground(b);\n            // Prioritize actual CMYK colors over Paper color for visual interest\n            const aIsPaper = a.includes(\"Paper\");\n            const bIsPaper = b.includes(\"Paper\");\n            const aIsCmyk = !aIsPaper && analysisA && analysisA.c !== undefined;\n            const bIsCmyk = !bIsPaper && analysisB && analysisB.c !== undefined;\n            // If one is CMYK and other is Paper, prefer CMYK for visual interest\n            if (aIsCmyk && bIsPaper) return -1;\n            if (bIsCmyk && aIsPaper) return 1;\n            // If both are CMYK, sort by lightness (lower K value = lighter)\n            if (aIsCmyk && bIsCmyk) {\n                const cmykA = this.parseCmykFromColorRef(a);\n                const cmykB = this.parseCmykFromColorRef(b);\n                if (cmykA && cmykB) {\n                    // First compare by category priority (very_light > light_gray, etc.)\n                    const categoryPriority = {\n                        very_light: 1,\n                        light_gray: 2,\n                        paper: 3,\n                        unknown: 4\n                    };\n                    const priorityA = categoryPriority[analysisA.category] || 4;\n                    const priorityB = categoryPriority[analysisB.category] || 4;\n                    if (priorityA !== priorityB) {\n                        return priorityA - priorityB;\n                    }\n                    // If same category, sort by K value (lower K = lighter)\n                    return cmykA.k - cmykB.k;\n                }\n            }\n            // If both are Paper or both are unknown, maintain original order\n            return 0;\n        });\n    }\n}\n// Restore CommonJS exports\nmodule.exports = ColorUtils;\nmodule.exports.cmykToRgb = ColorUtils.cmykToRgb;\nmodule.exports.cmykToRgbString = ColorUtils.cmykToRgbString;\nmodule.exports.cmykToHex = ColorUtils.cmykToHex;\nmodule.exports.rgbToHex = ColorUtils.rgbToHex;\nmodule.exports.parseCmykFromColorRef = ColorUtils.parseCmykFromColorRef;\nmodule.exports.convertIdmlColorToRgb = ColorUtils.convertIdmlColorToRgb;\nmodule.exports.analyzeCmykForBackground = ColorUtils.analyzeCmykForBackground;\nmodule.exports.analyzeIdmlColorForBackground = ColorUtils.analyzeIdmlColorForBackground;\nmodule.exports.getRgbBrightness = ColorUtils.getRgbBrightness;\nmodule.exports.getCmykBrightness = ColorUtils.getCmykBrightness;\nmodule.exports.sortColorsByLightness = ColorUtils.sortColorsByLightness;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtBQUMvRG9CLG9DQUFvQyxHQUFHMUYsV0FBV3VFLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2lkbWwtdmlld2VyLy4vbGliL3V0aWxzL0NvbG9yVXRpbHMuanM/NTU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29sb3JVdGlscy5qcyAtIENvbXByZWhlbnNpdmUgY29sb3IgY29udmVyc2lvbiBhbmQgbWFuaXB1bGF0aW9uIHV0aWxpdGllc1xyXG4gKiBIYW5kbGVzIENNWUssIFJHQiwgSEVYLCBhbmQgb3RoZXIgY29sb3IgZm9ybWF0IGNvbnZlcnNpb25zIGZvciBJRE1MIHByb2Nlc3NpbmdcclxuICovXHJcblxyXG5jbGFzcyBDb2xvclV0aWxzIHtcclxuICAvKipcclxuICAgKiBDb252ZXJ0IENNWUsgY29sb3IgdmFsdWVzIHRvIFJHQlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gQ3lhbiAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFllbGxvdyAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgLSBCbGFjay9LZXkgKDAtMTAwKVxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFJHQiBvYmplY3Qgd2l0aCByLCBnLCBiIHZhbHVlcyAoMC0yNTUpXHJcbiAgICovXHJcbiAgc3RhdGljIGNteWtUb1JnYihjLCBtLCB5LCBrKSB7XHJcbiAgICAvLyBOb3JtYWxpemUgQ01ZSyB2YWx1ZXMgdG8gMC0xIHJhbmdlXHJcbiAgICBjb25zdCBjTm9ybSA9IGMgLyAxMDA7XHJcbiAgICBjb25zdCBtTm9ybSA9IG0gLyAxMDA7XHJcbiAgICBjb25zdCB5Tm9ybSA9IHkgLyAxMDA7XHJcbiAgICBjb25zdCBrTm9ybSA9IGsgLyAxMDA7XHJcblxyXG4gICAgLy8gQ29udmVydCB0byBSR0IgdXNpbmcgc3RhbmRhcmQgZm9ybXVsYVxyXG4gICAgY29uc3QgciA9IE1hdGgucm91bmQoMjU1ICogKDEgLSBjTm9ybSkgKiAoMSAtIGtOb3JtKSk7XHJcbiAgICBjb25zdCBnID0gTWF0aC5yb3VuZCgyNTUgKiAoMSAtIG1Ob3JtKSAqICgxIC0ga05vcm0pKTtcclxuICAgIGNvbnN0IGIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0geU5vcm0pICogKDEgLSBrTm9ybSkpO1xyXG5cclxuICAgIHJldHVybiB7IHIsIGcsIGIgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgQ01ZSyB0byBSR0IgQ1NTIHN0cmluZ1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gQ3lhbiAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gLSBNYWdlbnRhICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFllbGxvdyAoMC0xMDApXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgLSBCbGFjay9LZXkgKDAtMTAwKVxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IENTUyByZ2IoKSBzdHJpbmdcclxuICAgKi9cclxuICBzdGF0aWMgY215a1RvUmdiU3RyaW5nKGMsIG0sIHksIGspIHtcclxuICAgIGNvbnN0IHsgciwgZywgYiB9ID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XHJcbiAgICByZXR1cm4gYHJnYigke3J9LCAke2d9LCAke2J9KWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IFJHQiB0byBIRVhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFJlZCAoMC0yNTUpXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGcgLSBHcmVlbiAoMC0yNTUpXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBCbHVlICgwLTI1NSlcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBIRVggY29sb3Igc3RyaW5nXHJcbiAgICovXHJcbiAgc3RhdGljIHJnYlRvSGV4KHIsIGcsIGIpIHtcclxuICAgIGNvbnN0IHRvSGV4ID0gKGNvbXBvbmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBoZXggPSBjb21wb25lbnQudG9TdHJpbmcoMTYpO1xyXG4gICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgaGV4IDogaGV4O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBgIyR7dG9IZXgocil9JHt0b0hleChnKX0ke3RvSGV4KGIpfWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IENNWUsgdG8gSEVYXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBDeWFuICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbSAtIE1hZ2VudGEgKDAtMTAwKVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWWVsbG93ICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayAtIEJsYWNrL0tleSAoMC0xMDApXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gSEVYIGNvbG9yIHN0cmluZ1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjbXlrVG9IZXgoYywgbSwgeSwgaykge1xyXG4gICAgY29uc3QgeyByLCBnLCBiIH0gPSB0aGlzLmNteWtUb1JnYihjLCBtLCB5LCBrKTtcclxuICAgIHJldHVybiB0aGlzLnJnYlRvSGV4KHIsIGcsIGIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2UgQ01ZSyB2YWx1ZXMgZnJvbSBJRE1MIGNvbG9yIHJlZmVyZW5jZSBzdHJpbmdcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JSZWYgLSBJRE1MIGNvbG9yIHJlZmVyZW5jZSAoZS5nLiwgXCJDb2xvci9DPTEgTT0xOCBZPTE2IEs9MFwiKVxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH0gT2JqZWN0IHdpdGggYywgbSwgeSwgayB2YWx1ZXMgb3IgbnVsbCBpZiBub3QgcGFyc2VhYmxlXHJcbiAgICovXHJcbiAgc3RhdGljIHBhcnNlQ215a0Zyb21Db2xvclJlZihjb2xvclJlZikge1xyXG4gICAgaWYgKCFjb2xvclJlZiB8fCB0eXBlb2YgY29sb3JSZWYgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWF0Y2ggQ01ZSyBwYXR0ZXJuIGluIElETUwgY29sb3IgcmVmZXJlbmNlc1xyXG4gICAgY29uc3QgY215a01hdGNoID0gY29sb3JSZWYubWF0Y2goXHJcbiAgICAgIC9Db2xvclxcL0M9KFtcXGQuXSspXFxzKk09KFtcXGQuXSspXFxzKlk9KFtcXGQuXSspXFxzKks9KFtcXGQuXSspL1xyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoY215a01hdGNoKSB7XHJcbiAgICAgIGNvbnN0IFssIGMsIG0sIHksIGtdID0gY215a01hdGNoLm1hcCgodmFsKSA9PiBwYXJzZUZsb2F0KHZhbCkpO1xyXG4gICAgICByZXR1cm4geyBjLCBtLCB5LCBrIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IElETUwgY29sb3IgcmVmZXJlbmNlIHRvIFJHQiBDU1Mgc3RyaW5nXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yUmVmIC0gSURNTCBjb2xvciByZWZlcmVuY2VcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDU1MgY29sb3Igc3RyaW5nIChyZ2IsIGhleCwgb3IgbmFtZWQgY29sb3IpXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbnZlcnRJZG1sQ29sb3JUb1JnYihjb2xvclJlZk9yT2JqKSB7XHJcbiAgICBpZiAoIWNvbG9yUmVmT3JPYmogfHwgY29sb3JSZWZPck9iaiA9PT0gXCJDb2xvci9Ob25lXCIpIHtcclxuICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFTkhBTkNFRDogSGFuZGxlIGNvbG9yIG9iamVjdHMgd2l0aCBpbnRlbGxpZ2VudCBSR0IvQ01ZSyBwcmlvcml0aXphdGlvblxyXG4gICAgaWYgKHR5cGVvZiBjb2xvclJlZk9yT2JqID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn46oIENvbnZlcnRpbmcgY29sb3Igb2JqZWN0OmAsIHtcclxuICAgICAgICBzZWxmOiBjb2xvclJlZk9yT2JqLnNlbGYsXHJcbiAgICAgICAgc291cmNlOiBjb2xvclJlZk9yT2JqLmNvbG9yU291cmNlLFxyXG4gICAgICAgIGhhc1JHQjogY29sb3JSZWZPck9iai5oYXNEaXJlY3RSR0IsXHJcbiAgICAgICAgaGFzQ01ZSzogY29sb3JSZWZPck9iai5oYXNEaXJlY3RDTVlLLFxyXG4gICAgICAgIHNwYWNlOiBjb2xvclJlZk9yT2JqLnNwYWNlLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFBSSU9SSVRZIDE6IFVzZSBkaXJlY3QgUkdCIHZhbHVlcyAoT05MWSBpZiB0aGV5J3JlIG1lYW5pbmdmdWwsIG5vdCBhbGwgemVyb3MpXHJcbiAgICAgIGlmIChcclxuICAgICAgICBjb2xvclJlZk9yT2JqLmhhc0RpcmVjdFJHQiAmJlxyXG4gICAgICAgICgoY29sb3JSZWZPck9iai5yZWQgIT09IHVuZGVmaW5lZCAmJiBjb2xvclJlZk9yT2JqLnJlZCA+IDApIHx8XHJcbiAgICAgICAgICAoY29sb3JSZWZPck9iai5ncmVlbiAhPT0gdW5kZWZpbmVkICYmIGNvbG9yUmVmT3JPYmouZ3JlZW4gPiAwKSB8fFxyXG4gICAgICAgICAgKGNvbG9yUmVmT3JPYmouYmx1ZSAhPT0gdW5kZWZpbmVkICYmIGNvbG9yUmVmT3JPYmouYmx1ZSA+IDApKVxyXG4gICAgICApIHtcclxuICAgICAgICBjb25zdCByZ2JTdHJpbmcgPSBgcmdiKCR7Y29sb3JSZWZPck9iai5yZWQgfHwgMH0sICR7XHJcbiAgICAgICAgICBjb2xvclJlZk9yT2JqLmdyZWVuIHx8IDBcclxuICAgICAgICB9LCAke2NvbG9yUmVmT3JPYmouYmx1ZSB8fCAwfSlgO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgIOKchSBVc2luZyBkaXJlY3QgUkdCIHZhbHVlczogJHtyZ2JTdHJpbmd9IChzb3VyY2U6ICR7Y29sb3JSZWZPck9iai5jb2xvclNvdXJjZX0pYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHJnYlN0cmluZztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUFJJT1JJVFkgMjogQ29udmVydCBDTVlLIHZhbHVlcyB0byBSR0IgKHdoZW4gUkdCIG5vdCBhdmFpbGFibGUgb3IgUkdCIGlzIGFsbCB6ZXJvcylcclxuICAgICAgaWYgKFxyXG4gICAgICAgIGNvbG9yUmVmT3JPYmouaGFzRGlyZWN0Q01ZSyAmJlxyXG4gICAgICAgIChjb2xvclJlZk9yT2JqLmN5YW4gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgY29sb3JSZWZPck9iai5tYWdlbnRhICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgIGNvbG9yUmVmT3JPYmoueWVsbG93ICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgIGNvbG9yUmVmT3JPYmouYmxhY2sgIT09IHVuZGVmaW5lZClcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc3QgeyByLCBnLCBiIH0gPSB0aGlzLmNteWtUb1JnYihcclxuICAgICAgICAgIGNvbG9yUmVmT3JPYmouY3lhbiB8fCAwLFxyXG4gICAgICAgICAgY29sb3JSZWZPck9iai5tYWdlbnRhIHx8IDAsXHJcbiAgICAgICAgICBjb2xvclJlZk9yT2JqLnllbGxvdyB8fCAwLFxyXG4gICAgICAgICAgY29sb3JSZWZPck9iai5ibGFjayB8fCAwXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCByZ2JTdHJpbmcgPSBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYDtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGAgICDwn5SEIENvbnZlcnRlZCBDTVlLIHRvIFJHQjogQzoke2NvbG9yUmVmT3JPYmouY3lhbn0gTToke2NvbG9yUmVmT3JPYmoubWFnZW50YX0gWToke2NvbG9yUmVmT3JPYmoueWVsbG93fSBLOiR7Y29sb3JSZWZPck9iai5ibGFja30g4oaSICR7cmdiU3RyaW5nfSAoc291cmNlOiAke2NvbG9yUmVmT3JPYmouY29sb3JTb3VyY2V9KWBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiByZ2JTdHJpbmc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFBSSU9SSVRZIDM6IEhhbmRsZSBzcGVjaWFsIGNhc2Ugd2hlcmUgUkdCIHZhbHVlcyBhcmUgYWxsIHplcm8gYnV0IGl0J3MgbWFya2VkIGFzIFJHQiBzb3VyY2VcclxuICAgICAgLy8gVGhpcyBzaG91bGQgTk9UIHVzZSBcIjAgMCAwXCIgZm9yIHN0YW5kYXJkIGNvbG9yc1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgY29sb3JSZWZPck9iai5oYXNEaXJlY3RSR0IgJiZcclxuICAgICAgICBjb2xvclJlZk9yT2JqLnJlZCA9PT0gMCAmJlxyXG4gICAgICAgIGNvbG9yUmVmT3JPYmouZ3JlZW4gPT09IDAgJiZcclxuICAgICAgICBjb2xvclJlZk9yT2JqLmJsdWUgPT09IDAgJiZcclxuICAgICAgICBjb2xvclJlZk9yT2JqLmlzQ3VzdG9tQ29sb3IgPT09IHRydWVcclxuICAgICAgKSB7XHJcbiAgICAgICAgLy8gT25seSB1c2UgUkdCIFwiMCAwIDBcIiBmb3IgY3VzdG9tIGNvbG9ycyB0aGF0IGV4cGxpY2l0bHkgd2FudCBibGFja1xyXG4gICAgICAgIGNvbnN0IHJnYlN0cmluZyA9IGByZ2IoMCwgMCwgMClgO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgIOKchSBVc2luZyBSR0IgYmxhY2sgZm9yIGN1c3RvbSBjb2xvcjogJHtyZ2JTdHJpbmd9IChzb3VyY2U6ICR7Y29sb3JSZWZPck9iai5jb2xvclNvdXJjZX0pYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHJnYlN0cmluZztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRkFMTEJBQ0s6IExlZ2FjeSBvYmplY3QgaGFuZGxpbmcgKGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXHJcbiAgICAgIC8vIENoZWNrIGZvciBsZWdhY3kgcmVkL2dyZWVuL2JsdWUgcHJvcGVydGllcyAoYnV0IGF2b2lkIGFsbC16ZXJvIHVubGVzcyBpdCdzIGEgY3VzdG9tIGNvbG9yKVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgY29sb3JSZWZPck9iai5yZWQgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGNvbG9yUmVmT3JPYmouZ3JlZW4gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGNvbG9yUmVmT3JPYmouYmx1ZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICkge1xyXG4gICAgICAgIC8vIE9ubHkgdXNlIFJHQiBpZiBpdCBoYXMgYWN0dWFsIGNvbG9yIHZhbHVlcyBPUiBpdCdzIGV4cGxpY2l0bHkgYSBjdXN0b20gY29sb3JcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBjb2xvclJlZk9yT2JqLnJlZCA+IDAgfHxcclxuICAgICAgICAgIGNvbG9yUmVmT3JPYmouZ3JlZW4gPiAwIHx8XHJcbiAgICAgICAgICBjb2xvclJlZk9yT2JqLmJsdWUgPiAwIHx8XHJcbiAgICAgICAgICBjb2xvclJlZk9yT2JqLmlzQ3VzdG9tQ29sb3IgPT09IHRydWVcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbnN0IHJnYlN0cmluZyA9IGByZ2IoJHtjb2xvclJlZk9yT2JqLnJlZH0sICR7Y29sb3JSZWZPck9iai5ncmVlbn0sICR7Y29sb3JSZWZPck9iai5ibHVlfSlgO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIOKchSBVc2luZyBsZWdhY3kgUkdCIHByb3BlcnRpZXM6ICR7cmdiU3RyaW5nfWApO1xyXG4gICAgICAgICAgcmV0dXJuIHJnYlN0cmluZztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGAgICDimqDvuI8gIFNraXBwaW5nIGxlZ2FjeSBSR0IgXCIwIDAgMFwiIGZvciBub24tY3VzdG9tIGNvbG9yYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciBsZWdhY3kgY3lhbi9tYWdlbnRhL3llbGxvdy9ibGFjayBwcm9wZXJ0aWVzXHJcbiAgICAgIGlmIChcclxuICAgICAgICBjb2xvclJlZk9yT2JqLmN5YW4gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGNvbG9yUmVmT3JPYmoubWFnZW50YSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgY29sb3JSZWZPck9iai55ZWxsb3cgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGNvbG9yUmVmT3JPYmouYmxhY2sgIT09IHVuZGVmaW5lZFxyXG4gICAgICApIHtcclxuICAgICAgICAvLyBPbmx5IGNvbnZlcnQgQ01ZSyBpZiBpdCBoYXMgbWVhbmluZ2Z1bCB2YWx1ZXMgT1IgaXQncyBmcm9tIGEgQ01ZSyBzb3VyY2UgdGhhdCBzaG91bGQgYmUgcHJvY2Vzc2VkXHJcbiAgICAgICAgY29uc3QgaGFzVmFsaWRDTVlLID1cclxuICAgICAgICAgIGNvbG9yUmVmT3JPYmouY3lhbiA+IDAgfHxcclxuICAgICAgICAgIGNvbG9yUmVmT3JPYmoubWFnZW50YSA+IDAgfHxcclxuICAgICAgICAgIGNvbG9yUmVmT3JPYmoueWVsbG93ID4gMCB8fFxyXG4gICAgICAgICAgY29sb3JSZWZPck9iai5ibGFjayA+IDA7XHJcbiAgICAgICAgY29uc3QgaXNDTVlLU291cmNlID1cclxuICAgICAgICAgIGNvbG9yUmVmT3JPYmouY29sb3JTb3VyY2UgJiZcclxuICAgICAgICAgIGNvbG9yUmVmT3JPYmouY29sb3JTb3VyY2UuaW5jbHVkZXMoXCJjbXlrXCIpO1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBoYXNWYWxpZENNWUsgfHxcclxuICAgICAgICAgIGlzQ01ZS1NvdXJjZSB8fFxyXG4gICAgICAgICAgY29sb3JSZWZPck9iai5pc0N1c3RvbUNvbG9yID09PSB0cnVlXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBjb25zdCB7IHIsIGcsIGIgfSA9IHRoaXMuY215a1RvUmdiKFxyXG4gICAgICAgICAgICBjb2xvclJlZk9yT2JqLmN5YW4sXHJcbiAgICAgICAgICAgIGNvbG9yUmVmT3JPYmoubWFnZW50YSxcclxuICAgICAgICAgICAgY29sb3JSZWZPck9iai55ZWxsb3csXHJcbiAgICAgICAgICAgIGNvbG9yUmVmT3JPYmouYmxhY2tcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjb25zdCByZ2JTdHJpbmcgPSBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYDtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGAgICDwn5SEIENvbnZlcnRlZCBsZWdhY3kgQ01ZSyB0byBSR0I6ICR7cmdiU3RyaW5nfWApO1xyXG4gICAgICAgICAgcmV0dXJuIHJnYlN0cmluZztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGAgICDimqDvuI8gIFNraXBwaW5nIGxlZ2FjeSBDTVlLIFwiMCAwIDAgMFwiIGZvciBub24tQ01ZSyBzb3VyY2VgXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZSBzdHJpbmctYmFzZWQgY29sb3IgcmVmZXJlbmNlcyAoY29sb3IgbmFtZXMgbGlrZSBcIkNvbG9yL01haW5cIiwgXCJDb2xvci9CbGFja1wiLCBldGMuKVxyXG4gICAgaWYgKHR5cGVvZiBjb2xvclJlZk9yT2JqID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn46oIFByb2Nlc3Npbmcgc3RyaW5nIGNvbG9yIHJlZmVyZW5jZTogXCIke2NvbG9yUmVmT3JPYmp9XCJgKTtcclxuXHJcbiAgICAgIC8vIFRyeSB0byBwYXJzZSBDTVlLIHBhdHRlcm4gZnJvbSBzdHJpbmdcclxuICAgICAgY29uc3QgY215ayA9IHRoaXMucGFyc2VDbXlrRnJvbUNvbG9yUmVmKGNvbG9yUmVmT3JPYmopO1xyXG4gICAgICBpZiAoY215aykge1xyXG4gICAgICAgIGNvbnN0IHJnYlN0cmluZyA9IHRoaXMuY215a1RvUmdiU3RyaW5nKGNteWsuYywgY215ay5tLCBjbXlrLnksIGNteWsuayk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgICAg8J+UhCBQYXJzZWQgYW5kIGNvbnZlcnRlZCBDTVlLIHN0cmluZzogJHtjb2xvclJlZk9yT2JqfSDihpIgJHtyZ2JTdHJpbmd9YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHJnYlN0cmluZztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgcHJlZGVmaW5lZCBuYW1lZCBjb2xvcnNcclxuICAgICAgY29uc3QgbmFtZWRDb2xvcnMgPSB7XHJcbiAgICAgICAgXCJDb2xvci9CbGFja1wiOiBcInJnYigwLCAwLCAwKVwiLFxyXG4gICAgICAgIFwiQ29sb3IvV2hpdGVcIjogXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIixcclxuICAgICAgICBcIkNvbG9yL1JlZFwiOiBcInJnYigyNTUsIDAsIDApXCIsXHJcbiAgICAgICAgXCJDb2xvci9HcmVlblwiOiBcInJnYigwLCAyNTUsIDApXCIsXHJcbiAgICAgICAgXCJDb2xvci9CbHVlXCI6IFwicmdiKDAsIDAsIDI1NSlcIixcclxuICAgICAgICBcIkNvbG9yL0N5YW5cIjogXCJyZ2IoMCwgMjU1LCAyNTUpXCIsXHJcbiAgICAgICAgXCJDb2xvci9NYWdlbnRhXCI6IFwicmdiKDI1NSwgMCwgMjU1KVwiLFxyXG4gICAgICAgIFwiQ29sb3IvWWVsbG93XCI6IFwicmdiKDI1NSwgMjU1LCAwKVwiLFxyXG4gICAgICAgIFwiQ29sb3IvUGFwZXJcIjogXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIixcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChuYW1lZENvbG9yc1tjb2xvclJlZk9yT2JqXSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYCAgIOKchSBVc2luZyBwcmVkZWZpbmVkIG5hbWVkIGNvbG9yOiAke2NvbG9yUmVmT3JPYmp9IOKGkiAke25hbWVkQ29sb3JzW2NvbG9yUmVmT3JPYmpdfWBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBuYW1lZENvbG9yc1tjb2xvclJlZk9yT2JqXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVsdGltYXRlIGZhbGxiYWNrXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYCAgIOKaoO+4jyAgTm8gdmFsaWQgY29sb3IgZGF0YSBmb3VuZCwgdXNpbmcgZGVmYXVsdCBncmF5OiAke0pTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgIGNvbG9yUmVmT3JPYmpcclxuICAgICAgKX1gXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIFwicmdiKDIwMCwgMjAwLCAyMDApXCI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgaWYgYSBDTVlLIGNvbG9yIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgYSBiYWNrZ3JvdW5kXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBDeWFuICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbSAtIE1hZ2VudGEgKDAtMTAwKVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWWVsbG93ICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayAtIEJsYWNrL0tleSAoMC0xMDApXHJcbiAgICogQHJldHVybnMge29iamVjdH0gQW5hbHlzaXMgcmVzdWx0IHdpdGggaXNMaWdodEJhY2tncm91bmQgYm9vbGVhbiBhbmQgcmVhc29uaW5nXHJcbiAgICovXHJcbiAgc3RhdGljIGFuYWx5emVDbXlrRm9yQmFja2dyb3VuZChjLCBtLCB5LCBrKSB7XHJcbiAgICBjb25zdCBtYXhDTVkgPSBNYXRoLm1heChjLCBtLCB5KTtcclxuICAgIGNvbnN0IGF2Z0NNWSA9IChjICsgbSArIHkpIC8gMztcclxuXHJcbiAgICBjb25zdCBhbmFseXNpcyA9IHtcclxuICAgICAgYyxcclxuICAgICAgbSxcclxuICAgICAgeSxcclxuICAgICAgayxcclxuICAgICAgbWF4Q01ZLFxyXG4gICAgICBhdmdDTVksXHJcbiAgICAgIGlzTGlnaHRCYWNrZ3JvdW5kOiBmYWxzZSxcclxuICAgICAgY2F0ZWdvcnk6IFwidW5rbm93blwiLFxyXG4gICAgICByZWFzb25pbmc6IFwiXCIsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFZlcnkgbGlnaHQgY29sb3JzOiBsb3cgSyBhbmQgbG93IENNWSB2YWx1ZXNcclxuICAgIGlmIChrIDw9IDIwICYmIG1heENNWSA8PSAzMCAmJiBhdmdDTVkgPD0gMjApIHtcclxuICAgICAgYW5hbHlzaXMuaXNMaWdodEJhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICBhbmFseXNpcy5jYXRlZ29yeSA9IFwidmVyeV9saWdodFwiO1xyXG4gICAgICBhbmFseXNpcy5yZWFzb25pbmcgPSBcIlZlcnkgbGlnaHQgY29sb3Igc3VpdGFibGUgZm9yIGJhY2tncm91bmRcIjtcclxuICAgICAgcmV0dXJuIGFuYWx5c2lzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExpZ2h0IHRpbnRlZCBjb2xvcnM6IHZlcnkgbG93IEssIHNsaWdodGx5IGhpZ2hlciBDTVkgKGxpa2UgbGlnaHQgcGluaywgbGlnaHQgYmx1ZSwgZXRjLilcclxuICAgIGlmIChrIDw9IDEwICYmIG1heENNWSA8PSA1MCAmJiBhdmdDTVkgPD0gMjUpIHtcclxuICAgICAgYW5hbHlzaXMuaXNMaWdodEJhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICBhbmFseXNpcy5jYXRlZ29yeSA9IFwibGlnaHRfdGludGVkXCI7XHJcbiAgICAgIGFuYWx5c2lzLnJlYXNvbmluZyA9IFwiTGlnaHQgdGludGVkIGNvbG9yIHN1aXRhYmxlIGZvciBiYWNrZ3JvdW5kXCI7XHJcbiAgICAgIHJldHVybiBhbmFseXNpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBMaWdodCBncmF5OiBiYWxhbmNlZCBDTVksIG1vZGVyYXRlIEtcclxuICAgIGlmIChcclxuICAgICAgayA+PSA1ICYmXHJcbiAgICAgIGsgPD0gNjAgJiZcclxuICAgICAgbWF4Q01ZIDw9IDE1ICYmXHJcbiAgICAgIE1hdGguYWJzKGMgLSBtKSA8PSA1ICYmXHJcbiAgICAgIE1hdGguYWJzKG0gLSB5KSA8PSA1XHJcbiAgICApIHtcclxuICAgICAgYW5hbHlzaXMuaXNMaWdodEJhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICBhbmFseXNpcy5jYXRlZ29yeSA9IFwibGlnaHRfZ3JheVwiO1xyXG4gICAgICBhbmFseXNpcy5yZWFzb25pbmcgPSBcIkxpZ2h0IGdyYXkgY29sb3Igc3VpdGFibGUgZm9yIGJhY2tncm91bmRcIjtcclxuICAgICAgcmV0dXJuIGFuYWx5c2lzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdCBzdWl0YWJsZSBmb3IgYmFja2dyb3VuZFxyXG4gICAgYW5hbHlzaXMucmVhc29uaW5nID0gXCJUb28gZGFyayBvciBzYXR1cmF0ZWQgZm9yIGJhY2tncm91bmQgdXNlXCI7XHJcbiAgICByZXR1cm4gYW5hbHlzaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbmFseXplIElETUwgY29sb3IgcmVmZXJlbmNlIGZvciBiYWNrZ3JvdW5kIHN1aXRhYmlsaXR5XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yUmVmIC0gSURNTCBjb2xvciByZWZlcmVuY2VcclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9IEFuYWx5c2lzIHJlc3VsdCBvciBudWxsIGlmIG5vdCBDTVlLXHJcbiAgICovXHJcbiAgc3RhdGljIGFuYWx5emVJZG1sQ29sb3JGb3JCYWNrZ3JvdW5kKGNvbG9yUmVmKSB7XHJcbiAgICAvLyBIYW5kbGUgUGFwZXIgY29sb3Igc3BlY2lhbGx5XHJcbiAgICBpZiAoY29sb3JSZWYgPT09IFwiQ29sb3IvUGFwZXJcIiB8fCBjb2xvclJlZi5pbmNsdWRlcyhcIlBhcGVyXCIpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNMaWdodEJhY2tncm91bmQ6IHRydWUsXHJcbiAgICAgICAgY2F0ZWdvcnk6IFwicGFwZXJcIixcclxuICAgICAgICByZWFzb25pbmc6IFwiSW5EZXNpZ24gUGFwZXIgY29sb3IgLSBpZGVhbCBmb3IgYmFja2dyb3VuZFwiLFxyXG4gICAgICAgIGNvbG9yUmVmLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNteWsgPSB0aGlzLnBhcnNlQ215a0Zyb21Db2xvclJlZihjb2xvclJlZik7XHJcbiAgICBpZiAoIWNteWspIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYW5hbHlzaXMgPSB0aGlzLmFuYWx5emVDbXlrRm9yQmFja2dyb3VuZChcclxuICAgICAgY215ay5jLFxyXG4gICAgICBjbXlrLm0sXHJcbiAgICAgIGNteWsueSxcclxuICAgICAgY215ay5rXHJcbiAgICApO1xyXG4gICAgYW5hbHlzaXMuY29sb3JSZWYgPSBjb2xvclJlZjtcclxuICAgIHJldHVybiBhbmFseXNpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBSR0IgYnJpZ2h0bmVzcyB2YWx1ZSAoMC0yNTUsIGhpZ2hlciA9IGJyaWdodGVyKVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gUmVkICgwLTI1NSlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZyAtIEdyZWVuICgwLTI1NSlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIEJsdWUgKDAtMjU1KVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEJyaWdodG5lc3MgdmFsdWVcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0UmdiQnJpZ2h0bmVzcyhyLCBnLCBiKSB7XHJcbiAgICAvLyBVc2UgcmVsYXRpdmUgbHVtaW5hbmNlIGZvcm11bGFcclxuICAgIHJldHVybiAwLjI5OSAqIHIgKyAwLjU4NyAqIGcgKyAwLjExNCAqIGI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYnJpZ2h0bmVzcyBmcm9tIENNWUsgdmFsdWVzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBDeWFuICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbSAtIE1hZ2VudGEgKDAtMTAwKVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWWVsbG93ICgwLTEwMClcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayAtIEJsYWNrL0tleSAoMC0xMDApXHJcbiAgICogQHJldHVybnMge251bWJlcn0gQnJpZ2h0bmVzcyB2YWx1ZSAoMC0yNTUpXHJcbiAgICovXHJcbiAgc3RhdGljIGdldENteWtCcmlnaHRuZXNzKGMsIG0sIHksIGspIHtcclxuICAgIGNvbnN0IHsgciwgZywgYiB9ID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRSZ2JCcmlnaHRuZXNzKHIsIGcsIGIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydCBjb2xvcnMgYnkgbGlnaHRuZXNzIChsaWdodGVzdCBmaXJzdClcclxuICAgKiBAcGFyYW0ge0FycmF5fSBjb2xvclJlZnMgLSBBcnJheSBvZiBJRE1MIGNvbG9yIHJlZmVyZW5jZXNcclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFNvcnRlZCBhcnJheSB3aXRoIGxpZ2h0ZXN0IGNvbG9ycyBmaXJzdFxyXG4gICAqL1xyXG4gIHN0YXRpYyBzb3J0Q29sb3JzQnlMaWdodG5lc3MoY29sb3JSZWZzKSB7XHJcbiAgICByZXR1cm4gY29sb3JSZWZzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgLy8gQW5hbHl6ZSBib3RoIGNvbG9ycyBmb3IgYmFja2dyb3VuZCBzdWl0YWJpbGl0eVxyXG4gICAgICBjb25zdCBhbmFseXNpc0EgPSB0aGlzLmFuYWx5emVJZG1sQ29sb3JGb3JCYWNrZ3JvdW5kKGEpO1xyXG4gICAgICBjb25zdCBhbmFseXNpc0IgPSB0aGlzLmFuYWx5emVJZG1sQ29sb3JGb3JCYWNrZ3JvdW5kKGIpO1xyXG5cclxuICAgICAgLy8gUHJpb3JpdGl6ZSBhY3R1YWwgQ01ZSyBjb2xvcnMgb3ZlciBQYXBlciBjb2xvciBmb3IgdmlzdWFsIGludGVyZXN0XHJcbiAgICAgIGNvbnN0IGFJc1BhcGVyID0gYS5pbmNsdWRlcyhcIlBhcGVyXCIpO1xyXG4gICAgICBjb25zdCBiSXNQYXBlciA9IGIuaW5jbHVkZXMoXCJQYXBlclwiKTtcclxuICAgICAgY29uc3QgYUlzQ215ayA9ICFhSXNQYXBlciAmJiBhbmFseXNpc0EgJiYgYW5hbHlzaXNBLmMgIT09IHVuZGVmaW5lZDtcclxuICAgICAgY29uc3QgYklzQ215ayA9ICFiSXNQYXBlciAmJiBhbmFseXNpc0IgJiYgYW5hbHlzaXNCLmMgIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIC8vIElmIG9uZSBpcyBDTVlLIGFuZCBvdGhlciBpcyBQYXBlciwgcHJlZmVyIENNWUsgZm9yIHZpc3VhbCBpbnRlcmVzdFxyXG4gICAgICBpZiAoYUlzQ215ayAmJiBiSXNQYXBlcikgcmV0dXJuIC0xO1xyXG4gICAgICBpZiAoYklzQ215ayAmJiBhSXNQYXBlcikgcmV0dXJuIDE7XHJcblxyXG4gICAgICAvLyBJZiBib3RoIGFyZSBDTVlLLCBzb3J0IGJ5IGxpZ2h0bmVzcyAobG93ZXIgSyB2YWx1ZSA9IGxpZ2h0ZXIpXHJcbiAgICAgIGlmIChhSXNDbXlrICYmIGJJc0NteWspIHtcclxuICAgICAgICBjb25zdCBjbXlrQSA9IHRoaXMucGFyc2VDbXlrRnJvbUNvbG9yUmVmKGEpO1xyXG4gICAgICAgIGNvbnN0IGNteWtCID0gdGhpcy5wYXJzZUNteWtGcm9tQ29sb3JSZWYoYik7XHJcblxyXG4gICAgICAgIGlmIChjbXlrQSAmJiBjbXlrQikge1xyXG4gICAgICAgICAgLy8gRmlyc3QgY29tcGFyZSBieSBjYXRlZ29yeSBwcmlvcml0eSAodmVyeV9saWdodCA+IGxpZ2h0X2dyYXksIGV0Yy4pXHJcbiAgICAgICAgICBjb25zdCBjYXRlZ29yeVByaW9yaXR5ID0ge1xyXG4gICAgICAgICAgICB2ZXJ5X2xpZ2h0OiAxLFxyXG4gICAgICAgICAgICBsaWdodF9ncmF5OiAyLFxyXG4gICAgICAgICAgICBwYXBlcjogMyxcclxuICAgICAgICAgICAgdW5rbm93bjogNCxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgY29uc3QgcHJpb3JpdHlBID0gY2F0ZWdvcnlQcmlvcml0eVthbmFseXNpc0EuY2F0ZWdvcnldIHx8IDQ7XHJcbiAgICAgICAgICBjb25zdCBwcmlvcml0eUIgPSBjYXRlZ29yeVByaW9yaXR5W2FuYWx5c2lzQi5jYXRlZ29yeV0gfHwgNDtcclxuXHJcbiAgICAgICAgICBpZiAocHJpb3JpdHlBICE9PSBwcmlvcml0eUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByaW9yaXR5QSAtIHByaW9yaXR5QjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBJZiBzYW1lIGNhdGVnb3J5LCBzb3J0IGJ5IEsgdmFsdWUgKGxvd2VyIEsgPSBsaWdodGVyKVxyXG4gICAgICAgICAgcmV0dXJuIGNteWtBLmsgLSBjbXlrQi5rO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgYm90aCBhcmUgUGFwZXIgb3IgYm90aCBhcmUgdW5rbm93biwgbWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFJlc3RvcmUgQ29tbW9uSlMgZXhwb3J0c1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yVXRpbHM7XHJcbm1vZHVsZS5leHBvcnRzLmNteWtUb1JnYiA9IENvbG9yVXRpbHMuY215a1RvUmdiO1xyXG5tb2R1bGUuZXhwb3J0cy5jbXlrVG9SZ2JTdHJpbmcgPSBDb2xvclV0aWxzLmNteWtUb1JnYlN0cmluZztcclxubW9kdWxlLmV4cG9ydHMuY215a1RvSGV4ID0gQ29sb3JVdGlscy5jbXlrVG9IZXg7XHJcbm1vZHVsZS5leHBvcnRzLnJnYlRvSGV4ID0gQ29sb3JVdGlscy5yZ2JUb0hleDtcclxubW9kdWxlLmV4cG9ydHMucGFyc2VDbXlrRnJvbUNvbG9yUmVmID0gQ29sb3JVdGlscy5wYXJzZUNteWtGcm9tQ29sb3JSZWY7XHJcbm1vZHVsZS5leHBvcnRzLmNvbnZlcnRJZG1sQ29sb3JUb1JnYiA9IENvbG9yVXRpbHMuY29udmVydElkbWxDb2xvclRvUmdiO1xyXG5tb2R1bGUuZXhwb3J0cy5hbmFseXplQ215a0ZvckJhY2tncm91bmQgPSBDb2xvclV0aWxzLmFuYWx5emVDbXlrRm9yQmFja2dyb3VuZDtcclxubW9kdWxlLmV4cG9ydHMuYW5hbHl6ZUlkbWxDb2xvckZvckJhY2tncm91bmQgPVxyXG4gIENvbG9yVXRpbHMuYW5hbHl6ZUlkbWxDb2xvckZvckJhY2tncm91bmQ7XHJcbm1vZHVsZS5leHBvcnRzLmdldFJnYkJyaWdodG5lc3MgPSBDb2xvclV0aWxzLmdldFJnYkJyaWdodG5lc3M7XHJcbm1vZHVsZS5leHBvcnRzLmdldENteWtCcmlnaHRuZXNzID0gQ29sb3JVdGlscy5nZXRDbXlrQnJpZ2h0bmVzcztcclxubW9kdWxlLmV4cG9ydHMuc29ydENvbG9yc0J5TGlnaHRuZXNzID0gQ29sb3JVdGlscy5zb3J0Q29sb3JzQnlMaWdodG5lc3M7XHJcbiJdLCJuYW1lcyI6WyJDb2xvclV0aWxzIiwiY215a1RvUmdiIiwiYyIsIm0iLCJ5IiwiayIsImNOb3JtIiwibU5vcm0iLCJ5Tm9ybSIsImtOb3JtIiwiciIsIk1hdGgiLCJyb3VuZCIsImciLCJiIiwiY215a1RvUmdiU3RyaW5nIiwicmdiVG9IZXgiLCJ0b0hleCIsImNvbXBvbmVudCIsImhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiY215a1RvSGV4IiwicGFyc2VDbXlrRnJvbUNvbG9yUmVmIiwiY29sb3JSZWYiLCJjbXlrTWF0Y2giLCJtYXRjaCIsIm1hcCIsInZhbCIsInBhcnNlRmxvYXQiLCJjb252ZXJ0SWRtbENvbG9yVG9SZ2IiLCJjb2xvclJlZk9yT2JqIiwiY29uc29sZSIsImxvZyIsInNlbGYiLCJzb3VyY2UiLCJjb2xvclNvdXJjZSIsImhhc1JHQiIsImhhc0RpcmVjdFJHQiIsImhhc0NNWUsiLCJoYXNEaXJlY3RDTVlLIiwic3BhY2UiLCJyZWQiLCJ1bmRlZmluZWQiLCJncmVlbiIsImJsdWUiLCJyZ2JTdHJpbmciLCJjeWFuIiwibWFnZW50YSIsInllbGxvdyIsImJsYWNrIiwiaXNDdXN0b21Db2xvciIsImhhc1ZhbGlkQ01ZSyIsImlzQ01ZS1NvdXJjZSIsImluY2x1ZGVzIiwiY215ayIsIm5hbWVkQ29sb3JzIiwiSlNPTiIsInN0cmluZ2lmeSIsImFuYWx5emVDbXlrRm9yQmFja2dyb3VuZCIsIm1heENNWSIsIm1heCIsImF2Z0NNWSIsImFuYWx5c2lzIiwiaXNMaWdodEJhY2tncm91bmQiLCJjYXRlZ29yeSIsInJlYXNvbmluZyIsImFicyIsImFuYWx5emVJZG1sQ29sb3JGb3JCYWNrZ3JvdW5kIiwiZ2V0UmdiQnJpZ2h0bmVzcyIsImdldENteWtCcmlnaHRuZXNzIiwic29ydENvbG9yc0J5TGlnaHRuZXNzIiwiY29sb3JSZWZzIiwic29ydCIsImEiLCJhbmFseXNpc0EiLCJhbmFseXNpc0IiLCJhSXNQYXBlciIsImJJc1BhcGVyIiwiYUlzQ215ayIsImJJc0NteWsiLCJjbXlrQSIsImNteWtCIiwiY2F0ZWdvcnlQcmlvcml0eSIsInZlcnlfbGlnaHQiLCJsaWdodF9ncmF5IiwicGFwZXIiLCJ1bmtub3duIiwicHJpb3JpdHlBIiwicHJpb3JpdHlCIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/utils/ColorUtils.js\n");

/***/ }),

/***/ "./lib/utils/IDMLUtils.js":
/*!********************************!*\
  !*** ./lib/utils/IDMLUtils.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass IDMLUtils {\n    static parseGeometricBounds(boundsString) {\n        console.log(\"DEBUG: boundsString =\", boundsString);\n        if (!boundsString || boundsString === \"undefined\") {\n            console.log(\"Warning: Missing geometric bounds, using defaults\");\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n        const bounds = boundsString.split(\" \").map(parseFloat);\n        const result = {\n            top: bounds[0] || 0,\n            left: bounds[1] || 0,\n            bottom: bounds[2] || 0,\n            right: bounds[3] || 0,\n            width: (bounds[3] || 0) - (bounds[1] || 0),\n            height: (bounds[2] || 0) - (bounds[0] || 0)\n        };\n        console.log(\"Parsed bounds:\", result);\n        return result;\n    }\n    static parseTransform(transformString) {\n        if (!transformString) return {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            tx: 0,\n            ty: 0\n        };\n        const values = transformString.split(\" \").map(parseFloat);\n        return {\n            a: values[0] || 1,\n            b: values[1] || 0,\n            c: values[2] || 0,\n            d: values[3] || 1,\n            tx: values[4] || 0,\n            ty: values[5] || 0\n        };\n    }\n    static calculateRotation(transform) {\n        // Calculate rotation angle from transform matrix\n        return Math.atan2(transform.b, transform.a) * (180 / Math.PI);\n    }\n    static calculateCorners(bounds, transform) {\n        const corners = {\n            topLeft: {\n                x: bounds.left,\n                y: bounds.top\n            },\n            topRight: {\n                x: bounds.right,\n                y: bounds.top\n            },\n            bottomLeft: {\n                x: bounds.left,\n                y: bounds.bottom\n            },\n            bottomRight: {\n                x: bounds.right,\n                y: bounds.bottom\n            }\n        };\n        // Apply transformation to corners\n        Object.keys(corners).forEach((corner)=>{\n            const point = corners[corner];\n            corners[corner] = {\n                x: transform.a * point.x + transform.c * point.y + transform.tx,\n                y: transform.b * point.x + transform.d * point.y + transform.ty\n            };\n        });\n        return corners;\n    }\n    static cmykToRgb(c, m, y, k) {\n        // Convert CMYK percentages (0-100) to RGB (0-255)\n        c = c / 100;\n        m = m / 100;\n        y = y / 100;\n        k = k / 100;\n        const r = Math.round(255 * (1 - c) * (1 - k));\n        const g = Math.round(255 * (1 - m) * (1 - k));\n        const b = Math.round(255 * (1 - y) * (1 - k));\n        return {\n            r,\n            g,\n            b\n        };\n    }\n    static parseInDesignColor(colorRef) {\n        if (!colorRef || colorRef === \"Color/None\") return null;\n        // Handle CMYK colors\n        const cmykMatch = colorRef.match(/Color\\/C=(\\d+)\\s*M=(\\d+)\\s*Y=(\\d+)\\s*K=(\\d+)/);\n        if (cmykMatch) {\n            const [, c, m, y, k] = cmykMatch.map(Number);\n            const rgb = this.cmykToRgb(c, m, y, k);\n            return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n        }\n        // Handle RGB colors\n        const rgbMatch = colorRef.match(/Color\\/R=(\\d+)\\s*G=(\\d+)\\s*B=(\\d+)/);\n        if (rgbMatch) {\n            const [, r, g, b] = rgbMatch.map(Number);\n            return `rgb(${r}, ${g}, ${b})`;\n        }\n        // Standard colors\n        const standardColors = {\n            \"Color/Black\": \"rgb(0, 0, 0)\",\n            \"Color/White\": \"rgb(255, 255, 255)\",\n            \"Color/Red\": \"rgb(255, 0, 0)\",\n            \"Color/Green\": \"rgb(0, 255, 0)\",\n            \"Color/Blue\": \"rgb(0, 0, 255)\",\n            \"Color/Cyan\": \"rgb(0, 255, 255)\",\n            \"Color/Magenta\": \"rgb(255, 0, 255)\",\n            \"Color/Yellow\": \"rgb(255, 255, 0)\",\n            \"Color/Paper\": \"rgb(255, 255, 255)\",\n            \"Color/Registration\": \"rgb(0, 0, 0)\"\n        };\n        return standardColors[colorRef] || null;\n    }\n    static decodeXMLEntities(text) {\n        if (!text) return \"\";\n        return text.replace(/&#x000A;/g, \"\\n\") // Line feed\n        .replace(/&#x000D;/g, \"\\r\") // Carriage return\n        .replace(/&#x0009;/g, \"\t\") // Tab\n        .replace(/&#x00A0;/g, \"\\xa0\") // Non-breaking space\n        .replace(/&#x2028;/g, \"\\n\") // Line separator\n        .replace(/&#x2029;/g, \"\\u2029\") // Paragraph separator\n        .replace(/&#10;/g, \"\\n\") // Decimal line feed\n        .replace(/&#13;/g, \"\\r\") // Decimal carriage return\n        .replace(/&#9;/g, \"\t\") // Decimal tab\n        .replace(/&#160;/g, \"\\xa0\") // Decimal non-breaking space\n        .replace(/&lt;/g, \"<\") // Less than\n        .replace(/&gt;/g, \">\") // Greater than\n        .replace(/&amp;/g, \"&\") // Ampersand (must be last)\n        .replace(/&quot;/g, '\"') // Quote\n        .replace(/&apos;/g, \"'\"); // Apostrophe\n    }\n    static cleanTextContent(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\t/g, \"    \") // Convert tabs to spaces\n        .replace(/\\u00A0/g, \" \") // Convert non-breaking spaces\n        .replace(/ +/g, \" \") // Collapse multiple spaces\n        // REMOVED: .replace(/\\n{3,}/g, '\\n\\n')  // Allow unlimited consecutive line breaks\n        .trim();\n    }\n    static preserveLineBreaks(content) {\n        return content.replace(/\\r\\n/g, \"\\n\") // Normalize Windows line breaks\n        .replace(/\\r/g, \"\\n\") // Normalize old Mac line breaks\n        .replace(/\\u2028/g, \"\\n\") // Convert line separators\n        .replace(/\\u2029/g, \"\\n\\n\"); // Convert paragraph separators\n    // REMOVED: .replace(/\\n{3,}/g, '\\n\\n'); // Allow unlimited consecutive line breaks\n    }\n    // NEW: Clean up excessive line breaks to prevent text overflow\n    static cleanTextForRendering(text) {\n        if (!text) return \"\";\n        return text// Normalize line endings\n        .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\")// Remove trailing whitespace on each line only\n        .replace(/[ \\t]+\\n/g, \"\\n\");\n    // DO NOT collapse multiple spaces, tabs, or newlines\n    // DO NOT trim the whole string\n    }\n    // ENHANCED: Better line break processing that preserves word spaces\n    static sophisticatedLineBreakProcessing(content) {\n        if (!content) return \"\";\n        // DEBUG: Track if problematic text is being processed\n        const hasProblematicText = content.includes(\"pavoluptusda\") || content.includes(\"pa\") && content.includes(\"voluptusda\");\n        if (hasProblematicText) {\n            console.log(\"\\uD83D\\uDD27 IDMLUtils.sophisticatedLineBreakProcessing:\");\n            console.log(\"   - Input:\", JSON.stringify(content));\n        }\n        // First clean up the content but preserve word spaces\n        let processed = this.cleanTextForRendering(content).replace(/\\u2028/g, \"\\n\");\n        if (hasProblematicText) {\n            console.log(\"   - After cleanTextForRendering:\", JSON.stringify(processed));\n        }\n        // Normalize line breaks but don't touch word spaces\n        // processed = processed\n        //   .replace(/\\r\\n/g, '\\n')      // Normalize Windows line breaks\n        //   .replace(/\\r/g, '\\n')        // Normalize old Mac line breaks\n        //   .replace(/\\u2029/g, '\\n')    // Convert line separators\n        //   .replace(/\\u2028/g, '\\n\\n')  // Convert paragraph separators to double breaks\n        //   .replace(/\\u000A/g, '\\n');   // Convert explicit line feed characters\n        // Ensure paragraph breaks are properly spaced\n        // processed = processed.replace(/\\n\\n+/g, '\\n\\n'); // REMOVE THIS LINE to preserve all consecutive newlines\n        return processed;\n    }\n    static countWords(text) {\n        return text.split(/\\s+/).filter((word)=>word.length > 0).length;\n    }\n    static parseNumeric(value) {\n        if (value === null || value === undefined || value === \"\") return null;\n        const num = parseFloat(value);\n        return isNaN(num) ? null : num;\n    }\n    static isImageFile(fileName) {\n        const imageExtensions = [\n            \".jpg\",\n            \".jpeg\",\n            \".png\",\n            \".gif\",\n            \".tiff\",\n            \".tif\",\n            \".bmp\",\n            \".svg\",\n            \".eps\",\n            \".ai\",\n            \".psd\",\n            \".webp\",\n            \".ico\",\n            \".jfif\",\n            \".jp2\",\n            \".jpx\"\n        ];\n        return imageExtensions.some((ext)=>fileName.toLowerCase().endsWith(ext));\n    }\n    static getImageExtension(imageTypeName) {\n        const typeMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return typeMap[imageTypeName] || \"jpg\";\n    }\n    static getImageExtensionFromFormat(format) {\n        const formatMap = {\n            \"$ID/JPEG\": \"jpg\",\n            \"$ID/PNG\": \"png\",\n            \"$ID/TIFF\": \"tif\",\n            \"$ID/GIF\": \"gif\",\n            \"$ID/BMP\": \"bmp\"\n        };\n        return formatMap[format] || \"jpg\";\n    }\n    static extractImageNameFromLink(linkUri) {\n        if (!linkUri) return null;\n        // Extract filename from path like \"file:C:/Users/lalo/Downloads/Tesla-Model-3.jpg 13325 \"\n        const match = linkUri.match(/([^\\/\\\\]+)\\.[^.]+$/);\n        return match ? match[1] : null;\n    }\n    static calculateCoordinateOffset(elements) {\n        if (!elements || elements.length === 0) {\n            console.log(\"\\uD83D\\uDEAB No elements provided for coordinate offset calculation\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        let minX = Infinity, minY = Infinity;\n        let maxStrokeWidth = 0;\n        let validElements = 0;\n        console.log(`ðŸ” ANALYZING ${elements.length} elements for coordinate offset...`);\n        // First pass: find TRUE minimum coordinates across all elements\n        elements.forEach((element, index)=>{\n            const bounds = element.geometricBounds || element.originalBounds;\n            const transform = element.itemTransform || {\n                tx: 0,\n                ty: 0\n            };\n            if (bounds && (bounds.left !== undefined || bounds.top !== undefined)) {\n                // Calculate final position after transform\n                const finalX = (bounds.left || 0) + (transform.tx || 0);\n                const finalY = (bounds.top || 0) + (transform.ty || 0);\n                console.log(`   Element ${index}: bounds(${bounds.left}, ${bounds.top}) + transform(${transform.tx}, ${transform.ty}) = final(${finalX}, ${finalY})`);\n                minX = Math.min(minX, finalX);\n                minY = Math.min(minY, finalY);\n                validElements++;\n                // Track maximum stroke width for intelligent padding\n                const strokeWidth = element.strokeWeight || 0;\n                maxStrokeWidth = Math.max(maxStrokeWidth, strokeWidth);\n            } else {\n                console.log(`   Element ${index}: No valid bounds - skipping`);\n            }\n        });\n        // Handle case where no valid elements found\n        if (validElements === 0) {\n            console.log(\"âš ï¸  No valid elements with bounds found - using zero offset\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        // Reset infinite values to 0 if no valid coordinates found\n        if (minX === Infinity) minX = 0;\n        if (minY === Infinity) minY = 0;\n        console.log(`ðŸ“Š ANALYSIS COMPLETE: minX=${minX}, minY=${minY}, maxStroke=${maxStrokeWidth}px, validElements=${validElements}`);\n        // ZERO-BASED OFFSET CALCULATION:\n        // The goal is to have NO OFFSET unless absolutely necessary for negative coordinates\n        let offsetX = 0;\n        let offsetY = 0;\n        // Only add offset if coordinates are actually negative\n        if (minX < 0) {\n            offsetX = Math.abs(minX);\n            console.log(`âŒ Negative X detected: ${minX} â†’ adding offset: ${offsetX}`);\n        }\n        if (minY < 0) {\n            offsetY = Math.abs(minY);\n            console.log(`âŒ Negative Y detected: ${minY} â†’ adding offset: ${offsetY}`);\n        }\n        // Add minimal stroke padding only if we already have an offset\n        if ((offsetX > 0 || offsetY > 0) && maxStrokeWidth > 0) {\n            const strokePadding = Math.ceil(maxStrokeWidth / 2);\n            if (offsetX > 0) offsetX += strokePadding;\n            if (offsetY > 0) offsetY += strokePadding;\n            console.log(`ðŸ–Œï¸ Added stroke padding: ${strokePadding}px`);\n        }\n        console.log(`ðŸŽ¯ FINAL OFFSET: X=${offsetX}, Y=${offsetY}`);\n        console.log(`   ${offsetX === 0 ? \"âœ… Perfect! No X offset needed\" : `âš ï¸ X offset: ${offsetX}px (${minX} was negative)`}`);\n        console.log(`   ${offsetY === 0 ? \"âœ… Perfect! No Y offset needed\" : `âš ï¸ Y offset: ${offsetY}px (${minY} was negative)`}`);\n        return {\n            x: offsetX,\n            y: offsetY\n        };\n    }\n    /**\r\n   * Calculate precise coordinate offset for pixel-perfect InDesign coordinate system transformation\r\n   * This ensures accurate positioning similar to professional tools like IMG.LY InDesign\r\n   * @param {Array} elements - Array of elements with bounds and transforms\r\n   * @returns {Object} - {x, y} offset for coordinate transformation\r\n   */ static calculateCoordinateOffsetPrecise(elements) {\n        if (!elements || elements.length === 0) {\n            console.warn(\"\\uD83C\\uDFAF No elements provided for coordinate offset calculation\");\n            return {\n                x: 0,\n                y: 0\n            };\n        }\n        console.log(\"\\uD83D\\uDD0D ANALYZING\", elements.length, \"elements for PRECISE coordinate offset...\");\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxStroke = 0;\n        let validElements = 0;\n        elements.forEach((element, index)=>{\n            if (!element.geometricBounds || !element.itemTransform) {\n                console.warn(`   âš ï¸ Element ${index} missing bounds/transform - skipping`);\n                return;\n            }\n            // Calculate final position (bounds + transform)\n            const finalX = element.geometricBounds.left + element.itemTransform.tx;\n            const finalY = element.geometricBounds.top + element.itemTransform.ty;\n            // Track stroke width for precise positioning\n            const strokeWidth = element.strokeWeight || 0;\n            maxStroke = Math.max(maxStroke, strokeWidth);\n            console.log(`   Element ${index}: bounds(${element.geometricBounds.left}, ${element.geometricBounds.top}) + transform(${element.itemTransform.tx}, ${element.itemTransform.ty}) = final(${finalX}, ${finalY})`);\n            minX = Math.min(minX, finalX);\n            minY = Math.min(minY, finalY);\n            validElements++;\n        });\n        console.log(\"\\uD83D\\uDCCA ANALYSIS COMPLETE:\", `minX=${minX}, minY=${minY}, maxStroke=${maxStroke}px, validElements=${validElements}`);\n        // FIXED: Only add offset if coordinates are actually negative\n        // Don't force elements to start at origin - preserve InDesign positioning\n        let offsetX = 0;\n        let offsetY = 0;\n        // Only handle negative coordinates that would be clipped by the browser\n        if (minX < 0) {\n            offsetX = Math.abs(minX) + maxStroke;\n            console.log(`âŒ Negative X detected: ${minX} â†’ adding offset: ${offsetX}`);\n        } else {\n            console.log(`âœ… Positive X coordinates: ${minX} â†’ no offset needed`);\n        }\n        if (minY < 0) {\n            offsetY = Math.abs(minY) + maxStroke;\n            console.log(`âŒ Negative Y detected: ${minY} â†’ adding offset: ${offsetY}`);\n        } else {\n            console.log(`âœ… Positive Y coordinates: ${minY} â†’ no offset needed`);\n        }\n        const finalOffset = {\n            x: offsetX,\n            y: offsetY\n        };\n        console.log(\"\\uD83C\\uDFAF FINAL PRECISE OFFSET:\", `X=${offsetX}, Y=${offsetY}`);\n        console.log(`   ${offsetX === 0 ? \"âœ… Perfect! No X offset needed\" : `âš ï¸ X offset: ${offsetX}px (compensating for negative coordinates)`}`);\n        console.log(`   ${offsetY === 0 ? \"âœ… Perfect! No Y offset needed\" : `âš ï¸ Y offset: ${offsetY}px (compensating for negative coordinates)`}`);\n        return finalOffset;\n    }\n    static calculateBoundsFromPath(item) {\n        try {\n            // First try to get bounds from GeometricBounds attribute\n            if (item[\"@_GeometricBounds\"]) {\n                return this.parseGeometricBounds(item[\"@_GeometricBounds\"]);\n            }\n            // Then try path geometry\n            const pathGeometry = item?.Properties?.PathGeometry?.GeometryPathType?.PathPointArray?.PathPointType;\n            if (!pathGeometry || !Array.isArray(pathGeometry)) {\n                console.log(`Warning: No geometry found for ${item[\"@_Self\"]}, using item transform`);\n                // Fallback to item transform if available\n                const transform = this.parseTransform(item[\"@_ItemTransform\"]);\n                return {\n                    top: transform.ty || 0,\n                    left: transform.tx || 0,\n                    bottom: (transform.ty || 0) + 100,\n                    right: (transform.tx || 0) + 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n            pathGeometry.forEach((point)=>{\n                const anchor = point[\"@_Anchor\"];\n                if (anchor) {\n                    const [x, y] = anchor.split(\" \").map(parseFloat);\n                    if (!isNaN(x) && !isNaN(y)) {\n                        minX = Math.min(minX, x);\n                        maxX = Math.max(maxX, x);\n                        minY = Math.min(minY, y);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            });\n            if (minX === Infinity || minY === Infinity) {\n                console.log(`Warning: Could not calculate bounds for ${item[\"@_Self\"]}`);\n                return {\n                    top: 0,\n                    left: 0,\n                    bottom: 100,\n                    right: 100,\n                    width: 100,\n                    height: 100\n                };\n            }\n            return {\n                top: minY,\n                left: minX,\n                bottom: maxY,\n                right: maxX,\n                width: maxX - minX,\n                height: maxY - minY\n            };\n        } catch (error) {\n            console.error(`Error calculating bounds for ${item[\"@_Self\"]}:`, error);\n            return {\n                top: 0,\n                left: 0,\n                bottom: 100,\n                right: 100,\n                width: 100,\n                height: 100\n            };\n        }\n    }\n    static calculateRelativePosition(frameBounds, contentBounds, frameTransform, contentTransform) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            offsetX: (contentBounds.left || 0) - (frameBounds.left || 0),\n            offsetY: (contentBounds.top || 0) - (frameBounds.top || 0),\n            scaleX: contentTransform?.a || 1,\n            scaleY: contentTransform?.d || 1,\n            transformDifference: {\n                frame: frameTransform,\n                content: contentTransform\n            }\n        };\n    }\n    static calculateGap(frameBounds, contentBounds) {\n        if (!frameBounds || !contentBounds) return null;\n        return {\n            top: (contentBounds.top || 0) - (frameBounds.top || 0),\n            left: (contentBounds.left || 0) - (frameBounds.left || 0),\n            bottom: (frameBounds.bottom || 0) - (contentBounds.bottom || 0),\n            right: (frameBounds.right || 0) - (contentBounds.right || 0)\n        };\n    }\n    static calculateImagePositionInFrame(frameBounds, frameTransform, placedContent) {\n        if (!frameBounds || !placedContent?.transform) {\n            return null;\n        }\n        const imageTransform = placedContent.transform;\n        // Calculate image position relative to frame\n        const imageX = (frameBounds.left || 0) + (imageTransform.tx || 0);\n        const imageY = (frameBounds.top || 0) + (imageTransform.ty || 0);\n        // Calculate image size with scaling\n        const imageWidth = (frameBounds.width || 0) * (imageTransform.a || 1);\n        const imageHeight = (frameBounds.height || 0) * (imageTransform.d || 1);\n        return {\n            x: imageX,\n            y: imageY,\n            width: imageWidth,\n            height: imageHeight,\n            scaleX: imageTransform.a || 1,\n            scaleY: imageTransform.d || 1\n        };\n    }\n    static getXMLStructure(obj, maxDepth = 3, currentDepth = 0) {\n        if (currentDepth >= maxDepth || typeof obj !== \"object\" || obj === null) {\n            return typeof obj;\n        }\n        const structure = {};\n        Object.keys(obj).forEach((key)=>{\n            if (Array.isArray(obj[key])) {\n                structure[key] = `Array[${obj[key].length}]`;\n            } else if (typeof obj[key] === \"object\" && obj[key] !== null) {\n                structure[key] = this.getXMLStructure(obj[key], maxDepth, currentDepth + 1);\n            } else {\n                structure[key] = typeof obj[key];\n            }\n        });\n        return structure;\n    }\n    static isFormattingAttribute(attributeName) {\n        const formattingAttributes = [\n            \"@_PointSize\",\n            \"@_Leading\",\n            \"@_Tracking\",\n            \"@_FontStyle\",\n            \"@_AppliedFont\",\n            \"@_FillColor\",\n            \"@_StrokeColor\",\n            \"@_Justification\",\n            \"@_LeftIndent\",\n            \"@_RightIndent\",\n            \"@_FirstLineIndent\",\n            \"@_SpaceBefore\",\n            \"@_SpaceAfter\",\n            \"@_Alignment\"\n        ];\n        return formattingAttributes.includes(attributeName);\n    }\n    static saveDebugInfo(debugInfo, fileName) {\n        try {\n            fs.writeFileSync(fileName, JSON.stringify(debugInfo, null, 2));\n            console.log(`âœ… Debug info saved to ${fileName}`);\n        } catch (error) {\n            console.error(\"âŒ Error saving debug info:\", error);\n            console.log(\"Debug info (first 2000 chars):\", JSON.stringify(debugInfo, null, 2).substring(0, 2000));\n        }\n    }\n}\nmodule.exports = IDMLUtils;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNGO1FBRUEsT0FBT0Q7SUFDVDtJQUVBLE9BQU9FLHNCQUFzQkMsYUFBYSxFQUFFO1FBQzFDLE1BQU1DLHVCQUF1QjtZQUMzQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7UUFDRCxPQUFPQSxxQkFBcUI5RixRQUFRLENBQUM2RjtJQUN2QztJQUVBLE9BQU9FLGNBQWNDLFNBQVMsRUFBRWxGLFFBQVEsRUFBRTtRQUN4QyxJQUFJO1lBQ0ZsRixHQUFHcUssYUFBYSxDQUFDbkYsVUFBVWIsS0FBS0MsU0FBUyxDQUFDOEYsV0FBVyxNQUFNO1lBQzNEaEssUUFBUUMsR0FBRyxDQUFDLENBQUMsc0JBQXNCLEVBQUU2RSxTQUFTLENBQUM7UUFDakQsRUFBRSxPQUFPc0QsT0FBTztZQUNkcEksUUFBUW9JLEtBQUssQ0FBQyw4QkFBOEJBO1lBQzVDcEksUUFBUUMsR0FBRyxDQUNULGtDQUNBZ0UsS0FBS0MsU0FBUyxDQUFDOEYsV0FBVyxNQUFNLEdBQUdFLFNBQVMsQ0FBQyxHQUFHO1FBRXBEO0lBQ0Y7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUd2SyIsInNvdXJjZXMiOlsid2VicGFjazovL2lkbWwtdmlld2VyLy4vbGliL3V0aWxzL0lETUxVdGlscy5qcz84ZDJmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcblxyXG5jbGFzcyBJRE1MVXRpbHMge1xyXG4gIHN0YXRpYyBwYXJzZUdlb21ldHJpY0JvdW5kcyhib3VuZHNTdHJpbmcpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IGJvdW5kc1N0cmluZyA9XCIsIGJvdW5kc1N0cmluZyk7XHJcbiAgICBpZiAoIWJvdW5kc1N0cmluZyB8fCBib3VuZHNTdHJpbmcgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiBNaXNzaW5nIGdlb21ldHJpYyBib3VuZHMsIHVzaW5nIGRlZmF1bHRzXCIpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMTAwLFxyXG4gICAgICAgIHJpZ2h0OiAxMDAsXHJcbiAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBib3VuZHMgPSBib3VuZHNTdHJpbmcuc3BsaXQoXCIgXCIpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgdG9wOiBib3VuZHNbMF0gfHwgMCxcclxuICAgICAgbGVmdDogYm91bmRzWzFdIHx8IDAsXHJcbiAgICAgIGJvdHRvbTogYm91bmRzWzJdIHx8IDAsXHJcbiAgICAgIHJpZ2h0OiBib3VuZHNbM10gfHwgMCxcclxuICAgICAgd2lkdGg6IChib3VuZHNbM10gfHwgMCkgLSAoYm91bmRzWzFdIHx8IDApLFxyXG4gICAgICBoZWlnaHQ6IChib3VuZHNbMl0gfHwgMCkgLSAoYm91bmRzWzBdIHx8IDApLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlBhcnNlZCBib3VuZHM6XCIsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybVN0cmluZykge1xyXG4gICAgaWYgKCF0cmFuc2Zvcm1TdHJpbmcpIHJldHVybiB7IGE6IDEsIGI6IDAsIGM6IDAsIGQ6IDEsIHR4OiAwLCB0eTogMCB9O1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IHRyYW5zZm9ybVN0cmluZy5zcGxpdChcIiBcIikubWFwKHBhcnNlRmxvYXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYTogdmFsdWVzWzBdIHx8IDEsIC8vIHggc2NhbGVcclxuICAgICAgYjogdmFsdWVzWzFdIHx8IDAsIC8vIHkgc2tld1xyXG4gICAgICBjOiB2YWx1ZXNbMl0gfHwgMCwgLy8geCBza2V3XHJcbiAgICAgIGQ6IHZhbHVlc1szXSB8fCAxLCAvLyB5IHNjYWxlXHJcbiAgICAgIHR4OiB2YWx1ZXNbNF0gfHwgMCwgLy8geCB0cmFuc2xhdGlvblxyXG4gICAgICB0eTogdmFsdWVzWzVdIHx8IDAsIC8vIHkgdHJhbnNsYXRpb25cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FsY3VsYXRlUm90YXRpb24odHJhbnNmb3JtKSB7XHJcbiAgICAvLyBDYWxjdWxhdGUgcm90YXRpb24gYW5nbGUgZnJvbSB0cmFuc2Zvcm0gbWF0cml4XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmEpICogKDE4MCAvIE1hdGguUEkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUNvcm5lcnMoYm91bmRzLCB0cmFuc2Zvcm0pIHtcclxuICAgIGNvbnN0IGNvcm5lcnMgPSB7XHJcbiAgICAgIHRvcExlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy50b3AgfSxcclxuICAgICAgdG9wUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMudG9wIH0sXHJcbiAgICAgIGJvdHRvbUxlZnQ6IHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy5ib3R0b20gfSxcclxuICAgICAgYm90dG9tUmlnaHQ6IHsgeDogYm91bmRzLnJpZ2h0LCB5OiBib3VuZHMuYm90dG9tIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIGNvcm5lcnNcclxuICAgIE9iamVjdC5rZXlzKGNvcm5lcnMpLmZvckVhY2goKGNvcm5lcikgPT4ge1xyXG4gICAgICBjb25zdCBwb2ludCA9IGNvcm5lcnNbY29ybmVyXTtcclxuICAgICAgY29ybmVyc1tjb3JuZXJdID0ge1xyXG4gICAgICAgIHg6IHRyYW5zZm9ybS5hICogcG9pbnQueCArIHRyYW5zZm9ybS5jICogcG9pbnQueSArIHRyYW5zZm9ybS50eCxcclxuICAgICAgICB5OiB0cmFuc2Zvcm0uYiAqIHBvaW50LnggKyB0cmFuc2Zvcm0uZCAqIHBvaW50LnkgKyB0cmFuc2Zvcm0udHksXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29ybmVycztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjbXlrVG9SZ2IoYywgbSwgeSwgaykge1xyXG4gICAgLy8gQ29udmVydCBDTVlLIHBlcmNlbnRhZ2VzICgwLTEwMCkgdG8gUkdCICgwLTI1NSlcclxuICAgIGMgPSBjIC8gMTAwO1xyXG4gICAgbSA9IG0gLyAxMDA7XHJcbiAgICB5ID0geSAvIDEwMDtcclxuICAgIGsgPSBrIC8gMTAwO1xyXG5cclxuICAgIGNvbnN0IHIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gYykgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGcgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0gbSkgKiAoMSAtIGspKTtcclxuICAgIGNvbnN0IGIgPSBNYXRoLnJvdW5kKDI1NSAqICgxIC0geSkgKiAoMSAtIGspKTtcclxuXHJcbiAgICByZXR1cm4geyByLCBnLCBiIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VJbkRlc2lnbkNvbG9yKGNvbG9yUmVmKSB7XHJcbiAgICBpZiAoIWNvbG9yUmVmIHx8IGNvbG9yUmVmID09PSBcIkNvbG9yL05vbmVcIikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gSGFuZGxlIENNWUsgY29sb3JzXHJcbiAgICBjb25zdCBjbXlrTWF0Y2ggPSBjb2xvclJlZi5tYXRjaChcclxuICAgICAgL0NvbG9yXFwvQz0oXFxkKylcXHMqTT0oXFxkKylcXHMqWT0oXFxkKylcXHMqSz0oXFxkKykvXHJcbiAgICApO1xyXG4gICAgaWYgKGNteWtNYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCBjLCBtLCB5LCBrXSA9IGNteWtNYXRjaC5tYXAoTnVtYmVyKTtcclxuICAgICAgY29uc3QgcmdiID0gdGhpcy5jbXlrVG9SZ2IoYywgbSwgeSwgayk7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cmdiLnJ9LCAke3JnYi5nfSwgJHtyZ2IuYn0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgUkdCIGNvbG9yc1xyXG4gICAgY29uc3QgcmdiTWF0Y2ggPSBjb2xvclJlZi5tYXRjaCgvQ29sb3JcXC9SPShcXGQrKVxccypHPShcXGQrKVxccypCPShcXGQrKS8pO1xyXG4gICAgaWYgKHJnYk1hdGNoKSB7XHJcbiAgICAgIGNvbnN0IFssIHIsIGcsIGJdID0gcmdiTWF0Y2gubWFwKE51bWJlcik7XHJcbiAgICAgIHJldHVybiBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGFuZGFyZCBjb2xvcnNcclxuICAgIGNvbnN0IHN0YW5kYXJkQ29sb3JzID0ge1xyXG4gICAgICBcIkNvbG9yL0JsYWNrXCI6IFwicmdiKDAsIDAsIDApXCIsXHJcbiAgICAgIFwiQ29sb3IvV2hpdGVcIjogXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIixcclxuICAgICAgXCJDb2xvci9SZWRcIjogXCJyZ2IoMjU1LCAwLCAwKVwiLFxyXG4gICAgICBcIkNvbG9yL0dyZWVuXCI6IFwicmdiKDAsIDI1NSwgMClcIixcclxuICAgICAgXCJDb2xvci9CbHVlXCI6IFwicmdiKDAsIDAsIDI1NSlcIixcclxuICAgICAgXCJDb2xvci9DeWFuXCI6IFwicmdiKDAsIDI1NSwgMjU1KVwiLFxyXG4gICAgICBcIkNvbG9yL01hZ2VudGFcIjogXCJyZ2IoMjU1LCAwLCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvWWVsbG93XCI6IFwicmdiKDI1NSwgMjU1LCAwKVwiLFxyXG4gICAgICBcIkNvbG9yL1BhcGVyXCI6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsXHJcbiAgICAgIFwiQ29sb3IvUmVnaXN0cmF0aW9uXCI6IFwicmdiKDAsIDAsIDApXCIsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBzdGFuZGFyZENvbG9yc1tjb2xvclJlZl0gfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBkZWNvZGVYTUxFbnRpdGllcyh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMDBBOy9nLCBcIlxcblwiKSAvLyBMaW5lIGZlZWRcclxuICAgICAgLnJlcGxhY2UoLyYjeDAwMEQ7L2csIFwiXFxyXCIpIC8vIENhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiN4MDAwOTsvZywgXCJcXHRcIikgLy8gVGFiXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gwMEEwOy9nLCBcIlxcdTAwQTBcIikgLy8gTm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgIC5yZXBsYWNlKC8mI3gyMDI4Oy9nLCBcIlxcblwiKSAvLyBMaW5lIHNlcGFyYXRvclxyXG4gICAgICAucmVwbGFjZSgvJiN4MjAyOTsvZywgXCJcXHUyMDI5XCIpIC8vIFBhcmFncmFwaCBzZXBhcmF0b3JcclxuICAgICAgLnJlcGxhY2UoLyYjMTA7L2csIFwiXFxuXCIpIC8vIERlY2ltYWwgbGluZSBmZWVkXHJcbiAgICAgIC5yZXBsYWNlKC8mIzEzOy9nLCBcIlxcclwiKSAvLyBEZWNpbWFsIGNhcnJpYWdlIHJldHVyblxyXG4gICAgICAucmVwbGFjZSgvJiM5Oy9nLCBcIlxcdFwiKSAvLyBEZWNpbWFsIHRhYlxyXG4gICAgICAucmVwbGFjZSgvJiMxNjA7L2csIFwiXFx1MDBBMFwiKSAvLyBEZWNpbWFsIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAucmVwbGFjZSgvJmx0Oy9nLCBcIjxcIikgLy8gTGVzcyB0aGFuXHJcbiAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKSAvLyBHcmVhdGVyIHRoYW5cclxuICAgICAgLnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKSAvLyBBbXBlcnNhbmQgKG11c3QgYmUgbGFzdClcclxuICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKSAvLyBRdW90ZVxyXG4gICAgICAucmVwbGFjZSgvJmFwb3M7L2csIFwiJ1wiKTsgLy8gQXBvc3Ryb3BoZVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNsZWFuVGV4dENvbnRlbnQoY29udGVudCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgY29udGVudFxyXG4gICAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIikgLy8gTm9ybWFsaXplIFdpbmRvd3MgbGluZSBicmVha3NcclxuICAgICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCBcIiAgICBcIikgLy8gQ29udmVydCB0YWJzIHRvIHNwYWNlc1xyXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMEEwL2csIFwiIFwiKSAvLyBDb252ZXJ0IG5vbi1icmVha2luZyBzcGFjZXNcclxuICAgICAgICAucmVwbGFjZSgvICsvZywgXCIgXCIpIC8vIENvbGxhcHNlIG11bHRpcGxlIHNwYWNlc1xyXG4gICAgICAgIC8vIFJFTU9WRUQ6IC5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKSAgLy8gQWxsb3cgdW5saW1pdGVkIGNvbnNlY3V0aXZlIGxpbmUgYnJlYWtzXHJcbiAgICAgICAgLnRyaW0oKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwcmVzZXJ2ZUxpbmVCcmVha3MoY29udGVudCkge1xyXG4gICAgcmV0dXJuIGNvbnRlbnRcclxuICAgICAgLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKSAvLyBOb3JtYWxpemUgV2luZG93cyBsaW5lIGJyZWFrc1xyXG4gICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxuXCIpIC8vIENvbnZlcnQgbGluZSBzZXBhcmF0b3JzXHJcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxuXFxuXCIpOyAvLyBDb252ZXJ0IHBhcmFncmFwaCBzZXBhcmF0b3JzXHJcbiAgICAvLyBSRU1PVkVEOiAucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJyk7IC8vIEFsbG93IHVubGltaXRlZCBjb25zZWN1dGl2ZSBsaW5lIGJyZWFrc1xyXG4gIH1cclxuXHJcbiAgLy8gTkVXOiBDbGVhbiB1cCBleGNlc3NpdmUgbGluZSBicmVha3MgdG8gcHJldmVudCB0ZXh0IG92ZXJmbG93XHJcbiAgc3RhdGljIGNsZWFuVGV4dEZvclJlbmRlcmluZyh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiBcIlwiO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGV4dFxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBsaW5lIGVuZGluZ3NcclxuICAgICAgICAucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKVxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG9uIGVhY2ggbGluZSBvbmx5XHJcbiAgICAgICAgLnJlcGxhY2UoL1sgXFx0XStcXG4vZywgXCJcXG5cIilcclxuICAgICk7XHJcbiAgICAvLyBETyBOT1QgY29sbGFwc2UgbXVsdGlwbGUgc3BhY2VzLCB0YWJzLCBvciBuZXdsaW5lc1xyXG4gICAgLy8gRE8gTk9UIHRyaW0gdGhlIHdob2xlIHN0cmluZ1xyXG4gIH1cclxuXHJcbiAgLy8gRU5IQU5DRUQ6IEJldHRlciBsaW5lIGJyZWFrIHByb2Nlc3NpbmcgdGhhdCBwcmVzZXJ2ZXMgd29yZCBzcGFjZXNcclxuICBzdGF0aWMgc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3NpbmcoY29udGVudCkge1xyXG4gICAgaWYgKCFjb250ZW50KSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAvLyBERUJVRzogVHJhY2sgaWYgcHJvYmxlbWF0aWMgdGV4dCBpcyBiZWluZyBwcm9jZXNzZWRcclxuICAgIGNvbnN0IGhhc1Byb2JsZW1hdGljVGV4dCA9XHJcbiAgICAgIGNvbnRlbnQuaW5jbHVkZXMoXCJwYXZvbHVwdHVzZGFcIikgfHxcclxuICAgICAgKGNvbnRlbnQuaW5jbHVkZXMoXCJwYVwiKSAmJiBjb250ZW50LmluY2x1ZGVzKFwidm9sdXB0dXNkYVwiKSk7XHJcbiAgICBpZiAoaGFzUHJvYmxlbWF0aWNUZXh0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBJRE1MVXRpbHMuc29waGlzdGljYXRlZExpbmVCcmVha1Byb2Nlc3Npbmc6XCIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIiAgIC0gSW5wdXQ6XCIsIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaXJzdCBjbGVhbiB1cCB0aGUgY29udGVudCBidXQgcHJlc2VydmUgd29yZCBzcGFjZXNcclxuICAgIGxldCBwcm9jZXNzZWQgPSB0aGlzLmNsZWFuVGV4dEZvclJlbmRlcmluZyhjb250ZW50KS5yZXBsYWNlKFxyXG4gICAgICAvXFx1MjAyOC9nLFxyXG4gICAgICBcIlxcblwiXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChoYXNQcm9ibGVtYXRpY1RleHQpIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCIgICAtIEFmdGVyIGNsZWFuVGV4dEZvclJlbmRlcmluZzpcIixcclxuICAgICAgICBKU09OLnN0cmluZ2lmeShwcm9jZXNzZWQpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ybWFsaXplIGxpbmUgYnJlYWtzIGJ1dCBkb24ndCB0b3VjaCB3b3JkIHNwYWNlc1xyXG4gICAgLy8gcHJvY2Vzc2VkID0gcHJvY2Vzc2VkXHJcbiAgICAvLyAgIC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpICAgICAgLy8gTm9ybWFsaXplIFdpbmRvd3MgbGluZSBicmVha3NcclxuICAgIC8vICAgLnJlcGxhY2UoL1xcci9nLCAnXFxuJykgICAgICAgIC8vIE5vcm1hbGl6ZSBvbGQgTWFjIGxpbmUgYnJlYWtzXHJcbiAgICAvLyAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXG4nKSAgICAvLyBDb252ZXJ0IGxpbmUgc2VwYXJhdG9yc1xyXG4gICAgLy8gICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxuXFxuJykgIC8vIENvbnZlcnQgcGFyYWdyYXBoIHNlcGFyYXRvcnMgdG8gZG91YmxlIGJyZWFrc1xyXG4gICAgLy8gICAucmVwbGFjZSgvXFx1MDAwQS9nLCAnXFxuJyk7ICAgLy8gQ29udmVydCBleHBsaWNpdCBsaW5lIGZlZWQgY2hhcmFjdGVyc1xyXG5cclxuICAgIC8vIEVuc3VyZSBwYXJhZ3JhcGggYnJlYWtzIGFyZSBwcm9wZXJseSBzcGFjZWRcclxuICAgIC8vIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5yZXBsYWNlKC9cXG5cXG4rL2csICdcXG5cXG4nKTsgLy8gUkVNT1ZFIFRISVMgTElORSB0byBwcmVzZXJ2ZSBhbGwgY29uc2VjdXRpdmUgbmV3bGluZXNcclxuXHJcbiAgICByZXR1cm4gcHJvY2Vzc2VkO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNvdW50V29yZHModGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQuc3BsaXQoL1xccysvKS5maWx0ZXIoKHdvcmQpID0+IHdvcmQubGVuZ3RoID4gMCkubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlTnVtZXJpYyh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IFwiXCIpIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICByZXR1cm4gaXNOYU4obnVtKSA/IG51bGwgOiBudW07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaXNJbWFnZUZpbGUoZmlsZU5hbWUpIHtcclxuICAgIGNvbnN0IGltYWdlRXh0ZW5zaW9ucyA9IFtcclxuICAgICAgXCIuanBnXCIsXHJcbiAgICAgIFwiLmpwZWdcIixcclxuICAgICAgXCIucG5nXCIsXHJcbiAgICAgIFwiLmdpZlwiLFxyXG4gICAgICBcIi50aWZmXCIsXHJcbiAgICAgIFwiLnRpZlwiLFxyXG4gICAgICBcIi5ibXBcIixcclxuICAgICAgXCIuc3ZnXCIsXHJcbiAgICAgIFwiLmVwc1wiLFxyXG4gICAgICBcIi5haVwiLFxyXG4gICAgICBcIi5wc2RcIixcclxuICAgICAgXCIud2VicFwiLFxyXG4gICAgICBcIi5pY29cIixcclxuICAgICAgXCIuamZpZlwiLFxyXG4gICAgICBcIi5qcDJcIixcclxuICAgICAgXCIuanB4XCIsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGltYWdlRXh0ZW5zaW9ucy5zb21lKChleHQpID0+IGZpbGVOYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0SW1hZ2VFeHRlbnNpb24oaW1hZ2VUeXBlTmFtZSkge1xyXG4gICAgY29uc3QgdHlwZU1hcCA9IHtcclxuICAgICAgXCIkSUQvSlBFR1wiOiBcImpwZ1wiLFxyXG4gICAgICBcIiRJRC9QTkdcIjogXCJwbmdcIixcclxuICAgICAgXCIkSUQvVElGRlwiOiBcInRpZlwiLFxyXG4gICAgICBcIiRJRC9HSUZcIjogXCJnaWZcIixcclxuICAgICAgXCIkSUQvQk1QXCI6IFwiYm1wXCIsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHR5cGVNYXBbaW1hZ2VUeXBlTmFtZV0gfHwgXCJqcGdcIjtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRJbWFnZUV4dGVuc2lvbkZyb21Gb3JtYXQoZm9ybWF0KSB7XHJcbiAgICBjb25zdCBmb3JtYXRNYXAgPSB7XHJcbiAgICAgIFwiJElEL0pQRUdcIjogXCJqcGdcIixcclxuICAgICAgXCIkSUQvUE5HXCI6IFwicG5nXCIsXHJcbiAgICAgIFwiJElEL1RJRkZcIjogXCJ0aWZcIixcclxuICAgICAgXCIkSUQvR0lGXCI6IFwiZ2lmXCIsXHJcbiAgICAgIFwiJElEL0JNUFwiOiBcImJtcFwiLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBmb3JtYXRNYXBbZm9ybWF0XSB8fCBcImpwZ1wiO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGV4dHJhY3RJbWFnZU5hbWVGcm9tTGluayhsaW5rVXJpKSB7XHJcbiAgICBpZiAoIWxpbmtVcmkpIHJldHVybiBudWxsO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgZmlsZW5hbWUgZnJvbSBwYXRoIGxpa2UgXCJmaWxlOkM6L1VzZXJzL2xhbG8vRG93bmxvYWRzL1Rlc2xhLU1vZGVsLTMuanBnIDEzMzI1IFwiXHJcbiAgICBjb25zdCBtYXRjaCA9IGxpbmtVcmkubWF0Y2goLyhbXlxcL1xcXFxdKylcXC5bXi5dKyQvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0KGVsZW1lbnRzKSB7XHJcbiAgICBpZiAoIWVsZW1lbnRzIHx8IGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCfmqsgTm8gZWxlbWVudHMgcHJvdmlkZWQgZm9yIGNvb3JkaW5hdGUgb2Zmc2V0IGNhbGN1bGF0aW9uXCIpO1xyXG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG1pblggPSBJbmZpbml0eSxcclxuICAgICAgbWluWSA9IEluZmluaXR5O1xyXG4gICAgbGV0IG1heFN0cm9rZVdpZHRoID0gMDtcclxuICAgIGxldCB2YWxpZEVsZW1lbnRzID0gMDtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCflI0gQU5BTFlaSU5HICR7ZWxlbWVudHMubGVuZ3RofSBlbGVtZW50cyBmb3IgY29vcmRpbmF0ZSBvZmZzZXQuLi5gXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEZpcnN0IHBhc3M6IGZpbmQgVFJVRSBtaW5pbXVtIGNvb3JkaW5hdGVzIGFjcm9zcyBhbGwgZWxlbWVudHNcclxuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGJvdW5kcyA9IGVsZW1lbnQuZ2VvbWV0cmljQm91bmRzIHx8IGVsZW1lbnQub3JpZ2luYWxCb3VuZHM7XHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVsZW1lbnQuaXRlbVRyYW5zZm9ybSB8fCB7IHR4OiAwLCB0eTogMCB9O1xyXG5cclxuICAgICAgaWYgKGJvdW5kcyAmJiAoYm91bmRzLmxlZnQgIT09IHVuZGVmaW5lZCB8fCBib3VuZHMudG9wICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZpbmFsIHBvc2l0aW9uIGFmdGVyIHRyYW5zZm9ybVxyXG4gICAgICAgIGNvbnN0IGZpbmFsWCA9IChib3VuZHMubGVmdCB8fCAwKSArICh0cmFuc2Zvcm0udHggfHwgMCk7XHJcbiAgICAgICAgY29uc3QgZmluYWxZID0gKGJvdW5kcy50b3AgfHwgMCkgKyAodHJhbnNmb3JtLnR5IHx8IDApO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGAgICBFbGVtZW50ICR7aW5kZXh9OiBib3VuZHMoJHtib3VuZHMubGVmdH0sICR7Ym91bmRzLnRvcH0pICsgdHJhbnNmb3JtKCR7dHJhbnNmb3JtLnR4fSwgJHt0cmFuc2Zvcm0udHl9KSA9IGZpbmFsKCR7ZmluYWxYfSwgJHtmaW5hbFl9KWBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgZmluYWxYKTtcclxuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgZmluYWxZKTtcclxuICAgICAgICB2YWxpZEVsZW1lbnRzKys7XHJcblxyXG4gICAgICAgIC8vIFRyYWNrIG1heGltdW0gc3Ryb2tlIHdpZHRoIGZvciBpbnRlbGxpZ2VudCBwYWRkaW5nXHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBlbGVtZW50LnN0cm9rZVdlaWdodCB8fCAwO1xyXG4gICAgICAgIG1heFN0cm9rZVdpZHRoID0gTWF0aC5tYXgobWF4U3Ryb2tlV2lkdGgsIHN0cm9rZVdpZHRoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgICAgRWxlbWVudCAke2luZGV4fTogTm8gdmFsaWQgYm91bmRzIC0gc2tpcHBpbmdgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgbm8gdmFsaWQgZWxlbWVudHMgZm91bmRcclxuICAgIGlmICh2YWxpZEVsZW1lbnRzID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwi4pqg77iPICBObyB2YWxpZCBlbGVtZW50cyB3aXRoIGJvdW5kcyBmb3VuZCAtIHVzaW5nIHplcm8gb2Zmc2V0XCJcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGluZmluaXRlIHZhbHVlcyB0byAwIGlmIG5vIHZhbGlkIGNvb3JkaW5hdGVzIGZvdW5kXHJcbiAgICBpZiAobWluWCA9PT0gSW5maW5pdHkpIG1pblggPSAwO1xyXG4gICAgaWYgKG1pblkgPT09IEluZmluaXR5KSBtaW5ZID0gMDtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYPCfk4ogQU5BTFlTSVMgQ09NUExFVEU6IG1pblg9JHttaW5YfSwgbWluWT0ke21pbll9LCBtYXhTdHJva2U9JHttYXhTdHJva2VXaWR0aH1weCwgdmFsaWRFbGVtZW50cz0ke3ZhbGlkRWxlbWVudHN9YFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBaRVJPLUJBU0VEIE9GRlNFVCBDQUxDVUxBVElPTjpcclxuICAgIC8vIFRoZSBnb2FsIGlzIHRvIGhhdmUgTk8gT0ZGU0VUIHVubGVzcyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBmb3IgbmVnYXRpdmUgY29vcmRpbmF0ZXNcclxuICAgIGxldCBvZmZzZXRYID0gMDtcclxuICAgIGxldCBvZmZzZXRZID0gMDtcclxuXHJcbiAgICAvLyBPbmx5IGFkZCBvZmZzZXQgaWYgY29vcmRpbmF0ZXMgYXJlIGFjdHVhbGx5IG5lZ2F0aXZlXHJcbiAgICBpZiAobWluWCA8IDApIHtcclxuICAgICAgb2Zmc2V0WCA9IE1hdGguYWJzKG1pblgpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4p2MIE5lZ2F0aXZlIFggZGV0ZWN0ZWQ6ICR7bWluWH0g4oaSIGFkZGluZyBvZmZzZXQ6ICR7b2Zmc2V0WH1gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1pblkgPCAwKSB7XHJcbiAgICAgIG9mZnNldFkgPSBNYXRoLmFicyhtaW5ZKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYOKdjCBOZWdhdGl2ZSBZIGRldGVjdGVkOiAke21pbll9IOKGkiBhZGRpbmcgb2Zmc2V0OiAke29mZnNldFl9YFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBtaW5pbWFsIHN0cm9rZSBwYWRkaW5nIG9ubHkgaWYgd2UgYWxyZWFkeSBoYXZlIGFuIG9mZnNldFxyXG4gICAgaWYgKChvZmZzZXRYID4gMCB8fCBvZmZzZXRZID4gMCkgJiYgbWF4U3Ryb2tlV2lkdGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IHN0cm9rZVBhZGRpbmcgPSBNYXRoLmNlaWwobWF4U3Ryb2tlV2lkdGggLyAyKTtcclxuICAgICAgaWYgKG9mZnNldFggPiAwKSBvZmZzZXRYICs9IHN0cm9rZVBhZGRpbmc7XHJcbiAgICAgIGlmIChvZmZzZXRZID4gMCkgb2Zmc2V0WSArPSBzdHJva2VQYWRkaW5nO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+WjO+4jyBBZGRlZCBzdHJva2UgcGFkZGluZzogJHtzdHJva2VQYWRkaW5nfXB4YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYPCfjq8gRklOQUwgT0ZGU0VUOiBYPSR7b2Zmc2V0WH0sIFk9JHtvZmZzZXRZfWApO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGAgICAke1xyXG4gICAgICAgIG9mZnNldFggPT09IDBcclxuICAgICAgICAgID8gXCLinIUgUGVyZmVjdCEgTm8gWCBvZmZzZXQgbmVlZGVkXCJcclxuICAgICAgICAgIDogYOKaoO+4jyBYIG9mZnNldDogJHtvZmZzZXRYfXB4ICgke21pblh9IHdhcyBuZWdhdGl2ZSlgXHJcbiAgICAgIH1gXHJcbiAgICApO1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGAgICAke1xyXG4gICAgICAgIG9mZnNldFkgPT09IDBcclxuICAgICAgICAgID8gXCLinIUgUGVyZmVjdCEgTm8gWSBvZmZzZXQgbmVlZGVkXCJcclxuICAgICAgICAgIDogYOKaoO+4jyBZIG9mZnNldDogJHtvZmZzZXRZfXB4ICgke21pbll9IHdhcyBuZWdhdGl2ZSlgXHJcbiAgICAgIH1gXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7IHg6IG9mZnNldFgsIHk6IG9mZnNldFkgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBwcmVjaXNlIGNvb3JkaW5hdGUgb2Zmc2V0IGZvciBwaXhlbC1wZXJmZWN0IEluRGVzaWduIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9uXHJcbiAgICogVGhpcyBlbnN1cmVzIGFjY3VyYXRlIHBvc2l0aW9uaW5nIHNpbWlsYXIgdG8gcHJvZmVzc2lvbmFsIHRvb2xzIGxpa2UgSU1HLkxZIEluRGVzaWduXHJcbiAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgLSBBcnJheSBvZiBlbGVtZW50cyB3aXRoIGJvdW5kcyBhbmQgdHJhbnNmb3Jtc1xyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0ge3gsIHl9IG9mZnNldCBmb3IgY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvblxyXG4gICAqL1xyXG4gIHN0YXRpYyBjYWxjdWxhdGVDb29yZGluYXRlT2Zmc2V0UHJlY2lzZShlbGVtZW50cykge1xyXG4gICAgaWYgKCFlbGVtZW50cyB8fCBlbGVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS53YXJuKFwi8J+OryBObyBlbGVtZW50cyBwcm92aWRlZCBmb3IgY29vcmRpbmF0ZSBvZmZzZXQgY2FsY3VsYXRpb25cIik7XHJcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgXCLwn5SNIEFOQUxZWklOR1wiLFxyXG4gICAgICBlbGVtZW50cy5sZW5ndGgsXHJcbiAgICAgIFwiZWxlbWVudHMgZm9yIFBSRUNJU0UgY29vcmRpbmF0ZSBvZmZzZXQuLi5cIlxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgbWluWCA9IEluZmluaXR5O1xyXG4gICAgbGV0IG1pblkgPSBJbmZpbml0eTtcclxuICAgIGxldCBtYXhTdHJva2UgPSAwO1xyXG4gICAgbGV0IHZhbGlkRWxlbWVudHMgPSAwO1xyXG5cclxuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmICghZWxlbWVudC5nZW9tZXRyaWNCb3VuZHMgfHwgIWVsZW1lbnQuaXRlbVRyYW5zZm9ybSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgIGAgICDimqDvuI8gRWxlbWVudCAke2luZGV4fSBtaXNzaW5nIGJvdW5kcy90cmFuc2Zvcm0gLSBza2lwcGluZ2BcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIGZpbmFsIHBvc2l0aW9uIChib3VuZHMgKyB0cmFuc2Zvcm0pXHJcbiAgICAgIGNvbnN0IGZpbmFsWCA9IGVsZW1lbnQuZ2VvbWV0cmljQm91bmRzLmxlZnQgKyBlbGVtZW50Lml0ZW1UcmFuc2Zvcm0udHg7XHJcbiAgICAgIGNvbnN0IGZpbmFsWSA9IGVsZW1lbnQuZ2VvbWV0cmljQm91bmRzLnRvcCArIGVsZW1lbnQuaXRlbVRyYW5zZm9ybS50eTtcclxuXHJcbiAgICAgIC8vIFRyYWNrIHN0cm9rZSB3aWR0aCBmb3IgcHJlY2lzZSBwb3NpdGlvbmluZ1xyXG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IGVsZW1lbnQuc3Ryb2tlV2VpZ2h0IHx8IDA7XHJcbiAgICAgIG1heFN0cm9rZSA9IE1hdGgubWF4KG1heFN0cm9rZSwgc3Ryb2tlV2lkdGgpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYCAgIEVsZW1lbnQgJHtpbmRleH06IGJvdW5kcygke2VsZW1lbnQuZ2VvbWV0cmljQm91bmRzLmxlZnR9LCAke2VsZW1lbnQuZ2VvbWV0cmljQm91bmRzLnRvcH0pICsgdHJhbnNmb3JtKCR7ZWxlbWVudC5pdGVtVHJhbnNmb3JtLnR4fSwgJHtlbGVtZW50Lml0ZW1UcmFuc2Zvcm0udHl9KSA9IGZpbmFsKCR7ZmluYWxYfSwgJHtmaW5hbFl9KWBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBmaW5hbFgpO1xyXG4gICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgZmluYWxZKTtcclxuICAgICAgdmFsaWRFbGVtZW50cysrO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwi8J+TiiBBTkFMWVNJUyBDT01QTEVURTpcIixcclxuICAgICAgYG1pblg9JHttaW5YfSwgbWluWT0ke21pbll9LCBtYXhTdHJva2U9JHttYXhTdHJva2V9cHgsIHZhbGlkRWxlbWVudHM9JHt2YWxpZEVsZW1lbnRzfWBcclxuICAgICk7XHJcblxyXG4gICAgLy8gRklYRUQ6IE9ubHkgYWRkIG9mZnNldCBpZiBjb29yZGluYXRlcyBhcmUgYWN0dWFsbHkgbmVnYXRpdmVcclxuICAgIC8vIERvbid0IGZvcmNlIGVsZW1lbnRzIHRvIHN0YXJ0IGF0IG9yaWdpbiAtIHByZXNlcnZlIEluRGVzaWduIHBvc2l0aW9uaW5nXHJcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XHJcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XHJcblxyXG4gICAgLy8gT25seSBoYW5kbGUgbmVnYXRpdmUgY29vcmRpbmF0ZXMgdGhhdCB3b3VsZCBiZSBjbGlwcGVkIGJ5IHRoZSBicm93c2VyXHJcbiAgICBpZiAobWluWCA8IDApIHtcclxuICAgICAgb2Zmc2V0WCA9IE1hdGguYWJzKG1pblgpICsgbWF4U3Ryb2tlO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4p2MIE5lZ2F0aXZlIFggZGV0ZWN0ZWQ6ICR7bWluWH0g4oaSIGFkZGluZyBvZmZzZXQ6ICR7b2Zmc2V0WH1gXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFBvc2l0aXZlIFggY29vcmRpbmF0ZXM6ICR7bWluWH0g4oaSIG5vIG9mZnNldCBuZWVkZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWluWSA8IDApIHtcclxuICAgICAgb2Zmc2V0WSA9IE1hdGguYWJzKG1pblkpICsgbWF4U3Ryb2tlO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBg4p2MIE5lZ2F0aXZlIFkgZGV0ZWN0ZWQ6ICR7bWluWX0g4oaSIGFkZGluZyBvZmZzZXQ6ICR7b2Zmc2V0WX1gXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFBvc2l0aXZlIFkgY29vcmRpbmF0ZXM6ICR7bWluWX0g4oaSIG5vIG9mZnNldCBuZWVkZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmaW5hbE9mZnNldCA9IHsgeDogb2Zmc2V0WCwgeTogb2Zmc2V0WSB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwi8J+OryBGSU5BTCBQUkVDSVNFIE9GRlNFVDpcIiwgYFg9JHtvZmZzZXRYfSwgWT0ke29mZnNldFl9YCk7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYCAgICR7XHJcbiAgICAgICAgb2Zmc2V0WCA9PT0gMFxyXG4gICAgICAgICAgPyBcIuKchSBQZXJmZWN0ISBObyBYIG9mZnNldCBuZWVkZWRcIlxyXG4gICAgICAgICAgOiBg4pqg77iPIFggb2Zmc2V0OiAke29mZnNldFh9cHggKGNvbXBlbnNhdGluZyBmb3IgbmVnYXRpdmUgY29vcmRpbmF0ZXMpYFxyXG4gICAgICB9YFxyXG4gICAgKTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBgICAgJHtcclxuICAgICAgICBvZmZzZXRZID09PSAwXHJcbiAgICAgICAgICA/IFwi4pyFIFBlcmZlY3QhIE5vIFkgb2Zmc2V0IG5lZWRlZFwiXHJcbiAgICAgICAgICA6IGDimqDvuI8gWSBvZmZzZXQ6ICR7b2Zmc2V0WX1weCAoY29tcGVuc2F0aW5nIGZvciBuZWdhdGl2ZSBjb29yZGluYXRlcylgXHJcbiAgICAgIH1gXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBmaW5hbE9mZnNldDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVCb3VuZHNGcm9tUGF0aChpdGVtKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IGJvdW5kcyBmcm9tIEdlb21ldHJpY0JvdW5kcyBhdHRyaWJ1dGVcclxuICAgICAgaWYgKGl0ZW1bXCJAX0dlb21ldHJpY0JvdW5kc1wiXSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlR2VvbWV0cmljQm91bmRzKGl0ZW1bXCJAX0dlb21ldHJpY0JvdW5kc1wiXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZW4gdHJ5IHBhdGggZ2VvbWV0cnlcclxuICAgICAgY29uc3QgcGF0aEdlb21ldHJ5ID1cclxuICAgICAgICBpdGVtPy5Qcm9wZXJ0aWVzPy5QYXRoR2VvbWV0cnk/Lkdlb21ldHJ5UGF0aFR5cGU/LlBhdGhQb2ludEFycmF5XHJcbiAgICAgICAgICA/LlBhdGhQb2ludFR5cGU7XHJcblxyXG4gICAgICBpZiAoIXBhdGhHZW9tZXRyeSB8fCAhQXJyYXkuaXNBcnJheShwYXRoR2VvbWV0cnkpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgV2FybmluZzogTm8gZ2VvbWV0cnkgZm91bmQgZm9yICR7aXRlbVtcIkBfU2VsZlwiXX0sIHVzaW5nIGl0ZW0gdHJhbnNmb3JtYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGl0ZW0gdHJhbnNmb3JtIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMucGFyc2VUcmFuc2Zvcm0oaXRlbVtcIkBfSXRlbVRyYW5zZm9ybVwiXSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHRvcDogdHJhbnNmb3JtLnR5IHx8IDAsXHJcbiAgICAgICAgICBsZWZ0OiB0cmFuc2Zvcm0udHggfHwgMCxcclxuICAgICAgICAgIGJvdHRvbTogKHRyYW5zZm9ybS50eSB8fCAwKSArIDEwMCwgLy8gRGVmYXVsdCBoZWlnaHRcclxuICAgICAgICAgIHJpZ2h0OiAodHJhbnNmb3JtLnR4IHx8IDApICsgMTAwLCAvLyBEZWZhdWx0IHdpZHRoXHJcbiAgICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgICAgaGVpZ2h0OiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IG1pblggPSBJbmZpbml0eSxcclxuICAgICAgICBtaW5ZID0gSW5maW5pdHksXHJcbiAgICAgICAgbWF4WCA9IC1JbmZpbml0eSxcclxuICAgICAgICBtYXhZID0gLUluZmluaXR5O1xyXG5cclxuICAgICAgcGF0aEdlb21ldHJ5LmZvckVhY2goKHBvaW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yID0gcG9pbnRbXCJAX0FuY2hvclwiXTtcclxuICAgICAgICBpZiAoYW5jaG9yKSB7XHJcbiAgICAgICAgICBjb25zdCBbeCwgeV0gPSBhbmNob3Iuc3BsaXQoXCIgXCIpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgICAgICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XHJcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcclxuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xyXG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XHJcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKG1pblggPT09IEluZmluaXR5IHx8IG1pblkgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgV2FybmluZzogQ291bGQgbm90IGNhbGN1bGF0ZSBib3VuZHMgZm9yICR7aXRlbVtcIkBfU2VsZlwiXX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgIGJvdHRvbTogMTAwLFxyXG4gICAgICAgICAgcmlnaHQ6IDEwMCxcclxuICAgICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogbWluWSxcclxuICAgICAgICBsZWZ0OiBtaW5YLFxyXG4gICAgICAgIGJvdHRvbTogbWF4WSxcclxuICAgICAgICByaWdodDogbWF4WCxcclxuICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXHJcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWSxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNhbGN1bGF0aW5nIGJvdW5kcyBmb3IgJHtpdGVtW1wiQF9TZWxmXCJdfTpgLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgYm90dG9tOiAxMDAsXHJcbiAgICAgICAgcmlnaHQ6IDEwMCxcclxuICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZVJlbGF0aXZlUG9zaXRpb24oXHJcbiAgICBmcmFtZUJvdW5kcyxcclxuICAgIGNvbnRlbnRCb3VuZHMsXHJcbiAgICBmcmFtZVRyYW5zZm9ybSxcclxuICAgIGNvbnRlbnRUcmFuc2Zvcm1cclxuICApIHtcclxuICAgIGlmICghZnJhbWVCb3VuZHMgfHwgIWNvbnRlbnRCb3VuZHMpIHJldHVybiBudWxsO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9mZnNldFg6IChjb250ZW50Qm91bmRzLmxlZnQgfHwgMCkgLSAoZnJhbWVCb3VuZHMubGVmdCB8fCAwKSxcclxuICAgICAgb2Zmc2V0WTogKGNvbnRlbnRCb3VuZHMudG9wIHx8IDApIC0gKGZyYW1lQm91bmRzLnRvcCB8fCAwKSxcclxuICAgICAgc2NhbGVYOiBjb250ZW50VHJhbnNmb3JtPy5hIHx8IDEsXHJcbiAgICAgIHNjYWxlWTogY29udGVudFRyYW5zZm9ybT8uZCB8fCAxLFxyXG4gICAgICB0cmFuc2Zvcm1EaWZmZXJlbmNlOiB7XHJcbiAgICAgICAgZnJhbWU6IGZyYW1lVHJhbnNmb3JtLFxyXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRUcmFuc2Zvcm0sXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbGN1bGF0ZUdhcChmcmFtZUJvdW5kcywgY29udGVudEJvdW5kcykge1xyXG4gICAgaWYgKCFmcmFtZUJvdW5kcyB8fCAhY29udGVudEJvdW5kcykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiAoY29udGVudEJvdW5kcy50b3AgfHwgMCkgLSAoZnJhbWVCb3VuZHMudG9wIHx8IDApLFxyXG4gICAgICBsZWZ0OiAoY29udGVudEJvdW5kcy5sZWZ0IHx8IDApIC0gKGZyYW1lQm91bmRzLmxlZnQgfHwgMCksXHJcbiAgICAgIGJvdHRvbTogKGZyYW1lQm91bmRzLmJvdHRvbSB8fCAwKSAtIChjb250ZW50Qm91bmRzLmJvdHRvbSB8fCAwKSxcclxuICAgICAgcmlnaHQ6IChmcmFtZUJvdW5kcy5yaWdodCB8fCAwKSAtIChjb250ZW50Qm91bmRzLnJpZ2h0IHx8IDApLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYWxjdWxhdGVJbWFnZVBvc2l0aW9uSW5GcmFtZShcclxuICAgIGZyYW1lQm91bmRzLFxyXG4gICAgZnJhbWVUcmFuc2Zvcm0sXHJcbiAgICBwbGFjZWRDb250ZW50XHJcbiAgKSB7XHJcbiAgICBpZiAoIWZyYW1lQm91bmRzIHx8ICFwbGFjZWRDb250ZW50Py50cmFuc2Zvcm0pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW1hZ2VUcmFuc2Zvcm0gPSBwbGFjZWRDb250ZW50LnRyYW5zZm9ybTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgaW1hZ2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gZnJhbWVcclxuICAgIGNvbnN0IGltYWdlWCA9IChmcmFtZUJvdW5kcy5sZWZ0IHx8IDApICsgKGltYWdlVHJhbnNmb3JtLnR4IHx8IDApO1xyXG4gICAgY29uc3QgaW1hZ2VZID0gKGZyYW1lQm91bmRzLnRvcCB8fCAwKSArIChpbWFnZVRyYW5zZm9ybS50eSB8fCAwKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgaW1hZ2Ugc2l6ZSB3aXRoIHNjYWxpbmdcclxuICAgIGNvbnN0IGltYWdlV2lkdGggPSAoZnJhbWVCb3VuZHMud2lkdGggfHwgMCkgKiAoaW1hZ2VUcmFuc2Zvcm0uYSB8fCAxKTtcclxuICAgIGNvbnN0IGltYWdlSGVpZ2h0ID0gKGZyYW1lQm91bmRzLmhlaWdodCB8fCAwKSAqIChpbWFnZVRyYW5zZm9ybS5kIHx8IDEpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGltYWdlWCxcclxuICAgICAgeTogaW1hZ2VZLFxyXG4gICAgICB3aWR0aDogaW1hZ2VXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBpbWFnZUhlaWdodCxcclxuICAgICAgc2NhbGVYOiBpbWFnZVRyYW5zZm9ybS5hIHx8IDEsXHJcbiAgICAgIHNjYWxlWTogaW1hZ2VUcmFuc2Zvcm0uZCB8fCAxLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRYTUxTdHJ1Y3R1cmUob2JqLCBtYXhEZXB0aCA9IDMsIGN1cnJlbnREZXB0aCA9IDApIHtcclxuICAgIGlmIChjdXJyZW50RGVwdGggPj0gbWF4RGVwdGggfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RydWN0dXJlID0ge307XHJcblxyXG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XHJcbiAgICAgICAgc3RydWN0dXJlW2tleV0gPSBgQXJyYXlbJHtvYmpba2V5XS5sZW5ndGh9XWA7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtrZXldID09PSBcIm9iamVjdFwiICYmIG9ialtrZXldICE9PSBudWxsKSB7XHJcbiAgICAgICAgc3RydWN0dXJlW2tleV0gPSB0aGlzLmdldFhNTFN0cnVjdHVyZShcclxuICAgICAgICAgIG9ialtrZXldLFxyXG4gICAgICAgICAgbWF4RGVwdGgsXHJcbiAgICAgICAgICBjdXJyZW50RGVwdGggKyAxXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHJ1Y3R1cmVba2V5XSA9IHR5cGVvZiBvYmpba2V5XTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHN0cnVjdHVyZTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBpc0Zvcm1hdHRpbmdBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkge1xyXG4gICAgY29uc3QgZm9ybWF0dGluZ0F0dHJpYnV0ZXMgPSBbXHJcbiAgICAgIFwiQF9Qb2ludFNpemVcIixcclxuICAgICAgXCJAX0xlYWRpbmdcIixcclxuICAgICAgXCJAX1RyYWNraW5nXCIsXHJcbiAgICAgIFwiQF9Gb250U3R5bGVcIixcclxuICAgICAgXCJAX0FwcGxpZWRGb250XCIsXHJcbiAgICAgIFwiQF9GaWxsQ29sb3JcIixcclxuICAgICAgXCJAX1N0cm9rZUNvbG9yXCIsXHJcbiAgICAgIFwiQF9KdXN0aWZpY2F0aW9uXCIsXHJcbiAgICAgIFwiQF9MZWZ0SW5kZW50XCIsXHJcbiAgICAgIFwiQF9SaWdodEluZGVudFwiLFxyXG4gICAgICBcIkBfRmlyc3RMaW5lSW5kZW50XCIsXHJcbiAgICAgIFwiQF9TcGFjZUJlZm9yZVwiLFxyXG4gICAgICBcIkBfU3BhY2VBZnRlclwiLFxyXG4gICAgICBcIkBfQWxpZ25tZW50XCIsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGZvcm1hdHRpbmdBdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHNhdmVEZWJ1Z0luZm8oZGVidWdJbmZvLCBmaWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlTmFtZSwgSlNPTi5zdHJpbmdpZnkoZGVidWdJbmZvLCBudWxsLCAyKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgRGVidWcgaW5mbyBzYXZlZCB0byAke2ZpbGVOYW1lfWApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBzYXZpbmcgZGVidWcgaW5mbzpcIiwgZXJyb3IpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIkRlYnVnIGluZm8gKGZpcnN0IDIwMDAgY2hhcnMpOlwiLFxyXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGRlYnVnSW5mbywgbnVsbCwgMikuc3Vic3RyaW5nKDAsIDIwMDApXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElETUxVdGlscztcclxuIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwiZnMiLCJJRE1MVXRpbHMiLCJwYXJzZUdlb21ldHJpY0JvdW5kcyIsImJvdW5kc1N0cmluZyIsImNvbnNvbGUiLCJsb2ciLCJ0b3AiLCJsZWZ0IiwiYm90dG9tIiwicmlnaHQiLCJ3aWR0aCIsImhlaWdodCIsImJvdW5kcyIsInNwbGl0IiwibWFwIiwicGFyc2VGbG9hdCIsInJlc3VsdCIsInBhcnNlVHJhbnNmb3JtIiwidHJhbnNmb3JtU3RyaW5nIiwiYSIsImIiLCJjIiwiZCIsInR4IiwidHkiLCJ2YWx1ZXMiLCJjYWxjdWxhdGVSb3RhdGlvbiIsInRyYW5zZm9ybSIsIk1hdGgiLCJhdGFuMiIsIlBJIiwiY2FsY3VsYXRlQ29ybmVycyIsImNvcm5lcnMiLCJ0b3BMZWZ0IiwieCIsInkiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiY29ybmVyIiwicG9pbnQiLCJjbXlrVG9SZ2IiLCJtIiwiayIsInIiLCJyb3VuZCIsImciLCJwYXJzZUluRGVzaWduQ29sb3IiLCJjb2xvclJlZiIsImNteWtNYXRjaCIsIm1hdGNoIiwiTnVtYmVyIiwicmdiIiwicmdiTWF0Y2giLCJzdGFuZGFyZENvbG9ycyIsImRlY29kZVhNTEVudGl0aWVzIiwidGV4dCIsInJlcGxhY2UiLCJjbGVhblRleHRDb250ZW50IiwiY29udGVudCIsInRyaW0iLCJwcmVzZXJ2ZUxpbmVCcmVha3MiLCJjbGVhblRleHRGb3JSZW5kZXJpbmciLCJzb3BoaXN0aWNhdGVkTGluZUJyZWFrUHJvY2Vzc2luZyIsImhhc1Byb2JsZW1hdGljVGV4dCIsImluY2x1ZGVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInByb2Nlc3NlZCIsImNvdW50V29yZHMiLCJmaWx0ZXIiLCJ3b3JkIiwibGVuZ3RoIiwicGFyc2VOdW1lcmljIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJudW0iLCJpc05hTiIsImlzSW1hZ2VGaWxlIiwiZmlsZU5hbWUiLCJpbWFnZUV4dGVuc2lvbnMiLCJzb21lIiwiZXh0IiwidG9Mb3dlckNhc2UiLCJlbmRzV2l0aCIsImdldEltYWdlRXh0ZW5zaW9uIiwiaW1hZ2VUeXBlTmFtZSIsInR5cGVNYXAiLCJnZXRJbWFnZUV4dGVuc2lvbkZyb21Gb3JtYXQiLCJmb3JtYXQiLCJmb3JtYXRNYXAiLCJleHRyYWN0SW1hZ2VOYW1lRnJvbUxpbmsiLCJsaW5rVXJpIiwiY2FsY3VsYXRlQ29vcmRpbmF0ZU9mZnNldCIsImVsZW1lbnRzIiwibWluWCIsIkluZmluaXR5IiwibWluWSIsIm1heFN0cm9rZVdpZHRoIiwidmFsaWRFbGVtZW50cyIsImVsZW1lbnQiLCJpbmRleCIsImdlb21ldHJpY0JvdW5kcyIsIm9yaWdpbmFsQm91bmRzIiwiaXRlbVRyYW5zZm9ybSIsImZpbmFsWCIsImZpbmFsWSIsIm1pbiIsInN0cm9rZVdpZHRoIiwic3Ryb2tlV2VpZ2h0IiwibWF4Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJhYnMiLCJzdHJva2VQYWRkaW5nIiwiY2VpbCIsImNhbGN1bGF0ZUNvb3JkaW5hdGVPZmZzZXRQcmVjaXNlIiwid2FybiIsIm1heFN0cm9rZSIsImZpbmFsT2Zmc2V0IiwiY2FsY3VsYXRlQm91bmRzRnJvbVBhdGgiLCJpdGVtIiwicGF0aEdlb21ldHJ5IiwiUHJvcGVydGllcyIsIlBhdGhHZW9tZXRyeSIsIkdlb21ldHJ5UGF0aFR5cGUiLCJQYXRoUG9pbnRBcnJheSIsIlBhdGhQb2ludFR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJtYXhYIiwibWF4WSIsImFuY2hvciIsImVycm9yIiwiY2FsY3VsYXRlUmVsYXRpdmVQb3NpdGlvbiIsImZyYW1lQm91bmRzIiwiY29udGVudEJvdW5kcyIsImZyYW1lVHJhbnNmb3JtIiwiY29udGVudFRyYW5zZm9ybSIsInNjYWxlWCIsInNjYWxlWSIsInRyYW5zZm9ybURpZmZlcmVuY2UiLCJmcmFtZSIsImNhbGN1bGF0ZUdhcCIsImNhbGN1bGF0ZUltYWdlUG9zaXRpb25JbkZyYW1lIiwicGxhY2VkQ29udGVudCIsImltYWdlVHJhbnNmb3JtIiwiaW1hZ2VYIiwiaW1hZ2VZIiwiaW1hZ2VXaWR0aCIsImltYWdlSGVpZ2h0IiwiZ2V0WE1MU3RydWN0dXJlIiwib2JqIiwibWF4RGVwdGgiLCJjdXJyZW50RGVwdGgiLCJzdHJ1Y3R1cmUiLCJrZXkiLCJpc0Zvcm1hdHRpbmdBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVOYW1lIiwiZm9ybWF0dGluZ0F0dHJpYnV0ZXMiLCJzYXZlRGVidWdJbmZvIiwiZGVidWdJbmZvIiwid3JpdGVGaWxlU3luYyIsInN1YnN0cmluZyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/utils/IDMLUtils.js\n");

/***/ }),

/***/ "./lib/utils/InDesignTextMetrics.js":
/*!******************************************!*\
  !*** ./lib/utils/InDesignTextMetrics.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\r\n * InDesignTextMetrics.js - Precise text measurement utility for 1:1 InDesign compatibility\r\n * Handles font metrics, leading calculations, and text frame insets exactly like InDesign\r\n */ \nclass InDesignTextMetrics {\n    /**\r\n   * Calculate precise text frame dimensions including InDesign-specific insets\r\n   * @param {object} textFrame - The text frame element\r\n   * @param {object} textFramePrefs - Text frame preferences from InDesign\r\n   * @returns {object} Adjusted frame dimensions\r\n   */ static calculateTextFrameInsets(textFrame, textFramePrefs) {\n        // InDesign default text frame insets (in points)\n        const DEFAULT_INSETS = {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        };\n        // Extract insets from preferences if available\n        const insets = {\n            top: textFramePrefs?.insetSpacing?.top || textFramePrefs?.textInsets?.top || DEFAULT_INSETS.top,\n            bottom: textFramePrefs?.insetSpacing?.bottom || textFramePrefs?.textInsets?.bottom || DEFAULT_INSETS.bottom,\n            left: textFramePrefs?.insetSpacing?.left || textFramePrefs?.textInsets?.left || DEFAULT_INSETS.left,\n            right: textFramePrefs?.insetSpacing?.right || textFramePrefs?.textInsets?.right || DEFAULT_INSETS.right\n        };\n        // Calculate content area (available for text)\n        const contentArea = {\n            width: Math.max(0, textFrame.position.width - insets.left - insets.right),\n            height: Math.max(0, textFrame.position.height - insets.top - insets.bottom),\n            offsetX: insets.left,\n            offsetY: insets.top\n        };\n        return {\n            originalFrame: textFrame.position,\n            insets,\n            contentArea,\n            hasInsets: insets.top > 0 || insets.bottom > 0 || insets.left > 0 || insets.right > 0\n        };\n    }\n    /**\r\n   * Convert InDesign leading to precise CSS line-height\r\n   * @param {number|string} leading - InDesign leading value\r\n   * @param {number} fontSize - Font size in points\r\n   * @param {string} leadingType - Type of leading (auto, absolute, percentage)\r\n   * @returns {object} CSS-compatible line height info\r\n   */ static convertLeadingToCSS(leading, fontSize, leadingType = \"auto\") {\n        let cssLineHeight;\n        let lineHeightPx;\n        switch(leadingType){\n            case \"auto\":\n                // InDesign auto leading is typically 120% of font size\n                cssLineHeight = 1.2;\n                lineHeightPx = fontSize * 1.2;\n                break;\n            case \"absolute\":\n                // Leading is in points, convert to line-height ratio\n                if (typeof leading === \"number\" && leading > 0) {\n                    cssLineHeight = Math.max(0.8, leading / fontSize);\n                    lineHeightPx = leading;\n                } else {\n                    cssLineHeight = 1.2;\n                    lineHeightPx = fontSize * 1.2;\n                }\n                break;\n            case \"percentage\":\n                // Leading is percentage-based\n                const percentage = parseFloat(leading) / 100;\n                cssLineHeight = Math.max(0.8, percentage);\n                lineHeightPx = fontSize * percentage;\n                break;\n            default:\n                cssLineHeight = 1.2;\n                lineHeightPx = fontSize * 1.2;\n        }\n        return {\n            cssLineHeight: Math.round(cssLineHeight * 1000) / 1000,\n            lineHeightPx: Math.round(lineHeightPx * 100) / 100,\n            leadingType,\n            originalLeading: leading\n        };\n    }\n    /**\r\n   * Calculate first baseline offset according to InDesign rules\r\n   * @param {string} firstBaselineOffset - InDesign first baseline offset setting\r\n   * @param {number} fontSize - Font size in points\r\n   * @param {number} lineHeight - Line height in points\r\n   * @returns {number} First baseline offset in points\r\n   */ static calculateFirstBaselineOffset(firstBaselineOffset, fontSize, lineHeight) {\n        switch(firstBaselineOffset){\n            case \"AscentOffset\":\n                // Text sits at natural ascent line (default)\n                return fontSize * 0.8; // Approximate ascent for most fonts\n            case \"CapHeightOffset\":\n                // Text sits at cap height\n                return fontSize * 0.7; // Approximate cap height for most fonts\n            case \"FixedHeight\":\n                // Custom fixed height - use line height\n                return lineHeight;\n            case \"XHeightOffset\":\n                // Text sits at x-height\n                return fontSize * 0.5; // Approximate x-height for most fonts\n            default:\n                return fontSize * 0.8; // Default to ascent offset\n        }\n    }\n    /**\r\n   * Measure text accurately using canvas with InDesign-specific adjustments\r\n   * @param {string} text - Text to measure\r\n   * @param {object} textStyles - Complete text styling object\r\n   * @param {object} frameMetrics - Text frame metrics\r\n   * @returns {object} Precise text measurement data\r\n   */ static measureTextPrecisely(text, textStyles, frameMetrics) {\n        if (!text || text.trim() === \"\") {\n            return {\n                textWidth: 0,\n                textHeight: 0,\n                lineCount: 0,\n                lines: [],\n                willOverflow: false,\n                fits: true\n            };\n        }\n        // Create canvas for measurement\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        // Set font with proper fallbacks\n        const fontSize = parseFloat(textStyles.fontSize) || 12;\n        const fontFamily = textStyles.fontFamily || \"Arial, sans-serif\";\n        const fontWeight = textStyles.fontWeight || \"normal\";\n        const fontStyle = textStyles.fontStyle || \"normal\";\n        ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n        // Calculate effective content width accounting for tracking\n        const tracking = textStyles.tracking || 0;\n        const trackingAdjustment = tracking * fontSize / 1000; // Convert em to px\n        const effectiveWidth = Math.max(10, frameMetrics.contentArea.width - Math.abs(trackingAdjustment) - 2); // Leave 2px margin\n        // Split text into words for accurate wrapping, preserving line breaks\n        const words = text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\").split(/(\\s+|\\n)/).filter((word)=>word.length > 0);\n        const lines = [];\n        let currentLine = \"\";\n        let currentLineWidth = 0;\n        // Measure space width once\n        const spaceWidth = ctx.measureText(\" \").width + trackingAdjustment;\n        for(let i = 0; i < words.length; i++){\n            const word = words[i];\n            // Handle explicit line breaks\n            if (word === \"\\n\") {\n                if (currentLine) {\n                    lines.push({\n                        text: currentLine,\n                        width: currentLineWidth\n                    });\n                    currentLine = \"\";\n                    currentLineWidth = 0;\n                }\n                continue;\n            }\n            // Skip pure whitespace (except spaces)\n            if (/^\\s+$/.test(word) && word !== \" \") {\n                continue;\n            }\n            const wordWidth = ctx.measureText(word).width + Math.max(0, word.length - 1) * trackingAdjustment;\n            // Check if word fits on current line\n            const wordWithSpaceWidth = currentLine && word !== \" \" ? wordWidth + spaceWidth : wordWidth;\n            if (currentLine && word !== \" \" && currentLineWidth + wordWithSpaceWidth > effectiveWidth) {\n                // Word doesn't fit, start new line\n                lines.push({\n                    text: currentLine,\n                    width: currentLineWidth\n                });\n                currentLine = word;\n                currentLineWidth = wordWidth;\n            } else {\n                // Word fits, add to current line\n                if (currentLine && word !== \" \") {\n                    currentLine += \" \" + word;\n                    currentLineWidth += wordWithSpaceWidth;\n                } else if (word !== \" \") {\n                    currentLine = word;\n                    currentLineWidth = wordWidth;\n                }\n            }\n        }\n        // Add the last line\n        if (currentLine) {\n            lines.push({\n                text: currentLine,\n                width: currentLineWidth\n            });\n        }\n        // Calculate text height using InDesign-accurate leading\n        const lineHeightInfo = this.convertLeadingToCSS(textStyles.leading, fontSize, textStyles.leadingType);\n        const lineCount = Math.max(1, lines.length);\n        const firstBaselineOffset = this.calculateFirstBaselineOffset(textStyles.firstBaselineOffset || \"AscentOffset\", fontSize, lineHeightInfo.lineHeightPx);\n        // Calculate total text height including first baseline offset\n        const textHeight = firstBaselineOffset + (lineCount - 1) * lineHeightInfo.lineHeightPx;\n        // Check if text overflows the available height\n        const willOverflow = textHeight > frameMetrics.contentArea.height;\n        return {\n            textWidth: Math.max(...lines.map((line)=>line.width)),\n            textHeight: Math.round(textHeight * 100) / 100,\n            lineCount,\n            lines,\n            lineHeightPx: lineHeightInfo.lineHeightPx,\n            firstBaselineOffset,\n            willOverflow,\n            fits: !willOverflow,\n            availableHeight: frameMetrics.contentArea.height,\n            overflowAmount: willOverflow ? textHeight - frameMetrics.contentArea.height : 0,\n            // Detailed metrics for debugging\n            metrics: {\n                fontSize,\n                leading: textStyles.leading,\n                leadingType: textStyles.leadingType,\n                effectiveWidth,\n                tracking: trackingAdjustment,\n                spaceWidth\n            }\n        };\n    }\n    /**\r\n   * Calculate optimal font size to prevent overflow while maintaining design integrity\r\n   * @param {object} textMeasurement - Result from measureTextPrecisely\r\n   * @param {object} originalStyles - Original text styles\r\n   * @param {number} maxReduction - Maximum font size reduction allowed (0.0-1.0)\r\n   * @returns {object} Adjusted text styles or null if no adjustment needed\r\n   */ static calculateOptimalFontSize(textMeasurement, originalStyles, maxReduction = 0.25) {\n        if (!textMeasurement.willOverflow) {\n            return null; // No adjustment needed\n        }\n        const originalFontSize = parseFloat(originalStyles.fontSize) || 12;\n        const overflowRatio = textMeasurement.textHeight / textMeasurement.availableHeight;\n        console.log(\"\\uD83D\\uDD27 calculateOptimalFontSize:\", {\n            originalFontSize,\n            textHeight: textMeasurement.textHeight,\n            availableHeight: textMeasurement.availableHeight,\n            overflowRatio,\n            overflowAmount: textMeasurement.overflowAmount\n        });\n        // Calculate required scale factor to fit exactly\n        let scaleFactor = 1 / overflowRatio;\n        // Apply maximum reduction limit to preserve design integrity\n        const minAllowedScale = 1 - maxReduction;\n        const finalScaleFactor = Math.max(minAllowedScale, scaleFactor);\n        const newFontSize = originalFontSize * finalScaleFactor;\n        console.log(\"\\uD83D\\uDD27 Scale calculation:\", {\n            requiredScale: scaleFactor,\n            maxReduction,\n            minAllowedScale,\n            finalScaleFactor,\n            newFontSize\n        });\n        // Calculate if text will still overflow after adjustment\n        const willStillOverflow = finalScaleFactor > scaleFactor;\n        return {\n            adjustedStyles: {\n                ...originalStyles,\n                fontSize: `${Math.round(newFontSize * 100) / 100}px`,\n                // Also adjust line-height proportionally if needed\n                lineHeight: overflowRatio > 1.3 ? Math.max(0.9, parseFloat(originalStyles.lineHeight || \"1.2\") * finalScaleFactor) : originalStyles.lineHeight\n            },\n            adjustmentType: willStillOverflow ? \"partial_font_reduction\" : \"font_size_optimized\",\n            scaleFactor: finalScaleFactor,\n            originalFontSize,\n            newFontSize: Math.round(newFontSize * 100) / 100,\n            stillOverflows: willStillOverflow,\n            reductionApplied: ((1 - finalScaleFactor) * 100).toFixed(1) + \"%\"\n        };\n    }\n    /**\r\n   * Generate CSS styles with InDesign-accurate typography\r\n   * @param {object} inDesignFormatting - Formatting object from InDesign\r\n   * @param {object} frameMetrics - Text frame metrics\r\n   * @returns {object} CSS styles optimized for InDesign compatibility\r\n   */ static generateInDesignCSS(inDesignFormatting, frameMetrics) {\n        const fontSize = inDesignFormatting.fontSize || 12;\n        // Convert leading to CSS\n        const lineHeightInfo = this.convertLeadingToCSS(inDesignFormatting.leading, fontSize, inDesignFormatting.leadingType);\n        // Calculate first baseline offset for positioning\n        const firstBaselineOffset = this.calculateFirstBaselineOffset(inDesignFormatting.firstBaselineOffset || \"AscentOffset\", fontSize, lineHeightInfo.lineHeightPx);\n        return {\n            // Typography\n            fontSize: `${fontSize}px`,\n            lineHeight: lineHeightInfo.cssLineHeight,\n            fontFamily: inDesignFormatting.fontFamily || \"Arial, sans-serif\",\n            fontWeight: inDesignFormatting.fontWeight || \"normal\",\n            fontStyle: inDesignFormatting.fontStyle || \"normal\",\n            // Advanced typography\n            letterSpacing: inDesignFormatting.tracking ? `${inDesignFormatting.tracking / 1000}em` : \"normal\",\n            textAlign: inDesignFormatting.textAlign || \"left\",\n            color: inDesignFormatting.color || \"black\",\n            // Layout and positioning - minimal padding to avoid excessive top spacing\n            padding: `${Math.min(2, firstBaselineOffset * 0.3)}px ${frameMetrics.insets.right}px ${frameMetrics.insets.bottom}px ${frameMetrics.insets.left}px`,\n            margin: 0,\n            // Overflow control\n            width: `${frameMetrics.contentArea.width}px`,\n            height: `${frameMetrics.contentArea.height}px`,\n            overflow: \"hidden\",\n            boxSizing: \"border-box\",\n            // Text layout optimization\n            whiteSpace: \"normal\",\n            wordWrap: \"break-word\",\n            overflowWrap: \"break-word\",\n            wordBreak: \"normal\",\n            // InDesign-specific adjustments\n            position: \"relative\",\n            top: frameMetrics.hasInsets ? `${frameMetrics.offsetY}px` : \"0\",\n            left: frameMetrics.hasInsets ? `${frameMetrics.offsetX}px` : \"0\",\n            // Debug info (can be removed in production)\n            \"--indesign-leading\": inDesignFormatting.leading,\n            \"--indesign-leading-type\": inDesignFormatting.leadingType,\n            \"--css-line-height\": lineHeightInfo.cssLineHeight,\n            \"--first-baseline-offset\": `${firstBaselineOffset}px`\n        };\n    }\n}\n// Export for use in other modules\nif ( true && module.exports) {\n    module.exports = InDesignTextMetrics;\n} else if (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZXRyaWNzLmpzPzdlNWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEluRGVzaWduVGV4dE1ldHJpY3MuanMgLSBQcmVjaXNlIHRleHQgbWVhc3VyZW1lbnQgdXRpbGl0eSBmb3IgMToxIEluRGVzaWduIGNvbXBhdGliaWxpdHlcclxuICogSGFuZGxlcyBmb250IG1ldHJpY3MsIGxlYWRpbmcgY2FsY3VsYXRpb25zLCBhbmQgdGV4dCBmcmFtZSBpbnNldHMgZXhhY3RseSBsaWtlIEluRGVzaWduXHJcbiAqL1xyXG5cclxuY2xhc3MgSW5EZXNpZ25UZXh0TWV0cmljcyB7XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHByZWNpc2UgdGV4dCBmcmFtZSBkaW1lbnNpb25zIGluY2x1ZGluZyBJbkRlc2lnbi1zcGVjaWZpYyBpbnNldHNcclxuICAgKiBAcGFyYW0ge29iamVjdH0gdGV4dEZyYW1lIC0gVGhlIHRleHQgZnJhbWUgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0ZXh0RnJhbWVQcmVmcyAtIFRleHQgZnJhbWUgcHJlZmVyZW5jZXMgZnJvbSBJbkRlc2lnblxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IEFkanVzdGVkIGZyYW1lIGRpbWVuc2lvbnNcclxuICAgKi9cclxuICBzdGF0aWMgY2FsY3VsYXRlVGV4dEZyYW1lSW5zZXRzKHRleHRGcmFtZSwgdGV4dEZyYW1lUHJlZnMpIHtcclxuICAgIC8vIEluRGVzaWduIGRlZmF1bHQgdGV4dCBmcmFtZSBpbnNldHMgKGluIHBvaW50cylcclxuICAgIGNvbnN0IERFRkFVTFRfSU5TRVRTID0ge1xyXG4gICAgICB0b3A6IDAsXHJcbiAgICAgIGJvdHRvbTogMCxcclxuICAgICAgbGVmdDogMCxcclxuICAgICAgcmlnaHQ6IDBcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgaW5zZXRzIGZyb20gcHJlZmVyZW5jZXMgaWYgYXZhaWxhYmxlXHJcbiAgICBjb25zdCBpbnNldHMgPSB7XHJcbiAgICAgIHRvcDogdGV4dEZyYW1lUHJlZnM/Lmluc2V0U3BhY2luZz8udG9wIHx8IHRleHRGcmFtZVByZWZzPy50ZXh0SW5zZXRzPy50b3AgfHwgREVGQVVMVF9JTlNFVFMudG9wLFxyXG4gICAgICBib3R0b206IHRleHRGcmFtZVByZWZzPy5pbnNldFNwYWNpbmc/LmJvdHRvbSB8fCB0ZXh0RnJhbWVQcmVmcz8udGV4dEluc2V0cz8uYm90dG9tIHx8IERFRkFVTFRfSU5TRVRTLmJvdHRvbSxcclxuICAgICAgbGVmdDogdGV4dEZyYW1lUHJlZnM/Lmluc2V0U3BhY2luZz8ubGVmdCB8fCB0ZXh0RnJhbWVQcmVmcz8udGV4dEluc2V0cz8ubGVmdCB8fCBERUZBVUxUX0lOU0VUUy5sZWZ0LFxyXG4gICAgICByaWdodDogdGV4dEZyYW1lUHJlZnM/Lmluc2V0U3BhY2luZz8ucmlnaHQgfHwgdGV4dEZyYW1lUHJlZnM/LnRleHRJbnNldHM/LnJpZ2h0IHx8IERFRkFVTFRfSU5TRVRTLnJpZ2h0XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgY29udGVudCBhcmVhIChhdmFpbGFibGUgZm9yIHRleHQpXHJcbiAgICBjb25zdCBjb250ZW50QXJlYSA9IHtcclxuICAgICAgd2lkdGg6IE1hdGgubWF4KDAsIHRleHRGcmFtZS5wb3NpdGlvbi53aWR0aCAtIGluc2V0cy5sZWZ0IC0gaW5zZXRzLnJpZ2h0KSxcclxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCB0ZXh0RnJhbWUucG9zaXRpb24uaGVpZ2h0IC0gaW5zZXRzLnRvcCAtIGluc2V0cy5ib3R0b20pLFxyXG4gICAgICBvZmZzZXRYOiBpbnNldHMubGVmdCxcclxuICAgICAgb2Zmc2V0WTogaW5zZXRzLnRvcFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3JpZ2luYWxGcmFtZTogdGV4dEZyYW1lLnBvc2l0aW9uLFxyXG4gICAgICBpbnNldHMsXHJcbiAgICAgIGNvbnRlbnRBcmVhLFxyXG4gICAgICBoYXNJbnNldHM6IGluc2V0cy50b3AgPiAwIHx8IGluc2V0cy5ib3R0b20gPiAwIHx8IGluc2V0cy5sZWZ0ID4gMCB8fCBpbnNldHMucmlnaHQgPiAwXHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBDb252ZXJ0IEluRGVzaWduIGxlYWRpbmcgdG8gcHJlY2lzZSBDU1MgbGluZS1oZWlnaHRcclxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGxlYWRpbmcgLSBJbkRlc2lnbiBsZWFkaW5nIHZhbHVlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZvbnRTaXplIC0gRm9udCBzaXplIGluIHBvaW50c1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZWFkaW5nVHlwZSAtIFR5cGUgb2YgbGVhZGluZyAoYXV0bywgYWJzb2x1dGUsIHBlcmNlbnRhZ2UpXHJcbiAgICogQHJldHVybnMge29iamVjdH0gQ1NTLWNvbXBhdGlibGUgbGluZSBoZWlnaHQgaW5mb1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjb252ZXJ0TGVhZGluZ1RvQ1NTKGxlYWRpbmcsIGZvbnRTaXplLCBsZWFkaW5nVHlwZSA9ICdhdXRvJykge1xyXG4gICAgbGV0IGNzc0xpbmVIZWlnaHQ7XHJcbiAgICBsZXQgbGluZUhlaWdodFB4O1xyXG4gICAgXHJcbiAgICBzd2l0Y2ggKGxlYWRpbmdUeXBlKSB7XHJcbiAgICAgIGNhc2UgJ2F1dG8nOlxyXG4gICAgICAgIC8vIEluRGVzaWduIGF1dG8gbGVhZGluZyBpcyB0eXBpY2FsbHkgMTIwJSBvZiBmb250IHNpemVcclxuICAgICAgICBjc3NMaW5lSGVpZ2h0ID0gMS4yO1xyXG4gICAgICAgIGxpbmVIZWlnaHRQeCA9IGZvbnRTaXplICogMS4yO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIFxyXG4gICAgICBjYXNlICdhYnNvbHV0ZSc6XHJcbiAgICAgICAgLy8gTGVhZGluZyBpcyBpbiBwb2ludHMsIGNvbnZlcnQgdG8gbGluZS1oZWlnaHQgcmF0aW9cclxuICAgICAgICBpZiAodHlwZW9mIGxlYWRpbmcgPT09ICdudW1iZXInICYmIGxlYWRpbmcgPiAwKSB7XHJcbiAgICAgICAgICBjc3NMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoMC44LCBsZWFkaW5nIC8gZm9udFNpemUpO1xyXG4gICAgICAgICAgbGluZUhlaWdodFB4ID0gbGVhZGluZztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY3NzTGluZUhlaWdodCA9IDEuMjtcclxuICAgICAgICAgIGxpbmVIZWlnaHRQeCA9IGZvbnRTaXplICogMS4yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgICBcclxuICAgICAgY2FzZSAncGVyY2VudGFnZSc6XHJcbiAgICAgICAgLy8gTGVhZGluZyBpcyBwZXJjZW50YWdlLWJhc2VkXHJcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnNlRmxvYXQobGVhZGluZykgLyAxMDA7XHJcbiAgICAgICAgY3NzTGluZUhlaWdodCA9IE1hdGgubWF4KDAuOCwgcGVyY2VudGFnZSk7XHJcbiAgICAgICAgbGluZUhlaWdodFB4ID0gZm9udFNpemUgKiBwZXJjZW50YWdlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIFxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNzc0xpbmVIZWlnaHQgPSAxLjI7XHJcbiAgICAgICAgbGluZUhlaWdodFB4ID0gZm9udFNpemUgKiAxLjI7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNzc0xpbmVIZWlnaHQ6IE1hdGgucm91bmQoY3NzTGluZUhlaWdodCAqIDEwMDApIC8gMTAwMCwgLy8gUm91bmQgdG8gMyBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICBsaW5lSGVpZ2h0UHg6IE1hdGgucm91bmQobGluZUhlaWdodFB4ICogMTAwKSAvIDEwMCwgICAgIC8vIFJvdW5kIHRvIDIgZGVjaW1hbCBwbGFjZXNcclxuICAgICAgbGVhZGluZ1R5cGUsXHJcbiAgICAgIG9yaWdpbmFsTGVhZGluZzogbGVhZGluZ1xyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIGZpcnN0IGJhc2VsaW5lIG9mZnNldCBhY2NvcmRpbmcgdG8gSW5EZXNpZ24gcnVsZXNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlyc3RCYXNlbGluZU9mZnNldCAtIEluRGVzaWduIGZpcnN0IGJhc2VsaW5lIG9mZnNldCBzZXR0aW5nXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZvbnRTaXplIC0gRm9udCBzaXplIGluIHBvaW50c1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lSGVpZ2h0IC0gTGluZSBoZWlnaHQgaW4gcG9pbnRzXHJcbiAgICogQHJldHVybnMge251bWJlcn0gRmlyc3QgYmFzZWxpbmUgb2Zmc2V0IGluIHBvaW50c1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjYWxjdWxhdGVGaXJzdEJhc2VsaW5lT2Zmc2V0KGZpcnN0QmFzZWxpbmVPZmZzZXQsIGZvbnRTaXplLCBsaW5lSGVpZ2h0KSB7XHJcbiAgICBzd2l0Y2ggKGZpcnN0QmFzZWxpbmVPZmZzZXQpIHtcclxuICAgICAgY2FzZSAnQXNjZW50T2Zmc2V0JzpcclxuICAgICAgICAvLyBUZXh0IHNpdHMgYXQgbmF0dXJhbCBhc2NlbnQgbGluZSAoZGVmYXVsdClcclxuICAgICAgICByZXR1cm4gZm9udFNpemUgKiAwLjg7IC8vIEFwcHJveGltYXRlIGFzY2VudCBmb3IgbW9zdCBmb250c1xyXG4gICAgICAgIFxyXG4gICAgICBjYXNlICdDYXBIZWlnaHRPZmZzZXQnOlxyXG4gICAgICAgIC8vIFRleHQgc2l0cyBhdCBjYXAgaGVpZ2h0XHJcbiAgICAgICAgcmV0dXJuIGZvbnRTaXplICogMC43OyAvLyBBcHByb3hpbWF0ZSBjYXAgaGVpZ2h0IGZvciBtb3N0IGZvbnRzXHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ0ZpeGVkSGVpZ2h0JzpcclxuICAgICAgICAvLyBDdXN0b20gZml4ZWQgaGVpZ2h0IC0gdXNlIGxpbmUgaGVpZ2h0XHJcbiAgICAgICAgcmV0dXJuIGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ1hIZWlnaHRPZmZzZXQnOlxyXG4gICAgICAgIC8vIFRleHQgc2l0cyBhdCB4LWhlaWdodFxyXG4gICAgICAgIHJldHVybiBmb250U2l6ZSAqIDAuNTsgLy8gQXBwcm94aW1hdGUgeC1oZWlnaHQgZm9yIG1vc3QgZm9udHNcclxuICAgICAgICBcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gZm9udFNpemUgKiAwLjg7IC8vIERlZmF1bHQgdG8gYXNjZW50IG9mZnNldFxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBNZWFzdXJlIHRleHQgYWNjdXJhdGVseSB1c2luZyBjYW52YXMgd2l0aCBJbkRlc2lnbi1zcGVjaWZpYyBhZGp1c3RtZW50c1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCB0byBtZWFzdXJlXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHRleHRTdHlsZXMgLSBDb21wbGV0ZSB0ZXh0IHN0eWxpbmcgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGZyYW1lTWV0cmljcyAtIFRleHQgZnJhbWUgbWV0cmljc1xyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFByZWNpc2UgdGV4dCBtZWFzdXJlbWVudCBkYXRhXHJcbiAgICovXHJcbiAgc3RhdGljIG1lYXN1cmVUZXh0UHJlY2lzZWx5KHRleHQsIHRleHRTdHlsZXMsIGZyYW1lTWV0cmljcykge1xyXG4gICAgaWYgKCF0ZXh0IHx8IHRleHQudHJpbSgpID09PSAnJykge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRleHRXaWR0aDogMCxcclxuICAgICAgICB0ZXh0SGVpZ2h0OiAwLFxyXG4gICAgICAgIGxpbmVDb3VudDogMCxcclxuICAgICAgICBsaW5lczogW10sXHJcbiAgICAgICAgd2lsbE92ZXJmbG93OiBmYWxzZSxcclxuICAgICAgICBmaXRzOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBjYW52YXMgZm9yIG1lYXN1cmVtZW50XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgXHJcbiAgICAvLyBTZXQgZm9udCB3aXRoIHByb3BlciBmYWxsYmFja3NcclxuICAgIGNvbnN0IGZvbnRTaXplID0gcGFyc2VGbG9hdCh0ZXh0U3R5bGVzLmZvbnRTaXplKSB8fCAxMjtcclxuICAgIGNvbnN0IGZvbnRGYW1pbHkgPSB0ZXh0U3R5bGVzLmZvbnRGYW1pbHkgfHwgJ0FyaWFsLCBzYW5zLXNlcmlmJztcclxuICAgIGNvbnN0IGZvbnRXZWlnaHQgPSB0ZXh0U3R5bGVzLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCc7XHJcbiAgICBjb25zdCBmb250U3R5bGUgPSB0ZXh0U3R5bGVzLmZvbnRTdHlsZSB8fCAnbm9ybWFsJztcclxuICAgIFxyXG4gICAgY3R4LmZvbnQgPSBgJHtmb250U3R5bGV9ICR7Zm9udFdlaWdodH0gJHtmb250U2l6ZX1weCAke2ZvbnRGYW1pbHl9YDtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGVmZmVjdGl2ZSBjb250ZW50IHdpZHRoIGFjY291bnRpbmcgZm9yIHRyYWNraW5nXHJcbiAgICBjb25zdCB0cmFja2luZyA9IHRleHRTdHlsZXMudHJhY2tpbmcgfHwgMDtcclxuICAgIGNvbnN0IHRyYWNraW5nQWRqdXN0bWVudCA9IHRyYWNraW5nICogZm9udFNpemUgLyAxMDAwOyAvLyBDb252ZXJ0IGVtIHRvIHB4XHJcbiAgICBjb25zdCBlZmZlY3RpdmVXaWR0aCA9IE1hdGgubWF4KDEwLCBmcmFtZU1ldHJpY3MuY29udGVudEFyZWEud2lkdGggLSBNYXRoLmFicyh0cmFja2luZ0FkanVzdG1lbnQpIC0gMik7IC8vIExlYXZlIDJweCBtYXJnaW5cclxuICAgIFxyXG4gICAgLy8gU3BsaXQgdGV4dCBpbnRvIHdvcmRzIGZvciBhY2N1cmF0ZSB3cmFwcGluZywgcHJlc2VydmluZyBsaW5lIGJyZWFrc1xyXG4gICAgY29uc3Qgd29yZHMgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKS5zcGxpdCgvKFxccyt8XFxuKS8pLmZpbHRlcih3b3JkID0+IHdvcmQubGVuZ3RoID4gMCk7XHJcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnRMaW5lID0gJyc7XHJcbiAgICBsZXQgY3VycmVudExpbmVXaWR0aCA9IDA7XHJcbiAgICBcclxuICAgIC8vIE1lYXN1cmUgc3BhY2Ugd2lkdGggb25jZVxyXG4gICAgY29uc3Qgc3BhY2VXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dCgnICcpLndpZHRoICsgdHJhY2tpbmdBZGp1c3RtZW50O1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHdvcmQgPSB3b3Jkc1tpXTtcclxuICAgICAgXHJcbiAgICAgIC8vIEhhbmRsZSBleHBsaWNpdCBsaW5lIGJyZWFrc1xyXG4gICAgICBpZiAod29yZCA9PT0gJ1xcbicpIHtcclxuICAgICAgICBpZiAoY3VycmVudExpbmUpIHtcclxuICAgICAgICAgIGxpbmVzLnB1c2goe1xyXG4gICAgICAgICAgICB0ZXh0OiBjdXJyZW50TGluZSxcclxuICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRMaW5lV2lkdGhcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY3VycmVudExpbmUgPSAnJztcclxuICAgICAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gU2tpcCBwdXJlIHdoaXRlc3BhY2UgKGV4Y2VwdCBzcGFjZXMpXHJcbiAgICAgIGlmICgvXlxccyskLy50ZXN0KHdvcmQpICYmIHdvcmQgIT09ICcgJykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB3b3JkV2lkdGggPSBjdHgubWVhc3VyZVRleHQod29yZCkud2lkdGggKyBNYXRoLm1heCgwLCAod29yZC5sZW5ndGggLSAxKSkgKiB0cmFja2luZ0FkanVzdG1lbnQ7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiB3b3JkIGZpdHMgb24gY3VycmVudCBsaW5lXHJcbiAgICAgIGNvbnN0IHdvcmRXaXRoU3BhY2VXaWR0aCA9IGN1cnJlbnRMaW5lICYmIHdvcmQgIT09ICcgJyA/IHdvcmRXaWR0aCArIHNwYWNlV2lkdGggOiB3b3JkV2lkdGg7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoY3VycmVudExpbmUgJiYgd29yZCAhPT0gJyAnICYmIChjdXJyZW50TGluZVdpZHRoICsgd29yZFdpdGhTcGFjZVdpZHRoID4gZWZmZWN0aXZlV2lkdGgpKSB7XHJcbiAgICAgICAgLy8gV29yZCBkb2Vzbid0IGZpdCwgc3RhcnQgbmV3IGxpbmVcclxuICAgICAgICBsaW5lcy5wdXNoKHtcclxuICAgICAgICAgIHRleHQ6IGN1cnJlbnRMaW5lLFxyXG4gICAgICAgICAgd2lkdGg6IGN1cnJlbnRMaW5lV2lkdGhcclxuICAgICAgICB9KTtcclxuICAgICAgICBjdXJyZW50TGluZSA9IHdvcmQ7XHJcbiAgICAgICAgY3VycmVudExpbmVXaWR0aCA9IHdvcmRXaWR0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBXb3JkIGZpdHMsIGFkZCB0byBjdXJyZW50IGxpbmVcclxuICAgICAgICBpZiAoY3VycmVudExpbmUgJiYgd29yZCAhPT0gJyAnKSB7XHJcbiAgICAgICAgICBjdXJyZW50TGluZSArPSAnICcgKyB3b3JkO1xyXG4gICAgICAgICAgY3VycmVudExpbmVXaWR0aCArPSB3b3JkV2l0aFNwYWNlV2lkdGg7XHJcbiAgICAgICAgfSBlbHNlIGlmICh3b3JkICE9PSAnICcpIHtcclxuICAgICAgICAgIGN1cnJlbnRMaW5lID0gd29yZDtcclxuICAgICAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB3b3JkV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEFkZCB0aGUgbGFzdCBsaW5lXHJcbiAgICBpZiAoY3VycmVudExpbmUpIHtcclxuICAgICAgbGluZXMucHVzaCh7XHJcbiAgICAgICAgdGV4dDogY3VycmVudExpbmUsXHJcbiAgICAgICAgd2lkdGg6IGN1cnJlbnRMaW5lV2lkdGhcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSB0ZXh0IGhlaWdodCB1c2luZyBJbkRlc2lnbi1hY2N1cmF0ZSBsZWFkaW5nXHJcbiAgICBjb25zdCBsaW5lSGVpZ2h0SW5mbyA9IHRoaXMuY29udmVydExlYWRpbmdUb0NTUyhcclxuICAgICAgdGV4dFN0eWxlcy5sZWFkaW5nLCBcclxuICAgICAgZm9udFNpemUsIFxyXG4gICAgICB0ZXh0U3R5bGVzLmxlYWRpbmdUeXBlXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zdCBsaW5lQ291bnQgPSBNYXRoLm1heCgxLCBsaW5lcy5sZW5ndGgpO1xyXG4gICAgY29uc3QgZmlyc3RCYXNlbGluZU9mZnNldCA9IHRoaXMuY2FsY3VsYXRlRmlyc3RCYXNlbGluZU9mZnNldChcclxuICAgICAgdGV4dFN0eWxlcy5maXJzdEJhc2VsaW5lT2Zmc2V0IHx8ICdBc2NlbnRPZmZzZXQnLFxyXG4gICAgICBmb250U2l6ZSxcclxuICAgICAgbGluZUhlaWdodEluZm8ubGluZUhlaWdodFB4XHJcbiAgICApO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgdGV4dCBoZWlnaHQgaW5jbHVkaW5nIGZpcnN0IGJhc2VsaW5lIG9mZnNldFxyXG4gICAgY29uc3QgdGV4dEhlaWdodCA9IGZpcnN0QmFzZWxpbmVPZmZzZXQgKyAoKGxpbmVDb3VudCAtIDEpICogbGluZUhlaWdodEluZm8ubGluZUhlaWdodFB4KTtcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgdGV4dCBvdmVyZmxvd3MgdGhlIGF2YWlsYWJsZSBoZWlnaHRcclxuICAgIGNvbnN0IHdpbGxPdmVyZmxvdyA9IHRleHRIZWlnaHQgPiBmcmFtZU1ldHJpY3MuY29udGVudEFyZWEuaGVpZ2h0O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0V2lkdGg6IE1hdGgubWF4KC4uLmxpbmVzLm1hcChsaW5lID0+IGxpbmUud2lkdGgpKSxcclxuICAgICAgdGV4dEhlaWdodDogTWF0aC5yb3VuZCh0ZXh0SGVpZ2h0ICogMTAwKSAvIDEwMCxcclxuICAgICAgbGluZUNvdW50LFxyXG4gICAgICBsaW5lcyxcclxuICAgICAgbGluZUhlaWdodFB4OiBsaW5lSGVpZ2h0SW5mby5saW5lSGVpZ2h0UHgsXHJcbiAgICAgIGZpcnN0QmFzZWxpbmVPZmZzZXQsXHJcbiAgICAgIHdpbGxPdmVyZmxvdyxcclxuICAgICAgZml0czogIXdpbGxPdmVyZmxvdyxcclxuICAgICAgYXZhaWxhYmxlSGVpZ2h0OiBmcmFtZU1ldHJpY3MuY29udGVudEFyZWEuaGVpZ2h0LFxyXG4gICAgICBvdmVyZmxvd0Ftb3VudDogd2lsbE92ZXJmbG93ID8gdGV4dEhlaWdodCAtIGZyYW1lTWV0cmljcy5jb250ZW50QXJlYS5oZWlnaHQgOiAwLFxyXG4gICAgICAvLyBEZXRhaWxlZCBtZXRyaWNzIGZvciBkZWJ1Z2dpbmdcclxuICAgICAgbWV0cmljczoge1xyXG4gICAgICAgIGZvbnRTaXplLFxyXG4gICAgICAgIGxlYWRpbmc6IHRleHRTdHlsZXMubGVhZGluZyxcclxuICAgICAgICBsZWFkaW5nVHlwZTogdGV4dFN0eWxlcy5sZWFkaW5nVHlwZSxcclxuICAgICAgICBlZmZlY3RpdmVXaWR0aCxcclxuICAgICAgICB0cmFja2luZzogdHJhY2tpbmdBZGp1c3RtZW50LFxyXG4gICAgICAgIHNwYWNlV2lkdGhcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIG9wdGltYWwgZm9udCBzaXplIHRvIHByZXZlbnQgb3ZlcmZsb3cgd2hpbGUgbWFpbnRhaW5pbmcgZGVzaWduIGludGVncml0eVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0ZXh0TWVhc3VyZW1lbnQgLSBSZXN1bHQgZnJvbSBtZWFzdXJlVGV4dFByZWNpc2VseVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcmlnaW5hbFN0eWxlcyAtIE9yaWdpbmFsIHRleHQgc3R5bGVzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFJlZHVjdGlvbiAtIE1heGltdW0gZm9udCBzaXplIHJlZHVjdGlvbiBhbGxvd2VkICgwLjAtMS4wKVxyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IEFkanVzdGVkIHRleHQgc3R5bGVzIG9yIG51bGwgaWYgbm8gYWRqdXN0bWVudCBuZWVkZWRcclxuICAgKi9cclxuICBzdGF0aWMgY2FsY3VsYXRlT3B0aW1hbEZvbnRTaXplKHRleHRNZWFzdXJlbWVudCwgb3JpZ2luYWxTdHlsZXMsIG1heFJlZHVjdGlvbiA9IDAuMjUpIHtcclxuICAgIGlmICghdGV4dE1lYXN1cmVtZW50LndpbGxPdmVyZmxvdykge1xyXG4gICAgICByZXR1cm4gbnVsbDsgLy8gTm8gYWRqdXN0bWVudCBuZWVkZWRcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3Qgb3JpZ2luYWxGb250U2l6ZSA9IHBhcnNlRmxvYXQob3JpZ2luYWxTdHlsZXMuZm9udFNpemUpIHx8IDEyO1xyXG4gICAgY29uc3Qgb3ZlcmZsb3dSYXRpbyA9IHRleHRNZWFzdXJlbWVudC50ZXh0SGVpZ2h0IC8gdGV4dE1lYXN1cmVtZW50LmF2YWlsYWJsZUhlaWdodDtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ/CflKcgY2FsY3VsYXRlT3B0aW1hbEZvbnRTaXplOicsIHtcclxuICAgICAgb3JpZ2luYWxGb250U2l6ZSxcclxuICAgICAgdGV4dEhlaWdodDogdGV4dE1lYXN1cmVtZW50LnRleHRIZWlnaHQsXHJcbiAgICAgIGF2YWlsYWJsZUhlaWdodDogdGV4dE1lYXN1cmVtZW50LmF2YWlsYWJsZUhlaWdodCxcclxuICAgICAgb3ZlcmZsb3dSYXRpbyxcclxuICAgICAgb3ZlcmZsb3dBbW91bnQ6IHRleHRNZWFzdXJlbWVudC5vdmVyZmxvd0Ftb3VudFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSByZXF1aXJlZCBzY2FsZSBmYWN0b3IgdG8gZml0IGV4YWN0bHlcclxuICAgIGxldCBzY2FsZUZhY3RvciA9IDEgLyBvdmVyZmxvd1JhdGlvO1xyXG4gICAgXHJcbiAgICAvLyBBcHBseSBtYXhpbXVtIHJlZHVjdGlvbiBsaW1pdCB0byBwcmVzZXJ2ZSBkZXNpZ24gaW50ZWdyaXR5XHJcbiAgICBjb25zdCBtaW5BbGxvd2VkU2NhbGUgPSAxIC0gbWF4UmVkdWN0aW9uO1xyXG4gICAgY29uc3QgZmluYWxTY2FsZUZhY3RvciA9IE1hdGgubWF4KG1pbkFsbG93ZWRTY2FsZSwgc2NhbGVGYWN0b3IpO1xyXG4gICAgXHJcbiAgICBjb25zdCBuZXdGb250U2l6ZSA9IG9yaWdpbmFsRm9udFNpemUgKiBmaW5hbFNjYWxlRmFjdG9yO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygn8J+UpyBTY2FsZSBjYWxjdWxhdGlvbjonLCB7XHJcbiAgICAgIHJlcXVpcmVkU2NhbGU6IHNjYWxlRmFjdG9yLFxyXG4gICAgICBtYXhSZWR1Y3Rpb24sXHJcbiAgICAgIG1pbkFsbG93ZWRTY2FsZSxcclxuICAgICAgZmluYWxTY2FsZUZhY3RvcixcclxuICAgICAgbmV3Rm9udFNpemVcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgaWYgdGV4dCB3aWxsIHN0aWxsIG92ZXJmbG93IGFmdGVyIGFkanVzdG1lbnRcclxuICAgIGNvbnN0IHdpbGxTdGlsbE92ZXJmbG93ID0gZmluYWxTY2FsZUZhY3RvciA+IHNjYWxlRmFjdG9yO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhZGp1c3RlZFN0eWxlczoge1xyXG4gICAgICAgIC4uLm9yaWdpbmFsU3R5bGVzLFxyXG4gICAgICAgIGZvbnRTaXplOiBgJHtNYXRoLnJvdW5kKG5ld0ZvbnRTaXplICogMTAwKSAvIDEwMH1weGAsXHJcbiAgICAgICAgLy8gQWxzbyBhZGp1c3QgbGluZS1oZWlnaHQgcHJvcG9ydGlvbmFsbHkgaWYgbmVlZGVkXHJcbiAgICAgICAgbGluZUhlaWdodDogb3ZlcmZsb3dSYXRpbyA+IDEuMyA/IFxyXG4gICAgICAgICAgTWF0aC5tYXgoMC45LCBwYXJzZUZsb2F0KG9yaWdpbmFsU3R5bGVzLmxpbmVIZWlnaHQgfHwgJzEuMicpICogZmluYWxTY2FsZUZhY3RvcikgOlxyXG4gICAgICAgICAgb3JpZ2luYWxTdHlsZXMubGluZUhlaWdodFxyXG4gICAgICB9LFxyXG4gICAgICBhZGp1c3RtZW50VHlwZTogd2lsbFN0aWxsT3ZlcmZsb3cgPyAncGFydGlhbF9mb250X3JlZHVjdGlvbicgOiAnZm9udF9zaXplX29wdGltaXplZCcsXHJcbiAgICAgIHNjYWxlRmFjdG9yOiBmaW5hbFNjYWxlRmFjdG9yLFxyXG4gICAgICBvcmlnaW5hbEZvbnRTaXplLFxyXG4gICAgICBuZXdGb250U2l6ZTogTWF0aC5yb3VuZChuZXdGb250U2l6ZSAqIDEwMCkgLyAxMDAsXHJcbiAgICAgIHN0aWxsT3ZlcmZsb3dzOiB3aWxsU3RpbGxPdmVyZmxvdyxcclxuICAgICAgcmVkdWN0aW9uQXBwbGllZDogKCgxIC0gZmluYWxTY2FsZUZhY3RvcikgKiAxMDApLnRvRml4ZWQoMSkgKyAnJSdcclxuICAgIH07XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIENTUyBzdHlsZXMgd2l0aCBJbkRlc2lnbi1hY2N1cmF0ZSB0eXBvZ3JhcGh5XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGluRGVzaWduRm9ybWF0dGluZyAtIEZvcm1hdHRpbmcgb2JqZWN0IGZyb20gSW5EZXNpZ25cclxuICAgKiBAcGFyYW0ge29iamVjdH0gZnJhbWVNZXRyaWNzIC0gVGV4dCBmcmFtZSBtZXRyaWNzXHJcbiAgICogQHJldHVybnMge29iamVjdH0gQ1NTIHN0eWxlcyBvcHRpbWl6ZWQgZm9yIEluRGVzaWduIGNvbXBhdGliaWxpdHlcclxuICAgKi9cclxuICBzdGF0aWMgZ2VuZXJhdGVJbkRlc2lnbkNTUyhpbkRlc2lnbkZvcm1hdHRpbmcsIGZyYW1lTWV0cmljcykge1xyXG4gICAgY29uc3QgZm9udFNpemUgPSBpbkRlc2lnbkZvcm1hdHRpbmcuZm9udFNpemUgfHwgMTI7XHJcbiAgICBcclxuICAgIC8vIENvbnZlcnQgbGVhZGluZyB0byBDU1NcclxuICAgIGNvbnN0IGxpbmVIZWlnaHRJbmZvID0gdGhpcy5jb252ZXJ0TGVhZGluZ1RvQ1NTKFxyXG4gICAgICBpbkRlc2lnbkZvcm1hdHRpbmcubGVhZGluZyxcclxuICAgICAgZm9udFNpemUsXHJcbiAgICAgIGluRGVzaWduRm9ybWF0dGluZy5sZWFkaW5nVHlwZVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGZpcnN0IGJhc2VsaW5lIG9mZnNldCBmb3IgcG9zaXRpb25pbmdcclxuICAgIGNvbnN0IGZpcnN0QmFzZWxpbmVPZmZzZXQgPSB0aGlzLmNhbGN1bGF0ZUZpcnN0QmFzZWxpbmVPZmZzZXQoXHJcbiAgICAgIGluRGVzaWduRm9ybWF0dGluZy5maXJzdEJhc2VsaW5lT2Zmc2V0IHx8ICdBc2NlbnRPZmZzZXQnLFxyXG4gICAgICBmb250U2l6ZSxcclxuICAgICAgbGluZUhlaWdodEluZm8ubGluZUhlaWdodFB4XHJcbiAgICApO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyBUeXBvZ3JhcGh5XHJcbiAgICAgIGZvbnRTaXplOiBgJHtmb250U2l6ZX1weGAsXHJcbiAgICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRJbmZvLmNzc0xpbmVIZWlnaHQsXHJcbiAgICAgIGZvbnRGYW1pbHk6IGluRGVzaWduRm9ybWF0dGluZy5mb250RmFtaWx5IHx8ICdBcmlhbCwgc2Fucy1zZXJpZicsXHJcbiAgICAgIGZvbnRXZWlnaHQ6IGluRGVzaWduRm9ybWF0dGluZy5mb250V2VpZ2h0IHx8ICdub3JtYWwnLFxyXG4gICAgICBmb250U3R5bGU6IGluRGVzaWduRm9ybWF0dGluZy5mb250U3R5bGUgfHwgJ25vcm1hbCcsXHJcbiAgICAgIFxyXG4gICAgICAvLyBBZHZhbmNlZCB0eXBvZ3JhcGh5XHJcbiAgICAgIGxldHRlclNwYWNpbmc6IGluRGVzaWduRm9ybWF0dGluZy50cmFja2luZyA/IGAke2luRGVzaWduRm9ybWF0dGluZy50cmFja2luZyAvIDEwMDB9ZW1gIDogJ25vcm1hbCcsXHJcbiAgICAgIHRleHRBbGlnbjogaW5EZXNpZ25Gb3JtYXR0aW5nLnRleHRBbGlnbiB8fCAnbGVmdCcsXHJcbiAgICAgIGNvbG9yOiBpbkRlc2lnbkZvcm1hdHRpbmcuY29sb3IgfHwgJ2JsYWNrJyxcclxuICAgICAgXHJcbiAgICAgIC8vIExheW91dCBhbmQgcG9zaXRpb25pbmcgLSBtaW5pbWFsIHBhZGRpbmcgdG8gYXZvaWQgZXhjZXNzaXZlIHRvcCBzcGFjaW5nXHJcbiAgICAgIHBhZGRpbmc6IGAke01hdGgubWluKDIsIGZpcnN0QmFzZWxpbmVPZmZzZXQgKiAwLjMpfXB4ICR7ZnJhbWVNZXRyaWNzLmluc2V0cy5yaWdodH1weCAke2ZyYW1lTWV0cmljcy5pbnNldHMuYm90dG9tfXB4ICR7ZnJhbWVNZXRyaWNzLmluc2V0cy5sZWZ0fXB4YCxcclxuICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICBcclxuICAgICAgLy8gT3ZlcmZsb3cgY29udHJvbFxyXG4gICAgICB3aWR0aDogYCR7ZnJhbWVNZXRyaWNzLmNvbnRlbnRBcmVhLndpZHRofXB4YCxcclxuICAgICAgaGVpZ2h0OiBgJHtmcmFtZU1ldHJpY3MuY29udGVudEFyZWEuaGVpZ2h0fXB4YCxcclxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcclxuICAgICAgXHJcbiAgICAgIC8vIFRleHQgbGF5b3V0IG9wdGltaXphdGlvblxyXG4gICAgICB3aGl0ZVNwYWNlOiAnbm9ybWFsJyxcclxuICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJyxcclxuICAgICAgb3ZlcmZsb3dXcmFwOiAnYnJlYWstd29yZCcsXHJcbiAgICAgIHdvcmRCcmVhazogJ25vcm1hbCcsXHJcbiAgICAgIFxyXG4gICAgICAvLyBJbkRlc2lnbi1zcGVjaWZpYyBhZGp1c3RtZW50c1xyXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgdG9wOiBmcmFtZU1ldHJpY3MuaGFzSW5zZXRzID8gYCR7ZnJhbWVNZXRyaWNzLm9mZnNldFl9cHhgIDogJzAnLFxyXG4gICAgICBsZWZ0OiBmcmFtZU1ldHJpY3MuaGFzSW5zZXRzID8gYCR7ZnJhbWVNZXRyaWNzLm9mZnNldFh9cHhgIDogJzAnLFxyXG4gICAgICBcclxuICAgICAgLy8gRGVidWcgaW5mbyAoY2FuIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbilcclxuICAgICAgJy0taW5kZXNpZ24tbGVhZGluZyc6IGluRGVzaWduRm9ybWF0dGluZy5sZWFkaW5nLFxyXG4gICAgICAnLS1pbmRlc2lnbi1sZWFkaW5nLXR5cGUnOiBpbkRlc2lnbkZvcm1hdHRpbmcubGVhZGluZ1R5cGUsXHJcbiAgICAgICctLWNzcy1saW5lLWhlaWdodCc6IGxpbmVIZWlnaHRJbmZvLmNzc0xpbmVIZWlnaHQsXHJcbiAgICAgICctLWZpcnN0LWJhc2VsaW5lLW9mZnNldCc6IGAke2ZpcnN0QmFzZWxpbmVPZmZzZXR9cHhgXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IGZvciB1c2UgaW4gb3RoZXIgbW9kdWxlc1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEluRGVzaWduVGV4dE1ldHJpY3M7XHJcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICB3aW5kb3cuSW5EZXNpZ25UZXh0TWV0cmljcyA9IEluRGVzaWduVGV4dE1ldHJpY3M7XHJcbn0gIl0sIm5hbWVzIjpbIkluRGVzaWduVGV4dE1ldHJpY3MiLCJjYWxjdWxhdGVUZXh0RnJhbWVJbnNldHMiLCJ0ZXh0RnJhbWUiLCJ0ZXh0RnJhbWVQcmVmcyIsIkRFRkFVTFRfSU5TRVRTIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiaW5zZXRzIiwiaW5zZXRTcGFjaW5nIiwidGV4dEluc2V0cyIsImNvbnRlbnRBcmVhIiwid2lkdGgiLCJNYXRoIiwibWF4IiwicG9zaXRpb24iLCJoZWlnaHQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIm9yaWdpbmFsRnJhbWUiLCJoYXNJbnNldHMiLCJjb252ZXJ0TGVhZGluZ1RvQ1NTIiwibGVhZGluZyIsImZvbnRTaXplIiwibGVhZGluZ1R5cGUiLCJjc3NMaW5lSGVpZ2h0IiwibGluZUhlaWdodFB4IiwicGVyY2VudGFnZSIsInBhcnNlRmxvYXQiLCJyb3VuZCIsIm9yaWdpbmFsTGVhZGluZyIsImNhbGN1bGF0ZUZpcnN0QmFzZWxpbmVPZmZzZXQiLCJmaXJzdEJhc2VsaW5lT2Zmc2V0IiwibGluZUhlaWdodCIsIm1lYXN1cmVUZXh0UHJlY2lzZWx5IiwidGV4dCIsInRleHRTdHlsZXMiLCJmcmFtZU1ldHJpY3MiLCJ0cmltIiwidGV4dFdpZHRoIiwidGV4dEhlaWdodCIsImxpbmVDb3VudCIsImxpbmVzIiwid2lsbE92ZXJmbG93IiwiZml0cyIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJmb250RmFtaWx5IiwiZm9udFdlaWdodCIsImZvbnRTdHlsZSIsImZvbnQiLCJ0cmFja2luZyIsInRyYWNraW5nQWRqdXN0bWVudCIsImVmZmVjdGl2ZVdpZHRoIiwiYWJzIiwid29yZHMiLCJyZXBsYWNlIiwic3BsaXQiLCJmaWx0ZXIiLCJ3b3JkIiwibGVuZ3RoIiwiY3VycmVudExpbmUiLCJjdXJyZW50TGluZVdpZHRoIiwic3BhY2VXaWR0aCIsIm1lYXN1cmVUZXh0IiwiaSIsInB1c2giLCJ0ZXN0Iiwid29yZFdpZHRoIiwid29yZFdpdGhTcGFjZVdpZHRoIiwibGluZUhlaWdodEluZm8iLCJtYXAiLCJsaW5lIiwiYXZhaWxhYmxlSGVpZ2h0Iiwib3ZlcmZsb3dBbW91bnQiLCJtZXRyaWNzIiwiY2FsY3VsYXRlT3B0aW1hbEZvbnRTaXplIiwidGV4dE1lYXN1cmVtZW50Iiwib3JpZ2luYWxTdHlsZXMiLCJtYXhSZWR1Y3Rpb24iLCJvcmlnaW5hbEZvbnRTaXplIiwib3ZlcmZsb3dSYXRpbyIsImNvbnNvbGUiLCJsb2ciLCJzY2FsZUZhY3RvciIsIm1pbkFsbG93ZWRTY2FsZSIsImZpbmFsU2NhbGVGYWN0b3IiLCJuZXdGb250U2l6ZSIsInJlcXVpcmVkU2NhbGUiLCJ3aWxsU3RpbGxPdmVyZmxvdyIsImFkanVzdGVkU3R5bGVzIiwiYWRqdXN0bWVudFR5cGUiLCJzdGlsbE92ZXJmbG93cyIsInJlZHVjdGlvbkFwcGxpZWQiLCJ0b0ZpeGVkIiwiZ2VuZXJhdGVJbkRlc2lnbkNTUyIsImluRGVzaWduRm9ybWF0dGluZyIsImxldHRlclNwYWNpbmciLCJ0ZXh0QWxpZ24iLCJjb2xvciIsInBhZGRpbmciLCJtaW4iLCJtYXJnaW4iLCJvdmVyZmxvdyIsImJveFNpemluZyIsIndoaXRlU3BhY2UiLCJ3b3JkV3JhcCIsIm92ZXJmbG93V3JhcCIsIndvcmRCcmVhayIsIm1vZHVsZSIsImV4cG9ydHMiLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/utils/InDesignTextMetrics.js\n");

/***/ }),

/***/ "./lib/utils/NextFontMapper.js":
/*!*************************************!*\
  !*** ./lib/utils/NextFontMapper.js ***!
  \*************************************/
/***/ ((module) => {

eval("/**\r\n * NextFontMapper.js - Dynamic Next.js font mapping based on font characteristics\r\n * NO HARDCODED MAPPINGS - Automatically maps any font to appropriate Next.js fonts\r\n */ \nclass NextFontMapper {\n    constructor(){\n        // Available Next.js font categories and their characteristics\n        this.nextFontDatabase = this.initializeNextFontDatabase();\n        this.fontCache = new Map(); // Cache for resolved fonts\n        this.nextFontImports = new Set(); // Track which fonts need to be imported\n    }\n    /**\r\n   * Initialize comprehensive Next.js font database with characteristics\r\n   * @returns {Object} Font database categorized by type and characteristics\r\n   */ initializeNextFontDatabase() {\n        return {\n            serif: {\n                traditional: [\n                    {\n                        nextFont: \"Crimson_Text\",\n                        family: \"Crimson Text\",\n                        weights: [\n                            \"400\",\n                            \"600\",\n                            \"700\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"elegant\",\n                            \"traditional\",\n                            \"readable\",\n                            \"body-text\"\n                        ],\n                        keywords: [\n                            \"minion\",\n                            \"times\",\n                            \"garamond\",\n                            \"baskerville\",\n                            \"caslon\"\n                        ]\n                    },\n                    {\n                        nextFont: \"Libre_Baskerville\",\n                        family: \"Libre Baskerville\",\n                        weights: [\n                            \"400\",\n                            \"700\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"classic\",\n                            \"readable\",\n                            \"book\"\n                        ],\n                        keywords: [\n                            \"baskerville\",\n                            \"libre\",\n                            \"book\"\n                        ]\n                    },\n                    {\n                        nextFont: \"Lora\",\n                        family: \"Lora\",\n                        weights: [\n                            \"400\",\n                            \"500\",\n                            \"600\",\n                            \"700\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"modern\",\n                            \"friendly\",\n                            \"calligraphic\"\n                        ],\n                        keywords: [\n                            \"lora\",\n                            \"modern-serif\"\n                        ]\n                    }\n                ],\n                display: [\n                    {\n                        nextFont: \"Playfair_Display\",\n                        family: \"Playfair Display\",\n                        weights: [\n                            \"400\",\n                            \"500\",\n                            \"600\",\n                            \"700\",\n                            \"800\",\n                            \"900\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"elegant\",\n                            \"high-contrast\",\n                            \"display\",\n                            \"luxury\"\n                        ],\n                        keywords: [\n                            \"playfair\",\n                            \"display\",\n                            \"elegant\",\n                            \"luxury\"\n                        ]\n                    },\n                    {\n                        nextFont: \"Cormorant_Garamond\",\n                        family: \"Cormorant Garamond\",\n                        weights: [\n                            \"300\",\n                            \"400\",\n                            \"500\",\n                            \"600\",\n                            \"700\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"refined\",\n                            \"garamond\",\n                            \"classic\"\n                        ],\n                        keywords: [\n                            \"garamond\",\n                            \"cormorant\",\n                            \"refined\"\n                        ]\n                    }\n                ]\n            },\n            \"sans-serif\": {\n                geometric: [\n                    {\n                        nextFont: \"Inter\",\n                        family: \"Inter\",\n                        weights: [\n                            \"100\",\n                            \"200\",\n                            \"300\",\n                            \"400\",\n                            \"500\",\n                            \"600\",\n                            \"700\",\n                            \"800\",\n                            \"900\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"modern\",\n                            \"clean\",\n                            \"ui\",\n                            \"versatile\",\n                            \"geometric\"\n                        ],\n                        keywords: [\n                            \"inter\",\n                            \"ui\",\n                            \"interface\",\n                            \"modern\"\n                        ]\n                    },\n                    {\n                        nextFont: \"Nunito_Sans\",\n                        family: \"Nunito Sans\",\n                        weights: [\n                            \"200\",\n                            \"300\",\n                            \"400\",\n                            \"500\",\n                            \"600\",\n                            \"700\",\n                            \"800\",\n                            \"900\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"friendly\",\n                            \"rounded\",\n                            \"geometric\"\n                        ],\n                        keywords: [\n                            \"nunito\",\n                            \"friendly\",\n                            \"rounded\",\n                            \"futura\",\n                            \"avenir\"\n                        ]\n                    }\n                ],\n                humanist: [\n                    {\n                        nextFont: \"Open_Sans\",\n                        family: \"Open Sans\",\n                        weights: [\n                            \"300\",\n                            \"400\",\n                            \"500\",\n                            \"600\",\n                            \"700\",\n                            \"800\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"versatile\",\n                            \"readable\",\n                            \"neutral\",\n                            \"professional\"\n                        ],\n                        keywords: [\n                            \"open\",\n                            \"myriad\",\n                            \"professional\",\n                            \"clean\"\n                        ]\n                    },\n                    {\n                        nextFont: \"Source_Sans_3\",\n                        family: \"Source Sans 3\",\n                        weights: [\n                            \"200\",\n                            \"300\",\n                            \"400\",\n                            \"500\",\n                            \"600\",\n                            \"700\",\n                            \"800\",\n                            \"900\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"adobe\",\n                            \"technical\",\n                            \"clean\"\n                        ],\n                        keywords: [\n                            \"source\",\n                            \"adobe\",\n                            \"technical\",\n                            \"calibri\"\n                        ]\n                    },\n                    {\n                        nextFont: \"Lato\",\n                        family: \"Lato\",\n                        weights: [\n                            \"100\",\n                            \"300\",\n                            \"400\",\n                            \"700\",\n                            \"900\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"warm\",\n                            \"friendly\",\n                            \"professional\"\n                        ],\n                        keywords: [\n                            \"lato\",\n                            \"warm\",\n                            \"friendly\"\n                        ]\n                    }\n                ],\n                grotesque: [\n                    {\n                        nextFont: \"Roboto\",\n                        family: \"Roboto\",\n                        weights: [\n                            \"100\",\n                            \"300\",\n                            \"400\",\n                            \"500\",\n                            \"700\",\n                            \"900\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"android\",\n                            \"modern\",\n                            \"mechanical\"\n                        ],\n                        keywords: [\n                            \"roboto\",\n                            \"android\",\n                            \"mechanical\"\n                        ]\n                    },\n                    {\n                        nextFont: \"Work_Sans\",\n                        family: \"Work Sans\",\n                        weights: [\n                            \"100\",\n                            \"200\",\n                            \"300\",\n                            \"400\",\n                            \"500\",\n                            \"600\",\n                            \"700\",\n                            \"800\",\n                            \"900\"\n                        ],\n                        styles: [\n                            \"normal\",\n                            \"italic\"\n                        ],\n                        googleFont: true,\n                        characteristics: [\n                            \"work\",\n                            \"professional\",\n                            \"clean\"\n                        ],\n                        keywords: [\n                            \"work\",\n                            \"professional\",\n                            \"helvetica\"\n                        ]\n                    }\n                ]\n            },\n            monospace: [\n                {\n                    nextFont: \"JetBrains_Mono\",\n                    family: \"JetBrains Mono\",\n                    weights: [\n                        \"100\",\n                        \"200\",\n                        \"300\",\n                        \"400\",\n                        \"500\",\n                        \"600\",\n                        \"700\",\n                        \"800\"\n                    ],\n                    styles: [\n                        \"normal\",\n                        \"italic\"\n                    ],\n                    googleFont: true,\n                    characteristics: [\n                        \"coding\",\n                        \"modern\",\n                        \"ligatures\"\n                    ],\n                    keywords: [\n                        \"jetbrains\",\n                        \"code\",\n                        \"programming\"\n                    ]\n                },\n                {\n                    nextFont: \"Courier_Prime\",\n                    family: \"Courier Prime\",\n                    weights: [\n                        \"400\",\n                        \"700\"\n                    ],\n                    styles: [\n                        \"normal\",\n                        \"italic\"\n                    ],\n                    googleFont: true,\n                    characteristics: [\n                        \"typewriter\",\n                        \"classic\",\n                        \"courier\"\n                    ],\n                    keywords: [\n                        \"courier\",\n                        \"typewriter\",\n                        \"classic\"\n                    ]\n                },\n                {\n                    nextFont: \"Source_Code_Pro\",\n                    family: \"Source Code Pro\",\n                    weights: [\n                        \"200\",\n                        \"300\",\n                        \"400\",\n                        \"500\",\n                        \"600\",\n                        \"700\",\n                        \"800\",\n                        \"900\"\n                    ],\n                    styles: [\n                        \"normal\",\n                        \"italic\"\n                    ],\n                    googleFont: true,\n                    characteristics: [\n                        \"adobe\",\n                        \"coding\",\n                        \"technical\"\n                    ],\n                    keywords: [\n                        \"source\",\n                        \"code\",\n                        \"adobe\",\n                        \"technical\"\n                    ]\n                }\n            ],\n            // Language-specific fonts\n            japanese: [\n                {\n                    nextFont: \"Noto_Serif_JP\",\n                    family: \"Noto Serif JP\",\n                    weights: [\n                        \"200\",\n                        \"300\",\n                        \"400\",\n                        \"500\",\n                        \"600\",\n                        \"700\",\n                        \"900\"\n                    ],\n                    styles: [\n                        \"normal\"\n                    ],\n                    googleFont: true,\n                    characteristics: [\n                        \"japanese\",\n                        \"serif\",\n                        \"traditional\"\n                    ],\n                    keywords: [\n                        \"japanese\",\n                        \"jp\",\n                        \"mincho\",\n                        \"kozuka\",\n                        \"noto\"\n                    ]\n                },\n                {\n                    nextFont: \"Noto_Sans_JP\",\n                    family: \"Noto Sans JP\",\n                    weights: [\n                        \"100\",\n                        \"300\",\n                        \"400\",\n                        \"500\",\n                        \"700\",\n                        \"900\"\n                    ],\n                    styles: [\n                        \"normal\"\n                    ],\n                    googleFont: true,\n                    characteristics: [\n                        \"japanese\",\n                        \"sans-serif\",\n                        \"modern\"\n                    ],\n                    keywords: [\n                        \"japanese\",\n                        \"jp\",\n                        \"gothic\",\n                        \"sans\",\n                        \"noto\"\n                    ]\n                }\n            ],\n            chinese: [\n                {\n                    nextFont: \"Noto_Serif_SC\",\n                    family: \"Noto Serif SC\",\n                    weights: [\n                        \"200\",\n                        \"300\",\n                        \"400\",\n                        \"500\",\n                        \"600\",\n                        \"700\",\n                        \"900\"\n                    ],\n                    styles: [\n                        \"normal\"\n                    ],\n                    googleFont: true,\n                    characteristics: [\n                        \"chinese\",\n                        \"simplified\",\n                        \"serif\"\n                    ],\n                    keywords: [\n                        \"chinese\",\n                        \"simplified\",\n                        \"sc\",\n                        \"simsun\",\n                        \"noto\"\n                    ]\n                },\n                {\n                    nextFont: \"Noto_Sans_SC\",\n                    family: \"Noto Sans SC\",\n                    weights: [\n                        \"100\",\n                        \"300\",\n                        \"400\",\n                        \"500\",\n                        \"700\",\n                        \"900\"\n                    ],\n                    styles: [\n                        \"normal\"\n                    ],\n                    googleFont: true,\n                    characteristics: [\n                        \"chinese\",\n                        \"simplified\",\n                        \"sans-serif\"\n                    ],\n                    keywords: [\n                        \"chinese\",\n                        \"simplified\",\n                        \"sc\",\n                        \"sans\",\n                        \"noto\"\n                    ]\n                }\n            ]\n        };\n    }\n    /**\r\n   * Dynamically map IDML font to Next.js font based on characteristics\r\n   * @param {string} idmlFontFamily - Original IDML font family\r\n   * @param {string} fontStyle - Font style (Regular, Bold, Italic, etc.)\r\n   * @param {number} fontSize - Font size in pixels\r\n   * @param {Object} fontMetadata - Additional font metadata from IDML\r\n   * @returns {Object} Next.js font configuration\r\n   */ mapToNextFont(idmlFontFamily, fontStyle = \"Regular\", fontSize = 16, fontMetadata = {}) {\n        if (!idmlFontFamily) {\n            console.log(\"âš ï¸  No font family provided, using default\");\n            return this.getDefaultFont();\n        }\n        // Create cache key\n        const cacheKey = `${idmlFontFamily}-${fontStyle}-${fontSize}`;\n        // Check cache first\n        if (this.fontCache.has(cacheKey)) {\n            return this.fontCache.get(cacheKey);\n        }\n        console.log(`ðŸ” Dynamically mapping font: \"${idmlFontFamily}\" (${fontStyle})`);\n        // Analyze font characteristics\n        const fontAnalysis = this.analyzeFontCharacteristics(idmlFontFamily, fontStyle, fontMetadata);\n        console.log(`ðŸ“Š Font analysis for \"${idmlFontFamily}\":`, {\n            category: fontAnalysis.category,\n            subcategory: fontAnalysis.subcategory,\n            language: fontAnalysis.language,\n            keywords: fontAnalysis.detectedKeywords,\n            confidence: fontAnalysis.confidence\n        });\n        // Find best matching Next.js font\n        const bestMatch = this.findBestNextJSFont(fontAnalysis, idmlFontFamily);\n        // Build final font configuration\n        const finalConfig = this.buildFontConfig(bestMatch, fontStyle, fontSize, idmlFontFamily);\n        // Add to cache\n        this.fontCache.set(cacheKey, finalConfig);\n        // Track for import generation\n        this.nextFontImports.add(bestMatch.nextFont);\n        console.log(`âœ… Dynamic mapping: \"${idmlFontFamily}\" â†’ \"${finalConfig.fontFamily}\" (${bestMatch.nextFont})`);\n        return finalConfig;\n    }\n    /**\r\n   * Analyze font characteristics to determine category and properties\r\n   * @param {string} fontName - Font name to analyze\r\n   * @param {string} fontStyle - Font style\r\n   * @param {Object} metadata - Additional metadata\r\n   * @returns {Object} Font analysis result\r\n   */ analyzeFontCharacteristics(fontName, fontStyle, metadata = {}) {\n        const lowerName = fontName.toLowerCase();\n        const analysis = {\n            category: \"sans-serif\",\n            subcategory: \"humanist\",\n            language: \"latin\",\n            detectedKeywords: [],\n            confidence: 0,\n            weight: this.extractWeight(fontStyle),\n            isDisplay: false,\n            isCondensed: false\n        };\n        // Language detection\n        if (this.isJapaneseFont(lowerName)) {\n            analysis.language = \"japanese\";\n            analysis.category = this.isSerifFont(lowerName) ? \"serif\" : \"sans-serif\";\n            analysis.confidence += 0.8;\n            return analysis;\n        }\n        if (this.isChineseFont(lowerName)) {\n            analysis.language = \"chinese\";\n            analysis.category = this.isSerifFont(lowerName) ? \"serif\" : \"sans-serif\";\n            analysis.confidence += 0.8;\n            return analysis;\n        }\n        // Category detection\n        if (this.isSerifFont(lowerName)) {\n            analysis.category = \"serif\";\n            analysis.subcategory = this.isDisplayFont(lowerName) ? \"display\" : \"traditional\";\n            analysis.confidence += 0.6;\n        } else if (this.isMonospaceFont(lowerName)) {\n            analysis.category = \"monospace\";\n            analysis.confidence += 0.8;\n        } else {\n            // Sans-serif subcategory detection\n            analysis.category = \"sans-serif\";\n            if (this.isGeometricFont(lowerName)) {\n                analysis.subcategory = \"geometric\";\n                analysis.confidence += 0.5;\n            } else if (this.isGrotesqueFont(lowerName)) {\n                analysis.subcategory = \"grotesque\";\n                analysis.confidence += 0.5;\n            } else {\n                analysis.subcategory = \"humanist\"; // default\n                analysis.confidence += 0.3;\n            }\n        }\n        // Additional characteristics\n        analysis.isDisplay = this.isDisplayFont(lowerName);\n        analysis.isCondensed = this.isCondensedFont(lowerName);\n        // Extract keywords for matching\n        analysis.detectedKeywords = this.extractKeywords(lowerName);\n        return analysis;\n    }\n    /**\r\n   * Check if font is Japanese\r\n   */ isJapaneseFont(fontName) {\n        const japaneseIndicators = [\n            \"kozuka\",\n            \"mincho\",\n            \"gothic\",\n            \"hiragino\",\n            \"yu\",\n            \"meiryo\",\n            \"noto\",\n            \"jp\"\n        ];\n        return japaneseIndicators.some((indicator)=>fontName.includes(indicator));\n    }\n    /**\r\n   * Check if font is Chinese\r\n   */ isChineseFont(fontName) {\n        const chineseIndicators = [\n            \"simsun\",\n            \"simhei\",\n            \"microsoft yahei\",\n            \"songti\",\n            \"fangsong\",\n            \"sc\",\n            \"tc\"\n        ];\n        return chineseIndicators.some((indicator)=>fontName.includes(indicator));\n    }\n    /**\r\n   * Check if font is serif\r\n   */ isSerifFont(fontName) {\n        const serifIndicators = [\n            \"serif\",\n            \"times\",\n            \"minion\",\n            \"georgia\",\n            \"garamond\",\n            \"baskerville\",\n            \"caslon\",\n            \"mincho\",\n            \"songti\",\n            \"book\"\n        ];\n        return serifIndicators.some((indicator)=>fontName.includes(indicator));\n    }\n    /**\r\n   * Check if font is monospace\r\n   */ isMonospaceFont(fontName) {\n        const monospaceIndicators = [\n            \"mono\",\n            \"courier\",\n            \"code\",\n            \"console\",\n            \"terminal\",\n            \"typewriter\"\n        ];\n        return monospaceIndicators.some((indicator)=>fontName.includes(indicator));\n    }\n    /**\r\n   * Check if font is geometric sans-serif\r\n   */ isGeometricFont(fontName) {\n        const geometricIndicators = [\n            \"futura\",\n            \"avenir\",\n            \"nunito\",\n            \"inter\",\n            \"circular\",\n            \"geometric\"\n        ];\n        return geometricIndicators.some((indicator)=>fontName.includes(indicator));\n    }\n    /**\r\n   * Check if font is grotesque sans-serif\r\n   */ isGrotesqueFont(fontName) {\n        const grotesqueIndicators = [\n            \"helvetica\",\n            \"arial\",\n            \"roboto\",\n            \"work\",\n            \"franklin\",\n            \"akzidenz\"\n        ];\n        return grotesqueIndicators.some((indicator)=>fontName.includes(indicator));\n    }\n    /**\r\n   * Check if font is display type\r\n   */ isDisplayFont(fontName) {\n        const displayIndicators = [\n            \"display\",\n            \"title\",\n            \"headline\",\n            \"poster\",\n            \"banner\",\n            \"playfair\"\n        ];\n        return displayIndicators.some((indicator)=>fontName.includes(indicator));\n    }\n    /**\r\n   * Check if font is condensed\r\n   */ isCondensedFont(fontName) {\n        const condensedIndicators = [\n            \"condensed\",\n            \"compressed\",\n            \"narrow\",\n            \"compact\"\n        ];\n        return condensedIndicators.some((indicator)=>fontName.includes(indicator));\n    }\n    /**\r\n   * Extract weight from font style\r\n   */ extractWeight(fontStyle) {\n        const style = (fontStyle || \"\").toLowerCase();\n        if (style.includes(\"thin\")) return \"thin\";\n        if (style.includes(\"light\")) return \"light\";\n        if (style.includes(\"medium\")) return \"medium\";\n        if (style.includes(\"semibold\") || style.includes(\"semi bold\")) return \"semibold\";\n        if (style.includes(\"bold\")) return \"bold\";\n        if (style.includes(\"black\") || style.includes(\"heavy\")) return \"black\";\n        return \"regular\";\n    }\n    /**\r\n   * Extract keywords from font name for matching\r\n   */ extractKeywords(fontName) {\n        // Remove common suffixes and split into words\n        const cleaned = fontName.replace(/\\s+(pro|std|regular|bold|italic|light|medium|heavy|black|mt)$/gi, \"\").replace(/[^\\w\\s]/g, \" \").toLowerCase();\n        return cleaned.split(/\\s+/).filter((word)=>word.length > 2);\n    }\n    /**\r\n   * Find best matching Next.js font based on analysis\r\n   * @param {Object} analysis - Font analysis result\r\n   * @param {string} originalName - Original font name for logging\r\n   * @returns {Object} Best matching Next.js font configuration\r\n   */ findBestNextJSFont(analysis, originalName) {\n        let candidates = [];\n        // Get font category\n        if (analysis.language === \"japanese\") {\n            candidates = this.nextFontDatabase.japanese;\n        } else if (analysis.language === \"chinese\") {\n            candidates = this.nextFontDatabase.chinese;\n        } else if (analysis.category === \"monospace\") {\n            candidates = this.nextFontDatabase.monospace;\n        } else if (analysis.category === \"serif\") {\n            const subcategory = analysis.subcategory || \"traditional\";\n            candidates = this.nextFontDatabase.serif[subcategory] || this.nextFontDatabase.serif.traditional;\n        } else {\n            // sans-serif\n            const subcategory = analysis.subcategory || \"humanist\";\n            candidates = this.nextFontDatabase[\"sans-serif\"][subcategory] || this.nextFontDatabase[\"sans-serif\"].humanist;\n        }\n        if (!candidates || candidates.length === 0) {\n            console.log(`âš ï¸ No candidates found for ${originalName}, using default`);\n            return this.getDefaultFontConfig();\n        }\n        // Score each candidate\n        const scoredCandidates = candidates.map((font)=>({\n                ...font,\n                score: this.calculateFontScore(font, analysis, originalName)\n            }));\n        // Sort by score (highest first)\n        scoredCandidates.sort((a, b)=>b.score - a.score);\n        const bestMatch = scoredCandidates[0];\n        console.log(`ðŸŽ¯ Best match for \"${originalName}\": ${bestMatch.family} (score: ${bestMatch.score.toFixed(2)})`);\n        return bestMatch;\n    }\n    /**\r\n   * Calculate matching score between font and analysis\r\n   */ calculateFontScore(font, analysis, originalName) {\n        let score = 0;\n        const lowerOriginal = originalName.toLowerCase();\n        // Keyword matching (high weight)\n        const keywordMatches = analysis.detectedKeywords.filter((keyword)=>font.keywords.some((fontKeyword)=>fontKeyword.includes(keyword) || keyword.includes(fontKeyword)));\n        score += keywordMatches.length * 2;\n        // Exact keyword match (very high weight)\n        if (font.keywords.some((keyword)=>lowerOriginal.includes(keyword))) {\n            score += 5;\n        }\n        // Family name similarity\n        if (lowerOriginal.includes(font.family.toLowerCase().split(\" \")[0])) {\n            score += 3;\n        }\n        // Characteristics matching\n        const characteristicMatches = font.characteristics.filter((char)=>analysis.detectedKeywords.includes(char) || lowerOriginal.includes(char));\n        score += characteristicMatches.length * 1;\n        // Weight availability\n        const targetWeight = this.mapFontWeight(analysis.weight, font.weights);\n        if (font.weights.includes(targetWeight)) {\n            score += 0.5;\n        }\n        // Display font preference\n        if (analysis.isDisplay && font.characteristics.includes(\"display\")) {\n            score += 2;\n        }\n        return score;\n    }\n    /**\r\n   * Build final font configuration\r\n   * @param {Object} fontConfig - Next.js font configuration\r\n   * @param {string} fontStyle - Original font style\r\n   * @param {number} fontSize - Font size\r\n   * @param {string} originalFamily - Original font family name\r\n   * @returns {Object} Complete font configuration\r\n   */ buildFontConfig(fontConfig, fontStyle, fontSize, originalFamily) {\n        // Safety check\n        if (!fontConfig) {\n            console.error(\"âš ï¸ buildFontConfig received null/undefined fontConfig\");\n            fontConfig = this.getDefaultFontConfig();\n        }\n        const weight = this.mapFontWeight(fontStyle, fontConfig.weights);\n        const style = this.mapFontStyle(fontStyle);\n        // ENHANCED: Extract complete style analysis\n        const styleAnalysis = this.analyzeComplexFontStyle(fontStyle);\n        return {\n            // Next.js specific\n            nextFont: fontConfig.nextFont,\n            nextFontVariable: `--font-${fontConfig.nextFont.toLowerCase()}`,\n            // CSS properties\n            fontFamily: fontConfig.family,\n            fontSize: `${fontSize}px`,\n            fontWeight: weight,\n            fontStyle: style,\n            // ENHANCED: Complete style information\n            completeStyle: {\n                weight: weight,\n                style: style,\n                isItalic: styleAnalysis.isItalic,\n                isBold: styleAnalysis.isBold,\n                originalStyle: fontStyle,\n                complexStyle: styleAnalysis.complexStyle,\n                // CSS class suggestions\n                cssClasses: this.generateCSSClasses(styleAnalysis),\n                // Multiple weights for Next.js font loading\n                requiredWeights: this.getRequiredWeights(styleAnalysis, fontConfig.weights),\n                requiredStyles: this.getRequiredStyles(styleAnalysis)\n            },\n            // Fallback chain\n            fontFamilyFallback: [\n                fontConfig.family,\n                \"system-ui\",\n                \"-apple-system\",\n                \"sans-serif\"\n            ].join(\", \"),\n            // Metadata\n            category: fontConfig.characteristics ? fontConfig.characteristics[0] : \"sans-serif\",\n            isGoogleFont: fontConfig.googleFont || false,\n            isSystemFont: fontConfig.systemFont || false,\n            // Original values\n            originalFamily: originalFamily,\n            originalStyle: fontStyle,\n            originalSize: fontSize,\n            // Mapping info\n            mappingConfidence: fontConfig.score || 0,\n            mappingReason: this.generateMappingReason(fontConfig, originalFamily)\n        };\n    }\n    /**\r\n   * Analyze complex font styles like \"Bold Italic\", \"Semibold Condensed\", etc.\r\n   * @param {string} fontStyle - Font style string\r\n   * @returns {Object} Style analysis result\r\n   */ analyzeComplexFontStyle(fontStyle) {\n        if (!fontStyle) {\n            return {\n                isBold: false,\n                isItalic: false,\n                complexStyle: \"regular\",\n                weight: \"400\",\n                style: \"normal\"\n            };\n        }\n        const style = fontStyle.toLowerCase();\n        const analysis = {\n            isBold: style.includes(\"bold\"),\n            isItalic: style.includes(\"italic\") || style.includes(\"oblique\"),\n            isLight: style.includes(\"light\"),\n            isMedium: style.includes(\"medium\"),\n            isSemibold: style.includes(\"semibold\") || style.includes(\"demibold\"),\n            isBlack: style.includes(\"black\") || style.includes(\"heavy\"),\n            isCondensed: style.includes(\"condensed\") || style.includes(\"compressed\"),\n            originalStyle: fontStyle\n        };\n        // Determine complex style description\n        let complexStyle = \"regular\";\n        if (analysis.isBold && analysis.isItalic) {\n            complexStyle = \"bold-italic\";\n        } else if (analysis.isBold) {\n            complexStyle = \"bold\";\n        } else if (analysis.isItalic) {\n            complexStyle = \"italic\";\n        } else if (analysis.isSemibold) {\n            complexStyle = analysis.isItalic ? \"semibold-italic\" : \"semibold\";\n        } else if (analysis.isLight) {\n            complexStyle = analysis.isItalic ? \"light-italic\" : \"light\";\n        } else if (analysis.isMedium) {\n            complexStyle = analysis.isItalic ? \"medium-italic\" : \"medium\";\n        } else if (analysis.isBlack) {\n            complexStyle = analysis.isItalic ? \"black-italic\" : \"black\";\n        }\n        analysis.complexStyle = complexStyle;\n        analysis.weight = this.extractWeight(fontStyle);\n        analysis.style = analysis.isItalic ? \"italic\" : \"normal\";\n        return analysis;\n    }\n    /**\r\n   * Generate CSS classes for styling\r\n   * @param {Object} styleAnalysis - Style analysis result\r\n   * @returns {Array} CSS class suggestions\r\n   */ generateCSSClasses(styleAnalysis) {\n        const classes = [];\n        if (styleAnalysis.isBold) classes.push(\"font-bold\");\n        else if (styleAnalysis.isSemibold) classes.push(\"font-semibold\");\n        else if (styleAnalysis.isMedium) classes.push(\"font-medium\");\n        else if (styleAnalysis.isLight) classes.push(\"font-light\");\n        else classes.push(\"font-normal\");\n        if (styleAnalysis.isItalic) classes.push(\"italic\");\n        return classes;\n    }\n    /**\r\n   * Get required weights for Next.js font loading\r\n   * @param {Object} styleAnalysis - Style analysis result\r\n   * @param {Array} availableWeights - Available weights\r\n   * @returns {Array} Required weights\r\n   */ getRequiredWeights(styleAnalysis, availableWeights) {\n        const weights = [\n            \"400\"\n        ]; // Always include normal\n        if (styleAnalysis.isBold && availableWeights.includes(\"700\")) {\n            weights.push(\"700\");\n        }\n        if (styleAnalysis.isSemibold && availableWeights.includes(\"600\")) {\n            weights.push(\"600\");\n        }\n        if (styleAnalysis.isMedium && availableWeights.includes(\"500\")) {\n            weights.push(\"500\");\n        }\n        if (styleAnalysis.isLight && availableWeights.includes(\"300\")) {\n            weights.push(\"300\");\n        }\n        if (styleAnalysis.isBlack && availableWeights.includes(\"900\")) {\n            weights.push(\"900\");\n        }\n        return [\n            ...new Set(weights)\n        ];\n    }\n    /**\r\n   * Get required styles for Next.js font loading\r\n   * @param {Object} styleAnalysis - Style analysis result\r\n   * @returns {Array} Required styles\r\n   */ getRequiredStyles(styleAnalysis) {\n        const styles = [\n            \"normal\"\n        ];\n        if (styleAnalysis.isItalic) {\n            styles.push(\"italic\");\n        }\n        return styles;\n    }\n    /**\r\n   * Generate explanation for why this font was chosen\r\n   */ generateMappingReason(fontConfig, originalFamily) {\n        const reasons = [];\n        if (fontConfig.keywords && fontConfig.keywords.some((k)=>originalFamily.toLowerCase().includes(k))) {\n            reasons.push(\"keyword match\");\n        }\n        if (fontConfig.characteristics) {\n            reasons.push(`${fontConfig.characteristics[0]} characteristics`);\n        }\n        if (fontConfig.googleFont) {\n            reasons.push(\"Google Font availability\");\n        }\n        return reasons.length > 0 ? reasons.join(\", \") : \"category fallback\";\n    }\n    /**\r\n   * Map InDesign font style to CSS font weight\r\n   * @param {string} fontStyle - InDesign font style\r\n   * @param {Array} availableWeights - Available weights for font\r\n   * @returns {string} CSS font weight\r\n   */ mapFontWeight(fontStyle, availableWeights = [\n        \"400\"\n    ]) {\n        const style = (fontStyle || \"\").toLowerCase();\n        // Weight mapping\n        const weightMap = {\n            thin: \"100\",\n            extralight: \"200\",\n            light: \"300\",\n            regular: \"400\",\n            normal: \"400\",\n            medium: \"500\",\n            semibold: \"600\",\n            bold: \"700\",\n            extrabold: \"800\",\n            black: \"900\",\n            heavy: \"900\"\n        };\n        // Check for weight keywords in style\n        for (const [keyword, weight] of Object.entries(weightMap)){\n            if (style.includes(keyword)) {\n                // Ensure the weight is available\n                return availableWeights.includes(weight) ? weight : availableWeights.includes(\"400\") ? \"400\" : availableWeights[0];\n            }\n        }\n        // Default to normal weight\n        return availableWeights.includes(\"400\") ? \"400\" : availableWeights[0];\n    }\n    /**\r\n   * Map InDesign font style to CSS font style\r\n   * @param {string} fontStyle - InDesign font style\r\n   * @returns {string} CSS font style\r\n   */ mapFontStyle(fontStyle) {\n        const style = (fontStyle || \"\").toLowerCase();\n        if (style.includes(\"italic\") || style.includes(\"oblique\")) {\n            return \"italic\";\n        }\n        return \"normal\";\n    }\n    /**\r\n   * Get default fallback font configuration\r\n   * @returns {Object} Default font configuration\r\n   */ getDefaultFontConfig() {\n        return this.nextFontDatabase[\"sans-serif\"].humanist[0]; // Inter\n    }\n    /**\r\n   * Get default fallback font\r\n   * @returns {Object} Default font configuration\r\n   */ getDefaultFont() {\n        return this.buildFontConfig(this.getDefaultFontConfig(), \"Regular\", 16, \"Default Font\");\n    }\n    /**\r\n   * Generate Next.js font imports code\r\n   * @returns {string} Import statements for fonts\r\n   */ generateNextFontImports() {\n        const imports = Array.from(this.nextFontImports).map((fontName)=>{\n            return `import { ${fontName} } from 'next/font/google';`;\n        });\n        return imports.join(\"\\n\");\n    }\n    /**\r\n   * Generate Next.js font variable definitions\r\n   * @returns {string} Font variable definitions\r\n   */ generateFontVariables() {\n        const variables = Array.from(this.nextFontImports).map((fontName)=>{\n            // Find font config for weights and styles\n            const fontConfig = this.findFontConfigByNextFont(fontName);\n            // ENHANCED: Collect all required weights and styles from mapped fonts\n            const allRequiredWeights = new Set([\n                \"400\"\n            ]); // Always include normal\n            const allRequiredStyles = new Set([\n                \"normal\"\n            ]); // Always include normal\n            // Check all cached fonts for this Next.js font to see what weights/styles are needed\n            for (const [cacheKey, cachedFont] of this.fontCache.entries()){\n                if (cachedFont.nextFont === fontName) {\n                    if (cachedFont.completeStyle?.requiredWeights) {\n                        cachedFont.completeStyle.requiredWeights.forEach((w)=>allRequiredWeights.add(w));\n                    }\n                    if (cachedFont.completeStyle?.requiredStyles) {\n                        cachedFont.completeStyle.requiredStyles.forEach((s)=>allRequiredStyles.add(s));\n                    }\n                }\n            }\n            const weights = Array.from(allRequiredWeights).filter((w)=>fontConfig.weights.includes(w));\n            const styles = Array.from(allRequiredStyles).filter((s)=>fontConfig.styles.includes(s));\n            return `const ${fontName.toLowerCase()} = ${fontName}({\r\n  weight: [${weights.map((w)=>`'${w}'`).join(\", \")}],\r\n  style: [${styles.map((s)=>`'${s}'`).join(\", \")}],\r\n  subsets: ['latin'],\r\n  variable: '--font-${fontName.toLowerCase()}',\r\n  display: 'swap' // Optimize loading\r\n});`;\n        });\n        return variables.join(\"\\n\\n\");\n    }\n    /**\r\n   * Find font config by Next.js font name\r\n   */ findFontConfigByNextFont(nextFontName) {\n        // Search through all categories\n        for (const category of Object.values(this.nextFontDatabase)){\n            if (Array.isArray(category)) {\n                const found = category.find((f)=>f.nextFont === nextFontName);\n                if (found) return found;\n            } else {\n                for (const subcategory of Object.values(category)){\n                    const found = subcategory.find((f)=>f.nextFont === nextFontName);\n                    if (found) return found;\n                }\n            }\n        }\n        // Default fallback\n        return this.getDefaultFontConfig();\n    }\n    /**\r\n   * Get all unique fonts used in a document\r\n   * @param {Object} documentData - Processed IDML document data\r\n   * @returns {Array} Array of font configurations\r\n   */ extractDocumentFonts(documentData) {\n        const usedFonts = new Set();\n        const fontConfigs = [];\n        console.log(\"\\uD83D\\uDD0D Extracting fonts from document data...\");\n        // Extract fonts from stories\n        if (documentData.stories) {\n            Object.values(documentData.stories).forEach((story)=>{\n                if (story.content && story.content.formattedContent) {\n                    story.content.formattedContent.forEach((segment)=>{\n                        if (segment.formatting && segment.formatting.fontFamily) {\n                            const key = `${segment.formatting.fontFamily}-${segment.formatting.fontStyle || \"Regular\"}`;\n                            if (!usedFonts.has(key)) {\n                                usedFonts.add(key);\n                                const config = this.mapToNextFont(segment.formatting.fontFamily, segment.formatting.fontStyle, segment.formatting.fontSize || 16);\n                                fontConfigs.push(config);\n                            }\n                        }\n                    });\n                }\n            });\n        }\n        // Extract fonts from resources\n        if (documentData.resources && documentData.resources.fonts) {\n            Object.values(documentData.resources.fonts).forEach((fontFamily)=>{\n                if (fontFamily.fonts) {\n                    fontFamily.fonts.forEach((font)=>{\n                        const key = `${font.fontFamily}-${font.fontStyleName}`;\n                        if (!usedFonts.has(key)) {\n                            usedFonts.add(key);\n                            const config = this.mapToNextFont(font.fontFamily, font.fontStyleName, 16, {\n                                postScriptName: font.postScriptName,\n                                status: font.status\n                            });\n                            fontConfigs.push(config);\n                        }\n                    });\n                }\n            });\n        }\n        console.log(`ðŸ“Š Extracted ${fontConfigs.length} unique fonts from document`);\n        // Log summary\n        fontConfigs.forEach((font, index)=>{\n            console.log(`   ${index + 1}. \"${font.originalFamily}\" â†’ \"${font.fontFamily}\" (${font.mappingReason})`);\n        });\n        return fontConfigs;\n    }\n    /**\r\n   * Clear caches\r\n   */ clearCache() {\n        this.fontCache.clear();\n        this.nextFontImports.clear();\n    }\n}\nmodule.exports = NextFontMapper;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S3FHLE1BQU07NEJBQ3JCOzRCQUVGYixZQUFZeEMsSUFBSSxDQUFDZ0Q7d0JBQ25CO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBN0osUUFBUUMsR0FBRyxDQUNULENBQUMsYUFBYSxFQUFFb0osWUFBWTlGLE1BQU0sQ0FBQywyQkFBMkIsQ0FBQztRQUdqRSxjQUFjO1FBQ2Q4RixZQUFZWixPQUFPLENBQUMsQ0FBQzVFLE1BQU1zRztZQUN6Qm5LLFFBQVFDLEdBQUcsQ0FDVCxDQUFDLEdBQUcsRUFBRWtLLFFBQVEsRUFBRSxHQUFHLEVBQUV0RyxLQUFLZ0IsY0FBYyxDQUFDLEtBQUssRUFBRWhCLEtBQUsxQyxVQUFVLENBQUMsR0FBRyxFQUNqRTBDLEtBQUt5QyxhQUFhLENBQ25CLENBQUMsQ0FBQztRQUVQO1FBRUEsT0FBTytDO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEZSxhQUFhO1FBQ1gsSUFBSSxDQUFDN0wsU0FBUyxDQUFDOEwsS0FBSztRQUNwQixJQUFJLENBQUM1TCxlQUFlLENBQUM0TCxLQUFLO0lBQzVCO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHcE0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZG1sLXZpZXdlci8uL2xpYi91dGlscy9OZXh0Rm9udE1hcHBlci5qcz9kNWJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBOZXh0Rm9udE1hcHBlci5qcyAtIER5bmFtaWMgTmV4dC5qcyBmb250IG1hcHBpbmcgYmFzZWQgb24gZm9udCBjaGFyYWN0ZXJpc3RpY3NcclxuICogTk8gSEFSRENPREVEIE1BUFBJTkdTIC0gQXV0b21hdGljYWxseSBtYXBzIGFueSBmb250IHRvIGFwcHJvcHJpYXRlIE5leHQuanMgZm9udHNcclxuICovXHJcblxyXG5jbGFzcyBOZXh0Rm9udE1hcHBlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvLyBBdmFpbGFibGUgTmV4dC5qcyBmb250IGNhdGVnb3JpZXMgYW5kIHRoZWlyIGNoYXJhY3RlcmlzdGljc1xyXG4gICAgdGhpcy5uZXh0Rm9udERhdGFiYXNlID0gdGhpcy5pbml0aWFsaXplTmV4dEZvbnREYXRhYmFzZSgpO1xyXG4gICAgdGhpcy5mb250Q2FjaGUgPSBuZXcgTWFwKCk7IC8vIENhY2hlIGZvciByZXNvbHZlZCBmb250c1xyXG4gICAgdGhpcy5uZXh0Rm9udEltcG9ydHMgPSBuZXcgU2V0KCk7IC8vIFRyYWNrIHdoaWNoIGZvbnRzIG5lZWQgdG8gYmUgaW1wb3J0ZWRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgY29tcHJlaGVuc2l2ZSBOZXh0LmpzIGZvbnQgZGF0YWJhc2Ugd2l0aCBjaGFyYWN0ZXJpc3RpY3NcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb250IGRhdGFiYXNlIGNhdGVnb3JpemVkIGJ5IHR5cGUgYW5kIGNoYXJhY3RlcmlzdGljc1xyXG4gICAqL1xyXG4gIGluaXRpYWxpemVOZXh0Rm9udERhdGFiYXNlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2VyaWY6IHtcclxuICAgICAgICB0cmFkaXRpb25hbDogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuZXh0Rm9udDogXCJDcmltc29uX1RleHRcIixcclxuICAgICAgICAgICAgZmFtaWx5OiBcIkNyaW1zb24gVGV4dFwiLFxyXG4gICAgICAgICAgICB3ZWlnaHRzOiBbXCI0MDBcIiwgXCI2MDBcIiwgXCI3MDBcIl0sXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wibm9ybWFsXCIsIFwiaXRhbGljXCJdLFxyXG4gICAgICAgICAgICBnb29nbGVGb250OiB0cnVlLFxyXG4gICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IFtcclxuICAgICAgICAgICAgICBcImVsZWdhbnRcIixcclxuICAgICAgICAgICAgICBcInRyYWRpdGlvbmFsXCIsXHJcbiAgICAgICAgICAgICAgXCJyZWFkYWJsZVwiLFxyXG4gICAgICAgICAgICAgIFwiYm9keS10ZXh0XCIsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGtleXdvcmRzOiBbXCJtaW5pb25cIiwgXCJ0aW1lc1wiLCBcImdhcmFtb25kXCIsIFwiYmFza2VydmlsbGVcIiwgXCJjYXNsb25cIl0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuZXh0Rm9udDogXCJMaWJyZV9CYXNrZXJ2aWxsZVwiLFxyXG4gICAgICAgICAgICBmYW1pbHk6IFwiTGlicmUgQmFza2VydmlsbGVcIixcclxuICAgICAgICAgICAgd2VpZ2h0czogW1wiNDAwXCIsIFwiNzAwXCJdLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiXSxcclxuICAgICAgICAgICAgZ29vZ2xlRm9udDogdHJ1ZSxcclxuICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBbXCJjbGFzc2ljXCIsIFwicmVhZGFibGVcIiwgXCJib29rXCJdLFxyXG4gICAgICAgICAgICBrZXl3b3JkczogW1wiYmFza2VydmlsbGVcIiwgXCJsaWJyZVwiLCBcImJvb2tcIl0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuZXh0Rm9udDogXCJMb3JhXCIsXHJcbiAgICAgICAgICAgIGZhbWlseTogXCJMb3JhXCIsXHJcbiAgICAgICAgICAgIHdlaWdodHM6IFtcIjQwMFwiLCBcIjUwMFwiLCBcIjYwMFwiLCBcIjcwMFwiXSxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCJub3JtYWxcIiwgXCJpdGFsaWNcIl0sXHJcbiAgICAgICAgICAgIGdvb2dsZUZvbnQ6IHRydWUsXHJcbiAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogW1wibW9kZXJuXCIsIFwiZnJpZW5kbHlcIiwgXCJjYWxsaWdyYXBoaWNcIl0sXHJcbiAgICAgICAgICAgIGtleXdvcmRzOiBbXCJsb3JhXCIsIFwibW9kZXJuLXNlcmlmXCJdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGRpc3BsYXk6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmV4dEZvbnQ6IFwiUGxheWZhaXJfRGlzcGxheVwiLFxyXG4gICAgICAgICAgICBmYW1pbHk6IFwiUGxheWZhaXIgRGlzcGxheVwiLFxyXG4gICAgICAgICAgICB3ZWlnaHRzOiBbXCI0MDBcIiwgXCI1MDBcIiwgXCI2MDBcIiwgXCI3MDBcIiwgXCI4MDBcIiwgXCI5MDBcIl0sXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wibm9ybWFsXCIsIFwiaXRhbGljXCJdLFxyXG4gICAgICAgICAgICBnb29nbGVGb250OiB0cnVlLFxyXG4gICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IFtcImVsZWdhbnRcIiwgXCJoaWdoLWNvbnRyYXN0XCIsIFwiZGlzcGxheVwiLCBcImx1eHVyeVwiXSxcclxuICAgICAgICAgICAga2V5d29yZHM6IFtcInBsYXlmYWlyXCIsIFwiZGlzcGxheVwiLCBcImVsZWdhbnRcIiwgXCJsdXh1cnlcIl0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuZXh0Rm9udDogXCJDb3Jtb3JhbnRfR2FyYW1vbmRcIixcclxuICAgICAgICAgICAgZmFtaWx5OiBcIkNvcm1vcmFudCBHYXJhbW9uZFwiLFxyXG4gICAgICAgICAgICB3ZWlnaHRzOiBbXCIzMDBcIiwgXCI0MDBcIiwgXCI1MDBcIiwgXCI2MDBcIiwgXCI3MDBcIl0sXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wibm9ybWFsXCIsIFwiaXRhbGljXCJdLFxyXG4gICAgICAgICAgICBnb29nbGVGb250OiB0cnVlLFxyXG4gICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IFtcInJlZmluZWRcIiwgXCJnYXJhbW9uZFwiLCBcImNsYXNzaWNcIl0sXHJcbiAgICAgICAgICAgIGtleXdvcmRzOiBbXCJnYXJhbW9uZFwiLCBcImNvcm1vcmFudFwiLCBcInJlZmluZWRcIl0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBcInNhbnMtc2VyaWZcIjoge1xyXG4gICAgICAgIGdlb21ldHJpYzogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuZXh0Rm9udDogXCJJbnRlclwiLFxyXG4gICAgICAgICAgICBmYW1pbHk6IFwiSW50ZXJcIixcclxuICAgICAgICAgICAgd2VpZ2h0czogW1xyXG4gICAgICAgICAgICAgIFwiMTAwXCIsXHJcbiAgICAgICAgICAgICAgXCIyMDBcIixcclxuICAgICAgICAgICAgICBcIjMwMFwiLFxyXG4gICAgICAgICAgICAgIFwiNDAwXCIsXHJcbiAgICAgICAgICAgICAgXCI1MDBcIixcclxuICAgICAgICAgICAgICBcIjYwMFwiLFxyXG4gICAgICAgICAgICAgIFwiNzAwXCIsXHJcbiAgICAgICAgICAgICAgXCI4MDBcIixcclxuICAgICAgICAgICAgICBcIjkwMFwiLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiXSxcclxuICAgICAgICAgICAgZ29vZ2xlRm9udDogdHJ1ZSxcclxuICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBbXHJcbiAgICAgICAgICAgICAgXCJtb2Rlcm5cIixcclxuICAgICAgICAgICAgICBcImNsZWFuXCIsXHJcbiAgICAgICAgICAgICAgXCJ1aVwiLFxyXG4gICAgICAgICAgICAgIFwidmVyc2F0aWxlXCIsXHJcbiAgICAgICAgICAgICAgXCJnZW9tZXRyaWNcIixcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAga2V5d29yZHM6IFtcImludGVyXCIsIFwidWlcIiwgXCJpbnRlcmZhY2VcIiwgXCJtb2Rlcm5cIl0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuZXh0Rm9udDogXCJOdW5pdG9fU2Fuc1wiLFxyXG4gICAgICAgICAgICBmYW1pbHk6IFwiTnVuaXRvIFNhbnNcIixcclxuICAgICAgICAgICAgd2VpZ2h0czogW1wiMjAwXCIsIFwiMzAwXCIsIFwiNDAwXCIsIFwiNTAwXCIsIFwiNjAwXCIsIFwiNzAwXCIsIFwiODAwXCIsIFwiOTAwXCJdLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiXSxcclxuICAgICAgICAgICAgZ29vZ2xlRm9udDogdHJ1ZSxcclxuICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBbXCJmcmllbmRseVwiLCBcInJvdW5kZWRcIiwgXCJnZW9tZXRyaWNcIl0sXHJcbiAgICAgICAgICAgIGtleXdvcmRzOiBbXCJudW5pdG9cIiwgXCJmcmllbmRseVwiLCBcInJvdW5kZWRcIiwgXCJmdXR1cmFcIiwgXCJhdmVuaXJcIl0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgaHVtYW5pc3Q6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmV4dEZvbnQ6IFwiT3Blbl9TYW5zXCIsXHJcbiAgICAgICAgICAgIGZhbWlseTogXCJPcGVuIFNhbnNcIixcclxuICAgICAgICAgICAgd2VpZ2h0czogW1wiMzAwXCIsIFwiNDAwXCIsIFwiNTAwXCIsIFwiNjAwXCIsIFwiNzAwXCIsIFwiODAwXCJdLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiXSxcclxuICAgICAgICAgICAgZ29vZ2xlRm9udDogdHJ1ZSxcclxuICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBbXHJcbiAgICAgICAgICAgICAgXCJ2ZXJzYXRpbGVcIixcclxuICAgICAgICAgICAgICBcInJlYWRhYmxlXCIsXHJcbiAgICAgICAgICAgICAgXCJuZXV0cmFsXCIsXHJcbiAgICAgICAgICAgICAgXCJwcm9mZXNzaW9uYWxcIixcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAga2V5d29yZHM6IFtcIm9wZW5cIiwgXCJteXJpYWRcIiwgXCJwcm9mZXNzaW9uYWxcIiwgXCJjbGVhblwiXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5leHRGb250OiBcIlNvdXJjZV9TYW5zXzNcIixcclxuICAgICAgICAgICAgZmFtaWx5OiBcIlNvdXJjZSBTYW5zIDNcIixcclxuICAgICAgICAgICAgd2VpZ2h0czogW1wiMjAwXCIsIFwiMzAwXCIsIFwiNDAwXCIsIFwiNTAwXCIsIFwiNjAwXCIsIFwiNzAwXCIsIFwiODAwXCIsIFwiOTAwXCJdLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiXSxcclxuICAgICAgICAgICAgZ29vZ2xlRm9udDogdHJ1ZSxcclxuICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBbXCJhZG9iZVwiLCBcInRlY2huaWNhbFwiLCBcImNsZWFuXCJdLFxyXG4gICAgICAgICAgICBrZXl3b3JkczogW1wic291cmNlXCIsIFwiYWRvYmVcIiwgXCJ0ZWNobmljYWxcIiwgXCJjYWxpYnJpXCJdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmV4dEZvbnQ6IFwiTGF0b1wiLFxyXG4gICAgICAgICAgICBmYW1pbHk6IFwiTGF0b1wiLFxyXG4gICAgICAgICAgICB3ZWlnaHRzOiBbXCIxMDBcIiwgXCIzMDBcIiwgXCI0MDBcIiwgXCI3MDBcIiwgXCI5MDBcIl0sXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wibm9ybWFsXCIsIFwiaXRhbGljXCJdLFxyXG4gICAgICAgICAgICBnb29nbGVGb250OiB0cnVlLFxyXG4gICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IFtcIndhcm1cIiwgXCJmcmllbmRseVwiLCBcInByb2Zlc3Npb25hbFwiXSxcclxuICAgICAgICAgICAga2V5d29yZHM6IFtcImxhdG9cIiwgXCJ3YXJtXCIsIFwiZnJpZW5kbHlcIl0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZ3JvdGVzcXVlOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5leHRGb250OiBcIlJvYm90b1wiLFxyXG4gICAgICAgICAgICBmYW1pbHk6IFwiUm9ib3RvXCIsXHJcbiAgICAgICAgICAgIHdlaWdodHM6IFtcIjEwMFwiLCBcIjMwMFwiLCBcIjQwMFwiLCBcIjUwMFwiLCBcIjcwMFwiLCBcIjkwMFwiXSxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCJub3JtYWxcIiwgXCJpdGFsaWNcIl0sXHJcbiAgICAgICAgICAgIGdvb2dsZUZvbnQ6IHRydWUsXHJcbiAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogW1wiYW5kcm9pZFwiLCBcIm1vZGVyblwiLCBcIm1lY2hhbmljYWxcIl0sXHJcbiAgICAgICAgICAgIGtleXdvcmRzOiBbXCJyb2JvdG9cIiwgXCJhbmRyb2lkXCIsIFwibWVjaGFuaWNhbFwiXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5leHRGb250OiBcIldvcmtfU2Fuc1wiLFxyXG4gICAgICAgICAgICBmYW1pbHk6IFwiV29yayBTYW5zXCIsXHJcbiAgICAgICAgICAgIHdlaWdodHM6IFtcclxuICAgICAgICAgICAgICBcIjEwMFwiLFxyXG4gICAgICAgICAgICAgIFwiMjAwXCIsXHJcbiAgICAgICAgICAgICAgXCIzMDBcIixcclxuICAgICAgICAgICAgICBcIjQwMFwiLFxyXG4gICAgICAgICAgICAgIFwiNTAwXCIsXHJcbiAgICAgICAgICAgICAgXCI2MDBcIixcclxuICAgICAgICAgICAgICBcIjcwMFwiLFxyXG4gICAgICAgICAgICAgIFwiODAwXCIsXHJcbiAgICAgICAgICAgICAgXCI5MDBcIixcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCJub3JtYWxcIiwgXCJpdGFsaWNcIl0sXHJcbiAgICAgICAgICAgIGdvb2dsZUZvbnQ6IHRydWUsXHJcbiAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogW1wid29ya1wiLCBcInByb2Zlc3Npb25hbFwiLCBcImNsZWFuXCJdLFxyXG4gICAgICAgICAgICBrZXl3b3JkczogW1wid29ya1wiLCBcInByb2Zlc3Npb25hbFwiLCBcImhlbHZldGljYVwiXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuXHJcbiAgICAgIG1vbm9zcGFjZTogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIG5leHRGb250OiBcIkpldEJyYWluc19Nb25vXCIsXHJcbiAgICAgICAgICBmYW1pbHk6IFwiSmV0QnJhaW5zIE1vbm9cIixcclxuICAgICAgICAgIHdlaWdodHM6IFtcIjEwMFwiLCBcIjIwMFwiLCBcIjMwMFwiLCBcIjQwMFwiLCBcIjUwMFwiLCBcIjYwMFwiLCBcIjcwMFwiLCBcIjgwMFwiXSxcclxuICAgICAgICAgIHN0eWxlczogW1wibm9ybWFsXCIsIFwiaXRhbGljXCJdLFxyXG4gICAgICAgICAgZ29vZ2xlRm9udDogdHJ1ZSxcclxuICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogW1wiY29kaW5nXCIsIFwibW9kZXJuXCIsIFwibGlnYXR1cmVzXCJdLFxyXG4gICAgICAgICAga2V5d29yZHM6IFtcImpldGJyYWluc1wiLCBcImNvZGVcIiwgXCJwcm9ncmFtbWluZ1wiXSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG5leHRGb250OiBcIkNvdXJpZXJfUHJpbWVcIixcclxuICAgICAgICAgIGZhbWlseTogXCJDb3VyaWVyIFByaW1lXCIsXHJcbiAgICAgICAgICB3ZWlnaHRzOiBbXCI0MDBcIiwgXCI3MDBcIl0sXHJcbiAgICAgICAgICBzdHlsZXM6IFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiXSxcclxuICAgICAgICAgIGdvb2dsZUZvbnQ6IHRydWUsXHJcbiAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IFtcInR5cGV3cml0ZXJcIiwgXCJjbGFzc2ljXCIsIFwiY291cmllclwiXSxcclxuICAgICAgICAgIGtleXdvcmRzOiBbXCJjb3VyaWVyXCIsIFwidHlwZXdyaXRlclwiLCBcImNsYXNzaWNcIl0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuZXh0Rm9udDogXCJTb3VyY2VfQ29kZV9Qcm9cIixcclxuICAgICAgICAgIGZhbWlseTogXCJTb3VyY2UgQ29kZSBQcm9cIixcclxuICAgICAgICAgIHdlaWdodHM6IFtcIjIwMFwiLCBcIjMwMFwiLCBcIjQwMFwiLCBcIjUwMFwiLCBcIjYwMFwiLCBcIjcwMFwiLCBcIjgwMFwiLCBcIjkwMFwiXSxcclxuICAgICAgICAgIHN0eWxlczogW1wibm9ybWFsXCIsIFwiaXRhbGljXCJdLFxyXG4gICAgICAgICAgZ29vZ2xlRm9udDogdHJ1ZSxcclxuICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogW1wiYWRvYmVcIiwgXCJjb2RpbmdcIiwgXCJ0ZWNobmljYWxcIl0sXHJcbiAgICAgICAgICBrZXl3b3JkczogW1wic291cmNlXCIsIFwiY29kZVwiLCBcImFkb2JlXCIsIFwidGVjaG5pY2FsXCJdLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcblxyXG4gICAgICAvLyBMYW5ndWFnZS1zcGVjaWZpYyBmb250c1xyXG4gICAgICBqYXBhbmVzZTogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIG5leHRGb250OiBcIk5vdG9fU2VyaWZfSlBcIixcclxuICAgICAgICAgIGZhbWlseTogXCJOb3RvIFNlcmlmIEpQXCIsXHJcbiAgICAgICAgICB3ZWlnaHRzOiBbXCIyMDBcIiwgXCIzMDBcIiwgXCI0MDBcIiwgXCI1MDBcIiwgXCI2MDBcIiwgXCI3MDBcIiwgXCI5MDBcIl0sXHJcbiAgICAgICAgICBzdHlsZXM6IFtcIm5vcm1hbFwiXSxcclxuICAgICAgICAgIGdvb2dsZUZvbnQ6IHRydWUsXHJcbiAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IFtcImphcGFuZXNlXCIsIFwic2VyaWZcIiwgXCJ0cmFkaXRpb25hbFwiXSxcclxuICAgICAgICAgIGtleXdvcmRzOiBbXCJqYXBhbmVzZVwiLCBcImpwXCIsIFwibWluY2hvXCIsIFwia296dWthXCIsIFwibm90b1wiXSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG5leHRGb250OiBcIk5vdG9fU2Fuc19KUFwiLFxyXG4gICAgICAgICAgZmFtaWx5OiBcIk5vdG8gU2FucyBKUFwiLFxyXG4gICAgICAgICAgd2VpZ2h0czogW1wiMTAwXCIsIFwiMzAwXCIsIFwiNDAwXCIsIFwiNTAwXCIsIFwiNzAwXCIsIFwiOTAwXCJdLFxyXG4gICAgICAgICAgc3R5bGVzOiBbXCJub3JtYWxcIl0sXHJcbiAgICAgICAgICBnb29nbGVGb250OiB0cnVlLFxyXG4gICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBbXCJqYXBhbmVzZVwiLCBcInNhbnMtc2VyaWZcIiwgXCJtb2Rlcm5cIl0sXHJcbiAgICAgICAgICBrZXl3b3JkczogW1wiamFwYW5lc2VcIiwgXCJqcFwiLCBcImdvdGhpY1wiLCBcInNhbnNcIiwgXCJub3RvXCJdLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcblxyXG4gICAgICBjaGluZXNlOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbmV4dEZvbnQ6IFwiTm90b19TZXJpZl9TQ1wiLFxyXG4gICAgICAgICAgZmFtaWx5OiBcIk5vdG8gU2VyaWYgU0NcIixcclxuICAgICAgICAgIHdlaWdodHM6IFtcIjIwMFwiLCBcIjMwMFwiLCBcIjQwMFwiLCBcIjUwMFwiLCBcIjYwMFwiLCBcIjcwMFwiLCBcIjkwMFwiXSxcclxuICAgICAgICAgIHN0eWxlczogW1wibm9ybWFsXCJdLFxyXG4gICAgICAgICAgZ29vZ2xlRm9udDogdHJ1ZSxcclxuICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogW1wiY2hpbmVzZVwiLCBcInNpbXBsaWZpZWRcIiwgXCJzZXJpZlwiXSxcclxuICAgICAgICAgIGtleXdvcmRzOiBbXCJjaGluZXNlXCIsIFwic2ltcGxpZmllZFwiLCBcInNjXCIsIFwic2ltc3VuXCIsIFwibm90b1wiXSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG5leHRGb250OiBcIk5vdG9fU2Fuc19TQ1wiLFxyXG4gICAgICAgICAgZmFtaWx5OiBcIk5vdG8gU2FucyBTQ1wiLFxyXG4gICAgICAgICAgd2VpZ2h0czogW1wiMTAwXCIsIFwiMzAwXCIsIFwiNDAwXCIsIFwiNTAwXCIsIFwiNzAwXCIsIFwiOTAwXCJdLFxyXG4gICAgICAgICAgc3R5bGVzOiBbXCJub3JtYWxcIl0sXHJcbiAgICAgICAgICBnb29nbGVGb250OiB0cnVlLFxyXG4gICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBbXCJjaGluZXNlXCIsIFwic2ltcGxpZmllZFwiLCBcInNhbnMtc2VyaWZcIl0sXHJcbiAgICAgICAgICBrZXl3b3JkczogW1wiY2hpbmVzZVwiLCBcInNpbXBsaWZpZWRcIiwgXCJzY1wiLCBcInNhbnNcIiwgXCJub3RvXCJdLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHluYW1pY2FsbHkgbWFwIElETUwgZm9udCB0byBOZXh0LmpzIGZvbnQgYmFzZWQgb24gY2hhcmFjdGVyaXN0aWNzXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkbWxGb250RmFtaWx5IC0gT3JpZ2luYWwgSURNTCBmb250IGZhbWlseVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3R5bGUgLSBGb250IHN0eWxlIChSZWd1bGFyLCBCb2xkLCBJdGFsaWMsIGV0Yy4pXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZvbnRTaXplIC0gRm9udCBzaXplIGluIHBpeGVsc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb250TWV0YWRhdGEgLSBBZGRpdGlvbmFsIGZvbnQgbWV0YWRhdGEgZnJvbSBJRE1MXHJcbiAgICogQHJldHVybnMge09iamVjdH0gTmV4dC5qcyBmb250IGNvbmZpZ3VyYXRpb25cclxuICAgKi9cclxuICBtYXBUb05leHRGb250KFxyXG4gICAgaWRtbEZvbnRGYW1pbHksXHJcbiAgICBmb250U3R5bGUgPSBcIlJlZ3VsYXJcIixcclxuICAgIGZvbnRTaXplID0gMTYsXHJcbiAgICBmb250TWV0YWRhdGEgPSB7fVxyXG4gICkge1xyXG4gICAgaWYgKCFpZG1sRm9udEZhbWlseSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuKaoO+4jyAgTm8gZm9udCBmYW1pbHkgcHJvdmlkZWQsIHVzaW5nIGRlZmF1bHRcIik7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRGb250KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGNhY2hlIGtleVxyXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtpZG1sRm9udEZhbWlseX0tJHtmb250U3R5bGV9LSR7Zm9udFNpemV9YDtcclxuXHJcbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxyXG4gICAgaWYgKHRoaXMuZm9udENhY2hlLmhhcyhjYWNoZUtleSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZm9udENhY2hlLmdldChjYWNoZUtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5SNIER5bmFtaWNhbGx5IG1hcHBpbmcgZm9udDogXCIke2lkbWxGb250RmFtaWx5fVwiICgke2ZvbnRTdHlsZX0pYFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBbmFseXplIGZvbnQgY2hhcmFjdGVyaXN0aWNzXHJcbiAgICBjb25zdCBmb250QW5hbHlzaXMgPSB0aGlzLmFuYWx5emVGb250Q2hhcmFjdGVyaXN0aWNzKFxyXG4gICAgICBpZG1sRm9udEZhbWlseSxcclxuICAgICAgZm9udFN0eWxlLFxyXG4gICAgICBmb250TWV0YWRhdGFcclxuICAgICk7XHJcblxyXG4gICAgY29uc29sZS5sb2coYPCfk4ogRm9udCBhbmFseXNpcyBmb3IgXCIke2lkbWxGb250RmFtaWx5fVwiOmAsIHtcclxuICAgICAgY2F0ZWdvcnk6IGZvbnRBbmFseXNpcy5jYXRlZ29yeSxcclxuICAgICAgc3ViY2F0ZWdvcnk6IGZvbnRBbmFseXNpcy5zdWJjYXRlZ29yeSxcclxuICAgICAgbGFuZ3VhZ2U6IGZvbnRBbmFseXNpcy5sYW5ndWFnZSxcclxuICAgICAga2V5d29yZHM6IGZvbnRBbmFseXNpcy5kZXRlY3RlZEtleXdvcmRzLFxyXG4gICAgICBjb25maWRlbmNlOiBmb250QW5hbHlzaXMuY29uZmlkZW5jZSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEZpbmQgYmVzdCBtYXRjaGluZyBOZXh0LmpzIGZvbnRcclxuICAgIGNvbnN0IGJlc3RNYXRjaCA9IHRoaXMuZmluZEJlc3ROZXh0SlNGb250KGZvbnRBbmFseXNpcywgaWRtbEZvbnRGYW1pbHkpO1xyXG5cclxuICAgIC8vIEJ1aWxkIGZpbmFsIGZvbnQgY29uZmlndXJhdGlvblxyXG4gICAgY29uc3QgZmluYWxDb25maWcgPSB0aGlzLmJ1aWxkRm9udENvbmZpZyhcclxuICAgICAgYmVzdE1hdGNoLFxyXG4gICAgICBmb250U3R5bGUsXHJcbiAgICAgIGZvbnRTaXplLFxyXG4gICAgICBpZG1sRm9udEZhbWlseVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBZGQgdG8gY2FjaGVcclxuICAgIHRoaXMuZm9udENhY2hlLnNldChjYWNoZUtleSwgZmluYWxDb25maWcpO1xyXG5cclxuICAgIC8vIFRyYWNrIGZvciBpbXBvcnQgZ2VuZXJhdGlvblxyXG4gICAgdGhpcy5uZXh0Rm9udEltcG9ydHMuYWRkKGJlc3RNYXRjaC5uZXh0Rm9udCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDinIUgRHluYW1pYyBtYXBwaW5nOiBcIiR7aWRtbEZvbnRGYW1pbHl9XCIg4oaSIFwiJHtmaW5hbENvbmZpZy5mb250RmFtaWx5fVwiICgke2Jlc3RNYXRjaC5uZXh0Rm9udH0pYFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxDb25maWc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbmFseXplIGZvbnQgY2hhcmFjdGVyaXN0aWNzIHRvIGRldGVybWluZSBjYXRlZ29yeSBhbmQgcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb250TmFtZSAtIEZvbnQgbmFtZSB0byBhbmFseXplXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTdHlsZSAtIEZvbnQgc3R5bGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGEgLSBBZGRpdGlvbmFsIG1ldGFkYXRhXHJcbiAgICogQHJldHVybnMge09iamVjdH0gRm9udCBhbmFseXNpcyByZXN1bHRcclxuICAgKi9cclxuICBhbmFseXplRm9udENoYXJhY3RlcmlzdGljcyhmb250TmFtZSwgZm9udFN0eWxlLCBtZXRhZGF0YSA9IHt9KSB7XHJcbiAgICBjb25zdCBsb3dlck5hbWUgPSBmb250TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgY29uc3QgYW5hbHlzaXMgPSB7XHJcbiAgICAgIGNhdGVnb3J5OiBcInNhbnMtc2VyaWZcIiwgLy8gZGVmYXVsdFxyXG4gICAgICBzdWJjYXRlZ29yeTogXCJodW1hbmlzdFwiLCAvLyBkZWZhdWx0XHJcbiAgICAgIGxhbmd1YWdlOiBcImxhdGluXCIsXHJcbiAgICAgIGRldGVjdGVkS2V5d29yZHM6IFtdLFxyXG4gICAgICBjb25maWRlbmNlOiAwLFxyXG4gICAgICB3ZWlnaHQ6IHRoaXMuZXh0cmFjdFdlaWdodChmb250U3R5bGUpLFxyXG4gICAgICBpc0Rpc3BsYXk6IGZhbHNlLFxyXG4gICAgICBpc0NvbmRlbnNlZDogZmFsc2UsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExhbmd1YWdlIGRldGVjdGlvblxyXG4gICAgaWYgKHRoaXMuaXNKYXBhbmVzZUZvbnQobG93ZXJOYW1lKSkge1xyXG4gICAgICBhbmFseXNpcy5sYW5ndWFnZSA9IFwiamFwYW5lc2VcIjtcclxuICAgICAgYW5hbHlzaXMuY2F0ZWdvcnkgPSB0aGlzLmlzU2VyaWZGb250KGxvd2VyTmFtZSkgPyBcInNlcmlmXCIgOiBcInNhbnMtc2VyaWZcIjtcclxuICAgICAgYW5hbHlzaXMuY29uZmlkZW5jZSArPSAwLjg7XHJcbiAgICAgIHJldHVybiBhbmFseXNpcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc0NoaW5lc2VGb250KGxvd2VyTmFtZSkpIHtcclxuICAgICAgYW5hbHlzaXMubGFuZ3VhZ2UgPSBcImNoaW5lc2VcIjtcclxuICAgICAgYW5hbHlzaXMuY2F0ZWdvcnkgPSB0aGlzLmlzU2VyaWZGb250KGxvd2VyTmFtZSkgPyBcInNlcmlmXCIgOiBcInNhbnMtc2VyaWZcIjtcclxuICAgICAgYW5hbHlzaXMuY29uZmlkZW5jZSArPSAwLjg7XHJcbiAgICAgIHJldHVybiBhbmFseXNpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYXRlZ29yeSBkZXRlY3Rpb25cclxuICAgIGlmICh0aGlzLmlzU2VyaWZGb250KGxvd2VyTmFtZSkpIHtcclxuICAgICAgYW5hbHlzaXMuY2F0ZWdvcnkgPSBcInNlcmlmXCI7XHJcbiAgICAgIGFuYWx5c2lzLnN1YmNhdGVnb3J5ID0gdGhpcy5pc0Rpc3BsYXlGb250KGxvd2VyTmFtZSlcclxuICAgICAgICA/IFwiZGlzcGxheVwiXHJcbiAgICAgICAgOiBcInRyYWRpdGlvbmFsXCI7XHJcbiAgICAgIGFuYWx5c2lzLmNvbmZpZGVuY2UgKz0gMC42O1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzTW9ub3NwYWNlRm9udChsb3dlck5hbWUpKSB7XHJcbiAgICAgIGFuYWx5c2lzLmNhdGVnb3J5ID0gXCJtb25vc3BhY2VcIjtcclxuICAgICAgYW5hbHlzaXMuY29uZmlkZW5jZSArPSAwLjg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTYW5zLXNlcmlmIHN1YmNhdGVnb3J5IGRldGVjdGlvblxyXG4gICAgICBhbmFseXNpcy5jYXRlZ29yeSA9IFwic2Fucy1zZXJpZlwiO1xyXG4gICAgICBpZiAodGhpcy5pc0dlb21ldHJpY0ZvbnQobG93ZXJOYW1lKSkge1xyXG4gICAgICAgIGFuYWx5c2lzLnN1YmNhdGVnb3J5ID0gXCJnZW9tZXRyaWNcIjtcclxuICAgICAgICBhbmFseXNpcy5jb25maWRlbmNlICs9IDAuNTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzR3JvdGVzcXVlRm9udChsb3dlck5hbWUpKSB7XHJcbiAgICAgICAgYW5hbHlzaXMuc3ViY2F0ZWdvcnkgPSBcImdyb3Rlc3F1ZVwiO1xyXG4gICAgICAgIGFuYWx5c2lzLmNvbmZpZGVuY2UgKz0gMC41O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFuYWx5c2lzLnN1YmNhdGVnb3J5ID0gXCJodW1hbmlzdFwiOyAvLyBkZWZhdWx0XHJcbiAgICAgICAgYW5hbHlzaXMuY29uZmlkZW5jZSArPSAwLjM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGRpdGlvbmFsIGNoYXJhY3RlcmlzdGljc1xyXG4gICAgYW5hbHlzaXMuaXNEaXNwbGF5ID0gdGhpcy5pc0Rpc3BsYXlGb250KGxvd2VyTmFtZSk7XHJcbiAgICBhbmFseXNpcy5pc0NvbmRlbnNlZCA9IHRoaXMuaXNDb25kZW5zZWRGb250KGxvd2VyTmFtZSk7XHJcblxyXG4gICAgLy8gRXh0cmFjdCBrZXl3b3JkcyBmb3IgbWF0Y2hpbmdcclxuICAgIGFuYWx5c2lzLmRldGVjdGVkS2V5d29yZHMgPSB0aGlzLmV4dHJhY3RLZXl3b3Jkcyhsb3dlck5hbWUpO1xyXG5cclxuICAgIHJldHVybiBhbmFseXNpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGZvbnQgaXMgSmFwYW5lc2VcclxuICAgKi9cclxuICBpc0phcGFuZXNlRm9udChmb250TmFtZSkge1xyXG4gICAgY29uc3QgamFwYW5lc2VJbmRpY2F0b3JzID0gW1xyXG4gICAgICBcImtvenVrYVwiLFxyXG4gICAgICBcIm1pbmNob1wiLFxyXG4gICAgICBcImdvdGhpY1wiLFxyXG4gICAgICBcImhpcmFnaW5vXCIsXHJcbiAgICAgIFwieXVcIixcclxuICAgICAgXCJtZWlyeW9cIixcclxuICAgICAgXCJub3RvXCIsXHJcbiAgICAgIFwianBcIixcclxuICAgIF07XHJcbiAgICByZXR1cm4gamFwYW5lc2VJbmRpY2F0b3JzLnNvbWUoKGluZGljYXRvcikgPT4gZm9udE5hbWUuaW5jbHVkZXMoaW5kaWNhdG9yKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBmb250IGlzIENoaW5lc2VcclxuICAgKi9cclxuICBpc0NoaW5lc2VGb250KGZvbnROYW1lKSB7XHJcbiAgICBjb25zdCBjaGluZXNlSW5kaWNhdG9ycyA9IFtcclxuICAgICAgXCJzaW1zdW5cIixcclxuICAgICAgXCJzaW1oZWlcIixcclxuICAgICAgXCJtaWNyb3NvZnQgeWFoZWlcIixcclxuICAgICAgXCJzb25ndGlcIixcclxuICAgICAgXCJmYW5nc29uZ1wiLFxyXG4gICAgICBcInNjXCIsXHJcbiAgICAgIFwidGNcIixcclxuICAgIF07XHJcbiAgICByZXR1cm4gY2hpbmVzZUluZGljYXRvcnMuc29tZSgoaW5kaWNhdG9yKSA9PiBmb250TmFtZS5pbmNsdWRlcyhpbmRpY2F0b3IpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGZvbnQgaXMgc2VyaWZcclxuICAgKi9cclxuICBpc1NlcmlmRm9udChmb250TmFtZSkge1xyXG4gICAgY29uc3Qgc2VyaWZJbmRpY2F0b3JzID0gW1xyXG4gICAgICBcInNlcmlmXCIsXHJcbiAgICAgIFwidGltZXNcIixcclxuICAgICAgXCJtaW5pb25cIixcclxuICAgICAgXCJnZW9yZ2lhXCIsXHJcbiAgICAgIFwiZ2FyYW1vbmRcIixcclxuICAgICAgXCJiYXNrZXJ2aWxsZVwiLFxyXG4gICAgICBcImNhc2xvblwiLFxyXG4gICAgICBcIm1pbmNob1wiLFxyXG4gICAgICBcInNvbmd0aVwiLFxyXG4gICAgICBcImJvb2tcIixcclxuICAgIF07XHJcbiAgICByZXR1cm4gc2VyaWZJbmRpY2F0b3JzLnNvbWUoKGluZGljYXRvcikgPT4gZm9udE5hbWUuaW5jbHVkZXMoaW5kaWNhdG9yKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBmb250IGlzIG1vbm9zcGFjZVxyXG4gICAqL1xyXG4gIGlzTW9ub3NwYWNlRm9udChmb250TmFtZSkge1xyXG4gICAgY29uc3QgbW9ub3NwYWNlSW5kaWNhdG9ycyA9IFtcclxuICAgICAgXCJtb25vXCIsXHJcbiAgICAgIFwiY291cmllclwiLFxyXG4gICAgICBcImNvZGVcIixcclxuICAgICAgXCJjb25zb2xlXCIsXHJcbiAgICAgIFwidGVybWluYWxcIixcclxuICAgICAgXCJ0eXBld3JpdGVyXCIsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIG1vbm9zcGFjZUluZGljYXRvcnMuc29tZSgoaW5kaWNhdG9yKSA9PlxyXG4gICAgICBmb250TmFtZS5pbmNsdWRlcyhpbmRpY2F0b3IpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgZm9udCBpcyBnZW9tZXRyaWMgc2Fucy1zZXJpZlxyXG4gICAqL1xyXG4gIGlzR2VvbWV0cmljRm9udChmb250TmFtZSkge1xyXG4gICAgY29uc3QgZ2VvbWV0cmljSW5kaWNhdG9ycyA9IFtcclxuICAgICAgXCJmdXR1cmFcIixcclxuICAgICAgXCJhdmVuaXJcIixcclxuICAgICAgXCJudW5pdG9cIixcclxuICAgICAgXCJpbnRlclwiLFxyXG4gICAgICBcImNpcmN1bGFyXCIsXHJcbiAgICAgIFwiZ2VvbWV0cmljXCIsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGdlb21ldHJpY0luZGljYXRvcnMuc29tZSgoaW5kaWNhdG9yKSA9PlxyXG4gICAgICBmb250TmFtZS5pbmNsdWRlcyhpbmRpY2F0b3IpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgZm9udCBpcyBncm90ZXNxdWUgc2Fucy1zZXJpZlxyXG4gICAqL1xyXG4gIGlzR3JvdGVzcXVlRm9udChmb250TmFtZSkge1xyXG4gICAgY29uc3QgZ3JvdGVzcXVlSW5kaWNhdG9ycyA9IFtcclxuICAgICAgXCJoZWx2ZXRpY2FcIixcclxuICAgICAgXCJhcmlhbFwiLFxyXG4gICAgICBcInJvYm90b1wiLFxyXG4gICAgICBcIndvcmtcIixcclxuICAgICAgXCJmcmFua2xpblwiLFxyXG4gICAgICBcImFremlkZW56XCIsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGdyb3Rlc3F1ZUluZGljYXRvcnMuc29tZSgoaW5kaWNhdG9yKSA9PlxyXG4gICAgICBmb250TmFtZS5pbmNsdWRlcyhpbmRpY2F0b3IpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgZm9udCBpcyBkaXNwbGF5IHR5cGVcclxuICAgKi9cclxuICBpc0Rpc3BsYXlGb250KGZvbnROYW1lKSB7XHJcbiAgICBjb25zdCBkaXNwbGF5SW5kaWNhdG9ycyA9IFtcclxuICAgICAgXCJkaXNwbGF5XCIsXHJcbiAgICAgIFwidGl0bGVcIixcclxuICAgICAgXCJoZWFkbGluZVwiLFxyXG4gICAgICBcInBvc3RlclwiLFxyXG4gICAgICBcImJhbm5lclwiLFxyXG4gICAgICBcInBsYXlmYWlyXCIsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGRpc3BsYXlJbmRpY2F0b3JzLnNvbWUoKGluZGljYXRvcikgPT4gZm9udE5hbWUuaW5jbHVkZXMoaW5kaWNhdG9yKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBmb250IGlzIGNvbmRlbnNlZFxyXG4gICAqL1xyXG4gIGlzQ29uZGVuc2VkRm9udChmb250TmFtZSkge1xyXG4gICAgY29uc3QgY29uZGVuc2VkSW5kaWNhdG9ycyA9IFtcclxuICAgICAgXCJjb25kZW5zZWRcIixcclxuICAgICAgXCJjb21wcmVzc2VkXCIsXHJcbiAgICAgIFwibmFycm93XCIsXHJcbiAgICAgIFwiY29tcGFjdFwiLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBjb25kZW5zZWRJbmRpY2F0b3JzLnNvbWUoKGluZGljYXRvcikgPT5cclxuICAgICAgZm9udE5hbWUuaW5jbHVkZXMoaW5kaWNhdG9yKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3Qgd2VpZ2h0IGZyb20gZm9udCBzdHlsZVxyXG4gICAqL1xyXG4gIGV4dHJhY3RXZWlnaHQoZm9udFN0eWxlKSB7XHJcbiAgICBjb25zdCBzdHlsZSA9IChmb250U3R5bGUgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChzdHlsZS5pbmNsdWRlcyhcInRoaW5cIikpIHJldHVybiBcInRoaW5cIjtcclxuICAgIGlmIChzdHlsZS5pbmNsdWRlcyhcImxpZ2h0XCIpKSByZXR1cm4gXCJsaWdodFwiO1xyXG4gICAgaWYgKHN0eWxlLmluY2x1ZGVzKFwibWVkaXVtXCIpKSByZXR1cm4gXCJtZWRpdW1cIjtcclxuICAgIGlmIChzdHlsZS5pbmNsdWRlcyhcInNlbWlib2xkXCIpIHx8IHN0eWxlLmluY2x1ZGVzKFwic2VtaSBib2xkXCIpKVxyXG4gICAgICByZXR1cm4gXCJzZW1pYm9sZFwiO1xyXG4gICAgaWYgKHN0eWxlLmluY2x1ZGVzKFwiYm9sZFwiKSkgcmV0dXJuIFwiYm9sZFwiO1xyXG4gICAgaWYgKHN0eWxlLmluY2x1ZGVzKFwiYmxhY2tcIikgfHwgc3R5bGUuaW5jbHVkZXMoXCJoZWF2eVwiKSkgcmV0dXJuIFwiYmxhY2tcIjtcclxuICAgIHJldHVybiBcInJlZ3VsYXJcIjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3Qga2V5d29yZHMgZnJvbSBmb250IG5hbWUgZm9yIG1hdGNoaW5nXHJcbiAgICovXHJcbiAgZXh0cmFjdEtleXdvcmRzKGZvbnROYW1lKSB7XHJcbiAgICAvLyBSZW1vdmUgY29tbW9uIHN1ZmZpeGVzIGFuZCBzcGxpdCBpbnRvIHdvcmRzXHJcbiAgICBjb25zdCBjbGVhbmVkID0gZm9udE5hbWVcclxuICAgICAgLnJlcGxhY2UoXHJcbiAgICAgICAgL1xccysocHJvfHN0ZHxyZWd1bGFyfGJvbGR8aXRhbGljfGxpZ2h0fG1lZGl1bXxoZWF2eXxibGFja3xtdCkkL2dpLFxyXG4gICAgICAgIFwiXCJcclxuICAgICAgKVxyXG4gICAgICAucmVwbGFjZSgvW15cXHdcXHNdL2csIFwiIFwiKVxyXG4gICAgICAudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICByZXR1cm4gY2xlYW5lZC5zcGxpdCgvXFxzKy8pLmZpbHRlcigod29yZCkgPT4gd29yZC5sZW5ndGggPiAyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmQgYmVzdCBtYXRjaGluZyBOZXh0LmpzIGZvbnQgYmFzZWQgb24gYW5hbHlzaXNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gYW5hbHlzaXMgLSBGb250IGFuYWx5c2lzIHJlc3VsdFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5hbE5hbWUgLSBPcmlnaW5hbCBmb250IG5hbWUgZm9yIGxvZ2dpbmdcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBCZXN0IG1hdGNoaW5nIE5leHQuanMgZm9udCBjb25maWd1cmF0aW9uXHJcbiAgICovXHJcbiAgZmluZEJlc3ROZXh0SlNGb250KGFuYWx5c2lzLCBvcmlnaW5hbE5hbWUpIHtcclxuICAgIGxldCBjYW5kaWRhdGVzID0gW107XHJcblxyXG4gICAgLy8gR2V0IGZvbnQgY2F0ZWdvcnlcclxuICAgIGlmIChhbmFseXNpcy5sYW5ndWFnZSA9PT0gXCJqYXBhbmVzZVwiKSB7XHJcbiAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLm5leHRGb250RGF0YWJhc2UuamFwYW5lc2U7XHJcbiAgICB9IGVsc2UgaWYgKGFuYWx5c2lzLmxhbmd1YWdlID09PSBcImNoaW5lc2VcIikge1xyXG4gICAgICBjYW5kaWRhdGVzID0gdGhpcy5uZXh0Rm9udERhdGFiYXNlLmNoaW5lc2U7XHJcbiAgICB9IGVsc2UgaWYgKGFuYWx5c2lzLmNhdGVnb3J5ID09PSBcIm1vbm9zcGFjZVwiKSB7XHJcbiAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLm5leHRGb250RGF0YWJhc2UubW9ub3NwYWNlO1xyXG4gICAgfSBlbHNlIGlmIChhbmFseXNpcy5jYXRlZ29yeSA9PT0gXCJzZXJpZlwiKSB7XHJcbiAgICAgIGNvbnN0IHN1YmNhdGVnb3J5ID0gYW5hbHlzaXMuc3ViY2F0ZWdvcnkgfHwgXCJ0cmFkaXRpb25hbFwiO1xyXG4gICAgICBjYW5kaWRhdGVzID1cclxuICAgICAgICB0aGlzLm5leHRGb250RGF0YWJhc2Uuc2VyaWZbc3ViY2F0ZWdvcnldIHx8XHJcbiAgICAgICAgdGhpcy5uZXh0Rm9udERhdGFiYXNlLnNlcmlmLnRyYWRpdGlvbmFsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gc2Fucy1zZXJpZlxyXG4gICAgICBjb25zdCBzdWJjYXRlZ29yeSA9IGFuYWx5c2lzLnN1YmNhdGVnb3J5IHx8IFwiaHVtYW5pc3RcIjtcclxuICAgICAgY2FuZGlkYXRlcyA9XHJcbiAgICAgICAgdGhpcy5uZXh0Rm9udERhdGFiYXNlW1wic2Fucy1zZXJpZlwiXVtzdWJjYXRlZ29yeV0gfHxcclxuICAgICAgICB0aGlzLm5leHRGb250RGF0YWJhc2VbXCJzYW5zLXNlcmlmXCJdLmh1bWFuaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY2FuZGlkYXRlcyB8fCBjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIE5vIGNhbmRpZGF0ZXMgZm91bmQgZm9yICR7b3JpZ2luYWxOYW1lfSwgdXNpbmcgZGVmYXVsdGApO1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0Rm9udENvbmZpZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNjb3JlIGVhY2ggY2FuZGlkYXRlXHJcbiAgICBjb25zdCBzY29yZWRDYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5tYXAoKGZvbnQpID0+ICh7XHJcbiAgICAgIC4uLmZvbnQsXHJcbiAgICAgIHNjb3JlOiB0aGlzLmNhbGN1bGF0ZUZvbnRTY29yZShmb250LCBhbmFseXNpcywgb3JpZ2luYWxOYW1lKSxcclxuICAgIH0pKTtcclxuXHJcbiAgICAvLyBTb3J0IGJ5IHNjb3JlIChoaWdoZXN0IGZpcnN0KVxyXG4gICAgc2NvcmVkQ2FuZGlkYXRlcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XHJcblxyXG4gICAgY29uc3QgYmVzdE1hdGNoID0gc2NvcmVkQ2FuZGlkYXRlc1swXTtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBg8J+OryBCZXN0IG1hdGNoIGZvciBcIiR7b3JpZ2luYWxOYW1lfVwiOiAke1xyXG4gICAgICAgIGJlc3RNYXRjaC5mYW1pbHlcclxuICAgICAgfSAoc2NvcmU6ICR7YmVzdE1hdGNoLnNjb3JlLnRvRml4ZWQoMil9KWBcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIGJlc3RNYXRjaDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBtYXRjaGluZyBzY29yZSBiZXR3ZWVuIGZvbnQgYW5kIGFuYWx5c2lzXHJcbiAgICovXHJcbiAgY2FsY3VsYXRlRm9udFNjb3JlKGZvbnQsIGFuYWx5c2lzLCBvcmlnaW5hbE5hbWUpIHtcclxuICAgIGxldCBzY29yZSA9IDA7XHJcbiAgICBjb25zdCBsb3dlck9yaWdpbmFsID0gb3JpZ2luYWxOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gS2V5d29yZCBtYXRjaGluZyAoaGlnaCB3ZWlnaHQpXHJcbiAgICBjb25zdCBrZXl3b3JkTWF0Y2hlcyA9IGFuYWx5c2lzLmRldGVjdGVkS2V5d29yZHMuZmlsdGVyKChrZXl3b3JkKSA9PlxyXG4gICAgICBmb250LmtleXdvcmRzLnNvbWUoXHJcbiAgICAgICAgKGZvbnRLZXl3b3JkKSA9PlxyXG4gICAgICAgICAgZm9udEtleXdvcmQuaW5jbHVkZXMoa2V5d29yZCkgfHwga2V5d29yZC5pbmNsdWRlcyhmb250S2V5d29yZClcclxuICAgICAgKVxyXG4gICAgKTtcclxuICAgIHNjb3JlICs9IGtleXdvcmRNYXRjaGVzLmxlbmd0aCAqIDI7XHJcblxyXG4gICAgLy8gRXhhY3Qga2V5d29yZCBtYXRjaCAodmVyeSBoaWdoIHdlaWdodClcclxuICAgIGlmIChmb250LmtleXdvcmRzLnNvbWUoKGtleXdvcmQpID0+IGxvd2VyT3JpZ2luYWwuaW5jbHVkZXMoa2V5d29yZCkpKSB7XHJcbiAgICAgIHNjb3JlICs9IDU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmFtaWx5IG5hbWUgc2ltaWxhcml0eVxyXG4gICAgaWYgKGxvd2VyT3JpZ2luYWwuaW5jbHVkZXMoZm9udC5mYW1pbHkudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIilbMF0pKSB7XHJcbiAgICAgIHNjb3JlICs9IDM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hhcmFjdGVyaXN0aWNzIG1hdGNoaW5nXHJcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY01hdGNoZXMgPSBmb250LmNoYXJhY3RlcmlzdGljcy5maWx0ZXIoXHJcbiAgICAgIChjaGFyKSA9PlxyXG4gICAgICAgIGFuYWx5c2lzLmRldGVjdGVkS2V5d29yZHMuaW5jbHVkZXMoY2hhcikgfHwgbG93ZXJPcmlnaW5hbC5pbmNsdWRlcyhjaGFyKVxyXG4gICAgKTtcclxuICAgIHNjb3JlICs9IGNoYXJhY3RlcmlzdGljTWF0Y2hlcy5sZW5ndGggKiAxO1xyXG5cclxuICAgIC8vIFdlaWdodCBhdmFpbGFiaWxpdHlcclxuICAgIGNvbnN0IHRhcmdldFdlaWdodCA9IHRoaXMubWFwRm9udFdlaWdodChhbmFseXNpcy53ZWlnaHQsIGZvbnQud2VpZ2h0cyk7XHJcbiAgICBpZiAoZm9udC53ZWlnaHRzLmluY2x1ZGVzKHRhcmdldFdlaWdodCkpIHtcclxuICAgICAgc2NvcmUgKz0gMC41O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BsYXkgZm9udCBwcmVmZXJlbmNlXHJcbiAgICBpZiAoYW5hbHlzaXMuaXNEaXNwbGF5ICYmIGZvbnQuY2hhcmFjdGVyaXN0aWNzLmluY2x1ZGVzKFwiZGlzcGxheVwiKSkge1xyXG4gICAgICBzY29yZSArPSAyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzY29yZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkIGZpbmFsIGZvbnQgY29uZmlndXJhdGlvblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb250Q29uZmlnIC0gTmV4dC5qcyBmb250IGNvbmZpZ3VyYXRpb25cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udFN0eWxlIC0gT3JpZ2luYWwgZm9udCBzdHlsZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmb250U2l6ZSAtIEZvbnQgc2l6ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5hbEZhbWlseSAtIE9yaWdpbmFsIGZvbnQgZmFtaWx5IG5hbWVcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBDb21wbGV0ZSBmb250IGNvbmZpZ3VyYXRpb25cclxuICAgKi9cclxuICBidWlsZEZvbnRDb25maWcoZm9udENvbmZpZywgZm9udFN0eWxlLCBmb250U2l6ZSwgb3JpZ2luYWxGYW1pbHkpIHtcclxuICAgIC8vIFNhZmV0eSBjaGVja1xyXG4gICAgaWYgKCFmb250Q29uZmlnKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLimqDvuI8gYnVpbGRGb250Q29uZmlnIHJlY2VpdmVkIG51bGwvdW5kZWZpbmVkIGZvbnRDb25maWdcIik7XHJcbiAgICAgIGZvbnRDb25maWcgPSB0aGlzLmdldERlZmF1bHRGb250Q29uZmlnKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgd2VpZ2h0ID0gdGhpcy5tYXBGb250V2VpZ2h0KGZvbnRTdHlsZSwgZm9udENvbmZpZy53ZWlnaHRzKTtcclxuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5tYXBGb250U3R5bGUoZm9udFN0eWxlKTtcclxuXHJcbiAgICAvLyBFTkhBTkNFRDogRXh0cmFjdCBjb21wbGV0ZSBzdHlsZSBhbmFseXNpc1xyXG4gICAgY29uc3Qgc3R5bGVBbmFseXNpcyA9IHRoaXMuYW5hbHl6ZUNvbXBsZXhGb250U3R5bGUoZm9udFN0eWxlKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyBOZXh0LmpzIHNwZWNpZmljXHJcbiAgICAgIG5leHRGb250OiBmb250Q29uZmlnLm5leHRGb250LFxyXG4gICAgICBuZXh0Rm9udFZhcmlhYmxlOiBgLS1mb250LSR7Zm9udENvbmZpZy5uZXh0Rm9udC50b0xvd2VyQ2FzZSgpfWAsXHJcblxyXG4gICAgICAvLyBDU1MgcHJvcGVydGllc1xyXG4gICAgICBmb250RmFtaWx5OiBmb250Q29uZmlnLmZhbWlseSxcclxuICAgICAgZm9udFNpemU6IGAke2ZvbnRTaXplfXB4YCxcclxuICAgICAgZm9udFdlaWdodDogd2VpZ2h0LFxyXG4gICAgICBmb250U3R5bGU6IHN0eWxlLFxyXG5cclxuICAgICAgLy8gRU5IQU5DRUQ6IENvbXBsZXRlIHN0eWxlIGluZm9ybWF0aW9uXHJcbiAgICAgIGNvbXBsZXRlU3R5bGU6IHtcclxuICAgICAgICB3ZWlnaHQ6IHdlaWdodCxcclxuICAgICAgICBzdHlsZTogc3R5bGUsXHJcbiAgICAgICAgaXNJdGFsaWM6IHN0eWxlQW5hbHlzaXMuaXNJdGFsaWMsXHJcbiAgICAgICAgaXNCb2xkOiBzdHlsZUFuYWx5c2lzLmlzQm9sZCxcclxuICAgICAgICBvcmlnaW5hbFN0eWxlOiBmb250U3R5bGUsXHJcbiAgICAgICAgY29tcGxleFN0eWxlOiBzdHlsZUFuYWx5c2lzLmNvbXBsZXhTdHlsZSxcclxuXHJcbiAgICAgICAgLy8gQ1NTIGNsYXNzIHN1Z2dlc3Rpb25zXHJcbiAgICAgICAgY3NzQ2xhc3NlczogdGhpcy5nZW5lcmF0ZUNTU0NsYXNzZXMoc3R5bGVBbmFseXNpcyksXHJcblxyXG4gICAgICAgIC8vIE11bHRpcGxlIHdlaWdodHMgZm9yIE5leHQuanMgZm9udCBsb2FkaW5nXHJcbiAgICAgICAgcmVxdWlyZWRXZWlnaHRzOiB0aGlzLmdldFJlcXVpcmVkV2VpZ2h0cyhcclxuICAgICAgICAgIHN0eWxlQW5hbHlzaXMsXHJcbiAgICAgICAgICBmb250Q29uZmlnLndlaWdodHNcclxuICAgICAgICApLFxyXG4gICAgICAgIHJlcXVpcmVkU3R5bGVzOiB0aGlzLmdldFJlcXVpcmVkU3R5bGVzKHN0eWxlQW5hbHlzaXMpLFxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gRmFsbGJhY2sgY2hhaW5cclxuICAgICAgZm9udEZhbWlseUZhbGxiYWNrOiBbXHJcbiAgICAgICAgZm9udENvbmZpZy5mYW1pbHksXHJcbiAgICAgICAgXCJzeXN0ZW0tdWlcIixcclxuICAgICAgICBcIi1hcHBsZS1zeXN0ZW1cIixcclxuICAgICAgICBcInNhbnMtc2VyaWZcIixcclxuICAgICAgXS5qb2luKFwiLCBcIiksXHJcblxyXG4gICAgICAvLyBNZXRhZGF0YVxyXG4gICAgICBjYXRlZ29yeTogZm9udENvbmZpZy5jaGFyYWN0ZXJpc3RpY3NcclxuICAgICAgICA/IGZvbnRDb25maWcuY2hhcmFjdGVyaXN0aWNzWzBdXHJcbiAgICAgICAgOiBcInNhbnMtc2VyaWZcIixcclxuICAgICAgaXNHb29nbGVGb250OiBmb250Q29uZmlnLmdvb2dsZUZvbnQgfHwgZmFsc2UsXHJcbiAgICAgIGlzU3lzdGVtRm9udDogZm9udENvbmZpZy5zeXN0ZW1Gb250IHx8IGZhbHNlLFxyXG5cclxuICAgICAgLy8gT3JpZ2luYWwgdmFsdWVzXHJcbiAgICAgIG9yaWdpbmFsRmFtaWx5OiBvcmlnaW5hbEZhbWlseSxcclxuICAgICAgb3JpZ2luYWxTdHlsZTogZm9udFN0eWxlLFxyXG4gICAgICBvcmlnaW5hbFNpemU6IGZvbnRTaXplLFxyXG5cclxuICAgICAgLy8gTWFwcGluZyBpbmZvXHJcbiAgICAgIG1hcHBpbmdDb25maWRlbmNlOiBmb250Q29uZmlnLnNjb3JlIHx8IDAsXHJcbiAgICAgIG1hcHBpbmdSZWFzb246IHRoaXMuZ2VuZXJhdGVNYXBwaW5nUmVhc29uKGZvbnRDb25maWcsIG9yaWdpbmFsRmFtaWx5KSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbmFseXplIGNvbXBsZXggZm9udCBzdHlsZXMgbGlrZSBcIkJvbGQgSXRhbGljXCIsIFwiU2VtaWJvbGQgQ29uZGVuc2VkXCIsIGV0Yy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udFN0eWxlIC0gRm9udCBzdHlsZSBzdHJpbmdcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBTdHlsZSBhbmFseXNpcyByZXN1bHRcclxuICAgKi9cclxuICBhbmFseXplQ29tcGxleEZvbnRTdHlsZShmb250U3R5bGUpIHtcclxuICAgIGlmICghZm9udFN0eWxlKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNCb2xkOiBmYWxzZSxcclxuICAgICAgICBpc0l0YWxpYzogZmFsc2UsXHJcbiAgICAgICAgY29tcGxleFN0eWxlOiBcInJlZ3VsYXJcIixcclxuICAgICAgICB3ZWlnaHQ6IFwiNDAwXCIsXHJcbiAgICAgICAgc3R5bGU6IFwibm9ybWFsXCIsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3R5bGUgPSBmb250U3R5bGUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBjb25zdCBhbmFseXNpcyA9IHtcclxuICAgICAgaXNCb2xkOiBzdHlsZS5pbmNsdWRlcyhcImJvbGRcIiksXHJcbiAgICAgIGlzSXRhbGljOiBzdHlsZS5pbmNsdWRlcyhcIml0YWxpY1wiKSB8fCBzdHlsZS5pbmNsdWRlcyhcIm9ibGlxdWVcIiksXHJcbiAgICAgIGlzTGlnaHQ6IHN0eWxlLmluY2x1ZGVzKFwibGlnaHRcIiksXHJcbiAgICAgIGlzTWVkaXVtOiBzdHlsZS5pbmNsdWRlcyhcIm1lZGl1bVwiKSxcclxuICAgICAgaXNTZW1pYm9sZDogc3R5bGUuaW5jbHVkZXMoXCJzZW1pYm9sZFwiKSB8fCBzdHlsZS5pbmNsdWRlcyhcImRlbWlib2xkXCIpLFxyXG4gICAgICBpc0JsYWNrOiBzdHlsZS5pbmNsdWRlcyhcImJsYWNrXCIpIHx8IHN0eWxlLmluY2x1ZGVzKFwiaGVhdnlcIiksXHJcbiAgICAgIGlzQ29uZGVuc2VkOiBzdHlsZS5pbmNsdWRlcyhcImNvbmRlbnNlZFwiKSB8fCBzdHlsZS5pbmNsdWRlcyhcImNvbXByZXNzZWRcIiksXHJcbiAgICAgIG9yaWdpbmFsU3R5bGU6IGZvbnRTdHlsZSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGNvbXBsZXggc3R5bGUgZGVzY3JpcHRpb25cclxuICAgIGxldCBjb21wbGV4U3R5bGUgPSBcInJlZ3VsYXJcIjtcclxuICAgIGlmIChhbmFseXNpcy5pc0JvbGQgJiYgYW5hbHlzaXMuaXNJdGFsaWMpIHtcclxuICAgICAgY29tcGxleFN0eWxlID0gXCJib2xkLWl0YWxpY1wiO1xyXG4gICAgfSBlbHNlIGlmIChhbmFseXNpcy5pc0JvbGQpIHtcclxuICAgICAgY29tcGxleFN0eWxlID0gXCJib2xkXCI7XHJcbiAgICB9IGVsc2UgaWYgKGFuYWx5c2lzLmlzSXRhbGljKSB7XHJcbiAgICAgIGNvbXBsZXhTdHlsZSA9IFwiaXRhbGljXCI7XHJcbiAgICB9IGVsc2UgaWYgKGFuYWx5c2lzLmlzU2VtaWJvbGQpIHtcclxuICAgICAgY29tcGxleFN0eWxlID0gYW5hbHlzaXMuaXNJdGFsaWMgPyBcInNlbWlib2xkLWl0YWxpY1wiIDogXCJzZW1pYm9sZFwiO1xyXG4gICAgfSBlbHNlIGlmIChhbmFseXNpcy5pc0xpZ2h0KSB7XHJcbiAgICAgIGNvbXBsZXhTdHlsZSA9IGFuYWx5c2lzLmlzSXRhbGljID8gXCJsaWdodC1pdGFsaWNcIiA6IFwibGlnaHRcIjtcclxuICAgIH0gZWxzZSBpZiAoYW5hbHlzaXMuaXNNZWRpdW0pIHtcclxuICAgICAgY29tcGxleFN0eWxlID0gYW5hbHlzaXMuaXNJdGFsaWMgPyBcIm1lZGl1bS1pdGFsaWNcIiA6IFwibWVkaXVtXCI7XHJcbiAgICB9IGVsc2UgaWYgKGFuYWx5c2lzLmlzQmxhY2spIHtcclxuICAgICAgY29tcGxleFN0eWxlID0gYW5hbHlzaXMuaXNJdGFsaWMgPyBcImJsYWNrLWl0YWxpY1wiIDogXCJibGFja1wiO1xyXG4gICAgfVxyXG5cclxuICAgIGFuYWx5c2lzLmNvbXBsZXhTdHlsZSA9IGNvbXBsZXhTdHlsZTtcclxuICAgIGFuYWx5c2lzLndlaWdodCA9IHRoaXMuZXh0cmFjdFdlaWdodChmb250U3R5bGUpO1xyXG4gICAgYW5hbHlzaXMuc3R5bGUgPSBhbmFseXNpcy5pc0l0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xyXG5cclxuICAgIHJldHVybiBhbmFseXNpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIENTUyBjbGFzc2VzIGZvciBzdHlsaW5nXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlQW5hbHlzaXMgLSBTdHlsZSBhbmFseXNpcyByZXN1bHRcclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IENTUyBjbGFzcyBzdWdnZXN0aW9uc1xyXG4gICAqL1xyXG4gIGdlbmVyYXRlQ1NTQ2xhc3NlcyhzdHlsZUFuYWx5c2lzKSB7XHJcbiAgICBjb25zdCBjbGFzc2VzID0gW107XHJcblxyXG4gICAgaWYgKHN0eWxlQW5hbHlzaXMuaXNCb2xkKSBjbGFzc2VzLnB1c2goXCJmb250LWJvbGRcIik7XHJcbiAgICBlbHNlIGlmIChzdHlsZUFuYWx5c2lzLmlzU2VtaWJvbGQpIGNsYXNzZXMucHVzaChcImZvbnQtc2VtaWJvbGRcIik7XHJcbiAgICBlbHNlIGlmIChzdHlsZUFuYWx5c2lzLmlzTWVkaXVtKSBjbGFzc2VzLnB1c2goXCJmb250LW1lZGl1bVwiKTtcclxuICAgIGVsc2UgaWYgKHN0eWxlQW5hbHlzaXMuaXNMaWdodCkgY2xhc3Nlcy5wdXNoKFwiZm9udC1saWdodFwiKTtcclxuICAgIGVsc2UgY2xhc3Nlcy5wdXNoKFwiZm9udC1ub3JtYWxcIik7XHJcblxyXG4gICAgaWYgKHN0eWxlQW5hbHlzaXMuaXNJdGFsaWMpIGNsYXNzZXMucHVzaChcIml0YWxpY1wiKTtcclxuXHJcbiAgICByZXR1cm4gY2xhc3NlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCByZXF1aXJlZCB3ZWlnaHRzIGZvciBOZXh0LmpzIGZvbnQgbG9hZGluZ1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZUFuYWx5c2lzIC0gU3R5bGUgYW5hbHlzaXMgcmVzdWx0XHJcbiAgICogQHBhcmFtIHtBcnJheX0gYXZhaWxhYmxlV2VpZ2h0cyAtIEF2YWlsYWJsZSB3ZWlnaHRzXHJcbiAgICogQHJldHVybnMge0FycmF5fSBSZXF1aXJlZCB3ZWlnaHRzXHJcbiAgICovXHJcbiAgZ2V0UmVxdWlyZWRXZWlnaHRzKHN0eWxlQW5hbHlzaXMsIGF2YWlsYWJsZVdlaWdodHMpIHtcclxuICAgIGNvbnN0IHdlaWdodHMgPSBbXCI0MDBcIl07IC8vIEFsd2F5cyBpbmNsdWRlIG5vcm1hbFxyXG5cclxuICAgIGlmIChzdHlsZUFuYWx5c2lzLmlzQm9sZCAmJiBhdmFpbGFibGVXZWlnaHRzLmluY2x1ZGVzKFwiNzAwXCIpKSB7XHJcbiAgICAgIHdlaWdodHMucHVzaChcIjcwMFwiKTtcclxuICAgIH1cclxuICAgIGlmIChzdHlsZUFuYWx5c2lzLmlzU2VtaWJvbGQgJiYgYXZhaWxhYmxlV2VpZ2h0cy5pbmNsdWRlcyhcIjYwMFwiKSkge1xyXG4gICAgICB3ZWlnaHRzLnB1c2goXCI2MDBcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoc3R5bGVBbmFseXNpcy5pc01lZGl1bSAmJiBhdmFpbGFibGVXZWlnaHRzLmluY2x1ZGVzKFwiNTAwXCIpKSB7XHJcbiAgICAgIHdlaWdodHMucHVzaChcIjUwMFwiKTtcclxuICAgIH1cclxuICAgIGlmIChzdHlsZUFuYWx5c2lzLmlzTGlnaHQgJiYgYXZhaWxhYmxlV2VpZ2h0cy5pbmNsdWRlcyhcIjMwMFwiKSkge1xyXG4gICAgICB3ZWlnaHRzLnB1c2goXCIzMDBcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoc3R5bGVBbmFseXNpcy5pc0JsYWNrICYmIGF2YWlsYWJsZVdlaWdodHMuaW5jbHVkZXMoXCI5MDBcIikpIHtcclxuICAgICAgd2VpZ2h0cy5wdXNoKFwiOTAwXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbLi4ubmV3IFNldCh3ZWlnaHRzKV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgcmVxdWlyZWQgc3R5bGVzIGZvciBOZXh0LmpzIGZvbnQgbG9hZGluZ1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZUFuYWx5c2lzIC0gU3R5bGUgYW5hbHlzaXMgcmVzdWx0XHJcbiAgICogQHJldHVybnMge0FycmF5fSBSZXF1aXJlZCBzdHlsZXNcclxuICAgKi9cclxuICBnZXRSZXF1aXJlZFN0eWxlcyhzdHlsZUFuYWx5c2lzKSB7XHJcbiAgICBjb25zdCBzdHlsZXMgPSBbXCJub3JtYWxcIl07XHJcblxyXG4gICAgaWYgKHN0eWxlQW5hbHlzaXMuaXNJdGFsaWMpIHtcclxuICAgICAgc3R5bGVzLnB1c2goXCJpdGFsaWNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0eWxlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGV4cGxhbmF0aW9uIGZvciB3aHkgdGhpcyBmb250IHdhcyBjaG9zZW5cclxuICAgKi9cclxuICBnZW5lcmF0ZU1hcHBpbmdSZWFzb24oZm9udENvbmZpZywgb3JpZ2luYWxGYW1pbHkpIHtcclxuICAgIGNvbnN0IHJlYXNvbnMgPSBbXTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIGZvbnRDb25maWcua2V5d29yZHMgJiZcclxuICAgICAgZm9udENvbmZpZy5rZXl3b3Jkcy5zb21lKChrKSA9PiBvcmlnaW5hbEZhbWlseS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGspKVxyXG4gICAgKSB7XHJcbiAgICAgIHJlYXNvbnMucHVzaChcImtleXdvcmQgbWF0Y2hcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZvbnRDb25maWcuY2hhcmFjdGVyaXN0aWNzKSB7XHJcbiAgICAgIHJlYXNvbnMucHVzaChgJHtmb250Q29uZmlnLmNoYXJhY3RlcmlzdGljc1swXX0gY2hhcmFjdGVyaXN0aWNzYCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZvbnRDb25maWcuZ29vZ2xlRm9udCkge1xyXG4gICAgICByZWFzb25zLnB1c2goXCJHb29nbGUgRm9udCBhdmFpbGFiaWxpdHlcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlYXNvbnMubGVuZ3RoID4gMCA/IHJlYXNvbnMuam9pbihcIiwgXCIpIDogXCJjYXRlZ29yeSBmYWxsYmFja1wiO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWFwIEluRGVzaWduIGZvbnQgc3R5bGUgdG8gQ1NTIGZvbnQgd2VpZ2h0XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTdHlsZSAtIEluRGVzaWduIGZvbnQgc3R5bGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhdmFpbGFibGVXZWlnaHRzIC0gQXZhaWxhYmxlIHdlaWdodHMgZm9yIGZvbnRcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDU1MgZm9udCB3ZWlnaHRcclxuICAgKi9cclxuICBtYXBGb250V2VpZ2h0KGZvbnRTdHlsZSwgYXZhaWxhYmxlV2VpZ2h0cyA9IFtcIjQwMFwiXSkge1xyXG4gICAgY29uc3Qgc3R5bGUgPSAoZm9udFN0eWxlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gV2VpZ2h0IG1hcHBpbmdcclxuICAgIGNvbnN0IHdlaWdodE1hcCA9IHtcclxuICAgICAgdGhpbjogXCIxMDBcIixcclxuICAgICAgZXh0cmFsaWdodDogXCIyMDBcIixcclxuICAgICAgbGlnaHQ6IFwiMzAwXCIsXHJcbiAgICAgIHJlZ3VsYXI6IFwiNDAwXCIsXHJcbiAgICAgIG5vcm1hbDogXCI0MDBcIixcclxuICAgICAgbWVkaXVtOiBcIjUwMFwiLFxyXG4gICAgICBzZW1pYm9sZDogXCI2MDBcIixcclxuICAgICAgYm9sZDogXCI3MDBcIixcclxuICAgICAgZXh0cmFib2xkOiBcIjgwMFwiLFxyXG4gICAgICBibGFjazogXCI5MDBcIixcclxuICAgICAgaGVhdnk6IFwiOTAwXCIsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENoZWNrIGZvciB3ZWlnaHQga2V5d29yZHMgaW4gc3R5bGVcclxuICAgIGZvciAoY29uc3QgW2tleXdvcmQsIHdlaWdodF0gb2YgT2JqZWN0LmVudHJpZXMod2VpZ2h0TWFwKSkge1xyXG4gICAgICBpZiAoc3R5bGUuaW5jbHVkZXMoa2V5d29yZCkpIHtcclxuICAgICAgICAvLyBFbnN1cmUgdGhlIHdlaWdodCBpcyBhdmFpbGFibGVcclxuICAgICAgICByZXR1cm4gYXZhaWxhYmxlV2VpZ2h0cy5pbmNsdWRlcyh3ZWlnaHQpXHJcbiAgICAgICAgICA/IHdlaWdodFxyXG4gICAgICAgICAgOiBhdmFpbGFibGVXZWlnaHRzLmluY2x1ZGVzKFwiNDAwXCIpXHJcbiAgICAgICAgICA/IFwiNDAwXCJcclxuICAgICAgICAgIDogYXZhaWxhYmxlV2VpZ2h0c1swXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgdG8gbm9ybWFsIHdlaWdodFxyXG4gICAgcmV0dXJuIGF2YWlsYWJsZVdlaWdodHMuaW5jbHVkZXMoXCI0MDBcIikgPyBcIjQwMFwiIDogYXZhaWxhYmxlV2VpZ2h0c1swXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcCBJbkRlc2lnbiBmb250IHN0eWxlIHRvIENTUyBmb250IHN0eWxlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTdHlsZSAtIEluRGVzaWduIGZvbnQgc3R5bGVcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDU1MgZm9udCBzdHlsZVxyXG4gICAqL1xyXG4gIG1hcEZvbnRTdHlsZShmb250U3R5bGUpIHtcclxuICAgIGNvbnN0IHN0eWxlID0gKGZvbnRTdHlsZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIGlmIChzdHlsZS5pbmNsdWRlcyhcIml0YWxpY1wiKSB8fCBzdHlsZS5pbmNsdWRlcyhcIm9ibGlxdWVcIikpIHtcclxuICAgICAgcmV0dXJuIFwiaXRhbGljXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFwibm9ybWFsXCI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgZGVmYXVsdCBmYWxsYmFjayBmb250IGNvbmZpZ3VyYXRpb25cclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBEZWZhdWx0IGZvbnQgY29uZmlndXJhdGlvblxyXG4gICAqL1xyXG4gIGdldERlZmF1bHRGb250Q29uZmlnKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubmV4dEZvbnREYXRhYmFzZVtcInNhbnMtc2VyaWZcIl0uaHVtYW5pc3RbMF07IC8vIEludGVyXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgZGVmYXVsdCBmYWxsYmFjayBmb250XHJcbiAgICogQHJldHVybnMge09iamVjdH0gRGVmYXVsdCBmb250IGNvbmZpZ3VyYXRpb25cclxuICAgKi9cclxuICBnZXREZWZhdWx0Rm9udCgpIHtcclxuICAgIHJldHVybiB0aGlzLmJ1aWxkRm9udENvbmZpZyhcclxuICAgICAgdGhpcy5nZXREZWZhdWx0Rm9udENvbmZpZygpLFxyXG4gICAgICBcIlJlZ3VsYXJcIixcclxuICAgICAgMTYsXHJcbiAgICAgIFwiRGVmYXVsdCBGb250XCJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBOZXh0LmpzIGZvbnQgaW1wb3J0cyBjb2RlXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gSW1wb3J0IHN0YXRlbWVudHMgZm9yIGZvbnRzXHJcbiAgICovXHJcbiAgZ2VuZXJhdGVOZXh0Rm9udEltcG9ydHMoKSB7XHJcbiAgICBjb25zdCBpbXBvcnRzID0gQXJyYXkuZnJvbSh0aGlzLm5leHRGb250SW1wb3J0cykubWFwKChmb250TmFtZSkgPT4ge1xyXG4gICAgICByZXR1cm4gYGltcG9ydCB7ICR7Zm9udE5hbWV9IH0gZnJvbSAnbmV4dC9mb250L2dvb2dsZSc7YDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBpbXBvcnRzLmpvaW4oXCJcXG5cIik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBOZXh0LmpzIGZvbnQgdmFyaWFibGUgZGVmaW5pdGlvbnNcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBGb250IHZhcmlhYmxlIGRlZmluaXRpb25zXHJcbiAgICovXHJcbiAgZ2VuZXJhdGVGb250VmFyaWFibGVzKCkge1xyXG4gICAgY29uc3QgdmFyaWFibGVzID0gQXJyYXkuZnJvbSh0aGlzLm5leHRGb250SW1wb3J0cykubWFwKChmb250TmFtZSkgPT4ge1xyXG4gICAgICAvLyBGaW5kIGZvbnQgY29uZmlnIGZvciB3ZWlnaHRzIGFuZCBzdHlsZXNcclxuICAgICAgY29uc3QgZm9udENvbmZpZyA9IHRoaXMuZmluZEZvbnRDb25maWdCeU5leHRGb250KGZvbnROYW1lKTtcclxuXHJcbiAgICAgIC8vIEVOSEFOQ0VEOiBDb2xsZWN0IGFsbCByZXF1aXJlZCB3ZWlnaHRzIGFuZCBzdHlsZXMgZnJvbSBtYXBwZWQgZm9udHNcclxuICAgICAgY29uc3QgYWxsUmVxdWlyZWRXZWlnaHRzID0gbmV3IFNldChbXCI0MDBcIl0pOyAvLyBBbHdheXMgaW5jbHVkZSBub3JtYWxcclxuICAgICAgY29uc3QgYWxsUmVxdWlyZWRTdHlsZXMgPSBuZXcgU2V0KFtcIm5vcm1hbFwiXSk7IC8vIEFsd2F5cyBpbmNsdWRlIG5vcm1hbFxyXG5cclxuICAgICAgLy8gQ2hlY2sgYWxsIGNhY2hlZCBmb250cyBmb3IgdGhpcyBOZXh0LmpzIGZvbnQgdG8gc2VlIHdoYXQgd2VpZ2h0cy9zdHlsZXMgYXJlIG5lZWRlZFxyXG4gICAgICBmb3IgKGNvbnN0IFtjYWNoZUtleSwgY2FjaGVkRm9udF0gb2YgdGhpcy5mb250Q2FjaGUuZW50cmllcygpKSB7XHJcbiAgICAgICAgaWYgKGNhY2hlZEZvbnQubmV4dEZvbnQgPT09IGZvbnROYW1lKSB7XHJcbiAgICAgICAgICBpZiAoY2FjaGVkRm9udC5jb21wbGV0ZVN0eWxlPy5yZXF1aXJlZFdlaWdodHMpIHtcclxuICAgICAgICAgICAgY2FjaGVkRm9udC5jb21wbGV0ZVN0eWxlLnJlcXVpcmVkV2VpZ2h0cy5mb3JFYWNoKCh3KSA9PlxyXG4gICAgICAgICAgICAgIGFsbFJlcXVpcmVkV2VpZ2h0cy5hZGQodylcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChjYWNoZWRGb250LmNvbXBsZXRlU3R5bGU/LnJlcXVpcmVkU3R5bGVzKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZEZvbnQuY29tcGxldGVTdHlsZS5yZXF1aXJlZFN0eWxlcy5mb3JFYWNoKChzKSA9PlxyXG4gICAgICAgICAgICAgIGFsbFJlcXVpcmVkU3R5bGVzLmFkZChzKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgd2VpZ2h0cyA9IEFycmF5LmZyb20oYWxsUmVxdWlyZWRXZWlnaHRzKS5maWx0ZXIoKHcpID0+XHJcbiAgICAgICAgZm9udENvbmZpZy53ZWlnaHRzLmluY2x1ZGVzKHcpXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHN0eWxlcyA9IEFycmF5LmZyb20oYWxsUmVxdWlyZWRTdHlsZXMpLmZpbHRlcigocykgPT5cclxuICAgICAgICBmb250Q29uZmlnLnN0eWxlcy5pbmNsdWRlcyhzKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIGBjb25zdCAke2ZvbnROYW1lLnRvTG93ZXJDYXNlKCl9ID0gJHtmb250TmFtZX0oe1xyXG4gIHdlaWdodDogWyR7d2VpZ2h0cy5tYXAoKHcpID0+IGAnJHt3fSdgKS5qb2luKFwiLCBcIil9XSxcclxuICBzdHlsZTogWyR7c3R5bGVzLm1hcCgocykgPT4gYCcke3N9J2ApLmpvaW4oXCIsIFwiKX1dLFxyXG4gIHN1YnNldHM6IFsnbGF0aW4nXSxcclxuICB2YXJpYWJsZTogJy0tZm9udC0ke2ZvbnROYW1lLnRvTG93ZXJDYXNlKCl9JyxcclxuICBkaXNwbGF5OiAnc3dhcCcgLy8gT3B0aW1pemUgbG9hZGluZ1xyXG59KTtgO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHZhcmlhYmxlcy5qb2luKFwiXFxuXFxuXCIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZCBmb250IGNvbmZpZyBieSBOZXh0LmpzIGZvbnQgbmFtZVxyXG4gICAqL1xyXG4gIGZpbmRGb250Q29uZmlnQnlOZXh0Rm9udChuZXh0Rm9udE5hbWUpIHtcclxuICAgIC8vIFNlYXJjaCB0aHJvdWdoIGFsbCBjYXRlZ29yaWVzXHJcbiAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIE9iamVjdC52YWx1ZXModGhpcy5uZXh0Rm9udERhdGFiYXNlKSkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjYXRlZ29yeSkpIHtcclxuICAgICAgICBjb25zdCBmb3VuZCA9IGNhdGVnb3J5LmZpbmQoKGYpID0+IGYubmV4dEZvbnQgPT09IG5leHRGb250TmFtZSk7XHJcbiAgICAgICAgaWYgKGZvdW5kKSByZXR1cm4gZm91bmQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBzdWJjYXRlZ29yeSBvZiBPYmplY3QudmFsdWVzKGNhdGVnb3J5KSkge1xyXG4gICAgICAgICAgY29uc3QgZm91bmQgPSBzdWJjYXRlZ29yeS5maW5kKChmKSA9PiBmLm5leHRGb250ID09PSBuZXh0Rm9udE5hbWUpO1xyXG4gICAgICAgICAgaWYgKGZvdW5kKSByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmYXVsdCBmYWxsYmFja1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdEZvbnRDb25maWcoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgdW5pcXVlIGZvbnRzIHVzZWQgaW4gYSBkb2N1bWVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkb2N1bWVudERhdGEgLSBQcm9jZXNzZWQgSURNTCBkb2N1bWVudCBkYXRhXHJcbiAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBmb250IGNvbmZpZ3VyYXRpb25zXHJcbiAgICovXHJcbiAgZXh0cmFjdERvY3VtZW50Rm9udHMoZG9jdW1lbnREYXRhKSB7XHJcbiAgICBjb25zdCB1c2VkRm9udHMgPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBmb250Q29uZmlncyA9IFtdO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwi8J+UjSBFeHRyYWN0aW5nIGZvbnRzIGZyb20gZG9jdW1lbnQgZGF0YS4uLlwiKTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IGZvbnRzIGZyb20gc3Rvcmllc1xyXG4gICAgaWYgKGRvY3VtZW50RGF0YS5zdG9yaWVzKSB7XHJcbiAgICAgIE9iamVjdC52YWx1ZXMoZG9jdW1lbnREYXRhLnN0b3JpZXMpLmZvckVhY2goKHN0b3J5KSA9PiB7XHJcbiAgICAgICAgaWYgKHN0b3J5LmNvbnRlbnQgJiYgc3RvcnkuY29udGVudC5mb3JtYXR0ZWRDb250ZW50KSB7XHJcbiAgICAgICAgICBzdG9yeS5jb250ZW50LmZvcm1hdHRlZENvbnRlbnQuZm9yRWFjaCgoc2VnbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5mb3JtYXR0aW5nICYmIHNlZ21lbnQuZm9ybWF0dGluZy5mb250RmFtaWx5KSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7c2VnbWVudC5mb3JtYXR0aW5nLmZvbnRGYW1pbHl9LSR7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50LmZvcm1hdHRpbmcuZm9udFN0eWxlIHx8IFwiUmVndWxhclwiXHJcbiAgICAgICAgICAgICAgfWA7XHJcbiAgICAgICAgICAgICAgaWYgKCF1c2VkRm9udHMuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHVzZWRGb250cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMubWFwVG9OZXh0Rm9udChcclxuICAgICAgICAgICAgICAgICAgc2VnbWVudC5mb3JtYXR0aW5nLmZvbnRGYW1pbHksXHJcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQuZm9ybWF0dGluZy5mb250U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQuZm9ybWF0dGluZy5mb250U2l6ZSB8fCAxNlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGZvbnRDb25maWdzLnB1c2goY29uZmlnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXh0cmFjdCBmb250cyBmcm9tIHJlc291cmNlc1xyXG4gICAgaWYgKGRvY3VtZW50RGF0YS5yZXNvdXJjZXMgJiYgZG9jdW1lbnREYXRhLnJlc291cmNlcy5mb250cykge1xyXG4gICAgICBPYmplY3QudmFsdWVzKGRvY3VtZW50RGF0YS5yZXNvdXJjZXMuZm9udHMpLmZvckVhY2goKGZvbnRGYW1pbHkpID0+IHtcclxuICAgICAgICBpZiAoZm9udEZhbWlseS5mb250cykge1xyXG4gICAgICAgICAgZm9udEZhbWlseS5mb250cy5mb3JFYWNoKChmb250KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2ZvbnQuZm9udEZhbWlseX0tJHtmb250LmZvbnRTdHlsZU5hbWV9YDtcclxuICAgICAgICAgICAgaWYgKCF1c2VkRm9udHMuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICB1c2VkRm9udHMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5tYXBUb05leHRGb250KFxyXG4gICAgICAgICAgICAgICAgZm9udC5mb250RmFtaWx5LFxyXG4gICAgICAgICAgICAgICAgZm9udC5mb250U3R5bGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgMTYsIC8vIERlZmF1bHQgc2l6ZSBmb3IgcmVzb3VyY2UgZm9udHNcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgcG9zdFNjcmlwdE5hbWU6IGZvbnQucG9zdFNjcmlwdE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogZm9udC5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICBmb250Q29uZmlncy5wdXNoKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5OKIEV4dHJhY3RlZCAke2ZvbnRDb25maWdzLmxlbmd0aH0gdW5pcXVlIGZvbnRzIGZyb20gZG9jdW1lbnRgXHJcbiAgICApO1xyXG5cclxuICAgIC8vIExvZyBzdW1tYXJ5XHJcbiAgICBmb250Q29uZmlncy5mb3JFYWNoKChmb250LCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgICAgJHtpbmRleCArIDF9LiBcIiR7Zm9udC5vcmlnaW5hbEZhbWlseX1cIiDihpIgXCIke2ZvbnQuZm9udEZhbWlseX1cIiAoJHtcclxuICAgICAgICAgIGZvbnQubWFwcGluZ1JlYXNvblxyXG4gICAgICAgIH0pYFxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGZvbnRDb25maWdzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgY2FjaGVzXHJcbiAgICovXHJcbiAgY2xlYXJDYWNoZSgpIHtcclxuICAgIHRoaXMuZm9udENhY2hlLmNsZWFyKCk7XHJcbiAgICB0aGlzLm5leHRGb250SW1wb3J0cy5jbGVhcigpO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZXh0Rm9udE1hcHBlcjtcclxuIl0sIm5hbWVzIjpbIk5leHRGb250TWFwcGVyIiwiY29uc3RydWN0b3IiLCJuZXh0Rm9udERhdGFiYXNlIiwiaW5pdGlhbGl6ZU5leHRGb250RGF0YWJhc2UiLCJmb250Q2FjaGUiLCJNYXAiLCJuZXh0Rm9udEltcG9ydHMiLCJTZXQiLCJzZXJpZiIsInRyYWRpdGlvbmFsIiwibmV4dEZvbnQiLCJmYW1pbHkiLCJ3ZWlnaHRzIiwic3R5bGVzIiwiZ29vZ2xlRm9udCIsImNoYXJhY3RlcmlzdGljcyIsImtleXdvcmRzIiwiZGlzcGxheSIsImdlb21ldHJpYyIsImh1bWFuaXN0IiwiZ3JvdGVzcXVlIiwibW9ub3NwYWNlIiwiamFwYW5lc2UiLCJjaGluZXNlIiwibWFwVG9OZXh0Rm9udCIsImlkbWxGb250RmFtaWx5IiwiZm9udFN0eWxlIiwiZm9udFNpemUiLCJmb250TWV0YWRhdGEiLCJjb25zb2xlIiwibG9nIiwiZ2V0RGVmYXVsdEZvbnQiLCJjYWNoZUtleSIsImhhcyIsImdldCIsImZvbnRBbmFseXNpcyIsImFuYWx5emVGb250Q2hhcmFjdGVyaXN0aWNzIiwiY2F0ZWdvcnkiLCJzdWJjYXRlZ29yeSIsImxhbmd1YWdlIiwiZGV0ZWN0ZWRLZXl3b3JkcyIsImNvbmZpZGVuY2UiLCJiZXN0TWF0Y2giLCJmaW5kQmVzdE5leHRKU0ZvbnQiLCJmaW5hbENvbmZpZyIsImJ1aWxkRm9udENvbmZpZyIsInNldCIsImFkZCIsImZvbnRGYW1pbHkiLCJmb250TmFtZSIsIm1ldGFkYXRhIiwibG93ZXJOYW1lIiwidG9Mb3dlckNhc2UiLCJhbmFseXNpcyIsIndlaWdodCIsImV4dHJhY3RXZWlnaHQiLCJpc0Rpc3BsYXkiLCJpc0NvbmRlbnNlZCIsImlzSmFwYW5lc2VGb250IiwiaXNTZXJpZkZvbnQiLCJpc0NoaW5lc2VGb250IiwiaXNEaXNwbGF5Rm9udCIsImlzTW9ub3NwYWNlRm9udCIsImlzR2VvbWV0cmljRm9udCIsImlzR3JvdGVzcXVlRm9udCIsImlzQ29uZGVuc2VkRm9udCIsImV4dHJhY3RLZXl3b3JkcyIsImphcGFuZXNlSW5kaWNhdG9ycyIsInNvbWUiLCJpbmRpY2F0b3IiLCJpbmNsdWRlcyIsImNoaW5lc2VJbmRpY2F0b3JzIiwic2VyaWZJbmRpY2F0b3JzIiwibW9ub3NwYWNlSW5kaWNhdG9ycyIsImdlb21ldHJpY0luZGljYXRvcnMiLCJncm90ZXNxdWVJbmRpY2F0b3JzIiwiZGlzcGxheUluZGljYXRvcnMiLCJjb25kZW5zZWRJbmRpY2F0b3JzIiwic3R5bGUiLCJjbGVhbmVkIiwicmVwbGFjZSIsInNwbGl0IiwiZmlsdGVyIiwid29yZCIsImxlbmd0aCIsIm9yaWdpbmFsTmFtZSIsImNhbmRpZGF0ZXMiLCJnZXREZWZhdWx0Rm9udENvbmZpZyIsInNjb3JlZENhbmRpZGF0ZXMiLCJtYXAiLCJmb250Iiwic2NvcmUiLCJjYWxjdWxhdGVGb250U2NvcmUiLCJzb3J0IiwiYSIsImIiLCJ0b0ZpeGVkIiwibG93ZXJPcmlnaW5hbCIsImtleXdvcmRNYXRjaGVzIiwia2V5d29yZCIsImZvbnRLZXl3b3JkIiwiY2hhcmFjdGVyaXN0aWNNYXRjaGVzIiwiY2hhciIsInRhcmdldFdlaWdodCIsIm1hcEZvbnRXZWlnaHQiLCJmb250Q29uZmlnIiwib3JpZ2luYWxGYW1pbHkiLCJlcnJvciIsIm1hcEZvbnRTdHlsZSIsInN0eWxlQW5hbHlzaXMiLCJhbmFseXplQ29tcGxleEZvbnRTdHlsZSIsIm5leHRGb250VmFyaWFibGUiLCJmb250V2VpZ2h0IiwiY29tcGxldGVTdHlsZSIsImlzSXRhbGljIiwiaXNCb2xkIiwib3JpZ2luYWxTdHlsZSIsImNvbXBsZXhTdHlsZSIsImNzc0NsYXNzZXMiLCJnZW5lcmF0ZUNTU0NsYXNzZXMiLCJyZXF1aXJlZFdlaWdodHMiLCJnZXRSZXF1aXJlZFdlaWdodHMiLCJyZXF1aXJlZFN0eWxlcyIsImdldFJlcXVpcmVkU3R5bGVzIiwiZm9udEZhbWlseUZhbGxiYWNrIiwiam9pbiIsImlzR29vZ2xlRm9udCIsImlzU3lzdGVtRm9udCIsInN5c3RlbUZvbnQiLCJvcmlnaW5hbFNpemUiLCJtYXBwaW5nQ29uZmlkZW5jZSIsIm1hcHBpbmdSZWFzb24iLCJnZW5lcmF0ZU1hcHBpbmdSZWFzb24iLCJpc0xpZ2h0IiwiaXNNZWRpdW0iLCJpc1NlbWlib2xkIiwiaXNCbGFjayIsImNsYXNzZXMiLCJwdXNoIiwiYXZhaWxhYmxlV2VpZ2h0cyIsInJlYXNvbnMiLCJrIiwid2VpZ2h0TWFwIiwidGhpbiIsImV4dHJhbGlnaHQiLCJsaWdodCIsInJlZ3VsYXIiLCJub3JtYWwiLCJtZWRpdW0iLCJzZW1pYm9sZCIsImJvbGQiLCJleHRyYWJvbGQiLCJibGFjayIsImhlYXZ5IiwiT2JqZWN0IiwiZW50cmllcyIsImdlbmVyYXRlTmV4dEZvbnRJbXBvcnRzIiwiaW1wb3J0cyIsIkFycmF5IiwiZnJvbSIsImdlbmVyYXRlRm9udFZhcmlhYmxlcyIsInZhcmlhYmxlcyIsImZpbmRGb250Q29uZmlnQnlOZXh0Rm9udCIsImFsbFJlcXVpcmVkV2VpZ2h0cyIsImFsbFJlcXVpcmVkU3R5bGVzIiwiY2FjaGVkRm9udCIsImZvckVhY2giLCJ3IiwicyIsIm5leHRGb250TmFtZSIsInZhbHVlcyIsImlzQXJyYXkiLCJmb3VuZCIsImZpbmQiLCJmIiwiZXh0cmFjdERvY3VtZW50Rm9udHMiLCJkb2N1bWVudERhdGEiLCJ1c2VkRm9udHMiLCJmb250Q29uZmlncyIsInN0b3JpZXMiLCJzdG9yeSIsImNvbnRlbnQiLCJmb3JtYXR0ZWRDb250ZW50Iiwic2VnbWVudCIsImZvcm1hdHRpbmciLCJrZXkiLCJjb25maWciLCJyZXNvdXJjZXMiLCJmb250cyIsImZvbnRTdHlsZU5hbWUiLCJwb3N0U2NyaXB0TmFtZSIsInN0YXR1cyIsImluZGV4IiwiY2xlYXJDYWNoZSIsImNsZWFyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/utils/NextFontMapper.js\n");

/***/ }),

/***/ "./lib/utils/UnitConverter.js":
/*!************************************!*\
  !*** ./lib/utils/UnitConverter.js ***!
  \************************************/
/***/ ((module) => {

eval("/**\r\n * UnitConverter - Converts various design units to pixels\r\n * All conversions go through inches, then: pixels = inches Ã— DPI\r\n *\r\n * Supported units: Pixels, Points, Picas, Millimeters, Centimeters, Inches, Cicero, Agate\r\n */ \nclass UnitConverter {\n    constructor(dpi = 96){\n        this.dpi = dpi; // Default web DPI\n        // Conversion factors to inches\n        this.CONVERSIONS_TO_INCHES = {\n            // Already in pixels - no conversion needed\n            Pixels: null,\n            pixels: null,\n            px: null,\n            // Standard units to inches\n            Points: 1 / 72,\n            points: 1 / 72,\n            pt: 1 / 72,\n            Picas: 1 / 6,\n            picas: 1 / 6,\n            pc: 1 / 6,\n            Millimeters: 0.0393701,\n            millimeters: 0.0393701,\n            mm: 0.0393701,\n            Centimeters: 0.393701,\n            centimeters: 0.393701,\n            cm: 0.393701,\n            Inches: 1,\n            inches: 1,\n            in: 1,\n            Cicero: 0.178,\n            cicero: 0.178,\n            Agate: 5.5 / 72,\n            agate: 5.5 / 72,\n            ag: 5.5 / 72\n        };\n    }\n    /**\r\n   * Set the DPI for conversions\r\n   * @param {number} dpi - Dots per inch (96 for web, 300/600 for print)\r\n   */ setDPI(dpi) {\n        this.dpi = dpi;\n    }\n    /**\r\n   * Get the DPI currently being used\r\n   * @returns {number} Current DPI setting\r\n   */ getDPI() {\n        return this.dpi;\n    }\n    /**\r\n   * Check if a unit is supported for conversion\r\n   * @param {string} unit - Unit name to check\r\n   * @returns {boolean} True if unit is supported\r\n   */ isSupportedUnit(unit) {\n        return unit in this.CONVERSIONS_TO_INCHES;\n    }\n    /**\r\n   * Convert any supported unit to pixels\r\n   * @param {number} value - Numeric value to convert\r\n   * @param {string} fromUnit - Source unit (e.g., 'Points', 'Millimeters')\r\n   * @returns {number} Value converted to pixels\r\n   */ toPixels(value, fromUnit) {\n        if (typeof value !== \"number\" || isNaN(value)) {\n            console.warn(`UnitConverter: Invalid value \"${value}\" for conversion`);\n            return 0;\n        }\n        if (!fromUnit) {\n            console.warn(\"UnitConverter: No unit specified, assuming pixels\");\n            return value;\n        }\n        // Check if already in pixels\n        if (this.CONVERSIONS_TO_INCHES[fromUnit] === null) {\n            return value; // Already in pixels, no conversion needed\n        }\n        // Get conversion factor to inches\n        const toInches = this.CONVERSIONS_TO_INCHES[fromUnit];\n        if (toInches === undefined) {\n            console.warn(`UnitConverter: Unsupported unit \"${fromUnit}\", treating as pixels`);\n            return value;\n        }\n        // Convert: value â†’ inches â†’ pixels\n        const inches = value * toInches;\n        const pixels = inches * this.dpi;\n        console.log(`ðŸ“ Converting: ${value} ${fromUnit} â†’ ${inches.toFixed(4)} in â†’ ${pixels.toFixed(2)} px (DPI: ${this.dpi})`);\n        return Math.round(pixels * 100) / 100; // Round to 2 decimal places\n    }\n    /**\r\n   * Convert multiple values to pixels (for geometric bounds, etc.)\r\n   * @param {object} values - Object with numeric values to convert\r\n   * @param {string} fromUnit - Source unit\r\n   * @returns {object} Object with values converted to pixels\r\n   */ convertObjectToPixels(values, fromUnit) {\n        if (!values || typeof values !== \"object\") {\n            return values;\n        }\n        const converted = {};\n        for (const [key, value] of Object.entries(values)){\n            if (typeof value === \"number\") {\n                converted[key] = this.toPixels(value, fromUnit);\n            } else {\n                converted[key] = value; // Keep non-numeric values as-is\n            }\n        }\n        return converted;\n    }\n    /**\r\n   * Convert dimensions object to pixels while preserving original\r\n   * @param {object} dimensions - Dimensions object with width, height, units\r\n   * @returns {object} Object with both original and pixel dimensions\r\n   */ convertDimensions(dimensions) {\n        if (!dimensions || typeof dimensions !== \"object\") {\n            return dimensions;\n        }\n        const { width, height, units, ...rest } = dimensions;\n        // If already in pixels, return as-is but add pixel dimensions for consistency\n        if (this.CONVERSIONS_TO_INCHES[units] === null) {\n            return {\n                ...dimensions,\n                pixelDimensions: {\n                    width: width,\n                    height: height,\n                    units: \"Pixels\"\n                }\n            };\n        }\n        // Convert to pixels\n        const pixelWidth = this.toPixels(width, units);\n        const pixelHeight = this.toPixels(height, units);\n        return {\n            ...dimensions,\n            pixelDimensions: {\n                width: pixelWidth,\n                height: pixelHeight,\n                units: \"Pixels\"\n            }\n        };\n    }\n    /**\r\n   * Get a list of all supported units\r\n   * @returns {string[]} Array of supported unit names\r\n   */ getSupportedUnits() {\n        return Object.keys(this.CONVERSIONS_TO_INCHES);\n    }\n    /**\r\n   * Create a unit converter with specific DPI\r\n   * @param {number} dpi - DPI setting\r\n   * @returns {UnitConverter} New UnitConverter instance\r\n   */ static withDPI(dpi) {\n        return new UnitConverter(dpi);\n    }\n}\nmodule.exports = UnitConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0xZLFNBQVMsQ0FBQ0MsSUFBSSxHQUFHZCxPQUFPLGdDQUFnQztZQUMxRDtRQUNGO1FBRUEsT0FBT2E7SUFDVDtJQUVBOzs7O0dBSUMsR0FDREksa0JBQWtCQyxVQUFVLEVBQUU7UUFDNUIsSUFBSSxDQUFDQSxjQUFjLE9BQU9BLGVBQWUsVUFBVTtZQUNqRCxPQUFPQTtRQUNUO1FBRUEsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFLEdBQUdDLE1BQU0sR0FBR0o7UUFFMUMsOEVBQThFO1FBQzlFLElBQUksSUFBSSxDQUFDL0MscUJBQXFCLENBQUNrRCxNQUFNLEtBQUssTUFBTTtZQUM5QyxPQUFPO2dCQUNMLEdBQUdILFVBQVU7Z0JBQ2JLLGlCQUFpQjtvQkFDZkosT0FBT0E7b0JBQ1BDLFFBQVFBO29CQUNSQyxPQUFPO2dCQUNUO1lBQ0Y7UUFDRjtRQUVBLG9CQUFvQjtRQUNwQixNQUFNRyxhQUFhLElBQUksQ0FBQ3pCLFFBQVEsQ0FBQ29CLE9BQU9FO1FBQ3hDLE1BQU1JLGNBQWMsSUFBSSxDQUFDMUIsUUFBUSxDQUFDcUIsUUFBUUM7UUFFMUMsT0FBTztZQUNMLEdBQUdILFVBQVU7WUFDYkssaUJBQWlCO2dCQUNmSixPQUFPSztnQkFDUEosUUFBUUs7Z0JBQ1JKLE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDREssb0JBQW9CO1FBQ2xCLE9BQU9YLE9BQU9ZLElBQUksQ0FBQyxJQUFJLENBQUN4RCxxQkFBcUI7SUFDL0M7SUFFQTs7OztHQUlDLEdBQ0QsT0FBT3lELFFBQVExRCxHQUFHLEVBQUU7UUFDbEIsT0FBTyxJQUFJRixjQUFjRTtJQUMzQjtBQUNGO0FBRUEyRCxPQUFPQyxPQUFPLEdBQUc5RCIsInNvdXJjZXMiOlsid2VicGFjazovL2lkbWwtdmlld2VyLy4vbGliL3V0aWxzL1VuaXRDb252ZXJ0ZXIuanM/MjViMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVW5pdENvbnZlcnRlciAtIENvbnZlcnRzIHZhcmlvdXMgZGVzaWduIHVuaXRzIHRvIHBpeGVsc1xyXG4gKiBBbGwgY29udmVyc2lvbnMgZ28gdGhyb3VnaCBpbmNoZXMsIHRoZW46IHBpeGVscyA9IGluY2hlcyDDlyBEUElcclxuICpcclxuICogU3VwcG9ydGVkIHVuaXRzOiBQaXhlbHMsIFBvaW50cywgUGljYXMsIE1pbGxpbWV0ZXJzLCBDZW50aW1ldGVycywgSW5jaGVzLCBDaWNlcm8sIEFnYXRlXHJcbiAqL1xyXG5cclxuY2xhc3MgVW5pdENvbnZlcnRlciB7XHJcbiAgY29uc3RydWN0b3IoZHBpID0gOTYpIHtcclxuICAgIHRoaXMuZHBpID0gZHBpOyAvLyBEZWZhdWx0IHdlYiBEUElcclxuXHJcbiAgICAvLyBDb252ZXJzaW9uIGZhY3RvcnMgdG8gaW5jaGVzXHJcbiAgICB0aGlzLkNPTlZFUlNJT05TX1RPX0lOQ0hFUyA9IHtcclxuICAgICAgLy8gQWxyZWFkeSBpbiBwaXhlbHMgLSBubyBjb252ZXJzaW9uIG5lZWRlZFxyXG4gICAgICBQaXhlbHM6IG51bGwsXHJcbiAgICAgIHBpeGVsczogbnVsbCxcclxuICAgICAgcHg6IG51bGwsXHJcblxyXG4gICAgICAvLyBTdGFuZGFyZCB1bml0cyB0byBpbmNoZXNcclxuICAgICAgUG9pbnRzOiAxIC8gNzIsIC8vIDEgcG9pbnQgPSAxLzcyIGluY2hcclxuICAgICAgcG9pbnRzOiAxIC8gNzIsXHJcbiAgICAgIHB0OiAxIC8gNzIsXHJcblxyXG4gICAgICBQaWNhczogMSAvIDYsIC8vIDEgcGljYSA9IDEvNiBpbmNoID0gMTIgcG9pbnRzXHJcbiAgICAgIHBpY2FzOiAxIC8gNixcclxuICAgICAgcGM6IDEgLyA2LFxyXG5cclxuICAgICAgTWlsbGltZXRlcnM6IDAuMDM5MzcwMSwgLy8gMSBtbSA9IDAuMDM5MzcwMSBpbmNoZXNcclxuICAgICAgbWlsbGltZXRlcnM6IDAuMDM5MzcwMSxcclxuICAgICAgbW06IDAuMDM5MzcwMSxcclxuXHJcbiAgICAgIENlbnRpbWV0ZXJzOiAwLjM5MzcwMSwgLy8gMSBjbSA9IDAuMzkzNzAxIGluY2hlc1xyXG4gICAgICBjZW50aW1ldGVyczogMC4zOTM3MDEsXHJcbiAgICAgIGNtOiAwLjM5MzcwMSxcclxuXHJcbiAgICAgIEluY2hlczogMSwgLy8gMSBpbmNoID0gMSBpbmNoXHJcbiAgICAgIGluY2hlczogMSxcclxuICAgICAgaW46IDEsXHJcblxyXG4gICAgICBDaWNlcm86IDAuMTc4LCAvLyAxIGNpY2VybyA9IDEyIERpZG90IHBvaW50cyDiiYggMC4xNzggaW5jaGVzXHJcbiAgICAgIGNpY2VybzogMC4xNzgsXHJcblxyXG4gICAgICBBZ2F0ZTogNS41IC8gNzIsIC8vIDEgYWdhdGUgPSA1LjUgcG9pbnRzID0gNS41LzcyIGluY2hlc1xyXG4gICAgICBhZ2F0ZTogNS41IC8gNzIsXHJcbiAgICAgIGFnOiA1LjUgLyA3MixcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIERQSSBmb3IgY29udmVyc2lvbnNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHBpIC0gRG90cyBwZXIgaW5jaCAoOTYgZm9yIHdlYiwgMzAwLzYwMCBmb3IgcHJpbnQpXHJcbiAgICovXHJcbiAgc2V0RFBJKGRwaSkge1xyXG4gICAgdGhpcy5kcGkgPSBkcGk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIERQSSBjdXJyZW50bHkgYmVpbmcgdXNlZFxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEN1cnJlbnQgRFBJIHNldHRpbmdcclxuICAgKi9cclxuICBnZXREUEkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcGk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHVuaXQgaXMgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBVbml0IG5hbWUgdG8gY2hlY2tcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB1bml0IGlzIHN1cHBvcnRlZFxyXG4gICAqL1xyXG4gIGlzU3VwcG9ydGVkVW5pdCh1bml0KSB7XHJcbiAgICByZXR1cm4gdW5pdCBpbiB0aGlzLkNPTlZFUlNJT05TX1RPX0lOQ0hFUztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYW55IHN1cHBvcnRlZCB1bml0IHRvIHBpeGVsc1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE51bWVyaWMgdmFsdWUgdG8gY29udmVydFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tVW5pdCAtIFNvdXJjZSB1bml0IChlLmcuLCAnUG9pbnRzJywgJ01pbGxpbWV0ZXJzJylcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSBjb252ZXJ0ZWQgdG8gcGl4ZWxzXHJcbiAgICovXHJcbiAgdG9QaXhlbHModmFsdWUsIGZyb21Vbml0KSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oYFVuaXRDb252ZXJ0ZXI6IEludmFsaWQgdmFsdWUgXCIke3ZhbHVlfVwiIGZvciBjb252ZXJzaW9uYCk7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZnJvbVVuaXQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFwiVW5pdENvbnZlcnRlcjogTm8gdW5pdCBzcGVjaWZpZWQsIGFzc3VtaW5nIHBpeGVsc1wiKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgaW4gcGl4ZWxzXHJcbiAgICBpZiAodGhpcy5DT05WRVJTSU9OU19UT19JTkNIRVNbZnJvbVVuaXRdID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTsgLy8gQWxyZWFkeSBpbiBwaXhlbHMsIG5vIGNvbnZlcnNpb24gbmVlZGVkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IGNvbnZlcnNpb24gZmFjdG9yIHRvIGluY2hlc1xyXG4gICAgY29uc3QgdG9JbmNoZXMgPSB0aGlzLkNPTlZFUlNJT05TX1RPX0lOQ0hFU1tmcm9tVW5pdF07XHJcblxyXG4gICAgaWYgKHRvSW5jaGVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBVbml0Q29udmVydGVyOiBVbnN1cHBvcnRlZCB1bml0IFwiJHtmcm9tVW5pdH1cIiwgdHJlYXRpbmcgYXMgcGl4ZWxzYFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydDogdmFsdWUg4oaSIGluY2hlcyDihpIgcGl4ZWxzXHJcbiAgICBjb25zdCBpbmNoZXMgPSB2YWx1ZSAqIHRvSW5jaGVzO1xyXG4gICAgY29uc3QgcGl4ZWxzID0gaW5jaGVzICogdGhpcy5kcGk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn5OQIENvbnZlcnRpbmc6ICR7dmFsdWV9ICR7ZnJvbVVuaXR9IOKGkiAke2luY2hlcy50b0ZpeGVkKFxyXG4gICAgICAgIDRcclxuICAgICAgKX0gaW4g4oaSICR7cGl4ZWxzLnRvRml4ZWQoMil9IHB4IChEUEk6ICR7dGhpcy5kcGl9KWBcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgucm91bmQocGl4ZWxzICogMTAwKSAvIDEwMDsgLy8gUm91bmQgdG8gMiBkZWNpbWFsIHBsYWNlc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBtdWx0aXBsZSB2YWx1ZXMgdG8gcGl4ZWxzIChmb3IgZ2VvbWV0cmljIGJvdW5kcywgZXRjLilcclxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIC0gT2JqZWN0IHdpdGggbnVtZXJpYyB2YWx1ZXMgdG8gY29udmVydFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tVW5pdCAtIFNvdXJjZSB1bml0XHJcbiAgICogQHJldHVybnMge29iamVjdH0gT2JqZWN0IHdpdGggdmFsdWVzIGNvbnZlcnRlZCB0byBwaXhlbHNcclxuICAgKi9cclxuICBjb252ZXJ0T2JqZWN0VG9QaXhlbHModmFsdWVzLCBmcm9tVW5pdCkge1xyXG4gICAgaWYgKCF2YWx1ZXMgfHwgdHlwZW9mIHZhbHVlcyAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbnZlcnRlZCA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWVzKSkge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgY29udmVydGVkW2tleV0gPSB0aGlzLnRvUGl4ZWxzKHZhbHVlLCBmcm9tVW5pdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udmVydGVkW2tleV0gPSB2YWx1ZTsgLy8gS2VlcCBub24tbnVtZXJpYyB2YWx1ZXMgYXMtaXNcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb252ZXJ0ZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IGRpbWVuc2lvbnMgb2JqZWN0IHRvIHBpeGVscyB3aGlsZSBwcmVzZXJ2aW5nIG9yaWdpbmFsXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGRpbWVuc2lvbnMgLSBEaW1lbnNpb25zIG9iamVjdCB3aXRoIHdpZHRoLCBoZWlnaHQsIHVuaXRzXHJcbiAgICogQHJldHVybnMge29iamVjdH0gT2JqZWN0IHdpdGggYm90aCBvcmlnaW5hbCBhbmQgcGl4ZWwgZGltZW5zaW9uc1xyXG4gICAqL1xyXG4gIGNvbnZlcnREaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcclxuICAgIGlmICghZGltZW5zaW9ucyB8fCB0eXBlb2YgZGltZW5zaW9ucyAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICByZXR1cm4gZGltZW5zaW9ucztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHVuaXRzLCAuLi5yZXN0IH0gPSBkaW1lbnNpb25zO1xyXG5cclxuICAgIC8vIElmIGFscmVhZHkgaW4gcGl4ZWxzLCByZXR1cm4gYXMtaXMgYnV0IGFkZCBwaXhlbCBkaW1lbnNpb25zIGZvciBjb25zaXN0ZW5jeVxyXG4gICAgaWYgKHRoaXMuQ09OVkVSU0lPTlNfVE9fSU5DSEVTW3VuaXRzXSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLmRpbWVuc2lvbnMsXHJcbiAgICAgICAgcGl4ZWxEaW1lbnNpb25zOiB7XHJcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgIHVuaXRzOiBcIlBpeGVsc1wiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCB0byBwaXhlbHNcclxuICAgIGNvbnN0IHBpeGVsV2lkdGggPSB0aGlzLnRvUGl4ZWxzKHdpZHRoLCB1bml0cyk7XHJcbiAgICBjb25zdCBwaXhlbEhlaWdodCA9IHRoaXMudG9QaXhlbHMoaGVpZ2h0LCB1bml0cyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4uZGltZW5zaW9ucywgLy8gS2VlcCBvcmlnaW5hbCBkaW1lbnNpb25zXHJcbiAgICAgIHBpeGVsRGltZW5zaW9uczoge1xyXG4gICAgICAgIHdpZHRoOiBwaXhlbFdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogcGl4ZWxIZWlnaHQsXHJcbiAgICAgICAgdW5pdHM6IFwiUGl4ZWxzXCIsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwgc3VwcG9ydGVkIHVuaXRzXHJcbiAgICogQHJldHVybnMge3N0cmluZ1tdfSBBcnJheSBvZiBzdXBwb3J0ZWQgdW5pdCBuYW1lc1xyXG4gICAqL1xyXG4gIGdldFN1cHBvcnRlZFVuaXRzKCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuQ09OVkVSU0lPTlNfVE9fSU5DSEVTKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIHVuaXQgY29udmVydGVyIHdpdGggc3BlY2lmaWMgRFBJXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRwaSAtIERQSSBzZXR0aW5nXHJcbiAgICogQHJldHVybnMge1VuaXRDb252ZXJ0ZXJ9IE5ldyBVbml0Q29udmVydGVyIGluc3RhbmNlXHJcbiAgICovXHJcbiAgc3RhdGljIHdpdGhEUEkoZHBpKSB7XHJcbiAgICByZXR1cm4gbmV3IFVuaXRDb252ZXJ0ZXIoZHBpKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVW5pdENvbnZlcnRlcjtcclxuIl0sIm5hbWVzIjpbIlVuaXRDb252ZXJ0ZXIiLCJjb25zdHJ1Y3RvciIsImRwaSIsIkNPTlZFUlNJT05TX1RPX0lOQ0hFUyIsIlBpeGVscyIsInBpeGVscyIsInB4IiwiUG9pbnRzIiwicG9pbnRzIiwicHQiLCJQaWNhcyIsInBpY2FzIiwicGMiLCJNaWxsaW1ldGVycyIsIm1pbGxpbWV0ZXJzIiwibW0iLCJDZW50aW1ldGVycyIsImNlbnRpbWV0ZXJzIiwiY20iLCJJbmNoZXMiLCJpbmNoZXMiLCJpbiIsIkNpY2VybyIsImNpY2VybyIsIkFnYXRlIiwiYWdhdGUiLCJhZyIsInNldERQSSIsImdldERQSSIsImlzU3VwcG9ydGVkVW5pdCIsInVuaXQiLCJ0b1BpeGVscyIsInZhbHVlIiwiZnJvbVVuaXQiLCJpc05hTiIsImNvbnNvbGUiLCJ3YXJuIiwidG9JbmNoZXMiLCJ1bmRlZmluZWQiLCJsb2ciLCJ0b0ZpeGVkIiwiTWF0aCIsInJvdW5kIiwiY29udmVydE9iamVjdFRvUGl4ZWxzIiwidmFsdWVzIiwiY29udmVydGVkIiwia2V5IiwiT2JqZWN0IiwiZW50cmllcyIsImNvbnZlcnREaW1lbnNpb25zIiwiZGltZW5zaW9ucyIsIndpZHRoIiwiaGVpZ2h0IiwidW5pdHMiLCJyZXN0IiwicGl4ZWxEaW1lbnNpb25zIiwicGl4ZWxXaWR0aCIsInBpeGVsSGVpZ2h0IiwiZ2V0U3VwcG9ydGVkVW5pdHMiLCJrZXlzIiwid2l0aERQSSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/utils/UnitConverter.js\n");

/***/ }),

/***/ "./pages/view/[uploadId].js":
/*!**********************************!*\
  !*** ./pages/view/[uploadId].js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Viewer)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/index.js */ \"./lib/index.js\");\n/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lib_index_js__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n // Added missing import for React.Fragment\n\nfunction Viewer() {\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const { uploadId } = router.query;\n    const [documentData, setDocumentData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [selectedElement, setSelectedElement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showMargins, setShowMargins] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [showDebugInfo, setShowDebugInfo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // CONFIGURATION OPTIONS - Make background detection flexible\n    const [backgroundConfig, setBackgroundConfig] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        mode: \"auto\",\n        customColor: \"#ffffff\",\n        allowColorAnalysis: true,\n        preferPaperColor: true,\n        fallbackToWhite: true\n    });\n    // Background color override controls\n    const backgroundModes = [\n        {\n            value: \"auto\",\n            label: \"Auto Detect\"\n        },\n        {\n            value: \"white\",\n            label: \"Force White\"\n        },\n        {\n            value: \"transparent\",\n            label: \"Transparent\"\n        },\n        {\n            value: \"custom\",\n            label: \"Custom Color\"\n        }\n    ];\n    const mmToPx = (mm)=>{\n        if (typeof mm !== \"number\") return 0;\n        return mm * 96 / 25.4;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (uploadId) {\n            loadDocument();\n        }\n    }, [\n        uploadId\n    ]);\n    const loadDocument = async ()=>{\n        try {\n            const response = await fetch(`/api/document/${uploadId}`);\n            const data = await response.json();\n            console.log(\"\\uD83D\\uDCC4 Document data:\", data);\n            // DEBUG: Check element positioning data in detail\n            console.log(\"\\uD83D\\uDD0D DEBUG DATA STRUCTURE:\");\n            console.log(\"DATA EXISTS:\", !!data);\n            console.log(\"DATA.ELEMENTS EXISTS:\", !!data?.elements);\n            console.log(\"DATA.ELEMENTS LENGTH:\", data?.elements?.length);\n            console.log(\"DATA KEYS:\", data ? Object.keys(data) : \"no data\");\n            console.log(\"FULL DATA OBJECT:\", data);\n            if (data && data.elements && data.elements.length > 0) {\n                console.log(\"\\uD83D\\uDD0D ELEMENT POSITIONING ANALYSIS:\");\n                console.log(\"RAW ELEMENTS ARRAY:\", data.elements);\n                data.elements.forEach((element, index)=>{\n                    console.log(`\\n=== ELEMENT ${index} ===`);\n                    console.log(\"ELEMENT ID:\", element.id);\n                    console.log(\"ELEMENT NAME:\", element.name);\n                    console.log(\"ELEMENT TYPE:\", element.type);\n                    console.log(\"ORIGINAL POSITION:\", element.position);\n                    console.log(\"PIXEL POSITION:\", element.pixelPosition);\n                    // Check for Y=0 issues\n                    if (element.position?.y === 0) {\n                        console.log(\"\\uD83D\\uDEA8 ORIGINAL POSITION Y IS ZERO!\");\n                    }\n                    if (element.pixelPosition?.y === 0) {\n                        console.log(\"\\uD83D\\uDEA8 PIXEL POSITION Y IS ZERO!\");\n                    }\n                    // Show what coordinates we're actually using for positioning\n                    const finalPosition = element.pixelPosition || element.position;\n                    console.log(\"FINAL POSITION FOR RENDERING:\", finalPosition);\n                    // Show each coordinate explicitly\n                    console.log(\"FINAL X:\", finalPosition?.x);\n                    console.log(\"FINAL Y:\", finalPosition?.y);\n                    console.log(\"FINAL WIDTH:\", finalPosition?.width);\n                    console.log(\"FINAL HEIGHT:\", finalPosition?.height);\n                });\n            } else {\n                console.log(\"\\uD83D\\uDEA8 NO ELEMENTS FOUND! This is the problem.\");\n            }\n            setDocumentData(data);\n            setLoading(false);\n        } catch (error) {\n            console.error(\"Error loading document:\", error);\n            setLoading(false);\n        }\n    };\n    // Use ColorUtils for color conversion\n    const convertColor = (colorRef)=>{\n        // If colorRef is a string and matches a color in resources, use the color object\n        if (typeof colorRef === \"string\" && documentData.resources && documentData.resources.colors && documentData.resources.colors[colorRef]) {\n            return _lib_index_js__WEBPACK_IMPORTED_MODULE_3__.ColorUtils.convertIdmlColorToRgb(documentData.resources.colors[colorRef]);\n        }\n        // Otherwise, pass through (handles objects or fallback)\n        return _lib_index_js__WEBPACK_IMPORTED_MODULE_3__.ColorUtils.convertIdmlColorToRgb(colorRef);\n    };\n    const getDocumentBackgroundColor = (documentData)=>{\n        console.log(\"\\uD83D\\uDD0D Starting improved background color detection...\", {\n            config: backgroundConfig\n        });\n        // 1. Look for a full-page rectangle with a fill (prefer this over swatch analysis)\n        if (documentData.elements) {\n            const pageWidth = documentData.pageInfo?.dimensions?.pixelDimensions?.width || 612;\n            const pageHeight = documentData.pageInfo?.dimensions?.pixelDimensions?.height || 792;\n            // Find the largest rectangle with a non-None fill\n            const fullPageRects = documentData.elements.filter((el)=>el.type === \"Rectangle\" && el.pixelPosition && el.pixelPosition.x <= 5 && el.pixelPosition.y <= 5 && el.pixelPosition.width >= pageWidth * 0.95 && el.pixelPosition.height >= pageHeight * 0.95 && el.fill && el.fill !== \"Color/None\");\n            if (fullPageRects.length > 0) {\n                // Use the largest by area\n                const bgRect = fullPageRects.reduce((a, b)=>a.pixelPosition.width * a.pixelPosition.height > b.pixelPosition.width * b.pixelPosition.height ? a : b);\n                console.log(\"\\uD83C\\uDFA8 Using full-page rectangle as background:\", bgRect.fill);\n                return convertColor(bgRect.fill);\n            }\n        }\n        // Handle configured background modes\n        if (backgroundConfig.mode === \"white\") {\n            console.log(\"\\uD83D\\uDCC4 âœ… Force white mode - returning white\");\n            return \"white\";\n        }\n        if (backgroundConfig.mode === \"transparent\") {\n            console.log(\"\\uD83D\\uDCC4 âœ… Transparent mode - returning transparent\");\n            return \"transparent\";\n        }\n        if (backgroundConfig.mode === \"custom\") {\n            console.log(\"\\uD83D\\uDCC4 âœ… Custom color mode - returning:\", backgroundConfig.customColor);\n            return backgroundConfig.customColor;\n        }\n        // Auto mode - continue with detection logic\n        // Strategy 1: Look for page background color in pageInfo\n        if (documentData.pageInfo?.backgroundColor && documentData.pageInfo.backgroundColor !== \"Color/None\") {\n            console.log(\"\\uD83D\\uDCC4 Found page background in pageInfo:\", documentData.pageInfo.backgroundColor);\n            return convertColor(documentData.pageInfo.backgroundColor);\n        }\n        // Strategy 2: Look for document background in document properties\n        if (documentData.document?.backgroundColor && documentData.document.backgroundColor !== \"Color/None\") {\n            console.log(\"\\uD83D\\uDCC4 Found document background in document:\", documentData.document.backgroundColor);\n            return convertColor(documentData.document.backgroundColor);\n        }\n        // Strategy 3: Look for spreads background color\n        if (documentData.spreads) {\n            for (const [spreadId, spread] of Object.entries(documentData.spreads)){\n                if (spread.backgroundColor && spread.backgroundColor !== \"Color/None\") {\n                    console.log(\"\\uD83D\\uDCC4 Found spread background color:\", spread.backgroundColor);\n                    return convertColor(spread.backgroundColor);\n                }\n            }\n        }\n        // STRATEGY 3.5: Analyze document colors for suitable background colors using ColorUtils\n        if (documentData.resources?.colors) {\n            console.log(\"\\uD83D\\uDCC4 Analyzing document colors for background candidates...\");\n            // Use ColorUtils to analyze and filter background colors\n            const colorKeys = Object.keys(documentData.resources.colors);\n            const backgroundCandidates = [];\n            for (const colorKey of colorKeys){\n                const analysis = _lib_index_js__WEBPACK_IMPORTED_MODULE_3__.ColorUtils.analyzeIdmlColorForBackground(colorKey);\n                if (analysis && analysis.isLightBackground) {\n                    console.log(`   âœ… Background candidate: ${colorKey} - ${analysis.reasoning} (${analysis.category})`);\n                    backgroundCandidates.push(colorKey);\n                } else if (analysis) {\n                    console.log(`   âŒ Not suitable: ${colorKey} - ${analysis.reasoning}`);\n                }\n            }\n            if (backgroundCandidates.length > 0) {\n                // Sort candidates using ColorUtils sorting function\n                const sortedCandidates = _lib_index_js__WEBPACK_IMPORTED_MODULE_3__.ColorUtils.sortColorsByLightness(backgroundCandidates);\n                const bestCandidate = sortedCandidates[0];\n                console.log(`ðŸ“„ Found ${backgroundCandidates.length} background color candidates:`, sortedCandidates);\n                console.log(\"\\uD83D\\uDCC4 Using best background color candidate:\", bestCandidate);\n                return convertColor(bestCandidate);\n            }\n        }\n        // Strategy 4: Look for a large background rectangle element with actual fill\n        if (documentData.elements) {\n            const pageWidth = documentData.pageInfo?.dimensions?.pixelDimensions?.width || 612;\n            const pageHeight = documentData.pageInfo?.dimensions?.pixelDimensions?.height || 792;\n            console.log(\"\\uD83D\\uDCC4 Searching for background in\", documentData.elements.length, \"elements\");\n            console.log(\"\\uD83D\\uDCC4 Page dimensions:\", pageWidth, \"x\", pageHeight);\n            // Log all rectangles with their positions and fills for debugging\n            const rectangles = documentData.elements.filter((element)=>element.type === \"Rectangle\");\n            console.log(\"\\uD83D\\uDCC4 Found\", rectangles.length, \"rectangles:\");\n            let hasAnyActualFill = false;\n            rectangles.forEach((rect)=>{\n                console.log(`   - ${rect.id}: pos(${rect.position.x}, ${rect.position.y}) size(${rect.position.width} x ${rect.position.height}) fill: ${rect.fill}`);\n                if (rect.fill && rect.fill !== \"Color/None\") {\n                    hasAnyActualFill = true;\n                }\n            });\n            // CRITICAL FIX: If ALL rectangles have Color/None, check if we already found a background color above\n            if (!hasAnyActualFill) {\n                console.log(\"\\uD83D\\uDCC4 âœ… ALL rectangles have Color/None - but checking for document-level background first\");\n            // Don't immediately default to white - continue checking other strategies\n            }\n            // Strategy 4a: Look for rectangles that cover the entire page area with actual color\n            const fullPageElements = documentData.elements.filter((element)=>{\n                return element.type === \"Rectangle\" && element.position.x <= 50 && // More tolerance for left edge\n                element.position.y <= 50 && // More tolerance for top edge\n                element.position.width >= pageWidth * 0.8 && // Covers most width\n                element.position.height >= pageHeight * 0.8 && // Covers most height\n                element.fill && element.fill !== \"Color/None\";\n            });\n            if (fullPageElements.length > 0) {\n                // Get the largest background element (likely the page background)\n                const backgroundElement = fullPageElements.reduce((largest, current)=>{\n                    const largestArea = largest.position.width * largest.position.height;\n                    const currentArea = current.position.width * current.position.height;\n                    return currentArea > largestArea ? current : largest;\n                });\n                console.log(\"\\uD83D\\uDCC4 Found full-page background element:\", backgroundElement.id, \"with color:\", backgroundElement.fill);\n                return convertColor(backgroundElement.fill);\n            }\n            // Strategy 4b: Look for any large rectangle with actual color (even if not full page)\n            const largeColoredElements = documentData.elements.filter((element)=>{\n                const area = element.position.width * element.position.height;\n                const pageArea = pageWidth * pageHeight;\n                return element.type === \"Rectangle\" && area >= pageArea * 0.3 && // At least 30% of page area\n                element.fill && element.fill !== \"Color/None\";\n            });\n            if (largeColoredElements.length > 0) {\n                // Sort by area, largest first\n                largeColoredElements.sort((a, b)=>{\n                    const areaA = a.position.width * a.position.height;\n                    const areaB = b.position.width * b.position.height;\n                    return areaB - areaA;\n                });\n                const backgroundElement = largeColoredElements[0];\n                console.log(\"\\uD83D\\uDCC4 Found large colored background element:\", backgroundElement.id, \"with color:\", backgroundElement.fill);\n                return convertColor(backgroundElement.fill);\n            }\n        }\n        // Strategy 5: Look for Paper color specifically (InDesign's default) - if enabled\n        if (backgroundConfig.preferPaperColor && documentData.resources?.colors) {\n            const paperColor = Object.entries(documentData.resources.colors).find(([key, color])=>color.name === \"Paper\" || key === \"Color/Paper\");\n            if (paperColor) {\n                console.log(\"\\uD83D\\uDCC4 Found Paper color in resources - using as background\");\n                return convertColor(paperColor[0]);\n            }\n        }\n        // Strategy 6: Check for explicitly named background colors\n        if (documentData.resources?.colors) {\n            // Look for specific background color names\n            const backgroundColorNames = [\n                \"Page\",\n                \"Background\",\n                \"Document\",\n                \"Page Color\",\n                \"Background Color\"\n            ];\n            for (const colorName of backgroundColorNames){\n                const foundColor = Object.entries(documentData.resources.colors).find(([key, color])=>color.name && backgroundColorNames.some((name)=>color.name.toLowerCase().includes(name.toLowerCase())));\n                if (foundColor) {\n                    console.log(\"\\uD83D\\uDCC4 Found named background color:\", foundColor[1].name);\n                    return convertColor(foundColor[0]);\n                }\n            }\n        }\n        // Strategy 7: Check spreads data for background colors\n        if (documentData.spreads) {\n            console.log(\"\\uD83D\\uDCC4 Checking spreads for background colors...\");\n            for (const [spreadId, spread] of Object.entries(documentData.spreads)){\n                console.log(`   - Spread ${spreadId} keys:`, Object.keys(spread));\n                // Check for page background in spread\n                if (spread.pages) {\n                    for (const [index, page] of spread.pages.entries()){\n                        console.log(`     - Page ${index} keys:`, Object.keys(page));\n                        if (page.backgroundColor && page.backgroundColor !== \"Color/None\") {\n                            console.log(\"\\uD83D\\uDCC4 Found page background in spread page:\", page.backgroundColor);\n                            return convertColor(page.backgroundColor);\n                        }\n                    }\n                }\n            }\n        }\n        // Strategy 8: Check master spreads for background\n        if (documentData.masterSpreads) {\n            console.log(\"\\uD83D\\uDCC4 Checking master spreads for background colors...\");\n            for (const [masterId, master] of Object.entries(documentData.masterSpreads)){\n                console.log(`   - Master ${masterId} keys:`, Object.keys(master));\n                if (master.backgroundColor && master.backgroundColor !== \"Color/None\") {\n                    console.log(\"\\uD83D\\uDCC4 Found master spread background:\", master.backgroundColor);\n                    return convertColor(master.backgroundColor);\n                }\n            }\n        }\n        // Strategy 9: IMPROVED color analysis - only as last resort and only for colors actually used as fills - if enabled\n        if (backgroundConfig.allowColorAnalysis && documentData.resources?.colors && documentData.elements) {\n            console.log(\"\\uD83D\\uDCC4 Performing last-resort color analysis...\");\n            // First, get all colors actually used as fills in the document\n            const usedFillColors = new Set();\n            documentData.elements.forEach((element)=>{\n                if (element.fill && element.fill !== \"Color/None\") {\n                    usedFillColors.add(element.fill);\n                }\n            });\n            console.log(\"\\uD83D\\uDCC4 Colors actually used as fills:\", Array.from(usedFillColors));\n            if (usedFillColors.size === 0) {\n                console.log(\"\\uD83D\\uDCC4 âœ… No colors used as fills - confirming white background\");\n                return \"white\";\n            }\n            // Analyze only colors that are actually used as fills\n            const fillColorAnalysis = Array.from(usedFillColors).map((colorKey)=>{\n                const color = documentData.resources.colors[colorKey];\n                if (!color) return null;\n                // Extract CMYK values from the key if available\n                const cmykMatch = colorKey.match(/Color\\/C=([\\d.]+)\\s*M=([\\d.]+)\\s*Y=([\\d.]+)\\s*K=([\\d.]+)/);\n                if (!cmykMatch) return null;\n                const [, c, m, y, k] = cmykMatch.map((val)=>parseFloat(val));\n                console.log(`   â†’ Analyzing used fill color ${colorKey}: C=${c} M=${m} Y=${y} K=${k}`);\n                // Calculate how \"background-like\" this color is\n                const colorfulness = c + m + y;\n                const darkness = k;\n                const lightness = 100 - darkness; // Higher is lighter\n                // Background colors should typically be:\n                // - Low colorfulness (neutral)\n                // - High lightness (bright)\n                // - Large coverage area\n                let backgroundScore = 0;\n                // Prefer lighter colors (white/paper-like)\n                backgroundScore += lightness * 2;\n                // Slightly penalize very colorful colors (unless they cover large areas)\n                if (colorfulness > 50) {\n                    backgroundScore -= colorfulness * 0.5;\n                }\n                // Calculate total area covered by this color\n                let totalArea = 0;\n                documentData.elements.forEach((element)=>{\n                    if (element.fill === colorKey) {\n                        totalArea += (element.position.width || 0) * (element.position.height || 0);\n                    }\n                });\n                const pageArea = (documentData.pageInfo?.dimensions?.width || 612) * (documentData.pageInfo?.dimensions?.height || 792);\n                const coverageRatio = totalArea / pageArea;\n                // Heavily boost colors that cover large areas\n                backgroundScore += coverageRatio * 1000;\n                console.log(`   ðŸ“Š Background score for ${colorKey}: ${backgroundScore} (lightness: ${lightness}, colorfulness: ${colorfulness}, coverage: ${coverageRatio.toFixed(3)})`);\n                return {\n                    key: colorKey,\n                    color,\n                    cmyk: {\n                        c,\n                        m,\n                        y,\n                        k\n                    },\n                    backgroundScore,\n                    lightness,\n                    colorfulness,\n                    coverageRatio\n                };\n            }).filter(Boolean);\n            if (fillColorAnalysis.length > 0) {\n                // Sort by background score (highest first)\n                fillColorAnalysis.sort((a, b)=>b.backgroundScore - a.backgroundScore);\n                const bestBackgroundColor = fillColorAnalysis[0];\n                console.log(`ðŸŽ¨ Selected background color from fills: ${bestBackgroundColor.key} (score: ${bestBackgroundColor.backgroundScore})`);\n                console.log(`   Color details: C=${bestBackgroundColor.cmyk.c} M=${bestBackgroundColor.cmyk.m} Y=${bestBackgroundColor.cmyk.y} K=${bestBackgroundColor.cmyk.k}`);\n                return convertColor(bestBackgroundColor.key);\n            }\n        }\n        // Final Fallback: Use configured fallback\n        if (backgroundConfig.fallbackToWhite) {\n            console.log(\"\\uD83D\\uDCC4 âœ… No background color detected - using white fallback\");\n            return \"white\";\n        } else {\n            console.log(\"\\uD83D\\uDCC4 âœ… No background color detected - using transparent fallback\");\n            return \"transparent\";\n        }\n    };\n    const getFontWeight = (fontStyle)=>{\n        if (!fontStyle) return \"400\";\n        const style = fontStyle.toLowerCase();\n        // Handle complex styles like \"Bold Italic\", \"Semibold Condensed\", etc.\n        if (style.includes(\"thin\")) return \"100\";\n        if (style.includes(\"extralight\") || style.includes(\"ultra light\")) return \"200\";\n        if (style.includes(\"light\")) return \"300\";\n        if (style.includes(\"medium\")) return \"500\";\n        if (style.includes(\"demibold\") || style.includes(\"semibold\")) return \"600\";\n        if (style.includes(\"bold\")) return \"700\";\n        if (style.includes(\"extrabold\") || style.includes(\"ultra bold\")) return \"800\";\n        if (style.includes(\"black\") || style.includes(\"heavy\")) return \"900\";\n        return \"400\"; // Regular/Normal\n    };\n    const getFontStyle = (fontStyle)=>{\n        if (!fontStyle || fontStyle === \"\" || fontStyle === \"Regular\" || fontStyle === \"normal\") {\n            return \"normal\";\n        }\n        const style = fontStyle.toLowerCase().trim();\n        // FIXED: More precise italic detection - only exact matches or explicit italic styles\n        const willBeItalic = style === \"italic\" || style === \"oblique\" || style.endsWith(\" italic\") || style.startsWith(\"italic \") || style === \"it\" || style.includes(\" italic \") || style.endsWith(\"-italic\") || style.startsWith(\"italic-\");\n        // DEBUG: Log when italic is being applied\n        if (willBeItalic) {\n            console.log(\"\\uD83C\\uDFA8 Font style applying ITALIC:\", {\n                input: fontStyle,\n                inputType: typeof fontStyle,\n                normalizedInput: style,\n                reason: \"Matched italic pattern\"\n            });\n        }\n        if (willBeItalic) {\n            return \"italic\";\n        }\n        // Default to normal for everything else (including Regular, Medium, Bold, etc.)\n        return \"normal\";\n    };\n    const extractTextDecorations = (formatting)=>{\n        const decorations = [];\n        // Check for underline\n        if (formatting.underline || formatting.characterStyle && formatting.characterStyle.toLowerCase().includes(\"underline\")) {\n            decorations.push(\"underline\");\n        }\n        // Check for strikethrough\n        if (formatting.strikethrough || formatting.strikeThrough || formatting.characterStyle && formatting.characterStyle.toLowerCase().includes(\"strikethrough\")) {\n            decorations.push(\"line-through\");\n        }\n        // Check for overline\n        if (formatting.overline || formatting.characterStyle && formatting.characterStyle.toLowerCase().includes(\"overline\")) {\n            decorations.push(\"overline\");\n        }\n        return decorations.length > 0 ? decorations.join(\" \") : \"none\";\n    };\n    const getTextAlign = (alignment)=>{\n        const alignments = {\n            LeftAlign: \"left\",\n            RightAlign: \"right\",\n            CenterAlign: \"center\",\n            LeftJustified: \"justify\",\n            RightJustified: \"justify\",\n            CenterJustified: \"center\",\n            FullyJustified: \"justify\"\n        };\n        return alignments[alignment] || \"left\";\n    };\n    // ENHANCED: Pixel-perfect text measurement using canvas for accuracy\n    const measureTextAccurately = (text, fontSize, fontFamily, fontWeight, fontStyle)=>{\n        // Create a canvas for precise text measurement\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        // Set font properties to match the text\n        ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n        const metrics = ctx.measureText(text);\n        const width = metrics.width;\n        const height = fontSize * 1.2; // Approximate height based on font size\n        return {\n            width,\n            height,\n            actualBounds: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n    };\n    // IMPROVED: Calculate text metrics with more generous spacing\n    const calculateTextMetrics = (text, fontSize, lineHeight, containerWidth, containerHeight, fontFamily = \"Arial\", fontWeight = \"normal\", fontStyle = \"normal\")=>{\n        if (!text) return {\n            willOverflow: false,\n            estimatedLines: 0,\n            estimatedTextHeight: 0\n        };\n        // Method 1: Canvas-based measurement (most accurate)\n        const canvasMetrics = measureTextAccurately(text, fontSize, fontFamily, fontWeight, fontStyle);\n        // IMPROVED: More generous line height calculation\n        let lineHeightPx;\n        if (typeof lineHeight === \"string\" && lineHeight.includes(\"px\")) {\n            lineHeightPx = parseFloat(lineHeight);\n        } else if (typeof lineHeight === \"number\") {\n            lineHeightPx = lineHeight * fontSize;\n        } else {\n            // Parse CSS line-height values like \"1.2\", \"1.5\", etc.\n            const numericLineHeight = parseFloat(lineHeight) || 1.2;\n            lineHeightPx = numericLineHeight * fontSize;\n        }\n        // FIXED: More accurate word-based wrapping like InDesign\n        const effectiveWidth = containerWidth - 4; // Account for padding\n        // Split text into words and measure actual width\n        const words = text.split(/\\s+/).filter((word)=>word.length > 0);\n        const lines = [];\n        let currentLine = \"\";\n        let currentLineWidth = 0;\n        // Create canvas context for accurate word measurement\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n        for(let i = 0; i < words.length; i++){\n            const word = words[i];\n            const wordWidth = ctx.measureText(word).width;\n            const spaceWidth = ctx.measureText(\" \").width;\n            // Check if adding this word would exceed the line width\n            const wordWithSpaceWidth = currentLine ? wordWidth + spaceWidth : wordWidth;\n            if (currentLine && currentLineWidth + wordWithSpaceWidth > effectiveWidth) {\n                // Start a new line\n                lines.push(currentLine);\n                currentLine = word;\n                currentLineWidth = wordWidth;\n            } else {\n                // Add word to current line\n                if (currentLine) {\n                    currentLine += \" \" + word;\n                    currentLineWidth += wordWithSpaceWidth;\n                } else {\n                    currentLine = word;\n                    currentLineWidth = wordWidth;\n                }\n            }\n        }\n        // Add the last line if it has content\n        if (currentLine) {\n            lines.push(currentLine);\n        }\n        const estimatedLines = Math.max(1, lines.length);\n        const estimatedTextHeight = estimatedLines * lineHeightPx;\n        // Account for padding in available height\n        const availableHeight = containerHeight - 4;\n        return {\n            estimatedLines,\n            estimatedTextHeight,\n            lineHeightPx,\n            availableHeight,\n            actualLines: lines,\n            willOverflow: estimatedTextHeight > availableHeight,\n            overfillRatio: estimatedTextHeight / availableHeight,\n            overflowSeverity: estimatedTextHeight > availableHeight * 1.5 ? \"severe\" : estimatedTextHeight > availableHeight * 1.2 ? \"moderate\" : \"minor\"\n        };\n    };\n    // ENHANCED: Multiple text fitting strategies for pixel-perfect display\n    const TEXT_FITTING_STRATEGIES = {\n        AUTO_SCALE: \"auto_scale\",\n        TRUNCATE: \"truncate\",\n        ALLOW_OVERFLOW: \"allow_overflow\",\n        PRECISE_FIT: \"precise_fit\",\n        COMPRESS_LINES: \"compress_lines\"\n    };\n    // Configuration - you can change this based on your preference\n    const [textFittingStrategy, setTextFittingStrategy] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(TEXT_FITTING_STRATEGIES.PRECISE_FIT);\n    const getOptimalTextStyles = (baseStyles, textMetrics, containerWidth, containerHeight, strategy = textFittingStrategy)=>{\n        if (!textMetrics.willOverflow) {\n            return {\n                styles: baseStyles,\n                wasAdjusted: false,\n                adjustmentDetails: null\n            };\n        }\n        const fontSize = parseFloat(baseStyles.fontSize);\n        const lineHeight = parseFloat(baseStyles.lineHeight);\n        switch(strategy){\n            case TEXT_FITTING_STRATEGIES.AUTO_SCALE:\n                {\n                    // Progressive font size reduction\n                    const maxReduction = textMetrics.overflowSeverity === \"severe\" ? 0.7 : textMetrics.overflowSeverity === \"moderate\" ? 0.8 : 0.9;\n                    const scaleFactor = Math.max(maxReduction, 1 / textMetrics.overfillRatio);\n                    return {\n                        styles: {\n                            ...baseStyles,\n                            fontSize: `${Math.max(8, fontSize * scaleFactor)}px`,\n                            lineHeight: Math.max(0.9, lineHeight * scaleFactor),\n                            overflow: \"hidden\"\n                        },\n                        wasAdjusted: true,\n                        adjustmentDetails: {\n                            type: \"font_scaled\",\n                            scaleFactor: scaleFactor,\n                            originalSize: fontSize,\n                            newSize: fontSize * scaleFactor\n                        }\n                    };\n                }\n            case TEXT_FITTING_STRATEGIES.TRUNCATE:\n                {\n                    // Calculate how many lines can fit\n                    const availableLines = Math.floor(textMetrics.availableHeight / textMetrics.lineHeightPx);\n                    const truncateAtLine = Math.max(1, availableLines);\n                    return {\n                        styles: {\n                            ...baseStyles,\n                            overflow: \"hidden\",\n                            textOverflow: \"ellipsis\",\n                            display: \"-webkit-box\",\n                            WebkitLineClamp: truncateAtLine,\n                            WebkitBoxOrient: \"vertical\",\n                            lineHeight: baseStyles.lineHeight\n                        },\n                        wasAdjusted: true,\n                        adjustmentDetails: {\n                            type: \"text_truncated\",\n                            visibleLines: truncateAtLine,\n                            totalLines: textMetrics.estimatedLines\n                        }\n                    };\n                }\n            case TEXT_FITTING_STRATEGIES.COMPRESS_LINES:\n                {\n                    // First try reducing line height, then font size if needed\n                    const targetHeight = textMetrics.availableHeight;\n                    const currentHeight = textMetrics.estimatedTextHeight;\n                    const compressionRatio = targetHeight / currentHeight;\n                    if (compressionRatio > 0.8) {\n                        // Just compress line height\n                        return {\n                            styles: {\n                                ...baseStyles,\n                                lineHeight: Math.max(0.8, lineHeight * compressionRatio),\n                                overflow: \"hidden\"\n                            },\n                            wasAdjusted: true,\n                            adjustmentDetails: {\n                                type: \"line_height_compressed\",\n                                originalLineHeight: lineHeight,\n                                newLineHeight: lineHeight * compressionRatio\n                            }\n                        };\n                    } else {\n                        // Compress both line height and font size\n                        const fontReduction = Math.max(0.8, compressionRatio);\n                        return {\n                            styles: {\n                                ...baseStyles,\n                                fontSize: `${fontSize * fontReduction}px`,\n                                lineHeight: Math.max(0.8, lineHeight * compressionRatio),\n                                overflow: \"hidden\"\n                            },\n                            wasAdjusted: true,\n                            adjustmentDetails: {\n                                type: \"full_compression\",\n                                fontReduction: fontReduction,\n                                lineHeightReduction: compressionRatio\n                            }\n                        };\n                    }\n                }\n            case TEXT_FITTING_STRATEGIES.PRECISE_FIT:\n                {\n                    // ENHANCED: More nuanced fitting approach\n                    const compressionNeeded = textMetrics.availableHeight / textMetrics.estimatedTextHeight;\n                    if (compressionNeeded >= 0.95) {\n                        // Text fits well, just ensure no overflow\n                        return {\n                            styles: {\n                                ...baseStyles,\n                                overflow: \"hidden\"\n                            },\n                            wasAdjusted: false,\n                            adjustmentDetails: {\n                                type: \"no_adjustment_needed\"\n                            }\n                        };\n                    } else if (compressionNeeded > 0.85) {\n                        // Minor adjustment - just reduce line height slightly\n                        const lineHeightReduction = Math.max(0.9, compressionNeeded * 1.05);\n                        return {\n                            styles: {\n                                ...baseStyles,\n                                lineHeight: Math.max(0.9, parseFloat(baseStyles.lineHeight) * lineHeightReduction),\n                                overflow: \"hidden\"\n                            },\n                            wasAdjusted: true,\n                            adjustmentDetails: {\n                                type: \"minor_line_height_adjustment\",\n                                lineHeightReduction,\n                                originalLineHeight: baseStyles.lineHeight\n                            }\n                        };\n                    } else if (compressionNeeded > 0.7) {\n                        // Moderate adjustment - compress both font and line height proportionally\n                        const fontScale = Math.max(0.9, Math.sqrt(compressionNeeded)); // Less aggressive font scaling\n                        const lineScale = Math.max(0.85, compressionNeeded / fontScale);\n                        return {\n                            styles: {\n                                ...baseStyles,\n                                fontSize: `${fontSize * fontScale}px`,\n                                lineHeight: Math.max(0.85, parseFloat(baseStyles.lineHeight) * lineScale),\n                                overflow: \"hidden\"\n                            },\n                            wasAdjusted: true,\n                            adjustmentDetails: {\n                                type: \"moderate_dual_adjustment\",\n                                fontScale,\n                                lineScale,\n                                compressionNeeded\n                            }\n                        };\n                    } else {\n                        // Major adjustment - apply reasonable compression then allow slight overflow\n                        const maxFontScale = 0.85; // Less aggressive than before\n                        const maxLineScale = 0.8; // Less aggressive than before\n                        return {\n                            styles: {\n                                ...baseStyles,\n                                fontSize: `${fontSize * maxFontScale}px`,\n                                lineHeight: Math.max(0.8, parseFloat(baseStyles.lineHeight) * maxLineScale),\n                                overflow: \"hidden\",\n                                // Allow some overflow rather than harsh truncation\n                                maxHeight: `${textMetrics.availableHeight}px`\n                            },\n                            wasAdjusted: true,\n                            adjustmentDetails: {\n                                type: \"major_adjustment_with_overflow\",\n                                fontScale: maxFontScale,\n                                lineScale: maxLineScale,\n                                allowedOverflow: true\n                            }\n                        };\n                    }\n                }\n            case TEXT_FITTING_STRATEGIES.ALLOW_OVERFLOW:\n            default:\n                {\n                    return {\n                        styles: {\n                            ...baseStyles,\n                            overflow: \"visible\"\n                        },\n                        wasAdjusted: false,\n                        adjustmentDetails: {\n                            type: \"overflow_allowed\"\n                        }\n                    };\n                }\n        }\n    };\n    const renderFormattedText = (story, containerHeight = null, adjustedFontSize = null)=>{\n        if (!story.formattedContent || !Array.isArray(story.formattedContent)) {\n            console.log(\"Text value:\", story.text); // Debug: check actual value before rendering\n            // Use CSS to preserve all whitespace and newlines\n            if (typeof story.text === \"string\") {\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    style: {\n                        whiteSpace: \"pre-line\",\n                        display: \"block\"\n                    },\n                    children: story.text\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                    lineNumber: 1037,\n                    columnNumber: 11\n                }, this);\n            }\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                children: story.text\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                lineNumber: 1047,\n                columnNumber: 14\n            }, this);\n        }\n        // DEBUG: Count line breaks in formatted content\n        const lineBreakCount = story.formattedContent.filter((item)=>item.formatting?.isBreak).length;\n        const consecutiveBreaks = [];\n        let currentBreakGroup = [];\n        story.formattedContent.forEach((item, index)=>{\n            if (item.formatting?.isBreak) {\n                currentBreakGroup.push({\n                    index,\n                    source: item.formatting.source,\n                    breakType: item.formatting.breakType\n                });\n            } else if (currentBreakGroup.length > 0) {\n                if (currentBreakGroup.length > 1) {\n                    consecutiveBreaks.push(currentBreakGroup);\n                }\n                currentBreakGroup = [];\n            }\n        });\n        if (currentBreakGroup.length > 1) {\n            consecutiveBreaks.push(currentBreakGroup);\n        }\n        console.log(`ðŸŽ¨ Rendering formatted text with ${lineBreakCount} total line breaks`);\n        if (consecutiveBreaks.length > 0) {\n            console.log(`ðŸŽ¨ Found ${consecutiveBreaks.length} groups of consecutive line breaks:`, consecutiveBreaks);\n        }\n        return story.formattedContent.map((content, index)=>{\n            // FIXED: Render ALL line breaks to preserve user's intended spacing\n            if (content.formatting?.isBreak) {\n                // Render any type of line break - don't filter based on source\n                console.log(`ðŸŽ¨ Rendering line break ${index}: source=${content.formatting.source}, type=${content.formatting.breakType}`);\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, index, false, {\n                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                    lineNumber: 1094,\n                    columnNumber: 18\n                }, this);\n            }\n            const formatting = content.formatting || {};\n            // CRITICAL FIX: Use adjusted font size if overflow prevention was applied\n            const originalFontSize = formatting.fontSize || story.styling?.fontSize || 12;\n            const fontSize = adjustedFontSize || originalFontSize;\n            // DEBUG: Log style resolution for any text with formatting applied (generic check)\n            const hasFormatting = formatting.fontStyle || formatting.characterStyle || formatting.paragraphStyle;\n            const finalFontStyle = getFontStyle(formatting.fontStyle);\n            if (hasFormatting || finalFontStyle === \"italic\") {\n                console.log(\"\\uD83C\\uDFA8 Style resolution for text:\", JSON.stringify(content.text?.substring(0, 20) + \"...\"), {\n                    rawFormatting: formatting,\n                    resolvedFontStyle: formatting.fontStyle,\n                    storyDefaultStyle: story.styling?.fontStyle,\n                    finalFontStyle: finalFontStyle,\n                    characterStyle: formatting.characterStyle,\n                    paragraphStyle: formatting.paragraphStyle\n                });\n                // WARN: Alert if italic is being applied when it shouldn't be\n                if (finalFontStyle === \"italic\" && (!formatting.fontStyle || formatting.fontStyle === \"Regular\")) {\n                    console.warn(\"âš ï¸  UNEXPECTED ITALIC: Text is being styled as italic but fontStyle is:\", formatting.fontStyle);\n                }\n            }\n            // IMPROVED: More generous line height calculation for individual spans\n            let lineHeight = \"inherit\"; // Inherit from parent container\n            if (formatting.effectiveLineHeight) {\n                lineHeight = formatting.effectiveLineHeight;\n            } else if (formatting.leading !== undefined) {\n                if (formatting.leading === \"auto\") {\n                    lineHeight = \"inherit\";\n                } else if (typeof formatting.leading === \"number\") {\n                    // IMPROVED: More generous line height range to prevent text chopping\n                    const ratio = formatting.leading / fontSize;\n                    lineHeight = Math.max(1.1, Math.min(2.5, ratio)); // More generous range\n                }\n            }\n            // ENHANCED: Use complete character styles if available\n            const completeStyles = formatting.completeStyles || {};\n            const style = {\n                fontSize: `${fontSize}px`,\n                fontFamily: formatting.fontFamily || story.styling?.fontFamily || \"Arial, sans-serif\",\n                // ENHANCED: Use complete style analysis for proper font weight/style\n                fontWeight: completeStyles.fontWeight || getFontWeight(formatting.fontStyle) || \"400\",\n                fontStyle: completeStyles.fontStyle || getFontStyle(formatting.fontStyle) || \"normal\",\n                color: convertColor(formatting.fillColor) || \"black\",\n                textAlign: getTextAlign(formatting.alignment),\n                lineHeight: lineHeight,\n                letterSpacing: formatting.tracking ? `${formatting.tracking / 1000}em` : \"normal\",\n                // ENHANCED: Complete text decoration support\n                textDecoration: completeStyles.textDecoration || extractTextDecorations(formatting),\n                // ENHANCED: Text effects\n                textTransform: completeStyles.textTransform || \"none\",\n                textShadow: completeStyles.textShadow || \"none\",\n                // FIXED: Remove margins that could cause spacing issues\n                margin: 0,\n                padding: 0,\n                // Only apply indentation if explicitly specified\n                ...formatting.leftIndent && {\n                    marginLeft: `${formatting.leftIndent}px`\n                },\n                ...formatting.rightIndent && {\n                    marginRight: `${formatting.rightIndent}px`\n                },\n                ...formatting.firstLineIndent && {\n                    textIndent: `${formatting.firstLineIndent}px`\n                },\n                ...formatting.spaceBefore && {\n                    marginTop: `${formatting.spaceBefore}px`\n                },\n                ...formatting.spaceAfter && {\n                    marginBottom: `${formatting.spaceAfter}px`\n                },\n                // ENHANCED: Advanced InDesign properties\n                ...completeStyles.baselineShift && {\n                    verticalAlign: `${completeStyles.baselineShift}px`\n                },\n                ...completeStyles.horizontalScale && completeStyles.horizontalScale !== 100 && {\n                    transform: `scaleX(${completeStyles.horizontalScale / 100})`\n                }\n            };\n            // CRITICAL FIX: Add space after span if needed to prevent word joining\n            const currentText = content.text || \"\";\n            const nextContent = story.formattedContent[index + 1];\n            const needsSpaceAfter = nextContent && !nextContent.formatting?.isBreak && !currentText.endsWith(\" \") && !currentText.endsWith(\"\\n\") && nextContent.text && !nextContent.text.startsWith(\" \") && !nextContent.text.startsWith(\"\\n\");\n            // DEBUG: Log space insertion for problematic text\n            if (currentText.includes(\"pa\") && nextContent?.text?.includes(\"voluptusda\") || currentText.includes(\"voluptusda\") && index > 0) {\n                console.log(`ðŸ”§ Space insertion check [${index}]:`, {\n                    currentText: JSON.stringify(currentText),\n                    nextText: nextContent ? JSON.stringify(nextContent.text) : \"none\",\n                    needsSpaceAfter,\n                    currentEndsWithSpace: currentText.endsWith(\" \"),\n                    nextStartsWithSpace: nextContent?.text?.startsWith(\" \")\n                });\n            }\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        style: style,\n                        children: content.text\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1246,\n                        columnNumber: 13\n                    }, this),\n                    needsSpaceAfter && \" \"\n                ]\n            }, index, true, {\n                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                lineNumber: 1245,\n                columnNumber: 11\n            }, this);\n        }).filter(Boolean); // Remove null entries from skipped line breaks\n    };\n    const getStoryStyles = (story, containerHeight = null, containerWidth = null)=>{\n        const styling = story.styling || {};\n        const fontSize = styling.fontSize || 12;\n        // IMPROVED: More generous line height calculation to prevent text chopping\n        let lineHeight = \"1.3\"; // More generous default CSS line-height\n        if (styling.effectiveLineHeight) {\n            lineHeight = styling.effectiveLineHeight;\n        } else if (styling.leading !== undefined) {\n            if (styling.leading === \"auto\") {\n                lineHeight = \"1.3\"; // More generous auto line height\n            } else if (typeof styling.leading === \"number\") {\n                // Convert InDesign points to CSS line-height ratio, more generous range\n                const ratio = styling.leading / fontSize;\n                lineHeight = Math.max(1.1, Math.min(2.5, ratio)).toString(); // More generous range\n            }\n        }\n        return {\n            fontSize: `${fontSize}px`,\n            fontFamily: styling.fontFamily || \"Arial, sans-serif\",\n            fontWeight: getFontWeight(styling.fontStyle),\n            fontStyle: getFontStyle(styling.fontStyle),\n            color: convertColor(styling.fillColor) || \"black\",\n            textAlign: getTextAlign(styling.alignment),\n            lineHeight: lineHeight,\n            letterSpacing: styling.tracking ? `${styling.tracking / 1000}em` : \"normal\",\n            // IMPROVED: Minimal padding to prevent container size conflicts\n            padding: \"1px 2px\",\n            margin: 0,\n            // FIXED: Use full container size, let CSS handle overflow properly\n            height: \"100%\",\n            width: \"100%\",\n            minHeight: `${fontSize * 1.4}px`,\n            wordWrap: \"break-word\",\n            overflow: \"visible\",\n            boxSizing: \"border-box\",\n            // IMPROVED: Better text layout handling\n            display: \"block\",\n            whiteSpace: \"pre-wrap\",\n            wordBreak: \"break-word\",\n            overflowWrap: \"break-word\",\n            // IMPROVED: Allow text to flow naturally\n            textOverflow: \"visible\",\n            lineClamp: \"none\"\n        };\n    };\n    // ENHANCED: Extract InDesign-accurate formatting for precise text measurement\n    const getInDesignAccurateFormatting = (story)=>{\n        const styling = story.styling || {};\n        const firstFormatted = story.formattedContent?.find((item)=>item.formatting && !item.formatting.isBreak);\n        const formatting = firstFormatted?.formatting || styling;\n        return {\n            fontSize: formatting.fontSize || styling.fontSize || 12,\n            fontFamily: formatting.fontFamily || styling.fontFamily || \"Arial, sans-serif\",\n            fontWeight: getFontWeight(formatting.fontStyle || styling.fontStyle),\n            fontStyle: getFontStyle(formatting.fontStyle || styling.fontStyle),\n            color: convertColor(formatting.fillColor || styling.fillColor) || \"black\",\n            textAlign: getTextAlign(formatting.alignment || styling.alignment),\n            // InDesign-specific properties for precise measurement\n            leading: formatting.leading || styling.leading || \"auto\",\n            leadingType: formatting.leadingType || styling.leadingType || \"auto\",\n            tracking: formatting.tracking || styling.tracking || 0,\n            baselineShift: formatting.baselineShift || 0,\n            // Text frame properties\n            firstBaselineOffset: formatting.firstBaselineOffset || \"AscentOffset\",\n            verticalJustification: formatting.verticalJustification || \"TopAlign\"\n        };\n    };\n    if (loading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                padding: \"20px\"\n            },\n            children: \"Loading document...\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n            lineNumber: 1347,\n            columnNumber: 12\n        }, this);\n    }\n    if (!documentData) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                padding: \"20px\"\n            },\n            children: \"Error loading document\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n            lineNumber: 1351,\n            columnNumber: 12\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            display: \"flex\",\n            height: \"100vh\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    width: \"400px\",\n                    backgroundColor: \"#f5f5f5\",\n                    padding: \"20px\",\n                    overflowY: \"auto\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            backgroundColor: \"#e3f2fd\",\n                            padding: \"12px\",\n                            borderRadius: \"6px\",\n                            marginBottom: \"16px\",\n                            border: \"1px solid #2196f3\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                style: {\n                                    margin: \"0 0 8px 0\",\n                                    color: \"#1976d2\",\n                                    fontSize: \"14px\"\n                                },\n                                children: \"\\uD83C\\uDFAF Text Fitting Strategy\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1375,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                value: textFittingStrategy,\n                                onChange: (e)=>setTextFittingStrategy(e.target.value),\n                                style: {\n                                    width: \"100%\",\n                                    padding: \"6px\",\n                                    borderRadius: \"4px\",\n                                    border: \"1px solid #ccc\",\n                                    fontSize: \"12px\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: TEXT_FITTING_STRATEGIES.PRECISE_FIT,\n                                        children: \"\\uD83C\\uDFAF Precise Fit (InDesign-style)\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1391,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: TEXT_FITTING_STRATEGIES.AUTO_SCALE,\n                                        children: \"\\uD83D\\uDCCF Auto Scale Font\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1394,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: TEXT_FITTING_STRATEGIES.TRUNCATE,\n                                        children: \"âœ‚ï¸ Truncate with Ellipsis\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1397,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: TEXT_FITTING_STRATEGIES.COMPRESS_LINES,\n                                        children: \"\\uD83D\\uDCCA Compress Line Height\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1400,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: TEXT_FITTING_STRATEGIES.ALLOW_OVERFLOW,\n                                        children: \"\\uD83C\\uDF0A Allow Overflow\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1403,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1380,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    fontSize: \"10px\",\n                                    color: \"#666\",\n                                    marginTop: \"4px\"\n                                },\n                                children: [\n                                    textFittingStrategy === TEXT_FITTING_STRATEGIES.PRECISE_FIT && \"Smart font & line height adjustment with truncation fallback\",\n                                    textFittingStrategy === TEXT_FITTING_STRATEGIES.AUTO_SCALE && \"Reduce font size proportionally to fit container\",\n                                    textFittingStrategy === TEXT_FITTING_STRATEGIES.TRUNCATE && \"Cut off text with ellipsis when it overflows\",\n                                    textFittingStrategy === TEXT_FITTING_STRATEGIES.COMPRESS_LINES && \"Reduce line height first, then font size\",\n                                    textFittingStrategy === TEXT_FITTING_STRATEGIES.ALLOW_OVERFLOW && \"Let text overflow naturally (original behavior)\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1407,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1366,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            backgroundColor: \"#fff3e0\",\n                            padding: \"12px\",\n                            borderRadius: \"6px\",\n                            marginBottom: \"16px\",\n                            border: \"1px solid #ff9800\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                style: {\n                                    margin: \"0 0 8px 0\",\n                                    color: \"#f57700\",\n                                    fontSize: \"14px\"\n                                },\n                                children: \"\\uD83C\\uDFA8 Background Color\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1431,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                value: backgroundConfig.mode,\n                                onChange: (e)=>setBackgroundConfig({\n                                        ...backgroundConfig,\n                                        mode: e.target.value\n                                    }),\n                                style: {\n                                    width: \"100%\",\n                                    padding: \"6px\",\n                                    borderRadius: \"4px\",\n                                    border: \"1px solid #ccc\",\n                                    fontSize: \"12px\",\n                                    marginBottom: \"8px\"\n                                },\n                                children: backgroundModes.map((mode)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: mode.value,\n                                        children: mode.label\n                                    }, mode.value, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1453,\n                                        columnNumber: 15\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1438,\n                                columnNumber: 11\n                            }, this),\n                            backgroundConfig.mode === \"custom\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    marginBottom: \"8px\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        style: {\n                                            fontSize: \"11px\",\n                                            color: \"#666\",\n                                            display: \"block\",\n                                            marginBottom: \"4px\"\n                                        },\n                                        children: \"Custom Color:\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1462,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"color\",\n                                        value: backgroundConfig.customColor,\n                                        onChange: (e)=>setBackgroundConfig({\n                                                ...backgroundConfig,\n                                                customColor: e.target.value\n                                            }),\n                                        style: {\n                                            width: \"100%\",\n                                            height: \"30px\",\n                                            border: \"1px solid #ccc\",\n                                            borderRadius: \"4px\"\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1472,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1461,\n                                columnNumber: 13\n                            }, this),\n                            backgroundConfig.mode === \"auto\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    fontSize: \"11px\",\n                                    marginTop: \"8px\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            marginBottom: \"4px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"checkbox\",\n                                                checked: backgroundConfig.preferPaperColor,\n                                                onChange: (e)=>setBackgroundConfig({\n                                                        ...backgroundConfig,\n                                                        preferPaperColor: e.target.checked\n                                                    }),\n                                                style: {\n                                                    marginRight: \"6px\"\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1501,\n                                                columnNumber: 17\n                                            }, this),\n                                            \"Prefer Paper color\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1494,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            marginBottom: \"4px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"checkbox\",\n                                                checked: backgroundConfig.allowColorAnalysis,\n                                                onChange: (e)=>setBackgroundConfig({\n                                                        ...backgroundConfig,\n                                                        allowColorAnalysis: e.target.checked\n                                                    }),\n                                                style: {\n                                                    marginRight: \"6px\"\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1521,\n                                                columnNumber: 17\n                                            }, this),\n                                            \"Allow color analysis\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1514,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"checkbox\",\n                                                checked: backgroundConfig.fallbackToWhite,\n                                                onChange: (e)=>setBackgroundConfig({\n                                                        ...backgroundConfig,\n                                                        fallbackToWhite: e.target.checked\n                                                    }),\n                                                style: {\n                                                    marginRight: \"6px\"\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1535,\n                                                columnNumber: 17\n                                            }, this),\n                                            \"Fallback to white\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1534,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1493,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    marginTop: \"8px\",\n                                    padding: \"6px\",\n                                    backgroundColor: \"#f5f5f5\",\n                                    borderRadius: \"3px\",\n                                    fontSize: \"11px\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                        children: \"Current:\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1561,\n                                        columnNumber: 13\n                                    }, this),\n                                    \" \",\n                                    documentData ? getDocumentBackgroundColor(documentData) : \"Loading...\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1552,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1422,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            backgroundColor: \"#f0f8ff\",\n                            padding: \"12px\",\n                            borderRadius: \"4px\",\n                            marginBottom: \"16px\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                style: {\n                                    margin: \"0 0 8px 0\",\n                                    fontSize: \"14px\",\n                                    color: \"#333\"\n                                },\n                                children: \"\\uD83D\\uDD27 View Controls\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1577,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    display: \"flex\",\n                                    flexDirection: \"column\",\n                                    gap: \"8px\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            fontSize: \"12px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"checkbox\",\n                                                checked: showMargins,\n                                                onChange: (e)=>setShowMargins(e.target.checked),\n                                                style: {\n                                                    marginRight: \"8px\"\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1589,\n                                                columnNumber: 15\n                                            }, this),\n                                            \"Show Page Margins (dotted lines)\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1582,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            fontSize: \"12px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"checkbox\",\n                                                checked: showDebugInfo,\n                                                onChange: (e)=>setShowDebugInfo(e.target.checked),\n                                                style: {\n                                                    marginRight: \"8px\"\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1605,\n                                                columnNumber: 15\n                                            }, this),\n                                            \"Show Debug Information\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1598,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1581,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1569,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            backgroundColor: \"#f9f9f9\",\n                            padding: \"8px\",\n                            borderRadius: \"4px\",\n                            marginBottom: \"16px\",\n                            fontSize: \"11px\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    fontWeight: \"bold\",\n                                    marginBottom: \"6px\"\n                                },\n                                children: \"\\uD83D\\uDCCA Status Indicators:\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1626,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    display: \"flex\",\n                                    flexWrap: \"wrap\",\n                                    gap: \"8px\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            gap: \"2px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                style: {\n                                                    backgroundColor: \"#4caf50\",\n                                                    color: \"white\",\n                                                    padding: \"1px 3px\",\n                                                    borderRadius: \"2px\"\n                                                },\n                                                children: \"\\uD83C\\uDFAF\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1631,\n                                                columnNumber: 15\n                                            }, this),\n                                            \"Precise Fit\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1630,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            gap: \"2px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                style: {\n                                                    backgroundColor: \"#2196f3\",\n                                                    color: \"white\",\n                                                    padding: \"1px 3px\",\n                                                    borderRadius: \"2px\"\n                                                },\n                                                children: \"\\uD83D\\uDCCF\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1644,\n                                                columnNumber: 15\n                                            }, this),\n                                            \"Font Scaled\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1643,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            gap: \"2px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                style: {\n                                                    backgroundColor: \"#ff9800\",\n                                                    color: \"white\",\n                                                    padding: \"1px 3px\",\n                                                    borderRadius: \"2px\"\n                                                },\n                                                children: \"âœ‚ï¸\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1657,\n                                                columnNumber: 15\n                                            }, this),\n                                            \"Truncated\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1656,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1629,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    display: \"flex\",\n                                    flexWrap: \"wrap\",\n                                    gap: \"8px\",\n                                    marginTop: \"4px\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            gap: \"2px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                style: {\n                                                    backgroundColor: \"#f44336\",\n                                                    color: \"white\",\n                                                    padding: \"1px 2px\",\n                                                    borderRadius: \"1px\",\n                                                    fontSize: \"9px\"\n                                                },\n                                                children: \"S\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1679,\n                                                columnNumber: 15\n                                            }, this),\n                                            \"Severe overflow\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1678,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            gap: \"2px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                style: {\n                                                    backgroundColor: \"#ff9800\",\n                                                    color: \"white\",\n                                                    padding: \"1px 2px\",\n                                                    borderRadius: \"1px\",\n                                                    fontSize: \"9px\"\n                                                },\n                                                children: \"M\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1693,\n                                                columnNumber: 15\n                                            }, this),\n                                            \"Moderate\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1692,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            gap: \"2px\"\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                style: {\n                                                    backgroundColor: \"#ffeb3b\",\n                                                    color: \"black\",\n                                                    padding: \"1px 2px\",\n                                                    borderRadius: \"1px\",\n                                                    fontSize: \"9px\"\n                                                },\n                                                children: \"L\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 1707,\n                                                columnNumber: 15\n                                            }, this),\n                                            \"Light\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 1706,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1670,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1617,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        children: \"Document Info\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1723,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            \"Version: \",\n                            documentData.document?.version\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1724,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            \"Pages: \",\n                            documentData.document?.pageCount\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1725,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            \"Size:\",\n                            \" \",\n                            Math.round(documentData.pageInfo?.dimensions?.pixelDimensions?.width || documentData.pageInfo?.dimensions?.width || 0),\n                            \" \",\n                            \"\\xd7\",\n                            \" \",\n                            Math.round(documentData.pageInfo?.dimensions?.pixelDimensions?.height || documentData.pageInfo?.dimensions?.height || 0),\n                            \"px\",\n                            documentData.pageInfo?.dimensions?.pixelDimensions && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    fontSize: \"12px\",\n                                    color: \"#666\",\n                                    display: \"block\"\n                                },\n                                children: [\n                                    \"(Original: \",\n                                    Math.round(documentData.pageInfo.dimensions.width),\n                                    \" \\xd7\",\n                                    \" \",\n                                    Math.round(documentData.pageInfo.dimensions.height),\n                                    \" \",\n                                    documentData.pageInfo.dimensions.units,\n                                    \")\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1741,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1726,\n                        columnNumber: 9\n                    }, this),\n                    documentData.unitConversion && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            marginTop: \"10px\",\n                            padding: \"8px\",\n                            backgroundColor: \"#e8f4fd\",\n                            borderRadius: \"4px\",\n                            fontSize: \"12px\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                children: \"\\uD83D\\uDCD0 Unit Conversion:\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1760,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1761,\n                                columnNumber: 13\n                            }, this),\n                            \"Status:\",\n                            \" \",\n                            documentData.unitConversion.enabled ? \"âœ… Enabled\" : \"âŒ Disabled\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1764,\n                                columnNumber: 13\n                            }, this),\n                            \"DPI: \",\n                            documentData.unitConversion.dpi,\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1766,\n                                columnNumber: 13\n                            }, this),\n                            \"Original: \",\n                            documentData.unitConversion.originalUnits,\n                            \" â†’ Pixels\",\n                            documentData.unitConversion.convertedToPixels && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    color: \"#28a745\",\n                                    fontWeight: \"bold\"\n                                },\n                                children: \" âœ…\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1769,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1751,\n                        columnNumber: 11\n                    }, this),\n                    documentData.pageInfo?.margins && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            marginTop: \"10px\",\n                            padding: \"8px\",\n                            backgroundColor: \"#fff3cd\",\n                            borderRadius: \"4px\",\n                            fontSize: \"11px\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                children: \"\\uD83D\\uDCCF Positioning Debug:\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1785,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1786,\n                                columnNumber: 13\n                            }, this),\n                            \"Page:\",\n                            \" \",\n                            Math.round(documentData.pageInfo.dimensions?.pixelDimensions?.width || documentData.pageInfo.dimensions?.width || 0),\n                            \" \",\n                            \"\\xd7\",\n                            \" \",\n                            Math.round(documentData.pageInfo.dimensions?.pixelDimensions?.height || documentData.pageInfo.dimensions?.height || 0),\n                            \"px\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1800,\n                                columnNumber: 13\n                            }, this),\n                            \"Margins (px): T:\",\n                            documentData.pageInfo.margins.pixelMargins?.top || documentData.pageInfo.margins.top || 0,\n                            \"R:\",\n                            documentData.pageInfo.margins.pixelMargins?.right || documentData.pageInfo.margins.right || 0,\n                            \"B:\",\n                            documentData.pageInfo.margins.pixelMargins?.bottom || documentData.pageInfo.margins.bottom || 0,\n                            \"L:\",\n                            documentData.pageInfo.margins.pixelMargins?.left || documentData.pageInfo.margins.left || 0,\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1817,\n                                columnNumber: 13\n                            }, this),\n                            \"Content Area:\",\n                            \" \",\n                            Math.round((documentData.pageInfo.dimensions?.pixelDimensions?.width || documentData.pageInfo.dimensions?.width || 0) - (documentData.pageInfo.margins.pixelMargins?.left || documentData.pageInfo.margins.left || 0) - (documentData.pageInfo.margins.pixelMargins?.right || documentData.pageInfo.margins.right || 0)),\n                            \" \",\n                            \"\\xd7\",\n                            \" \",\n                            Math.round((documentData.pageInfo.dimensions?.pixelDimensions?.height || documentData.pageInfo.dimensions?.height || 0) - (documentData.pageInfo.margins.pixelMargins?.top || documentData.pageInfo.margins.top || 0) - (documentData.pageInfo.margins.pixelMargins?.bottom || documentData.pageInfo.margins.bottom || 0)),\n                            \"px\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1776,\n                        columnNumber: 11\n                    }, this),\n                    documentData.packageInfo && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            marginTop: \"10px\",\n                            padding: \"8px\",\n                            backgroundColor: \"#e9ecef\",\n                            borderRadius: \"4px\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                children: \"Package Info:\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1856,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1857,\n                                columnNumber: 13\n                            }, this),\n                            \"Links: \",\n                            documentData.packageInfo.linksCount,\n                            \" \",\n                            documentData.packageInfo.hasLinks ? \"âœ…\" : \"âŒ\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 1860,\n                                columnNumber: 13\n                            }, this),\n                            \"Fonts: \",\n                            documentData.packageInfo.fontsCount,\n                            \" \",\n                            documentData.packageInfo.hasFonts ? \"âœ…\" : \"âŒ\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1848,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        style: {\n                            marginTop: \"20px\"\n                        },\n                        children: [\n                            \"Elements (\",\n                            documentData.elements?.length || 0,\n                            \")\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1866,\n                        columnNumber: 9\n                    }, this),\n                    (documentData.elements || []).map((element, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            onClick: ()=>setSelectedElement(element),\n                            style: {\n                                padding: \"8px\",\n                                margin: \"4px 0\",\n                                backgroundColor: selectedElement?.id === element.id ? \"#007bff\" : \"white\",\n                                color: selectedElement?.id === element.id ? \"white\" : \"black\",\n                                border: \"1px solid #ddd\",\n                                cursor: \"pointer\",\n                                fontSize: \"12px\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: element.type\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1884,\n                                    columnNumber: 13\n                                }, this),\n                                \" (\",\n                                element.id,\n                                \")\",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1885,\n                                    columnNumber: 13\n                                }, this),\n                                element.name !== \"$ID/\" ? element.name : `${element.type}_${element.id}`,\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1889,\n                                    columnNumber: 13\n                                }, this),\n                                \"Pos: (\",\n                                Math.round((element.pixelPosition || element.position).x),\n                                \", \",\n                                Math.round((element.pixelPosition || element.position).y),\n                                \")px\",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1893,\n                                    columnNumber: 13\n                                }, this),\n                                \"Size:\",\n                                \" \",\n                                Math.round((element.pixelPosition || element.position).width),\n                                \" \\xd7\",\n                                \" \",\n                                Math.round((element.pixelPosition || element.position).height),\n                                \"px\",\n                                element.isContentFrame && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1901,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            style: {\n                                                color: \"#ffc107\"\n                                            },\n                                            children: \"\\uD83D\\uDDBCï¸ Content Frame\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1902,\n                                            columnNumber: 17\n                                        }, this),\n                                        element.placedContent && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 1905,\n                                                    columnNumber: 21\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    style: {\n                                                        fontSize: \"10px\",\n                                                        color: \"#6c757d\"\n                                                    },\n                                                    children: [\n                                                        \"Type: \",\n                                                        element.placedContent.imageTypeName,\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                            lineNumber: 1908,\n                                                            columnNumber: 23\n                                                        }, this),\n                                                        \"PPI: \",\n                                                        element.placedContent.actualPpi,\n                                                        \" â†’\",\n                                                        \" \",\n                                                        element.placedContent.effectivePpi,\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                            lineNumber: 1911,\n                                                            columnNumber: 23\n                                                        }, this),\n                                                        \"Scale:\",\n                                                        \" \",\n                                                        Math.round((element.placedContent.transform?.a || 1) * 100),\n                                                        \"%\"\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 1906,\n                                                    columnNumber: 21\n                                                }, this)\n                                            ]\n                                        }, void 0, true)\n                                    ]\n                                }, void 0, true),\n                                element.parentStory && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1924,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            style: {\n                                                color: \"#17a2b8\"\n                                            },\n                                            children: [\n                                                \"\\uD83D\\uDCDD Story: \",\n                                                element.parentStory\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1925,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true)\n                            ]\n                        }, element.id, true, {\n                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                            lineNumber: 1870,\n                            columnNumber: 11\n                        }, this)),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        style: {\n                            marginTop: \"20px\"\n                        },\n                        children: \"Stories & Formatting\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                        lineNumber: 1933,\n                        columnNumber: 9\n                    }, this),\n                    Object.keys(documentData.stories || {}).map((storyId)=>{\n                        const story = documentData.stories[storyId];\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                padding: \"8px\",\n                                margin: \"4px 0\",\n                                backgroundColor: \"red\",\n                                border: \"1px solid #ddd\",\n                                fontSize: \"12px\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: storyId\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1947,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1948,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: \"Text:\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1949,\n                                    columnNumber: 15\n                                }, this),\n                                ' \"',\n                                story.text?.substring(0, 50) || \"\",\n                                '...\"',\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1950,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: \"Words:\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1951,\n                                    columnNumber: 15\n                                }, this),\n                                \" \",\n                                story.wordCount,\n                                \" |\",\n                                \" \",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: \"Chars:\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1952,\n                                    columnNumber: 15\n                                }, this),\n                                \" \",\n                                story.characterCount,\n                                story.styling && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    style: {\n                                        marginTop: \"8px\",\n                                        padding: \"4px\",\n                                        backgroundColor: \"#f8f9fa\",\n                                        borderRadius: \"2px\"\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"Styling:\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1963,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1964,\n                                            columnNumber: 19\n                                        }, this),\n                                        \"Font: \",\n                                        story.styling.fontFamily,\n                                        \" \",\n                                        story.styling.fontStyle,\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1966,\n                                            columnNumber: 19\n                                        }, this),\n                                        \"Size: \",\n                                        story.styling.fontSize,\n                                        \"px\",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1968,\n                                            columnNumber: 19\n                                        }, this),\n                                        \"Align: \",\n                                        story.styling.alignment,\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1970,\n                                            columnNumber: 19\n                                        }, this),\n                                        \"Color:\",\n                                        \" \",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            style: {\n                                                backgroundColor: convertColor(story.styling.fillColor),\n                                                padding: \"2px 4px\",\n                                                color: \"white\",\n                                                fontSize: \"10px\",\n                                                borderRadius: \"2px\"\n                                            },\n                                            children: story.styling.fillColor\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1972,\n                                            columnNumber: 19\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1955,\n                                    columnNumber: 17\n                                }, this),\n                                story.formattedContent && story.formattedContent.length > 1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    style: {\n                                        marginTop: \"8px\",\n                                        padding: \"4px\",\n                                        backgroundColor: \"#fff3cd\",\n                                        borderRadius: \"2px\"\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"Rich Formatting:\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1995,\n                                            columnNumber: 19\n                                        }, this),\n                                        \" \",\n                                        story.formattedContent.length,\n                                        \" segments\",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 1997,\n                                            columnNumber: 19\n                                        }, this),\n                                        \"Line Breaks: \",\n                                        story.lineBreakCount\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 1987,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, storyId, true, {\n                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                            lineNumber: 1937,\n                            columnNumber: 13\n                        }, this);\n                    })\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                lineNumber: 1357,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: \"flex\",\n                    flex: 1,\n                    justifyContent: \"center\",\n                    alignItems: \"flex-start\",\n                    padding: \"20px\",\n                    overflow: \"auto\",\n                    backgroundColor: \"#e9ecef\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        position: \"relative\",\n                        width: (documentData.pageInfo?.dimensions?.pixelDimensions?.width || documentData.pageInfo?.dimensions?.width || 612) + \"px\",\n                        height: (documentData.pageInfo?.dimensions?.pixelDimensions?.height || documentData.pageInfo?.dimensions?.height || 792) + \"px\",\n                        backgroundColor: (()=>{\n                            const bgColor = getDocumentBackgroundColor(documentData);\n                            console.log(\"\\uD83C\\uDFA8 Final background color being applied to DOCUMENT CANVAS only:\", bgColor);\n                            return bgColor;\n                        })(),\n                        margin: \"0 auto\",\n                        border: \"1px solid #ccc\",\n                        boxShadow: \"0 4px 8px rgba(0,0,0,0.1)\",\n                        overflow: \"hidden\",\n                        // FIXED: Ensure this container is clearly distinct from the outer background\n                        borderRadius: \"2px\"\n                    },\n                    children: [\n                        (()=>{\n                            // DEBUG: Log page dimensions and margins\n                            const pageWidth = documentData.pageInfo?.dimensions?.pixelDimensions?.width || documentData.pageInfo?.dimensions?.width || 612;\n                            const pageHeight = documentData.pageInfo?.dimensions?.pixelDimensions?.height || documentData.pageInfo?.dimensions?.height || 792;\n                            const marginLeft = documentData.pageInfo?.margins?.pixelMargins?.left || documentData.pageInfo?.margins?.left || 0;\n                            const marginTop = documentData.pageInfo?.margins?.pixelMargins?.top || documentData.pageInfo?.margins?.top || 0;\n                            const marginRight = documentData.pageInfo?.margins?.pixelMargins?.right || documentData.pageInfo?.margins?.right || 0;\n                            const marginBottom = documentData.pageInfo?.margins?.pixelMargins?.bottom || documentData.pageInfo?.margins?.bottom || 0;\n                            if (showDebugInfo) {\n                                console.log(\"\\uD83D\\uDCD0 PAGE DIMENSIONS DEBUG:\");\n                                console.log(`   ðŸ“ Page size: ${pageWidth} Ã— ${pageHeight}px`);\n                                console.log(`   ðŸ“ Margins: top=${marginTop}, right=${marginRight}, bottom=${marginBottom}, left=${marginLeft}`);\n                                console.log(`   ðŸ“ Content area: ${pageWidth - marginLeft - marginRight} Ã— ${pageHeight - marginTop - marginBottom}px`);\n                                console.log(`   ðŸ“ Dotted border position: top=${marginTop}, left=${marginLeft}, right=${marginRight}, bottom=${marginBottom}`);\n                            }\n                            return null; // This is just for debugging, return nothing\n                        })(),\n                        showMargins && documentData.pageInfo?.margins && (()=>{\n                            const visualMarginTop = documentData.pageInfo.margins.pixelMargins?.top || documentData.pageInfo.margins.top || 0;\n                            const visualMarginLeft = documentData.pageInfo.margins.pixelMargins?.left || documentData.pageInfo.margins.left || 0;\n                            const visualMarginRight = documentData.pageInfo.margins.pixelMargins?.right || documentData.pageInfo.margins.right || 0;\n                            const visualMarginBottom = documentData.pageInfo.margins.pixelMargins?.bottom || documentData.pageInfo.margins.bottom || 0;\n                            if (showDebugInfo) {\n                                console.log(\"\\uD83D\\uDCD0 MARGIN VISUALIZATION:\", {\n                                    top: visualMarginTop,\n                                    left: visualMarginLeft,\n                                    right: visualMarginRight,\n                                    bottom: visualMarginBottom\n                                });\n                            }\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    position: \"absolute\",\n                                    top: visualMarginTop + \"px\",\n                                    left: visualMarginLeft + \"px\",\n                                    right: visualMarginRight + \"px\",\n                                    bottom: visualMarginBottom + \"px\",\n                                    border: \"3px dashed rgba(255, 0, 0, 0.4)\",\n                                    pointerEvents: \"none\",\n                                    zIndex: 100\n                                }\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 2122,\n                                columnNumber: 17\n                            }, this);\n                        })(),\n                        (documentData.elements || []).map((element, index)=>{\n                            // ENFORCED: Only use pixelPosition (in pixels) for rendering\n                            if (!element.pixelPosition) {\n                                console.warn(`âš ï¸ Skipping element ${element.id} because pixelPosition is missing!`);\n                                return null;\n                            }\n                            const elementPosition = element.pixelPosition;\n                            const isContentFrame = element.isContentFrame || element.hasPlacedContent;\n                            const hasPlacedContent = element.placedContent;\n                            // FIXED: Remove margin application - margins are for visual guidelines only\n                            // Element positions should be exactly as calculated from IDML coordinates\n                            // Margins in the UI are just dotted lines showing the content area\n                            if (showDebugInfo) {\n                                console.log(\"\\uD83E\\uDDF1 Element positioning:\", element.id, \"Type:\", element.type, \"Position source:\", element.pixelPosition ? \"pixelPosition\" : \"position\", \"Final coords:\", {\n                                    x: elementPosition.x,\n                                    y: elementPosition.y,\n                                    width: elementPosition.width,\n                                    height: elementPosition.height\n                                }, \"Conversion info:\", element.position?._conversionInfo);\n                            }\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                onClick: ()=>setSelectedElement(element),\n                                style: {\n                                    position: \"absolute\",\n                                    // FIXED: Use element position directly without any margin offsets\n                                    // This ensures pixel-perfect positioning matching InDesign layout\n                                    left: elementPosition.x + \"px\",\n                                    top: elementPosition.y + \"px\",\n                                    width: elementPosition.width + \"px\",\n                                    height: elementPosition.height + \"px\",\n                                    backgroundColor: element.fill ? convertColor(element.fill) : \"transparent\",\n                                    border: selectedElement?.id === element.id ? \"2px solid #007bff\" : isContentFrame ? \"2px solid #00aaff\" : element.type === \"TextFrame\" ? \"1px solid #ff6b6b\" : \"1px dashed rgba(0,0,0,0.3)\",\n                                    cursor: \"pointer\",\n                                    overflow: \"visible\",\n                                    transform: elementPosition.rotation ? `rotate(${elementPosition.rotation}deg)` : undefined,\n                                    transformOrigin: \"center center\",\n                                    zIndex: index,\n                                    boxSizing: \"border-box\",\n                                    boxShadow: isContentFrame ? \"0 0 0 1px rgba(0, 170, 255, 0.3)\" : \"none\"\n                                },\n                                title: `${element.type} (${element.id})${isContentFrame ? \" - Content Frame\" : \"\"}$[PIXEL ONLY]`,\n                                children: [\n                                    showDebugInfo && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        style: {\n                                            position: \"absolute\",\n                                            top: \"-20px\",\n                                            left: \"0px\",\n                                            fontSize: \"10px\",\n                                            background: \"rgba(255, 255, 0, 0.8)\",\n                                            padding: \"2px 4px\",\n                                            borderRadius: \"2px\",\n                                            pointerEvents: \"none\",\n                                            zIndex: 1000,\n                                            whiteSpace: \"nowrap\"\n                                        },\n                                        children: [\n                                            element.id,\n                                            \": (\",\n                                            Math.round(elementPosition.x),\n                                            \",\",\n                                            \" \",\n                                            Math.round(elementPosition.y),\n                                            \")\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 2214,\n                                        columnNumber: 19\n                                    }, this),\n                                    element.linkedImage && (element.linkedImage.url ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                        src: element.linkedImage.url,\n                                        alt: \"Frame content\",\n                                        style: {\n                                            position: \"absolute\",\n                                            left: \"0px\",\n                                            top: \"0px\",\n                                            width: \"100%\",\n                                            height: \"100%\",\n                                            objectFit: \"cover\",\n                                            transformOrigin: \"center center\"\n                                        },\n                                        onError: (e)=>{\n                                            console.error(\"Error loading image:\", e);\n                                            e.target.style.display = \"none\";\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 2236,\n                                        columnNumber: 21\n                                    }, this) : element.linkedImage.isEmbedded ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        style: {\n                                            position: \"absolute\",\n                                            left: \"0px\",\n                                            top: \"0px\",\n                                            width: \"100%\",\n                                            height: \"100%\",\n                                            backgroundColor: \"#f0f0f0\",\n                                            border: \"2px solid #007bff\",\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            justifyContent: \"center\",\n                                            fontSize: \"12px\",\n                                            color: \"#007bff\",\n                                            flexDirection: \"column\"\n                                        },\n                                        children: [\n                                            \"\\uD83D\\uDDBCï¸ Embedded Image\",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 2272,\n                                                columnNumber: 23\n                                            }, this),\n                                            \"No image data\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 2254,\n                                        columnNumber: 21\n                                    }, this) : null),\n                                    element.type === \"TextFrame\" && element.parentStory && documentData.stories[element.parentStory] && (()=>{\n                                        const story = documentData.stories[element.parentStory];\n                                        // ENHANCED: Calculate precise text frame metrics using InDesign-compatible system\n                                        const frameMetrics = _lib_index_js__WEBPACK_IMPORTED_MODULE_3__.InDesignTextMetrics.calculateTextFrameInsets(element, element.textFramePreferences);\n                                        // Get story formatting with InDesign-accurate properties\n                                        const storyFormatting = getInDesignAccurateFormatting(story);\n                                        // Clean text to remove excessive line breaks that could cause overflow\n                                        const cleanText = (story.text || \"\").replace(/\\n\\s*\\n/g, \"\\n\").trim();\n                                        // ENHANCED: Use InDesign-accurate text measurement\n                                        const textMeasurement = _lib_index_js__WEBPACK_IMPORTED_MODULE_3__.InDesignTextMetrics.measureTextPrecisely(cleanText, storyFormatting, frameMetrics);\n                                        // IMPROVED: Generate CSS styles with full container dimensions\n                                        let finalStyles = getStoryStyles(story, element.position.height, element.position.width);\n                                        let wasAdjusted = false;\n                                        let adjustmentDetails = null;\n                                        // IMPROVED: Use full container dimensions for overflow detection (in pixels)\n                                        const containerWidth = elementPosition.width; // Use full width in pixels\n                                        const containerHeight = elementPosition.height; // Use full height in pixels // Use full height\n                                        // TEMPORARILY DISABLED: Apply overflow prevention if needed (may be causing text chopping)\n                                        if (false) {}\n                                        // Extract adjusted font size for text spans\n                                        const adjustedFontSize = wasAdjusted && adjustmentDetails ? adjustmentDetails.newFontSize : null;\n                                        const createTooltip = ()=>{\n                                            const baseInfo = `Story: ${element.parentStory}\\nFrame: ${element.position.width}Ã—${element.position.height}px\\nContent: ${frameMetrics.contentArea.width}Ã—${frameMetrics.contentArea.height}px`;\n                                            if (!wasAdjusted) {\n                                                return `${baseInfo}\\nText fits perfectly! âœ…`;\n                                            }\n                                            return `${baseInfo}\\nAdjusted: ${adjustmentDetails.adjustmentType}\\nFont: ${adjustmentDetails.originalFontSize}px â†’ ${adjustmentDetails.newFontSize}px\\nScale: ${(adjustmentDetails.scaleFactor * 100).toFixed(1)}%`;\n                                        };\n                                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            style: {\n                                                // HYBRID APPROACH: Use full frame size but apply insets as padding\n                                                position: \"absolute\",\n                                                top: \"0px\",\n                                                left: \"0px\",\n                                                width: `${elementPosition.width}px`,\n                                                height: `${elementPosition.height}px`,\n                                                // HYBRID: Apply insets as padding to create visual spacing without reducing text area too much\n                                                padding: `${frameMetrics.insets.top}px ${frameMetrics.insets.right}px ${frameMetrics.insets.bottom}px ${frameMetrics.insets.left}px`,\n                                                // Text styling from story\n                                                fontSize: `${finalStyles.fontSize}`,\n                                                fontFamily: finalStyles.fontFamily,\n                                                fontWeight: finalStyles.fontWeight,\n                                                fontStyle: finalStyles.fontStyle,\n                                                color: finalStyles.color,\n                                                textAlign: finalStyles.textAlign,\n                                                lineHeight: finalStyles.lineHeight,\n                                                letterSpacing: finalStyles.letterSpacing,\n                                                margin: 0,\n                                                // Text layout - allow overflow to prevent chopping\n                                                display: \"block\",\n                                                whiteSpace: \"pre-wrap\",\n                                                wordBreak: \"break-word\",\n                                                overflowWrap: \"break-word\",\n                                                overflow: \"visible\",\n                                                boxSizing: \"border-box\"\n                                            },\n                                            title: createTooltip(),\n                                            children: [\n                                                renderFormattedText(story, element.position.height, adjustedFontSize),\n                                                wasAdjusted && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    style: {\n                                                        position: \"absolute\",\n                                                        top: \"-2px\",\n                                                        left: \"-2px\",\n                                                        backgroundColor: adjustmentDetails?.stillOverflows ? \"#ff5722\" : \"#4caf50\",\n                                                        color: \"white\",\n                                                        fontSize: \"8px\",\n                                                        padding: \"1px 3px\",\n                                                        borderRadius: \"2px\",\n                                                        zIndex: 1000,\n                                                        pointerEvents: \"none\",\n                                                        fontFamily: \"monospace\"\n                                                    },\n                                                    children: adjustmentDetails?.stillOverflows ? \"âš ï¸\" : \"\\uD83C\\uDFAF\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 2415,\n                                                    columnNumber: 27\n                                                }, this),\n                                                !wasAdjusted && !textMeasurement.willOverflow && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    style: {\n                                                        position: \"absolute\",\n                                                        top: \"-2px\",\n                                                        right: \"-2px\",\n                                                        backgroundColor: \"#2e7d32\",\n                                                        color: \"white\",\n                                                        fontSize: \"8px\",\n                                                        padding: \"1px 3px\",\n                                                        borderRadius: \"2px\",\n                                                        zIndex: 1000,\n                                                        pointerEvents: \"none\",\n                                                        fontFamily: \"monospace\"\n                                                    },\n                                                    children: \"âœ…\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 2438,\n                                                    columnNumber: 27\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2373,\n                                            columnNumber: 23\n                                        }, this);\n                                    })(),\n                                    isContentFrame && !hasPlacedContent && !element.linkedImage?.isEmbedded && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        style: {\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            justifyContent: \"center\",\n                                            height: \"100%\",\n                                            fontSize: \"12px\",\n                                            color: \"#666\",\n                                            backgroundColor: \"rgba(0, 170, 255, 0.1)\",\n                                            flexDirection: \"column\"\n                                        },\n                                        children: [\n                                            \"\\uD83D\\uDDBCï¸ Content Frame\",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 2478,\n                                                columnNumber: 23\n                                            }, this),\n                                            Math.round(elementPosition.width),\n                                            \"\\xd7\",\n                                            Math.round(elementPosition.height),\n                                            \"px\",\n                                            element.name && element.name !== \"$ID/\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                        lineNumber: 2483,\n                                                        columnNumber: 27\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        style: {\n                                                            fontSize: \"10px\",\n                                                            fontStyle: \"italic\"\n                                                        },\n                                                        children: element.name\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                        lineNumber: 2484,\n                                                        columnNumber: 27\n                                                    }, this)\n                                                ]\n                                            }, void 0, true)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 2465,\n                                        columnNumber: 21\n                                    }, this),\n                                    !hasPlacedContent && element.type !== \"TextFrame\" && !isContentFrame && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        style: {\n                                            padding: \"4px\",\n                                            fontSize: \"10px\",\n                                            color: \"#999\",\n                                            display: \"flex\",\n                                            alignItems: \"center\",\n                                            justifyContent: \"center\",\n                                            height: \"100%\",\n                                            textAlign: \"center\"\n                                        },\n                                        children: [\n                                            element.type,\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                lineNumber: 2511,\n                                                columnNumber: 23\n                                            }, this),\n                                            Math.round(elementPosition.width),\n                                            \"\\xd7\",\n                                            Math.round(elementPosition.height),\n                                            \"px\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                        lineNumber: 2498,\n                                        columnNumber: 21\n                                    }, this)\n                                ]\n                            }, element.id, true, {\n                                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                lineNumber: 2174,\n                                columnNumber: 15\n                            }, this);\n                        }),\n                        selectedElement && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                position: \"absolute\",\n                                top: \"10px\",\n                                right: \"10px\",\n                                backgroundColor: \"rgba(0, 123, 255, 0.95)\",\n                                color: \"white\",\n                                padding: \"12px\",\n                                borderRadius: \"6px\",\n                                fontSize: \"12px\",\n                                maxWidth: \"300px\",\n                                lineHeight: \"1.4\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: selectedElement.type\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 2535,\n                                    columnNumber: 15\n                                }, this),\n                                \" (\",\n                                selectedElement.id,\n                                \")\",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 2536,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: \"Position:\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 2537,\n                                    columnNumber: 15\n                                }, this),\n                                \" (\",\n                                Math.round((selectedElement.pixelPosition || selectedElement.position).x),\n                                \",\",\n                                \" \",\n                                Math.round((selectedElement.pixelPosition || selectedElement.position).y),\n                                \")px\",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 2546,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: \"Size:\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                    lineNumber: 2547,\n                                    columnNumber: 15\n                                }, this),\n                                \" \",\n                                Math.round((selectedElement.pixelPosition || selectedElement.position).width),\n                                \" \",\n                                \"\\xd7\",\n                                \" \",\n                                Math.round((selectedElement.pixelPosition || selectedElement.position).height),\n                                \"px\",\n                                selectedElement.isContentFrame && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2560,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"\\uD83D\\uDDBCï¸ Content Frame\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2561,\n                                            columnNumber: 19\n                                        }, this),\n                                        selectedElement.placedContent && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 2564,\n                                                    columnNumber: 23\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                    children: \"Content:\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 2565,\n                                                    columnNumber: 23\n                                                }, this),\n                                                \" \",\n                                                selectedElement.placedContent.imageTypeName,\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 2567,\n                                                    columnNumber: 23\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                    children: \"PPI:\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 2568,\n                                                    columnNumber: 23\n                                                }, this),\n                                                \" \",\n                                                selectedElement.placedContent.actualPpi,\n                                                \" â†’\",\n                                                \" \",\n                                                selectedElement.placedContent.effectivePpi,\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 2571,\n                                                    columnNumber: 23\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                    children: \"Scale:\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                                    lineNumber: 2572,\n                                                    columnNumber: 23\n                                                }, this),\n                                                \" \",\n                                                Math.round((selectedElement.placedContent.transform?.a || 1) * 100),\n                                                \"% \\xd7\",\n                                                \" \",\n                                                Math.round((selectedElement.placedContent.transform?.d || 1) * 100),\n                                                \"%\"\n                                            ]\n                                        }, void 0, true)\n                                    ]\n                                }, void 0, true),\n                                selectedElement.parentStory && documentData.stories[selectedElement.parentStory] && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2588,\n                                            columnNumber: 21\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"\\uD83D\\uDCDD Text Story:\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2589,\n                                            columnNumber: 21\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2590,\n                                            columnNumber: 21\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"Font:\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2591,\n                                            columnNumber: 21\n                                        }, this),\n                                        \" \",\n                                        documentData.stories[selectedElement.parentStory].styling?.fontFamily,\n                                        \" \",\n                                        documentData.stories[selectedElement.parentStory].styling?.fontStyle,\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2600,\n                                            columnNumber: 21\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"Size:\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2601,\n                                            columnNumber: 21\n                                        }, this),\n                                        \" \",\n                                        documentData.stories[selectedElement.parentStory].styling?.fontSize,\n                                        \"px\",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2607,\n                                            columnNumber: 21\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"Words:\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2608,\n                                            columnNumber: 21\n                                        }, this),\n                                        \" \",\n                                        documentData.stories[selectedElement.parentStory].wordCount\n                                    ]\n                                }, void 0, true),\n                                selectedElement.linkedImage?.isEmbedded && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2617,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"\\uD83D\\uDCCE Embedded Image:\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2618,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2619,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"Type:\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2620,\n                                            columnNumber: 19\n                                        }, this),\n                                        \" \",\n                                        selectedElement.linkedImage.embeddedType,\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2622,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"Data:\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2623,\n                                            columnNumber: 19\n                                        }, this),\n                                        \" \",\n                                        selectedElement.linkedImage.embeddedData\n                                    ]\n                                }, void 0, true),\n                                selectedElement.linkedImage?.isPlaceholder && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2629,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                            children: \"\\uD83D\\uDCCB Image Placeholder\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                                            lineNumber: 2630,\n                                            columnNumber: 19\n                                        }, this)\n                                    ]\n                                }, void 0, true)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                            lineNumber: 2521,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                    lineNumber: 2019,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n                lineNumber: 2007,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Muhmmad Umer Farooq\\\\Desktop\\\\IDML\\\\idml-parser\\\\pages\\\\view\\\\[uploadId].js\",\n        lineNumber: 1355,\n        columnNumber: 5\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNSLDhEQUFDMUU7Ozs7O3NEQUNELDhEQUFDMEU7c0RBQU87Ozs7Ozt3Q0FBZTt3Q0FFckIxVixhQUFhNFgsT0FBTyxDQUFDeFgsZ0JBQWdCdVgsV0FBVyxDQUFDLENBQUN6RyxPQUFPLEVBQ3JEcEc7d0NBQ0o7d0NBRUE5SyxhQUFhNFgsT0FBTyxDQUFDeFgsZ0JBQWdCdVgsV0FBVyxDQUFDLENBQUN6RyxPQUFPLEVBQ3JEckk7c0RBRU4sOERBQUNtSTs7Ozs7c0RBQ0QsOERBQUMwRTtzREFBTzs7Ozs7O3dDQUFlO3dDQUVyQjFWLGFBQWE0WCxPQUFPLENBQUN4WCxnQkFBZ0J1WCxXQUFXLENBQUMsQ0FBQ3pHLE9BQU8sRUFDckRyRzt3Q0FDTDtzREFFRCw4REFBQ21HOzs7OztzREFDRCw4REFBQzBFO3NEQUFPOzs7Ozs7d0NBQWdCO3dDQUV0QjFWLGFBQWE0WCxPQUFPLENBQUN4WCxnQkFBZ0J1WCxXQUFXLENBQUMsQ0FDOUNHLFNBQVM7OztnQ0FJbkIxWCxnQkFBZ0I2WSxXQUFXLEVBQUVPLDRCQUM1Qjs7c0RBQ0UsOERBQUN4STs7Ozs7c0RBQ0QsOERBQUMwRTtzREFBTzs7Ozs7O3NEQUNSLDhEQUFDMUU7Ozs7O3NEQUNELDhEQUFDMEU7c0RBQU87Ozs7Ozt3Q0FBZTt3Q0FDdEJ0VixnQkFBZ0I2WSxXQUFXLENBQUNnQyxZQUFZO3NEQUN6Qyw4REFBQ2pLOzs7OztzREFDRCw4REFBQzBFO3NEQUFPOzs7Ozs7d0NBQWU7d0NBQ3RCdFYsZ0JBQWdCNlksV0FBVyxDQUFDaUMsWUFBWTs7O2dDQUc1QzlhLGdCQUFnQjZZLFdBQVcsRUFBRWtDLCtCQUM1Qjs7c0RBQ0UsOERBQUNuSzs7Ozs7c0RBQ0QsOERBQUMwRTtzREFBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2lkbWwtdmlld2VyLy4vcGFnZXMvdmlldy9bdXBsb2FkSWRdLmpzPzVhYWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9yb3V0ZXJcIjtcclxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiOyAvLyBBZGRlZCBtaXNzaW5nIGltcG9ydCBmb3IgUmVhY3QuRnJhZ21lbnRcclxuaW1wb3J0IHsgQ29sb3JVdGlscywgSW5EZXNpZ25UZXh0TWV0cmljcyB9IGZyb20gXCIuLi8uLi9saWIvaW5kZXguanNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZpZXdlcigpIHtcclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuICBjb25zdCB7IHVwbG9hZElkIH0gPSByb3V0ZXIucXVlcnk7XHJcbiAgY29uc3QgW2RvY3VtZW50RGF0YSwgc2V0RG9jdW1lbnREYXRhXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gIGNvbnN0IFtzZWxlY3RlZEVsZW1lbnQsIHNldFNlbGVjdGVkRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICBjb25zdCBbc2hvd01hcmdpbnMsIHNldFNob3dNYXJnaW5zXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gIGNvbnN0IFtzaG93RGVidWdJbmZvLCBzZXRTaG93RGVidWdJbmZvXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgLy8gQ09ORklHVVJBVElPTiBPUFRJT05TIC0gTWFrZSBiYWNrZ3JvdW5kIGRldGVjdGlvbiBmbGV4aWJsZVxyXG4gIGNvbnN0IFtiYWNrZ3JvdW5kQ29uZmlnLCBzZXRCYWNrZ3JvdW5kQ29uZmlnXSA9IHVzZVN0YXRlKHtcclxuICAgIG1vZGU6IFwiYXV0b1wiLCAvLyAnYXV0bycsICd3aGl0ZScsICdjdXN0b20nLCAndHJhbnNwYXJlbnQnXHJcbiAgICBjdXN0b21Db2xvcjogXCIjZmZmZmZmXCIsXHJcbiAgICBhbGxvd0NvbG9yQW5hbHlzaXM6IHRydWUsXHJcbiAgICBwcmVmZXJQYXBlckNvbG9yOiB0cnVlLFxyXG4gICAgZmFsbGJhY2tUb1doaXRlOiB0cnVlLFxyXG4gIH0pO1xyXG5cclxuICAvLyBCYWNrZ3JvdW5kIGNvbG9yIG92ZXJyaWRlIGNvbnRyb2xzXHJcbiAgY29uc3QgYmFja2dyb3VuZE1vZGVzID0gW1xyXG4gICAgeyB2YWx1ZTogXCJhdXRvXCIsIGxhYmVsOiBcIkF1dG8gRGV0ZWN0XCIgfSxcclxuICAgIHsgdmFsdWU6IFwid2hpdGVcIiwgbGFiZWw6IFwiRm9yY2UgV2hpdGVcIiB9LFxyXG4gICAgeyB2YWx1ZTogXCJ0cmFuc3BhcmVudFwiLCBsYWJlbDogXCJUcmFuc3BhcmVudFwiIH0sXHJcbiAgICB7IHZhbHVlOiBcImN1c3RvbVwiLCBsYWJlbDogXCJDdXN0b20gQ29sb3JcIiB9LFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IG1tVG9QeCA9IChtbSkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBtbSAhPT0gXCJudW1iZXJcIikgcmV0dXJuIDA7XHJcbiAgICByZXR1cm4gKG1tICogOTYpIC8gMjUuNDtcclxuICB9O1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHVwbG9hZElkKSB7XHJcbiAgICAgIGxvYWREb2N1bWVudCgpO1xyXG4gICAgfVxyXG4gIH0sIFt1cGxvYWRJZF0pO1xyXG5cclxuICBjb25zdCBsb2FkRG9jdW1lbnQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RvY3VtZW50LyR7dXBsb2FkSWR9YCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+ThCBEb2N1bWVudCBkYXRhOlwiLCBkYXRhKTtcclxuXHJcbiAgICAgIC8vIERFQlVHOiBDaGVjayBlbGVtZW50IHBvc2l0aW9uaW5nIGRhdGEgaW4gZGV0YWlsXHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBERUJVRyBEQVRBIFNUUlVDVFVSRTpcIik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiREFUQSBFWElTVFM6XCIsICEhZGF0YSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiREFUQS5FTEVNRU5UUyBFWElTVFM6XCIsICEhZGF0YT8uZWxlbWVudHMpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkRBVEEuRUxFTUVOVFMgTEVOR1RIOlwiLCBkYXRhPy5lbGVtZW50cz8ubGVuZ3RoKTtcclxuICAgICAgY29uc29sZS5sb2coXCJEQVRBIEtFWVM6XCIsIGRhdGEgPyBPYmplY3Qua2V5cyhkYXRhKSA6IFwibm8gZGF0YVwiKTtcclxuICAgICAgY29uc29sZS5sb2coXCJGVUxMIERBVEEgT0JKRUNUOlwiLCBkYXRhKTtcclxuXHJcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuZWxlbWVudHMgJiYgZGF0YS5lbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIEVMRU1FTlQgUE9TSVRJT05JTkcgQU5BTFlTSVM6XCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUkFXIEVMRU1FTlRTIEFSUkFZOlwiLCBkYXRhLmVsZW1lbnRzKTtcclxuXHJcbiAgICAgICAgZGF0YS5lbGVtZW50cy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFxcbj09PSBFTEVNRU5UICR7aW5kZXh9ID09PWApO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJFTEVNRU5UIElEOlwiLCBlbGVtZW50LmlkKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRUxFTUVOVCBOQU1FOlwiLCBlbGVtZW50Lm5hbWUpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJFTEVNRU5UIFRZUEU6XCIsIGVsZW1lbnQudHlwZSk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk9SSUdJTkFMIFBPU0lUSU9OOlwiLCBlbGVtZW50LnBvc2l0aW9uKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiUElYRUwgUE9TSVRJT046XCIsIGVsZW1lbnQucGl4ZWxQb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIFk9MCBpc3N1ZXNcclxuICAgICAgICAgIGlmIChlbGVtZW50LnBvc2l0aW9uPy55ID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+aqCBPUklHSU5BTCBQT1NJVElPTiBZIElTIFpFUk8hXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGVsZW1lbnQucGl4ZWxQb3NpdGlvbj8ueSA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfmqggUElYRUwgUE9TSVRJT04gWSBJUyBaRVJPIVwiKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTaG93IHdoYXQgY29vcmRpbmF0ZXMgd2UncmUgYWN0dWFsbHkgdXNpbmcgZm9yIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgICBjb25zdCBmaW5hbFBvc2l0aW9uID0gZWxlbWVudC5waXhlbFBvc2l0aW9uIHx8IGVsZW1lbnQucG9zaXRpb247XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkZJTkFMIFBPU0lUSU9OIEZPUiBSRU5ERVJJTkc6XCIsIGZpbmFsUG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgIC8vIFNob3cgZWFjaCBjb29yZGluYXRlIGV4cGxpY2l0bHlcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRklOQUwgWDpcIiwgZmluYWxQb3NpdGlvbj8ueCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkZJTkFMIFk6XCIsIGZpbmFsUG9zaXRpb24/LnkpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJGSU5BTCBXSURUSDpcIiwgZmluYWxQb3NpdGlvbj8ud2lkdGgpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJGSU5BTCBIRUlHSFQ6XCIsIGZpbmFsUG9zaXRpb24/LmhlaWdodCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5qoIE5PIEVMRU1FTlRTIEZPVU5EISBUaGlzIGlzIHRoZSBwcm9ibGVtLlwiKTtcclxuICAgICAgfVxyXG4gICAgICBzZXREb2N1bWVudERhdGEoZGF0YSk7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgZG9jdW1lbnQ6XCIsIGVycm9yKTtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gVXNlIENvbG9yVXRpbHMgZm9yIGNvbG9yIGNvbnZlcnNpb25cclxuICBjb25zdCBjb252ZXJ0Q29sb3IgPSAoY29sb3JSZWYpID0+IHtcclxuICAgIC8vIElmIGNvbG9yUmVmIGlzIGEgc3RyaW5nIGFuZCBtYXRjaGVzIGEgY29sb3IgaW4gcmVzb3VyY2VzLCB1c2UgdGhlIGNvbG9yIG9iamVjdFxyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgY29sb3JSZWYgPT09IFwic3RyaW5nXCIgJiZcclxuICAgICAgZG9jdW1lbnREYXRhLnJlc291cmNlcyAmJlxyXG4gICAgICBkb2N1bWVudERhdGEucmVzb3VyY2VzLmNvbG9ycyAmJlxyXG4gICAgICBkb2N1bWVudERhdGEucmVzb3VyY2VzLmNvbG9yc1tjb2xvclJlZl1cclxuICAgICkge1xyXG4gICAgICByZXR1cm4gQ29sb3JVdGlscy5jb252ZXJ0SWRtbENvbG9yVG9SZ2IoXHJcbiAgICAgICAgZG9jdW1lbnREYXRhLnJlc291cmNlcy5jb2xvcnNbY29sb3JSZWZdXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICAvLyBPdGhlcndpc2UsIHBhc3MgdGhyb3VnaCAoaGFuZGxlcyBvYmplY3RzIG9yIGZhbGxiYWNrKVxyXG4gICAgcmV0dXJuIENvbG9yVXRpbHMuY29udmVydElkbWxDb2xvclRvUmdiKGNvbG9yUmVmKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXREb2N1bWVudEJhY2tncm91bmRDb2xvciA9IChkb2N1bWVudERhdGEpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKFwi8J+UjSBTdGFydGluZyBpbXByb3ZlZCBiYWNrZ3JvdW5kIGNvbG9yIGRldGVjdGlvbi4uLlwiLCB7XHJcbiAgICAgIGNvbmZpZzogYmFja2dyb3VuZENvbmZpZyxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDEuIExvb2sgZm9yIGEgZnVsbC1wYWdlIHJlY3RhbmdsZSB3aXRoIGEgZmlsbCAocHJlZmVyIHRoaXMgb3ZlciBzd2F0Y2ggYW5hbHlzaXMpXHJcbiAgICBpZiAoZG9jdW1lbnREYXRhLmVsZW1lbnRzKSB7XHJcbiAgICAgIGNvbnN0IHBhZ2VXaWR0aCA9XHJcbiAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5kaW1lbnNpb25zPy5waXhlbERpbWVuc2lvbnM/LndpZHRoIHx8IDYxMjtcclxuICAgICAgY29uc3QgcGFnZUhlaWdodCA9XHJcbiAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5kaW1lbnNpb25zPy5waXhlbERpbWVuc2lvbnM/LmhlaWdodCB8fCA3OTI7XHJcblxyXG4gICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHJlY3RhbmdsZSB3aXRoIGEgbm9uLU5vbmUgZmlsbFxyXG4gICAgICBjb25zdCBmdWxsUGFnZVJlY3RzID0gZG9jdW1lbnREYXRhLmVsZW1lbnRzLmZpbHRlcihcclxuICAgICAgICAoZWwpID0+XHJcbiAgICAgICAgICBlbC50eXBlID09PSBcIlJlY3RhbmdsZVwiICYmXHJcbiAgICAgICAgICBlbC5waXhlbFBvc2l0aW9uICYmXHJcbiAgICAgICAgICBlbC5waXhlbFBvc2l0aW9uLnggPD0gNSAmJlxyXG4gICAgICAgICAgZWwucGl4ZWxQb3NpdGlvbi55IDw9IDUgJiZcclxuICAgICAgICAgIGVsLnBpeGVsUG9zaXRpb24ud2lkdGggPj0gcGFnZVdpZHRoICogMC45NSAmJlxyXG4gICAgICAgICAgZWwucGl4ZWxQb3NpdGlvbi5oZWlnaHQgPj0gcGFnZUhlaWdodCAqIDAuOTUgJiZcclxuICAgICAgICAgIGVsLmZpbGwgJiZcclxuICAgICAgICAgIGVsLmZpbGwgIT09IFwiQ29sb3IvTm9uZVwiXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChmdWxsUGFnZVJlY3RzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBVc2UgdGhlIGxhcmdlc3QgYnkgYXJlYVxyXG4gICAgICAgIGNvbnN0IGJnUmVjdCA9IGZ1bGxQYWdlUmVjdHMucmVkdWNlKChhLCBiKSA9PlxyXG4gICAgICAgICAgYS5waXhlbFBvc2l0aW9uLndpZHRoICogYS5waXhlbFBvc2l0aW9uLmhlaWdodCA+XHJcbiAgICAgICAgICBiLnBpeGVsUG9zaXRpb24ud2lkdGggKiBiLnBpeGVsUG9zaXRpb24uaGVpZ2h0XHJcbiAgICAgICAgICAgID8gYVxyXG4gICAgICAgICAgICA6IGJcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+OqCBVc2luZyBmdWxsLXBhZ2UgcmVjdGFuZ2xlIGFzIGJhY2tncm91bmQ6XCIsIGJnUmVjdC5maWxsKTtcclxuICAgICAgICByZXR1cm4gY29udmVydENvbG9yKGJnUmVjdC5maWxsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZSBjb25maWd1cmVkIGJhY2tncm91bmQgbW9kZXNcclxuICAgIGlmIChiYWNrZ3JvdW5kQ29uZmlnLm1vZGUgPT09IFwid2hpdGVcIikge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCfk4Qg4pyFIEZvcmNlIHdoaXRlIG1vZGUgLSByZXR1cm5pbmcgd2hpdGVcIik7XHJcbiAgICAgIHJldHVybiBcIndoaXRlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJhY2tncm91bmRDb25maWcubW9kZSA9PT0gXCJ0cmFuc3BhcmVudFwiKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+ThCDinIUgVHJhbnNwYXJlbnQgbW9kZSAtIHJldHVybmluZyB0cmFuc3BhcmVudFwiKTtcclxuICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYmFja2dyb3VuZENvbmZpZy5tb2RlID09PSBcImN1c3RvbVwiKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwi8J+ThCDinIUgQ3VzdG9tIGNvbG9yIG1vZGUgLSByZXR1cm5pbmc6XCIsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbmZpZy5jdXN0b21Db2xvclxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gYmFja2dyb3VuZENvbmZpZy5jdXN0b21Db2xvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBdXRvIG1vZGUgLSBjb250aW51ZSB3aXRoIGRldGVjdGlvbiBsb2dpY1xyXG5cclxuICAgIC8vIFN0cmF0ZWd5IDE6IExvb2sgZm9yIHBhZ2UgYmFja2dyb3VuZCBjb2xvciBpbiBwYWdlSW5mb1xyXG4gICAgaWYgKFxyXG4gICAgICBkb2N1bWVudERhdGEucGFnZUluZm8/LmJhY2tncm91bmRDb2xvciAmJlxyXG4gICAgICBkb2N1bWVudERhdGEucGFnZUluZm8uYmFja2dyb3VuZENvbG9yICE9PSBcIkNvbG9yL05vbmVcIlxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwi8J+ThCBGb3VuZCBwYWdlIGJhY2tncm91bmQgaW4gcGFnZUluZm86XCIsXHJcbiAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLmJhY2tncm91bmRDb2xvclxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gY29udmVydENvbG9yKGRvY3VtZW50RGF0YS5wYWdlSW5mby5iYWNrZ3JvdW5kQ29sb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0cmF0ZWd5IDI6IExvb2sgZm9yIGRvY3VtZW50IGJhY2tncm91bmQgaW4gZG9jdW1lbnQgcHJvcGVydGllc1xyXG4gICAgaWYgKFxyXG4gICAgICBkb2N1bWVudERhdGEuZG9jdW1lbnQ/LmJhY2tncm91bmRDb2xvciAmJlxyXG4gICAgICBkb2N1bWVudERhdGEuZG9jdW1lbnQuYmFja2dyb3VuZENvbG9yICE9PSBcIkNvbG9yL05vbmVcIlxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwi8J+ThCBGb3VuZCBkb2N1bWVudCBiYWNrZ3JvdW5kIGluIGRvY3VtZW50OlwiLFxyXG4gICAgICAgIGRvY3VtZW50RGF0YS5kb2N1bWVudC5iYWNrZ3JvdW5kQ29sb3JcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGNvbnZlcnRDb2xvcihkb2N1bWVudERhdGEuZG9jdW1lbnQuYmFja2dyb3VuZENvbG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdHJhdGVneSAzOiBMb29rIGZvciBzcHJlYWRzIGJhY2tncm91bmQgY29sb3JcclxuICAgIGlmIChkb2N1bWVudERhdGEuc3ByZWFkcykge1xyXG4gICAgICBmb3IgKGNvbnN0IFtzcHJlYWRJZCwgc3ByZWFkXSBvZiBPYmplY3QuZW50cmllcyhkb2N1bWVudERhdGEuc3ByZWFkcykpIHtcclxuICAgICAgICBpZiAoc3ByZWFkLmJhY2tncm91bmRDb2xvciAmJiBzcHJlYWQuYmFja2dyb3VuZENvbG9yICE9PSBcIkNvbG9yL05vbmVcIikge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIFwi8J+ThCBGb3VuZCBzcHJlYWQgYmFja2dyb3VuZCBjb2xvcjpcIixcclxuICAgICAgICAgICAgc3ByZWFkLmJhY2tncm91bmRDb2xvclxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJldHVybiBjb252ZXJ0Q29sb3Ioc3ByZWFkLmJhY2tncm91bmRDb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU1RSQVRFR1kgMy41OiBBbmFseXplIGRvY3VtZW50IGNvbG9ycyBmb3Igc3VpdGFibGUgYmFja2dyb3VuZCBjb2xvcnMgdXNpbmcgQ29sb3JVdGlsc1xyXG4gICAgaWYgKGRvY3VtZW50RGF0YS5yZXNvdXJjZXM/LmNvbG9ycykge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCfk4QgQW5hbHl6aW5nIGRvY3VtZW50IGNvbG9ycyBmb3IgYmFja2dyb3VuZCBjYW5kaWRhdGVzLi4uXCIpO1xyXG5cclxuICAgICAgLy8gVXNlIENvbG9yVXRpbHMgdG8gYW5hbHl6ZSBhbmQgZmlsdGVyIGJhY2tncm91bmQgY29sb3JzXHJcbiAgICAgIGNvbnN0IGNvbG9yS2V5cyA9IE9iamVjdC5rZXlzKGRvY3VtZW50RGF0YS5yZXNvdXJjZXMuY29sb3JzKTtcclxuICAgICAgY29uc3QgYmFja2dyb3VuZENhbmRpZGF0ZXMgPSBbXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29sb3JLZXkgb2YgY29sb3JLZXlzKSB7XHJcbiAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBDb2xvclV0aWxzLmFuYWx5emVJZG1sQ29sb3JGb3JCYWNrZ3JvdW5kKGNvbG9yS2V5KTtcclxuICAgICAgICBpZiAoYW5hbHlzaXMgJiYgYW5hbHlzaXMuaXNMaWdodEJhY2tncm91bmQpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgICAg4pyFIEJhY2tncm91bmQgY2FuZGlkYXRlOiAke2NvbG9yS2V5fSAtICR7YW5hbHlzaXMucmVhc29uaW5nfSAoJHthbmFseXNpcy5jYXRlZ29yeX0pYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGJhY2tncm91bmRDYW5kaWRhdGVzLnB1c2goY29sb3JLZXkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYW5hbHlzaXMpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgICAg4p2MIE5vdCBzdWl0YWJsZTogJHtjb2xvcktleX0gLSAke2FuYWx5c2lzLnJlYXNvbmluZ31gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJhY2tncm91bmRDYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBTb3J0IGNhbmRpZGF0ZXMgdXNpbmcgQ29sb3JVdGlscyBzb3J0aW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3Qgc29ydGVkQ2FuZGlkYXRlcyA9XHJcbiAgICAgICAgICBDb2xvclV0aWxzLnNvcnRDb2xvcnNCeUxpZ2h0bmVzcyhiYWNrZ3JvdW5kQ2FuZGlkYXRlcyk7XHJcbiAgICAgICAgY29uc3QgYmVzdENhbmRpZGF0ZSA9IHNvcnRlZENhbmRpZGF0ZXNbMF07XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfk4QgRm91bmQgJHtiYWNrZ3JvdW5kQ2FuZGlkYXRlcy5sZW5ndGh9IGJhY2tncm91bmQgY29sb3IgY2FuZGlkYXRlczpgLFxyXG4gICAgICAgICAgc29ydGVkQ2FuZGlkYXRlc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OEIFVzaW5nIGJlc3QgYmFja2dyb3VuZCBjb2xvciBjYW5kaWRhdGU6XCIsIGJlc3RDYW5kaWRhdGUpO1xyXG4gICAgICAgIHJldHVybiBjb252ZXJ0Q29sb3IoYmVzdENhbmRpZGF0ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdHJhdGVneSA0OiBMb29rIGZvciBhIGxhcmdlIGJhY2tncm91bmQgcmVjdGFuZ2xlIGVsZW1lbnQgd2l0aCBhY3R1YWwgZmlsbFxyXG4gICAgaWYgKGRvY3VtZW50RGF0YS5lbGVtZW50cykge1xyXG4gICAgICBjb25zdCBwYWdlV2lkdGggPVxyXG4gICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mbz8uZGltZW5zaW9ucz8ucGl4ZWxEaW1lbnNpb25zPy53aWR0aCB8fCA2MTI7XHJcbiAgICAgIGNvbnN0IHBhZ2VIZWlnaHQgPVxyXG4gICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mbz8uZGltZW5zaW9ucz8ucGl4ZWxEaW1lbnNpb25zPy5oZWlnaHQgfHwgNzkyO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCLwn5OEIFNlYXJjaGluZyBmb3IgYmFja2dyb3VuZCBpblwiLFxyXG4gICAgICAgIGRvY3VtZW50RGF0YS5lbGVtZW50cy5sZW5ndGgsXHJcbiAgICAgICAgXCJlbGVtZW50c1wiXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+ThCBQYWdlIGRpbWVuc2lvbnM6XCIsIHBhZ2VXaWR0aCwgXCJ4XCIsIHBhZ2VIZWlnaHQpO1xyXG5cclxuICAgICAgLy8gTG9nIGFsbCByZWN0YW5nbGVzIHdpdGggdGhlaXIgcG9zaXRpb25zIGFuZCBmaWxscyBmb3IgZGVidWdnaW5nXHJcbiAgICAgIGNvbnN0IHJlY3RhbmdsZXMgPSBkb2N1bWVudERhdGEuZWxlbWVudHMuZmlsdGVyKFxyXG4gICAgICAgIChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09IFwiUmVjdGFuZ2xlXCJcclxuICAgICAgKTtcclxuICAgICAgY29uc29sZS5sb2coXCLwn5OEIEZvdW5kXCIsIHJlY3RhbmdsZXMubGVuZ3RoLCBcInJlY3RhbmdsZXM6XCIpO1xyXG5cclxuICAgICAgbGV0IGhhc0FueUFjdHVhbEZpbGwgPSBmYWxzZTtcclxuICAgICAgcmVjdGFuZ2xlcy5mb3JFYWNoKChyZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgICAgLSAke3JlY3QuaWR9OiBwb3MoJHtyZWN0LnBvc2l0aW9uLnh9LCAke3JlY3QucG9zaXRpb24ueX0pIHNpemUoJHtyZWN0LnBvc2l0aW9uLndpZHRofSB4ICR7cmVjdC5wb3NpdGlvbi5oZWlnaHR9KSBmaWxsOiAke3JlY3QuZmlsbH1gXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAocmVjdC5maWxsICYmIHJlY3QuZmlsbCAhPT0gXCJDb2xvci9Ob25lXCIpIHtcclxuICAgICAgICAgIGhhc0FueUFjdHVhbEZpbGwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBDUklUSUNBTCBGSVg6IElmIEFMTCByZWN0YW5nbGVzIGhhdmUgQ29sb3IvTm9uZSwgY2hlY2sgaWYgd2UgYWxyZWFkeSBmb3VuZCBhIGJhY2tncm91bmQgY29sb3IgYWJvdmVcclxuICAgICAgaWYgKCFoYXNBbnlBY3R1YWxGaWxsKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBcIvCfk4Qg4pyFIEFMTCByZWN0YW5nbGVzIGhhdmUgQ29sb3IvTm9uZSAtIGJ1dCBjaGVja2luZyBmb3IgZG9jdW1lbnQtbGV2ZWwgYmFja2dyb3VuZCBmaXJzdFwiXHJcbiAgICAgICAgKTtcclxuICAgICAgICAvLyBEb24ndCBpbW1lZGlhdGVseSBkZWZhdWx0IHRvIHdoaXRlIC0gY29udGludWUgY2hlY2tpbmcgb3RoZXIgc3RyYXRlZ2llc1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdHJhdGVneSA0YTogTG9vayBmb3IgcmVjdGFuZ2xlcyB0aGF0IGNvdmVyIHRoZSBlbnRpcmUgcGFnZSBhcmVhIHdpdGggYWN0dWFsIGNvbG9yXHJcbiAgICAgIGNvbnN0IGZ1bGxQYWdlRWxlbWVudHMgPSBkb2N1bWVudERhdGEuZWxlbWVudHMuZmlsdGVyKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIGVsZW1lbnQudHlwZSA9PT0gXCJSZWN0YW5nbGVcIiAmJlxyXG4gICAgICAgICAgZWxlbWVudC5wb3NpdGlvbi54IDw9IDUwICYmIC8vIE1vcmUgdG9sZXJhbmNlIGZvciBsZWZ0IGVkZ2VcclxuICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24ueSA8PSA1MCAmJiAvLyBNb3JlIHRvbGVyYW5jZSBmb3IgdG9wIGVkZ2VcclxuICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24ud2lkdGggPj0gcGFnZVdpZHRoICogMC44ICYmIC8vIENvdmVycyBtb3N0IHdpZHRoXHJcbiAgICAgICAgICBlbGVtZW50LnBvc2l0aW9uLmhlaWdodCA+PSBwYWdlSGVpZ2h0ICogMC44ICYmIC8vIENvdmVycyBtb3N0IGhlaWdodFxyXG4gICAgICAgICAgZWxlbWVudC5maWxsICYmXHJcbiAgICAgICAgICBlbGVtZW50LmZpbGwgIT09IFwiQ29sb3IvTm9uZVwiXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoZnVsbFBhZ2VFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBsYXJnZXN0IGJhY2tncm91bmQgZWxlbWVudCAobGlrZWx5IHRoZSBwYWdlIGJhY2tncm91bmQpXHJcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZEVsZW1lbnQgPSBmdWxsUGFnZUVsZW1lbnRzLnJlZHVjZShcclxuICAgICAgICAgIChsYXJnZXN0LCBjdXJyZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhcmdlc3RBcmVhID1cclxuICAgICAgICAgICAgICBsYXJnZXN0LnBvc2l0aW9uLndpZHRoICogbGFyZ2VzdC5wb3NpdGlvbi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBcmVhID1cclxuICAgICAgICAgICAgICBjdXJyZW50LnBvc2l0aW9uLndpZHRoICogY3VycmVudC5wb3NpdGlvbi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50QXJlYSA+IGxhcmdlc3RBcmVhID8gY3VycmVudCA6IGxhcmdlc3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBcIvCfk4QgRm91bmQgZnVsbC1wYWdlIGJhY2tncm91bmQgZWxlbWVudDpcIixcclxuICAgICAgICAgIGJhY2tncm91bmRFbGVtZW50LmlkLFxyXG4gICAgICAgICAgXCJ3aXRoIGNvbG9yOlwiLFxyXG4gICAgICAgICAgYmFja2dyb3VuZEVsZW1lbnQuZmlsbFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRDb2xvcihiYWNrZ3JvdW5kRWxlbWVudC5maWxsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU3RyYXRlZ3kgNGI6IExvb2sgZm9yIGFueSBsYXJnZSByZWN0YW5nbGUgd2l0aCBhY3R1YWwgY29sb3IgKGV2ZW4gaWYgbm90IGZ1bGwgcGFnZSlcclxuICAgICAgY29uc3QgbGFyZ2VDb2xvcmVkRWxlbWVudHMgPSBkb2N1bWVudERhdGEuZWxlbWVudHMuZmlsdGVyKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXJlYSA9IGVsZW1lbnQucG9zaXRpb24ud2lkdGggKiBlbGVtZW50LnBvc2l0aW9uLmhlaWdodDtcclxuICAgICAgICBjb25zdCBwYWdlQXJlYSA9IHBhZ2VXaWR0aCAqIHBhZ2VIZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIGVsZW1lbnQudHlwZSA9PT0gXCJSZWN0YW5nbGVcIiAmJlxyXG4gICAgICAgICAgYXJlYSA+PSBwYWdlQXJlYSAqIDAuMyAmJiAvLyBBdCBsZWFzdCAzMCUgb2YgcGFnZSBhcmVhXHJcbiAgICAgICAgICBlbGVtZW50LmZpbGwgJiZcclxuICAgICAgICAgIGVsZW1lbnQuZmlsbCAhPT0gXCJDb2xvci9Ob25lXCJcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChsYXJnZUNvbG9yZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gU29ydCBieSBhcmVhLCBsYXJnZXN0IGZpcnN0XHJcbiAgICAgICAgbGFyZ2VDb2xvcmVkRWxlbWVudHMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgY29uc3QgYXJlYUEgPSBhLnBvc2l0aW9uLndpZHRoICogYS5wb3NpdGlvbi5oZWlnaHQ7XHJcbiAgICAgICAgICBjb25zdCBhcmVhQiA9IGIucG9zaXRpb24ud2lkdGggKiBiLnBvc2l0aW9uLmhlaWdodDtcclxuICAgICAgICAgIHJldHVybiBhcmVhQiAtIGFyZWFBO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kRWxlbWVudCA9IGxhcmdlQ29sb3JlZEVsZW1lbnRzWzBdO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgXCLwn5OEIEZvdW5kIGxhcmdlIGNvbG9yZWQgYmFja2dyb3VuZCBlbGVtZW50OlwiLFxyXG4gICAgICAgICAgYmFja2dyb3VuZEVsZW1lbnQuaWQsXHJcbiAgICAgICAgICBcIndpdGggY29sb3I6XCIsXHJcbiAgICAgICAgICBiYWNrZ3JvdW5kRWxlbWVudC5maWxsXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gY29udmVydENvbG9yKGJhY2tncm91bmRFbGVtZW50LmZpbGwpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RyYXRlZ3kgNTogTG9vayBmb3IgUGFwZXIgY29sb3Igc3BlY2lmaWNhbGx5IChJbkRlc2lnbidzIGRlZmF1bHQpIC0gaWYgZW5hYmxlZFxyXG4gICAgaWYgKGJhY2tncm91bmRDb25maWcucHJlZmVyUGFwZXJDb2xvciAmJiBkb2N1bWVudERhdGEucmVzb3VyY2VzPy5jb2xvcnMpIHtcclxuICAgICAgY29uc3QgcGFwZXJDb2xvciA9IE9iamVjdC5lbnRyaWVzKGRvY3VtZW50RGF0YS5yZXNvdXJjZXMuY29sb3JzKS5maW5kKFxyXG4gICAgICAgIChba2V5LCBjb2xvcl0pID0+IGNvbG9yLm5hbWUgPT09IFwiUGFwZXJcIiB8fCBrZXkgPT09IFwiQ29sb3IvUGFwZXJcIlxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHBhcGVyQ29sb3IpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4QgRm91bmQgUGFwZXIgY29sb3IgaW4gcmVzb3VyY2VzIC0gdXNpbmcgYXMgYmFja2dyb3VuZFwiKTtcclxuICAgICAgICByZXR1cm4gY29udmVydENvbG9yKHBhcGVyQ29sb3JbMF0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RyYXRlZ3kgNjogQ2hlY2sgZm9yIGV4cGxpY2l0bHkgbmFtZWQgYmFja2dyb3VuZCBjb2xvcnNcclxuICAgIGlmIChkb2N1bWVudERhdGEucmVzb3VyY2VzPy5jb2xvcnMpIHtcclxuICAgICAgLy8gTG9vayBmb3Igc3BlY2lmaWMgYmFja2dyb3VuZCBjb2xvciBuYW1lc1xyXG4gICAgICBjb25zdCBiYWNrZ3JvdW5kQ29sb3JOYW1lcyA9IFtcclxuICAgICAgICBcIlBhZ2VcIixcclxuICAgICAgICBcIkJhY2tncm91bmRcIixcclxuICAgICAgICBcIkRvY3VtZW50XCIsXHJcbiAgICAgICAgXCJQYWdlIENvbG9yXCIsXHJcbiAgICAgICAgXCJCYWNrZ3JvdW5kIENvbG9yXCIsXHJcbiAgICAgIF07XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvbG9yTmFtZSBvZiBiYWNrZ3JvdW5kQ29sb3JOYW1lcykge1xyXG4gICAgICAgIGNvbnN0IGZvdW5kQ29sb3IgPSBPYmplY3QuZW50cmllcyhkb2N1bWVudERhdGEucmVzb3VyY2VzLmNvbG9ycykuZmluZChcclxuICAgICAgICAgIChba2V5LCBjb2xvcl0pID0+XHJcbiAgICAgICAgICAgIGNvbG9yLm5hbWUgJiZcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yTmFtZXMuc29tZSgobmFtZSkgPT5cclxuICAgICAgICAgICAgICBjb2xvci5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobmFtZS50b0xvd2VyQ2FzZSgpKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKGZvdW5kQ29sb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+ThCBGb3VuZCBuYW1lZCBiYWNrZ3JvdW5kIGNvbG9yOlwiLCBmb3VuZENvbG9yWzFdLm5hbWUpO1xyXG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRDb2xvcihmb3VuZENvbG9yWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdHJhdGVneSA3OiBDaGVjayBzcHJlYWRzIGRhdGEgZm9yIGJhY2tncm91bmQgY29sb3JzXHJcbiAgICBpZiAoZG9jdW1lbnREYXRhLnNwcmVhZHMpIHtcclxuICAgICAgY29uc29sZS5sb2coXCLwn5OEIENoZWNraW5nIHNwcmVhZHMgZm9yIGJhY2tncm91bmQgY29sb3JzLi4uXCIpO1xyXG4gICAgICBmb3IgKGNvbnN0IFtzcHJlYWRJZCwgc3ByZWFkXSBvZiBPYmplY3QuZW50cmllcyhkb2N1bWVudERhdGEuc3ByZWFkcykpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgICAgLSBTcHJlYWQgJHtzcHJlYWRJZH0ga2V5czpgLCBPYmplY3Qua2V5cyhzcHJlYWQpKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHBhZ2UgYmFja2dyb3VuZCBpbiBzcHJlYWRcclxuICAgICAgICBpZiAoc3ByZWFkLnBhZ2VzKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgcGFnZV0gb2Ygc3ByZWFkLnBhZ2VzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgICAtIFBhZ2UgJHtpbmRleH0ga2V5czpgLCBPYmplY3Qua2V5cyhwYWdlKSk7XHJcbiAgICAgICAgICAgIGlmIChwYWdlLmJhY2tncm91bmRDb2xvciAmJiBwYWdlLmJhY2tncm91bmRDb2xvciAhPT0gXCJDb2xvci9Ob25lXCIpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgIFwi8J+ThCBGb3VuZCBwYWdlIGJhY2tncm91bmQgaW4gc3ByZWFkIHBhZ2U6XCIsXHJcbiAgICAgICAgICAgICAgICBwYWdlLmJhY2tncm91bmRDb2xvclxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRDb2xvcihwYWdlLmJhY2tncm91bmRDb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdHJhdGVneSA4OiBDaGVjayBtYXN0ZXIgc3ByZWFkcyBmb3IgYmFja2dyb3VuZFxyXG4gICAgaWYgKGRvY3VtZW50RGF0YS5tYXN0ZXJTcHJlYWRzKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+ThCBDaGVja2luZyBtYXN0ZXIgc3ByZWFkcyBmb3IgYmFja2dyb3VuZCBjb2xvcnMuLi5cIik7XHJcbiAgICAgIGZvciAoY29uc3QgW21hc3RlcklkLCBtYXN0ZXJdIG9mIE9iamVjdC5lbnRyaWVzKFxyXG4gICAgICAgIGRvY3VtZW50RGF0YS5tYXN0ZXJTcHJlYWRzXHJcbiAgICAgICkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgICAgLSBNYXN0ZXIgJHttYXN0ZXJJZH0ga2V5czpgLCBPYmplY3Qua2V5cyhtYXN0ZXIpKTtcclxuICAgICAgICBpZiAobWFzdGVyLmJhY2tncm91bmRDb2xvciAmJiBtYXN0ZXIuYmFja2dyb3VuZENvbG9yICE9PSBcIkNvbG9yL05vbmVcIikge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIFwi8J+ThCBGb3VuZCBtYXN0ZXIgc3ByZWFkIGJhY2tncm91bmQ6XCIsXHJcbiAgICAgICAgICAgIG1hc3Rlci5iYWNrZ3JvdW5kQ29sb3JcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICByZXR1cm4gY29udmVydENvbG9yKG1hc3Rlci5iYWNrZ3JvdW5kQ29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0cmF0ZWd5IDk6IElNUFJPVkVEIGNvbG9yIGFuYWx5c2lzIC0gb25seSBhcyBsYXN0IHJlc29ydCBhbmQgb25seSBmb3IgY29sb3JzIGFjdHVhbGx5IHVzZWQgYXMgZmlsbHMgLSBpZiBlbmFibGVkXHJcbiAgICBpZiAoXHJcbiAgICAgIGJhY2tncm91bmRDb25maWcuYWxsb3dDb2xvckFuYWx5c2lzICYmXHJcbiAgICAgIGRvY3VtZW50RGF0YS5yZXNvdXJjZXM/LmNvbG9ycyAmJlxyXG4gICAgICBkb2N1bWVudERhdGEuZWxlbWVudHNcclxuICAgICkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCfk4QgUGVyZm9ybWluZyBsYXN0LXJlc29ydCBjb2xvciBhbmFseXNpcy4uLlwiKTtcclxuXHJcbiAgICAgIC8vIEZpcnN0LCBnZXQgYWxsIGNvbG9ycyBhY3R1YWxseSB1c2VkIGFzIGZpbGxzIGluIHRoZSBkb2N1bWVudFxyXG4gICAgICBjb25zdCB1c2VkRmlsbENvbG9ycyA9IG5ldyBTZXQoKTtcclxuICAgICAgZG9jdW1lbnREYXRhLmVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudC5maWxsICYmIGVsZW1lbnQuZmlsbCAhPT0gXCJDb2xvci9Ob25lXCIpIHtcclxuICAgICAgICAgIHVzZWRGaWxsQ29sb3JzLmFkZChlbGVtZW50LmZpbGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIvCfk4QgQ29sb3JzIGFjdHVhbGx5IHVzZWQgYXMgZmlsbHM6XCIsXHJcbiAgICAgICAgQXJyYXkuZnJvbSh1c2VkRmlsbENvbG9ycylcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmICh1c2VkRmlsbENvbG9ycy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBcIvCfk4Qg4pyFIE5vIGNvbG9ycyB1c2VkIGFzIGZpbGxzIC0gY29uZmlybWluZyB3aGl0ZSBiYWNrZ3JvdW5kXCJcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBcIndoaXRlXCI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFuYWx5emUgb25seSBjb2xvcnMgdGhhdCBhcmUgYWN0dWFsbHkgdXNlZCBhcyBmaWxsc1xyXG4gICAgICBjb25zdCBmaWxsQ29sb3JBbmFseXNpcyA9IEFycmF5LmZyb20odXNlZEZpbGxDb2xvcnMpXHJcbiAgICAgICAgLm1hcCgoY29sb3JLZXkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGNvbG9yID0gZG9jdW1lbnREYXRhLnJlc291cmNlcy5jb2xvcnNbY29sb3JLZXldO1xyXG4gICAgICAgICAgaWYgKCFjb2xvcikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gRXh0cmFjdCBDTVlLIHZhbHVlcyBmcm9tIHRoZSBrZXkgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICBjb25zdCBjbXlrTWF0Y2ggPSBjb2xvcktleS5tYXRjaChcclxuICAgICAgICAgICAgL0NvbG9yXFwvQz0oW1xcZC5dKylcXHMqTT0oW1xcZC5dKylcXHMqWT0oW1xcZC5dKylcXHMqSz0oW1xcZC5dKykvXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgaWYgKCFjbXlrTWF0Y2gpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgIGNvbnN0IFssIGMsIG0sIHksIGtdID0gY215a01hdGNoLm1hcCgodmFsKSA9PiBwYXJzZUZsb2F0KHZhbCkpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGAgICDihpIgQW5hbHl6aW5nIHVzZWQgZmlsbCBjb2xvciAke2NvbG9yS2V5fTogQz0ke2N9IE09JHttfSBZPSR7eX0gSz0ke2t9YFxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgaG93IFwiYmFja2dyb3VuZC1saWtlXCIgdGhpcyBjb2xvciBpc1xyXG4gICAgICAgICAgY29uc3QgY29sb3JmdWxuZXNzID0gYyArIG0gKyB5O1xyXG4gICAgICAgICAgY29uc3QgZGFya25lc3MgPSBrO1xyXG4gICAgICAgICAgY29uc3QgbGlnaHRuZXNzID0gMTAwIC0gZGFya25lc3M7IC8vIEhpZ2hlciBpcyBsaWdodGVyXHJcblxyXG4gICAgICAgICAgLy8gQmFja2dyb3VuZCBjb2xvcnMgc2hvdWxkIHR5cGljYWxseSBiZTpcclxuICAgICAgICAgIC8vIC0gTG93IGNvbG9yZnVsbmVzcyAobmV1dHJhbClcclxuICAgICAgICAgIC8vIC0gSGlnaCBsaWdodG5lc3MgKGJyaWdodClcclxuICAgICAgICAgIC8vIC0gTGFyZ2UgY292ZXJhZ2UgYXJlYVxyXG5cclxuICAgICAgICAgIGxldCBiYWNrZ3JvdW5kU2NvcmUgPSAwO1xyXG5cclxuICAgICAgICAgIC8vIFByZWZlciBsaWdodGVyIGNvbG9ycyAod2hpdGUvcGFwZXItbGlrZSlcclxuICAgICAgICAgIGJhY2tncm91bmRTY29yZSArPSBsaWdodG5lc3MgKiAyO1xyXG5cclxuICAgICAgICAgIC8vIFNsaWdodGx5IHBlbmFsaXplIHZlcnkgY29sb3JmdWwgY29sb3JzICh1bmxlc3MgdGhleSBjb3ZlciBsYXJnZSBhcmVhcylcclxuICAgICAgICAgIGlmIChjb2xvcmZ1bG5lc3MgPiA1MCkge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2NvcmUgLT0gY29sb3JmdWxuZXNzICogMC41O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBhcmVhIGNvdmVyZWQgYnkgdGhpcyBjb2xvclxyXG4gICAgICAgICAgbGV0IHRvdGFsQXJlYSA9IDA7XHJcbiAgICAgICAgICBkb2N1bWVudERhdGEuZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5maWxsID09PSBjb2xvcktleSkge1xyXG4gICAgICAgICAgICAgIHRvdGFsQXJlYSArPVxyXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQucG9zaXRpb24ud2lkdGggfHwgMCkgKiAoZWxlbWVudC5wb3NpdGlvbi5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHBhZ2VBcmVhID1cclxuICAgICAgICAgICAgKGRvY3VtZW50RGF0YS5wYWdlSW5mbz8uZGltZW5zaW9ucz8ud2lkdGggfHwgNjEyKSAqXHJcbiAgICAgICAgICAgIChkb2N1bWVudERhdGEucGFnZUluZm8/LmRpbWVuc2lvbnM/LmhlaWdodCB8fCA3OTIpO1xyXG4gICAgICAgICAgY29uc3QgY292ZXJhZ2VSYXRpbyA9IHRvdGFsQXJlYSAvIHBhZ2VBcmVhO1xyXG5cclxuICAgICAgICAgIC8vIEhlYXZpbHkgYm9vc3QgY29sb3JzIHRoYXQgY292ZXIgbGFyZ2UgYXJlYXNcclxuICAgICAgICAgIGJhY2tncm91bmRTY29yZSArPSBjb3ZlcmFnZVJhdGlvICogMTAwMDtcclxuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYCAgIPCfk4ogQmFja2dyb3VuZCBzY29yZSBmb3IgJHtjb2xvcktleX06ICR7YmFja2dyb3VuZFNjb3JlfSAobGlnaHRuZXNzOiAke2xpZ2h0bmVzc30sIGNvbG9yZnVsbmVzczogJHtjb2xvcmZ1bG5lc3N9LCBjb3ZlcmFnZTogJHtjb3ZlcmFnZVJhdGlvLnRvRml4ZWQoXHJcbiAgICAgICAgICAgICAgM1xyXG4gICAgICAgICAgICApfSlgXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtleTogY29sb3JLZXksXHJcbiAgICAgICAgICAgIGNvbG9yLFxyXG4gICAgICAgICAgICBjbXlrOiB7IGMsIG0sIHksIGsgfSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZFNjb3JlLFxyXG4gICAgICAgICAgICBsaWdodG5lc3MsXHJcbiAgICAgICAgICAgIGNvbG9yZnVsbmVzcyxcclxuICAgICAgICAgICAgY292ZXJhZ2VSYXRpbyxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuICAgICAgaWYgKGZpbGxDb2xvckFuYWx5c2lzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBTb3J0IGJ5IGJhY2tncm91bmQgc2NvcmUgKGhpZ2hlc3QgZmlyc3QpXHJcbiAgICAgICAgZmlsbENvbG9yQW5hbHlzaXMuc29ydCgoYSwgYikgPT4gYi5iYWNrZ3JvdW5kU2NvcmUgLSBhLmJhY2tncm91bmRTY29yZSk7XHJcbiAgICAgICAgY29uc3QgYmVzdEJhY2tncm91bmRDb2xvciA9IGZpbGxDb2xvckFuYWx5c2lzWzBdO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGDwn46oIFNlbGVjdGVkIGJhY2tncm91bmQgY29sb3IgZnJvbSBmaWxsczogJHtiZXN0QmFja2dyb3VuZENvbG9yLmtleX0gKHNjb3JlOiAke2Jlc3RCYWNrZ3JvdW5kQ29sb3IuYmFja2dyb3VuZFNjb3JlfSlgXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGAgICBDb2xvciBkZXRhaWxzOiBDPSR7YmVzdEJhY2tncm91bmRDb2xvci5jbXlrLmN9IE09JHtiZXN0QmFja2dyb3VuZENvbG9yLmNteWsubX0gWT0ke2Jlc3RCYWNrZ3JvdW5kQ29sb3IuY215ay55fSBLPSR7YmVzdEJhY2tncm91bmRDb2xvci5jbXlrLmt9YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRDb2xvcihiZXN0QmFja2dyb3VuZENvbG9yLmtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5hbCBGYWxsYmFjazogVXNlIGNvbmZpZ3VyZWQgZmFsbGJhY2tcclxuICAgIGlmIChiYWNrZ3JvdW5kQ29uZmlnLmZhbGxiYWNrVG9XaGl0ZSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCfk4Qg4pyFIE5vIGJhY2tncm91bmQgY29sb3IgZGV0ZWN0ZWQgLSB1c2luZyB3aGl0ZSBmYWxsYmFja1wiKTtcclxuICAgICAgcmV0dXJuIFwid2hpdGVcIjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwi8J+ThCDinIUgTm8gYmFja2dyb3VuZCBjb2xvciBkZXRlY3RlZCAtIHVzaW5nIHRyYW5zcGFyZW50IGZhbGxiYWNrXCJcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRGb250V2VpZ2h0ID0gKGZvbnRTdHlsZSkgPT4ge1xyXG4gICAgaWYgKCFmb250U3R5bGUpIHJldHVybiBcIjQwMFwiO1xyXG5cclxuICAgIGNvbnN0IHN0eWxlID0gZm9udFN0eWxlLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gSGFuZGxlIGNvbXBsZXggc3R5bGVzIGxpa2UgXCJCb2xkIEl0YWxpY1wiLCBcIlNlbWlib2xkIENvbmRlbnNlZFwiLCBldGMuXHJcbiAgICBpZiAoc3R5bGUuaW5jbHVkZXMoXCJ0aGluXCIpKSByZXR1cm4gXCIxMDBcIjtcclxuICAgIGlmIChzdHlsZS5pbmNsdWRlcyhcImV4dHJhbGlnaHRcIikgfHwgc3R5bGUuaW5jbHVkZXMoXCJ1bHRyYSBsaWdodFwiKSlcclxuICAgICAgcmV0dXJuIFwiMjAwXCI7XHJcbiAgICBpZiAoc3R5bGUuaW5jbHVkZXMoXCJsaWdodFwiKSkgcmV0dXJuIFwiMzAwXCI7XHJcbiAgICBpZiAoc3R5bGUuaW5jbHVkZXMoXCJtZWRpdW1cIikpIHJldHVybiBcIjUwMFwiO1xyXG4gICAgaWYgKHN0eWxlLmluY2x1ZGVzKFwiZGVtaWJvbGRcIikgfHwgc3R5bGUuaW5jbHVkZXMoXCJzZW1pYm9sZFwiKSkgcmV0dXJuIFwiNjAwXCI7XHJcbiAgICBpZiAoc3R5bGUuaW5jbHVkZXMoXCJib2xkXCIpKSByZXR1cm4gXCI3MDBcIjtcclxuICAgIGlmIChzdHlsZS5pbmNsdWRlcyhcImV4dHJhYm9sZFwiKSB8fCBzdHlsZS5pbmNsdWRlcyhcInVsdHJhIGJvbGRcIikpXHJcbiAgICAgIHJldHVybiBcIjgwMFwiO1xyXG4gICAgaWYgKHN0eWxlLmluY2x1ZGVzKFwiYmxhY2tcIikgfHwgc3R5bGUuaW5jbHVkZXMoXCJoZWF2eVwiKSkgcmV0dXJuIFwiOTAwXCI7XHJcblxyXG4gICAgcmV0dXJuIFwiNDAwXCI7IC8vIFJlZ3VsYXIvTm9ybWFsXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0Rm9udFN0eWxlID0gKGZvbnRTdHlsZSkgPT4ge1xyXG4gICAgaWYgKFxyXG4gICAgICAhZm9udFN0eWxlIHx8XHJcbiAgICAgIGZvbnRTdHlsZSA9PT0gXCJcIiB8fFxyXG4gICAgICBmb250U3R5bGUgPT09IFwiUmVndWxhclwiIHx8XHJcbiAgICAgIGZvbnRTdHlsZSA9PT0gXCJub3JtYWxcIlxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBcIm5vcm1hbFwiO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0eWxlID0gZm9udFN0eWxlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG5cclxuICAgIC8vIEZJWEVEOiBNb3JlIHByZWNpc2UgaXRhbGljIGRldGVjdGlvbiAtIG9ubHkgZXhhY3QgbWF0Y2hlcyBvciBleHBsaWNpdCBpdGFsaWMgc3R5bGVzXHJcbiAgICBjb25zdCB3aWxsQmVJdGFsaWMgPVxyXG4gICAgICBzdHlsZSA9PT0gXCJpdGFsaWNcIiB8fFxyXG4gICAgICBzdHlsZSA9PT0gXCJvYmxpcXVlXCIgfHxcclxuICAgICAgc3R5bGUuZW5kc1dpdGgoXCIgaXRhbGljXCIpIHx8XHJcbiAgICAgIHN0eWxlLnN0YXJ0c1dpdGgoXCJpdGFsaWMgXCIpIHx8XHJcbiAgICAgIHN0eWxlID09PSBcIml0XCIgfHxcclxuICAgICAgc3R5bGUuaW5jbHVkZXMoXCIgaXRhbGljIFwiKSB8fFxyXG4gICAgICBzdHlsZS5lbmRzV2l0aChcIi1pdGFsaWNcIikgfHxcclxuICAgICAgc3R5bGUuc3RhcnRzV2l0aChcIml0YWxpYy1cIik7XHJcblxyXG4gICAgLy8gREVCVUc6IExvZyB3aGVuIGl0YWxpYyBpcyBiZWluZyBhcHBsaWVkXHJcbiAgICBpZiAod2lsbEJlSXRhbGljKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+OqCBGb250IHN0eWxlIGFwcGx5aW5nIElUQUxJQzpcIiwge1xyXG4gICAgICAgIGlucHV0OiBmb250U3R5bGUsXHJcbiAgICAgICAgaW5wdXRUeXBlOiB0eXBlb2YgZm9udFN0eWxlLFxyXG4gICAgICAgIG5vcm1hbGl6ZWRJbnB1dDogc3R5bGUsXHJcbiAgICAgICAgcmVhc29uOiBcIk1hdGNoZWQgaXRhbGljIHBhdHRlcm5cIixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpbGxCZUl0YWxpYykge1xyXG4gICAgICByZXR1cm4gXCJpdGFsaWNcIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWZhdWx0IHRvIG5vcm1hbCBmb3IgZXZlcnl0aGluZyBlbHNlIChpbmNsdWRpbmcgUmVndWxhciwgTWVkaXVtLCBCb2xkLCBldGMuKVxyXG4gICAgcmV0dXJuIFwibm9ybWFsXCI7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZXh0cmFjdFRleHREZWNvcmF0aW9ucyA9IChmb3JtYXR0aW5nKSA9PiB7XHJcbiAgICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8vIENoZWNrIGZvciB1bmRlcmxpbmVcclxuICAgIGlmIChcclxuICAgICAgZm9ybWF0dGluZy51bmRlcmxpbmUgfHxcclxuICAgICAgKGZvcm1hdHRpbmcuY2hhcmFjdGVyU3R5bGUgJiZcclxuICAgICAgICBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ1bmRlcmxpbmVcIikpXHJcbiAgICApIHtcclxuICAgICAgZGVjb3JhdGlvbnMucHVzaChcInVuZGVybGluZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBmb3Igc3RyaWtldGhyb3VnaFxyXG4gICAgaWYgKFxyXG4gICAgICBmb3JtYXR0aW5nLnN0cmlrZXRocm91Z2ggfHxcclxuICAgICAgZm9ybWF0dGluZy5zdHJpa2VUaHJvdWdoIHx8XHJcbiAgICAgIChmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlICYmXHJcbiAgICAgICAgZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic3RyaWtldGhyb3VnaFwiKSlcclxuICAgICkge1xyXG4gICAgICBkZWNvcmF0aW9ucy5wdXNoKFwibGluZS10aHJvdWdoXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGZvciBvdmVybGluZVxyXG4gICAgaWYgKFxyXG4gICAgICBmb3JtYXR0aW5nLm92ZXJsaW5lIHx8XHJcbiAgICAgIChmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlICYmXHJcbiAgICAgICAgZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwib3ZlcmxpbmVcIikpXHJcbiAgICApIHtcclxuICAgICAgZGVjb3JhdGlvbnMucHVzaChcIm92ZXJsaW5lXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPiAwID8gZGVjb3JhdGlvbnMuam9pbihcIiBcIikgOiBcIm5vbmVcIjtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRUZXh0QWxpZ24gPSAoYWxpZ25tZW50KSA9PiB7XHJcbiAgICBjb25zdCBhbGlnbm1lbnRzID0ge1xyXG4gICAgICBMZWZ0QWxpZ246IFwibGVmdFwiLFxyXG4gICAgICBSaWdodEFsaWduOiBcInJpZ2h0XCIsXHJcbiAgICAgIENlbnRlckFsaWduOiBcImNlbnRlclwiLFxyXG4gICAgICBMZWZ0SnVzdGlmaWVkOiBcImp1c3RpZnlcIixcclxuICAgICAgUmlnaHRKdXN0aWZpZWQ6IFwianVzdGlmeVwiLFxyXG4gICAgICBDZW50ZXJKdXN0aWZpZWQ6IFwiY2VudGVyXCIsXHJcbiAgICAgIEZ1bGx5SnVzdGlmaWVkOiBcImp1c3RpZnlcIixcclxuICAgIH07XHJcbiAgICByZXR1cm4gYWxpZ25tZW50c1thbGlnbm1lbnRdIHx8IFwibGVmdFwiO1xyXG4gIH07XHJcblxyXG4gIC8vIEVOSEFOQ0VEOiBQaXhlbC1wZXJmZWN0IHRleHQgbWVhc3VyZW1lbnQgdXNpbmcgY2FudmFzIGZvciBhY2N1cmFjeVxyXG4gIGNvbnN0IG1lYXN1cmVUZXh0QWNjdXJhdGVseSA9IChcclxuICAgIHRleHQsXHJcbiAgICBmb250U2l6ZSxcclxuICAgIGZvbnRGYW1pbHksXHJcbiAgICBmb250V2VpZ2h0LFxyXG4gICAgZm9udFN0eWxlXHJcbiAgKSA9PiB7XHJcbiAgICAvLyBDcmVhdGUgYSBjYW52YXMgZm9yIHByZWNpc2UgdGV4dCBtZWFzdXJlbWVudFxyXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgLy8gU2V0IGZvbnQgcHJvcGVydGllcyB0byBtYXRjaCB0aGUgdGV4dFxyXG4gICAgY3R4LmZvbnQgPSBgJHtmb250U3R5bGV9ICR7Zm9udFdlaWdodH0gJHtmb250U2l6ZX1weCAke2ZvbnRGYW1pbHl9YDtcclxuXHJcbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xyXG4gICAgY29uc3Qgd2lkdGggPSBtZXRyaWNzLndpZHRoO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gZm9udFNpemUgKiAxLjI7IC8vIEFwcHJveGltYXRlIGhlaWdodCBiYXNlZCBvbiBmb250IHNpemVcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aCxcclxuICAgICAgaGVpZ2h0LFxyXG4gICAgICBhY3R1YWxCb3VuZHM6XHJcbiAgICAgICAgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBJTVBST1ZFRDogQ2FsY3VsYXRlIHRleHQgbWV0cmljcyB3aXRoIG1vcmUgZ2VuZXJvdXMgc3BhY2luZ1xyXG4gIGNvbnN0IGNhbGN1bGF0ZVRleHRNZXRyaWNzID0gKFxyXG4gICAgdGV4dCxcclxuICAgIGZvbnRTaXplLFxyXG4gICAgbGluZUhlaWdodCxcclxuICAgIGNvbnRhaW5lcldpZHRoLFxyXG4gICAgY29udGFpbmVySGVpZ2h0LFxyXG4gICAgZm9udEZhbWlseSA9IFwiQXJpYWxcIixcclxuICAgIGZvbnRXZWlnaHQgPSBcIm5vcm1hbFwiLFxyXG4gICAgZm9udFN0eWxlID0gXCJub3JtYWxcIlxyXG4gICkgPT4ge1xyXG4gICAgaWYgKCF0ZXh0KVxyXG4gICAgICByZXR1cm4geyB3aWxsT3ZlcmZsb3c6IGZhbHNlLCBlc3RpbWF0ZWRMaW5lczogMCwgZXN0aW1hdGVkVGV4dEhlaWdodDogMCB9O1xyXG5cclxuICAgIC8vIE1ldGhvZCAxOiBDYW52YXMtYmFzZWQgbWVhc3VyZW1lbnQgKG1vc3QgYWNjdXJhdGUpXHJcbiAgICBjb25zdCBjYW52YXNNZXRyaWNzID0gbWVhc3VyZVRleHRBY2N1cmF0ZWx5KFxyXG4gICAgICB0ZXh0LFxyXG4gICAgICBmb250U2l6ZSxcclxuICAgICAgZm9udEZhbWlseSxcclxuICAgICAgZm9udFdlaWdodCxcclxuICAgICAgZm9udFN0eWxlXHJcbiAgICApO1xyXG5cclxuICAgIC8vIElNUFJPVkVEOiBNb3JlIGdlbmVyb3VzIGxpbmUgaGVpZ2h0IGNhbGN1bGF0aW9uXHJcbiAgICBsZXQgbGluZUhlaWdodFB4O1xyXG4gICAgaWYgKHR5cGVvZiBsaW5lSGVpZ2h0ID09PSBcInN0cmluZ1wiICYmIGxpbmVIZWlnaHQuaW5jbHVkZXMoXCJweFwiKSkge1xyXG4gICAgICBsaW5lSGVpZ2h0UHggPSBwYXJzZUZsb2F0KGxpbmVIZWlnaHQpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGluZUhlaWdodCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICBsaW5lSGVpZ2h0UHggPSBsaW5lSGVpZ2h0ICogZm9udFNpemU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBQYXJzZSBDU1MgbGluZS1oZWlnaHQgdmFsdWVzIGxpa2UgXCIxLjJcIiwgXCIxLjVcIiwgZXRjLlxyXG4gICAgICBjb25zdCBudW1lcmljTGluZUhlaWdodCA9IHBhcnNlRmxvYXQobGluZUhlaWdodCkgfHwgMS4yO1xyXG4gICAgICBsaW5lSGVpZ2h0UHggPSBudW1lcmljTGluZUhlaWdodCAqIGZvbnRTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZJWEVEOiBNb3JlIGFjY3VyYXRlIHdvcmQtYmFzZWQgd3JhcHBpbmcgbGlrZSBJbkRlc2lnblxyXG4gICAgY29uc3QgZWZmZWN0aXZlV2lkdGggPSBjb250YWluZXJXaWR0aCAtIDQ7IC8vIEFjY291bnQgZm9yIHBhZGRpbmdcclxuXHJcbiAgICAvLyBTcGxpdCB0ZXh0IGludG8gd29yZHMgYW5kIG1lYXN1cmUgYWN0dWFsIHdpZHRoXHJcbiAgICBjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoL1xccysvKS5maWx0ZXIoKHdvcmQpID0+IHdvcmQubGVuZ3RoID4gMCk7XHJcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnRMaW5lID0gXCJcIjtcclxuICAgIGxldCBjdXJyZW50TGluZVdpZHRoID0gMDtcclxuXHJcbiAgICAvLyBDcmVhdGUgY2FudmFzIGNvbnRleHQgZm9yIGFjY3VyYXRlIHdvcmQgbWVhc3VyZW1lbnRcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgY3R4LmZvbnQgPSBgJHtmb250U3R5bGV9ICR7Zm9udFdlaWdodH0gJHtmb250U2l6ZX1weCAke2ZvbnRGYW1pbHl9YDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHdvcmQgPSB3b3Jkc1tpXTtcclxuICAgICAgY29uc3Qgd29yZFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHdvcmQpLndpZHRoO1xyXG4gICAgICBjb25zdCBzcGFjZVdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KFwiIFwiKS53aWR0aDtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGFkZGluZyB0aGlzIHdvcmQgd291bGQgZXhjZWVkIHRoZSBsaW5lIHdpZHRoXHJcbiAgICAgIGNvbnN0IHdvcmRXaXRoU3BhY2VXaWR0aCA9IGN1cnJlbnRMaW5lXHJcbiAgICAgICAgPyB3b3JkV2lkdGggKyBzcGFjZVdpZHRoXHJcbiAgICAgICAgOiB3b3JkV2lkdGg7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgY3VycmVudExpbmUgJiZcclxuICAgICAgICBjdXJyZW50TGluZVdpZHRoICsgd29yZFdpdGhTcGFjZVdpZHRoID4gZWZmZWN0aXZlV2lkdGhcclxuICAgICAgKSB7XHJcbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgbGluZVxyXG4gICAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xyXG4gICAgICAgIGN1cnJlbnRMaW5lID0gd29yZDtcclxuICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gd29yZFdpZHRoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEFkZCB3b3JkIHRvIGN1cnJlbnQgbGluZVxyXG4gICAgICAgIGlmIChjdXJyZW50TGluZSkge1xyXG4gICAgICAgICAgY3VycmVudExpbmUgKz0gXCIgXCIgKyB3b3JkO1xyXG4gICAgICAgICAgY3VycmVudExpbmVXaWR0aCArPSB3b3JkV2l0aFNwYWNlV2lkdGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGN1cnJlbnRMaW5lID0gd29yZDtcclxuICAgICAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB3b3JkV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHRoZSBsYXN0IGxpbmUgaWYgaXQgaGFzIGNvbnRlbnRcclxuICAgIGlmIChjdXJyZW50TGluZSkge1xyXG4gICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBlc3RpbWF0ZWRMaW5lcyA9IE1hdGgubWF4KDEsIGxpbmVzLmxlbmd0aCk7XHJcbiAgICBjb25zdCBlc3RpbWF0ZWRUZXh0SGVpZ2h0ID0gZXN0aW1hdGVkTGluZXMgKiBsaW5lSGVpZ2h0UHg7XHJcblxyXG4gICAgLy8gQWNjb3VudCBmb3IgcGFkZGluZyBpbiBhdmFpbGFibGUgaGVpZ2h0XHJcbiAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSA0O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGVzdGltYXRlZExpbmVzLFxyXG4gICAgICBlc3RpbWF0ZWRUZXh0SGVpZ2h0LFxyXG4gICAgICBsaW5lSGVpZ2h0UHgsXHJcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcclxuICAgICAgYWN0dWFsTGluZXM6IGxpbmVzLCAvLyBJbmNsdWRlIGFjdHVhbCBsaW5lIGJyZWFrZG93biBmb3IgZGVidWdnaW5nXHJcbiAgICAgIHdpbGxPdmVyZmxvdzogZXN0aW1hdGVkVGV4dEhlaWdodCA+IGF2YWlsYWJsZUhlaWdodCxcclxuICAgICAgb3ZlcmZpbGxSYXRpbzogZXN0aW1hdGVkVGV4dEhlaWdodCAvIGF2YWlsYWJsZUhlaWdodCxcclxuICAgICAgb3ZlcmZsb3dTZXZlcml0eTpcclxuICAgICAgICBlc3RpbWF0ZWRUZXh0SGVpZ2h0ID4gYXZhaWxhYmxlSGVpZ2h0ICogMS41XHJcbiAgICAgICAgICA/IFwic2V2ZXJlXCJcclxuICAgICAgICAgIDogZXN0aW1hdGVkVGV4dEhlaWdodCA+IGF2YWlsYWJsZUhlaWdodCAqIDEuMlxyXG4gICAgICAgICAgPyBcIm1vZGVyYXRlXCJcclxuICAgICAgICAgIDogXCJtaW5vclwiLFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBFTkhBTkNFRDogTXVsdGlwbGUgdGV4dCBmaXR0aW5nIHN0cmF0ZWdpZXMgZm9yIHBpeGVsLXBlcmZlY3QgZGlzcGxheVxyXG4gIGNvbnN0IFRFWFRfRklUVElOR19TVFJBVEVHSUVTID0ge1xyXG4gICAgQVVUT19TQ0FMRTogXCJhdXRvX3NjYWxlXCIsIC8vIFJlZHVjZSBmb250IHNpemUgdG8gZml0XHJcbiAgICBUUlVOQ0FURTogXCJ0cnVuY2F0ZVwiLCAvLyBDdXQgb2ZmIHdpdGggZWxsaXBzaXNcclxuICAgIEFMTE9XX09WRVJGTE9XOiBcImFsbG93X292ZXJmbG93XCIsIC8vIExldCB0ZXh0IG92ZXJmbG93IG5hdHVyYWxseVxyXG4gICAgUFJFQ0lTRV9GSVQ6IFwicHJlY2lzZV9maXRcIiwgLy8gSW5EZXNpZ24tc3R5bGUgcHJlY2lzZSBmaXR0aW5nXHJcbiAgICBDT01QUkVTU19MSU5FUzogXCJjb21wcmVzc19saW5lc1wiLCAvLyBSZWR1Y2UgbGluZSBoZWlnaHQgZmlyc3RcclxuICB9O1xyXG5cclxuICAvLyBDb25maWd1cmF0aW9uIC0geW91IGNhbiBjaGFuZ2UgdGhpcyBiYXNlZCBvbiB5b3VyIHByZWZlcmVuY2VcclxuICBjb25zdCBbdGV4dEZpdHRpbmdTdHJhdGVneSwgc2V0VGV4dEZpdHRpbmdTdHJhdGVneV0gPSB1c2VTdGF0ZShcclxuICAgIFRFWFRfRklUVElOR19TVFJBVEVHSUVTLlBSRUNJU0VfRklUXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgZ2V0T3B0aW1hbFRleHRTdHlsZXMgPSAoXHJcbiAgICBiYXNlU3R5bGVzLFxyXG4gICAgdGV4dE1ldHJpY3MsXHJcbiAgICBjb250YWluZXJXaWR0aCxcclxuICAgIGNvbnRhaW5lckhlaWdodCxcclxuICAgIHN0cmF0ZWd5ID0gdGV4dEZpdHRpbmdTdHJhdGVneVxyXG4gICkgPT4ge1xyXG4gICAgaWYgKCF0ZXh0TWV0cmljcy53aWxsT3ZlcmZsb3cpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdHlsZXM6IGJhc2VTdHlsZXMsXHJcbiAgICAgICAgd2FzQWRqdXN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGFkanVzdG1lbnREZXRhaWxzOiBudWxsLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZvbnRTaXplID0gcGFyc2VGbG9hdChiYXNlU3R5bGVzLmZvbnRTaXplKTtcclxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBwYXJzZUZsb2F0KGJhc2VTdHlsZXMubGluZUhlaWdodCk7XHJcblxyXG4gICAgc3dpdGNoIChzdHJhdGVneSkge1xyXG4gICAgICBjYXNlIFRFWFRfRklUVElOR19TVFJBVEVHSUVTLkFVVE9fU0NBTEU6IHtcclxuICAgICAgICAvLyBQcm9ncmVzc2l2ZSBmb250IHNpemUgcmVkdWN0aW9uXHJcbiAgICAgICAgY29uc3QgbWF4UmVkdWN0aW9uID1cclxuICAgICAgICAgIHRleHRNZXRyaWNzLm92ZXJmbG93U2V2ZXJpdHkgPT09IFwic2V2ZXJlXCJcclxuICAgICAgICAgICAgPyAwLjdcclxuICAgICAgICAgICAgOiB0ZXh0TWV0cmljcy5vdmVyZmxvd1NldmVyaXR5ID09PSBcIm1vZGVyYXRlXCJcclxuICAgICAgICAgICAgPyAwLjhcclxuICAgICAgICAgICAgOiAwLjk7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBNYXRoLm1heChcclxuICAgICAgICAgIG1heFJlZHVjdGlvbixcclxuICAgICAgICAgIDEgLyB0ZXh0TWV0cmljcy5vdmVyZmlsbFJhdGlvXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN0eWxlczoge1xyXG4gICAgICAgICAgICAuLi5iYXNlU3R5bGVzLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogYCR7TWF0aC5tYXgoOCwgZm9udFNpemUgKiBzY2FsZUZhY3Rvcil9cHhgLFxyXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiBNYXRoLm1heCgwLjksIGxpbmVIZWlnaHQgKiBzY2FsZUZhY3RvciksXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHdhc0FkanVzdGVkOiB0cnVlLFxyXG4gICAgICAgICAgYWRqdXN0bWVudERldGFpbHM6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJmb250X3NjYWxlZFwiLFxyXG4gICAgICAgICAgICBzY2FsZUZhY3Rvcjogc2NhbGVGYWN0b3IsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsU2l6ZTogZm9udFNpemUsXHJcbiAgICAgICAgICAgIG5ld1NpemU6IGZvbnRTaXplICogc2NhbGVGYWN0b3IsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgVEVYVF9GSVRUSU5HX1NUUkFURUdJRVMuVFJVTkNBVEU6IHtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgbGluZXMgY2FuIGZpdFxyXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZUxpbmVzID0gTWF0aC5mbG9vcihcclxuICAgICAgICAgIHRleHRNZXRyaWNzLmF2YWlsYWJsZUhlaWdodCAvIHRleHRNZXRyaWNzLmxpbmVIZWlnaHRQeFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgdHJ1bmNhdGVBdExpbmUgPSBNYXRoLm1heCgxLCBhdmFpbGFibGVMaW5lcyk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdHlsZXM6IHtcclxuICAgICAgICAgICAgLi4uYmFzZVN0eWxlcyxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXHJcbiAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiBcIi13ZWJraXQtYm94XCIsXHJcbiAgICAgICAgICAgIFdlYmtpdExpbmVDbGFtcDogdHJ1bmNhdGVBdExpbmUsXHJcbiAgICAgICAgICAgIFdlYmtpdEJveE9yaWVudDogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiBiYXNlU3R5bGVzLmxpbmVIZWlnaHQsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgd2FzQWRqdXN0ZWQ6IHRydWUsXHJcbiAgICAgICAgICBhZGp1c3RtZW50RGV0YWlsczoge1xyXG4gICAgICAgICAgICB0eXBlOiBcInRleHRfdHJ1bmNhdGVkXCIsXHJcbiAgICAgICAgICAgIHZpc2libGVMaW5lczogdHJ1bmNhdGVBdExpbmUsXHJcbiAgICAgICAgICAgIHRvdGFsTGluZXM6IHRleHRNZXRyaWNzLmVzdGltYXRlZExpbmVzLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlIFRFWFRfRklUVElOR19TVFJBVEVHSUVTLkNPTVBSRVNTX0xJTkVTOiB7XHJcbiAgICAgICAgLy8gRmlyc3QgdHJ5IHJlZHVjaW5nIGxpbmUgaGVpZ2h0LCB0aGVuIGZvbnQgc2l6ZSBpZiBuZWVkZWRcclxuICAgICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSB0ZXh0TWV0cmljcy5hdmFpbGFibGVIZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IHRleHRNZXRyaWNzLmVzdGltYXRlZFRleHRIZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgY29tcHJlc3Npb25SYXRpbyA9IHRhcmdldEhlaWdodCAvIGN1cnJlbnRIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChjb21wcmVzc2lvblJhdGlvID4gMC44KSB7XHJcbiAgICAgICAgICAvLyBKdXN0IGNvbXByZXNzIGxpbmUgaGVpZ2h0XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdHlsZXM6IHtcclxuICAgICAgICAgICAgICAuLi5iYXNlU3R5bGVzLFxyXG4gICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IE1hdGgubWF4KDAuOCwgbGluZUhlaWdodCAqIGNvbXByZXNzaW9uUmF0aW8pLFxyXG4gICAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3YXNBZGp1c3RlZDogdHJ1ZSxcclxuICAgICAgICAgICAgYWRqdXN0bWVudERldGFpbHM6IHtcclxuICAgICAgICAgICAgICB0eXBlOiBcImxpbmVfaGVpZ2h0X2NvbXByZXNzZWRcIixcclxuICAgICAgICAgICAgICBvcmlnaW5hbExpbmVIZWlnaHQ6IGxpbmVIZWlnaHQsXHJcbiAgICAgICAgICAgICAgbmV3TGluZUhlaWdodDogbGluZUhlaWdodCAqIGNvbXByZXNzaW9uUmF0aW8sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBDb21wcmVzcyBib3RoIGxpbmUgaGVpZ2h0IGFuZCBmb250IHNpemVcclxuICAgICAgICAgIGNvbnN0IGZvbnRSZWR1Y3Rpb24gPSBNYXRoLm1heCgwLjgsIGNvbXByZXNzaW9uUmF0aW8pO1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3R5bGVzOiB7XHJcbiAgICAgICAgICAgICAgLi4uYmFzZVN0eWxlcyxcclxuICAgICAgICAgICAgICBmb250U2l6ZTogYCR7Zm9udFNpemUgKiBmb250UmVkdWN0aW9ufXB4YCxcclxuICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBNYXRoLm1heCgwLjgsIGxpbmVIZWlnaHQgKiBjb21wcmVzc2lvblJhdGlvKSxcclxuICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd2FzQWRqdXN0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGFkanVzdG1lbnREZXRhaWxzOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogXCJmdWxsX2NvbXByZXNzaW9uXCIsXHJcbiAgICAgICAgICAgICAgZm9udFJlZHVjdGlvbjogZm9udFJlZHVjdGlvbixcclxuICAgICAgICAgICAgICBsaW5lSGVpZ2h0UmVkdWN0aW9uOiBjb21wcmVzc2lvblJhdGlvLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgVEVYVF9GSVRUSU5HX1NUUkFURUdJRVMuUFJFQ0lTRV9GSVQ6IHtcclxuICAgICAgICAvLyBFTkhBTkNFRDogTW9yZSBudWFuY2VkIGZpdHRpbmcgYXBwcm9hY2hcclxuICAgICAgICBjb25zdCBjb21wcmVzc2lvbk5lZWRlZCA9XHJcbiAgICAgICAgICB0ZXh0TWV0cmljcy5hdmFpbGFibGVIZWlnaHQgLyB0ZXh0TWV0cmljcy5lc3RpbWF0ZWRUZXh0SGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoY29tcHJlc3Npb25OZWVkZWQgPj0gMC45NSkge1xyXG4gICAgICAgICAgLy8gVGV4dCBmaXRzIHdlbGwsIGp1c3QgZW5zdXJlIG5vIG92ZXJmbG93XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdHlsZXM6IHtcclxuICAgICAgICAgICAgICAuLi5iYXNlU3R5bGVzLFxyXG4gICAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3YXNBZGp1c3RlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGFkanVzdG1lbnREZXRhaWxzOiB7IHR5cGU6IFwibm9fYWRqdXN0bWVudF9uZWVkZWRcIiB9LFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvbXByZXNzaW9uTmVlZGVkID4gMC44NSkge1xyXG4gICAgICAgICAgLy8gTWlub3IgYWRqdXN0bWVudCAtIGp1c3QgcmVkdWNlIGxpbmUgaGVpZ2h0IHNsaWdodGx5XHJcbiAgICAgICAgICBjb25zdCBsaW5lSGVpZ2h0UmVkdWN0aW9uID0gTWF0aC5tYXgoMC45LCBjb21wcmVzc2lvbk5lZWRlZCAqIDEuMDUpO1xyXG5cclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0eWxlczoge1xyXG4gICAgICAgICAgICAgIC4uLmJhc2VTdHlsZXMsXHJcbiAgICAgICAgICAgICAgbGluZUhlaWdodDogTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICAwLjksXHJcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGJhc2VTdHlsZXMubGluZUhlaWdodCkgKiBsaW5lSGVpZ2h0UmVkdWN0aW9uXHJcbiAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd2FzQWRqdXN0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGFkanVzdG1lbnREZXRhaWxzOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogXCJtaW5vcl9saW5lX2hlaWdodF9hZGp1c3RtZW50XCIsXHJcbiAgICAgICAgICAgICAgbGluZUhlaWdodFJlZHVjdGlvbixcclxuICAgICAgICAgICAgICBvcmlnaW5hbExpbmVIZWlnaHQ6IGJhc2VTdHlsZXMubGluZUhlaWdodCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb21wcmVzc2lvbk5lZWRlZCA+IDAuNykge1xyXG4gICAgICAgICAgLy8gTW9kZXJhdGUgYWRqdXN0bWVudCAtIGNvbXByZXNzIGJvdGggZm9udCBhbmQgbGluZSBoZWlnaHQgcHJvcG9ydGlvbmFsbHlcclxuICAgICAgICAgIGNvbnN0IGZvbnRTY2FsZSA9IE1hdGgubWF4KDAuOSwgTWF0aC5zcXJ0KGNvbXByZXNzaW9uTmVlZGVkKSk7IC8vIExlc3MgYWdncmVzc2l2ZSBmb250IHNjYWxpbmdcclxuICAgICAgICAgIGNvbnN0IGxpbmVTY2FsZSA9IE1hdGgubWF4KDAuODUsIGNvbXByZXNzaW9uTmVlZGVkIC8gZm9udFNjYWxlKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdHlsZXM6IHtcclxuICAgICAgICAgICAgICAuLi5iYXNlU3R5bGVzLFxyXG4gICAgICAgICAgICAgIGZvbnRTaXplOiBgJHtmb250U2l6ZSAqIGZvbnRTY2FsZX1weGAsXHJcbiAgICAgICAgICAgICAgbGluZUhlaWdodDogTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICAwLjg1LFxyXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChiYXNlU3R5bGVzLmxpbmVIZWlnaHQpICogbGluZVNjYWxlXHJcbiAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd2FzQWRqdXN0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGFkanVzdG1lbnREZXRhaWxzOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogXCJtb2RlcmF0ZV9kdWFsX2FkanVzdG1lbnRcIixcclxuICAgICAgICAgICAgICBmb250U2NhbGUsXHJcbiAgICAgICAgICAgICAgbGluZVNjYWxlLFxyXG4gICAgICAgICAgICAgIGNvbXByZXNzaW9uTmVlZGVkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gTWFqb3IgYWRqdXN0bWVudCAtIGFwcGx5IHJlYXNvbmFibGUgY29tcHJlc3Npb24gdGhlbiBhbGxvdyBzbGlnaHQgb3ZlcmZsb3dcclxuICAgICAgICAgIGNvbnN0IG1heEZvbnRTY2FsZSA9IDAuODU7IC8vIExlc3MgYWdncmVzc2l2ZSB0aGFuIGJlZm9yZVxyXG4gICAgICAgICAgY29uc3QgbWF4TGluZVNjYWxlID0gMC44OyAvLyBMZXNzIGFnZ3Jlc3NpdmUgdGhhbiBiZWZvcmVcclxuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdHlsZXM6IHtcclxuICAgICAgICAgICAgICAuLi5iYXNlU3R5bGVzLFxyXG4gICAgICAgICAgICAgIGZvbnRTaXplOiBgJHtmb250U2l6ZSAqIG1heEZvbnRTY2FsZX1weGAsXHJcbiAgICAgICAgICAgICAgbGluZUhlaWdodDogTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICAwLjgsXHJcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGJhc2VTdHlsZXMubGluZUhlaWdodCkgKiBtYXhMaW5lU2NhbGVcclxuICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IHNvbWUgb3ZlcmZsb3cgcmF0aGVyIHRoYW4gaGFyc2ggdHJ1bmNhdGlvblxyXG4gICAgICAgICAgICAgIG1heEhlaWdodDogYCR7dGV4dE1ldHJpY3MuYXZhaWxhYmxlSGVpZ2h0fXB4YCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd2FzQWRqdXN0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGFkanVzdG1lbnREZXRhaWxzOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogXCJtYWpvcl9hZGp1c3RtZW50X3dpdGhfb3ZlcmZsb3dcIixcclxuICAgICAgICAgICAgICBmb250U2NhbGU6IG1heEZvbnRTY2FsZSxcclxuICAgICAgICAgICAgICBsaW5lU2NhbGU6IG1heExpbmVTY2FsZSxcclxuICAgICAgICAgICAgICBhbGxvd2VkT3ZlcmZsb3c6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY2FzZSBURVhUX0ZJVFRJTkdfU1RSQVRFR0lFUy5BTExPV19PVkVSRkxPVzpcclxuICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdHlsZXM6IHtcclxuICAgICAgICAgICAgLi4uYmFzZVN0eWxlcyxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwidmlzaWJsZVwiLCAvLyBMZXQgdGV4dCBvdmVyZmxvdyBuYXR1cmFsbHlcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB3YXNBZGp1c3RlZDogZmFsc2UsXHJcbiAgICAgICAgICBhZGp1c3RtZW50RGV0YWlsczogeyB0eXBlOiBcIm92ZXJmbG93X2FsbG93ZWRcIiB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCByZW5kZXJGb3JtYXR0ZWRUZXh0ID0gKFxyXG4gICAgc3RvcnksXHJcbiAgICBjb250YWluZXJIZWlnaHQgPSBudWxsLFxyXG4gICAgYWRqdXN0ZWRGb250U2l6ZSA9IG51bGxcclxuICApID0+IHtcclxuICAgIGlmICghc3RvcnkuZm9ybWF0dGVkQ29udGVudCB8fCAhQXJyYXkuaXNBcnJheShzdG9yeS5mb3JtYXR0ZWRDb250ZW50KSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlRleHQgdmFsdWU6XCIsIHN0b3J5LnRleHQpOyAvLyBEZWJ1ZzogY2hlY2sgYWN0dWFsIHZhbHVlIGJlZm9yZSByZW5kZXJpbmdcclxuICAgICAgLy8gVXNlIENTUyB0byBwcmVzZXJ2ZSBhbGwgd2hpdGVzcGFjZSBhbmQgbmV3bGluZXNcclxuICAgICAgaWYgKHR5cGVvZiBzdG9yeS50ZXh0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIDxzcGFuXHJcbiAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJwcmUtbGluZVwiLFxyXG4gICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAge3N0b3J5LnRleHR9XHJcbiAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gPHNwYW4+e3N0b3J5LnRleHR9PC9zcGFuPjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBERUJVRzogQ291bnQgbGluZSBicmVha3MgaW4gZm9ybWF0dGVkIGNvbnRlbnRcclxuICAgIGNvbnN0IGxpbmVCcmVha0NvdW50ID0gc3RvcnkuZm9ybWF0dGVkQ29udGVudC5maWx0ZXIoXHJcbiAgICAgIChpdGVtKSA9PiBpdGVtLmZvcm1hdHRpbmc/LmlzQnJlYWtcclxuICAgICkubGVuZ3RoO1xyXG4gICAgY29uc3QgY29uc2VjdXRpdmVCcmVha3MgPSBbXTtcclxuICAgIGxldCBjdXJyZW50QnJlYWtHcm91cCA9IFtdO1xyXG5cclxuICAgIHN0b3J5LmZvcm1hdHRlZENvbnRlbnQuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKGl0ZW0uZm9ybWF0dGluZz8uaXNCcmVhaykge1xyXG4gICAgICAgIGN1cnJlbnRCcmVha0dyb3VwLnB1c2goe1xyXG4gICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICBzb3VyY2U6IGl0ZW0uZm9ybWF0dGluZy5zb3VyY2UsXHJcbiAgICAgICAgICBicmVha1R5cGU6IGl0ZW0uZm9ybWF0dGluZy5icmVha1R5cGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudEJyZWFrR3JvdXAubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50QnJlYWtHcm91cC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICBjb25zZWN1dGl2ZUJyZWFrcy5wdXNoKGN1cnJlbnRCcmVha0dyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEJyZWFrR3JvdXAgPSBbXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGN1cnJlbnRCcmVha0dyb3VwLmxlbmd0aCA+IDEpIHtcclxuICAgICAgY29uc2VjdXRpdmVCcmVha3MucHVzaChjdXJyZW50QnJlYWtHcm91cCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIGDwn46oIFJlbmRlcmluZyBmb3JtYXR0ZWQgdGV4dCB3aXRoICR7bGluZUJyZWFrQ291bnR9IHRvdGFsIGxpbmUgYnJlYWtzYFxyXG4gICAgKTtcclxuICAgIGlmIChjb25zZWN1dGl2ZUJyZWFrcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGDwn46oIEZvdW5kICR7Y29uc2VjdXRpdmVCcmVha3MubGVuZ3RofSBncm91cHMgb2YgY29uc2VjdXRpdmUgbGluZSBicmVha3M6YCxcclxuICAgICAgICBjb25zZWN1dGl2ZUJyZWFrc1xyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdG9yeS5mb3JtYXR0ZWRDb250ZW50XHJcbiAgICAgIC5tYXAoKGNvbnRlbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgLy8gRklYRUQ6IFJlbmRlciBBTEwgbGluZSBicmVha3MgdG8gcHJlc2VydmUgdXNlcidzIGludGVuZGVkIHNwYWNpbmdcclxuICAgICAgICBpZiAoY29udGVudC5mb3JtYXR0aW5nPy5pc0JyZWFrKSB7XHJcbiAgICAgICAgICAvLyBSZW5kZXIgYW55IHR5cGUgb2YgbGluZSBicmVhayAtIGRvbid0IGZpbHRlciBiYXNlZCBvbiBzb3VyY2VcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBg8J+OqCBSZW5kZXJpbmcgbGluZSBicmVhayAke2luZGV4fTogc291cmNlPSR7Y29udGVudC5mb3JtYXR0aW5nLnNvdXJjZX0sIHR5cGU9JHtjb250ZW50LmZvcm1hdHRpbmcuYnJlYWtUeXBlfWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICByZXR1cm4gPGJyIGtleT17aW5kZXh9IC8+O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGluZyA9IGNvbnRlbnQuZm9ybWF0dGluZyB8fCB7fTtcclxuICAgICAgICAvLyBDUklUSUNBTCBGSVg6IFVzZSBhZGp1c3RlZCBmb250IHNpemUgaWYgb3ZlcmZsb3cgcHJldmVudGlvbiB3YXMgYXBwbGllZFxyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRm9udFNpemUgPVxyXG4gICAgICAgICAgZm9ybWF0dGluZy5mb250U2l6ZSB8fCBzdG9yeS5zdHlsaW5nPy5mb250U2l6ZSB8fCAxMjtcclxuICAgICAgICBjb25zdCBmb250U2l6ZSA9IGFkanVzdGVkRm9udFNpemUgfHwgb3JpZ2luYWxGb250U2l6ZTtcclxuXHJcbiAgICAgICAgLy8gREVCVUc6IExvZyBzdHlsZSByZXNvbHV0aW9uIGZvciBhbnkgdGV4dCB3aXRoIGZvcm1hdHRpbmcgYXBwbGllZCAoZ2VuZXJpYyBjaGVjaylcclxuICAgICAgICBjb25zdCBoYXNGb3JtYXR0aW5nID1cclxuICAgICAgICAgIGZvcm1hdHRpbmcuZm9udFN0eWxlIHx8XHJcbiAgICAgICAgICBmb3JtYXR0aW5nLmNoYXJhY3RlclN0eWxlIHx8XHJcbiAgICAgICAgICBmb3JtYXR0aW5nLnBhcmFncmFwaFN0eWxlO1xyXG4gICAgICAgIGNvbnN0IGZpbmFsRm9udFN0eWxlID0gZ2V0Rm9udFN0eWxlKGZvcm1hdHRpbmcuZm9udFN0eWxlKTtcclxuXHJcbiAgICAgICAgaWYgKGhhc0Zvcm1hdHRpbmcgfHwgZmluYWxGb250U3R5bGUgPT09IFwiaXRhbGljXCIpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBcIvCfjqggU3R5bGUgcmVzb2x1dGlvbiBmb3IgdGV4dDpcIixcclxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoY29udGVudC50ZXh0Py5zdWJzdHJpbmcoMCwgMjApICsgXCIuLi5cIiksXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICByYXdGb3JtYXR0aW5nOiBmb3JtYXR0aW5nLFxyXG4gICAgICAgICAgICAgIHJlc29sdmVkRm9udFN0eWxlOiBmb3JtYXR0aW5nLmZvbnRTdHlsZSxcclxuICAgICAgICAgICAgICBzdG9yeURlZmF1bHRTdHlsZTogc3Rvcnkuc3R5bGluZz8uZm9udFN0eWxlLFxyXG4gICAgICAgICAgICAgIGZpbmFsRm9udFN0eWxlOiBmaW5hbEZvbnRTdHlsZSxcclxuICAgICAgICAgICAgICBjaGFyYWN0ZXJTdHlsZTogZm9ybWF0dGluZy5jaGFyYWN0ZXJTdHlsZSxcclxuICAgICAgICAgICAgICBwYXJhZ3JhcGhTdHlsZTogZm9ybWF0dGluZy5wYXJhZ3JhcGhTdHlsZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvLyBXQVJOOiBBbGVydCBpZiBpdGFsaWMgaXMgYmVpbmcgYXBwbGllZCB3aGVuIGl0IHNob3VsZG4ndCBiZVxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBmaW5hbEZvbnRTdHlsZSA9PT0gXCJpdGFsaWNcIiAmJlxyXG4gICAgICAgICAgICAoIWZvcm1hdHRpbmcuZm9udFN0eWxlIHx8IGZvcm1hdHRpbmcuZm9udFN0eWxlID09PSBcIlJlZ3VsYXJcIilcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgICAgXCLimqDvuI8gIFVORVhQRUNURUQgSVRBTElDOiBUZXh0IGlzIGJlaW5nIHN0eWxlZCBhcyBpdGFsaWMgYnV0IGZvbnRTdHlsZSBpczpcIixcclxuICAgICAgICAgICAgICBmb3JtYXR0aW5nLmZvbnRTdHlsZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSU1QUk9WRUQ6IE1vcmUgZ2VuZXJvdXMgbGluZSBoZWlnaHQgY2FsY3VsYXRpb24gZm9yIGluZGl2aWR1YWwgc3BhbnNcclxuICAgICAgICBsZXQgbGluZUhlaWdodCA9IFwiaW5oZXJpdFwiOyAvLyBJbmhlcml0IGZyb20gcGFyZW50IGNvbnRhaW5lclxyXG5cclxuICAgICAgICBpZiAoZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0KSB7XHJcbiAgICAgICAgICBsaW5lSGVpZ2h0ID0gZm9ybWF0dGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0dGluZy5sZWFkaW5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGlmIChmb3JtYXR0aW5nLmxlYWRpbmcgPT09IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBcImluaGVyaXRcIjtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRpbmcubGVhZGluZyA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAvLyBJTVBST1ZFRDogTW9yZSBnZW5lcm91cyBsaW5lIGhlaWdodCByYW5nZSB0byBwcmV2ZW50IHRleHQgY2hvcHBpbmdcclxuICAgICAgICAgICAgY29uc3QgcmF0aW8gPSBmb3JtYXR0aW5nLmxlYWRpbmcgLyBmb250U2l6ZTtcclxuICAgICAgICAgICAgbGluZUhlaWdodCA9IE1hdGgubWF4KDEuMSwgTWF0aC5taW4oMi41LCByYXRpbykpOyAvLyBNb3JlIGdlbmVyb3VzIHJhbmdlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFTkhBTkNFRDogVXNlIGNvbXBsZXRlIGNoYXJhY3RlciBzdHlsZXMgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgY29uc3QgY29tcGxldGVTdHlsZXMgPSBmb3JtYXR0aW5nLmNvbXBsZXRlU3R5bGVzIHx8IHt9O1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IHtcclxuICAgICAgICAgIGZvbnRTaXplOiBgJHtmb250U2l6ZX1weGAsXHJcbiAgICAgICAgICBmb250RmFtaWx5OlxyXG4gICAgICAgICAgICBmb3JtYXR0aW5nLmZvbnRGYW1pbHkgfHxcclxuICAgICAgICAgICAgc3Rvcnkuc3R5bGluZz8uZm9udEZhbWlseSB8fFxyXG4gICAgICAgICAgICBcIkFyaWFsLCBzYW5zLXNlcmlmXCIsXHJcblxyXG4gICAgICAgICAgLy8gRU5IQU5DRUQ6IFVzZSBjb21wbGV0ZSBzdHlsZSBhbmFseXNpcyBmb3IgcHJvcGVyIGZvbnQgd2VpZ2h0L3N0eWxlXHJcbiAgICAgICAgICBmb250V2VpZ2h0OlxyXG4gICAgICAgICAgICBjb21wbGV0ZVN0eWxlcy5mb250V2VpZ2h0IHx8XHJcbiAgICAgICAgICAgIGdldEZvbnRXZWlnaHQoZm9ybWF0dGluZy5mb250U3R5bGUpIHx8XHJcbiAgICAgICAgICAgIFwiNDAwXCIsXHJcbiAgICAgICAgICBmb250U3R5bGU6XHJcbiAgICAgICAgICAgIGNvbXBsZXRlU3R5bGVzLmZvbnRTdHlsZSB8fFxyXG4gICAgICAgICAgICBnZXRGb250U3R5bGUoZm9ybWF0dGluZy5mb250U3R5bGUpIHx8XHJcbiAgICAgICAgICAgIFwibm9ybWFsXCIsXHJcblxyXG4gICAgICAgICAgY29sb3I6IGNvbnZlcnRDb2xvcihmb3JtYXR0aW5nLmZpbGxDb2xvcikgfHwgXCJibGFja1wiLFxyXG4gICAgICAgICAgdGV4dEFsaWduOiBnZXRUZXh0QWxpZ24oZm9ybWF0dGluZy5hbGlnbm1lbnQpLFxyXG4gICAgICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodCxcclxuICAgICAgICAgIGxldHRlclNwYWNpbmc6IGZvcm1hdHRpbmcudHJhY2tpbmdcclxuICAgICAgICAgICAgPyBgJHtmb3JtYXR0aW5nLnRyYWNraW5nIC8gMTAwMH1lbWBcclxuICAgICAgICAgICAgOiBcIm5vcm1hbFwiLFxyXG5cclxuICAgICAgICAgIC8vIEVOSEFOQ0VEOiBDb21wbGV0ZSB0ZXh0IGRlY29yYXRpb24gc3VwcG9ydFxyXG4gICAgICAgICAgdGV4dERlY29yYXRpb246XHJcbiAgICAgICAgICAgIGNvbXBsZXRlU3R5bGVzLnRleHREZWNvcmF0aW9uIHx8IGV4dHJhY3RUZXh0RGVjb3JhdGlvbnMoZm9ybWF0dGluZyksXHJcblxyXG4gICAgICAgICAgLy8gRU5IQU5DRUQ6IFRleHQgZWZmZWN0c1xyXG4gICAgICAgICAgdGV4dFRyYW5zZm9ybTogY29tcGxldGVTdHlsZXMudGV4dFRyYW5zZm9ybSB8fCBcIm5vbmVcIixcclxuICAgICAgICAgIHRleHRTaGFkb3c6IGNvbXBsZXRlU3R5bGVzLnRleHRTaGFkb3cgfHwgXCJub25lXCIsXHJcblxyXG4gICAgICAgICAgLy8gRklYRUQ6IFJlbW92ZSBtYXJnaW5zIHRoYXQgY291bGQgY2F1c2Ugc3BhY2luZyBpc3N1ZXNcclxuICAgICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICAgIHBhZGRpbmc6IDAsXHJcblxyXG4gICAgICAgICAgLy8gT25seSBhcHBseSBpbmRlbnRhdGlvbiBpZiBleHBsaWNpdGx5IHNwZWNpZmllZFxyXG4gICAgICAgICAgLi4uKGZvcm1hdHRpbmcubGVmdEluZGVudCAmJiB7XHJcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IGAke2Zvcm1hdHRpbmcubGVmdEluZGVudH1weGAsXHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIC4uLihmb3JtYXR0aW5nLnJpZ2h0SW5kZW50ICYmIHtcclxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IGAke2Zvcm1hdHRpbmcucmlnaHRJbmRlbnR9cHhgLFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICAuLi4oZm9ybWF0dGluZy5maXJzdExpbmVJbmRlbnQgJiYge1xyXG4gICAgICAgICAgICB0ZXh0SW5kZW50OiBgJHtmb3JtYXR0aW5nLmZpcnN0TGluZUluZGVudH1weGAsXHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIC4uLihmb3JtYXR0aW5nLnNwYWNlQmVmb3JlICYmIHtcclxuICAgICAgICAgICAgbWFyZ2luVG9wOiBgJHtmb3JtYXR0aW5nLnNwYWNlQmVmb3JlfXB4YCxcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgLi4uKGZvcm1hdHRpbmcuc3BhY2VBZnRlciAmJiB7XHJcbiAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogYCR7Zm9ybWF0dGluZy5zcGFjZUFmdGVyfXB4YCxcclxuICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgIC8vIEVOSEFOQ0VEOiBBZHZhbmNlZCBJbkRlc2lnbiBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAuLi4oY29tcGxldGVTdHlsZXMuYmFzZWxpbmVTaGlmdCAmJiB7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IGAke2NvbXBsZXRlU3R5bGVzLmJhc2VsaW5lU2hpZnR9cHhgLFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICAuLi4oY29tcGxldGVTdHlsZXMuaG9yaXpvbnRhbFNjYWxlICYmXHJcbiAgICAgICAgICAgIGNvbXBsZXRlU3R5bGVzLmhvcml6b250YWxTY2FsZSAhPT0gMTAwICYmIHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZVgoJHtjb21wbGV0ZVN0eWxlcy5ob3Jpem9udGFsU2NhbGUgLyAxMDB9KWAsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENSSVRJQ0FMIEZJWDogQWRkIHNwYWNlIGFmdGVyIHNwYW4gaWYgbmVlZGVkIHRvIHByZXZlbnQgd29yZCBqb2luaW5nXHJcbiAgICAgICAgY29uc3QgY3VycmVudFRleHQgPSBjb250ZW50LnRleHQgfHwgXCJcIjtcclxuICAgICAgICBjb25zdCBuZXh0Q29udGVudCA9IHN0b3J5LmZvcm1hdHRlZENvbnRlbnRbaW5kZXggKyAxXTtcclxuICAgICAgICBjb25zdCBuZWVkc1NwYWNlQWZ0ZXIgPVxyXG4gICAgICAgICAgbmV4dENvbnRlbnQgJiZcclxuICAgICAgICAgICFuZXh0Q29udGVudC5mb3JtYXR0aW5nPy5pc0JyZWFrICYmXHJcbiAgICAgICAgICAhY3VycmVudFRleHQuZW5kc1dpdGgoXCIgXCIpICYmXHJcbiAgICAgICAgICAhY3VycmVudFRleHQuZW5kc1dpdGgoXCJcXG5cIikgJiZcclxuICAgICAgICAgIG5leHRDb250ZW50LnRleHQgJiZcclxuICAgICAgICAgICFuZXh0Q29udGVudC50ZXh0LnN0YXJ0c1dpdGgoXCIgXCIpICYmXHJcbiAgICAgICAgICAhbmV4dENvbnRlbnQudGV4dC5zdGFydHNXaXRoKFwiXFxuXCIpO1xyXG5cclxuICAgICAgICAvLyBERUJVRzogTG9nIHNwYWNlIGluc2VydGlvbiBmb3IgcHJvYmxlbWF0aWMgdGV4dFxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIChjdXJyZW50VGV4dC5pbmNsdWRlcyhcInBhXCIpICYmXHJcbiAgICAgICAgICAgIG5leHRDb250ZW50Py50ZXh0Py5pbmNsdWRlcyhcInZvbHVwdHVzZGFcIikpIHx8XHJcbiAgICAgICAgICAoY3VycmVudFRleHQuaW5jbHVkZXMoXCJ2b2x1cHR1c2RhXCIpICYmIGluZGV4ID4gMClcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SnIFNwYWNlIGluc2VydGlvbiBjaGVjayBbJHtpbmRleH1dOmAsIHtcclxuICAgICAgICAgICAgY3VycmVudFRleHQ6IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRUZXh0KSxcclxuICAgICAgICAgICAgbmV4dFRleHQ6IG5leHRDb250ZW50ID8gSlNPTi5zdHJpbmdpZnkobmV4dENvbnRlbnQudGV4dCkgOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgbmVlZHNTcGFjZUFmdGVyLFxyXG4gICAgICAgICAgICBjdXJyZW50RW5kc1dpdGhTcGFjZTogY3VycmVudFRleHQuZW5kc1dpdGgoXCIgXCIpLFxyXG4gICAgICAgICAgICBuZXh0U3RhcnRzV2l0aFNwYWNlOiBuZXh0Q29udGVudD8udGV4dD8uc3RhcnRzV2l0aChcIiBcIiksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICA8UmVhY3QuRnJhZ21lbnQga2V5PXtpbmRleH0+XHJcbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXtzdHlsZX0+e2NvbnRlbnQudGV4dH08L3NwYW4+XHJcbiAgICAgICAgICAgIHtuZWVkc1NwYWNlQWZ0ZXIgJiYgXCIgXCJ9XHJcbiAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5maWx0ZXIoQm9vbGVhbik7IC8vIFJlbW92ZSBudWxsIGVudHJpZXMgZnJvbSBza2lwcGVkIGxpbmUgYnJlYWtzXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0U3RvcnlTdHlsZXMgPSAoXHJcbiAgICBzdG9yeSxcclxuICAgIGNvbnRhaW5lckhlaWdodCA9IG51bGwsXHJcbiAgICBjb250YWluZXJXaWR0aCA9IG51bGxcclxuICApID0+IHtcclxuICAgIGNvbnN0IHN0eWxpbmcgPSBzdG9yeS5zdHlsaW5nIHx8IHt9O1xyXG4gICAgY29uc3QgZm9udFNpemUgPSBzdHlsaW5nLmZvbnRTaXplIHx8IDEyO1xyXG5cclxuICAgIC8vIElNUFJPVkVEOiBNb3JlIGdlbmVyb3VzIGxpbmUgaGVpZ2h0IGNhbGN1bGF0aW9uIHRvIHByZXZlbnQgdGV4dCBjaG9wcGluZ1xyXG4gICAgbGV0IGxpbmVIZWlnaHQgPSBcIjEuM1wiOyAvLyBNb3JlIGdlbmVyb3VzIGRlZmF1bHQgQ1NTIGxpbmUtaGVpZ2h0XHJcblxyXG4gICAgaWYgKHN0eWxpbmcuZWZmZWN0aXZlTGluZUhlaWdodCkge1xyXG4gICAgICBsaW5lSGVpZ2h0ID0gc3R5bGluZy5lZmZlY3RpdmVMaW5lSGVpZ2h0O1xyXG4gICAgfSBlbHNlIGlmIChzdHlsaW5nLmxlYWRpbmcgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoc3R5bGluZy5sZWFkaW5nID09PSBcImF1dG9cIikge1xyXG4gICAgICAgIGxpbmVIZWlnaHQgPSBcIjEuM1wiOyAvLyBNb3JlIGdlbmVyb3VzIGF1dG8gbGluZSBoZWlnaHRcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3R5bGluZy5sZWFkaW5nID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgLy8gQ29udmVydCBJbkRlc2lnbiBwb2ludHMgdG8gQ1NTIGxpbmUtaGVpZ2h0IHJhdGlvLCBtb3JlIGdlbmVyb3VzIHJhbmdlXHJcbiAgICAgICAgY29uc3QgcmF0aW8gPSBzdHlsaW5nLmxlYWRpbmcgLyBmb250U2l6ZTtcclxuICAgICAgICBsaW5lSGVpZ2h0ID0gTWF0aC5tYXgoMS4xLCBNYXRoLm1pbigyLjUsIHJhdGlvKSkudG9TdHJpbmcoKTsgLy8gTW9yZSBnZW5lcm91cyByYW5nZVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZm9udFNpemU6IGAke2ZvbnRTaXplfXB4YCxcclxuICAgICAgZm9udEZhbWlseTogc3R5bGluZy5mb250RmFtaWx5IHx8IFwiQXJpYWwsIHNhbnMtc2VyaWZcIixcclxuICAgICAgZm9udFdlaWdodDogZ2V0Rm9udFdlaWdodChzdHlsaW5nLmZvbnRTdHlsZSksXHJcbiAgICAgIGZvbnRTdHlsZTogZ2V0Rm9udFN0eWxlKHN0eWxpbmcuZm9udFN0eWxlKSxcclxuICAgICAgY29sb3I6IGNvbnZlcnRDb2xvcihzdHlsaW5nLmZpbGxDb2xvcikgfHwgXCJibGFja1wiLFxyXG4gICAgICB0ZXh0QWxpZ246IGdldFRleHRBbGlnbihzdHlsaW5nLmFsaWdubWVudCksXHJcbiAgICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHQsXHJcbiAgICAgIGxldHRlclNwYWNpbmc6IHN0eWxpbmcudHJhY2tpbmdcclxuICAgICAgICA/IGAke3N0eWxpbmcudHJhY2tpbmcgLyAxMDAwfWVtYFxyXG4gICAgICAgIDogXCJub3JtYWxcIixcclxuXHJcbiAgICAgIC8vIElNUFJPVkVEOiBNaW5pbWFsIHBhZGRpbmcgdG8gcHJldmVudCBjb250YWluZXIgc2l6ZSBjb25mbGljdHNcclxuICAgICAgcGFkZGluZzogXCIxcHggMnB4XCIsXHJcbiAgICAgIG1hcmdpbjogMCxcclxuXHJcbiAgICAgIC8vIEZJWEVEOiBVc2UgZnVsbCBjb250YWluZXIgc2l6ZSwgbGV0IENTUyBoYW5kbGUgb3ZlcmZsb3cgcHJvcGVybHlcclxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIiwgLy8gVXNlIGZ1bGwgY29udGFpbmVyIGhlaWdodFxyXG4gICAgICB3aWR0aDogXCIxMDAlXCIsIC8vIFVzZSBmdWxsIGNvbnRhaW5lciB3aWR0aFxyXG4gICAgICBtaW5IZWlnaHQ6IGAke2ZvbnRTaXplICogMS40fXB4YCwgLy8gTW9yZSBnZW5lcm91cyBtaW5pbXVtIGhlaWdodFxyXG5cclxuICAgICAgd29yZFdyYXA6IFwiYnJlYWstd29yZFwiLFxyXG4gICAgICBvdmVyZmxvdzogXCJ2aXNpYmxlXCIsIC8vIENIQU5HRUQ6IEFsbG93IHRleHQgdG8gYmUgdmlzaWJsZSBpbnN0ZWFkIG9mIGhpZGRlblxyXG4gICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxyXG5cclxuICAgICAgLy8gSU1QUk9WRUQ6IEJldHRlciB0ZXh0IGxheW91dCBoYW5kbGluZ1xyXG4gICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXHJcbiAgICAgIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIixcclxuICAgICAgd29yZEJyZWFrOiBcImJyZWFrLXdvcmRcIixcclxuICAgICAgb3ZlcmZsb3dXcmFwOiBcImJyZWFrLXdvcmRcIixcclxuXHJcbiAgICAgIC8vIElNUFJPVkVEOiBBbGxvdyB0ZXh0IHRvIGZsb3cgbmF0dXJhbGx5XHJcbiAgICAgIHRleHRPdmVyZmxvdzogXCJ2aXNpYmxlXCIsIC8vIERvbid0IGNsaXAgdGV4dFxyXG4gICAgICBsaW5lQ2xhbXA6IFwibm9uZVwiLCAvLyBBbGxvdyBsb25nIHdvcmRzIHRvIGJyZWFrIGlmIG5lZWRlZFxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGZsZXhib3ggYWxpZ25tZW50IHRoYXQgbWlnaHQgY2F1c2UgaXNzdWVzXHJcbiAgICAgIC8vIGp1c3RpZnlDb250ZW50OiBzdHlsaW5nLmFsaWdubWVudCA9PT0gXCJDZW50ZXJBbGlnblwiID8gXCJjZW50ZXJcIiA6IFwiZmxleC1zdGFydFwiLFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBFTkhBTkNFRDogRXh0cmFjdCBJbkRlc2lnbi1hY2N1cmF0ZSBmb3JtYXR0aW5nIGZvciBwcmVjaXNlIHRleHQgbWVhc3VyZW1lbnRcclxuICBjb25zdCBnZXRJbkRlc2lnbkFjY3VyYXRlRm9ybWF0dGluZyA9IChzdG9yeSkgPT4ge1xyXG4gICAgY29uc3Qgc3R5bGluZyA9IHN0b3J5LnN0eWxpbmcgfHwge307XHJcbiAgICBjb25zdCBmaXJzdEZvcm1hdHRlZCA9IHN0b3J5LmZvcm1hdHRlZENvbnRlbnQ/LmZpbmQoXHJcbiAgICAgIChpdGVtKSA9PiBpdGVtLmZvcm1hdHRpbmcgJiYgIWl0ZW0uZm9ybWF0dGluZy5pc0JyZWFrXHJcbiAgICApO1xyXG4gICAgY29uc3QgZm9ybWF0dGluZyA9IGZpcnN0Rm9ybWF0dGVkPy5mb3JtYXR0aW5nIHx8IHN0eWxpbmc7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZm9udFNpemU6IGZvcm1hdHRpbmcuZm9udFNpemUgfHwgc3R5bGluZy5mb250U2l6ZSB8fCAxMixcclxuICAgICAgZm9udEZhbWlseTpcclxuICAgICAgICBmb3JtYXR0aW5nLmZvbnRGYW1pbHkgfHwgc3R5bGluZy5mb250RmFtaWx5IHx8IFwiQXJpYWwsIHNhbnMtc2VyaWZcIixcclxuICAgICAgZm9udFdlaWdodDogZ2V0Rm9udFdlaWdodChmb3JtYXR0aW5nLmZvbnRTdHlsZSB8fCBzdHlsaW5nLmZvbnRTdHlsZSksXHJcbiAgICAgIGZvbnRTdHlsZTogZ2V0Rm9udFN0eWxlKGZvcm1hdHRpbmcuZm9udFN0eWxlIHx8IHN0eWxpbmcuZm9udFN0eWxlKSxcclxuICAgICAgY29sb3I6IGNvbnZlcnRDb2xvcihmb3JtYXR0aW5nLmZpbGxDb2xvciB8fCBzdHlsaW5nLmZpbGxDb2xvcikgfHwgXCJibGFja1wiLFxyXG4gICAgICB0ZXh0QWxpZ246IGdldFRleHRBbGlnbihmb3JtYXR0aW5nLmFsaWdubWVudCB8fCBzdHlsaW5nLmFsaWdubWVudCksXHJcblxyXG4gICAgICAvLyBJbkRlc2lnbi1zcGVjaWZpYyBwcm9wZXJ0aWVzIGZvciBwcmVjaXNlIG1lYXN1cmVtZW50XHJcbiAgICAgIGxlYWRpbmc6IGZvcm1hdHRpbmcubGVhZGluZyB8fCBzdHlsaW5nLmxlYWRpbmcgfHwgXCJhdXRvXCIsXHJcbiAgICAgIGxlYWRpbmdUeXBlOiBmb3JtYXR0aW5nLmxlYWRpbmdUeXBlIHx8IHN0eWxpbmcubGVhZGluZ1R5cGUgfHwgXCJhdXRvXCIsXHJcbiAgICAgIHRyYWNraW5nOiBmb3JtYXR0aW5nLnRyYWNraW5nIHx8IHN0eWxpbmcudHJhY2tpbmcgfHwgMCxcclxuICAgICAgYmFzZWxpbmVTaGlmdDogZm9ybWF0dGluZy5iYXNlbGluZVNoaWZ0IHx8IDAsXHJcblxyXG4gICAgICAvLyBUZXh0IGZyYW1lIHByb3BlcnRpZXNcclxuICAgICAgZmlyc3RCYXNlbGluZU9mZnNldDogZm9ybWF0dGluZy5maXJzdEJhc2VsaW5lT2Zmc2V0IHx8IFwiQXNjZW50T2Zmc2V0XCIsXHJcbiAgICAgIHZlcnRpY2FsSnVzdGlmaWNhdGlvbjogZm9ybWF0dGluZy52ZXJ0aWNhbEp1c3RpZmljYXRpb24gfHwgXCJUb3BBbGlnblwiLFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBpZiAobG9hZGluZykge1xyXG4gICAgcmV0dXJuIDxkaXYgc3R5bGU9e3sgcGFkZGluZzogXCIyMHB4XCIgfX0+TG9hZGluZyBkb2N1bWVudC4uLjwvZGl2PjtcclxuICB9XHJcblxyXG4gIGlmICghZG9jdW1lbnREYXRhKSB7XHJcbiAgICByZXR1cm4gPGRpdiBzdHlsZT17eyBwYWRkaW5nOiBcIjIwcHhcIiB9fT5FcnJvciBsb2FkaW5nIGRvY3VtZW50PC9kaXY+O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGhlaWdodDogXCIxMDB2aFwiIH19PlxyXG4gICAgICB7LyogRW5oYW5jZWQgU2lkZWJhciAqL31cclxuICAgICAgPGRpdlxyXG4gICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICB3aWR0aDogXCI0MDBweFwiLFxyXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcclxuICAgICAgICAgIHBhZGRpbmc6IFwiMjBweFwiLFxyXG4gICAgICAgICAgb3ZlcmZsb3dZOiBcImF1dG9cIixcclxuICAgICAgICB9fVxyXG4gICAgICA+XHJcbiAgICAgICAgey8qIFRleHQgRml0dGluZyBTdHJhdGVneSBTZWxlY3RvciAqL31cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2UzZjJmZFwiLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBcIjEycHhcIixcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjZweFwiLFxyXG4gICAgICAgICAgICBtYXJnaW5Cb3R0b206IFwiMTZweFwiLFxyXG4gICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICMyMTk2ZjNcIixcclxuICAgICAgICAgIH19XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgPGg0XHJcbiAgICAgICAgICAgIHN0eWxlPXt7IG1hcmdpbjogXCIwIDAgOHB4IDBcIiwgY29sb3I6IFwiIzE5NzZkMlwiLCBmb250U2l6ZTogXCIxNHB4XCIgfX1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAg8J+OryBUZXh0IEZpdHRpbmcgU3RyYXRlZ3lcclxuICAgICAgICAgIDwvaDQ+XHJcbiAgICAgICAgICA8c2VsZWN0XHJcbiAgICAgICAgICAgIHZhbHVlPXt0ZXh0Rml0dGluZ1N0cmF0ZWd5fVxyXG4gICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFRleHRGaXR0aW5nU3RyYXRlZ3koZS50YXJnZXQudmFsdWUpfVxyXG4gICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICBwYWRkaW5nOiBcIjZweFwiLFxyXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuICAgICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNjY2NcIixcclxuICAgICAgICAgICAgICBmb250U2l6ZTogXCIxMnB4XCIsXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9e1RFWFRfRklUVElOR19TVFJBVEVHSUVTLlBSRUNJU0VfRklUfT5cclxuICAgICAgICAgICAgICDwn46vIFByZWNpc2UgRml0IChJbkRlc2lnbi1zdHlsZSlcclxuICAgICAgICAgICAgPC9vcHRpb24+XHJcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9e1RFWFRfRklUVElOR19TVFJBVEVHSUVTLkFVVE9fU0NBTEV9PlxyXG4gICAgICAgICAgICAgIPCfk48gQXV0byBTY2FsZSBGb250XHJcbiAgICAgICAgICAgIDwvb3B0aW9uPlxyXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtURVhUX0ZJVFRJTkdfU1RSQVRFR0lFUy5UUlVOQ0FURX0+XHJcbiAgICAgICAgICAgICAg4pyC77iPIFRydW5jYXRlIHdpdGggRWxsaXBzaXNcclxuICAgICAgICAgICAgPC9vcHRpb24+XHJcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9e1RFWFRfRklUVElOR19TVFJBVEVHSUVTLkNPTVBSRVNTX0xJTkVTfT5cclxuICAgICAgICAgICAgICDwn5OKIENvbXByZXNzIExpbmUgSGVpZ2h0XHJcbiAgICAgICAgICAgIDwvb3B0aW9uPlxyXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtURVhUX0ZJVFRJTkdfU1RSQVRFR0lFUy5BTExPV19PVkVSRkxPV30+XHJcbiAgICAgICAgICAgICAg8J+MiiBBbGxvdyBPdmVyZmxvd1xyXG4gICAgICAgICAgICA8L29wdGlvbj5cclxuICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250U2l6ZTogXCIxMHB4XCIsIGNvbG9yOiBcIiM2NjZcIiwgbWFyZ2luVG9wOiBcIjRweFwiIH19PlxyXG4gICAgICAgICAgICB7dGV4dEZpdHRpbmdTdHJhdGVneSA9PT0gVEVYVF9GSVRUSU5HX1NUUkFURUdJRVMuUFJFQ0lTRV9GSVQgJiZcclxuICAgICAgICAgICAgICBcIlNtYXJ0IGZvbnQgJiBsaW5lIGhlaWdodCBhZGp1c3RtZW50IHdpdGggdHJ1bmNhdGlvbiBmYWxsYmFja1wifVxyXG4gICAgICAgICAgICB7dGV4dEZpdHRpbmdTdHJhdGVneSA9PT0gVEVYVF9GSVRUSU5HX1NUUkFURUdJRVMuQVVUT19TQ0FMRSAmJlxyXG4gICAgICAgICAgICAgIFwiUmVkdWNlIGZvbnQgc2l6ZSBwcm9wb3J0aW9uYWxseSB0byBmaXQgY29udGFpbmVyXCJ9XHJcbiAgICAgICAgICAgIHt0ZXh0Rml0dGluZ1N0cmF0ZWd5ID09PSBURVhUX0ZJVFRJTkdfU1RSQVRFR0lFUy5UUlVOQ0FURSAmJlxyXG4gICAgICAgICAgICAgIFwiQ3V0IG9mZiB0ZXh0IHdpdGggZWxsaXBzaXMgd2hlbiBpdCBvdmVyZmxvd3NcIn1cclxuICAgICAgICAgICAge3RleHRGaXR0aW5nU3RyYXRlZ3kgPT09IFRFWFRfRklUVElOR19TVFJBVEVHSUVTLkNPTVBSRVNTX0xJTkVTICYmXHJcbiAgICAgICAgICAgICAgXCJSZWR1Y2UgbGluZSBoZWlnaHQgZmlyc3QsIHRoZW4gZm9udCBzaXplXCJ9XHJcbiAgICAgICAgICAgIHt0ZXh0Rml0dGluZ1N0cmF0ZWd5ID09PSBURVhUX0ZJVFRJTkdfU1RSQVRFR0lFUy5BTExPV19PVkVSRkxPVyAmJlxyXG4gICAgICAgICAgICAgIFwiTGV0IHRleHQgb3ZlcmZsb3cgbmF0dXJhbGx5IChvcmlnaW5hbCBiZWhhdmlvcilcIn1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICB7LyogQmFja2dyb3VuZCBDb2xvciBDb25maWd1cmF0aW9uICovfVxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmZmM2UwXCIsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiMTJweFwiLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNnB4XCIsXHJcbiAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogXCIxNnB4XCIsXHJcbiAgICAgICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2ZmOTgwMFwiLFxyXG4gICAgICAgICAgfX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICA8aDRcclxuICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luOiBcIjAgMCA4cHggMFwiLCBjb2xvcjogXCIjZjU3NzAwXCIsIGZvbnRTaXplOiBcIjE0cHhcIiB9fVxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICDwn46oIEJhY2tncm91bmQgQ29sb3JcclxuICAgICAgICAgIDwvaDQ+XHJcblxyXG4gICAgICAgICAgey8qIEJhY2tncm91bmQgTW9kZSBTZWxlY3RvciAqL31cclxuICAgICAgICAgIDxzZWxlY3RcclxuICAgICAgICAgICAgdmFsdWU9e2JhY2tncm91bmRDb25maWcubW9kZX1cclxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxyXG4gICAgICAgICAgICAgIHNldEJhY2tncm91bmRDb25maWcoeyAuLi5iYWNrZ3JvdW5kQ29uZmlnLCBtb2RlOiBlLnRhcmdldC52YWx1ZSB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgIHBhZGRpbmc6IFwiNnB4XCIsXHJcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxyXG4gICAgICAgICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2NjY1wiLFxyXG4gICAgICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcclxuICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206IFwiOHB4XCIsXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIHtiYWNrZ3JvdW5kTW9kZXMubWFwKChtb2RlKSA9PiAoXHJcbiAgICAgICAgICAgICAgPG9wdGlvbiBrZXk9e21vZGUudmFsdWV9IHZhbHVlPXttb2RlLnZhbHVlfT5cclxuICAgICAgICAgICAgICAgIHttb2RlLmxhYmVsfVxyXG4gICAgICAgICAgICAgIDwvb3B0aW9uPlxyXG4gICAgICAgICAgICApKX1cclxuICAgICAgICAgIDwvc2VsZWN0PlxyXG5cclxuICAgICAgICAgIHsvKiBDdXN0b20gQ29sb3IgUGlja2VyIC0gc2hvd24gd2hlbiBjdXN0b20gbW9kZSBzZWxlY3RlZCAqL31cclxuICAgICAgICAgIHtiYWNrZ3JvdW5kQ29uZmlnLm1vZGUgPT09IFwiY3VzdG9tXCIgJiYgKFxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogXCI4cHhcIiB9fT5cclxuICAgICAgICAgICAgICA8bGFiZWxcclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjExcHhcIixcclxuICAgICAgICAgICAgICAgICAgY29sb3I6IFwiIzY2NlwiLFxyXG4gICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXHJcbiAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogXCI0cHhcIixcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgQ3VzdG9tIENvbG9yOlxyXG4gICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICB0eXBlPVwiY29sb3JcIlxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e2JhY2tncm91bmRDb25maWcuY3VzdG9tQ29sb3J9XHJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XHJcbiAgICAgICAgICAgICAgICAgIHNldEJhY2tncm91bmRDb25maWcoe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmJhY2tncm91bmRDb25maWcsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ29sb3I6IGUudGFyZ2V0LnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMzBweFwiLFxyXG4gICAgICAgICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNjY2NcIixcclxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxyXG4gICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICl9XHJcblxyXG4gICAgICAgICAgey8qIEFkdmFuY2VkIE9wdGlvbnMgLSBzaG93biB3aGVuIGF1dG8gbW9kZSBzZWxlY3RlZCAqL31cclxuICAgICAgICAgIHtiYWNrZ3JvdW5kQ29uZmlnLm1vZGUgPT09IFwiYXV0b1wiICYmIChcclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250U2l6ZTogXCIxMXB4XCIsIG1hcmdpblRvcDogXCI4cHhcIiB9fT5cclxuICAgICAgICAgICAgICA8bGFiZWxcclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206IFwiNHB4XCIsXHJcbiAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxyXG4gICAgICAgICAgICAgICAgICBjaGVja2VkPXtiYWNrZ3JvdW5kQ29uZmlnLnByZWZlclBhcGVyQ29sb3J9XHJcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICBzZXRCYWNrZ3JvdW5kQ29uZmlnKHtcclxuICAgICAgICAgICAgICAgICAgICAgIC4uLmJhY2tncm91bmRDb25maWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJQYXBlckNvbG9yOiBlLnRhcmdldC5jaGVja2VkLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luUmlnaHQ6IFwiNnB4XCIgfX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICBQcmVmZXIgUGFwZXIgY29sb3JcclxuICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgIDxsYWJlbFxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogXCI0cHhcIixcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXHJcbiAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2JhY2tncm91bmRDb25maWcuYWxsb3dDb2xvckFuYWx5c2lzfVxyXG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0QmFja2dyb3VuZENvbmZpZyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAuLi5iYWNrZ3JvdW5kQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgYWxsb3dDb2xvckFuYWx5c2lzOiBlLnRhcmdldC5jaGVja2VkLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luUmlnaHQ6IFwiNnB4XCIgfX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICBBbGxvdyBjb2xvciBhbmFseXNpc1xyXG4gICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXHJcbiAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2JhY2tncm91bmRDb25maWcuZmFsbGJhY2tUb1doaXRlfVxyXG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0QmFja2dyb3VuZENvbmZpZyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAuLi5iYWNrZ3JvdW5kQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tUb1doaXRlOiBlLnRhcmdldC5jaGVja2VkLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luUmlnaHQ6IFwiNnB4XCIgfX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICBGYWxsYmFjayB0byB3aGl0ZVxyXG4gICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgKX1cclxuXHJcbiAgICAgICAgICB7LyogQ3VycmVudCBCYWNrZ3JvdW5kIERpc3BsYXkgKi99XHJcbiAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgbWFyZ2luVG9wOiBcIjhweFwiLFxyXG4gICAgICAgICAgICAgIHBhZGRpbmc6IFwiNnB4XCIsXHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcclxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiM3B4XCIsXHJcbiAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTFweFwiLFxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICA8c3Ryb25nPkN1cnJlbnQ6PC9zdHJvbmc+e1wiIFwifVxyXG4gICAgICAgICAgICB7ZG9jdW1lbnREYXRhXHJcbiAgICAgICAgICAgICAgPyBnZXREb2N1bWVudEJhY2tncm91bmRDb2xvcihkb2N1bWVudERhdGEpXHJcbiAgICAgICAgICAgICAgOiBcIkxvYWRpbmcuLi5cIn1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICB7LyogVmlldyBDb250cm9scyAqL31cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2YwZjhmZlwiLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBcIjEycHhcIixcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxyXG4gICAgICAgICAgICBtYXJnaW5Cb3R0b206IFwiMTZweFwiLFxyXG4gICAgICAgICAgfX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICA8aDQgc3R5bGU9e3sgbWFyZ2luOiBcIjAgMCA4cHggMFwiLCBmb250U2l6ZTogXCIxNHB4XCIsIGNvbG9yOiBcIiMzMzNcIiB9fT5cclxuICAgICAgICAgICAg8J+UpyBWaWV3IENvbnRyb2xzXHJcbiAgICAgICAgICA8L2g0PlxyXG5cclxuICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsIGdhcDogXCI4cHhcIiB9fT5cclxuICAgICAgICAgICAgPGxhYmVsXHJcbiAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcclxuICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxyXG4gICAgICAgICAgICAgICAgY2hlY2tlZD17c2hvd01hcmdpbnN9XHJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFNob3dNYXJnaW5zKGUudGFyZ2V0LmNoZWNrZWQpfVxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luUmlnaHQ6IFwiOHB4XCIgfX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgIFNob3cgUGFnZSBNYXJnaW5zIChkb3R0ZWQgbGluZXMpXHJcbiAgICAgICAgICAgIDwvbGFiZWw+XHJcblxyXG4gICAgICAgICAgICA8bGFiZWxcclxuICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxyXG4gICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXHJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXtzaG93RGVidWdJbmZvfVxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRTaG93RGVidWdJbmZvKGUudGFyZ2V0LmNoZWNrZWQpfVxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luUmlnaHQ6IFwiOHB4XCIgfX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgIFNob3cgRGVidWcgSW5mb3JtYXRpb25cclxuICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICB7LyogU3RhdHVzIEluZGljYXRvcnMgTGVnZW5kICovfVxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjlmOWY5XCIsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiOHB4XCIsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuICAgICAgICAgICAgbWFyZ2luQm90dG9tOiBcIjE2cHhcIixcclxuICAgICAgICAgICAgZm9udFNpemU6IFwiMTFweFwiLFxyXG4gICAgICAgICAgfX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRXZWlnaHQ6IFwiYm9sZFwiLCBtYXJnaW5Cb3R0b206IFwiNnB4XCIgfX0+XHJcbiAgICAgICAgICAgIPCfk4ogU3RhdHVzIEluZGljYXRvcnM6XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGZsZXhXcmFwOiBcIndyYXBcIiwgZ2FwOiBcIjhweFwiIH19PlxyXG4gICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBkaXNwbGF5OiBcImZsZXhcIiwgYWxpZ25JdGVtczogXCJjZW50ZXJcIiwgZ2FwOiBcIjJweFwiIH19PlxyXG4gICAgICAgICAgICAgIDxzcGFuXHJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzRjYWY1MFwiLFxyXG4gICAgICAgICAgICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjFweCAzcHhcIixcclxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjJweFwiLFxyXG4gICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICDwn46vXHJcbiAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgIFByZWNpc2UgRml0XHJcbiAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsIGdhcDogXCIycHhcIiB9fT5cclxuICAgICAgICAgICAgICA8c3BhblxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMyMTk2ZjNcIixcclxuICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcclxuICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCIxcHggM3B4XCIsXHJcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCIycHhcIixcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAg8J+Tj1xyXG4gICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICBGb250IFNjYWxlZFxyXG4gICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBnYXA6IFwiMnB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmY5ODAwXCIsXHJcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMXB4IDNweFwiLFxyXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiMnB4XCIsXHJcbiAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIOKcgu+4j1xyXG4gICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICBUcnVuY2F0ZWRcclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgZmxleFdyYXA6IFwid3JhcFwiLFxyXG4gICAgICAgICAgICAgIGdhcDogXCI4cHhcIixcclxuICAgICAgICAgICAgICBtYXJnaW5Ub3A6IFwiNHB4XCIsXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBnYXA6IFwiMnB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjQ0MzM2XCIsXHJcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMXB4IDJweFwiLFxyXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjlweFwiLFxyXG4gICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICBTXHJcbiAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgIFNldmVyZSBvdmVyZmxvd1xyXG4gICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBnYXA6IFwiMnB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmY5ODAwXCIsXHJcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMXB4IDJweFwiLFxyXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjlweFwiLFxyXG4gICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICBNXHJcbiAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgIE1vZGVyYXRlXHJcbiAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsIGdhcDogXCIycHhcIiB9fT5cclxuICAgICAgICAgICAgICA8c3BhblxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZmViM2JcIixcclxuICAgICAgICAgICAgICAgICAgY29sb3I6IFwiYmxhY2tcIixcclxuICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCIxcHggMnB4XCIsXHJcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCIxcHhcIixcclxuICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiOXB4XCIsXHJcbiAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIExcclxuICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgTGlnaHRcclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxoMz5Eb2N1bWVudCBJbmZvPC9oMz5cclxuICAgICAgICA8cD5WZXJzaW9uOiB7ZG9jdW1lbnREYXRhLmRvY3VtZW50Py52ZXJzaW9ufTwvcD5cclxuICAgICAgICA8cD5QYWdlczoge2RvY3VtZW50RGF0YS5kb2N1bWVudD8ucGFnZUNvdW50fTwvcD5cclxuICAgICAgICA8cD5cclxuICAgICAgICAgIFNpemU6e1wiIFwifVxyXG4gICAgICAgICAge01hdGgucm91bmQoXHJcbiAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mbz8uZGltZW5zaW9ucz8ucGl4ZWxEaW1lbnNpb25zPy53aWR0aCB8fFxyXG4gICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mbz8uZGltZW5zaW9ucz8ud2lkdGggfHxcclxuICAgICAgICAgICAgICAwXHJcbiAgICAgICAgICApfXtcIiBcIn1cclxuICAgICAgICAgIMOXe1wiIFwifVxyXG4gICAgICAgICAge01hdGgucm91bmQoXHJcbiAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mbz8uZGltZW5zaW9ucz8ucGl4ZWxEaW1lbnNpb25zPy5oZWlnaHQgfHxcclxuICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8/LmRpbWVuc2lvbnM/LmhlaWdodCB8fFxyXG4gICAgICAgICAgICAgIDBcclxuICAgICAgICAgICl9XHJcbiAgICAgICAgICBweFxyXG4gICAgICAgICAge2RvY3VtZW50RGF0YS5wYWdlSW5mbz8uZGltZW5zaW9ucz8ucGl4ZWxEaW1lbnNpb25zICYmIChcclxuICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgZm9udFNpemU6IFwiMTJweFwiLCBjb2xvcjogXCIjNjY2XCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9fT5cclxuICAgICAgICAgICAgICAoT3JpZ2luYWw6IHtNYXRoLnJvdW5kKGRvY3VtZW50RGF0YS5wYWdlSW5mby5kaW1lbnNpb25zLndpZHRoKX0gw5d7XCIgXCJ9XHJcbiAgICAgICAgICAgICAge01hdGgucm91bmQoZG9jdW1lbnREYXRhLnBhZ2VJbmZvLmRpbWVuc2lvbnMuaGVpZ2h0KX17XCIgXCJ9XHJcbiAgICAgICAgICAgICAge2RvY3VtZW50RGF0YS5wYWdlSW5mby5kaW1lbnNpb25zLnVuaXRzfSlcclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgKX1cclxuICAgICAgICA8L3A+XHJcblxyXG4gICAgICAgIHsvKiBVbml0IENvbnZlcnNpb24gSW5mbyAqL31cclxuICAgICAgICB7ZG9jdW1lbnREYXRhLnVuaXRDb252ZXJzaW9uICYmIChcclxuICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICBtYXJnaW5Ub3A6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgIHBhZGRpbmc6IFwiOHB4XCIsXHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlOGY0ZmRcIixcclxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXHJcbiAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICA8c3Ryb25nPvCfk5AgVW5pdCBDb252ZXJzaW9uOjwvc3Ryb25nPlxyXG4gICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgU3RhdHVzOntcIiBcIn1cclxuICAgICAgICAgICAge2RvY3VtZW50RGF0YS51bml0Q29udmVyc2lvbi5lbmFibGVkID8gXCLinIUgRW5hYmxlZFwiIDogXCLinYwgRGlzYWJsZWRcIn1cclxuICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgIERQSToge2RvY3VtZW50RGF0YS51bml0Q29udmVyc2lvbi5kcGl9XHJcbiAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICBPcmlnaW5hbDoge2RvY3VtZW50RGF0YS51bml0Q29udmVyc2lvbi5vcmlnaW5hbFVuaXRzfSDihpIgUGl4ZWxzXHJcbiAgICAgICAgICAgIHtkb2N1bWVudERhdGEudW5pdENvbnZlcnNpb24uY29udmVydGVkVG9QaXhlbHMgJiYgKFxyXG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGNvbG9yOiBcIiMyOGE3NDVcIiwgZm9udFdlaWdodDogXCJib2xkXCIgfX0+IOKchTwvc3Bhbj5cclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcblxyXG4gICAgICAgIHsvKiBQb3NpdGlvbmluZyBEZWJ1ZyBJbmZvICovfVxyXG4gICAgICAgIHtkb2N1bWVudERhdGEucGFnZUluZm8/Lm1hcmdpbnMgJiYgKFxyXG4gICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgIG1hcmdpblRvcDogXCIxMHB4XCIsXHJcbiAgICAgICAgICAgICAgcGFkZGluZzogXCI4cHhcIixcclxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZjNjZFwiLFxyXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuICAgICAgICAgICAgICBmb250U2l6ZTogXCIxMXB4XCIsXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIDxzdHJvbmc+8J+TjyBQb3NpdGlvbmluZyBEZWJ1Zzo8L3N0cm9uZz5cclxuICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgIFBhZ2U6e1wiIFwifVxyXG4gICAgICAgICAgICB7TWF0aC5yb3VuZChcclxuICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8uZGltZW5zaW9ucz8ucGl4ZWxEaW1lbnNpb25zPy53aWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLmRpbWVuc2lvbnM/LndpZHRoIHx8XHJcbiAgICAgICAgICAgICAgICAwXHJcbiAgICAgICAgICAgICl9e1wiIFwifVxyXG4gICAgICAgICAgICDDl3tcIiBcIn1cclxuICAgICAgICAgICAge01hdGgucm91bmQoXHJcbiAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLmRpbWVuc2lvbnM/LnBpeGVsRGltZW5zaW9ucz8uaGVpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8uZGltZW5zaW9ucz8uaGVpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgICAwXHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIHB4XHJcbiAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICBNYXJnaW5zIChweCk6IFQ6XHJcbiAgICAgICAgICAgIHtkb2N1bWVudERhdGEucGFnZUluZm8ubWFyZ2lucy5waXhlbE1hcmdpbnM/LnRvcCB8fFxyXG4gICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mby5tYXJnaW5zLnRvcCB8fFxyXG4gICAgICAgICAgICAgIDB9XHJcbiAgICAgICAgICAgIFI6XHJcbiAgICAgICAgICAgIHtkb2N1bWVudERhdGEucGFnZUluZm8ubWFyZ2lucy5waXhlbE1hcmdpbnM/LnJpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLm1hcmdpbnMucmlnaHQgfHxcclxuICAgICAgICAgICAgICAwfVxyXG4gICAgICAgICAgICBCOlxyXG4gICAgICAgICAgICB7ZG9jdW1lbnREYXRhLnBhZ2VJbmZvLm1hcmdpbnMucGl4ZWxNYXJnaW5zPy5ib3R0b20gfHxcclxuICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8ubWFyZ2lucy5ib3R0b20gfHxcclxuICAgICAgICAgICAgICAwfVxyXG4gICAgICAgICAgICBMOlxyXG4gICAgICAgICAgICB7ZG9jdW1lbnREYXRhLnBhZ2VJbmZvLm1hcmdpbnMucGl4ZWxNYXJnaW5zPy5sZWZ0IHx8XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLm1hcmdpbnMubGVmdCB8fFxyXG4gICAgICAgICAgICAgIDB9XHJcbiAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICBDb250ZW50IEFyZWE6e1wiIFwifVxyXG4gICAgICAgICAgICB7TWF0aC5yb3VuZChcclxuICAgICAgICAgICAgICAoZG9jdW1lbnREYXRhLnBhZ2VJbmZvLmRpbWVuc2lvbnM/LnBpeGVsRGltZW5zaW9ucz8ud2lkdGggfHxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mby5kaW1lbnNpb25zPy53aWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgMCkgLVxyXG4gICAgICAgICAgICAgICAgKGRvY3VtZW50RGF0YS5wYWdlSW5mby5tYXJnaW5zLnBpeGVsTWFyZ2lucz8ubGVmdCB8fFxyXG4gICAgICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8ubWFyZ2lucy5sZWZ0IHx8XHJcbiAgICAgICAgICAgICAgICAgIDApIC1cclxuICAgICAgICAgICAgICAgIChkb2N1bWVudERhdGEucGFnZUluZm8ubWFyZ2lucy5waXhlbE1hcmdpbnM/LnJpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mby5tYXJnaW5zLnJpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgICAgIDApXHJcbiAgICAgICAgICAgICl9e1wiIFwifVxyXG4gICAgICAgICAgICDDl3tcIiBcIn1cclxuICAgICAgICAgICAge01hdGgucm91bmQoXHJcbiAgICAgICAgICAgICAgKGRvY3VtZW50RGF0YS5wYWdlSW5mby5kaW1lbnNpb25zPy5waXhlbERpbWVuc2lvbnM/LmhlaWdodCB8fFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLmRpbWVuc2lvbnM/LmhlaWdodCB8fFxyXG4gICAgICAgICAgICAgICAgMCkgLVxyXG4gICAgICAgICAgICAgICAgKGRvY3VtZW50RGF0YS5wYWdlSW5mby5tYXJnaW5zLnBpeGVsTWFyZ2lucz8udG9wIHx8XHJcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mby5tYXJnaW5zLnRvcCB8fFxyXG4gICAgICAgICAgICAgICAgICAwKSAtXHJcbiAgICAgICAgICAgICAgICAoZG9jdW1lbnREYXRhLnBhZ2VJbmZvLm1hcmdpbnMucGl4ZWxNYXJnaW5zPy5ib3R0b20gfHxcclxuICAgICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLm1hcmdpbnMuYm90dG9tIHx8XHJcbiAgICAgICAgICAgICAgICAgIDApXHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIHB4XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApfVxyXG5cclxuICAgICAgICB7LyogUGFja2FnZSBJbmZvICovfVxyXG4gICAgICAgIHtkb2N1bWVudERhdGEucGFja2FnZUluZm8gJiYgKFxyXG4gICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgIG1hcmdpblRvcDogXCIxMHB4XCIsXHJcbiAgICAgICAgICAgICAgcGFkZGluZzogXCI4cHhcIixcclxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2U5ZWNlZlwiLFxyXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgPHN0cm9uZz5QYWNrYWdlIEluZm86PC9zdHJvbmc+XHJcbiAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICBMaW5rczoge2RvY3VtZW50RGF0YS5wYWNrYWdlSW5mby5saW5rc0NvdW50fXtcIiBcIn1cclxuICAgICAgICAgICAge2RvY3VtZW50RGF0YS5wYWNrYWdlSW5mby5oYXNMaW5rcyA/IFwi4pyFXCIgOiBcIuKdjFwifVxyXG4gICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgRm9udHM6IHtkb2N1bWVudERhdGEucGFja2FnZUluZm8uZm9udHNDb3VudH17XCIgXCJ9XHJcbiAgICAgICAgICAgIHtkb2N1bWVudERhdGEucGFja2FnZUluZm8uaGFzRm9udHMgPyBcIuKchVwiIDogXCLinYxcIn1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcblxyXG4gICAgICAgIDxoMyBzdHlsZT17eyBtYXJnaW5Ub3A6IFwiMjBweFwiIH19PlxyXG4gICAgICAgICAgRWxlbWVudHMgKHtkb2N1bWVudERhdGEuZWxlbWVudHM/Lmxlbmd0aCB8fCAwfSlcclxuICAgICAgICA8L2gzPlxyXG4gICAgICAgIHsoZG9jdW1lbnREYXRhLmVsZW1lbnRzIHx8IFtdKS5tYXAoKGVsZW1lbnQsIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIGtleT17ZWxlbWVudC5pZH1cclxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRFbGVtZW50KGVsZW1lbnQpfVxyXG4gICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgIHBhZGRpbmc6IFwiOHB4XCIsXHJcbiAgICAgICAgICAgICAgbWFyZ2luOiBcIjRweCAwXCIsXHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOlxyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50Py5pZCA9PT0gZWxlbWVudC5pZCA/IFwiIzAwN2JmZlwiIDogXCJ3aGl0ZVwiLFxyXG4gICAgICAgICAgICAgIGNvbG9yOiBzZWxlY3RlZEVsZW1lbnQ/LmlkID09PSBlbGVtZW50LmlkID8gXCJ3aGl0ZVwiIDogXCJibGFja1wiLFxyXG4gICAgICAgICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2RkZFwiLFxyXG4gICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXHJcbiAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICA8c3Ryb25nPntlbGVtZW50LnR5cGV9PC9zdHJvbmc+ICh7ZWxlbWVudC5pZH0pXHJcbiAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICB7ZWxlbWVudC5uYW1lICE9PSBcIiRJRC9cIlxyXG4gICAgICAgICAgICAgID8gZWxlbWVudC5uYW1lXHJcbiAgICAgICAgICAgICAgOiBgJHtlbGVtZW50LnR5cGV9XyR7ZWxlbWVudC5pZH1gfVxyXG4gICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgUG9zOiAoe01hdGgucm91bmQoXHJcbiAgICAgICAgICAgICAgKGVsZW1lbnQucGl4ZWxQb3NpdGlvbiB8fCBlbGVtZW50LnBvc2l0aW9uKS54XHJcbiAgICAgICAgICAgICl9LCB7TWF0aC5yb3VuZCgoZWxlbWVudC5waXhlbFBvc2l0aW9uIHx8IGVsZW1lbnQucG9zaXRpb24pLnkpfSlweFxyXG4gICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgU2l6ZTp7XCIgXCJ9XHJcbiAgICAgICAgICAgIHtNYXRoLnJvdW5kKFxyXG4gICAgICAgICAgICAgIChlbGVtZW50LnBpeGVsUG9zaXRpb24gfHwgZWxlbWVudC5wb3NpdGlvbikud2lkdGhcclxuICAgICAgICAgICAgKX0gw5d7XCIgXCJ9XHJcbiAgICAgICAgICAgIHtNYXRoLnJvdW5kKChlbGVtZW50LnBpeGVsUG9zaXRpb24gfHwgZWxlbWVudC5wb3NpdGlvbikuaGVpZ2h0KX1weFxyXG4gICAgICAgICAgICB7ZWxlbWVudC5pc0NvbnRlbnRGcmFtZSAmJiAoXHJcbiAgICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6IFwiI2ZmYzEwN1wiIH19PvCflrzvuI8gQ29udGVudCBGcmFtZTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIHtlbGVtZW50LnBsYWNlZENvbnRlbnQgJiYgKFxyXG4gICAgICAgICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGZvbnRTaXplOiBcIjEwcHhcIiwgY29sb3I6IFwiIzZjNzU3ZFwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgVHlwZToge2VsZW1lbnQucGxhY2VkQ29udGVudC5pbWFnZVR5cGVOYW1lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICBQUEk6IHtlbGVtZW50LnBsYWNlZENvbnRlbnQuYWN0dWFsUHBpfSDihpJ7XCIgXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICB7ZWxlbWVudC5wbGFjZWRDb250ZW50LmVmZmVjdGl2ZVBwaX1cclxuICAgICAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgU2NhbGU6e1wiIFwifVxyXG4gICAgICAgICAgICAgICAgICAgICAge01hdGgucm91bmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbGVtZW50LnBsYWNlZENvbnRlbnQudHJhbnNmb3JtPy5hIHx8IDEpICogMTAwXHJcbiAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgICAgJVxyXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgICAgICB7ZWxlbWVudC5wYXJlbnRTdG9yeSAmJiAoXHJcbiAgICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6IFwiIzE3YTJiOFwiIH19PlxyXG4gICAgICAgICAgICAgICAgICDwn5OdIFN0b3J5OiB7ZWxlbWVudC5wYXJlbnRTdG9yeX1cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICkpfVxyXG5cclxuICAgICAgICA8aDMgc3R5bGU9e3sgbWFyZ2luVG9wOiBcIjIwcHhcIiB9fT5TdG9yaWVzICYgRm9ybWF0dGluZzwvaDM+XHJcbiAgICAgICAge09iamVjdC5rZXlzKGRvY3VtZW50RGF0YS5zdG9yaWVzIHx8IHt9KS5tYXAoKHN0b3J5SWQpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHN0b3J5ID0gZG9jdW1lbnREYXRhLnN0b3JpZXNbc3RvcnlJZF07XHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAga2V5PXtzdG9yeUlkfVxyXG4gICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjhweFwiLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiBcIjRweCAwXCIsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmVkXCIsXHJcbiAgICAgICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNkZGRcIixcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcclxuICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgPHN0cm9uZz57c3RvcnlJZH08L3N0cm9uZz5cclxuICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICA8c3Ryb25nPlRleHQ6PC9zdHJvbmc+IFwie3N0b3J5LnRleHQ/LnN1YnN0cmluZygwLCA1MCkgfHwgXCJcIn0uLi5cIlxyXG4gICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgIDxzdHJvbmc+V29yZHM6PC9zdHJvbmc+IHtzdG9yeS53b3JkQ291bnR9IHx7XCIgXCJ9XHJcbiAgICAgICAgICAgICAgPHN0cm9uZz5DaGFyczo8L3N0cm9uZz4ge3N0b3J5LmNoYXJhY3RlckNvdW50fVxyXG4gICAgICAgICAgICAgIHsvKiBGb250IEluZm9ybWF0aW9uICovfVxyXG4gICAgICAgICAgICAgIHtzdG9yeS5zdHlsaW5nICYmIChcclxuICAgICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IFwiOHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCI0cHhcIixcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y4ZjlmYVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCIycHhcIixcclxuICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgPHN0cm9uZz5TdHlsaW5nOjwvc3Ryb25nPlxyXG4gICAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgRm9udDoge3N0b3J5LnN0eWxpbmcuZm9udEZhbWlseX0ge3N0b3J5LnN0eWxpbmcuZm9udFN0eWxlfVxyXG4gICAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgU2l6ZToge3N0b3J5LnN0eWxpbmcuZm9udFNpemV9cHhcclxuICAgICAgICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgICAgICAgIEFsaWduOiB7c3Rvcnkuc3R5bGluZy5hbGlnbm1lbnR9XHJcbiAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICBDb2xvcjp7XCIgXCJ9XHJcbiAgICAgICAgICAgICAgICAgIDxzcGFuXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29udmVydENvbG9yKHN0b3J5LnN0eWxpbmcuZmlsbENvbG9yKSxcclxuICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMnB4IDRweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjEwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCIycHhcIixcclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge3N0b3J5LnN0eWxpbmcuZmlsbENvbG9yfVxyXG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgIHsvKiBGb3JtYXR0ZWQgQ29udGVudCBQcmV2aWV3ICovfVxyXG4gICAgICAgICAgICAgIHtzdG9yeS5mb3JtYXR0ZWRDb250ZW50ICYmIHN0b3J5LmZvcm1hdHRlZENvbnRlbnQubGVuZ3RoID4gMSAmJiAoXHJcbiAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBcIjhweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiNHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZmYzY2RcIixcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiMnB4XCIsXHJcbiAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgIDxzdHJvbmc+UmljaCBGb3JtYXR0aW5nOjwvc3Ryb25nPntcIiBcIn1cclxuICAgICAgICAgICAgICAgICAge3N0b3J5LmZvcm1hdHRlZENvbnRlbnQubGVuZ3RofSBzZWdtZW50c1xyXG4gICAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgTGluZSBCcmVha3M6IHtzdG9yeS5saW5lQnJlYWtDb3VudH1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KX1cclxuICAgICAgPC9kaXY+XHJcblxyXG4gICAgICB7LyogRW5oYW5jZWQgQ2FudmFzICovfVxyXG4gICAgICA8ZGl2XHJcbiAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxyXG4gICAgICAgICAgZmxleDogMSxcclxuICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLCAvLyBrZWVwIHRoaXMgdG8gY2VudGVyIGl0XHJcbiAgICAgICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIiwgLy8gYWxpZ24gdG8gdG9wLCBub3QgY2VudGVyIHZlcnRpY2FsbHlcclxuICAgICAgICAgIHBhZGRpbmc6IFwiMjBweFwiLFxyXG4gICAgICAgICAgb3ZlcmZsb3c6IFwiYXV0b1wiLCAvLyBDaGFuZ2VkIHRvIGF1dG8gdG8gYWxsb3cgc2Nyb2xsaW5nIGlmIG5lZWRlZFxyXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlOWVjZWZcIiwgLy8gRklYRUQ6IEtlZXAgb3V0ZXIgY29udGFpbmVyIG5ldXRyYWwgZ3JheSBiYWNrZ3JvdW5kXHJcbiAgICAgICAgfX1cclxuICAgICAgPlxyXG4gICAgICAgIHsvKiBGSVhFRDogRG9jdW1lbnQgQ2FudmFzIENvbnRhaW5lciAtIG9ubHkgdGhpcyBnZXRzIHRoZSBkb2N1bWVudCBiYWNrZ3JvdW5kICovfVxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXHJcbiAgICAgICAgICAgIHdpZHRoOlxyXG4gICAgICAgICAgICAgIChkb2N1bWVudERhdGEucGFnZUluZm8/LmRpbWVuc2lvbnM/LnBpeGVsRGltZW5zaW9ucz8ud2lkdGggfHxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mbz8uZGltZW5zaW9ucz8ud2lkdGggfHxcclxuICAgICAgICAgICAgICAgIDYxMikgKyBcInB4XCIsXHJcbiAgICAgICAgICAgIGhlaWdodDpcclxuICAgICAgICAgICAgICAoZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5kaW1lbnNpb25zPy5waXhlbERpbWVuc2lvbnM/LmhlaWdodCB8fFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5kaW1lbnNpb25zPy5oZWlnaHQgfHxcclxuICAgICAgICAgICAgICAgIDc5MikgKyBcInB4XCIsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogKCgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBiZ0NvbG9yID0gZ2V0RG9jdW1lbnRCYWNrZ3JvdW5kQ29sb3IoZG9jdW1lbnREYXRhKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgIFwi8J+OqCBGaW5hbCBiYWNrZ3JvdW5kIGNvbG9yIGJlaW5nIGFwcGxpZWQgdG8gRE9DVU1FTlQgQ0FOVkFTIG9ubHk6XCIsXHJcbiAgICAgICAgICAgICAgICBiZ0NvbG9yXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICByZXR1cm4gYmdDb2xvcjtcclxuICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgbWFyZ2luOiBcIjAgYXV0b1wiLFxyXG4gICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNjY2NcIixcclxuICAgICAgICAgICAgYm94U2hhZG93OiBcIjAgNHB4IDhweCByZ2JhKDAsMCwwLDAuMSlcIixcclxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsIC8vIENsaXAgY29udGVudCB0byBwYWdlIGJvdW5kYXJpZXNcclxuICAgICAgICAgICAgLy8gRklYRUQ6IEVuc3VyZSB0aGlzIGNvbnRhaW5lciBpcyBjbGVhcmx5IGRpc3RpbmN0IGZyb20gdGhlIG91dGVyIGJhY2tncm91bmRcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjJweFwiLFxyXG4gICAgICAgICAgfX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICB7KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gREVCVUc6IExvZyBwYWdlIGRpbWVuc2lvbnMgYW5kIG1hcmdpbnNcclxuICAgICAgICAgICAgY29uc3QgcGFnZVdpZHRoID1cclxuICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8/LmRpbWVuc2lvbnM/LnBpeGVsRGltZW5zaW9ucz8ud2lkdGggfHxcclxuICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8/LmRpbWVuc2lvbnM/LndpZHRoIHx8XHJcbiAgICAgICAgICAgICAgNjEyO1xyXG4gICAgICAgICAgICBjb25zdCBwYWdlSGVpZ2h0ID1cclxuICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8/LmRpbWVuc2lvbnM/LnBpeGVsRGltZW5zaW9ucz8uaGVpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5kaW1lbnNpb25zPy5oZWlnaHQgfHxcclxuICAgICAgICAgICAgICA3OTI7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPVxyXG4gICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mbz8ubWFyZ2lucz8ucGl4ZWxNYXJnaW5zPy5sZWZ0IHx8XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5tYXJnaW5zPy5sZWZ0IHx8XHJcbiAgICAgICAgICAgICAgMDtcclxuICAgICAgICAgICAgY29uc3QgbWFyZ2luVG9wID1cclxuICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8/Lm1hcmdpbnM/LnBpeGVsTWFyZ2lucz8udG9wIHx8XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5tYXJnaW5zPy50b3AgfHxcclxuICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICBjb25zdCBtYXJnaW5SaWdodCA9XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5tYXJnaW5zPy5waXhlbE1hcmdpbnM/LnJpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5tYXJnaW5zPy5yaWdodCB8fFxyXG4gICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpbkJvdHRvbSA9XHJcbiAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvPy5tYXJnaW5zPy5waXhlbE1hcmdpbnM/LmJvdHRvbSB8fFxyXG4gICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mbz8ubWFyZ2lucz8uYm90dG9tIHx8XHJcbiAgICAgICAgICAgICAgMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaG93RGVidWdJbmZvKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OQIFBBR0UgRElNRU5TSU9OUyBERUJVRzpcIik7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIPCfk48gUGFnZSBzaXplOiAke3BhZ2VXaWR0aH0gw5cgJHtwYWdlSGVpZ2h0fXB4YCk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgICBgICAg8J+TjyBNYXJnaW5zOiB0b3A9JHttYXJnaW5Ub3B9LCByaWdodD0ke21hcmdpblJpZ2h0fSwgYm90dG9tPSR7bWFyZ2luQm90dG9tfSwgbGVmdD0ke21hcmdpbkxlZnR9YFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgICBgICAg8J+TjyBDb250ZW50IGFyZWE6ICR7XHJcbiAgICAgICAgICAgICAgICAgIHBhZ2VXaWR0aCAtIG1hcmdpbkxlZnQgLSBtYXJnaW5SaWdodFxyXG4gICAgICAgICAgICAgICAgfSDDlyAke3BhZ2VIZWlnaHQgLSBtYXJnaW5Ub3AgLSBtYXJnaW5Cb3R0b219cHhgXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgIGAgICDwn5OPIERvdHRlZCBib3JkZXIgcG9zaXRpb246IHRvcD0ke21hcmdpblRvcH0sIGxlZnQ9JHttYXJnaW5MZWZ0fSwgcmlnaHQ9JHttYXJnaW5SaWdodH0sIGJvdHRvbT0ke21hcmdpbkJvdHRvbX1gXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMganVzdCBmb3IgZGVidWdnaW5nLCByZXR1cm4gbm90aGluZ1xyXG4gICAgICAgICAgfSkoKX1cclxuICAgICAgICAgIHsvKiBNYXJnaW5zIFZpc3VhbGl6YXRpb24gLSBvbmx5IHNob3cgd2hlbiBlbmFibGVkICovfVxyXG4gICAgICAgICAge3Nob3dNYXJnaW5zICYmXHJcbiAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mbz8ubWFyZ2lucyAmJlxyXG4gICAgICAgICAgICAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHZpc3VhbE1hcmdpblRvcCA9XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8ubWFyZ2lucy5waXhlbE1hcmdpbnM/LnRvcCB8fFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLm1hcmdpbnMudG9wIHx8XHJcbiAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHZpc3VhbE1hcmdpbkxlZnQgPVxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLm1hcmdpbnMucGl4ZWxNYXJnaW5zPy5sZWZ0IHx8XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8ubWFyZ2lucy5sZWZ0IHx8XHJcbiAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHZpc3VhbE1hcmdpblJpZ2h0ID1cclxuICAgICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mby5tYXJnaW5zLnBpeGVsTWFyZ2lucz8ucmlnaHQgfHxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5wYWdlSW5mby5tYXJnaW5zLnJpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHZpc3VhbE1hcmdpbkJvdHRvbSA9XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudERhdGEucGFnZUluZm8ubWFyZ2lucy5waXhlbE1hcmdpbnM/LmJvdHRvbSB8fFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnBhZ2VJbmZvLm1hcmdpbnMuYm90dG9tIHx8XHJcbiAgICAgICAgICAgICAgICAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoc2hvd0RlYnVnSW5mbykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OQIE1BUkdJTiBWSVNVQUxJWkFUSU9OOlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgIHRvcDogdmlzdWFsTWFyZ2luVG9wLFxyXG4gICAgICAgICAgICAgICAgICBsZWZ0OiB2aXN1YWxNYXJnaW5MZWZ0LFxyXG4gICAgICAgICAgICAgICAgICByaWdodDogdmlzdWFsTWFyZ2luUmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgIGJvdHRvbTogdmlzdWFsTWFyZ2luQm90dG9tLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB2aXN1YWxNYXJnaW5Ub3AgKyBcInB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdmlzdWFsTWFyZ2luTGVmdCArIFwicHhcIixcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogdmlzdWFsTWFyZ2luUmlnaHQgKyBcInB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB2aXN1YWxNYXJnaW5Cb3R0b20gKyBcInB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIjNweCBkYXNoZWQgcmdiYSgyNTUsIDAsIDAsIDAuNClcIixcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDEwMCxcclxuICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSkoKX1cclxuICAgICAgICAgIHsoZG9jdW1lbnREYXRhLmVsZW1lbnRzIHx8IFtdKS5tYXAoKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEVORk9SQ0VEOiBPbmx5IHVzZSBwaXhlbFBvc2l0aW9uIChpbiBwaXhlbHMpIGZvciByZW5kZXJpbmdcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBpeGVsUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgICAgICBg4pqg77iPIFNraXBwaW5nIGVsZW1lbnQgJHtlbGVtZW50LmlkfSBiZWNhdXNlIHBpeGVsUG9zaXRpb24gaXMgbWlzc2luZyFgXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50UG9zaXRpb24gPSBlbGVtZW50LnBpeGVsUG9zaXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQ29udGVudEZyYW1lID1cclxuICAgICAgICAgICAgICBlbGVtZW50LmlzQ29udGVudEZyYW1lIHx8IGVsZW1lbnQuaGFzUGxhY2VkQ29udGVudDtcclxuICAgICAgICAgICAgY29uc3QgaGFzUGxhY2VkQ29udGVudCA9IGVsZW1lbnQucGxhY2VkQ29udGVudDtcclxuXHJcbiAgICAgICAgICAgIC8vIEZJWEVEOiBSZW1vdmUgbWFyZ2luIGFwcGxpY2F0aW9uIC0gbWFyZ2lucyBhcmUgZm9yIHZpc3VhbCBndWlkZWxpbmVzIG9ubHlcclxuICAgICAgICAgICAgLy8gRWxlbWVudCBwb3NpdGlvbnMgc2hvdWxkIGJlIGV4YWN0bHkgYXMgY2FsY3VsYXRlZCBmcm9tIElETUwgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgLy8gTWFyZ2lucyBpbiB0aGUgVUkgYXJlIGp1c3QgZG90dGVkIGxpbmVzIHNob3dpbmcgdGhlIGNvbnRlbnQgYXJlYVxyXG5cclxuICAgICAgICAgICAgaWYgKHNob3dEZWJ1Z0luZm8pIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgIFwi8J+nsSBFbGVtZW50IHBvc2l0aW9uaW5nOlwiLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pZCxcclxuICAgICAgICAgICAgICAgIFwiVHlwZTpcIixcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQudHlwZSxcclxuICAgICAgICAgICAgICAgIFwiUG9zaXRpb24gc291cmNlOlwiLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5waXhlbFBvc2l0aW9uID8gXCJwaXhlbFBvc2l0aW9uXCIgOiBcInBvc2l0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICBcIkZpbmFsIGNvb3JkczpcIixcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgeDogZWxlbWVudFBvc2l0aW9uLngsXHJcbiAgICAgICAgICAgICAgICAgIHk6IGVsZW1lbnRQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICAgICAgICB3aWR0aDogZWxlbWVudFBvc2l0aW9uLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnRQb3NpdGlvbi5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJDb252ZXJzaW9uIGluZm86XCIsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBvc2l0aW9uPy5fY29udmVyc2lvbkluZm9cclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIGtleT17ZWxlbWVudC5pZH1cclxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkRWxlbWVudChlbGVtZW50KX1cclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgIC8vIEZJWEVEOiBVc2UgZWxlbWVudCBwb3NpdGlvbiBkaXJlY3RseSB3aXRob3V0IGFueSBtYXJnaW4gb2Zmc2V0c1xyXG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZyBtYXRjaGluZyBJbkRlc2lnbiBsYXlvdXRcclxuICAgICAgICAgICAgICAgICAgbGVmdDogZWxlbWVudFBvc2l0aW9uLnggKyBcInB4XCIsXHJcbiAgICAgICAgICAgICAgICAgIHRvcDogZWxlbWVudFBvc2l0aW9uLnkgKyBcInB4XCIsXHJcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50UG9zaXRpb24ud2lkdGggKyBcInB4XCIsXHJcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogZWxlbWVudFBvc2l0aW9uLmhlaWdodCArIFwicHhcIixcclxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlbGVtZW50LmZpbGxcclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRDb2xvcihlbGVtZW50LmZpbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjpcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQ/LmlkID09PSBlbGVtZW50LmlkXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiMnB4IHNvbGlkICMwMDdiZmZcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBpc0NvbnRlbnRGcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgPyBcIjJweCBzb2xpZCAjMDBhYWZmXCJcclxuICAgICAgICAgICAgICAgICAgICAgIDogZWxlbWVudC50eXBlID09PSBcIlRleHRGcmFtZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiMXB4IHNvbGlkICNmZjZiNmJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBcIjFweCBkYXNoZWQgcmdiYSgwLDAsMCwwLjMpXCIsXHJcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBcInZpc2libGVcIiwgLy8gQ1JJVElDQUw6IEFsbG93IHRleHQgY29udGFpbmVycyB0byBvdmVyZmxvdyBmcmFtZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBlbGVtZW50UG9zaXRpb24ucm90YXRpb25cclxuICAgICAgICAgICAgICAgICAgICA/IGByb3RhdGUoJHtlbGVtZW50UG9zaXRpb24ucm90YXRpb259ZGVnKWBcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcImNlbnRlciBjZW50ZXJcIixcclxuICAgICAgICAgICAgICAgICAgekluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcclxuICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBpc0NvbnRlbnRGcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgID8gXCIwIDAgMCAxcHggcmdiYSgwLCAxNzAsIDI1NSwgMC4zKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICB0aXRsZT17YCR7ZWxlbWVudC50eXBlfSAoJHtlbGVtZW50LmlkfSkke1xyXG4gICAgICAgICAgICAgICAgICBpc0NvbnRlbnRGcmFtZSA/IFwiIC0gQ29udGVudCBGcmFtZVwiIDogXCJcIlxyXG4gICAgICAgICAgICAgICAgfSRbUElYRUwgT05MWV1gfVxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHsvKiBEZWJ1ZyBwb3NpdGlvbiBsYWJlbCAqL31cclxuICAgICAgICAgICAgICAgIHtzaG93RGVidWdJbmZvICYmIChcclxuICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIi0yMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIjBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwgMjU1LCAwLCAwLjgpXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjJweCA0cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCIycHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgekluZGV4OiAxMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge2VsZW1lbnQuaWR9OiAoe01hdGgucm91bmQoZWxlbWVudFBvc2l0aW9uLngpfSx7XCIgXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAge01hdGgucm91bmQoZWxlbWVudFBvc2l0aW9uLnkpfSlcclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICApfVxyXG5cclxuICAgICAgICAgICAgICAgIHsvKiBFbmhhbmNlZCBJbWFnZSBSZW5kZXJpbmcgZm9yIGJvdGggZW1iZWRkZWQgYW5kIGV4dGVybmFsIGltYWdlcyAqL31cclxuICAgICAgICAgICAgICAgIHtlbGVtZW50LmxpbmtlZEltYWdlICYmXHJcbiAgICAgICAgICAgICAgICAgIChlbGVtZW50LmxpbmtlZEltYWdlLnVybCA/IChcclxuICAgICAgICAgICAgICAgICAgICA8aW1nXHJcbiAgICAgICAgICAgICAgICAgICAgICBzcmM9e2VsZW1lbnQubGlua2VkSW1hZ2UudXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgYWx0PVwiRnJhbWUgY29udGVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIjBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0Rml0OiBcImNvdmVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCJjZW50ZXIgY2VudGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgb25FcnJvcj17KGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgaW1hZ2U6XCIsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICkgOiBlbGVtZW50LmxpbmtlZEltYWdlLmlzRW1iZWRkZWQgPyAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIjBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjBmMGYwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogXCIycHggc29saWQgIzAwN2JmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiIzAwN2JmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICDwn5a877iPIEVtYmVkZGVkIEltYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgIE5vIGltYWdlIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgKSA6IG51bGwpfVxyXG5cclxuICAgICAgICAgICAgICAgIHsvKiBQSVhFTC1QRVJGRUNUIFRleHQgUmVuZGVyaW5nIHdpdGggQWR2YW5jZWQgRml0dGluZyBTdHJhdGVnaWVzICovfVxyXG4gICAgICAgICAgICAgICAge2VsZW1lbnQudHlwZSA9PT0gXCJUZXh0RnJhbWVcIiAmJlxyXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudFN0b3J5ICYmXHJcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5zdG9yaWVzW2VsZW1lbnQucGFyZW50U3RvcnldICYmXHJcbiAgICAgICAgICAgICAgICAgICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcnkgPSBkb2N1bWVudERhdGEuc3Rvcmllc1tlbGVtZW50LnBhcmVudFN0b3J5XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRU5IQU5DRUQ6IENhbGN1bGF0ZSBwcmVjaXNlIHRleHQgZnJhbWUgbWV0cmljcyB1c2luZyBJbkRlc2lnbi1jb21wYXRpYmxlIHN5c3RlbVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lTWV0cmljcyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICBJbkRlc2lnblRleHRNZXRyaWNzLmNhbGN1bGF0ZVRleHRGcmFtZUluc2V0cyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC50ZXh0RnJhbWVQcmVmZXJlbmNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHN0b3J5IGZvcm1hdHRpbmcgd2l0aCBJbkRlc2lnbi1hY2N1cmF0ZSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcnlGb3JtYXR0aW5nID1cclxuICAgICAgICAgICAgICAgICAgICAgIGdldEluRGVzaWduQWNjdXJhdGVGb3JtYXR0aW5nKHN0b3J5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdGV4dCB0byByZW1vdmUgZXhjZXNzaXZlIGxpbmUgYnJlYWtzIHRoYXQgY291bGQgY2F1c2Ugb3ZlcmZsb3dcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGVhblRleHQgPSAoc3RvcnkudGV4dCB8fCBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcblxccypcXG4vZywgXCJcXG5cIilcclxuICAgICAgICAgICAgICAgICAgICAgIC50cmltKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVOSEFOQ0VEOiBVc2UgSW5EZXNpZ24tYWNjdXJhdGUgdGV4dCBtZWFzdXJlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRNZWFzdXJlbWVudCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICBJbkRlc2lnblRleHRNZXRyaWNzLm1lYXN1cmVUZXh0UHJlY2lzZWx5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhblRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3J5Rm9ybWF0dGluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVNZXRyaWNzXHJcbiAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJTVBST1ZFRDogR2VuZXJhdGUgQ1NTIHN0eWxlcyB3aXRoIGZ1bGwgY29udGFpbmVyIGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmluYWxTdHlsZXMgPSBnZXRTdG9yeVN0eWxlcyhcclxuICAgICAgICAgICAgICAgICAgICAgIHN0b3J5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wb3NpdGlvbi5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnBvc2l0aW9uLndpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgd2FzQWRqdXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYWRqdXN0bWVudERldGFpbHMgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJTVBST1ZFRDogVXNlIGZ1bGwgY29udGFpbmVyIGRpbWVuc2lvbnMgZm9yIG92ZXJmbG93IGRldGVjdGlvbiAoaW4gcGl4ZWxzKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gZWxlbWVudFBvc2l0aW9uLndpZHRoOyAvLyBVc2UgZnVsbCB3aWR0aCBpbiBwaXhlbHNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSBlbGVtZW50UG9zaXRpb24uaGVpZ2h0OyAvLyBVc2UgZnVsbCBoZWlnaHQgaW4gcGl4ZWxzIC8vIFVzZSBmdWxsIGhlaWdodFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBURU1QT1JBUklMWSBESVNBQkxFRDogQXBwbHkgb3ZlcmZsb3cgcHJldmVudGlvbiBpZiBuZWVkZWQgKG1heSBiZSBjYXVzaW5nIHRleHQgY2hvcHBpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZhbHNlICYmIHRleHRNZWFzdXJlbWVudC53aWxsT3ZlcmZsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBg8J+TjyBUZXh0IG92ZXJmbG93IGRldGVjdGVkIGluIHN0b3J5ICR7ZWxlbWVudC5wYXJlbnRTdG9yeX06YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRIZWlnaHQ6IHRleHRNZWFzdXJlbWVudC50ZXh0SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodDogdGV4dE1lYXN1cmVtZW50LmF2YWlsYWJsZUhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0Ftb3VudDogdGV4dE1lYXN1cmVtZW50Lm92ZXJmbG93QW1vdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDb3VudDogdGV4dE1lYXN1cmVtZW50LmxpbmVDb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgSW5EZXNpZ25UZXh0TWV0cmljcy5jYWxjdWxhdGVPcHRpbWFsRm9udFNpemUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE1lYXN1cmVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3J5Rm9ybWF0dGluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLjI1IC8vIE1heGltdW0gMjUlIGZvbnQgc2l6ZSByZWR1Y3Rpb24gZm9yIGJldHRlciBvdmVyZmxvdyBwcmV2ZW50aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdG1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmluYWxTdHlsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYWRqdXN0bWVudC5hZGp1c3RlZFN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FzQWRqdXN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RtZW50RGV0YWlscyA9IGFkanVzdG1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGFkanVzdGVkIGZvbnQgc2l6ZSBmb3IgdGV4dCBzcGFuc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkRm9udFNpemUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgd2FzQWRqdXN0ZWQgJiYgYWRqdXN0bWVudERldGFpbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGp1c3RtZW50RGV0YWlscy5uZXdGb250U2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVRvb2x0aXAgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlSW5mbyA9IGBTdG9yeTogJHtlbGVtZW50LnBhcmVudFN0b3J5fVxcbkZyYW1lOiAke2VsZW1lbnQucG9zaXRpb24ud2lkdGh9w5cke2VsZW1lbnQucG9zaXRpb24uaGVpZ2h0fXB4XFxuQ29udGVudDogJHtmcmFtZU1ldHJpY3MuY29udGVudEFyZWEud2lkdGh9w5cke2ZyYW1lTWV0cmljcy5jb250ZW50QXJlYS5oZWlnaHR9cHhgO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGlmICghd2FzQWRqdXN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VJbmZvfVxcblRleHQgZml0cyBwZXJmZWN0bHkhIOKchWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VJbmZvfVxcbkFkanVzdGVkOiAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RtZW50RGV0YWlscy5hZGp1c3RtZW50VHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxcbkZvbnQ6ICR7YWRqdXN0bWVudERldGFpbHMub3JpZ2luYWxGb250U2l6ZX1weCDihpIgJHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0bWVudERldGFpbHMubmV3Rm9udFNpemVcclxuICAgICAgICAgICAgICAgICAgICAgIH1weFxcblNjYWxlOiAkeyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0bWVudERldGFpbHMuc2NhbGVGYWN0b3IgKiAxMDBcclxuICAgICAgICAgICAgICAgICAgICAgICkudG9GaXhlZCgxKX0lYDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhZQlJJRCBBUFBST0FDSDogVXNlIGZ1bGwgZnJhbWUgc2l6ZSBidXQgYXBwbHkgaW5zZXRzIGFzIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIwcHhcIiwgLy8gVXNlIGZ1bGwgZnJhbWUgcG9zaXRpb25pbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIjBweFwiLCAvLyBVc2UgZnVsbCBmcmFtZSBwb3NpdGlvbmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBgJHtlbGVtZW50UG9zaXRpb24ud2lkdGh9cHhgLCAvLyBVc2UgZnVsbCBmcmFtZSB3aWR0aCBpbiBwaXhlbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2VsZW1lbnRQb3NpdGlvbi5oZWlnaHR9cHhgLCAvLyBVc2UgZnVsbCBmcmFtZSBoZWlnaHQgaW4gcGl4ZWxzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhZQlJJRDogQXBwbHkgaW5zZXRzIGFzIHBhZGRpbmcgdG8gY3JlYXRlIHZpc3VhbCBzcGFjaW5nIHdpdGhvdXQgcmVkdWNpbmcgdGV4dCBhcmVhIHRvbyBtdWNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogYCR7ZnJhbWVNZXRyaWNzLmluc2V0cy50b3B9cHggJHtmcmFtZU1ldHJpY3MuaW5zZXRzLnJpZ2h0fXB4ICR7ZnJhbWVNZXRyaWNzLmluc2V0cy5ib3R0b219cHggJHtmcmFtZU1ldHJpY3MuaW5zZXRzLmxlZnR9cHhgLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZXh0IHN0eWxpbmcgZnJvbSBzdG9yeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBgJHtmaW5hbFN0eWxlcy5mb250U2l6ZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGZpbmFsU3R5bGVzLmZvbnRGYW1pbHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogZmluYWxTdHlsZXMuZm9udFdlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U3R5bGU6IGZpbmFsU3R5bGVzLmZvbnRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZmluYWxTdHlsZXMuY29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBmaW5hbFN0eWxlcy50ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogZmluYWxTdHlsZXMubGluZUhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiBmaW5hbFN0eWxlcy5sZXR0ZXJTcGFjaW5nLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbGF5b3V0IC0gYWxsb3cgb3ZlcmZsb3cgdG8gcHJldmVudCBjaG9wcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS13cmFwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZEJyZWFrOiBcImJyZWFrLXdvcmRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1dyYXA6IFwiYnJlYWstd29yZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBcInZpc2libGVcIiwgLy8gQ1JJVElDQUw6IEFsbG93IHRleHQgdG8gb3ZlcmZsb3cgdG8gcHJldmVudCBjaG9wcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtjcmVhdGVUb29sdGlwKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZW5kZXJGb3JtYXR0ZWRUZXh0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3J5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24uaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdGVkRm9udFNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBFbmhhbmNlZCBTdGF0dXMgSW5kaWNhdG9ycyAqL31cclxuICAgICAgICAgICAgICAgICAgICAgICAge3dhc0FkanVzdGVkICYmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiLTJweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIi0ycHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhZGp1c3RtZW50RGV0YWlscz8uc3RpbGxPdmVyZmxvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiI2ZmNTcyMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIiM0Y2FmNTBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiOHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMXB4IDNweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiMnB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogMTAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHthZGp1c3RtZW50RGV0YWlscz8uc3RpbGxPdmVyZmxvd3MgPyBcIuKaoO+4j1wiIDogXCLwn46vXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7LyogUGVyZmVjdCBmaXQgaW5kaWNhdG9yICovfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IXdhc0FkanVzdGVkICYmICF0ZXh0TWVhc3VyZW1lbnQud2lsbE92ZXJmbG93ICYmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiLTJweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogXCItMnB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMmU3ZDMyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjhweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjFweCAzcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjJweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDEwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICDinIVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgIH0pKCl9XHJcblxyXG4gICAgICAgICAgICAgICAgey8qIENvbnRlbnQgZnJhbWUgcGxhY2Vob2xkZXIgd2hlbiBubyBjb250ZW50ICovfVxyXG4gICAgICAgICAgICAgICAgey8qIENvbnRlbnQgZnJhbWUgcGxhY2Vob2xkZXIgd2hlbiBubyBjb250ZW50ICovfVxyXG4gICAgICAgICAgICAgICAge2lzQ29udGVudEZyYW1lICYmXHJcbiAgICAgICAgICAgICAgICAgICFoYXNQbGFjZWRDb250ZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICFlbGVtZW50LmxpbmtlZEltYWdlPy5pc0VtYmVkZGVkICYmIChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiIzY2NlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgwLCAxNzAsIDI1NSwgMC4xKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICDwn5a877iPIENvbnRlbnQgRnJhbWVcclxuICAgICAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAge01hdGgucm91bmQoZWxlbWVudFBvc2l0aW9uLndpZHRoKX3Dl1xyXG4gICAgICAgICAgICAgICAgICAgICAge01hdGgucm91bmQoZWxlbWVudFBvc2l0aW9uLmhlaWdodCl9cHhcclxuICAgICAgICAgICAgICAgICAgICAgIHtlbGVtZW50Lm5hbWUgJiYgZWxlbWVudC5uYW1lICE9PSBcIiRJRC9cIiAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IGZvbnRTaXplOiBcIjEwcHhcIiwgZm9udFN0eWxlOiBcIml0YWxpY1wiIH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2VsZW1lbnQubmFtZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgKX1cclxuXHJcbiAgICAgICAgICAgICAgICB7LyogT3RoZXIgZWxlbWVudHMgKi99XHJcbiAgICAgICAgICAgICAgICB7IWhhc1BsYWNlZENvbnRlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgZWxlbWVudC50eXBlICE9PSBcIlRleHRGcmFtZVwiICYmXHJcbiAgICAgICAgICAgICAgICAgICFpc0NvbnRlbnRGcmFtZSAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCI0cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjOTk5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7ZWxlbWVudC50eXBlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7TWF0aC5yb3VuZChlbGVtZW50UG9zaXRpb24ud2lkdGgpfcOXXHJcbiAgICAgICAgICAgICAgICAgICAgICB7TWF0aC5yb3VuZChlbGVtZW50UG9zaXRpb24uaGVpZ2h0KX1weFxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSl9XHJcbiAgICAgICAgICB7LyogRW5oYW5jZWQgU2VsZWN0aW9uIEluZm8gUGFuZWwgKi99XHJcbiAgICAgICAgICB7c2VsZWN0ZWRFbGVtZW50ICYmIChcclxuICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgdG9wOiBcIjEwcHhcIixcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiBcIjEwcHhcIixcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDAsIDEyMywgMjU1LCAwLjk1KVwiLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMTJweFwiLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjZweFwiLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxyXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IFwiMzAwcHhcIixcclxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IFwiMS40XCIsXHJcbiAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxzdHJvbmc+e3NlbGVjdGVkRWxlbWVudC50eXBlfTwvc3Ryb25nPiAoe3NlbGVjdGVkRWxlbWVudC5pZH0pXHJcbiAgICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgICAgPHN0cm9uZz5Qb3NpdGlvbjo8L3N0cm9uZz4gKFxyXG4gICAgICAgICAgICAgIHtNYXRoLnJvdW5kKFxyXG4gICAgICAgICAgICAgICAgKHNlbGVjdGVkRWxlbWVudC5waXhlbFBvc2l0aW9uIHx8IHNlbGVjdGVkRWxlbWVudC5wb3NpdGlvbikueFxyXG4gICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgLHtcIiBcIn1cclxuICAgICAgICAgICAgICB7TWF0aC5yb3VuZChcclxuICAgICAgICAgICAgICAgIChzZWxlY3RlZEVsZW1lbnQucGl4ZWxQb3NpdGlvbiB8fCBzZWxlY3RlZEVsZW1lbnQucG9zaXRpb24pLnlcclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgIClweFxyXG4gICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgIDxzdHJvbmc+U2l6ZTo8L3N0cm9uZz57XCIgXCJ9XHJcbiAgICAgICAgICAgICAge01hdGgucm91bmQoXHJcbiAgICAgICAgICAgICAgICAoc2VsZWN0ZWRFbGVtZW50LnBpeGVsUG9zaXRpb24gfHwgc2VsZWN0ZWRFbGVtZW50LnBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAud2lkdGhcclxuICAgICAgICAgICAgICApfXtcIiBcIn1cclxuICAgICAgICAgICAgICDDl3tcIiBcIn1cclxuICAgICAgICAgICAgICB7TWF0aC5yb3VuZChcclxuICAgICAgICAgICAgICAgIChzZWxlY3RlZEVsZW1lbnQucGl4ZWxQb3NpdGlvbiB8fCBzZWxlY3RlZEVsZW1lbnQucG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgIC5oZWlnaHRcclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgIHB4XHJcbiAgICAgICAgICAgICAge3NlbGVjdGVkRWxlbWVudC5pc0NvbnRlbnRGcmFtZSAmJiAoXHJcbiAgICAgICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgPHN0cm9uZz7wn5a877iPIENvbnRlbnQgRnJhbWU8L3N0cm9uZz5cclxuICAgICAgICAgICAgICAgICAge3NlbGVjdGVkRWxlbWVudC5wbGFjZWRDb250ZW50ICYmIChcclxuICAgICAgICAgICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPkNvbnRlbnQ6PC9zdHJvbmc+e1wiIFwifVxyXG4gICAgICAgICAgICAgICAgICAgICAge3NlbGVjdGVkRWxlbWVudC5wbGFjZWRDb250ZW50LmltYWdlVHlwZU5hbWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+UFBJOjwvc3Ryb25nPntcIiBcIn1cclxuICAgICAgICAgICAgICAgICAgICAgIHtzZWxlY3RlZEVsZW1lbnQucGxhY2VkQ29udGVudC5hY3R1YWxQcGl9IOKGkntcIiBcIn1cclxuICAgICAgICAgICAgICAgICAgICAgIHtzZWxlY3RlZEVsZW1lbnQucGxhY2VkQ29udGVudC5lZmZlY3RpdmVQcGl9XHJcbiAgICAgICAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+U2NhbGU6PC9zdHJvbmc+e1wiIFwifVxyXG4gICAgICAgICAgICAgICAgICAgICAge01hdGgucm91bmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZWxlY3RlZEVsZW1lbnQucGxhY2VkQ29udGVudC50cmFuc2Zvcm0/LmEgfHwgMSkgKiAxMDBcclxuICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAlIMOXe1wiIFwifVxyXG4gICAgICAgICAgICAgICAgICAgICAge01hdGgucm91bmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZWxlY3RlZEVsZW1lbnQucGxhY2VkQ29udGVudC50cmFuc2Zvcm0/LmQgfHwgMSkgKiAxMDBcclxuICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAlXHJcbiAgICAgICAgICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgIHtzZWxlY3RlZEVsZW1lbnQucGFyZW50U3RvcnkgJiZcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5zdG9yaWVzW3NlbGVjdGVkRWxlbWVudC5wYXJlbnRTdG9yeV0gJiYgKFxyXG4gICAgICAgICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+8J+TnSBUZXh0IFN0b3J5Ojwvc3Ryb25nPlxyXG4gICAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+Rm9udDo8L3N0cm9uZz57XCIgXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnN0b3JpZXNbc2VsZWN0ZWRFbGVtZW50LnBhcmVudFN0b3J5XS5zdHlsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8uZm9udEZhbWlseVxyXG4gICAgICAgICAgICAgICAgICAgIH17XCIgXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnN0b3JpZXNbc2VsZWN0ZWRFbGVtZW50LnBhcmVudFN0b3J5XS5zdHlsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8uZm9udFN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+U2l6ZTo8L3N0cm9uZz57XCIgXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLnN0b3JpZXNbc2VsZWN0ZWRFbGVtZW50LnBhcmVudFN0b3J5XS5zdHlsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8uZm9udFNpemVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHhcclxuICAgICAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPldvcmRzOjwvc3Ryb25nPntcIiBcIn1cclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudERhdGEuc3Rvcmllc1tzZWxlY3RlZEVsZW1lbnQucGFyZW50U3RvcnldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC53b3JkQ291bnRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICB7c2VsZWN0ZWRFbGVtZW50LmxpbmtlZEltYWdlPy5pc0VtYmVkZGVkICYmIChcclxuICAgICAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICA8c3Ryb25nPvCfk44gRW1iZWRkZWQgSW1hZ2U6PC9zdHJvbmc+XHJcbiAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICA8c3Ryb25nPlR5cGU6PC9zdHJvbmc+e1wiIFwifVxyXG4gICAgICAgICAgICAgICAgICB7c2VsZWN0ZWRFbGVtZW50LmxpbmtlZEltYWdlLmVtYmVkZGVkVHlwZX1cclxuICAgICAgICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgICAgICAgIDxzdHJvbmc+RGF0YTo8L3N0cm9uZz57XCIgXCJ9XHJcbiAgICAgICAgICAgICAgICAgIHtzZWxlY3RlZEVsZW1lbnQubGlua2VkSW1hZ2UuZW1iZWRkZWREYXRhfVxyXG4gICAgICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICB7c2VsZWN0ZWRFbGVtZW50LmxpbmtlZEltYWdlPy5pc1BsYWNlaG9sZGVyICYmIChcclxuICAgICAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICA8c3Ryb25nPvCfk4sgSW1hZ2UgUGxhY2Vob2xkZXI8L3N0cm9uZz5cclxuICAgICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgKX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJvdXRlciIsIlJlYWN0IiwiQ29sb3JVdGlscyIsIkluRGVzaWduVGV4dE1ldHJpY3MiLCJWaWV3ZXIiLCJyb3V0ZXIiLCJ1cGxvYWRJZCIsInF1ZXJ5IiwiZG9jdW1lbnREYXRhIiwic2V0RG9jdW1lbnREYXRhIiwibG9hZGluZyIsInNldExvYWRpbmciLCJzZWxlY3RlZEVsZW1lbnQiLCJzZXRTZWxlY3RlZEVsZW1lbnQiLCJzaG93TWFyZ2lucyIsInNldFNob3dNYXJnaW5zIiwic2hvd0RlYnVnSW5mbyIsInNldFNob3dEZWJ1Z0luZm8iLCJiYWNrZ3JvdW5kQ29uZmlnIiwic2V0QmFja2dyb3VuZENvbmZpZyIsIm1vZGUiLCJjdXN0b21Db2xvciIsImFsbG93Q29sb3JBbmFseXNpcyIsInByZWZlclBhcGVyQ29sb3IiLCJmYWxsYmFja1RvV2hpdGUiLCJiYWNrZ3JvdW5kTW9kZXMiLCJ2YWx1ZSIsImxhYmVsIiwibW1Ub1B4IiwibW0iLCJsb2FkRG9jdW1lbnQiLCJyZXNwb25zZSIsImZldGNoIiwiZGF0YSIsImpzb24iLCJjb25zb2xlIiwibG9nIiwiZWxlbWVudHMiLCJsZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImVsZW1lbnQiLCJpbmRleCIsImlkIiwibmFtZSIsInR5cGUiLCJwb3NpdGlvbiIsInBpeGVsUG9zaXRpb24iLCJ5IiwiZmluYWxQb3NpdGlvbiIsIngiLCJ3aWR0aCIsImhlaWdodCIsImVycm9yIiwiY29udmVydENvbG9yIiwiY29sb3JSZWYiLCJyZXNvdXJjZXMiLCJjb2xvcnMiLCJjb252ZXJ0SWRtbENvbG9yVG9SZ2IiLCJnZXREb2N1bWVudEJhY2tncm91bmRDb2xvciIsImNvbmZpZyIsInBhZ2VXaWR0aCIsInBhZ2VJbmZvIiwiZGltZW5zaW9ucyIsInBpeGVsRGltZW5zaW9ucyIsInBhZ2VIZWlnaHQiLCJmdWxsUGFnZVJlY3RzIiwiZmlsdGVyIiwiZWwiLCJmaWxsIiwiYmdSZWN0IiwicmVkdWNlIiwiYSIsImIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJkb2N1bWVudCIsInNwcmVhZHMiLCJzcHJlYWRJZCIsInNwcmVhZCIsImVudHJpZXMiLCJjb2xvcktleXMiLCJiYWNrZ3JvdW5kQ2FuZGlkYXRlcyIsImNvbG9yS2V5IiwiYW5hbHlzaXMiLCJhbmFseXplSWRtbENvbG9yRm9yQmFja2dyb3VuZCIsImlzTGlnaHRCYWNrZ3JvdW5kIiwicmVhc29uaW5nIiwiY2F0ZWdvcnkiLCJwdXNoIiwic29ydGVkQ2FuZGlkYXRlcyIsInNvcnRDb2xvcnNCeUxpZ2h0bmVzcyIsImJlc3RDYW5kaWRhdGUiLCJyZWN0YW5nbGVzIiwiaGFzQW55QWN0dWFsRmlsbCIsInJlY3QiLCJmdWxsUGFnZUVsZW1lbnRzIiwiYmFja2dyb3VuZEVsZW1lbnQiLCJsYXJnZXN0IiwiY3VycmVudCIsImxhcmdlc3RBcmVhIiwiY3VycmVudEFyZWEiLCJsYXJnZUNvbG9yZWRFbGVtZW50cyIsImFyZWEiLCJwYWdlQXJlYSIsInNvcnQiLCJhcmVhQSIsImFyZWFCIiwicGFwZXJDb2xvciIsImZpbmQiLCJrZXkiLCJjb2xvciIsImJhY2tncm91bmRDb2xvck5hbWVzIiwiY29sb3JOYW1lIiwiZm91bmRDb2xvciIsInNvbWUiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwicGFnZXMiLCJwYWdlIiwibWFzdGVyU3ByZWFkcyIsIm1hc3RlcklkIiwibWFzdGVyIiwidXNlZEZpbGxDb2xvcnMiLCJTZXQiLCJhZGQiLCJBcnJheSIsImZyb20iLCJzaXplIiwiZmlsbENvbG9yQW5hbHlzaXMiLCJtYXAiLCJjbXlrTWF0Y2giLCJtYXRjaCIsImMiLCJtIiwiayIsInZhbCIsInBhcnNlRmxvYXQiLCJjb2xvcmZ1bG5lc3MiLCJkYXJrbmVzcyIsImxpZ2h0bmVzcyIsImJhY2tncm91bmRTY29yZSIsInRvdGFsQXJlYSIsImNvdmVyYWdlUmF0aW8iLCJ0b0ZpeGVkIiwiY215ayIsIkJvb2xlYW4iLCJiZXN0QmFja2dyb3VuZENvbG9yIiwiZ2V0Rm9udFdlaWdodCIsImZvbnRTdHlsZSIsInN0eWxlIiwiZ2V0Rm9udFN0eWxlIiwidHJpbSIsIndpbGxCZUl0YWxpYyIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsImlucHV0IiwiaW5wdXRUeXBlIiwibm9ybWFsaXplZElucHV0IiwicmVhc29uIiwiZXh0cmFjdFRleHREZWNvcmF0aW9ucyIsImZvcm1hdHRpbmciLCJkZWNvcmF0aW9ucyIsInVuZGVybGluZSIsImNoYXJhY3RlclN0eWxlIiwic3RyaWtldGhyb3VnaCIsInN0cmlrZVRocm91Z2giLCJvdmVybGluZSIsImpvaW4iLCJnZXRUZXh0QWxpZ24iLCJhbGlnbm1lbnQiLCJhbGlnbm1lbnRzIiwiTGVmdEFsaWduIiwiUmlnaHRBbGlnbiIsIkNlbnRlckFsaWduIiwiTGVmdEp1c3RpZmllZCIsIlJpZ2h0SnVzdGlmaWVkIiwiQ2VudGVySnVzdGlmaWVkIiwiRnVsbHlKdXN0aWZpZWQiLCJtZWFzdXJlVGV4dEFjY3VyYXRlbHkiLCJ0ZXh0IiwiZm9udFNpemUiLCJmb250RmFtaWx5IiwiZm9udFdlaWdodCIsImNhbnZhcyIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZm9udCIsIm1ldHJpY3MiLCJtZWFzdXJlVGV4dCIsImFjdHVhbEJvdW5kcyIsImFjdHVhbEJvdW5kaW5nQm94QXNjZW50IiwiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwiY2FsY3VsYXRlVGV4dE1ldHJpY3MiLCJsaW5lSGVpZ2h0IiwiY29udGFpbmVyV2lkdGgiLCJjb250YWluZXJIZWlnaHQiLCJ3aWxsT3ZlcmZsb3ciLCJlc3RpbWF0ZWRMaW5lcyIsImVzdGltYXRlZFRleHRIZWlnaHQiLCJjYW52YXNNZXRyaWNzIiwibGluZUhlaWdodFB4IiwibnVtZXJpY0xpbmVIZWlnaHQiLCJlZmZlY3RpdmVXaWR0aCIsIndvcmRzIiwic3BsaXQiLCJ3b3JkIiwibGluZXMiLCJjdXJyZW50TGluZSIsImN1cnJlbnRMaW5lV2lkdGgiLCJpIiwid29yZFdpZHRoIiwic3BhY2VXaWR0aCIsIndvcmRXaXRoU3BhY2VXaWR0aCIsIk1hdGgiLCJtYXgiLCJhdmFpbGFibGVIZWlnaHQiLCJhY3R1YWxMaW5lcyIsIm92ZXJmaWxsUmF0aW8iLCJvdmVyZmxvd1NldmVyaXR5IiwiVEVYVF9GSVRUSU5HX1NUUkFURUdJRVMiLCJBVVRPX1NDQUxFIiwiVFJVTkNBVEUiLCJBTExPV19PVkVSRkxPVyIsIlBSRUNJU0VfRklUIiwiQ09NUFJFU1NfTElORVMiLCJ0ZXh0Rml0dGluZ1N0cmF0ZWd5Iiwic2V0VGV4dEZpdHRpbmdTdHJhdGVneSIsImdldE9wdGltYWxUZXh0U3R5bGVzIiwiYmFzZVN0eWxlcyIsInRleHRNZXRyaWNzIiwic3RyYXRlZ3kiLCJzdHlsZXMiLCJ3YXNBZGp1c3RlZCIsImFkanVzdG1lbnREZXRhaWxzIiwibWF4UmVkdWN0aW9uIiwic2NhbGVGYWN0b3IiLCJvdmVyZmxvdyIsIm9yaWdpbmFsU2l6ZSIsIm5ld1NpemUiLCJhdmFpbGFibGVMaW5lcyIsImZsb29yIiwidHJ1bmNhdGVBdExpbmUiLCJ0ZXh0T3ZlcmZsb3ciLCJkaXNwbGF5IiwiV2Via2l0TGluZUNsYW1wIiwiV2Via2l0Qm94T3JpZW50IiwidmlzaWJsZUxpbmVzIiwidG90YWxMaW5lcyIsInRhcmdldEhlaWdodCIsImN1cnJlbnRIZWlnaHQiLCJjb21wcmVzc2lvblJhdGlvIiwib3JpZ2luYWxMaW5lSGVpZ2h0IiwibmV3TGluZUhlaWdodCIsImZvbnRSZWR1Y3Rpb24iLCJsaW5lSGVpZ2h0UmVkdWN0aW9uIiwiY29tcHJlc3Npb25OZWVkZWQiLCJmb250U2NhbGUiLCJzcXJ0IiwibGluZVNjYWxlIiwibWF4Rm9udFNjYWxlIiwibWF4TGluZVNjYWxlIiwibWF4SGVpZ2h0IiwiYWxsb3dlZE92ZXJmbG93IiwicmVuZGVyRm9ybWF0dGVkVGV4dCIsInN0b3J5IiwiYWRqdXN0ZWRGb250U2l6ZSIsImZvcm1hdHRlZENvbnRlbnQiLCJpc0FycmF5Iiwic3BhbiIsIndoaXRlU3BhY2UiLCJsaW5lQnJlYWtDb3VudCIsIml0ZW0iLCJpc0JyZWFrIiwiY29uc2VjdXRpdmVCcmVha3MiLCJjdXJyZW50QnJlYWtHcm91cCIsInNvdXJjZSIsImJyZWFrVHlwZSIsImNvbnRlbnQiLCJiciIsIm9yaWdpbmFsRm9udFNpemUiLCJzdHlsaW5nIiwiaGFzRm9ybWF0dGluZyIsInBhcmFncmFwaFN0eWxlIiwiZmluYWxGb250U3R5bGUiLCJKU09OIiwic3RyaW5naWZ5Iiwic3Vic3RyaW5nIiwicmF3Rm9ybWF0dGluZyIsInJlc29sdmVkRm9udFN0eWxlIiwic3RvcnlEZWZhdWx0U3R5bGUiLCJ3YXJuIiwiZWZmZWN0aXZlTGluZUhlaWdodCIsImxlYWRpbmciLCJ1bmRlZmluZWQiLCJyYXRpbyIsIm1pbiIsImNvbXBsZXRlU3R5bGVzIiwiZmlsbENvbG9yIiwidGV4dEFsaWduIiwibGV0dGVyU3BhY2luZyIsInRyYWNraW5nIiwidGV4dERlY29yYXRpb24iLCJ0ZXh0VHJhbnNmb3JtIiwidGV4dFNoYWRvdyIsIm1hcmdpbiIsInBhZGRpbmciLCJsZWZ0SW5kZW50IiwibWFyZ2luTGVmdCIsInJpZ2h0SW5kZW50IiwibWFyZ2luUmlnaHQiLCJmaXJzdExpbmVJbmRlbnQiLCJ0ZXh0SW5kZW50Iiwic3BhY2VCZWZvcmUiLCJtYXJnaW5Ub3AiLCJzcGFjZUFmdGVyIiwibWFyZ2luQm90dG9tIiwiYmFzZWxpbmVTaGlmdCIsInZlcnRpY2FsQWxpZ24iLCJob3Jpem9udGFsU2NhbGUiLCJ0cmFuc2Zvcm0iLCJjdXJyZW50VGV4dCIsIm5leHRDb250ZW50IiwibmVlZHNTcGFjZUFmdGVyIiwibmV4dFRleHQiLCJjdXJyZW50RW5kc1dpdGhTcGFjZSIsIm5leHRTdGFydHNXaXRoU3BhY2UiLCJGcmFnbWVudCIsImdldFN0b3J5U3R5bGVzIiwidG9TdHJpbmciLCJtaW5IZWlnaHQiLCJ3b3JkV3JhcCIsImJveFNpemluZyIsIndvcmRCcmVhayIsIm92ZXJmbG93V3JhcCIsImxpbmVDbGFtcCIsImdldEluRGVzaWduQWNjdXJhdGVGb3JtYXR0aW5nIiwiZmlyc3RGb3JtYXR0ZWQiLCJsZWFkaW5nVHlwZSIsImZpcnN0QmFzZWxpbmVPZmZzZXQiLCJ2ZXJ0aWNhbEp1c3RpZmljYXRpb24iLCJkaXYiLCJvdmVyZmxvd1kiLCJib3JkZXJSYWRpdXMiLCJib3JkZXIiLCJoNCIsInNlbGVjdCIsIm9uQ2hhbmdlIiwiZSIsInRhcmdldCIsIm9wdGlvbiIsImFsaWduSXRlbXMiLCJjaGVja2VkIiwic3Ryb25nIiwiZmxleERpcmVjdGlvbiIsImdhcCIsImZsZXhXcmFwIiwiaDMiLCJwIiwidmVyc2lvbiIsInBhZ2VDb3VudCIsInJvdW5kIiwidW5pdHMiLCJ1bml0Q29udmVyc2lvbiIsImVuYWJsZWQiLCJkcGkiLCJvcmlnaW5hbFVuaXRzIiwiY29udmVydGVkVG9QaXhlbHMiLCJtYXJnaW5zIiwicGl4ZWxNYXJnaW5zIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwicGFja2FnZUluZm8iLCJsaW5rc0NvdW50IiwiaGFzTGlua3MiLCJmb250c0NvdW50IiwiaGFzRm9udHMiLCJvbkNsaWNrIiwiY3Vyc29yIiwiaXNDb250ZW50RnJhbWUiLCJwbGFjZWRDb250ZW50IiwiaW1hZ2VUeXBlTmFtZSIsImFjdHVhbFBwaSIsImVmZmVjdGl2ZVBwaSIsInBhcmVudFN0b3J5Iiwic3RvcmllcyIsInN0b3J5SWQiLCJ3b3JkQ291bnQiLCJjaGFyYWN0ZXJDb3VudCIsImZsZXgiLCJqdXN0aWZ5Q29udGVudCIsImJnQ29sb3IiLCJib3hTaGFkb3ciLCJ2aXN1YWxNYXJnaW5Ub3AiLCJ2aXN1YWxNYXJnaW5MZWZ0IiwidmlzdWFsTWFyZ2luUmlnaHQiLCJ2aXN1YWxNYXJnaW5Cb3R0b20iLCJwb2ludGVyRXZlbnRzIiwiekluZGV4IiwiZWxlbWVudFBvc2l0aW9uIiwiaGFzUGxhY2VkQ29udGVudCIsIl9jb252ZXJzaW9uSW5mbyIsInJvdGF0aW9uIiwidHJhbnNmb3JtT3JpZ2luIiwidGl0bGUiLCJiYWNrZ3JvdW5kIiwibGlua2VkSW1hZ2UiLCJ1cmwiLCJpbWciLCJzcmMiLCJhbHQiLCJvYmplY3RGaXQiLCJvbkVycm9yIiwiaXNFbWJlZGRlZCIsImZyYW1lTWV0cmljcyIsImNhbGN1bGF0ZVRleHRGcmFtZUluc2V0cyIsInRleHRGcmFtZVByZWZlcmVuY2VzIiwic3RvcnlGb3JtYXR0aW5nIiwiY2xlYW5UZXh0IiwicmVwbGFjZSIsInRleHRNZWFzdXJlbWVudCIsIm1lYXN1cmVUZXh0UHJlY2lzZWx5IiwiZmluYWxTdHlsZXMiLCJ0ZXh0SGVpZ2h0Iiwib3ZlcmZsb3dBbW91bnQiLCJsaW5lQ291bnQiLCJhZGp1c3RtZW50IiwiY2FsY3VsYXRlT3B0aW1hbEZvbnRTaXplIiwiYWRqdXN0ZWRTdHlsZXMiLCJuZXdGb250U2l6ZSIsImNyZWF0ZVRvb2x0aXAiLCJiYXNlSW5mbyIsImNvbnRlbnRBcmVhIiwiYWRqdXN0bWVudFR5cGUiLCJpbnNldHMiLCJzdGlsbE92ZXJmbG93cyIsIm1heFdpZHRoIiwiZCIsImVtYmVkZGVkVHlwZSIsImVtYmVkZGVkRGF0YSIsImlzUGxhY2Vob2xkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/view/[uploadId].js\n");

/***/ }),

/***/ "fast-xml-parser":
/*!**********************************!*\
  !*** external "fast-xml-parser" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("fast-xml-parser");

/***/ }),

/***/ "next/dist/compiled/next-server/pages.runtime.dev.js":
/*!**********************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages.runtime.dev.js" ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages.runtime.dev.js");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("react-dom");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "yauzl":
/*!************************!*\
  !*** external "yauzl" ***!
  \************************/
/***/ ((module) => {

module.exports = require("yauzl");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@swc"], () => (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2Fview%2F%5BuploadId%5D&preferredRegion=&absolutePagePath=.%2Fpages%5Cview%5C%5BuploadId%5D.js&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();